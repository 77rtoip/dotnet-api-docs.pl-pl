<Type Name="EditingCommands" FullName="System.Windows.Documents.EditingCommands">
  <Metadata><Meta Name="ms.openlocfilehash" Value="42f8c0d175aa546d564a5d631302619e015aea19" /><Meta Name="ms.sourcegitcommit" Value="f1d16425528e237257ca3b58eb49217a514849ea" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="04/24/2019" /><Meta Name="ms.locfileid" Value="64275546" /></Metadata><TypeSignature Language="C#" Value="public static class EditingCommands" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit EditingCommands extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Documents.EditingCommands" />
  <TypeSignature Language="VB.NET" Value="Public Class EditingCommands" />
  <TypeSignature Language="C++ CLI" Value="public ref class EditingCommands abstract sealed" />
  <TypeSignature Language="F#" Value="type EditingCommands = class" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Zawiera standardowy zestaw powiązanych polecenia edycji.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono polecenia edycji i powiązaną domyślną klawiszy (z nazwami kluczy z <xref:System.Windows.Input.Key> i <xref:System.Windows.Input.ModifierKeys> wyliczenia).  
  
|Edytowanie polecenia|Domyślne gestu klucza|  
|---------------------|-------------------------|  
|<xref:System.Windows.Documents.EditingCommands.AlignCenter%2A>|`Ctrl`+`E`|  
|<xref:System.Windows.Documents.EditingCommands.AlignJustify%2A>|`Ctrl`+`J`|  
|<xref:System.Windows.Documents.EditingCommands.AlignLeft%2A>|`Ctrl`+`L`|  
|<xref:System.Windows.Documents.EditingCommands.AlignRight%2A>|`Ctrl`+`R`|  
|<xref:System.Windows.Documents.EditingCommands.Backspace%2A>|`Backspace`|  
|<xref:System.Windows.Documents.EditingCommands.CorrectSpellingError%2A>|nie gestu kluczy domyślne|  
|<xref:System.Windows.Documents.EditingCommands.DecreaseFontSize%2A>|`Ctrl`+`OemOpenBrackets`|  
|<xref:System.Windows.Documents.EditingCommands.DecreaseIndentation%2A>|`Ctrl`+`Shift`+`T`|  
|<xref:System.Windows.Documents.EditingCommands.Delete%2A>|`Delete`|  
|<xref:System.Windows.Documents.EditingCommands.DeleteNextWord%2A>|`Ctrl`+`Delete`|  
|<xref:System.Windows.Documents.EditingCommands.DeletePreviousWord%2A>|`Ctrl`+`Backspace`|  
|<xref:System.Windows.Documents.EditingCommands.EnterLineBreak%2A>|`Shift`+`Enter`|  
|<xref:System.Windows.Documents.EditingCommands.EnterParagraphBreak%2A>|`Enter`|  
|<xref:System.Windows.Documents.EditingCommands.IgnoreSpellingError%2A>|nie gestu kluczy domyślne|  
|<xref:System.Windows.Documents.EditingCommands.IncreaseFontSize%2A>|`Ctrl`+`OemCloseBrackets`|  
|<xref:System.Windows.Documents.EditingCommands.IncreaseIndentation%2A>|`Ctrl`+`T`|  
|<xref:System.Windows.Documents.EditingCommands.MoveDownByLine%2A>|`Down`|  
|<xref:System.Windows.Documents.EditingCommands.MoveDownByPage%2A>|`PageDown`|  
|<xref:System.Windows.Documents.EditingCommands.MoveDownByParagraph%2A>|`Ctrl`+`Down`|  
|<xref:System.Windows.Documents.EditingCommands.MoveLeftByCharacter%2A>|`Left`|  
|<xref:System.Windows.Documents.EditingCommands.MoveLeftByWord%2A>|`Ctrl`+`Left`|  
|<xref:System.Windows.Documents.EditingCommands.MoveRightByCharacter%2A>|`Right`|  
|<xref:System.Windows.Documents.EditingCommands.MoveRightByWord%2A>|`Ctrl`+`Right`|  
|<xref:System.Windows.Documents.EditingCommands.MoveToDocumentEnd%2A>|`Ctrl`+`End`|  
|<xref:System.Windows.Documents.EditingCommands.MoveToDocumentStart%2A>|`Ctrl`+`Home`|  
|<xref:System.Windows.Documents.EditingCommands.MoveToLineEnd%2A>|`End`|  
|<xref:System.Windows.Documents.EditingCommands.MoveToLineStart%2A>|`Home`|  
|<xref:System.Windows.Documents.EditingCommands.MoveUpByLine%2A>|`Up`|  
|<xref:System.Windows.Documents.EditingCommands.MoveUpByPage%2A>|`PageUp`|  
|<xref:System.Windows.Documents.EditingCommands.MoveUpByParagraph%2A>|`Ctrl`+`Up`|  
|<xref:System.Windows.Documents.EditingCommands.SelectDownByLine%2A>|`Shift`+`Down`|  
|<xref:System.Windows.Documents.EditingCommands.SelectDownByPage%2A>|`Shift`+`PageDown`|  
|<xref:System.Windows.Documents.EditingCommands.SelectDownByParagraph%2A>|`Ctrl`+`Shift`+`Down`|  
|<xref:System.Windows.Documents.EditingCommands.SelectLeftByCharacter%2A>|`Shift`+`Left`|  
|<xref:System.Windows.Documents.EditingCommands.SelectLeftByWord%2A>|`Ctrl`+`Shift`+`Left`|  
|<xref:System.Windows.Documents.EditingCommands.SelectRightByCharacter%2A>|`Shift`+`Right`|  
|<xref:System.Windows.Documents.EditingCommands.SelectRightByWord%2A>|`Ctrl`+`Shift`+`Right`|  
|<xref:System.Windows.Documents.EditingCommands.SelectToDocumentEnd%2A>|`Ctrl`+`Shift`+`End`|  
|<xref:System.Windows.Documents.EditingCommands.SelectToDocumentStart%2A>|`Ctrl`+`Shift`+`Home`|  
|<xref:System.Windows.Documents.EditingCommands.SelectToLineEnd%2A>|`Shift`+`End`|  
|<xref:System.Windows.Documents.EditingCommands.SelectToLineStart%2A>|`Shift`+`Home`|  
|<xref:System.Windows.Documents.EditingCommands.SelectUpByLine%2A>|`Shift`+`Up`|  
|<xref:System.Windows.Documents.EditingCommands.SelectUpByPage%2A>|`Shift`+`PageUp`|  
|<xref:System.Windows.Documents.EditingCommands.SelectUpByParagraph%2A>|`Ctrl`+`Shift`+`Up`|  
|<xref:System.Windows.Documents.EditingCommands.TabBackward%2A>|`Shift`+`Tab`|  
|<xref:System.Windows.Documents.EditingCommands.TabForward%2A>|`Tab`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleBold%2A>|`Ctrl`+`B`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleBullets%2A>|`Ctrl`+`Shift`+`L`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleInsert%2A>|`Insert`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleItalic%2A>|`Ctrl`+`I`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleNumbering%2A>|`Ctrl`+`Shift`+`N`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleSubscript%2A>|`Ctrl`+`OemPlus`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleSuperscript%2A>|`Ctrl`+`Shift+OemPlus`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleUnderline%2A>|`Ctrl`+`U`|  
  
 Polecenia przenoszenia karetki i wybór, rozwijając polecenia korzystają ze wspólnego zestawu domyślnego klucza gestów, ogólne różnica jest dodanie <xref:System.Windows.Input.ModifierKeys.Shift> klawisz, aby odróżnić polecenia zaznaczania od karetki przenoszenia poleceń.  Na przykład <xref:System.Windows.Documents.EditingCommands.MoveLeftByCharacter%2A> polecenie ma domyślne gest klucza z <xref:System.Windows.Input.Key.Left>i odpowiedni <xref:System.Windows.Documents.EditingCommands.SelectLeftByCharacter%2A> polecenie ma domyślne gest klucza z <xref:System.Windows.Input.ModifierKeys.Shift> + <xref:System.Windows.Input.Key.Left>.  
  
 Ogólnie rzecz biorąc, definicje polecenia dostarczone przez <xref:System.Windows.Documents.EditingCommands> klasy nie należy wprowadzać korzystanie z parametrów polecenia ( `parameter` parametr oczekiwany przez <xref:System.Windows.Input.ICommand.Execute%2A> metody).  
  
 Aby uzyskać więcej informacji na temat poleceń i polecenia, zobacz [przegląd danych wejściowych](~/docs/framework/wpf/advanced/input-overview.md).  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 W tym przykładzie <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (odziedziczone <xref:System.Windows.FrameworkElement>), i że zawiera on natywną obsługę wielu polecenia edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodą jest parametr polecenia.  Polecenia najbardziej edycji Ignoruj parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinna zawierać procedury obsługi dla określonego polecenia.  Ogólnie rzecz biorąc polecenia jest ignorowana, gdy wywoływane na obiekt, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Input.MediaCommands" />
    <altmember cref="T:System.Windows.Input.ApplicationCommands" />
    <altmember cref="T:System.Windows.Input.ComponentCommands" />
    <altmember cref="T:System.Windows.Input.RoutedCommand" />
    <altmember cref="T:System.Windows.Input.RoutedUICommand" />
    <altmember cref="T:System.Windows.Input.CommandBinding" />
    <altmember cref="T:System.Windows.Input.CommandManager" />
    <altmember cref="T:System.Windows.Input.NavigationCommands" />
  </Docs>
  <Members>
    <Member MemberName="AlignCenter">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand AlignCenter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand AlignCenter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.AlignCenter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AlignCenter As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ AlignCenter { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AlignCenter : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.AlignCenter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.AlignCenter" /> polecenia, które żąda się, że wyśrodkowany bieżący akapit, lub zaznaczenie akapitów.</summary>
        <value>Żądane polecenie.  Gest kluczy domyślne dla tego polecenia jest <see langword="Ctrl" /> + <see langword="E" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To polecenie działa na <xref:System.Windows.Documents.Paragraph> poziom.  Jeśli to polecenie jest wywoływane na częściowy wybór zawartości w akapicie (w tym zaznaczenie jest puste, gdzie karetka znajduje się w obrębie akapitu), żądany efekt zastosowany do całego akapitu.  Jeśli to polecenie jest wywoływane na wybór, która obejmuje wiele akapitów, efekt jest stosowany do całej zawartości każdego akapitu, który uczestniczy w zaznaczeniu.  
  
 Poniższa ilustracja przedstawia przykład wyśrodkowany zawartości.  
  
 ![Zrzut ekranu: Wartość właściwości TextAlign Centrum](~/add/media/flowdoc-textalign-center.png "zrzut ekranu: Wartość właściwości TextAlign Centrum")  
  
 To polecenie jest obsługiwany natywnie <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_AlignCenter"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="AlignCenter"/>  
```  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 W tym przykładzie <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (odziedziczone <xref:System.Windows.FrameworkElement>), i że zawiera on natywną obsługę wielu polecenia edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodą jest parametr polecenia.  Polecenia najbardziej edycji Ignoruj parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinna zawierać procedury obsługi dla określonego polecenia.  Ogólnie rzecz biorąc polecenia jest ignorowana, gdy wywoływane na obiekt, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignJustify" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignLeft" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignRight" />
      </Docs>
    </Member>
    <Member MemberName="AlignJustify">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand AlignJustify { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand AlignJustify" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.AlignJustify" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AlignJustify As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ AlignJustify { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AlignJustify : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.AlignJustify" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.AlignJustify" /> polecenia, które żąda bieżący akapit, lub zaznaczenie akapitów być uzasadnione.</summary>
        <value>Żądane polecenie.  Gest kluczy domyślne dla tego polecenia jest <see langword="Ctrl" /> + <see langword="J" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To polecenie działa na <xref:System.Windows.Documents.Paragraph> poziom.  Jeśli to polecenie jest wywoływane na częściowy wybór zawartości w akapicie (w tym zaznaczenie jest puste, gdzie karetka znajduje się w obrębie akapitu), żądany efekt zastosowany do całego akapitu.  Jeśli to polecenie jest wywoływane na wybór, która obejmuje wiele akapitów, efekt jest stosowany do wszystkich akapitów w zaznaczeniu.  
  
 Gdy zawartość jest uzasadnione, odstępy w poziomie w każdym wierszu zawartości jest dostosowywana tak, aby uzasadnionych wiersze są równe lub prawie równe szerokości.  Zawartość zwykle jest uzasadnione, aby utworzyć płynne krawędzie na stronach zawartości.  
  
 Często jest krótszy niż pozostałe, ostatni wiersz w akapicie mogą pozostać nieuzasadnione po wywołaniu tego polecenia.  
  
 Na poniższej ilustracji przedstawiono nieuzasadnione zawartości (wyrównane do lewej).  
  
 ![Zrzut ekranu: Zawartość jest uzasadnione](~/add/media/content-unjustified.png "zrzut ekranu: Zawartość jest uzasadnione")  
  
 Na poniższej ilustracji przedstawiono tę samą zawartość, po została uzasadniona.  
  
 ![Zrzut ekranu przedstawiający zawartości uzasadniona tekstu](~/add/media/content-justified.png "zrzut ekranu przedstawiający zawartości uzasadniona tekstu")  
  
 Nie jest zawsze rzeczywistą implementację, który odpowiada na polecenie w dowolnego obiektu; w wielu przypadkach wdrożenia, który odpowiada na polecenie spoczywa składnika zapisywania aplikacji.  
  
 To polecenie jest obsługiwany natywnie <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_AlignJustify"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="AlignJustify"/>  
```  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 W tym przykładzie <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (odziedziczone <xref:System.Windows.FrameworkElement>), i że zawiera on natywną obsługę wielu polecenia edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodą jest parametr polecenia.  Polecenia najbardziej edycji Ignoruj parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinna zawierać procedury obsługi dla określonego polecenia.  Ogólnie rzecz biorąc polecenia jest ignorowana, gdy wywoływane na obiekt, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignCenter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignLeft" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignRight" />
      </Docs>
    </Member>
    <Member MemberName="AlignLeft">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand AlignLeft { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand AlignLeft" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.AlignLeft" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AlignLeft As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ AlignLeft { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AlignLeft : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.AlignLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.AlignLeft" /> polecenia, które żąda się, że zaznaczenia zawartości być wyrównany do lewej.</summary>
        <value>Żądane polecenie.  Gest kluczy domyślne dla tego polecenia jest <see langword="Ctrl" /> + <see langword="L" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To polecenie działa na <xref:System.Windows.Documents.Paragraph> poziom.  Jeśli to polecenie jest wywoływane na częściowy wybór zawartości w akapicie (w tym zaznaczenie jest puste, gdzie karetka znajduje się w obrębie akapitu), żądany efekt zastosowany do całego akapitu.  Jeśli to polecenie jest wywoływane na wybór, która obejmuje wiele akapitów, efekt jest stosowany do całej zawartości każdego akapitu, który uczestniczy w zaznaczeniu.  
  
 Poniższa ilustracja przedstawia przykład zawartości wyrównane do lewej.  
  
 ![Zrzut ekranu: Wartość właściwości TextAlign po lewej stronie](~/add/media/flowdoc-textalign-left.png "zrzut ekranu: Wartość właściwości TextAlign po lewej stronie")  
  
 Nie jest zawsze rzeczywistą implementację, który odpowiada na polecenie w dowolnego obiektu; w wielu przypadkach wdrożenia, który odpowiada na polecenie spoczywa składnika zapisywania aplikacji.  
  
 To polecenie jest obsługiwany natywnie <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_AlignLeft"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="AlignLeft"/>  
```  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 W tym przykładzie <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (odziedziczone <xref:System.Windows.FrameworkElement>), i że zawiera on natywną obsługę wielu polecenia edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodą jest parametr polecenia.  Polecenia najbardziej edycji Ignoruj parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinna zawierać procedury obsługi dla określonego polecenia.  Ogólnie rzecz biorąc polecenia jest ignorowana, gdy wywoływane na obiekt, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignCenter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignJustify" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignRight" />
      </Docs>
    </Member>
    <Member MemberName="AlignRight">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand AlignRight { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand AlignRight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.AlignRight" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AlignRight As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ AlignRight { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AlignRight : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.AlignRight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.AlignRight" /> polecenia, które żąda zaznaczenia zawartości być wyrównane do prawej strony.</summary>
        <value>Żądane polecenie.  Gest kluczy domyślne dla tego polecenia jest <see langword="Ctrl" /> + <see langword="R" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To polecenie działa na <xref:System.Windows.Documents.Paragraph> poziom.  Jeśli to polecenie jest wywoływane na częściowy wybór zawartości w akapicie (w tym zaznaczenie jest puste, gdzie karetka znajduje się w obrębie akapitu), żądany efekt zastosowany do całego akapitu.  Jeśli to polecenie jest wywoływane na wybór, która obejmuje wiele akapitów, efekt jest stosowany do całej zawartości każdego akapitu, który uczestniczy w zaznaczeniu.  
  
 Poniższa ilustracja przedstawia przykład zawartości wyrównany do prawej.  
  
 ![Zrzut ekranu: TextAlign wartości po prawej stronie](~/add/media/flowdoc-textalign-right.png "zrzut ekranu: TextAlign wartości po prawej stronie")  
  
 Nie jest zawsze rzeczywistą implementację, który odpowiada na polecenie w dowolnego obiektu; w wielu przypadkach wdrożenia, który odpowiada na polecenie spoczywa składnika zapisywania aplikacji.  
  
 To polecenie jest obsługiwany natywnie <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_AlignRight"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="AlignRight"/>  
```  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 W tym przykładzie <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (odziedziczone <xref:System.Windows.FrameworkElement>), i że zawiera on natywną obsługę wielu polecenia edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodą jest parametr polecenia.  Polecenia najbardziej edycji Ignoruj parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinna zawierać procedury obsługi dla określonego polecenia.  Ogólnie rzecz biorąc polecenia jest ignorowana, gdy wywoływane na obiekt, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignCenter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignJustify" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignRight" />
      </Docs>
    </Member>
    <Member MemberName="Backspace">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand Backspace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand Backspace" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.Backspace" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Backspace As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ Backspace { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Backspace : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.Backspace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.Backspace" /> polecenia, które żąda wprowadzenia backspace w bieżącym położeniu lub za pośrednictwem bieżącego zaznaczenia.</summary>
        <value>Żądane polecenie.  Gest kluczy domyślne dla tego polecenia jest <see langword="Backspace" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po wywołaniu na zaznaczenie jest puste, to polecenie usuwa separator znaków lub po prostu przed karetką. Gdy wywoływana przy zaznaczeniem niepuste, to polecenie usuwa zaznaczenie.  
  
 To polecenie zachowuje formatowanie usunięto zaznaczenie zawartości od razu wstawione w tej samej lokalizacji, po wywołaniu tego polecenia.  Porównaj z <xref:System.Windows.Documents.EditingCommands.Delete%2A> polecenia, które nie zachowuje poprzednie formatowanie.  
  
 Nie jest zawsze rzeczywistą implementację, który odpowiada na polecenie w dowolnego obiektu; w wielu przypadkach wdrożenia, który odpowiada na polecenie spoczywa składnika zapisywania aplikacji.  
  
 To polecenie jest obsługiwany natywnie <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_Backspace"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="Backspace"/>  
```  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 W tym przykładzie <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (odziedziczone <xref:System.Windows.FrameworkElement>), i że zawiera on natywną obsługę wielu polecenia edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodą jest parametr polecenia.  Polecenia najbardziej edycji Ignoruj parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinna zawierać procedury obsługi dla określonego polecenia.  Ogólnie rzecz biorąc polecenia jest ignorowana, gdy wywoływane na obiekt, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CorrectSpellingError">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand CorrectSpellingError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand CorrectSpellingError" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.CorrectSpellingError" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CorrectSpellingError As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ CorrectSpellingError { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CorrectSpellingError : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.CorrectSpellingError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.CorrectSpellingError" /> polecenia, które żądania poprawek wszelkie wyraz w bieżącym położeniu.</summary>
        <value>Żądane polecenie.  To polecenie ma gestu klucza nie domyślne.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest zawsze rzeczywistą implementację, który odpowiada na polecenie w dowolnego obiektu; w wielu przypadkach wdrożenia, który odpowiada na polecenie spoczywa składnika zapisywania aplikacji.  
  
<a name="xamlAttributeUsage_CorrectSpellingError"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="CorrectSpellingError"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.IgnoreSpellingError" />
      </Docs>
    </Member>
    <Member MemberName="DecreaseFontSize">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand DecreaseFontSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand DecreaseFontSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.DecreaseFontSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DecreaseFontSize As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ DecreaseFontSize { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DecreaseFontSize : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.DecreaseFontSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.DecreaseFontSize" /> polecenia, które żąda zmniejszyć rozmiar czcionki dla bieżącego zaznaczenia przez punkt 1.</summary>
        <value>Żądane polecenie.  Gest kluczy domyślne dla tego polecenia jest <see langword="Ctrl" /> + <see langword="OemOpenBrackets" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli to polecenie jest wywoływane na zaznaczenie jest puste, gdzie karetka znajduje się w programie word, wybór jest automatycznie rozszerzana dotyczą polecenia cały wyraz.  
  
 Nie jest zawsze rzeczywistą implementację, który odpowiada na polecenie w dowolnego obiektu; w wielu przypadkach wdrożenia, który odpowiada na polecenie spoczywa składnika zapisywania aplikacji.  
  
 To polecenie jest obsługiwany natywnie <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_DecreaseFontSize"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="DecreaseFontSize"/>  
```  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 W tym przykładzie <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (odziedziczone <xref:System.Windows.FrameworkElement>), i że zawiera on natywną obsługę wielu polecenia edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodą jest parametr polecenia.  Polecenia najbardziej edycji Ignoruj parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinna zawierać procedury obsługi dla określonego polecenia.  Ogólnie rzecz biorąc polecenia jest ignorowana, gdy wywoływane na obiekt, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.IncreaseFontSize" />
      </Docs>
    </Member>
    <Member MemberName="DecreaseIndentation">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand DecreaseIndentation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand DecreaseIndentation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.DecreaseIndentation" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DecreaseIndentation As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ DecreaseIndentation { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DecreaseIndentation : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.DecreaseIndentation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.DecreaseIndentation" /> polecenia, które żądań tego wcięcia, dla bieżący akapit, należy zmniejszyć o jedną pozycję tabulatora.</summary>
        <value>Żądane polecenie.  Gest kluczy domyślne dla tego polecenia jest <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="T" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest zawsze rzeczywistą implementację, który odpowiada na polecenie w dowolnego obiektu; w wielu przypadkach wdrożenia, który odpowiada na polecenie spoczywa składnika zapisywania aplikacji.  
  
 To polecenie jest obsługiwany natywnie <xref:System.Windows.Controls.RichTextBox>.  
  
> [!IMPORTANT]
>  To polecenie nie ma wpływu na element tekstowy chyba że <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsTab%2A> właściwość elementu tekstu jest ustawiona na `true`.  
  
<a name="xamlAttributeUsage_DecreaseIndentation"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="DecreaseIndentation"/>  
```  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 W tym przykładzie <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (odziedziczone <xref:System.Windows.FrameworkElement>), i że zawiera on natywną obsługę wielu polecenia edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodą jest parametr polecenia.  Polecenia najbardziej edycji Ignoruj parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinna zawierać procedury obsługi dla określonego polecenia.  Ogólnie rzecz biorąc polecenia jest ignorowana, gdy wywoływane na obiekt, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.IncreaseIndentation" />
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand Delete { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand Delete" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.Delete" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Delete As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ Delete { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Delete : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.Delete" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.Delete" /> polecenia, które żądania usunięcia bieżącego zaznaczenia.</summary>
        <value>Żądane polecenie.  Gest kluczy domyślne dla tego polecenia jest <see langword="Delete" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To polecenie odrzuca formatowanie usunięto zaznaczenie.  Porównaj z <xref:System.Windows.Documents.EditingCommands.Backspace%2A> polecenia, który zachowuje formatowanie usunięto zaznaczenie zawartości od razu wstawione w tej samej lokalizacji, po wywołaniu tego polecenia.  
  
 Nie jest zawsze rzeczywistą implementację, który odpowiada na polecenie w dowolnego obiektu; w wielu przypadkach wdrożenia, który odpowiada na polecenie spoczywa składnika zapisywania aplikacji.  
  
 To polecenie jest obsługiwany natywnie <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_Delete"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="Delete"/>  
```  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 W tym przykładzie <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (odziedziczone <xref:System.Windows.FrameworkElement>), i że zawiera on natywną obsługę wielu polecenia edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodą jest parametr polecenia.  Polecenia najbardziej edycji Ignoruj parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinna zawierać procedury obsługi dla określonego polecenia.  Ogólnie rzecz biorąc polecenia jest ignorowana, gdy wywoływane na obiekt, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeleteNextWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand DeleteNextWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand DeleteNextWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.DeleteNextWord" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DeleteNextWord As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ DeleteNextWord { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeleteNextWord : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.DeleteNextWord" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.DeleteNextWord" /> polecenia, które żądania usunięcia następnego wyrazu (względem bieżącej pozycji).</summary>
        <value>Żądane polecenie.  Gest kluczy domyślne dla tego polecenia jest <see langword="Ctrl" /> + <see langword="Delete" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku karetka znajduje się w programie word, zostaną usunięte w pozostałej części programu word między bieżącą pozycję i koniec wyrazu.  
  
 Nie jest zawsze rzeczywistą implementację, który odpowiada na polecenie w dowolnego obiektu; w wielu przypadkach wdrożenia, który odpowiada na polecenie spoczywa składnika zapisywania aplikacji.  
  
 To polecenie jest obsługiwany natywnie <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_DeleteNextWord"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="DeleteNextWord"/>  
```  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 W tym przykładzie <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (odziedziczone <xref:System.Windows.FrameworkElement>), i że zawiera on natywną obsługę wielu polecenia edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodą jest parametr polecenia.  Polecenia najbardziej edycji Ignoruj parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinna zawierać procedury obsługi dla określonego polecenia.  Ogólnie rzecz biorąc polecenia jest ignorowana, gdy wywoływane na obiekt, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.DeletePreviousWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
      </Docs>
    </Member>
    <Member MemberName="DeletePreviousWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand DeletePreviousWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand DeletePreviousWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.DeletePreviousWord" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DeletePreviousWord As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ DeletePreviousWord { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeletePreviousWord : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.DeletePreviousWord" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.DeletePreviousWord" /> polecenia, które żądania usunięcia poprzedniego wyrazu (względem bieżącej pozycji).</summary>
        <value>Żądane polecenie.  Gest kluczy domyślne dla tego polecenia jest <see langword="Ctrl" /> + <see langword="Backspace" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku karetka znajduje się w programie word, zostaną usunięte w pozostałej części programu word zakresu od bieżącej pozycji do początku słowa.  
  
 Nie jest zawsze rzeczywistą implementację, który odpowiada na polecenie w dowolnego obiektu; w wielu przypadkach wdrożenia, który odpowiada na polecenie spoczywa składnika zapisywania aplikacji.  
  
 To polecenie jest obsługiwany natywnie <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_DeletePreviousWord"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="DeletePreviousWord"/>  
```  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 W tym przykładzie <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (odziedziczone <xref:System.Windows.FrameworkElement>), i że zawiera on natywną obsługę wielu polecenia edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodą jest parametr polecenia.  Polecenia najbardziej edycji Ignoruj parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinna zawierać procedury obsługi dla określonego polecenia.  Ogólnie rzecz biorąc polecenia jest ignorowana, gdy wywoływane na obiekt, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.DeleteNextWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
      </Docs>
    </Member>
    <Member MemberName="EnterLineBreak">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand EnterLineBreak { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand EnterLineBreak" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.EnterLineBreak" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property EnterLineBreak As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ EnterLineBreak { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EnterLineBreak : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.EnterLineBreak" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.EnterLineBreak" /> polecenia, które żąda wstawiony podział wiersza w bieżącym położeniu lub za pośrednictwem bieżącego zaznaczenia.</summary>
        <value>Żądane polecenie.  Gest kluczy domyślne dla tego polecenia jest <see langword="Shift" /> + <see langword="Enter" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dla edytory, które obsługują zawartość przepływu, takie jak <xref:System.Windows.Controls.RichTextBox>, to polecenie powoduje, że <xref:System.Windows.Documents.LineBreak> element ma zostać wstawiony w bieżącym położeniu.  
  
 Nie jest zawsze rzeczywistą implementację, który odpowiada na polecenie w dowolnego obiektu; w wielu przypadkach wdrożenia, który odpowiada na polecenie spoczywa składnika zapisywania aplikacji.  
  
 To polecenie jest obsługiwany natywnie <xref:System.Windows.Controls.RichTextBox> i <xref:System.Windows.Controls.TextBox>.  
  
<a name="xamlAttributeUsage_EnterLineBreak"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="EnterLineBreak"/>  
```  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 W tym przykładzie <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (odziedziczone <xref:System.Windows.FrameworkElement>), i że zawiera on natywną obsługę wielu polecenia edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodą jest parametr polecenia.  Polecenia najbardziej edycji Ignoruj parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinna zawierać procedury obsługi dla określonego polecenia.  Ogólnie rzecz biorąc polecenia jest ignorowana, gdy wywoływane na obiekt, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.EnterParagraphBreak" />
      </Docs>
    </Member>
    <Member MemberName="EnterParagraphBreak">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand EnterParagraphBreak { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand EnterParagraphBreak" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.EnterParagraphBreak" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property EnterParagraphBreak As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ EnterParagraphBreak { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EnterParagraphBreak : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.EnterParagraphBreak" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.EnterParagraphBreak" /> polecenia, które żąda wstawiony podziału akapitu w bieżącym położeniu lub za pośrednictwem bieżącego zaznaczenia.</summary>
        <value>Żądane polecenie.  Gest kluczy domyślne dla tego polecenia jest <see langword="Enter" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To polecenie jest odpowiednikiem użytkownika, naciskając klawisz ENTER.  
  
 Nie jest zawsze rzeczywistą implementację, który odpowiada na polecenie w dowolnego obiektu; w wielu przypadkach wdrożenia, który odpowiada na polecenie spoczywa składnika zapisywania aplikacji.  
  
 To polecenie jest obsługiwany natywnie <xref:System.Windows.Controls.RichTextBox> i <xref:System.Windows.Controls.TextBox> (gdy <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsReturn%2A> właściwość `true`).  
  
> [!IMPORTANT]
>  To polecenie nie ma wpływu na element tekstowy chyba że <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsReturn%2A> właściwość elementu tekstu jest ustawiona na `true`.  
  
<a name="xamlAttributeUsage_EnterParagraphBreak"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="EnterParagraphBreak"/>  
```  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 W tym przykładzie <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (odziedziczone <xref:System.Windows.FrameworkElement>), i że zawiera on natywną obsługę wielu polecenia edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodą jest parametr polecenia.  Polecenia najbardziej edycji Ignoruj parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinna zawierać procedury obsługi dla określonego polecenia.  Ogólnie rzecz biorąc polecenia jest ignorowana, gdy wywoływane na obiekt, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.EnterLineBreak" />
      </Docs>
    </Member>
    <Member MemberName="IgnoreSpellingError">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand IgnoreSpellingError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand IgnoreSpellingError" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.IgnoreSpellingError" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IgnoreSpellingError As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ IgnoreSpellingError { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.IgnoreSpellingError : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.IgnoreSpellingError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.IgnoreSpellingError" /> polecenia, które żąda zignorowane wszystkie wystąpienia błędnie napisanych wyrazów w bieżącym położeniu lub w bieżącym zaznaczeniu.</summary>
        <value>Żądane polecenie.  To polecenie ma gestu klucza nie domyślne.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest zawsze rzeczywistą implementację, który odpowiada na polecenie w dowolnego obiektu; w wielu przypadkach wdrożenia, który odpowiada na polecenie spoczywa składnika zapisywania aplikacji.  
  
<a name="xamlAttributeUsage_IgnoreSpellingError"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="IgnoreSpellingError"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.CorrectSpellingError" />
      </Docs>
    </Member>
    <Member MemberName="IncreaseFontSize">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand IncreaseFontSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand IncreaseFontSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.IncreaseFontSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IncreaseFontSize As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ IncreaseFontSize { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.IncreaseFontSize : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.IncreaseFontSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.IncreaseFontSize" /> polecenia, które żądania, czy rozmiar czcionki dla bieżącego wyboru można zwiększyć o 1 punkt.</summary>
        <value>Żądane polecenie.  Gest kluczy domyślne dla tego polecenia jest <see langword="Ctrl" /> + <see langword="OemCloseBrackets" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli to polecenie jest wywoływane na zaznaczenie jest puste, gdzie karetka znajduje się w programie word, wybór jest rozwinięty dotyczą polecenia cały wyraz.  
  
 Nie jest zawsze rzeczywistą implementację, który odpowiada na polecenie w dowolnego obiektu; w wielu przypadkach wdrożenia, który odpowiada na polecenie spoczywa składnika zapisywania aplikacji.  
  
 To polecenie jest obsługiwany natywnie <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_IncreaseFontSize"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="IncreaseFontSize"/>  
```  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 W tym przykładzie <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (odziedziczone <xref:System.Windows.FrameworkElement>), i że zawiera on natywną obsługę wielu polecenia edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodą jest parametr polecenia.  Polecenia najbardziej edycji Ignoruj parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinna zawierać procedury obsługi dla określonego polecenia.  Ogólnie rzecz biorąc polecenia jest ignorowana, gdy wywoływane na obiekt, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.DecreaseFontSize" />
      </Docs>
    </Member>
    <Member MemberName="IncreaseIndentation">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand IncreaseIndentation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand IncreaseIndentation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.IncreaseIndentation" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IncreaseIndentation As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ IncreaseIndentation { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.IncreaseIndentation : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.IncreaseIndentation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.IncreaseIndentation" /> polecenia, które żądań tego wcięcia, dla bieżący akapit można zwiększyć przez jedną pozycję tabulatora.</summary>
        <value>Żądane polecenie.  Gest kluczy domyślne dla tego polecenia jest <see langword="Ctrl" /> + <see langword="T" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest zawsze rzeczywistą implementację, który odpowiada na polecenie w dowolnego obiektu; w wielu przypadkach wdrożenia, który odpowiada na polecenie spoczywa składnika zapisywania aplikacji.  
  
 To polecenie jest obsługiwany natywnie <xref:System.Windows.Controls.RichTextBox>.  
  
> [!IMPORTANT]
>  To polecenie nie ma wpływu na element tekstowy chyba że <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsTab%2A> właściwość elementu tekstu jest ustawiona na `true`.  
  
<a name="xamlAttributeUsage_IncreaseIndentation"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="IncreaseIndentation"/>  
```  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 W tym przykładzie <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (odziedziczone <xref:System.Windows.FrameworkElement>), i że zawiera on natywną obsługę wielu polecenia edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodą jest parametr polecenia.  Polecenia najbardziej edycji Ignoruj parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinna zawierać procedury obsługi dla określonego polecenia.  Ogólnie rzecz biorąc polecenia jest ignorowana, gdy wywoływane na obiekt, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.DecreaseIndentation" />
      </Docs>
    </Member>
    <Member MemberName="MoveDownByLine">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveDownByLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveDownByLine" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveDownByLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveDownByLine As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveDownByLine { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveDownByLine : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveDownByLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.MoveDownByLine" /> polecenia, które żąda karetkę przejść przez jeden wiersz.</summary>
        <value>Żądane polecenie.  Gest kluczy domyślne dla tego polecenia jest <see langword="Down" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest zawsze rzeczywistą implementację, który odpowiada na polecenie w dowolnego obiektu; w wielu przypadkach wdrożenia, który odpowiada na polecenie spoczywa składnika zapisywania aplikacji.  
  
 To polecenie jest obsługiwany natywnie <xref:System.Windows.Controls.RichTextBox> i <xref:System.Windows.Controls.TextBox>.  
  
<a name="xamlAttributeUsage_MoveDownByLine"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="MoveDownByLine"/>  
```  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 W tym przykładzie <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (odziedziczone <xref:System.Windows.FrameworkElement>), i że zawiera on natywną obsługę wielu polecenia edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodą jest parametr polecenia.  Polecenia najbardziej edycji Ignoruj parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinna zawierać procedury obsługi dla określonego polecenia.  Ogólnie rzecz biorąc polecenia jest ignorowana, gdy wywoływane na obiekt, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByLine" />
      </Docs>
    </Member>
    <Member MemberName="MoveDownByPage">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveDownByPage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveDownByPage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveDownByPage" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveDownByPage As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveDownByPage { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveDownByPage : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveDownByPage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.MoveDownByPage" /> polecenia, które żądania, Przenieś karetkę dół o jedną stronę.</summary>
        <value>Żądane polecenie.  Gest kluczy domyślne dla tego polecenia jest <see langword="PageDown" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest zawsze rzeczywistą implementację, który odpowiada na polecenie w dowolnego obiektu; w wielu przypadkach wdrożenia, który odpowiada na polecenie spoczywa składnika zapisywania aplikacji.  
  
 To polecenie jest obsługiwany natywnie <xref:System.Windows.Controls.RichTextBox> i <xref:System.Windows.Controls.TextBox>.  
  
<a name="xamlAttributeUsage_MoveDownByPage"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="MoveDownByPage"/>  
```  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 W tym przykładzie <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (odziedziczone <xref:System.Windows.FrameworkElement>), i że zawiera on natywną obsługę wielu polecenia edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodą jest parametr polecenia.  Polecenia najbardziej edycji Ignoruj parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinna zawierać procedury obsługi dla określonego polecenia.  Ogólnie rzecz biorąc polecenia jest ignorowana, gdy wywoływane na obiekt, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByPage" />
      </Docs>
    </Member>
    <Member MemberName="MoveDownByParagraph">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveDownByParagraph { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveDownByParagraph" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveDownByParagraph As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveDownByParagraph { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveDownByParagraph : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveDownByParagraph" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" /> polecenia, które żąda karetkę przejść przez jednego akapitu.</summary>
        <value>Żądane polecenie.  Gest kluczy domyślne dla tego polecenia jest <see langword="Ctrl" /> + <see langword="Down" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To polecenie ustawia położenie karetki na początku następnego akapitu.  
  
 To polecenie zachowuje się jak <xref:System.Windows.Documents.EditingCommands.MoveToDocumentEnd%2A> po wywołaniu na <xref:System.Windows.Controls.TextBox>.  
  
 Nie jest zawsze rzeczywistą implementację, który odpowiada na polecenie w dowolnego obiektu; w wielu przypadkach wdrożenia, który odpowiada na polecenie spoczywa składnika zapisywania aplikacji.  
  
 To polecenie jest obsługiwany natywnie <xref:System.Windows.Controls.RichTextBox> i <xref:System.Windows.Controls.TextBox>.  
  
<a name="xamlAttributeUsage_MoveDownByParagraph"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="MoveDownByParagraph"/>  
```  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 W tym przykładzie <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (odziedziczone <xref:System.Windows.FrameworkElement>), i że zawiera on natywną obsługę wielu polecenia edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodą jest parametr polecenia.  Polecenia najbardziej edycji Ignoruj parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinna zawierać procedury obsługi dla określonego polecenia.  Ogólnie rzecz biorąc polecenia jest ignorowana, gdy wywoływane na obiekt, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" />
      </Docs>
    </Member>
    <Member MemberName="MoveLeftByCharacter">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveLeftByCharacter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveLeftByCharacter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveLeftByCharacter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveLeftByCharacter As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveLeftByCharacter { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveLeftByCharacter : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveLeftByCharacter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.MoveLeftByCharacter" /> polecenia, które żąda się, że karetkę w lewo o jeden znak.</summary>
        <value>Żądane polecenie.  Gest kluczy domyślne dla tego polecenia jest <see langword="Left" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest zawsze rzeczywistą implementację, który odpowiada na polecenie w dowolnego obiektu; w wielu przypadkach wdrożenia, który odpowiada na polecenie spoczywa składnika zapisywania aplikacji.  
  
 To polecenie jest obsługiwany natywnie <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_MoveLeftByCharacter"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="MoveLeftByCharacter"/>  
```  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 W tym przykładzie <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (odziedziczone <xref:System.Windows.FrameworkElement>), i że zawiera on natywną obsługę wielu polecenia edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodą jest parametr polecenia.  Polecenia najbardziej edycji Ignoruj parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinna zawierać procedury obsługi dla określonego polecenia.  Ogólnie rzecz biorąc polecenia jest ignorowana, gdy wywoływane na obiekt, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByCharacter" />
      </Docs>
    </Member>
    <Member MemberName="MoveLeftByWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveLeftByWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveLeftByWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveLeftByWord As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveLeftByWord { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveLeftByWord : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveLeftByWord" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" /> polecenia, które żądania, karetkę przejść jedno słowo w lewo.</summary>
        <value>Żądane polecenie.  Gest kluczy domyślne dla tego polecenia jest <see langword="Ctrl" /> + <see langword="Left" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli karetka znajduje się w programie word, to polecenie spowoduje przeniesienie karetkę do początku wyrazu.  W przeciwnym razie to polecenie spowoduje przeniesienie karetkę na początek poprzedniego wyrazu.  
  
 Nie jest zawsze rzeczywistą implementację, który odpowiada na polecenie w dowolnego obiektu; w wielu przypadkach wdrożenia, który odpowiada na polecenie spoczywa składnika zapisywania aplikacji.  
  
 To polecenie jest obsługiwany natywnie <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_MoveLeftByWord"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="MoveLeftByWord"/>  
```  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 W tym przykładzie <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (odziedziczone <xref:System.Windows.FrameworkElement>), i że zawiera on natywną obsługę wielu polecenia edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodą jest parametr polecenia.  Polecenia najbardziej edycji Ignoruj parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinna zawierać procedury obsługi dla określonego polecenia.  Ogólnie rzecz biorąc polecenia jest ignorowana, gdy wywoływane na obiekt, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
      </Docs>
    </Member>
    <Member MemberName="MoveRightByCharacter">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveRightByCharacter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveRightByCharacter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveRightByCharacter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveRightByCharacter As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveRightByCharacter { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveRightByCharacter : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveRightByCharacter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.MoveRightByCharacter" /> polecenia, które żąda karetkę bezpośrednio przenieść o jeden znak.</summary>
        <value>Żądane polecenie.  Gest kluczy domyślne dla tego polecenia jest <see langword="Right" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest zawsze rzeczywistą implementację, który odpowiada na polecenie w dowolnego obiektu; w wielu przypadkach wdrożenia, który odpowiada na polecenie spoczywa składnika zapisywania aplikacji.  
  
 To polecenie jest obsługiwany natywnie <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_MoveRightByCharacter"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="MoveRightByCharacter"/>  
```  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 W tym przykładzie <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (odziedziczone <xref:System.Windows.FrameworkElement>), i że zawiera on natywną obsługę wielu polecenia edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodą jest parametr polecenia.  Polecenia najbardziej edycji Ignoruj parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinna zawierać procedury obsługi dla określonego polecenia.  Ogólnie rzecz biorąc polecenia jest ignorowana, gdy wywoływane na obiekt, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByCharacter" />
      </Docs>
    </Member>
    <Member MemberName="MoveRightByWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveRightByWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveRightByWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveRightByWord As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveRightByWord { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveRightByWord : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveRightByWord" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" /> polecenia, które żąda bezpośrednio Przesuń karetkę o jedno słowo.</summary>
        <value>Żądane polecenie.  Gest kluczy domyślne dla tego polecenia jest <see langword="Ctrl" /> + <see langword="Right" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli karetka znajduje się w programie word, to polecenie spowoduje przeniesienie karetkę do końca tego słowa.  W przeciwnym razie to polecenie spowoduje przeniesienie karetkę do początku następnego wyrazu.  
  
 Nie jest zawsze rzeczywistą implementację, który odpowiada na polecenie w dowolnego obiektu; w wielu przypadkach wdrożenia, który odpowiada na polecenie spoczywa składnika zapisywania aplikacji.  
  
 To polecenie jest obsługiwany natywnie <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_MoveRightByWord"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="MoveRightByWord"/>  
```  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 W tym przykładzie <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (odziedziczone <xref:System.Windows.FrameworkElement>), i że zawiera on natywną obsługę wielu polecenia edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodą jest parametr polecenia.  Polecenia najbardziej edycji Ignoruj parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinna zawierać procedury obsługi dla określonego polecenia.  Ogólnie rzecz biorąc polecenia jest ignorowana, gdy wywoływane na obiekt, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
      </Docs>
    </Member>
    <Member MemberName="MoveToDocumentEnd">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveToDocumentEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveToDocumentEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveToDocumentEnd" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveToDocumentEnd As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveToDocumentEnd { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveToDocumentEnd : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveToDocumentEnd" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.MoveToDocumentEnd" /> polecenia, które żądania, karetkę przejść na końcu zawartości.</summary>
        <value>Żądane polecenie.  Gest kluczy domyślne dla tego polecenia jest <see langword="Ctrl" /> + <see langword="End" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A *kontenerze tekstu* jest elementem, który wchodzi w skład ultimate obramowania zawartości pod ręką.  <xref:System.Windows.Controls.TextBlock> i <xref:System.Windows.Documents.FlowDocument> należą kontenery tekstu.  Zawartość zbiorczo zawartych w kontenerze tekstu jest określany jako *dokumentu*.  
  
 Nie jest zawsze rzeczywistą implementację, który odpowiada na polecenie w dowolnego obiektu; w wielu przypadkach wdrożenia, który odpowiada na polecenie spoczywa składnika zapisywania aplikacji.  
  
 To polecenie jest obsługiwany natywnie <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_MoveToDocumentEnd"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="MoveToDocumentEnd"/>  
```  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 W tym przykładzie <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (odziedziczone <xref:System.Windows.FrameworkElement>), i że zawiera on natywną obsługę wielu polecenia edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodą jest parametr polecenia.  Polecenia najbardziej edycji Ignoruj parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinna zawierać procedury obsługi dla określonego polecenia.  Ogólnie rzecz biorąc polecenia jest ignorowana, gdy wywoływane na obiekt, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentStart" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentEnd" />
      </Docs>
    </Member>
    <Member MemberName="MoveToDocumentStart">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveToDocumentStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveToDocumentStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveToDocumentStart" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveToDocumentStart As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveToDocumentStart { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveToDocumentStart : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveToDocumentStart" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.MoveToDocumentStart" /> polecenia, które żądania, karetkę przejść do początku treści.</summary>
        <value>Żądane polecenie.  Gest kluczy domyślne dla tego polecenia jest <see langword="Ctrl" /> + <see langword="Home" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A *kontenerze tekstu* jest elementem, który wchodzi w skład ultimate obramowania zawartości pod ręką.  <xref:System.Windows.Controls.TextBlock> i <xref:System.Windows.Documents.FlowDocument> należą kontenery tekstu.  Zawartość zbiorczo zawartych w kontenerze tekstu jest określany jako *dokumentu*.  
  
 Nie jest zawsze rzeczywistą implementację, który odpowiada na polecenie w dowolnego obiektu; w wielu przypadkach wdrożenia, który odpowiada na polecenie spoczywa składnika zapisywania aplikacji.  
  
 To polecenie jest obsługiwany natywnie <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_MoveToDocumentStart"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="MoveToDocumentStart"/>  
```  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 W tym przykładzie <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (odziedziczone <xref:System.Windows.FrameworkElement>), i że zawiera on natywną obsługę wielu polecenia edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodą jest parametr polecenia.  Polecenia najbardziej edycji Ignoruj parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinna zawierać procedury obsługi dla określonego polecenia.  Ogólnie rzecz biorąc polecenia jest ignorowana, gdy wywoływane na obiekt, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToDocumentEnd" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentStart" />
      </Docs>
    </Member>
    <Member MemberName="MoveToLineEnd">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveToLineEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveToLineEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveToLineEnd" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveToLineEnd As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveToLineEnd { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveToLineEnd : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveToLineEnd" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.MoveToLineEnd" /> polecenia, które żądania, karetkę przejść do końca bieżącego wiersza.</summary>
        <value>Żądane polecenie.  Gest kluczy domyślne dla tego polecenia jest <see langword="End" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest zawsze rzeczywistą implementację, który odpowiada na polecenie w dowolnego obiektu; w wielu przypadkach wdrożenia, który odpowiada na polecenie spoczywa składnika zapisywania aplikacji.  
  
 To polecenie jest obsługiwany natywnie <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_MoveToLineEnd"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="MoveToLineEnd"/>  
```  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 W tym przykładzie <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (odziedziczone <xref:System.Windows.FrameworkElement>), i że zawiera on natywną obsługę wielu polecenia edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodą jest parametr polecenia.  Polecenia najbardziej edycji Ignoruj parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinna zawierać procedury obsługi dla określonego polecenia.  Ogólnie rzecz biorąc polecenia jest ignorowana, gdy wywoływane na obiekt, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToLineStart" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToLineEnd" />
      </Docs>
    </Member>
    <Member MemberName="MoveToLineStart">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveToLineStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveToLineStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveToLineStart" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveToLineStart As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveToLineStart { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveToLineStart : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveToLineStart" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.MoveToLineStart" /> polecenia, które żądania, karetkę przejść na początek bieżącego wiersza.</summary>
        <value>Żądane polecenie.  Gest kluczy domyślne dla tego polecenia jest <see langword="Home" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest zawsze rzeczywistą implementację, który odpowiada na polecenie w dowolnego obiektu; w wielu przypadkach wdrożenia, który odpowiada na polecenie spoczywa składnika zapisywania aplikacji.  
  
 To polecenie jest obsługiwany natywnie <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_MoveToLineStart"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="MoveToLineStart"/>  
```  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 W tym przykładzie <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (odziedziczone <xref:System.Windows.FrameworkElement>), i że zawiera on natywną obsługę wielu polecenia edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodą jest parametr polecenia.  Polecenia najbardziej edycji Ignoruj parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinna zawierać procedury obsługi dla określonego polecenia.  Ogólnie rzecz biorąc polecenia jest ignorowana, gdy wywoływane na obiekt, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToLineEnd" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToLineEnd" />
      </Docs>
    </Member>
    <Member MemberName="MoveUpByLine">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveUpByLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveUpByLine" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveUpByLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveUpByLine As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveUpByLine { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveUpByLine : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveUpByLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.MoveUpByLine" /> polecenia, które żąda karetkę przechodzą przez jeden wiersz.</summary>
        <value>Żądane polecenie.  Gest kluczy domyślne dla tego polecenia jest <see langword="Up" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest zawsze rzeczywistą implementację, który odpowiada na polecenie w dowolnego obiektu; w wielu przypadkach wdrożenia, który odpowiada na polecenie spoczywa składnika zapisywania aplikacji.  
  
 To polecenie jest obsługiwany natywnie <xref:System.Windows.Controls.RichTextBox> i <xref:System.Windows.Controls.TextBox>.  
  
<a name="xamlAttributeUsage_MoveUpByLine"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="MoveUpByLine"/>  
```  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 W tym przykładzie <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (odziedziczone <xref:System.Windows.FrameworkElement>), i że zawiera on natywną obsługę wielu polecenia edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodą jest parametr polecenia.  Polecenia najbardziej edycji Ignoruj parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinna zawierać procedury obsługi dla określonego polecenia.  Ogólnie rzecz biorąc polecenia jest ignorowana, gdy wywoływane na obiekt, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByLine" />
      </Docs>
    </Member>
    <Member MemberName="MoveUpByPage">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveUpByPage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveUpByPage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveUpByPage" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveUpByPage As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveUpByPage { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveUpByPage : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveUpByPage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.MoveUpByPage" /> polecenia, które żąda karetkę przesunięty o jedną stronę.</summary>
        <value>Żądane polecenie.  Gest kluczy domyślne dla tego polecenia jest <see langword="PageUp" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest zawsze rzeczywistą implementację, który odpowiada na polecenie w dowolnego obiektu; w wielu przypadkach wdrożenia, który odpowiada na polecenie spoczywa składnika zapisywania aplikacji.  
  
 To polecenie jest obsługiwany natywnie <xref:System.Windows.Controls.RichTextBox> i <xref:System.Windows.Controls.TextBox>.  
  
<a name="xamlAttributeUsage_MoveUpByPage"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="MoveUpByPage"/>  
```  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 W tym przykładzie <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (odziedziczone <xref:System.Windows.FrameworkElement>), i że zawiera on natywną obsługę wielu polecenia edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodą jest parametr polecenia.  Polecenia najbardziej edycji Ignoruj parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinna zawierać procedury obsługi dla określonego polecenia.  Ogólnie rzecz biorąc polecenia jest ignorowana, gdy wywoływane na obiekt, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByPage" />
      </Docs>
    </Member>
    <Member MemberName="MoveUpByParagraph">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveUpByParagraph { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveUpByParagraph" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveUpByParagraph As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveUpByParagraph { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveUpByParagraph : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveUpByParagraph" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" /> polecenia, które żąda karetkę przechodzą przez jednego akapitu.</summary>
        <value>Żądane polecenie.  Gest kluczy domyślne dla tego polecenia jest <see langword="Ctrl" /> + <see langword="Up" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To polecenie ustawia położenie karetki na początku następnego akapitu.  
  
 To polecenie zachowuje się jak <xref:System.Windows.Documents.EditingCommands.MoveToDocumentStart%2A> po wywołaniu na <xref:System.Windows.Controls.TextBox>.  
  
 Nie jest zawsze rzeczywistą implementację, który odpowiada na polecenie w dowolnego obiektu; w wielu przypadkach wdrożenia, który odpowiada na polecenie spoczywa składnika zapisywania aplikacji.  
  
 To polecenie jest obsługiwany natywnie <xref:System.Windows.Controls.RichTextBox> i <xref:System.Windows.Controls.TextBox>.  
  
<a name="xamlAttributeUsage_MoveUpByParagraph"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="MoveUpByParagraph"/>  
```  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 W tym przykładzie <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (odziedziczone <xref:System.Windows.FrameworkElement>), i że zawiera on natywną obsługę wielu polecenia edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodą jest parametr polecenia.  Polecenia najbardziej edycji Ignoruj parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinna zawierać procedury obsługi dla określonego polecenia.  Ogólnie rzecz biorąc polecenia jest ignorowana, gdy wywoływane na obiekt, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" />
      </Docs>
    </Member>
    <Member MemberName="SelectDownByLine">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectDownByLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectDownByLine" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectDownByLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectDownByLine As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectDownByLine { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectDownByLine : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectDownByLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.SelectDownByLine" /> polecenia, które żąda rozszerzona bieżące zaznaczenie w dół o jedną linię.</summary>
        <value>Żądane polecenie.  Gest kluczy domyślne dla tego polecenia jest <see langword="Shift" /> + <see langword="Down" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest zawsze rzeczywistą implementację, który odpowiada na polecenie w dowolnego obiektu; w wielu przypadkach wdrożenia, który odpowiada na polecenie spoczywa składnika zapisywania aplikacji.  
  
 To polecenie jest obsługiwany natywnie <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectDownByLine"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="SelectDownByLine"/>  
```  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 W tym przykładzie <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (odziedziczone <xref:System.Windows.FrameworkElement>), i że zawiera on natywną obsługę wielu polecenia edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodą jest parametr polecenia.  Polecenia najbardziej edycji Ignoruj parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinna zawierać procedury obsługi dla określonego polecenia.  Ogólnie rzecz biorąc polecenia jest ignorowana, gdy wywoływane na obiekt, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByLine" />
      </Docs>
    </Member>
    <Member MemberName="SelectDownByPage">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectDownByPage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectDownByPage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectDownByPage" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectDownByPage As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectDownByPage { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectDownByPage : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectDownByPage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.SelectDownByPage" /> polecenia, które żąda rozszerzona bieżące zaznaczenie w dół o jedną stronę.</summary>
        <value>Żądane polecenie.  Gest kluczy domyślne dla tego polecenia jest <see langword="Shift" /> + <see langword="PageDown" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest zawsze rzeczywistą implementację, który odpowiada na polecenie w dowolnego obiektu; w wielu przypadkach wdrożenia, który odpowiada na polecenie spoczywa składnika zapisywania aplikacji.  
  
 To polecenie jest obsługiwany natywnie <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectDownByPage"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="SelectDownByPage"/>  
```  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 W tym przykładzie <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (odziedziczone <xref:System.Windows.FrameworkElement>), i że zawiera on natywną obsługę wielu polecenia edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodą jest parametr polecenia.  Polecenia najbardziej edycji Ignoruj parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinna zawierać procedury obsługi dla określonego polecenia.  Ogólnie rzecz biorąc polecenia jest ignorowana, gdy wywoływane na obiekt, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByPage" />
      </Docs>
    </Member>
    <Member MemberName="SelectDownByParagraph">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectDownByParagraph { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectDownByParagraph" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectDownByParagraph As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectDownByParagraph { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectDownByParagraph : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectDownByParagraph" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" /> polecenia, które żąda rozszerzona bieżącego zaznaczenia w dół według jedną akapitu.</summary>
        <value>Żądane polecenie.  Gest kluczy domyślne dla tego polecenia jest <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="Down" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To polecenie rozwija zaznaczenie do początku następnego akapitu.  W przeciwnym razie polecenie rozwija zaznaczenie do końca bieżącego akapitu.  Rozszerzony wybór zawiera podział akapit, który oznacza koniec akapitu.  
  
 Nie jest zawsze rzeczywistą implementację, który odpowiada na polecenie w dowolnego obiektu; w wielu przypadkach wdrożenia, który odpowiada na polecenie spoczywa składnika zapisywania aplikacji.  
  
 To polecenie jest obsługiwany natywnie <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectDownByParagraph"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="SelectDownByParagraph"/>  
```  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 W tym przykładzie <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (odziedziczone <xref:System.Windows.FrameworkElement>), i że zawiera on natywną obsługę wielu polecenia edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodą jest parametr polecenia.  Polecenia najbardziej edycji Ignoruj parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinna zawierać procedury obsługi dla określonego polecenia.  Ogólnie rzecz biorąc polecenia jest ignorowana, gdy wywoływane na obiekt, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" />
      </Docs>
    </Member>
    <Member MemberName="SelectLeftByCharacter">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectLeftByCharacter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectLeftByCharacter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectLeftByCharacter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectLeftByCharacter As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectLeftByCharacter { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectLeftByCharacter : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectLeftByCharacter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.SelectLeftByCharacter" /> polecenia, które żąda się, że bieżące zaznaczenie wyodrębnienia lewo o jeden znak.</summary>
        <value>Żądane polecenie.  Gest kluczy domyślne dla tego polecenia jest <see langword="Shift" /> + <see langword="Left" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest zawsze rzeczywistą implementację, który odpowiada na polecenie w dowolnego obiektu; w wielu przypadkach wdrożenia, który odpowiada na polecenie spoczywa składnika zapisywania aplikacji.  
  
 To polecenie jest obsługiwany natywnie <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectLeftByCharacter"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="SelectLeftByCharacter"/>  
```  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 W tym przykładzie <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (odziedziczone <xref:System.Windows.FrameworkElement>), i że zawiera on natywną obsługę wielu polecenia edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodą jest parametr polecenia.  Polecenia najbardziej edycji Ignoruj parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinna zawierać procedury obsługi dla określonego polecenia.  Ogólnie rzecz biorąc polecenia jest ignorowana, gdy wywoływane na obiekt, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByCharacter" />
      </Docs>
    </Member>
    <Member MemberName="SelectLeftByWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectLeftByWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectLeftByWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectLeftByWord As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectLeftByWord { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectLeftByWord : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectLeftByWord" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" /> polecenia, które żąda się, że bieżące zaznaczenie lewej rozszerzona o jedno słowo.</summary>
        <value>Żądane polecenie.  Gest kluczy domyślne dla tego polecenia jest <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="Left" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli karetka znajduje się w programie word, to polecenie rozwija zaznaczenie do początku wyrazu.  W przeciwnym razie to polecenie rozwija zaznaczenie do początku poprzedniego wyrazu.  
  
 Rozszerzony wybór nie zawiera ograniczników programu word.  Porównaj z <xref:System.Windows.Documents.EditingCommands.SelectRightByWord%2A>, który ma ogranicznik programu word w zaznaczeniu rozwinięty.  
  
 Nie jest zawsze rzeczywistą implementację, który odpowiada na polecenie w dowolnego obiektu; w wielu przypadkach wdrożenia, który odpowiada na polecenie spoczywa składnika zapisywania aplikacji.  
  
 To polecenie jest obsługiwany natywnie <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectLeftByWord"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="SelectLeftByWord"/>  
```  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 W tym przykładzie <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (odziedziczone <xref:System.Windows.FrameworkElement>), i że zawiera on natywną obsługę wielu polecenia edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodą jest parametr polecenia.  Polecenia najbardziej edycji Ignoruj parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinna zawierać procedury obsługi dla określonego polecenia.  Ogólnie rzecz biorąc polecenia jest ignorowana, gdy wywoływane na obiekt, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
      </Docs>
    </Member>
    <Member MemberName="SelectRightByCharacter">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectRightByCharacter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectRightByCharacter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectRightByCharacter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectRightByCharacter As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectRightByCharacter { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectRightByCharacter : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectRightByCharacter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.SelectRightByCharacter" /> polecenia, które żąda rozszerzona bieżące zaznaczenie w prawo o jeden znak.</summary>
        <value>Żądane polecenie.  Gest kluczy domyślne dla tego polecenia jest <see langword="Shift" /> + <see langword="Right" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest zawsze rzeczywistą implementację, który odpowiada na polecenie w dowolnego obiektu; w wielu przypadkach wdrożenia, który odpowiada na polecenie spoczywa składnika zapisywania aplikacji.  
  
 To polecenie jest obsługiwany natywnie <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectRightByCharacter"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="SelectRightByCharacter"/>  
```  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 W tym przykładzie <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (odziedziczone <xref:System.Windows.FrameworkElement>), i że zawiera on natywną obsługę wielu polecenia edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodą jest parametr polecenia.  Polecenia najbardziej edycji Ignoruj parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinna zawierać procedury obsługi dla określonego polecenia.  Ogólnie rzecz biorąc polecenia jest ignorowana, gdy wywoływane na obiekt, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByCharacter" />
      </Docs>
    </Member>
    <Member MemberName="SelectRightByWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectRightByWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectRightByWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectRightByWord As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectRightByWord { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectRightByWord : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectRightByWord" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" /> polecenia, które żąda rozszerzona bieżące zaznaczenie w prawo o jedno słowo.</summary>
        <value>Żądane polecenie.  Gest kluczy domyślne dla tego polecenia jest <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="Right" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli karetka znajduje się w programie word, to polecenie rozwija zaznaczenie do końca tego słowa.  W przeciwnym razie to polecenie rozwija zaznaczenie do końca następnego wyrazu.  
  
 Rozwinięty zaznaczenie obejmuje ogranicznik programu word.  Porównaj z <xref:System.Windows.Documents.EditingCommands.SelectLeftByWord%2A> który nie obejmuje ogranicznik programu word w rozszerzony wybór.  
  
 Nie jest zawsze rzeczywistą implementację, który odpowiada na polecenie w dowolnego obiektu; w wielu przypadkach wdrożenia, który odpowiada na polecenie spoczywa składnika zapisywania aplikacji.  
  
 To polecenie jest obsługiwany natywnie <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectRightByWord"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="SelectRightByWord"/>  
```  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 W tym przykładzie <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (odziedziczone <xref:System.Windows.FrameworkElement>), i że zawiera on natywną obsługę wielu polecenia edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodą jest parametr polecenia.  Polecenia najbardziej edycji Ignoruj parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinna zawierać procedury obsługi dla określonego polecenia.  Ogólnie rzecz biorąc polecenia jest ignorowana, gdy wywoływane na obiekt, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
      </Docs>
    </Member>
    <Member MemberName="SelectToDocumentEnd">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectToDocumentEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectToDocumentEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectToDocumentEnd" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectToDocumentEnd As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectToDocumentEnd { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectToDocumentEnd : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectToDocumentEnd" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentEnd" /> polecenia, które żąda rozszerzona bieżące zaznaczenie na końcu zawartości.</summary>
        <value>Żądane polecenie.  Gest kluczy domyślne dla tego polecenia jest <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="End" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A *kontenerze tekstu* jest elementem, który wchodzi w skład ultimate obramowania zawartości pod ręką.  <xref:System.Windows.Controls.TextBlock> i <xref:System.Windows.Documents.FlowDocument> należą kontenery tekstu.  Zawartość zbiorczo zawartych w kontenerze tekstu jest określany jako *dokumentu*.  
  
 Nie jest zawsze rzeczywistą implementację, który odpowiada na polecenie w dowolnego obiektu; w wielu przypadkach wdrożenia, który odpowiada na polecenie spoczywa składnika zapisywania aplikacji.  
  
 To polecenie jest obsługiwany natywnie <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectToDocumentEnd"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="SelectToDocumentEnd"/>  
```  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 W tym przykładzie <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (odziedziczone <xref:System.Windows.FrameworkElement>), i że zawiera on natywną obsługę wielu polecenia edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodą jest parametr polecenia.  Polecenia najbardziej edycji Ignoruj parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinna zawierać procedury obsługi dla określonego polecenia.  Ogólnie rzecz biorąc polecenia jest ignorowana, gdy wywoływane na obiekt, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentStart" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToDocumentEnd" />
      </Docs>
    </Member>
    <Member MemberName="SelectToDocumentStart">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectToDocumentStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectToDocumentStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectToDocumentStart" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectToDocumentStart As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectToDocumentStart { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectToDocumentStart : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectToDocumentStart" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentStart" /> polecenia, które żąda rozszerzona bieżące zaznaczenie do początku treści.</summary>
        <value>Żądane polecenie.  Gest kluczy domyślne dla tego polecenia jest <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="Home" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A *kontenerze tekstu* jest elementem, który wchodzi w skład ultimate obramowania zawartości pod ręką.  <xref:System.Windows.Controls.TextBlock> i <xref:System.Windows.Documents.FlowDocument> należą kontenery tekstu.  Zawartość zbiorczo zawartych w kontenerze tekstu jest określany jako *dokumentu*.  
  
 Nie jest zawsze rzeczywistą implementację, który odpowiada na polecenie w dowolnego obiektu; w wielu przypadkach wdrożenia, który odpowiada na polecenie spoczywa składnika zapisywania aplikacji.  
  
 To polecenie jest obsługiwany natywnie <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectToDocumentStart"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="SelectToDocumentStart"/>  
```  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 W tym przykładzie <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (odziedziczone <xref:System.Windows.FrameworkElement>), i że zawiera on natywną obsługę wielu polecenia edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodą jest parametr polecenia.  Polecenia najbardziej edycji Ignoruj parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinna zawierać procedury obsługi dla określonego polecenia.  Ogólnie rzecz biorąc polecenia jest ignorowana, gdy wywoływane na obiekt, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentEnd" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToDocumentStart" />
      </Docs>
    </Member>
    <Member MemberName="SelectToLineEnd">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectToLineEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectToLineEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectToLineEnd" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectToLineEnd As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectToLineEnd { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectToLineEnd : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectToLineEnd" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.SelectToLineEnd" /> polecenia, które żąda rozszerzona bieżące zaznaczenie do końca bieżącego wiersza.</summary>
        <value>Żądane polecenie.  Gest kluczy domyślne dla tego polecenia jest <see langword="Shift" /> + <see langword="End" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest zawsze rzeczywistą implementację, który odpowiada na polecenie w dowolnego obiektu; w wielu przypadkach wdrożenia, który odpowiada na polecenie spoczywa składnika zapisywania aplikacji.  
  
 To polecenie jest obsługiwany natywnie <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectToLineEnd"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="SelectToLineEnd"/>  
```  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 W tym przykładzie <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (odziedziczone <xref:System.Windows.FrameworkElement>), i że zawiera on natywną obsługę wielu polecenia edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodą jest parametr polecenia.  Polecenia najbardziej edycji Ignoruj parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinna zawierać procedury obsługi dla określonego polecenia.  Ogólnie rzecz biorąc polecenia jest ignorowana, gdy wywoływane na obiekt, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToLineStart" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToLineEnd" />
      </Docs>
    </Member>
    <Member MemberName="SelectToLineStart">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectToLineStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectToLineStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectToLineStart" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectToLineStart As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectToLineStart { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectToLineStart : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectToLineStart" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.SelectToLineStart" /> polecenia, które żąda rozszerzona bieżące zaznaczenie do początku bieżącego wiersza.</summary>
        <value>Żądane polecenie.  Gest kluczy domyślne dla tego polecenia jest <see langword="Shift" /> + <see langword="Home" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest zawsze rzeczywistą implementację, który odpowiada na polecenie w dowolnego obiektu; w wielu przypadkach wdrożenia, który odpowiada na polecenie spoczywa składnika zapisywania aplikacji.  
  
 To polecenie jest obsługiwany natywnie <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectToLineStart"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="SelectToLineStart"/>  
```  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 W tym przykładzie <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (odziedziczone <xref:System.Windows.FrameworkElement>), i że zawiera on natywną obsługę wielu polecenia edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodą jest parametr polecenia.  Polecenia najbardziej edycji Ignoruj parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinna zawierać procedury obsługi dla określonego polecenia.  Ogólnie rzecz biorąc polecenia jest ignorowana, gdy wywoływane na obiekt, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToLineEnd" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToLineStart" />
      </Docs>
    </Member>
    <Member MemberName="SelectUpByLine">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectUpByLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectUpByLine" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectUpByLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectUpByLine As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectUpByLine { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectUpByLine : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectUpByLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.SelectUpByLine" /> polecenia, które żąda rozszerzona bieżące zaznaczenie się przez jeden wiersz.</summary>
        <value>Żądane polecenie.  Gest kluczy domyślne dla tego polecenia jest <see langword="Shift" /> + <see langword="Up" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest zawsze rzeczywistą implementację, który odpowiada na polecenie w dowolnego obiektu; w wielu przypadkach wdrożenia, który odpowiada na polecenie spoczywa składnika zapisywania aplikacji.  
  
 To polecenie jest obsługiwany natywnie <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectUpByLine"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="SelectUpByLine"/>  
```  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 W tym przykładzie <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (odziedziczone <xref:System.Windows.FrameworkElement>), i że zawiera on natywną obsługę wielu polecenia edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodą jest parametr polecenia.  Polecenia najbardziej edycji Ignoruj parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinna zawierać procedury obsługi dla określonego polecenia.  Ogólnie rzecz biorąc polecenia jest ignorowana, gdy wywoływane na obiekt, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByLine" />
      </Docs>
    </Member>
    <Member MemberName="SelectUpByPage">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectUpByPage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectUpByPage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectUpByPage" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectUpByPage As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectUpByPage { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectUpByPage : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectUpByPage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.SelectUpByPage" /> polecenia, które żąda rozszerzona bieżące zaznaczenie się o jedną stronę.</summary>
        <value>Żądane polecenie.  Gest kluczy domyślne dla tego polecenia jest <see langword="Shift" /> + <see langword="PageUp" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest zawsze rzeczywistą implementację, który odpowiada na polecenie w dowolnego obiektu; w wielu przypadkach wdrożenia, który odpowiada na polecenie spoczywa składnika zapisywania aplikacji.  
  
 To polecenie jest obsługiwany natywnie <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectUpByPage"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="SelectUpByPage"/>  
```  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 W tym przykładzie <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (odziedziczone <xref:System.Windows.FrameworkElement>), i że zawiera on natywną obsługę wielu polecenia edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodą jest parametr polecenia.  Polecenia najbardziej edycji Ignoruj parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinna zawierać procedury obsługi dla określonego polecenia.  Ogólnie rzecz biorąc polecenia jest ignorowana, gdy wywoływane na obiekt, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByPage" />
      </Docs>
    </Member>
    <Member MemberName="SelectUpByParagraph">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectUpByParagraph { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectUpByParagraph" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectUpByParagraph As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectUpByParagraph { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectUpByParagraph : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectUpByParagraph" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" /> polecenia, które żąda rozszerzona bieżące zaznaczenie się przez jeden akapit.</summary>
        <value>Żądane polecenie.  Gest kluczy domyślne dla tego polecenia jest <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="Up" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli karetka znajduje się na początku akapitu, to polecenie rozwija zaznaczenie do początku poprzednim akapicie.  W przeciwnym razie polecenie rozwija zaznaczenie do początku bieżącego akapitu.  
  
 Nie jest zawsze rzeczywistą implementację, który odpowiada na polecenie w dowolnego obiektu; w wielu przypadkach wdrożenia, który odpowiada na polecenie spoczywa składnika zapisywania aplikacji.  
  
 To polecenie jest obsługiwany natywnie <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectUpByParagraph"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="SelectUpByParagraph"/>  
```  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 W tym przykładzie <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (odziedziczone <xref:System.Windows.FrameworkElement>), i że zawiera on natywną obsługę wielu polecenia edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodą jest parametr polecenia.  Polecenia najbardziej edycji Ignoruj parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinna zawierać procedury obsługi dla określonego polecenia.  Ogólnie rzecz biorąc polecenia jest ignorowana, gdy wywoływane na obiekt, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" />
      </Docs>
    </Member>
    <Member MemberName="TabBackward">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand TabBackward { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand TabBackward" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.TabBackward" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property TabBackward As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ TabBackward { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TabBackward : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.TabBackward" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.TabBackward" /> polecenia.</summary>
        <value>Żądane polecenie.  Gest kluczy domyślne dla tego polecenia jest <see langword="Shift" /> + <see langword="Tab" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zachowanie tego polecenia, zależy od bieżącego zaznaczenia. Jeśli zaznaczenie jest pusta, to polecenie jest odpowiednikiem <xref:System.Windows.Documents.EditingCommands.DecreaseIndentation%2A>. Jeśli karetka znajduje się w komórce tabeli (reprezentowane przez <xref:System.Windows.Documents.TableCell> element), to polecenie spowoduje przeniesienie karetkę do poprzedniej komórki. W przeciwnym razie dodaje się znak tabulacji w bieżącym położeniu.  
  
 Nie jest zawsze rzeczywistą implementację, który odpowiada na polecenie w dowolnego obiektu; w wielu przypadkach wdrożenia, który odpowiada na polecenie spoczywa składnika zapisywania aplikacji.  
  
 To polecenie jest obsługiwany natywnie <xref:System.Windows.Controls.RichTextBox> i <xref:System.Windows.Controls.TextBox> (gdy <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsTab%2A> właściwość `true`).  
  
<a name="xamlAttributeUsage_TabBackward"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="TabBackward"/>  
```  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 W tym przykładzie <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (odziedziczone <xref:System.Windows.FrameworkElement>), i że zawiera on natywną obsługę wielu polecenia edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodą jest parametr polecenia.  Polecenia najbardziej edycji Ignoruj parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinna zawierać procedury obsługi dla określonego polecenia.  Ogólnie rzecz biorąc polecenia jest ignorowana, gdy wywoływane na obiekt, który nie obsługuje polecenia.  
  
```csharp  
RichTextBox rTB = new RichTextBox();  
  
EditingCommands.ToggleInsert.Execute(null, rTB);  
  
```  
  
```vb  
            Dim rTB As New RichTextBox()  
  
            EditingCommands.ToggleInsert.Execute(Nothing, rTB)  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.TabForward" />
      </Docs>
    </Member>
    <Member MemberName="TabForward">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand TabForward { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand TabForward" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.TabForward" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property TabForward As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ TabForward { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TabForward : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.TabForward" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.TabForward" /> polecenia.</summary>
        <value>Żądane polecenie.  Gest kluczy domyślne dla tego polecenia jest <see langword="Tab" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zachowanie tego polecenia, zależy od bieżącego zaznaczenia. Jeśli zaznaczenie jest pusty lub jeśli zaznaczenie jest puste, a bieżącym położeniu karetki jest na początku akapitu, to polecenie jest odpowiednikiem <xref:System.Windows.Documents.EditingCommands.IncreaseIndentation%2A>. Jeśli karetka znajduje się w komórce tabeli (reprezentowane przez <xref:System.Windows.Documents.TableCell> element), to polecenie spowoduje przeniesienie karetkę do następnej komórki. Jeśli karetka znajduje się w ostatniej komórki tabeli, to polecenie powoduje, że nowy wiersz do dołączenia do tabeli za pomocą karetki umieszczony w pierwszej komórki nowego wiersza.  W przeciwnym razie dodaje się znak tabulacji w bieżącym położeniu.  
  
 Nie jest zawsze rzeczywistą implementację, który odpowiada na polecenie w dowolnego obiektu; w wielu przypadkach wdrożenia, który odpowiada na polecenie spoczywa składnika zapisywania aplikacji.  
  
 To polecenie jest obsługiwany natywnie <xref:System.Windows.Controls.RichTextBox> i <xref:System.Windows.Controls.TextBox> (gdy <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsTab%2A> właściwość `true`).  
  
<a name="xamlAttributeUsage_TabForward"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="TabForward"/>  
```  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 W tym przykładzie <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (odziedziczone <xref:System.Windows.FrameworkElement>), i że zawiera on natywną obsługę wielu polecenia edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodą jest parametr polecenia.  Polecenia najbardziej edycji Ignoruj parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinna zawierać procedury obsługi dla określonego polecenia.  Ogólnie rzecz biorąc polecenia jest ignorowana, gdy wywoływane na obiekt, który nie obsługuje polecenia.  
  
```csharp  
RichTextBox rTB = new RichTextBox();  
  
EditingCommands.ToggleInsert.Execute(null, rTB);  
  
```  
  
```vb  
            Dim rTB As New RichTextBox()  
  
            EditingCommands.ToggleInsert.Execute(Nothing, rTB)  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.TabBackward" />
      </Docs>
    </Member>
    <Member MemberName="ToggleBold">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleBold { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleBold" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleBold" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleBold As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleBold { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToggleBold : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.ToggleBold" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.ToggleBold" /> polecenia, które żądania wysyłane przez <see cref="T:System.Windows.Documents.Bold" /> formatowanie zostać przełączona w bieżącym zaznaczeniu.</summary>
        <value>Żądane polecenie.  Gest kluczy domyślne dla tego polecenia jest <see langword="Ctrl" /> + <see langword="B" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Windows.FontWeight> dla bieżącego zaznaczenia znajduje się w zakresie od <xref:System.Windows.FontWeights.Thin%2A> do <xref:System.Windows.FontWeights.SemiBold%2A>, <xref:System.Windows.FontWeights.Bold%2A> jest stosowany do bieżącego zaznaczenia.  W przeciwnym razie <xref:System.Windows.FontWeights.Normal%2A> jest stosowany.  Lista porównawczych <xref:System.Windows.FontWeight> wartości, zobacz <xref:System.Windows.FontWeights>.  
  
 Jeśli zaznaczenie jest puste karetka znajduje się w programie word, wybór jest rozwinięta i obejmuje cały wyraz.  
  
 Nie jest zawsze rzeczywistą implementację, który odpowiada na polecenie w dowolnego obiektu; w wielu przypadkach wdrożenia, który odpowiada na polecenie spoczywa składnika zapisywania aplikacji.  
  
 To polecenie jest obsługiwany natywnie <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_ToggleBold"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="ToggleBold"/>  
```  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 W tym przykładzie <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (odziedziczone <xref:System.Windows.FrameworkElement>), i że zawiera on natywną obsługę wielu polecenia edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodą jest parametr polecenia.  Polecenia najbardziej edycji Ignoruj parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinna zawierać procedury obsługi dla określonego polecenia.  Ogólnie rzecz biorąc polecenia jest ignorowana, gdy wywoływane na obiekt, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleItalic" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleUnderline" />
      </Docs>
    </Member>
    <Member MemberName="ToggleBullets">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleBullets { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleBullets" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleBullets" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleBullets As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleBullets { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToggleBullets : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.ToggleBullets" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.ToggleBullets" /> polecenia, które żąda się, że formatowanie nieuporządkowaną listę (nazywane również listy punktowanej) zostać przełączona w bieżącym zaznaczeniu.</summary>
        <value>Żądane polecenie.  Gest kluczy domyślne dla tego polecenia jest <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="L" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To polecenie działa na <xref:System.Windows.Documents.Paragraph> poziom.  Jeśli to polecenie jest wywoływane na częściowy wybór zawartości w akapicie (w tym zaznaczenie jest puste, gdzie karetka znajduje się w obrębie akapitu), żądany efekt zastosowany do całego akapitu.  Jeśli to polecenie jest wywoływane na wybór, która obejmuje wiele akapitów, efekt jest stosowany do całej zawartości każdego akapitu, który uczestniczy w zaznaczeniu.  
  
 Nie jest zawsze rzeczywistą implementację, który odpowiada na polecenie w dowolnego obiektu; w wielu przypadkach wdrożenia, który odpowiada na polecenie spoczywa składnika zapisywania aplikacji.  
  
 To polecenie jest obsługiwany natywnie <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_ToggleBullets"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="ToggleBullets"/>  
```  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 W tym przykładzie <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (odziedziczone <xref:System.Windows.FrameworkElement>), i że zawiera on natywną obsługę wielu polecenia edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodą jest parametr polecenia.  Polecenia najbardziej edycji Ignoruj parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinna zawierać procedury obsługi dla określonego polecenia.  Ogólnie rzecz biorąc polecenia jest ignorowana, gdy wywoływane na obiekt, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleNumbering" />
      </Docs>
    </Member>
    <Member MemberName="ToggleInsert">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleInsert { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleInsert" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleInsert" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleInsert As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleInsert { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToggleInsert : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.ToggleInsert" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.ToggleInsert" /> polecenia, które włącza/wyłącza tryb pisania pomiędzy wstawiania i zastępowania.</summary>
        <value>Żądane polecenie.  Gest kluczy domyślne dla tego polecenia jest <see langword="Insert" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest zawsze rzeczywistą implementację, który odpowiada na polecenie w dowolnego obiektu; w wielu przypadkach wdrożenia, który odpowiada na polecenie spoczywa składnika zapisywania aplikacji.  
  
 To polecenie jest obsługiwany natywnie <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>, i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_ToggleInsert"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="ToggleInsert"/>  
```  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 W tym przykładzie <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (odziedziczone <xref:System.Windows.FrameworkElement>), i że zawiera on natywną obsługę wielu polecenia edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodą jest parametr polecenia.  Polecenia najbardziej edycji Ignoruj parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinna zawierać procedury obsługi dla określonego polecenia.  Ogólnie rzecz biorąc polecenia jest ignorowana, gdy wywoływane na obiekt, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToggleItalic">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleItalic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleItalic" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleItalic" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleItalic As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleItalic { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToggleItalic : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.ToggleItalic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.ToggleItalic" /> polecenia, które żądania wysyłane przez <see cref="T:System.Windows.Documents.Italic" /> formatowanie zostać przełączona w bieżącym zaznaczeniu.</summary>
        <value>Żądane polecenie.  Gest kluczy domyślne dla tego polecenia jest <see langword="Ctrl" /> + <see langword="I" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Windows.FontStyle> dla bieżącego zaznaczenia jest <xref:System.Windows.FontStyles.Normal%2A>, <xref:System.Windows.FontStyles.Italic%2A> jest stosowany do bieżącego zaznaczenia.  W przeciwnym razie <xref:System.Windows.FontStyles.Normal%2A> jest stosowany.  
  
 Jeśli zaznaczenie jest puste karetka znajduje się w programie word, wybór jest rozwinięta i obejmuje cały wyraz.  
  
 Nie jest zawsze rzeczywistą implementację, który odpowiada na polecenie w dowolnego obiektu; w wielu przypadkach wdrożenia, który odpowiada na polecenie spoczywa składnika zapisywania aplikacji.  
  
 To polecenie jest obsługiwany natywnie <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_ToggleItalic"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="ToggleItalic"/>  
```  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 W tym przykładzie <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (odziedziczone <xref:System.Windows.FrameworkElement>), i że zawiera on natywną obsługę wielu polecenia edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodą jest parametr polecenia.  Polecenia najbardziej edycji Ignoruj parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinna zawierać procedury obsługi dla określonego polecenia.  Ogólnie rzecz biorąc polecenia jest ignorowana, gdy wywoływane na obiekt, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleBold" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleUnderline" />
      </Docs>
    </Member>
    <Member MemberName="ToggleNumbering">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleNumbering { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleNumbering" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleNumbering" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleNumbering As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleNumbering { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToggleNumbering : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.ToggleNumbering" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.ToggleNumbering" /> polecenia, które żąda się, że formatowanie listy uporządkowanej (określane również jako listę numerowaną) zostać przełączona w bieżącym zaznaczeniu.</summary>
        <value>Żądane polecenie.  Gest kluczy domyślne dla tego polecenia jest <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="N" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To polecenie działa na <xref:System.Windows.Documents.Paragraph> poziom.  Jeśli to polecenie jest wywoływane na częściowy wybór zawartości w akapicie (w tym zaznaczenie jest puste, gdzie karetka znajduje się w obrębie akapitu), żądany efekt zastosowany do całego akapitu.  Jeśli to polecenie jest wywoływane na wybór, która obejmuje wiele akapitów, efekt jest stosowany do całej zawartości każdego akapitu, który uczestniczy w zaznaczeniu.  
  
 Nie jest zawsze rzeczywistą implementację, który odpowiada na polecenie w dowolnego obiektu; w wielu przypadkach wdrożenia, który odpowiada na polecenie spoczywa składnika zapisywania aplikacji.  
  
 To polecenie jest obsługiwany natywnie <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_ToggleNumbering"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="ToggleNumbering"/>  
```  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 W tym przykładzie <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (odziedziczone <xref:System.Windows.FrameworkElement>), i że zawiera on natywną obsługę wielu polecenia edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodą jest parametr polecenia.  Polecenia najbardziej edycji Ignoruj parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinna zawierać procedury obsługi dla określonego polecenia.  Ogólnie rzecz biorąc polecenia jest ignorowana, gdy wywoływane na obiekt, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleItalic" />
      </Docs>
    </Member>
    <Member MemberName="ToggleSubscript">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleSubscript { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleSubscript" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleSubscript" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleSubscript As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleSubscript { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToggleSubscript : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.ToggleSubscript" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.ToggleSubscript" /> polecenia, które żąda się, że indeks dolny zostać przełączona w bieżącym zaznaczeniu.</summary>
        <value>Żądane polecenie.  Gest kluczy domyślne dla tego polecenia jest <see langword="Ctrl" /> + <see langword="OemPlus" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest zawsze rzeczywistą implementację, który odpowiada na polecenie w dowolnego obiektu; w wielu przypadkach wdrożenia, który odpowiada na polecenie spoczywa składnika zapisywania aplikacji.  
  
<a name="xamlAttributeUsage_ToggleSubscript"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="ToggleSubscript"/>  
```  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 W tym przykładzie <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (odziedziczone <xref:System.Windows.FrameworkElement>), i że zawiera on natywną obsługę wielu polecenia edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodą jest parametr polecenia.  Polecenia najbardziej edycji Ignoruj parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinna zawierać procedury obsługi dla określonego polecenia.  Ogólnie rzecz biorąc polecenia jest ignorowana, gdy wywoływane na obiekt, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleSuperscript" />
      </Docs>
    </Member>
    <Member MemberName="ToggleSuperscript">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleSuperscript { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleSuperscript" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleSuperscript" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleSuperscript As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleSuperscript { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToggleSuperscript : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.ToggleSuperscript" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.ToggleSuperscript" /> polecenia, które żąda się, że górny zostać przełączona w bieżącym zaznaczeniu.</summary>
        <value>Żądane polecenie.  Gest kluczy domyślne dla tego polecenia jest <see langword="Ctrl" /> + <see langword="Shift" /> + <see langword="OemPlus" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest zawsze rzeczywistą implementację, który odpowiada na polecenie w dowolnego obiektu; w wielu przypadkach wdrożenia, który odpowiada na polecenie spoczywa składnika zapisywania aplikacji.  
  
<a name="xamlAttributeUsage_ToggleSuperscript"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="ToggleSuperscript"/>  
```  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 W tym przykładzie <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (odziedziczone <xref:System.Windows.FrameworkElement>), i że zawiera on natywną obsługę wielu polecenia edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodą jest parametr polecenia.  Polecenia najbardziej edycji Ignoruj parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinna zawierać procedury obsługi dla określonego polecenia.  Ogólnie rzecz biorąc polecenia jest ignorowana, gdy wywoływane na obiekt, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleSubscript" />
      </Docs>
    </Member>
    <Member MemberName="ToggleUnderline">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleUnderline { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleUnderline" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleUnderline" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleUnderline As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleUnderline { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToggleUnderline : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.ToggleUnderline" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje <see cref="P:System.Windows.Documents.EditingCommands.ToggleUnderline" /> polecenia, które żądania wysyłane przez <see cref="T:System.Windows.Documents.Underline" /> formatowanie zostać przełączona w bieżącym zaznaczeniu.</summary>
        <value>Żądane polecenie.  Gest kluczy domyślne dla tego polecenia jest <see langword="Ctrl" /> + <see langword="U" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli zaznaczenie jest puste karetka znajduje się w programie word, wybór jest rozwinięta i obejmuje cały wyraz.  
  
 Nie jest zawsze rzeczywistą implementację, który odpowiada na polecenie w dowolnego obiektu; w wielu przypadkach wdrożenia, który odpowiada na polecenie spoczywa składnika zapisywania aplikacji.  
  
 To polecenie jest obsługiwany natywnie <xref:System.Windows.Controls.RichTextBox>.  
  
<a name="xamlAttributeUsage_ToggleUnderline"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="ToggleUnderline"/>  
```  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób wywołania polecenia edycji na obiekt, który obsługuje polecenie.  
  
 W tym przykładzie <xref:System.Windows.Controls.RichTextBox> służy jako element docelowy polecenia.  Należy pamiętać, że <xref:System.Windows.Controls.RichTextBox> implementuje <xref:System.Windows.IInputElement> interfejsu (odziedziczone <xref:System.Windows.FrameworkElement>), i że zawiera on natywną obsługę wielu polecenia edycji.  
  
 Pierwszy argument dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metodą jest parametr polecenia.  Polecenia najbardziej edycji Ignoruj parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien być `null` dla polecenia edycji.  
  
 Drugi argument określa obiekt, do której będą kierowane polecenia.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinna zawierać procedury obsługi dla określonego polecenia.  Ogólnie rzecz biorąc polecenia jest ignorowana, gdy wywoływane na obiekt, który nie obsługuje polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleBold" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleItalic" />
      </Docs>
    </Member>
  </Members>
</Type>
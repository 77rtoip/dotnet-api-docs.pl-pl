<Type Name="EditingCommands" FullName="System.Windows.Documents.EditingCommands">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e548e08b556eb3bea554b24d86bbc3a1cc4dbe43" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69208813" /></Metadata><TypeSignature Language="C#" Value="public static class EditingCommands" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit EditingCommands extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Documents.EditingCommands" />
  <TypeSignature Language="VB.NET" Value="Public Class EditingCommands" />
  <TypeSignature Language="C++ CLI" Value="public ref class EditingCommands abstract sealed" />
  <TypeSignature Language="F#" Value="type EditingCommands = class" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Zawiera standardowy zestaw poleceń związanych z edycją.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono polecenia edycji i skojarzone domyślne gesty klawiszy (z nazwami kluczy z <xref:System.Windows.Input.Key> i <xref:System.Windows.Input.ModifierKeys> wyliczenia).  
  
|Edycja — polecenie|Gest domyślnego klawisza|  
|---------------------|-------------------------|  
|<xref:System.Windows.Documents.EditingCommands.AlignCenter%2A>|`Ctrl`+`E`|  
|<xref:System.Windows.Documents.EditingCommands.AlignJustify%2A>|`Ctrl`+`J`|  
|<xref:System.Windows.Documents.EditingCommands.AlignLeft%2A>|`Ctrl`+`L`|  
|<xref:System.Windows.Documents.EditingCommands.AlignRight%2A>|`Ctrl`+`R`|  
|<xref:System.Windows.Documents.EditingCommands.Backspace%2A>|`Backspace`|  
|<xref:System.Windows.Documents.EditingCommands.CorrectSpellingError%2A>|Brak gestu domyślnego klucza|  
|<xref:System.Windows.Documents.EditingCommands.DecreaseFontSize%2A>|`Ctrl`+`OemOpenBrackets`|  
|<xref:System.Windows.Documents.EditingCommands.DecreaseIndentation%2A>|`Ctrl`+`Shift`+`T`|  
|<xref:System.Windows.Documents.EditingCommands.Delete%2A>|`Delete`|  
|<xref:System.Windows.Documents.EditingCommands.DeleteNextWord%2A>|`Ctrl`+`Delete`|  
|<xref:System.Windows.Documents.EditingCommands.DeletePreviousWord%2A>|`Ctrl`+`Backspace`|  
|<xref:System.Windows.Documents.EditingCommands.EnterLineBreak%2A>|`Shift`+`Enter`|  
|<xref:System.Windows.Documents.EditingCommands.EnterParagraphBreak%2A>|`Enter`|  
|<xref:System.Windows.Documents.EditingCommands.IgnoreSpellingError%2A>|Brak gestu domyślnego klucza|  
|<xref:System.Windows.Documents.EditingCommands.IncreaseFontSize%2A>|`Ctrl`+`OemCloseBrackets`|  
|<xref:System.Windows.Documents.EditingCommands.IncreaseIndentation%2A>|`Ctrl`+`T`|  
|<xref:System.Windows.Documents.EditingCommands.MoveDownByLine%2A>|`Down`|  
|<xref:System.Windows.Documents.EditingCommands.MoveDownByPage%2A>|`PageDown`|  
|<xref:System.Windows.Documents.EditingCommands.MoveDownByParagraph%2A>|`Ctrl`+`Down`|  
|<xref:System.Windows.Documents.EditingCommands.MoveLeftByCharacter%2A>|`Left`|  
|<xref:System.Windows.Documents.EditingCommands.MoveLeftByWord%2A>|`Ctrl`+`Left`|  
|<xref:System.Windows.Documents.EditingCommands.MoveRightByCharacter%2A>|`Right`|  
|<xref:System.Windows.Documents.EditingCommands.MoveRightByWord%2A>|`Ctrl`+`Right`|  
|<xref:System.Windows.Documents.EditingCommands.MoveToDocumentEnd%2A>|`Ctrl`+`End`|  
|<xref:System.Windows.Documents.EditingCommands.MoveToDocumentStart%2A>|`Ctrl`+`Home`|  
|<xref:System.Windows.Documents.EditingCommands.MoveToLineEnd%2A>|`End`|  
|<xref:System.Windows.Documents.EditingCommands.MoveToLineStart%2A>|`Home`|  
|<xref:System.Windows.Documents.EditingCommands.MoveUpByLine%2A>|`Up`|  
|<xref:System.Windows.Documents.EditingCommands.MoveUpByPage%2A>|`PageUp`|  
|<xref:System.Windows.Documents.EditingCommands.MoveUpByParagraph%2A>|`Ctrl`+`Up`|  
|<xref:System.Windows.Documents.EditingCommands.SelectDownByLine%2A>|`Shift`+`Down`|  
|<xref:System.Windows.Documents.EditingCommands.SelectDownByPage%2A>|`Shift`+`PageDown`|  
|<xref:System.Windows.Documents.EditingCommands.SelectDownByParagraph%2A>|`Ctrl`+`Shift`+`Down`|  
|<xref:System.Windows.Documents.EditingCommands.SelectLeftByCharacter%2A>|`Shift`+`Left`|  
|<xref:System.Windows.Documents.EditingCommands.SelectLeftByWord%2A>|`Ctrl`+`Shift`+`Left`|  
|<xref:System.Windows.Documents.EditingCommands.SelectRightByCharacter%2A>|`Shift`+`Right`|  
|<xref:System.Windows.Documents.EditingCommands.SelectRightByWord%2A>|`Ctrl`+`Shift`+`Right`|  
|<xref:System.Windows.Documents.EditingCommands.SelectToDocumentEnd%2A>|`Ctrl`+`Shift`+`End`|  
|<xref:System.Windows.Documents.EditingCommands.SelectToDocumentStart%2A>|`Ctrl`+`Shift`+`Home`|  
|<xref:System.Windows.Documents.EditingCommands.SelectToLineEnd%2A>|`Shift`+`End`|  
|<xref:System.Windows.Documents.EditingCommands.SelectToLineStart%2A>|`Shift`+`Home`|  
|<xref:System.Windows.Documents.EditingCommands.SelectUpByLine%2A>|`Shift`+`Up`|  
|<xref:System.Windows.Documents.EditingCommands.SelectUpByPage%2A>|`Shift`+`PageUp`|  
|<xref:System.Windows.Documents.EditingCommands.SelectUpByParagraph%2A>|`Ctrl`+`Shift`+`Up`|  
|<xref:System.Windows.Documents.EditingCommands.TabBackward%2A>|`Shift`+`Tab`|  
|<xref:System.Windows.Documents.EditingCommands.TabForward%2A>|`Tab`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleBold%2A>|`Ctrl`+`B`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleBullets%2A>|`Ctrl`+`Shift`+`L`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleInsert%2A>|`Insert`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleItalic%2A>|`Ctrl`+`I`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleNumbering%2A>|`Ctrl`+`Shift`+`N`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleSubscript%2A>|`Ctrl`+`OemPlus`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleSuperscript%2A>|`Ctrl`+`Shift+OemPlus`|  
|<xref:System.Windows.Documents.EditingCommands.ToggleUnderline%2A>|`Ctrl`+`U`|  
  
 Polecenia przenoszenia karetki i rozwijania wyboru, które udostępniają wspólny zestaw domyślnych gestów klawiszy, ogólna różnica polega na dodaniu <xref:System.Windows.Input.ModifierKeys.Shift> klucza do odróżnienia poleceń wyboru od przenoszenia karetki.  Na przykład <xref:System.Windows.Documents.EditingCommands.MoveLeftByCharacter%2A> polecenie ma <xref:System.Windows.Input.ModifierKeys.Shift> <xref:System.Windows.Input.Key.Left>gest klawisza domyślnego, a odpowiadające mu <xref:System.Windows.Documents.EditingCommands.SelectLeftByCharacter%2A> polecenie ma gest + <xref:System.Windows.Input.Key.Left>klawisza domyślnego.  
  
 Ogólnie rzecz biorąc, definicje poleceń dostarczonych przez <xref:System.Windows.Documents.EditingCommands> klasę nie wykorzystują parametrów polecenia `parameter` (parametr oczekiwany przez <xref:System.Windows.Input.ICommand.Execute%2A> metodę).  
  
 Aby uzyskać więcej informacji na temat poleceń i poleceń, zobacz [Omówienie danych wejściowych](~/docs/framework/wpf/advanced/input-overview.md).  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać polecenie edycji na obiekcie, który obsługuje polecenie.  
  
 Na potrzeby tego przykładu <xref:System.Windows.Controls.RichTextBox> służy jako obiekt docelowy polecenia.  Należy pamiętać <xref:System.Windows.Controls.RichTextBox> , że <xref:System.Windows.IInputElement> implementuje interfejs (Dziedziczony <xref:System.Windows.FrameworkElement>z) i zawiera natywną obsługę wielu poleceń edycji.  
  
 Pierwszym argumentem dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metody jest parametr polecenia.  Większość poleceń edycji ignoruje parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien `null` dotyczyć poleceń edycji.  
  
 Drugi argument określa obiekt, do którego zostanie rozesłane polecenie.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinien zawierać procedurę obsługi dla określonego polecenia.  Ogólnie rzecz biorąc, polecenie jest ignorowane w przypadku wywołania na obiekcie, który nie obsługuje tego polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Input.MediaCommands" />
    <altmember cref="T:System.Windows.Input.ApplicationCommands" />
    <altmember cref="T:System.Windows.Input.ComponentCommands" />
    <altmember cref="T:System.Windows.Input.RoutedCommand" />
    <altmember cref="T:System.Windows.Input.RoutedUICommand" />
    <altmember cref="T:System.Windows.Input.CommandBinding" />
    <altmember cref="T:System.Windows.Input.CommandManager" />
    <altmember cref="T:System.Windows.Input.NavigationCommands" />
  </Docs>
  <Members>
    <Member MemberName="AlignCenter">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand AlignCenter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand AlignCenter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.AlignCenter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AlignCenter As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ AlignCenter { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AlignCenter : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.AlignCenter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.EditingCommands.AlignCenter" /> Reprezentuje polecenie, które żąda wyśrodkowania bieżącego akapitu lub zaznaczenia akapitów.</summary>
        <value>Żądane polecenie.  Domyślnym gestem dla tego polecenia jest <see langword="Ctrl" />. + <see langword="E" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To polecenie działa na <xref:System.Windows.Documents.Paragraph> poziomie.  Jeśli to polecenie jest wywoływane dla częściowego zaznaczenia zawartości w obrębie akapitu (w tym pustego zaznaczenia, gdzie karetka znajduje się w akapicie), żądany efekt jest stosowany do całego akapitu.  Jeśli to polecenie jest wywoływane w zaznaczeniu obejmującym wiele akapitów, efekt jest stosowany do całej zawartości każdego akapitu, który uczestniczy w zaznaczeniu.  
  
 Na poniższej ilustracji przedstawiono przykład zawartości wyśrodkowanej.  
  
 ![Zrzut ekranu Wartość właściwości TextAlign środka](~/add/media/flowdoc-textalign-center.png "zrzutu ekranu: Wartość właściwości TextAlign środka")  
  
 To polecenie jest natywnie obsługiwane przez <xref:System.Windows.Controls.RichTextBox>program.  
  
<a name="xamlAttributeUsage_AlignCenter"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="AlignCenter"/>  
```  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać polecenie edycji na obiekcie, który obsługuje polecenie.  
  
 Na potrzeby tego przykładu <xref:System.Windows.Controls.RichTextBox> służy jako obiekt docelowy polecenia.  Należy pamiętać <xref:System.Windows.Controls.RichTextBox> , że <xref:System.Windows.IInputElement> implementuje interfejs (Dziedziczony <xref:System.Windows.FrameworkElement>z) i zawiera natywną obsługę wielu poleceń edycji.  
  
 Pierwszym argumentem dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metody jest parametr polecenia.  Większość poleceń edycji ignoruje parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien `null` dotyczyć poleceń edycji.  
  
 Drugi argument określa obiekt, do którego zostanie rozesłane polecenie.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinien zawierać procedurę obsługi dla określonego polecenia.  Ogólnie rzecz biorąc, polecenie jest ignorowane w przypadku wywołania na obiekcie, który nie obsługuje tego polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignJustify" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignLeft" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignRight" />
      </Docs>
    </Member>
    <Member MemberName="AlignJustify">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand AlignJustify { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand AlignJustify" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.AlignJustify" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AlignJustify As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ AlignJustify { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AlignJustify : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.AlignJustify" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.EditingCommands.AlignJustify" /> Reprezentuje polecenie, które żąda justowania bieżącego akapitu lub zaznaczenia akapitów.</summary>
        <value>Żądane polecenie.  Domyślnym gestem dla tego polecenia jest <see langword="Ctrl" />. + <see langword="J" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To polecenie działa na <xref:System.Windows.Documents.Paragraph> poziomie.  Jeśli to polecenie jest wywoływane dla częściowego zaznaczenia zawartości w obrębie akapitu (w tym pustego zaznaczenia, gdzie karetka znajduje się w akapicie), żądany efekt jest stosowany do całego akapitu.  Jeśli to polecenie jest wywoływane w zaznaczeniu, który obejmuje wiele akapitów, efekt zostanie zastosowany do wszystkich akapitów w zaznaczeniu.  
  
 Gdy zawartość jest uzasadniona, poziomy odstępy w poszczególnych wierszach zawartości są dostosowywane tak, aby wyrównane linie były równe lub zbliżone do szerokości.  Zawartość jest zwykle wyrównana do tworzenia gładkich krawędzi po bokach zawartości.  
  
 Ponieważ jest często krótszy niż reszta, ostatni wiersz w akapicie może pozostać niewyrównany po wywołaniu tego polecenia.  
  
 Poniższy rysunek przedstawia zawartość niewyrównanych (wyrównanych do lewej).  
  
 ![Zrzut ekranu Zawartość jest nieuzasadnionego](~/add/media/content-unjustified.png "zrzutu ekranu: Zawartość jest niewyrównana")  
  
 Na poniższej ilustracji przedstawiono tę samą zawartość po jej wyjustowania.  
  
 ![Zrzut ekranu przedstawiający tekst wyjustowany do zawartości] (~/add/media/content-justified.png "Zrzut ekranu przedstawiający tekst wyjustowany do zawartości")  
  
 Nie jest konieczna rzeczywista implementacja, która reaguje na to polecenie na żadnym z określonych obiektów; w wielu przypadkach implementacja, która reaguje na polecenie, jest odpowiedzialna za moduł zapisujący aplikacji.  
  
 To polecenie jest natywnie obsługiwane przez <xref:System.Windows.Controls.RichTextBox>program.  
  
<a name="xamlAttributeUsage_AlignJustify"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="AlignJustify"/>  
```  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać polecenie edycji na obiekcie, który obsługuje polecenie.  
  
 Na potrzeby tego przykładu <xref:System.Windows.Controls.RichTextBox> służy jako obiekt docelowy polecenia.  Należy pamiętać <xref:System.Windows.Controls.RichTextBox> , że <xref:System.Windows.IInputElement> implementuje interfejs (Dziedziczony <xref:System.Windows.FrameworkElement>z) i zawiera natywną obsługę wielu poleceń edycji.  
  
 Pierwszym argumentem dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metody jest parametr polecenia.  Większość poleceń edycji ignoruje parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien `null` dotyczyć poleceń edycji.  
  
 Drugi argument określa obiekt, do którego zostanie rozesłane polecenie.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinien zawierać procedurę obsługi dla określonego polecenia.  Ogólnie rzecz biorąc, polecenie jest ignorowane w przypadku wywołania na obiekcie, który nie obsługuje tego polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignCenter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignLeft" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignRight" />
      </Docs>
    </Member>
    <Member MemberName="AlignLeft">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand AlignLeft { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand AlignLeft" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.AlignLeft" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AlignLeft As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ AlignLeft { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AlignLeft : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.AlignLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.EditingCommands.AlignLeft" /> Reprezentuje polecenie, które żąda, aby zaznaczenie zawartości było wyrównane do lewej strony.</summary>
        <value>Żądane polecenie.  Domyślnym gestem dla tego polecenia jest <see langword="Ctrl" />. + <see langword="L" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To polecenie działa na <xref:System.Windows.Documents.Paragraph> poziomie.  Jeśli to polecenie jest wywoływane dla częściowego zaznaczenia zawartości w obrębie akapitu (w tym pustego zaznaczenia, gdzie karetka znajduje się w akapicie), żądany efekt jest stosowany do całego akapitu.  Jeśli to polecenie jest wywoływane w zaznaczeniu obejmującym wiele akapitów, efekt jest stosowany do całej zawartości każdego akapitu, który uczestniczy w zaznaczeniu.  
  
 Na poniższej ilustracji przedstawiono przykład zawartości wyrównanej do lewej.  
  
 ![Zrzut ekranu Wartość właściwości TextAlign dla]lewego(~/add/media/flowdoc-textalign-left.png "zrzutu ekranu: Wartość właściwości TextAlign z lewej")  
  
 Nie jest konieczna rzeczywista implementacja, która reaguje na to polecenie na żadnym z określonych obiektów; w wielu przypadkach implementacja, która reaguje na polecenie, jest odpowiedzialna za moduł zapisujący aplikacji.  
  
 To polecenie jest natywnie obsługiwane przez <xref:System.Windows.Controls.RichTextBox>program.  
  
<a name="xamlAttributeUsage_AlignLeft"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="AlignLeft"/>  
```  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać polecenie edycji na obiekcie, który obsługuje polecenie.  
  
 Na potrzeby tego przykładu <xref:System.Windows.Controls.RichTextBox> służy jako obiekt docelowy polecenia.  Należy pamiętać <xref:System.Windows.Controls.RichTextBox> , że <xref:System.Windows.IInputElement> implementuje interfejs (Dziedziczony <xref:System.Windows.FrameworkElement>z) i zawiera natywną obsługę wielu poleceń edycji.  
  
 Pierwszym argumentem dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metody jest parametr polecenia.  Większość poleceń edycji ignoruje parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien `null` dotyczyć poleceń edycji.  
  
 Drugi argument określa obiekt, do którego zostanie rozesłane polecenie.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinien zawierać procedurę obsługi dla określonego polecenia.  Ogólnie rzecz biorąc, polecenie jest ignorowane w przypadku wywołania na obiekcie, który nie obsługuje tego polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignCenter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignJustify" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignRight" />
      </Docs>
    </Member>
    <Member MemberName="AlignRight">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand AlignRight { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand AlignRight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.AlignRight" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AlignRight As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ AlignRight { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AlignRight : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.AlignRight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.EditingCommands.AlignRight" /> Reprezentuje polecenie, które żąda, aby wybór zawartości był wyrównany do prawej strony.</summary>
        <value>Żądane polecenie.  Domyślnym gestem dla tego polecenia jest <see langword="Ctrl" />. + <see langword="R" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To polecenie działa na <xref:System.Windows.Documents.Paragraph> poziomie.  Jeśli to polecenie jest wywoływane dla częściowego zaznaczenia zawartości w obrębie akapitu (w tym pustego zaznaczenia, gdzie karetka znajduje się w akapicie), żądany efekt jest stosowany do całego akapitu.  Jeśli to polecenie jest wywoływane w zaznaczeniu obejmującym wiele akapitów, efekt jest stosowany do całej zawartości każdego akapitu, który uczestniczy w zaznaczeniu.  
  
 Na poniższej ilustracji przedstawiono przykład zawartości wyrównanej do prawej.  
  
 ![Zrzut ekranu Wartość TextAlign na]prawym(~/add/media/flowdoc-textalign-right.png "zrzucie ekranu: Wartość TextAlign z prawej")  
  
 Nie jest konieczna rzeczywista implementacja, która reaguje na to polecenie na żadnym z określonych obiektów; w wielu przypadkach implementacja, która reaguje na polecenie, jest odpowiedzialna za moduł zapisujący aplikacji.  
  
 To polecenie jest natywnie obsługiwane przez <xref:System.Windows.Controls.RichTextBox>program.  
  
<a name="xamlAttributeUsage_AlignRight"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="AlignRight"/>  
```  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać polecenie edycji na obiekcie, który obsługuje polecenie.  
  
 Na potrzeby tego przykładu <xref:System.Windows.Controls.RichTextBox> służy jako obiekt docelowy polecenia.  Należy pamiętać <xref:System.Windows.Controls.RichTextBox> , że <xref:System.Windows.IInputElement> implementuje interfejs (Dziedziczony <xref:System.Windows.FrameworkElement>z) i zawiera natywną obsługę wielu poleceń edycji.  
  
 Pierwszym argumentem dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metody jest parametr polecenia.  Większość poleceń edycji ignoruje parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien `null` dotyczyć poleceń edycji.  
  
 Drugi argument określa obiekt, do którego zostanie rozesłane polecenie.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinien zawierać procedurę obsługi dla określonego polecenia.  Ogólnie rzecz biorąc, polecenie jest ignorowane w przypadku wywołania na obiekcie, który nie obsługuje tego polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignCenter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignJustify" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.AlignRight" />
      </Docs>
    </Member>
    <Member MemberName="Backspace">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand Backspace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand Backspace" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.Backspace" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Backspace As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ Backspace { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Backspace : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.Backspace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.EditingCommands.Backspace" /> Reprezentuje polecenie, które żąda wprowadzenia Backspace w bieżącym położeniu lub w bieżącym zaznaczeniu.</summary>
        <value>Żądane polecenie.  Domyślnym gestem dla tego polecenia jest <see langword="Backspace" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po wywołaniu pustego zaznaczenia to polecenie usuwa separator akapitu tuż przed karetką. Po wywołaniu dla niepustego zaznaczenia to polecenie usuwa zaznaczenie.  
  
 To polecenie zachowuje formatowanie usuniętego zaznaczenia dla zawartości bezpośrednio wstawionej w tej samej lokalizacji po wywołaniu tego polecenia.  Z drugiej strony <xref:System.Windows.Documents.EditingCommands.Delete%2A> polecenie, które nie zachowuje poprzedniego formatowania.  
  
 Nie jest konieczna rzeczywista implementacja, która reaguje na to polecenie na żadnym z określonych obiektów; w wielu przypadkach implementacja, która reaguje na polecenie, jest odpowiedzialna za moduł zapisujący aplikacji.  
  
 To polecenie jest natywnie obsługiwane przez <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_Backspace"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="Backspace"/>  
```  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać polecenie edycji na obiekcie, który obsługuje polecenie.  
  
 Na potrzeby tego przykładu <xref:System.Windows.Controls.RichTextBox> służy jako obiekt docelowy polecenia.  Należy pamiętać <xref:System.Windows.Controls.RichTextBox> , że <xref:System.Windows.IInputElement> implementuje interfejs (Dziedziczony <xref:System.Windows.FrameworkElement>z) i zawiera natywną obsługę wielu poleceń edycji.  
  
 Pierwszym argumentem dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metody jest parametr polecenia.  Większość poleceń edycji ignoruje parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien `null` dotyczyć poleceń edycji.  
  
 Drugi argument określa obiekt, do którego zostanie rozesłane polecenie.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinien zawierać procedurę obsługi dla określonego polecenia.  Ogólnie rzecz biorąc, polecenie jest ignorowane w przypadku wywołania na obiekcie, który nie obsługuje tego polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CorrectSpellingError">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand CorrectSpellingError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand CorrectSpellingError" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.CorrectSpellingError" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CorrectSpellingError As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ CorrectSpellingError { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CorrectSpellingError : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.CorrectSpellingError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.EditingCommands.CorrectSpellingError" /> Reprezentuje polecenie, które żąda skorygowania dowolnego błędnego wyrazu w bieżącym położeniu.</summary>
        <value>Żądane polecenie.  To polecenie nie ma gestu domyślnego klucza.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest konieczna rzeczywista implementacja, która reaguje na to polecenie na żadnym z określonych obiektów; w wielu przypadkach implementacja, która reaguje na polecenie, jest odpowiedzialna za moduł zapisujący aplikacji.  
  
<a name="xamlAttributeUsage_CorrectSpellingError"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="CorrectSpellingError"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.IgnoreSpellingError" />
      </Docs>
    </Member>
    <Member MemberName="DecreaseFontSize">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand DecreaseFontSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand DecreaseFontSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.DecreaseFontSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DecreaseFontSize As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ DecreaseFontSize { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DecreaseFontSize : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.DecreaseFontSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.EditingCommands.DecreaseFontSize" /> Reprezentuje polecenie, które żąda zmniejszenia rozmiaru czcionki dla bieżącego zaznaczenia o 1 punkt.</summary>
        <value>Żądane polecenie.  Domyślnym gestem dla tego polecenia jest <see langword="Ctrl" />. + <see langword="OemOpenBrackets" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli to polecenie jest wywoływane na pustym zaznaczeniu, gdzie karetka znajduje się w obrębie słowa, zaznaczenie zostanie automatycznie rozwinięte, aby zastosować polecenie do całego wyrazu.  
  
 Nie jest konieczna rzeczywista implementacja, która reaguje na to polecenie na żadnym z określonych obiektów; w wielu przypadkach implementacja, która reaguje na polecenie, jest odpowiedzialna za moduł zapisujący aplikacji.  
  
 To polecenie jest natywnie obsługiwane przez <xref:System.Windows.Controls.RichTextBox>program.  
  
<a name="xamlAttributeUsage_DecreaseFontSize"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="DecreaseFontSize"/>  
```  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać polecenie edycji na obiekcie, który obsługuje polecenie.  
  
 Na potrzeby tego przykładu <xref:System.Windows.Controls.RichTextBox> służy jako obiekt docelowy polecenia.  Należy pamiętać <xref:System.Windows.Controls.RichTextBox> , że <xref:System.Windows.IInputElement> implementuje interfejs (Dziedziczony <xref:System.Windows.FrameworkElement>z) i zawiera natywną obsługę wielu poleceń edycji.  
  
 Pierwszym argumentem dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metody jest parametr polecenia.  Większość poleceń edycji ignoruje parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien `null` dotyczyć poleceń edycji.  
  
 Drugi argument określa obiekt, do którego zostanie rozesłane polecenie.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinien zawierać procedurę obsługi dla określonego polecenia.  Ogólnie rzecz biorąc, polecenie jest ignorowane w przypadku wywołania na obiekcie, który nie obsługuje tego polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.IncreaseFontSize" />
      </Docs>
    </Member>
    <Member MemberName="DecreaseIndentation">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand DecreaseIndentation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand DecreaseIndentation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.DecreaseIndentation" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DecreaseIndentation As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ DecreaseIndentation { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DecreaseIndentation : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.DecreaseIndentation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.EditingCommands.DecreaseIndentation" /> Reprezentuje polecenie, które żąda zmniejszenia wcięcia bieżącego akapitu o jeden tabulator.</summary>
        <value>Żądane polecenie.  Domyślnym <see langword="Ctrl" />gestem dla tego polecenia jest. + <see langword="Shift" /> + <see langword="T" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest konieczna rzeczywista implementacja, która reaguje na to polecenie na żadnym z określonych obiektów; w wielu przypadkach implementacja, która reaguje na polecenie, jest odpowiedzialna za moduł zapisujący aplikacji.  
  
 To polecenie jest natywnie obsługiwane przez <xref:System.Windows.Controls.RichTextBox>program.  
  
> [!IMPORTANT]
>  To polecenie nie ma wpływu na element tekstowy, <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsTab%2A> chyba że właściwość elementu tekstowego jest ustawiona na. `true`  
  
<a name="xamlAttributeUsage_DecreaseIndentation"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="DecreaseIndentation"/>  
```  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać polecenie edycji na obiekcie, który obsługuje polecenie.  
  
 Na potrzeby tego przykładu <xref:System.Windows.Controls.RichTextBox> służy jako obiekt docelowy polecenia.  Należy pamiętać <xref:System.Windows.Controls.RichTextBox> , że <xref:System.Windows.IInputElement> implementuje interfejs (Dziedziczony <xref:System.Windows.FrameworkElement>z) i zawiera natywną obsługę wielu poleceń edycji.  
  
 Pierwszym argumentem dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metody jest parametr polecenia.  Większość poleceń edycji ignoruje parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien `null` dotyczyć poleceń edycji.  
  
 Drugi argument określa obiekt, do którego zostanie rozesłane polecenie.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinien zawierać procedurę obsługi dla określonego polecenia.  Ogólnie rzecz biorąc, polecenie jest ignorowane w przypadku wywołania na obiekcie, który nie obsługuje tego polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.IncreaseIndentation" />
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand Delete { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand Delete" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.Delete" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Delete As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ Delete { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Delete : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.Delete" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.EditingCommands.Delete" /> Reprezentuje polecenie, które żąda usunięcia bieżącego zaznaczenia.</summary>
        <value>Żądane polecenie.  Domyślnym gestem dla tego polecenia jest <see langword="Delete" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To polecenie odrzuca wszelkie formatowanie usuniętego zaznaczenia.  Z kolei z <xref:System.Windows.Documents.EditingCommands.Backspace%2A> poleceniem, które zachowuje formatowanie usuniętego zaznaczenia dla zawartości bezpośrednio wstawionej w tej samej lokalizacji po wywołaniu tego polecenia.  
  
 Nie jest konieczna rzeczywista implementacja, która reaguje na to polecenie na żadnym z określonych obiektów; w wielu przypadkach implementacja, która reaguje na polecenie, jest odpowiedzialna za moduł zapisujący aplikacji.  
  
 To polecenie jest natywnie obsługiwane przez <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_Delete"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="Delete"/>  
```  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać polecenie edycji na obiekcie, który obsługuje polecenie.  
  
 Na potrzeby tego przykładu <xref:System.Windows.Controls.RichTextBox> służy jako obiekt docelowy polecenia.  Należy pamiętać <xref:System.Windows.Controls.RichTextBox> , że <xref:System.Windows.IInputElement> implementuje interfejs (Dziedziczony <xref:System.Windows.FrameworkElement>z) i zawiera natywną obsługę wielu poleceń edycji.  
  
 Pierwszym argumentem dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metody jest parametr polecenia.  Większość poleceń edycji ignoruje parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien `null` dotyczyć poleceń edycji.  
  
 Drugi argument określa obiekt, do którego zostanie rozesłane polecenie.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinien zawierać procedurę obsługi dla określonego polecenia.  Ogólnie rzecz biorąc, polecenie jest ignorowane w przypadku wywołania na obiekcie, który nie obsługuje tego polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeleteNextWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand DeleteNextWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand DeleteNextWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.DeleteNextWord" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DeleteNextWord As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ DeleteNextWord { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeleteNextWord : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.DeleteNextWord" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.EditingCommands.DeleteNextWord" /> Reprezentuje polecenie, które żąda usunięcia następnego wyrazu (względem bieżącego położenia).</summary>
        <value>Żądane polecenie.  Domyślnym gestem dla tego polecenia jest <see langword="Ctrl" />. + <see langword="Delete" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli karetka znajduje się w obrębie słowa, pozostała część wyrazu między bieżącą pozycją a końcem wyrazu zostanie usunięta.  
  
 Nie jest konieczna rzeczywista implementacja, która reaguje na to polecenie na żadnym z określonych obiektów; w wielu przypadkach implementacja, która reaguje na polecenie, jest odpowiedzialna za moduł zapisujący aplikacji.  
  
 To polecenie jest natywnie obsługiwane przez <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_DeleteNextWord"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="DeleteNextWord"/>  
```  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać polecenie edycji na obiekcie, który obsługuje polecenie.  
  
 Na potrzeby tego przykładu <xref:System.Windows.Controls.RichTextBox> służy jako obiekt docelowy polecenia.  Należy pamiętać <xref:System.Windows.Controls.RichTextBox> , że <xref:System.Windows.IInputElement> implementuje interfejs (Dziedziczony <xref:System.Windows.FrameworkElement>z) i zawiera natywną obsługę wielu poleceń edycji.  
  
 Pierwszym argumentem dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metody jest parametr polecenia.  Większość poleceń edycji ignoruje parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien `null` dotyczyć poleceń edycji.  
  
 Drugi argument określa obiekt, do którego zostanie rozesłane polecenie.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinien zawierać procedurę obsługi dla określonego polecenia.  Ogólnie rzecz biorąc, polecenie jest ignorowane w przypadku wywołania na obiekcie, który nie obsługuje tego polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.DeletePreviousWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
      </Docs>
    </Member>
    <Member MemberName="DeletePreviousWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand DeletePreviousWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand DeletePreviousWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.DeletePreviousWord" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DeletePreviousWord As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ DeletePreviousWord { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeletePreviousWord : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.DeletePreviousWord" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.EditingCommands.DeletePreviousWord" /> Reprezentuje polecenie, które żąda usunięcia poprzedniego wyrazu (względem bieżącego położenia).</summary>
        <value>Żądane polecenie.  Domyślnym gestem dla tego polecenia jest <see langword="Ctrl" />. + <see langword="Backspace" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli karetka znajduje się w obrębie słowa, pozostała część wyrazu między bieżącą pozycją a początkiem wyrazu zostanie usunięta.  
  
 Nie jest konieczna rzeczywista implementacja, która reaguje na to polecenie na żadnym z określonych obiektów; w wielu przypadkach implementacja, która reaguje na polecenie, jest odpowiedzialna za moduł zapisujący aplikacji.  
  
 To polecenie jest natywnie obsługiwane przez <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_DeletePreviousWord"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="DeletePreviousWord"/>  
```  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać polecenie edycji na obiekcie, który obsługuje polecenie.  
  
 Na potrzeby tego przykładu <xref:System.Windows.Controls.RichTextBox> służy jako obiekt docelowy polecenia.  Należy pamiętać <xref:System.Windows.Controls.RichTextBox> , że <xref:System.Windows.IInputElement> implementuje interfejs (Dziedziczony <xref:System.Windows.FrameworkElement>z) i zawiera natywną obsługę wielu poleceń edycji.  
  
 Pierwszym argumentem dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metody jest parametr polecenia.  Większość poleceń edycji ignoruje parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien `null` dotyczyć poleceń edycji.  
  
 Drugi argument określa obiekt, do którego zostanie rozesłane polecenie.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinien zawierać procedurę obsługi dla określonego polecenia.  Ogólnie rzecz biorąc, polecenie jest ignorowane w przypadku wywołania na obiekcie, który nie obsługuje tego polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.DeleteNextWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
      </Docs>
    </Member>
    <Member MemberName="EnterLineBreak">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand EnterLineBreak { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand EnterLineBreak" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.EnterLineBreak" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property EnterLineBreak As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ EnterLineBreak { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EnterLineBreak : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.EnterLineBreak" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.EditingCommands.EnterLineBreak" /> Reprezentuje polecenie, które żąda wstawiania podziału wiersza w bieżącym położeniu lub w bieżącym zaznaczeniu.</summary>
        <value>Żądane polecenie.  Domyślnym gestem dla tego polecenia jest <see langword="Shift" />. + <see langword="Enter" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dla edytorów, które obsługują zawartość przepływu, <xref:System.Windows.Controls.RichTextBox>takich jak polecenie <xref:System.Windows.Documents.LineBreak> powoduje, że element zostanie wstawiony w bieżącym położeniu.  
  
 Nie jest konieczna rzeczywista implementacja, która reaguje na to polecenie na żadnym z określonych obiektów; w wielu przypadkach implementacja, która reaguje na polecenie, jest odpowiedzialna za moduł zapisujący aplikacji.  
  
 To polecenie jest natywnie obsługiwane przez <xref:System.Windows.Controls.RichTextBox> program <xref:System.Windows.Controls.TextBox>i.  
  
<a name="xamlAttributeUsage_EnterLineBreak"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="EnterLineBreak"/>  
```  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać polecenie edycji na obiekcie, który obsługuje polecenie.  
  
 Na potrzeby tego przykładu <xref:System.Windows.Controls.RichTextBox> służy jako obiekt docelowy polecenia.  Należy pamiętać <xref:System.Windows.Controls.RichTextBox> , że <xref:System.Windows.IInputElement> implementuje interfejs (Dziedziczony <xref:System.Windows.FrameworkElement>z) i zawiera natywną obsługę wielu poleceń edycji.  
  
 Pierwszym argumentem dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metody jest parametr polecenia.  Większość poleceń edycji ignoruje parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien `null` dotyczyć poleceń edycji.  
  
 Drugi argument określa obiekt, do którego zostanie rozesłane polecenie.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinien zawierać procedurę obsługi dla określonego polecenia.  Ogólnie rzecz biorąc, polecenie jest ignorowane w przypadku wywołania na obiekcie, który nie obsługuje tego polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.EnterParagraphBreak" />
      </Docs>
    </Member>
    <Member MemberName="EnterParagraphBreak">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand EnterParagraphBreak { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand EnterParagraphBreak" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.EnterParagraphBreak" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property EnterParagraphBreak As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ EnterParagraphBreak { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EnterParagraphBreak : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.EnterParagraphBreak" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.EditingCommands.EnterParagraphBreak" /> Reprezentuje polecenie, które żąda wstawiania podziału akapitu w bieżącym położeniu lub w bieżącym zaznaczeniu.</summary>
        <value>Żądane polecenie.  Domyślnym gestem dla tego polecenia jest <see langword="Enter" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To polecenie jest równoznaczne z naciśnięciem klawisza ENTER.  
  
 Nie jest konieczna rzeczywista implementacja, która reaguje na to polecenie na żadnym z określonych obiektów; w wielu przypadkach implementacja, która reaguje na polecenie, jest odpowiedzialna za moduł zapisujący aplikacji.  
  
 To polecenie jest natywnie obsługiwane przez <xref:System.Windows.Controls.RichTextBox> program <xref:System.Windows.Controls.TextBox> i (gdy <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsReturn%2A> właściwość ma `true`wartość).  
  
> [!IMPORTANT]
>  To polecenie nie ma wpływu na element tekstowy, <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsReturn%2A> chyba że właściwość elementu tekstowego jest ustawiona na. `true`  
  
<a name="xamlAttributeUsage_EnterParagraphBreak"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="EnterParagraphBreak"/>  
```  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać polecenie edycji na obiekcie, który obsługuje polecenie.  
  
 Na potrzeby tego przykładu <xref:System.Windows.Controls.RichTextBox> służy jako obiekt docelowy polecenia.  Należy pamiętać <xref:System.Windows.Controls.RichTextBox> , że <xref:System.Windows.IInputElement> implementuje interfejs (Dziedziczony <xref:System.Windows.FrameworkElement>z) i zawiera natywną obsługę wielu poleceń edycji.  
  
 Pierwszym argumentem dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metody jest parametr polecenia.  Większość poleceń edycji ignoruje parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien `null` dotyczyć poleceń edycji.  
  
 Drugi argument określa obiekt, do którego zostanie rozesłane polecenie.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinien zawierać procedurę obsługi dla określonego polecenia.  Ogólnie rzecz biorąc, polecenie jest ignorowane w przypadku wywołania na obiekcie, który nie obsługuje tego polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.EnterLineBreak" />
      </Docs>
    </Member>
    <Member MemberName="IgnoreSpellingError">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand IgnoreSpellingError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand IgnoreSpellingError" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.IgnoreSpellingError" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IgnoreSpellingError As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ IgnoreSpellingError { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.IgnoreSpellingError : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.IgnoreSpellingError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.EditingCommands.IgnoreSpellingError" /> Reprezentuje polecenie, które żąda, aby wszystkie wystąpienia błędnie napisanych wyrazów w bieżącym położeniu lub w bieżącym zaznaczeniu zostały zignorowane.</summary>
        <value>Żądane polecenie.  To polecenie nie ma gestu domyślnego klucza.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest konieczna rzeczywista implementacja, która reaguje na to polecenie na żadnym z określonych obiektów; w wielu przypadkach implementacja, która reaguje na polecenie, jest odpowiedzialna za moduł zapisujący aplikacji.  
  
<a name="xamlAttributeUsage_IgnoreSpellingError"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="IgnoreSpellingError"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.CorrectSpellingError" />
      </Docs>
    </Member>
    <Member MemberName="IncreaseFontSize">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand IncreaseFontSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand IncreaseFontSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.IncreaseFontSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IncreaseFontSize As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ IncreaseFontSize { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.IncreaseFontSize : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.IncreaseFontSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.EditingCommands.IncreaseFontSize" /> Reprezentuje polecenie, które żąda zwiększenia rozmiaru czcionki dla bieżącego zaznaczenia o 1 punkt.</summary>
        <value>Żądane polecenie.  Domyślnym gestem dla tego polecenia jest <see langword="Ctrl" />. + <see langword="OemCloseBrackets" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli to polecenie jest wywoływane na pustym zaznaczeniu, gdzie karetka znajduje się w obrębie wyrazu, zaznaczenie zostanie rozwinięte, aby zastosować polecenie do całego wyrazu.  
  
 Nie jest konieczna rzeczywista implementacja, która reaguje na to polecenie na żadnym z określonych obiektów; w wielu przypadkach implementacja, która reaguje na polecenie, jest odpowiedzialna za moduł zapisujący aplikacji.  
  
 To polecenie jest natywnie obsługiwane przez <xref:System.Windows.Controls.RichTextBox>program.  
  
<a name="xamlAttributeUsage_IncreaseFontSize"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="IncreaseFontSize"/>  
```  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać polecenie edycji na obiekcie, który obsługuje polecenie.  
  
 Na potrzeby tego przykładu <xref:System.Windows.Controls.RichTextBox> służy jako obiekt docelowy polecenia.  Należy pamiętać <xref:System.Windows.Controls.RichTextBox> , że <xref:System.Windows.IInputElement> implementuje interfejs (Dziedziczony <xref:System.Windows.FrameworkElement>z) i zawiera natywną obsługę wielu poleceń edycji.  
  
 Pierwszym argumentem dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metody jest parametr polecenia.  Większość poleceń edycji ignoruje parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien `null` dotyczyć poleceń edycji.  
  
 Drugi argument określa obiekt, do którego zostanie rozesłane polecenie.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinien zawierać procedurę obsługi dla określonego polecenia.  Ogólnie rzecz biorąc, polecenie jest ignorowane w przypadku wywołania na obiekcie, który nie obsługuje tego polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.DecreaseFontSize" />
      </Docs>
    </Member>
    <Member MemberName="IncreaseIndentation">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand IncreaseIndentation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand IncreaseIndentation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.IncreaseIndentation" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IncreaseIndentation As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ IncreaseIndentation { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.IncreaseIndentation : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.IncreaseIndentation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.EditingCommands.IncreaseIndentation" /> Reprezentuje polecenie, które żąda zwiększenia wcięcia bieżącego akapitu o jeden tabulator.</summary>
        <value>Żądane polecenie.  Domyślnym gestem dla tego polecenia jest <see langword="Ctrl" />. + <see langword="T" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest konieczna rzeczywista implementacja, która reaguje na to polecenie na żadnym z określonych obiektów; w wielu przypadkach implementacja, która reaguje na polecenie, jest odpowiedzialna za moduł zapisujący aplikacji.  
  
 To polecenie jest natywnie obsługiwane przez <xref:System.Windows.Controls.RichTextBox>program.  
  
> [!IMPORTANT]
>  To polecenie nie ma wpływu na element tekstowy, <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsTab%2A> chyba że właściwość elementu tekstowego jest ustawiona na. `true`  
  
<a name="xamlAttributeUsage_IncreaseIndentation"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="IncreaseIndentation"/>  
```  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać polecenie edycji na obiekcie, który obsługuje polecenie.  
  
 Na potrzeby tego przykładu <xref:System.Windows.Controls.RichTextBox> służy jako obiekt docelowy polecenia.  Należy pamiętać <xref:System.Windows.Controls.RichTextBox> , że <xref:System.Windows.IInputElement> implementuje interfejs (Dziedziczony <xref:System.Windows.FrameworkElement>z) i zawiera natywną obsługę wielu poleceń edycji.  
  
 Pierwszym argumentem dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metody jest parametr polecenia.  Większość poleceń edycji ignoruje parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien `null` dotyczyć poleceń edycji.  
  
 Drugi argument określa obiekt, do którego zostanie rozesłane polecenie.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinien zawierać procedurę obsługi dla określonego polecenia.  Ogólnie rzecz biorąc, polecenie jest ignorowane w przypadku wywołania na obiekcie, który nie obsługuje tego polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.DecreaseIndentation" />
      </Docs>
    </Member>
    <Member MemberName="MoveDownByLine">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveDownByLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveDownByLine" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveDownByLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveDownByLine As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveDownByLine { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveDownByLine : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveDownByLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.EditingCommands.MoveDownByLine" /> Reprezentuje polecenie, które żąda przejścia w dół o jeden wiersz w dół.</summary>
        <value>Żądane polecenie.  Domyślnym gestem dla tego polecenia jest <see langword="Down" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest konieczna rzeczywista implementacja, która reaguje na to polecenie na żadnym z określonych obiektów; w wielu przypadkach implementacja, która reaguje na polecenie, jest odpowiedzialna za moduł zapisujący aplikacji.  
  
 To polecenie jest natywnie obsługiwane przez <xref:System.Windows.Controls.RichTextBox> program <xref:System.Windows.Controls.TextBox>i.  
  
<a name="xamlAttributeUsage_MoveDownByLine"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="MoveDownByLine"/>  
```  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać polecenie edycji na obiekcie, który obsługuje polecenie.  
  
 Na potrzeby tego przykładu <xref:System.Windows.Controls.RichTextBox> służy jako obiekt docelowy polecenia.  Należy pamiętać <xref:System.Windows.Controls.RichTextBox> , że <xref:System.Windows.IInputElement> implementuje interfejs (Dziedziczony <xref:System.Windows.FrameworkElement>z) i zawiera natywną obsługę wielu poleceń edycji.  
  
 Pierwszym argumentem dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metody jest parametr polecenia.  Większość poleceń edycji ignoruje parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien `null` dotyczyć poleceń edycji.  
  
 Drugi argument określa obiekt, do którego zostanie rozesłane polecenie.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinien zawierać procedurę obsługi dla określonego polecenia.  Ogólnie rzecz biorąc, polecenie jest ignorowane w przypadku wywołania na obiekcie, który nie obsługuje tego polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByLine" />
      </Docs>
    </Member>
    <Member MemberName="MoveDownByPage">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveDownByPage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveDownByPage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveDownByPage" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveDownByPage As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveDownByPage { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveDownByPage : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveDownByPage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.EditingCommands.MoveDownByPage" /> Reprezentuje polecenie, które powoduje, że karetka przesunie się o jedną stronę w dół.</summary>
        <value>Żądane polecenie.  Domyślnym gestem dla tego polecenia jest <see langword="PageDown" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest konieczna rzeczywista implementacja, która reaguje na to polecenie na żadnym z określonych obiektów; w wielu przypadkach implementacja, która reaguje na polecenie, jest odpowiedzialna za moduł zapisujący aplikacji.  
  
 To polecenie jest natywnie obsługiwane przez <xref:System.Windows.Controls.RichTextBox> program <xref:System.Windows.Controls.TextBox>i.  
  
<a name="xamlAttributeUsage_MoveDownByPage"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="MoveDownByPage"/>  
```  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać polecenie edycji na obiekcie, który obsługuje polecenie.  
  
 Na potrzeby tego przykładu <xref:System.Windows.Controls.RichTextBox> służy jako obiekt docelowy polecenia.  Należy pamiętać <xref:System.Windows.Controls.RichTextBox> , że <xref:System.Windows.IInputElement> implementuje interfejs (Dziedziczony <xref:System.Windows.FrameworkElement>z) i zawiera natywną obsługę wielu poleceń edycji.  
  
 Pierwszym argumentem dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metody jest parametr polecenia.  Większość poleceń edycji ignoruje parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien `null` dotyczyć poleceń edycji.  
  
 Drugi argument określa obiekt, do którego zostanie rozesłane polecenie.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinien zawierać procedurę obsługi dla określonego polecenia.  Ogólnie rzecz biorąc, polecenie jest ignorowane w przypadku wywołania na obiekcie, który nie obsługuje tego polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByPage" />
      </Docs>
    </Member>
    <Member MemberName="MoveDownByParagraph">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveDownByParagraph { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveDownByParagraph" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveDownByParagraph As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveDownByParagraph { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveDownByParagraph : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveDownByParagraph" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" /> Reprezentuje polecenie, które wymaga, aby karetka przesunie się o jeden akapit w dół.</summary>
        <value>Żądane polecenie.  Domyślnym gestem dla tego polecenia jest <see langword="Ctrl" />. + <see langword="Down" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To polecenie umieszcza karetkę na początku następnego akapitu.  
  
 To polecenie zachowuje się <xref:System.Windows.Documents.EditingCommands.MoveToDocumentEnd%2A> <xref:System.Windows.Controls.TextBox>jak w przypadku wywołania w.  
  
 Nie jest konieczna rzeczywista implementacja, która reaguje na to polecenie na żadnym z określonych obiektów; w wielu przypadkach implementacja, która reaguje na polecenie, jest odpowiedzialna za moduł zapisujący aplikacji.  
  
 To polecenie jest natywnie obsługiwane przez <xref:System.Windows.Controls.RichTextBox> program <xref:System.Windows.Controls.TextBox>i.  
  
<a name="xamlAttributeUsage_MoveDownByParagraph"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="MoveDownByParagraph"/>  
```  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać polecenie edycji na obiekcie, który obsługuje polecenie.  
  
 Na potrzeby tego przykładu <xref:System.Windows.Controls.RichTextBox> służy jako obiekt docelowy polecenia.  Należy pamiętać <xref:System.Windows.Controls.RichTextBox> , że <xref:System.Windows.IInputElement> implementuje interfejs (Dziedziczony <xref:System.Windows.FrameworkElement>z) i zawiera natywną obsługę wielu poleceń edycji.  
  
 Pierwszym argumentem dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metody jest parametr polecenia.  Większość poleceń edycji ignoruje parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien `null` dotyczyć poleceń edycji.  
  
 Drugi argument określa obiekt, do którego zostanie rozesłane polecenie.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinien zawierać procedurę obsługi dla określonego polecenia.  Ogólnie rzecz biorąc, polecenie jest ignorowane w przypadku wywołania na obiekcie, który nie obsługuje tego polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" />
      </Docs>
    </Member>
    <Member MemberName="MoveLeftByCharacter">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveLeftByCharacter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveLeftByCharacter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveLeftByCharacter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveLeftByCharacter As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveLeftByCharacter { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveLeftByCharacter : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveLeftByCharacter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.EditingCommands.MoveLeftByCharacter" /> Reprezentuje polecenie, które wymaga, aby karetka przesunie jeden znak w lewo.</summary>
        <value>Żądane polecenie.  Domyślnym gestem dla tego polecenia jest <see langword="Left" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest konieczna rzeczywista implementacja, która reaguje na to polecenie na żadnym z określonych obiektów; w wielu przypadkach implementacja, która reaguje na polecenie, jest odpowiedzialna za moduł zapisujący aplikacji.  
  
 To polecenie jest natywnie obsługiwane przez <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_MoveLeftByCharacter"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="MoveLeftByCharacter"/>  
```  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać polecenie edycji na obiekcie, który obsługuje polecenie.  
  
 Na potrzeby tego przykładu <xref:System.Windows.Controls.RichTextBox> służy jako obiekt docelowy polecenia.  Należy pamiętać <xref:System.Windows.Controls.RichTextBox> , że <xref:System.Windows.IInputElement> implementuje interfejs (Dziedziczony <xref:System.Windows.FrameworkElement>z) i zawiera natywną obsługę wielu poleceń edycji.  
  
 Pierwszym argumentem dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metody jest parametr polecenia.  Większość poleceń edycji ignoruje parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien `null` dotyczyć poleceń edycji.  
  
 Drugi argument określa obiekt, do którego zostanie rozesłane polecenie.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinien zawierać procedurę obsługi dla określonego polecenia.  Ogólnie rzecz biorąc, polecenie jest ignorowane w przypadku wywołania na obiekcie, który nie obsługuje tego polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByCharacter" />
      </Docs>
    </Member>
    <Member MemberName="MoveLeftByWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveLeftByWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveLeftByWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveLeftByWord As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveLeftByWord { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveLeftByWord : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveLeftByWord" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" /> Reprezentuje polecenie, które wymaga, aby karetka przesunie jeden wyraz w lewo.</summary>
        <value>Żądane polecenie.  Domyślnym gestem dla tego polecenia jest <see langword="Ctrl" />. + <see langword="Left" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli karetka znajduje się w obrębie słowa, to polecenie przesuwa karetkę do początku tego wyrazu.  W przeciwnym razie to polecenie przesuwa karetkę do początku poprzedniego wyrazu.  
  
 Nie jest konieczna rzeczywista implementacja, która reaguje na to polecenie na żadnym z określonych obiektów; w wielu przypadkach implementacja, która reaguje na polecenie, jest odpowiedzialna za moduł zapisujący aplikacji.  
  
 To polecenie jest natywnie obsługiwane przez <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_MoveLeftByWord"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="MoveLeftByWord"/>  
```  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać polecenie edycji na obiekcie, który obsługuje polecenie.  
  
 Na potrzeby tego przykładu <xref:System.Windows.Controls.RichTextBox> służy jako obiekt docelowy polecenia.  Należy pamiętać <xref:System.Windows.Controls.RichTextBox> , że <xref:System.Windows.IInputElement> implementuje interfejs (Dziedziczony <xref:System.Windows.FrameworkElement>z) i zawiera natywną obsługę wielu poleceń edycji.  
  
 Pierwszym argumentem dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metody jest parametr polecenia.  Większość poleceń edycji ignoruje parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien `null` dotyczyć poleceń edycji.  
  
 Drugi argument określa obiekt, do którego zostanie rozesłane polecenie.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinien zawierać procedurę obsługi dla określonego polecenia.  Ogólnie rzecz biorąc, polecenie jest ignorowane w przypadku wywołania na obiekcie, który nie obsługuje tego polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
      </Docs>
    </Member>
    <Member MemberName="MoveRightByCharacter">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveRightByCharacter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveRightByCharacter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveRightByCharacter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveRightByCharacter As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveRightByCharacter { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveRightByCharacter : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveRightByCharacter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.EditingCommands.MoveRightByCharacter" /> Reprezentuje polecenie, które wymaga, aby karetka przesunie jeden znak w prawo.</summary>
        <value>Żądane polecenie.  Domyślnym gestem dla tego polecenia jest <see langword="Right" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest konieczna rzeczywista implementacja, która reaguje na to polecenie na żadnym z określonych obiektów; w wielu przypadkach implementacja, która reaguje na polecenie, jest odpowiedzialna za moduł zapisujący aplikacji.  
  
 To polecenie jest natywnie obsługiwane przez <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_MoveRightByCharacter"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="MoveRightByCharacter"/>  
```  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać polecenie edycji na obiekcie, który obsługuje polecenie.  
  
 Na potrzeby tego przykładu <xref:System.Windows.Controls.RichTextBox> służy jako obiekt docelowy polecenia.  Należy pamiętać <xref:System.Windows.Controls.RichTextBox> , że <xref:System.Windows.IInputElement> implementuje interfejs (Dziedziczony <xref:System.Windows.FrameworkElement>z) i zawiera natywną obsługę wielu poleceń edycji.  
  
 Pierwszym argumentem dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metody jest parametr polecenia.  Większość poleceń edycji ignoruje parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien `null` dotyczyć poleceń edycji.  
  
 Drugi argument określa obiekt, do którego zostanie rozesłane polecenie.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinien zawierać procedurę obsługi dla określonego polecenia.  Ogólnie rzecz biorąc, polecenie jest ignorowane w przypadku wywołania na obiekcie, który nie obsługuje tego polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByCharacter" />
      </Docs>
    </Member>
    <Member MemberName="MoveRightByWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveRightByWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveRightByWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveRightByWord As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveRightByWord { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveRightByWord : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveRightByWord" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" /> Reprezentuje polecenie, które wymaga, aby karetka przesunie się o jeden wyraz w prawo.</summary>
        <value>Żądane polecenie.  Domyślnym gestem dla tego polecenia jest <see langword="Ctrl" />. + <see langword="Right" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli karetka znajduje się w obrębie słowa, to polecenie przesuwa karetkę do końca tego wyrazu.  W przeciwnym razie to polecenie przesuwa karetkę do początku następnego wyrazu.  
  
 Nie jest konieczna rzeczywista implementacja, która reaguje na to polecenie na żadnym z określonych obiektów; w wielu przypadkach implementacja, która reaguje na polecenie, jest odpowiedzialna za moduł zapisujący aplikacji.  
  
 To polecenie jest natywnie obsługiwane przez <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_MoveRightByWord"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="MoveRightByWord"/>  
```  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać polecenie edycji na obiekcie, który obsługuje polecenie.  
  
 Na potrzeby tego przykładu <xref:System.Windows.Controls.RichTextBox> służy jako obiekt docelowy polecenia.  Należy pamiętać <xref:System.Windows.Controls.RichTextBox> , że <xref:System.Windows.IInputElement> implementuje interfejs (Dziedziczony <xref:System.Windows.FrameworkElement>z) i zawiera natywną obsługę wielu poleceń edycji.  
  
 Pierwszym argumentem dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metody jest parametr polecenia.  Większość poleceń edycji ignoruje parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien `null` dotyczyć poleceń edycji.  
  
 Drugi argument określa obiekt, do którego zostanie rozesłane polecenie.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinien zawierać procedurę obsługi dla określonego polecenia.  Ogólnie rzecz biorąc, polecenie jest ignorowane w przypadku wywołania na obiekcie, który nie obsługuje tego polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
      </Docs>
    </Member>
    <Member MemberName="MoveToDocumentEnd">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveToDocumentEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveToDocumentEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveToDocumentEnd" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveToDocumentEnd As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveToDocumentEnd { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveToDocumentEnd : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveToDocumentEnd" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.EditingCommands.MoveToDocumentEnd" /> Reprezentuje polecenie, które żąda, aby karetka była przenoszona na bardzo koniec zawartości.</summary>
        <value>Żądane polecenie.  Domyślnym gestem dla tego polecenia jest <see langword="Ctrl" />. + <see langword="End" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 *Kontener tekstowy* to element, który tworzy ostatecznie obramowanie dla zawartości.  <xref:System.Windows.Controls.TextBlock>i <xref:System.Windows.Documents.FlowDocument> są przykładami kontenerów tekstu.  Zawartość zbiorczą znajdującą się w kontenerze tekstu nazywa się *dokumentem*.  
  
 Nie jest konieczna rzeczywista implementacja, która reaguje na to polecenie na żadnym z określonych obiektów; w wielu przypadkach implementacja, która reaguje na polecenie, jest odpowiedzialna za moduł zapisujący aplikacji.  
  
 To polecenie jest natywnie obsługiwane przez <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_MoveToDocumentEnd"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="MoveToDocumentEnd"/>  
```  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać polecenie edycji na obiekcie, który obsługuje polecenie.  
  
 Na potrzeby tego przykładu <xref:System.Windows.Controls.RichTextBox> służy jako obiekt docelowy polecenia.  Należy pamiętać <xref:System.Windows.Controls.RichTextBox> , że <xref:System.Windows.IInputElement> implementuje interfejs (Dziedziczony <xref:System.Windows.FrameworkElement>z) i zawiera natywną obsługę wielu poleceń edycji.  
  
 Pierwszym argumentem dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metody jest parametr polecenia.  Większość poleceń edycji ignoruje parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien `null` dotyczyć poleceń edycji.  
  
 Drugi argument określa obiekt, do którego zostanie rozesłane polecenie.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinien zawierać procedurę obsługi dla określonego polecenia.  Ogólnie rzecz biorąc, polecenie jest ignorowane w przypadku wywołania na obiekcie, który nie obsługuje tego polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentStart" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentEnd" />
      </Docs>
    </Member>
    <Member MemberName="MoveToDocumentStart">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveToDocumentStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveToDocumentStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveToDocumentStart" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveToDocumentStart As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveToDocumentStart { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveToDocumentStart : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveToDocumentStart" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.EditingCommands.MoveToDocumentStart" /> Reprezentuje polecenie, które żąda, aby karetka była przenoszona na bardzo początek zawartości.</summary>
        <value>Żądane polecenie.  Domyślnym gestem dla tego polecenia jest <see langword="Ctrl" />. + <see langword="Home" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 *Kontener tekstowy* to element, który tworzy ostatecznie obramowanie dla zawartości.  <xref:System.Windows.Controls.TextBlock>i <xref:System.Windows.Documents.FlowDocument> są przykładami kontenerów tekstu.  Zawartość zbiorczą znajdującą się w kontenerze tekstu nazywa się *dokumentem*.  
  
 Nie jest konieczna rzeczywista implementacja, która reaguje na to polecenie na żadnym z określonych obiektów; w wielu przypadkach implementacja, która reaguje na polecenie, jest odpowiedzialna za moduł zapisujący aplikacji.  
  
 To polecenie jest natywnie obsługiwane przez <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_MoveToDocumentStart"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="MoveToDocumentStart"/>  
```  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać polecenie edycji na obiekcie, który obsługuje polecenie.  
  
 Na potrzeby tego przykładu <xref:System.Windows.Controls.RichTextBox> służy jako obiekt docelowy polecenia.  Należy pamiętać <xref:System.Windows.Controls.RichTextBox> , że <xref:System.Windows.IInputElement> implementuje interfejs (Dziedziczony <xref:System.Windows.FrameworkElement>z) i zawiera natywną obsługę wielu poleceń edycji.  
  
 Pierwszym argumentem dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metody jest parametr polecenia.  Większość poleceń edycji ignoruje parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien `null` dotyczyć poleceń edycji.  
  
 Drugi argument określa obiekt, do którego zostanie rozesłane polecenie.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinien zawierać procedurę obsługi dla określonego polecenia.  Ogólnie rzecz biorąc, polecenie jest ignorowane w przypadku wywołania na obiekcie, który nie obsługuje tego polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToDocumentEnd" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentStart" />
      </Docs>
    </Member>
    <Member MemberName="MoveToLineEnd">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveToLineEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveToLineEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveToLineEnd" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveToLineEnd As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveToLineEnd { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveToLineEnd : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveToLineEnd" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.EditingCommands.MoveToLineEnd" /> Reprezentuje polecenie, które żąda przejścia karetki na koniec bieżącego wiersza.</summary>
        <value>Żądane polecenie.  Domyślnym gestem dla tego polecenia jest <see langword="End" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest konieczna rzeczywista implementacja, która reaguje na to polecenie na żadnym z określonych obiektów; w wielu przypadkach implementacja, która reaguje na polecenie, jest odpowiedzialna za moduł zapisujący aplikacji.  
  
 To polecenie jest natywnie obsługiwane przez <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_MoveToLineEnd"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="MoveToLineEnd"/>  
```  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać polecenie edycji na obiekcie, który obsługuje polecenie.  
  
 Na potrzeby tego przykładu <xref:System.Windows.Controls.RichTextBox> służy jako obiekt docelowy polecenia.  Należy pamiętać <xref:System.Windows.Controls.RichTextBox> , że <xref:System.Windows.IInputElement> implementuje interfejs (Dziedziczony <xref:System.Windows.FrameworkElement>z) i zawiera natywną obsługę wielu poleceń edycji.  
  
 Pierwszym argumentem dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metody jest parametr polecenia.  Większość poleceń edycji ignoruje parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien `null` dotyczyć poleceń edycji.  
  
 Drugi argument określa obiekt, do którego zostanie rozesłane polecenie.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinien zawierać procedurę obsługi dla określonego polecenia.  Ogólnie rzecz biorąc, polecenie jest ignorowane w przypadku wywołania na obiekcie, który nie obsługuje tego polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToLineStart" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToLineEnd" />
      </Docs>
    </Member>
    <Member MemberName="MoveToLineStart">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveToLineStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveToLineStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveToLineStart" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveToLineStart As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveToLineStart { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveToLineStart : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveToLineStart" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.EditingCommands.MoveToLineStart" /> Reprezentuje polecenie, które żąda przejścia karetki na początek bieżącego wiersza.</summary>
        <value>Żądane polecenie.  Domyślnym gestem dla tego polecenia jest <see langword="Home" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest konieczna rzeczywista implementacja, która reaguje na to polecenie na żadnym z określonych obiektów; w wielu przypadkach implementacja, która reaguje na polecenie, jest odpowiedzialna za moduł zapisujący aplikacji.  
  
 To polecenie jest natywnie obsługiwane przez <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_MoveToLineStart"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="MoveToLineStart"/>  
```  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać polecenie edycji na obiekcie, który obsługuje polecenie.  
  
 Na potrzeby tego przykładu <xref:System.Windows.Controls.RichTextBox> służy jako obiekt docelowy polecenia.  Należy pamiętać <xref:System.Windows.Controls.RichTextBox> , że <xref:System.Windows.IInputElement> implementuje interfejs (Dziedziczony <xref:System.Windows.FrameworkElement>z) i zawiera natywną obsługę wielu poleceń edycji.  
  
 Pierwszym argumentem dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metody jest parametr polecenia.  Większość poleceń edycji ignoruje parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien `null` dotyczyć poleceń edycji.  
  
 Drugi argument określa obiekt, do którego zostanie rozesłane polecenie.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinien zawierać procedurę obsługi dla określonego polecenia.  Ogólnie rzecz biorąc, polecenie jest ignorowane w przypadku wywołania na obiekcie, który nie obsługuje tego polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToLineEnd" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToLineEnd" />
      </Docs>
    </Member>
    <Member MemberName="MoveUpByLine">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveUpByLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveUpByLine" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveUpByLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveUpByLine As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveUpByLine { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveUpByLine : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveUpByLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.EditingCommands.MoveUpByLine" /> Reprezentuje polecenie, które żąda, aby karetka przesunie się o jeden wiersz w górę.</summary>
        <value>Żądane polecenie.  Domyślnym gestem dla tego polecenia jest <see langword="Up" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest konieczna rzeczywista implementacja, która reaguje na to polecenie na żadnym z określonych obiektów; w wielu przypadkach implementacja, która reaguje na polecenie, jest odpowiedzialna za moduł zapisujący aplikacji.  
  
 To polecenie jest natywnie obsługiwane przez <xref:System.Windows.Controls.RichTextBox> program <xref:System.Windows.Controls.TextBox>i.  
  
<a name="xamlAttributeUsage_MoveUpByLine"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="MoveUpByLine"/>  
```  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać polecenie edycji na obiekcie, który obsługuje polecenie.  
  
 Na potrzeby tego przykładu <xref:System.Windows.Controls.RichTextBox> służy jako obiekt docelowy polecenia.  Należy pamiętać <xref:System.Windows.Controls.RichTextBox> , że <xref:System.Windows.IInputElement> implementuje interfejs (Dziedziczony <xref:System.Windows.FrameworkElement>z) i zawiera natywną obsługę wielu poleceń edycji.  
  
 Pierwszym argumentem dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metody jest parametr polecenia.  Większość poleceń edycji ignoruje parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien `null` dotyczyć poleceń edycji.  
  
 Drugi argument określa obiekt, do którego zostanie rozesłane polecenie.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinien zawierać procedurę obsługi dla określonego polecenia.  Ogólnie rzecz biorąc, polecenie jest ignorowane w przypadku wywołania na obiekcie, który nie obsługuje tego polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByLine" />
      </Docs>
    </Member>
    <Member MemberName="MoveUpByPage">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveUpByPage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveUpByPage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveUpByPage" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveUpByPage As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveUpByPage { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveUpByPage : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveUpByPage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.EditingCommands.MoveUpByPage" /> Reprezentuje polecenie, które powoduje, że karetka przesuwa się o jedną stronę w górę.</summary>
        <value>Żądane polecenie.  Domyślnym gestem dla tego polecenia jest <see langword="PageUp" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest konieczna rzeczywista implementacja, która reaguje na to polecenie na żadnym z określonych obiektów; w wielu przypadkach implementacja, która reaguje na polecenie, jest odpowiedzialna za moduł zapisujący aplikacji.  
  
 To polecenie jest natywnie obsługiwane przez <xref:System.Windows.Controls.RichTextBox> program <xref:System.Windows.Controls.TextBox>i.  
  
<a name="xamlAttributeUsage_MoveUpByPage"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="MoveUpByPage"/>  
```  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać polecenie edycji na obiekcie, który obsługuje polecenie.  
  
 Na potrzeby tego przykładu <xref:System.Windows.Controls.RichTextBox> służy jako obiekt docelowy polecenia.  Należy pamiętać <xref:System.Windows.Controls.RichTextBox> , że <xref:System.Windows.IInputElement> implementuje interfejs (Dziedziczony <xref:System.Windows.FrameworkElement>z) i zawiera natywną obsługę wielu poleceń edycji.  
  
 Pierwszym argumentem dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metody jest parametr polecenia.  Większość poleceń edycji ignoruje parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien `null` dotyczyć poleceń edycji.  
  
 Drugi argument określa obiekt, do którego zostanie rozesłane polecenie.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinien zawierać procedurę obsługi dla określonego polecenia.  Ogólnie rzecz biorąc, polecenie jest ignorowane w przypadku wywołania na obiekcie, który nie obsługuje tego polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByPage" />
      </Docs>
    </Member>
    <Member MemberName="MoveUpByParagraph">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand MoveUpByParagraph { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand MoveUpByParagraph" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MoveUpByParagraph As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ MoveUpByParagraph { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MoveUpByParagraph : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.MoveUpByParagraph" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" /> Reprezentuje polecenie, które żąda, aby karetka była przenoszona do jednego akapitu.</summary>
        <value>Żądane polecenie.  Domyślnym gestem dla tego polecenia jest <see langword="Ctrl" />. + <see langword="Up" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To polecenie umieszcza karetkę na początku następnego akapitu.  
  
 To polecenie zachowuje się <xref:System.Windows.Documents.EditingCommands.MoveToDocumentStart%2A> <xref:System.Windows.Controls.TextBox>jak w przypadku wywołania w.  
  
 Nie jest konieczna rzeczywista implementacja, która reaguje na to polecenie na żadnym z określonych obiektów; w wielu przypadkach implementacja, która reaguje na polecenie, jest odpowiedzialna za moduł zapisujący aplikacji.  
  
 To polecenie jest natywnie obsługiwane przez <xref:System.Windows.Controls.RichTextBox> program <xref:System.Windows.Controls.TextBox>i.  
  
<a name="xamlAttributeUsage_MoveUpByParagraph"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="MoveUpByParagraph"/>  
```  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać polecenie edycji na obiekcie, który obsługuje polecenie.  
  
 Na potrzeby tego przykładu <xref:System.Windows.Controls.RichTextBox> służy jako obiekt docelowy polecenia.  Należy pamiętać <xref:System.Windows.Controls.RichTextBox> , że <xref:System.Windows.IInputElement> implementuje interfejs (Dziedziczony <xref:System.Windows.FrameworkElement>z) i zawiera natywną obsługę wielu poleceń edycji.  
  
 Pierwszym argumentem dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metody jest parametr polecenia.  Większość poleceń edycji ignoruje parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien `null` dotyczyć poleceń edycji.  
  
 Drugi argument określa obiekt, do którego zostanie rozesłane polecenie.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinien zawierać procedurę obsługi dla określonego polecenia.  Ogólnie rzecz biorąc, polecenie jest ignorowane w przypadku wywołania na obiekcie, który nie obsługuje tego polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" />
      </Docs>
    </Member>
    <Member MemberName="SelectDownByLine">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectDownByLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectDownByLine" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectDownByLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectDownByLine As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectDownByLine { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectDownByLine : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectDownByLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.EditingCommands.SelectDownByLine" /> Reprezentuje polecenie, które żąda, aby bieżące zaznaczenie było rozwinięte w dół o jeden wiersz.</summary>
        <value>Żądane polecenie.  Domyślnym gestem dla tego polecenia jest <see langword="Shift" />. + <see langword="Down" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest konieczna rzeczywista implementacja, która reaguje na to polecenie na żadnym z określonych obiektów; w wielu przypadkach implementacja, która reaguje na polecenie, jest odpowiedzialna za moduł zapisujący aplikacji.  
  
 To polecenie jest natywnie obsługiwane przez <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectDownByLine"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="SelectDownByLine"/>  
```  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać polecenie edycji na obiekcie, który obsługuje polecenie.  
  
 Na potrzeby tego przykładu <xref:System.Windows.Controls.RichTextBox> służy jako obiekt docelowy polecenia.  Należy pamiętać <xref:System.Windows.Controls.RichTextBox> , że <xref:System.Windows.IInputElement> implementuje interfejs (Dziedziczony <xref:System.Windows.FrameworkElement>z) i zawiera natywną obsługę wielu poleceń edycji.  
  
 Pierwszym argumentem dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metody jest parametr polecenia.  Większość poleceń edycji ignoruje parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien `null` dotyczyć poleceń edycji.  
  
 Drugi argument określa obiekt, do którego zostanie rozesłane polecenie.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinien zawierać procedurę obsługi dla określonego polecenia.  Ogólnie rzecz biorąc, polecenie jest ignorowane w przypadku wywołania na obiekcie, który nie obsługuje tego polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByLine" />
      </Docs>
    </Member>
    <Member MemberName="SelectDownByPage">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectDownByPage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectDownByPage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectDownByPage" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectDownByPage As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectDownByPage { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectDownByPage : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectDownByPage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.EditingCommands.SelectDownByPage" /> Reprezentuje polecenie, które żąda, aby bieżące zaznaczenie zostało rozszerzone o jedną stronę.</summary>
        <value>Żądane polecenie.  Domyślnym gestem dla tego polecenia jest <see langword="Shift" />. + <see langword="PageDown" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest konieczna rzeczywista implementacja, która reaguje na to polecenie na żadnym z określonych obiektów; w wielu przypadkach implementacja, która reaguje na polecenie, jest odpowiedzialna za moduł zapisujący aplikacji.  
  
 To polecenie jest natywnie obsługiwane przez <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectDownByPage"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="SelectDownByPage"/>  
```  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać polecenie edycji na obiekcie, który obsługuje polecenie.  
  
 Na potrzeby tego przykładu <xref:System.Windows.Controls.RichTextBox> służy jako obiekt docelowy polecenia.  Należy pamiętać <xref:System.Windows.Controls.RichTextBox> , że <xref:System.Windows.IInputElement> implementuje interfejs (Dziedziczony <xref:System.Windows.FrameworkElement>z) i zawiera natywną obsługę wielu poleceń edycji.  
  
 Pierwszym argumentem dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metody jest parametr polecenia.  Większość poleceń edycji ignoruje parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien `null` dotyczyć poleceń edycji.  
  
 Drugi argument określa obiekt, do którego zostanie rozesłane polecenie.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinien zawierać procedurę obsługi dla określonego polecenia.  Ogólnie rzecz biorąc, polecenie jest ignorowane w przypadku wywołania na obiekcie, który nie obsługuje tego polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByPage" />
      </Docs>
    </Member>
    <Member MemberName="SelectDownByParagraph">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectDownByParagraph { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectDownByParagraph" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectDownByParagraph As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectDownByParagraph { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectDownByParagraph : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectDownByParagraph" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" /> Reprezentuje polecenie, które żąda, aby bieżące zaznaczenie było rozwinięte w dół o jeden akapit.</summary>
        <value>Żądane polecenie.  Domyślnym <see langword="Ctrl" />gestem dla tego polecenia jest. + <see langword="Shift" /> + <see langword="Down" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To polecenie rozszerza zaznaczenie do początku następnego akapitu.  W przeciwnym razie to polecenie rozszerza zaznaczenie na koniec bieżącego akapitu.  Rozwinięte zaznaczenie obejmuje podział akapitu, który oznacza koniec akapitu.  
  
 Nie jest konieczna rzeczywista implementacja, która reaguje na to polecenie na żadnym z określonych obiektów; w wielu przypadkach implementacja, która reaguje na polecenie, jest odpowiedzialna za moduł zapisujący aplikacji.  
  
 To polecenie jest natywnie obsługiwane przez <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectDownByParagraph"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="SelectDownByParagraph"/>  
```  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać polecenie edycji na obiekcie, który obsługuje polecenie.  
  
 Na potrzeby tego przykładu <xref:System.Windows.Controls.RichTextBox> służy jako obiekt docelowy polecenia.  Należy pamiętać <xref:System.Windows.Controls.RichTextBox> , że <xref:System.Windows.IInputElement> implementuje interfejs (Dziedziczony <xref:System.Windows.FrameworkElement>z) i zawiera natywną obsługę wielu poleceń edycji.  
  
 Pierwszym argumentem dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metody jest parametr polecenia.  Większość poleceń edycji ignoruje parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien `null` dotyczyć poleceń edycji.  
  
 Drugi argument określa obiekt, do którego zostanie rozesłane polecenie.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinien zawierać procedurę obsługi dla określonego polecenia.  Ogólnie rzecz biorąc, polecenie jest ignorowane w przypadku wywołania na obiekcie, który nie obsługuje tego polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveDownByParagraph" />
      </Docs>
    </Member>
    <Member MemberName="SelectLeftByCharacter">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectLeftByCharacter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectLeftByCharacter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectLeftByCharacter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectLeftByCharacter As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectLeftByCharacter { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectLeftByCharacter : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectLeftByCharacter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.EditingCommands.SelectLeftByCharacter" /> Reprezentuje polecenie, które żąda, aby bieżące zaznaczenie było rozwinięte po lewej stronie o jeden znak.</summary>
        <value>Żądane polecenie.  Domyślnym gestem dla tego polecenia jest <see langword="Shift" />. + <see langword="Left" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest konieczna rzeczywista implementacja, która reaguje na to polecenie na żadnym z określonych obiektów; w wielu przypadkach implementacja, która reaguje na polecenie, jest odpowiedzialna za moduł zapisujący aplikacji.  
  
 To polecenie jest natywnie obsługiwane przez <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectLeftByCharacter"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="SelectLeftByCharacter"/>  
```  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać polecenie edycji na obiekcie, który obsługuje polecenie.  
  
 Na potrzeby tego przykładu <xref:System.Windows.Controls.RichTextBox> służy jako obiekt docelowy polecenia.  Należy pamiętać <xref:System.Windows.Controls.RichTextBox> , że <xref:System.Windows.IInputElement> implementuje interfejs (Dziedziczony <xref:System.Windows.FrameworkElement>z) i zawiera natywną obsługę wielu poleceń edycji.  
  
 Pierwszym argumentem dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metody jest parametr polecenia.  Większość poleceń edycji ignoruje parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien `null` dotyczyć poleceń edycji.  
  
 Drugi argument określa obiekt, do którego zostanie rozesłane polecenie.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinien zawierać procedurę obsługi dla określonego polecenia.  Ogólnie rzecz biorąc, polecenie jest ignorowane w przypadku wywołania na obiekcie, który nie obsługuje tego polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByCharacter" />
      </Docs>
    </Member>
    <Member MemberName="SelectLeftByWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectLeftByWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectLeftByWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectLeftByWord As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectLeftByWord { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectLeftByWord : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectLeftByWord" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" /> Reprezentuje polecenie, które żąda, aby bieżące zaznaczenie było rozwinięte po lewej stronie o jeden wyraz.</summary>
        <value>Żądane polecenie.  Domyślnym <see langword="Ctrl" />gestem dla tego polecenia jest. + <see langword="Shift" /> + <see langword="Left" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli karetka znajduje się w obrębie słowa, to polecenie rozszerza zaznaczenie do początku tego wyrazu.  W przeciwnym razie to polecenie rozszerza zaznaczenie na początek poprzedniego wyrazu.  
  
 Rozwinięte zaznaczenie nie zawiera ogranicznika wyrazu.  Kontrast z <xref:System.Windows.Documents.EditingCommands.SelectRightByWord%2A>, który obejmuje ogranicznik wyrazu w rozwiniętym zaznaczeniu.  
  
 Nie jest konieczna rzeczywista implementacja, która reaguje na to polecenie na żadnym z określonych obiektów; w wielu przypadkach implementacja, która reaguje na polecenie, jest odpowiedzialna za moduł zapisujący aplikacji.  
  
 To polecenie jest natywnie obsługiwane przez <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectLeftByWord"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="SelectLeftByWord"/>  
```  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać polecenie edycji na obiekcie, który obsługuje polecenie.  
  
 Na potrzeby tego przykładu <xref:System.Windows.Controls.RichTextBox> służy jako obiekt docelowy polecenia.  Należy pamiętać <xref:System.Windows.Controls.RichTextBox> , że <xref:System.Windows.IInputElement> implementuje interfejs (Dziedziczony <xref:System.Windows.FrameworkElement>z) i zawiera natywną obsługę wielu poleceń edycji.  
  
 Pierwszym argumentem dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metody jest parametr polecenia.  Większość poleceń edycji ignoruje parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien `null` dotyczyć poleceń edycji.  
  
 Drugi argument określa obiekt, do którego zostanie rozesłane polecenie.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinien zawierać procedurę obsługi dla określonego polecenia.  Ogólnie rzecz biorąc, polecenie jest ignorowane w przypadku wywołania na obiekcie, który nie obsługuje tego polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveLeftByWord" />
      </Docs>
    </Member>
    <Member MemberName="SelectRightByCharacter">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectRightByCharacter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectRightByCharacter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectRightByCharacter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectRightByCharacter As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectRightByCharacter { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectRightByCharacter : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectRightByCharacter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.EditingCommands.SelectRightByCharacter" /> Reprezentuje polecenie, które żąda, aby bieżące zaznaczenie było rozwinięte po prawej stronie o jeden znak.</summary>
        <value>Żądane polecenie.  Domyślnym gestem dla tego polecenia jest <see langword="Shift" />. + <see langword="Right" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest konieczna rzeczywista implementacja, która reaguje na to polecenie na żadnym z określonych obiektów; w wielu przypadkach implementacja, która reaguje na polecenie, jest odpowiedzialna za moduł zapisujący aplikacji.  
  
 To polecenie jest natywnie obsługiwane przez <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectRightByCharacter"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="SelectRightByCharacter"/>  
```  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać polecenie edycji na obiekcie, który obsługuje polecenie.  
  
 Na potrzeby tego przykładu <xref:System.Windows.Controls.RichTextBox> służy jako obiekt docelowy polecenia.  Należy pamiętać <xref:System.Windows.Controls.RichTextBox> , że <xref:System.Windows.IInputElement> implementuje interfejs (Dziedziczony <xref:System.Windows.FrameworkElement>z) i zawiera natywną obsługę wielu poleceń edycji.  
  
 Pierwszym argumentem dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metody jest parametr polecenia.  Większość poleceń edycji ignoruje parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien `null` dotyczyć poleceń edycji.  
  
 Drugi argument określa obiekt, do którego zostanie rozesłane polecenie.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinien zawierać procedurę obsługi dla określonego polecenia.  Ogólnie rzecz biorąc, polecenie jest ignorowane w przypadku wywołania na obiekcie, który nie obsługuje tego polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByCharacter" />
      </Docs>
    </Member>
    <Member MemberName="SelectRightByWord">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectRightByWord { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectRightByWord" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectRightByWord" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectRightByWord As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectRightByWord { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectRightByWord : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectRightByWord" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.EditingCommands.SelectRightByWord" /> Reprezentuje polecenie, które żąda, aby bieżące zaznaczenie było rozwinięte bezpośrednio przez jedno słowo.</summary>
        <value>Żądane polecenie.  Domyślnym <see langword="Ctrl" />gestem dla tego polecenia jest. + <see langword="Shift" /> + <see langword="Right" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli karetka znajduje się w obrębie słowa, to polecenie rozszerza zaznaczenie do końca tego wyrazu.  W przeciwnym razie to polecenie rozszerza zaznaczenie na koniec następnego wyrazu.  
  
 Rozwinięte zaznaczenie obejmuje ogranicznik wyrazu.  Kontrast, <xref:System.Windows.Documents.EditingCommands.SelectLeftByWord%2A> z którym nie obejmuje ogranicznika wyrazu w rozwiniętym zaznaczeniu.  
  
 Nie jest konieczna rzeczywista implementacja, która reaguje na to polecenie na żadnym z określonych obiektów; w wielu przypadkach implementacja, która reaguje na polecenie, jest odpowiedzialna za moduł zapisujący aplikacji.  
  
 To polecenie jest natywnie obsługiwane przez <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectRightByWord"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="SelectRightByWord"/>  
```  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać polecenie edycji na obiekcie, który obsługuje polecenie.  
  
 Na potrzeby tego przykładu <xref:System.Windows.Controls.RichTextBox> służy jako obiekt docelowy polecenia.  Należy pamiętać <xref:System.Windows.Controls.RichTextBox> , że <xref:System.Windows.IInputElement> implementuje interfejs (Dziedziczony <xref:System.Windows.FrameworkElement>z) i zawiera natywną obsługę wielu poleceń edycji.  
  
 Pierwszym argumentem dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metody jest parametr polecenia.  Większość poleceń edycji ignoruje parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien `null` dotyczyć poleceń edycji.  
  
 Drugi argument określa obiekt, do którego zostanie rozesłane polecenie.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinien zawierać procedurę obsługi dla określonego polecenia.  Ogólnie rzecz biorąc, polecenie jest ignorowane w przypadku wywołania na obiekcie, który nie obsługuje tego polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectLeftByWord" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectRightByCharacter" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveRightByWord" />
      </Docs>
    </Member>
    <Member MemberName="SelectToDocumentEnd">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectToDocumentEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectToDocumentEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectToDocumentEnd" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectToDocumentEnd As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectToDocumentEnd { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectToDocumentEnd : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectToDocumentEnd" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentEnd" /> Reprezentuje polecenie, które żąda, aby bieżące zaznaczenie było rozwinięte na bardzo zakończenie zawartości.</summary>
        <value>Żądane polecenie.  Domyślnym <see langword="Ctrl" />gestem dla tego polecenia jest. + <see langword="Shift" /> + <see langword="End" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 *Kontener tekstowy* to element, który tworzy ostatecznie obramowanie dla zawartości.  <xref:System.Windows.Controls.TextBlock>i <xref:System.Windows.Documents.FlowDocument> są przykładami kontenerów tekstu.  Zawartość zbiorczą znajdującą się w kontenerze tekstu nazywa się *dokumentem*.  
  
 Nie jest konieczna rzeczywista implementacja, która reaguje na to polecenie na żadnym z określonych obiektów; w wielu przypadkach implementacja, która reaguje na polecenie, jest odpowiedzialna za moduł zapisujący aplikacji.  
  
 To polecenie jest natywnie obsługiwane przez <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectToDocumentEnd"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="SelectToDocumentEnd"/>  
```  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać polecenie edycji na obiekcie, który obsługuje polecenie.  
  
 Na potrzeby tego przykładu <xref:System.Windows.Controls.RichTextBox> służy jako obiekt docelowy polecenia.  Należy pamiętać <xref:System.Windows.Controls.RichTextBox> , że <xref:System.Windows.IInputElement> implementuje interfejs (Dziedziczony <xref:System.Windows.FrameworkElement>z) i zawiera natywną obsługę wielu poleceń edycji.  
  
 Pierwszym argumentem dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metody jest parametr polecenia.  Większość poleceń edycji ignoruje parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien `null` dotyczyć poleceń edycji.  
  
 Drugi argument określa obiekt, do którego zostanie rozesłane polecenie.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinien zawierać procedurę obsługi dla określonego polecenia.  Ogólnie rzecz biorąc, polecenie jest ignorowane w przypadku wywołania na obiekcie, który nie obsługuje tego polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentStart" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToDocumentEnd" />
      </Docs>
    </Member>
    <Member MemberName="SelectToDocumentStart">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectToDocumentStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectToDocumentStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectToDocumentStart" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectToDocumentStart As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectToDocumentStart { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectToDocumentStart : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectToDocumentStart" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentStart" /> Reprezentuje polecenie, które żąda, aby bieżące zaznaczenie było rozwinięte na początku zawartości.</summary>
        <value>Żądane polecenie.  Domyślnym <see langword="Ctrl" />gestem dla tego polecenia jest. + <see langword="Shift" /> + <see langword="Home" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 *Kontener tekstowy* to element, który tworzy ostatecznie obramowanie dla zawartości.  <xref:System.Windows.Controls.TextBlock>i <xref:System.Windows.Documents.FlowDocument> są przykładami kontenerów tekstu.  Zawartość zbiorczą znajdującą się w kontenerze tekstu nazywa się *dokumentem*.  
  
 Nie jest konieczna rzeczywista implementacja, która reaguje na to polecenie na żadnym z określonych obiektów; w wielu przypadkach implementacja, która reaguje na polecenie, jest odpowiedzialna za moduł zapisujący aplikacji.  
  
 To polecenie jest natywnie obsługiwane przez <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectToDocumentStart"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="SelectToDocumentStart"/>  
```  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać polecenie edycji na obiekcie, który obsługuje polecenie.  
  
 Na potrzeby tego przykładu <xref:System.Windows.Controls.RichTextBox> służy jako obiekt docelowy polecenia.  Należy pamiętać <xref:System.Windows.Controls.RichTextBox> , że <xref:System.Windows.IInputElement> implementuje interfejs (Dziedziczony <xref:System.Windows.FrameworkElement>z) i zawiera natywną obsługę wielu poleceń edycji.  
  
 Pierwszym argumentem dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metody jest parametr polecenia.  Większość poleceń edycji ignoruje parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien `null` dotyczyć poleceń edycji.  
  
 Drugi argument określa obiekt, do którego zostanie rozesłane polecenie.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinien zawierać procedurę obsługi dla określonego polecenia.  Ogólnie rzecz biorąc, polecenie jest ignorowane w przypadku wywołania na obiekcie, który nie obsługuje tego polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToDocumentEnd" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToDocumentStart" />
      </Docs>
    </Member>
    <Member MemberName="SelectToLineEnd">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectToLineEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectToLineEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectToLineEnd" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectToLineEnd As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectToLineEnd { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectToLineEnd : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectToLineEnd" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.EditingCommands.SelectToLineEnd" /> Reprezentuje polecenie, które żąda, aby bieżące zaznaczenie było rozwinięte na koniec bieżącego wiersza.</summary>
        <value>Żądane polecenie.  Domyślnym gestem dla tego polecenia jest <see langword="Shift" />. + <see langword="End" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest konieczna rzeczywista implementacja, która reaguje na to polecenie na żadnym z określonych obiektów; w wielu przypadkach implementacja, która reaguje na polecenie, jest odpowiedzialna za moduł zapisujący aplikacji.  
  
 To polecenie jest natywnie obsługiwane przez <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectToLineEnd"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="SelectToLineEnd"/>  
```  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać polecenie edycji na obiekcie, który obsługuje polecenie.  
  
 Na potrzeby tego przykładu <xref:System.Windows.Controls.RichTextBox> służy jako obiekt docelowy polecenia.  Należy pamiętać <xref:System.Windows.Controls.RichTextBox> , że <xref:System.Windows.IInputElement> implementuje interfejs (Dziedziczony <xref:System.Windows.FrameworkElement>z) i zawiera natywną obsługę wielu poleceń edycji.  
  
 Pierwszym argumentem dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metody jest parametr polecenia.  Większość poleceń edycji ignoruje parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien `null` dotyczyć poleceń edycji.  
  
 Drugi argument określa obiekt, do którego zostanie rozesłane polecenie.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinien zawierać procedurę obsługi dla określonego polecenia.  Ogólnie rzecz biorąc, polecenie jest ignorowane w przypadku wywołania na obiekcie, który nie obsługuje tego polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToLineStart" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToLineEnd" />
      </Docs>
    </Member>
    <Member MemberName="SelectToLineStart">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectToLineStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectToLineStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectToLineStart" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectToLineStart As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectToLineStart { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectToLineStart : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectToLineStart" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.EditingCommands.SelectToLineStart" /> Reprezentuje polecenie, które żąda, aby bieżące zaznaczenie było rozwinięte na początku bieżącego wiersza.</summary>
        <value>Żądane polecenie.  Domyślnym gestem dla tego polecenia jest <see langword="Shift" />. + <see langword="Home" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest konieczna rzeczywista implementacja, która reaguje na to polecenie na żadnym z określonych obiektów; w wielu przypadkach implementacja, która reaguje na polecenie, jest odpowiedzialna za moduł zapisujący aplikacji.  
  
 To polecenie jest natywnie obsługiwane przez <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectToLineStart"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="SelectToLineStart"/>  
```  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać polecenie edycji na obiekcie, który obsługuje polecenie.  
  
 Na potrzeby tego przykładu <xref:System.Windows.Controls.RichTextBox> służy jako obiekt docelowy polecenia.  Należy pamiętać <xref:System.Windows.Controls.RichTextBox> , że <xref:System.Windows.IInputElement> implementuje interfejs (Dziedziczony <xref:System.Windows.FrameworkElement>z) i zawiera natywną obsługę wielu poleceń edycji.  
  
 Pierwszym argumentem dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metody jest parametr polecenia.  Większość poleceń edycji ignoruje parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien `null` dotyczyć poleceń edycji.  
  
 Drugi argument określa obiekt, do którego zostanie rozesłane polecenie.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinien zawierać procedurę obsługi dla określonego polecenia.  Ogólnie rzecz biorąc, polecenie jest ignorowane w przypadku wywołania na obiekcie, który nie obsługuje tego polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectToLineEnd" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveToLineStart" />
      </Docs>
    </Member>
    <Member MemberName="SelectUpByLine">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectUpByLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectUpByLine" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectUpByLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectUpByLine As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectUpByLine { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectUpByLine : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectUpByLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.EditingCommands.SelectUpByLine" /> Reprezentuje polecenie, które żąda, aby bieżące zaznaczenie było rozwinięte o jeden wiersz.</summary>
        <value>Żądane polecenie.  Domyślnym gestem dla tego polecenia jest <see langword="Shift" />. + <see langword="Up" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest konieczna rzeczywista implementacja, która reaguje na to polecenie na żadnym z określonych obiektów; w wielu przypadkach implementacja, która reaguje na polecenie, jest odpowiedzialna za moduł zapisujący aplikacji.  
  
 To polecenie jest natywnie obsługiwane przez <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectUpByLine"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="SelectUpByLine"/>  
```  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać polecenie edycji na obiekcie, który obsługuje polecenie.  
  
 Na potrzeby tego przykładu <xref:System.Windows.Controls.RichTextBox> służy jako obiekt docelowy polecenia.  Należy pamiętać <xref:System.Windows.Controls.RichTextBox> , że <xref:System.Windows.IInputElement> implementuje interfejs (Dziedziczony <xref:System.Windows.FrameworkElement>z) i zawiera natywną obsługę wielu poleceń edycji.  
  
 Pierwszym argumentem dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metody jest parametr polecenia.  Większość poleceń edycji ignoruje parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien `null` dotyczyć poleceń edycji.  
  
 Drugi argument określa obiekt, do którego zostanie rozesłane polecenie.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinien zawierać procedurę obsługi dla określonego polecenia.  Ogólnie rzecz biorąc, polecenie jest ignorowane w przypadku wywołania na obiekcie, który nie obsługuje tego polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByLine" />
      </Docs>
    </Member>
    <Member MemberName="SelectUpByPage">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectUpByPage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectUpByPage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectUpByPage" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectUpByPage As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectUpByPage { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectUpByPage : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectUpByPage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.EditingCommands.SelectUpByPage" /> Reprezentuje polecenie, które żąda, aby bieżące zaznaczenie zostało rozszerzone o jedną stronę.</summary>
        <value>Żądane polecenie.  Domyślnym gestem dla tego polecenia jest <see langword="Shift" />. + <see langword="PageUp" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest konieczna rzeczywista implementacja, która reaguje na to polecenie na żadnym z określonych obiektów; w wielu przypadkach implementacja, która reaguje na polecenie, jest odpowiedzialna za moduł zapisujący aplikacji.  
  
 To polecenie jest natywnie obsługiwane przez <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectUpByPage"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="SelectUpByPage"/>  
```  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać polecenie edycji na obiekcie, który obsługuje polecenie.  
  
 Na potrzeby tego przykładu <xref:System.Windows.Controls.RichTextBox> służy jako obiekt docelowy polecenia.  Należy pamiętać <xref:System.Windows.Controls.RichTextBox> , że <xref:System.Windows.IInputElement> implementuje interfejs (Dziedziczony <xref:System.Windows.FrameworkElement>z) i zawiera natywną obsługę wielu poleceń edycji.  
  
 Pierwszym argumentem dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metody jest parametr polecenia.  Większość poleceń edycji ignoruje parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien `null` dotyczyć poleceń edycji.  
  
 Drugi argument określa obiekt, do którego zostanie rozesłane polecenie.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinien zawierać procedurę obsługi dla określonego polecenia.  Ogólnie rzecz biorąc, polecenie jest ignorowane w przypadku wywołania na obiekcie, który nie obsługuje tego polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByPage" />
      </Docs>
    </Member>
    <Member MemberName="SelectUpByParagraph">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand SelectUpByParagraph { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand SelectUpByParagraph" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SelectUpByParagraph As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ SelectUpByParagraph { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectUpByParagraph : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.SelectUpByParagraph" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.EditingCommands.SelectUpByParagraph" /> Reprezentuje polecenie, które żąda, aby bieżące zaznaczenie było rozwinięte o jeden akapit.</summary>
        <value>Żądane polecenie.  Domyślnym <see langword="Ctrl" />gestem dla tego polecenia jest. + <see langword="Shift" /> + <see langword="Up" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli karetka znajduje się na początku akapitu, to polecenie rozszerza zaznaczenie na początek poprzedniego akapitu.  W przeciwnym razie to polecenie rozszerza zaznaczenie na początek bieżącego akapitu.  
  
 Nie jest konieczna rzeczywista implementacja, która reaguje na to polecenie na żadnym z określonych obiektów; w wielu przypadkach implementacja, która reaguje na polecenie, jest odpowiedzialna za moduł zapisujący aplikacji.  
  
 To polecenie jest natywnie obsługiwane przez <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_SelectUpByParagraph"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="SelectUpByParagraph"/>  
```  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać polecenie edycji na obiekcie, który obsługuje polecenie.  
  
 Na potrzeby tego przykładu <xref:System.Windows.Controls.RichTextBox> służy jako obiekt docelowy polecenia.  Należy pamiętać <xref:System.Windows.Controls.RichTextBox> , że <xref:System.Windows.IInputElement> implementuje interfejs (Dziedziczony <xref:System.Windows.FrameworkElement>z) i zawiera natywną obsługę wielu poleceń edycji.  
  
 Pierwszym argumentem dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metody jest parametr polecenia.  Większość poleceń edycji ignoruje parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien `null` dotyczyć poleceń edycji.  
  
 Drugi argument określa obiekt, do którego zostanie rozesłane polecenie.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinien zawierać procedurę obsługi dla określonego polecenia.  Ogólnie rzecz biorąc, polecenie jest ignorowane w przypadku wywołania na obiekcie, który nie obsługuje tego polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectDownByParagraph" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByLine" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.SelectUpByPage" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.MoveUpByParagraph" />
      </Docs>
    </Member>
    <Member MemberName="TabBackward">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand TabBackward { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand TabBackward" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.TabBackward" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property TabBackward As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ TabBackward { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TabBackward : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.TabBackward" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.EditingCommands.TabBackward" /> Reprezentuje polecenie.</summary>
        <value>Żądane polecenie.  Domyślnym gestem dla tego polecenia jest <see langword="Shift" />. + <see langword="Tab" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zachowanie tego polecenia zależy od bieżącego zaznaczenia. Jeśli zaznaczenie nie jest puste, to polecenie jest równoważne <xref:System.Windows.Documents.EditingCommands.DecreaseIndentation%2A>. Jeśli karetka znajduje się w komórce tabeli (reprezentowanej przez <xref:System.Windows.Documents.TableCell> element), to polecenie przesuwa karetkę do poprzedniej komórki. W przeciwnym razie znak tabulacji zostanie wstawiony w bieżącym położeniu.  
  
 Nie jest konieczna rzeczywista implementacja, która reaguje na to polecenie na żadnym z określonych obiektów; w wielu przypadkach implementacja, która reaguje na polecenie, jest odpowiedzialna za moduł zapisujący aplikacji.  
  
 To polecenie jest natywnie obsługiwane przez <xref:System.Windows.Controls.RichTextBox> program <xref:System.Windows.Controls.TextBox> i (gdy <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsTab%2A> właściwość ma `true`wartość).  
  
<a name="xamlAttributeUsage_TabBackward"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="TabBackward"/>  
```  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać polecenie edycji na obiekcie, który obsługuje polecenie.  
  
 Na potrzeby tego przykładu <xref:System.Windows.Controls.RichTextBox> służy jako obiekt docelowy polecenia.  Należy pamiętać <xref:System.Windows.Controls.RichTextBox> , że <xref:System.Windows.IInputElement> implementuje interfejs (Dziedziczony <xref:System.Windows.FrameworkElement>z) i zawiera natywną obsługę wielu poleceń edycji.  
  
 Pierwszym argumentem dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metody jest parametr polecenia.  Większość poleceń edycji ignoruje parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien `null` dotyczyć poleceń edycji.  
  
 Drugi argument określa obiekt, do którego zostanie rozesłane polecenie.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinien zawierać procedurę obsługi dla określonego polecenia.  Ogólnie rzecz biorąc, polecenie jest ignorowane w przypadku wywołania na obiekcie, który nie obsługuje tego polecenia.  
  
```csharp  
RichTextBox rTB = new RichTextBox();  
  
EditingCommands.ToggleInsert.Execute(null, rTB);  
  
```  
  
```vb  
            Dim rTB As New RichTextBox()  
  
            EditingCommands.ToggleInsert.Execute(Nothing, rTB)  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.TabForward" />
      </Docs>
    </Member>
    <Member MemberName="TabForward">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand TabForward { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand TabForward" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.TabForward" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property TabForward As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ TabForward { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TabForward : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.TabForward" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.EditingCommands.TabForward" /> Reprezentuje polecenie.</summary>
        <value>Żądane polecenie.  Domyślnym gestem dla tego polecenia jest <see langword="Tab" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zachowanie tego polecenia zależy od bieżącego zaznaczenia. Jeśli zaznaczenie jest niepuste lub jeśli zaznaczenie jest puste i bieżące położenie karetki znajduje się na początku akapitu, to polecenie jest równoważne <xref:System.Windows.Documents.EditingCommands.IncreaseIndentation%2A>. Jeśli karetka znajduje się w komórce tabeli (reprezentowanej przez <xref:System.Windows.Documents.TableCell> element), to polecenie przesuwa karetkę do następnej komórki. Jeśli karetka znajduje się w ostatniej komórce tabeli, to polecenie powoduje dołączenie nowego wiersza do tabeli, z karetką umieszczoną w pierwszej komórce nowego wiersza.  W przeciwnym razie znak tabulacji zostanie wstawiony w bieżącym położeniu.  
  
 Nie jest konieczna rzeczywista implementacja, która reaguje na to polecenie na żadnym z określonych obiektów; w wielu przypadkach implementacja, która reaguje na polecenie, jest odpowiedzialna za moduł zapisujący aplikacji.  
  
 To polecenie jest natywnie obsługiwane przez <xref:System.Windows.Controls.RichTextBox> program <xref:System.Windows.Controls.TextBox> i (gdy <xref:System.Windows.Controls.Primitives.TextBoxBase.AcceptsTab%2A> właściwość ma `true`wartość).  
  
<a name="xamlAttributeUsage_TabForward"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="TabForward"/>  
```  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać polecenie edycji na obiekcie, który obsługuje polecenie.  
  
 Na potrzeby tego przykładu <xref:System.Windows.Controls.RichTextBox> służy jako obiekt docelowy polecenia.  Należy pamiętać <xref:System.Windows.Controls.RichTextBox> , że <xref:System.Windows.IInputElement> implementuje interfejs (Dziedziczony <xref:System.Windows.FrameworkElement>z) i zawiera natywną obsługę wielu poleceń edycji.  
  
 Pierwszym argumentem dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metody jest parametr polecenia.  Większość poleceń edycji ignoruje parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien `null` dotyczyć poleceń edycji.  
  
 Drugi argument określa obiekt, do którego zostanie rozesłane polecenie.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinien zawierać procedurę obsługi dla określonego polecenia.  Ogólnie rzecz biorąc, polecenie jest ignorowane w przypadku wywołania na obiekcie, który nie obsługuje tego polecenia.  
  
```csharp  
RichTextBox rTB = new RichTextBox();  
  
EditingCommands.ToggleInsert.Execute(null, rTB);  
  
```  
  
```vb  
            Dim rTB As New RichTextBox()  
  
            EditingCommands.ToggleInsert.Execute(Nothing, rTB)  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.TabBackward" />
      </Docs>
    </Member>
    <Member MemberName="ToggleBold">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleBold { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleBold" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleBold" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleBold As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleBold { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToggleBold : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.ToggleBold" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje polecenie, które żąda przełączenia <see cref="T:System.Windows.Documents.Bold" /> formatowania w bieżącym zaznaczeniu. <see cref="P:System.Windows.Documents.EditingCommands.ToggleBold" /></summary>
        <value>Żądane polecenie.  Domyślnym gestem dla tego polecenia jest <see langword="Ctrl" />. + <see langword="B" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli dla bieżącego zaznaczenia znajduje się w zakresie od <xref:System.Windows.FontWeights.Thin%2A> do <xref:System.Windows.FontWeights.SemiBold%2A>, <xref:System.Windows.FontWeights.Bold%2A> zostanie zastosowany do bieżącego zaznaczenia. <xref:System.Windows.FontWeight>  W przeciwnym razie jest stosowane. <xref:System.Windows.FontWeights.Normal%2A>  Aby uzyskać porównawczą listę <xref:System.Windows.FontWeight> wartości, zobacz <xref:System.Windows.FontWeights>.  
  
 Gdy zaznaczenie jest puste, a karetka znajduje się w obrębie słowa, zaznaczenie zostanie rozwinięte, aby uwzględnić całe słowo.  
  
 Nie jest konieczna rzeczywista implementacja, która reaguje na to polecenie na żadnym z określonych obiektów; w wielu przypadkach implementacja, która reaguje na polecenie, jest odpowiedzialna za moduł zapisujący aplikacji.  
  
 To polecenie jest natywnie obsługiwane przez <xref:System.Windows.Controls.RichTextBox>program.  
  
<a name="xamlAttributeUsage_ToggleBold"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="ToggleBold"/>  
```  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać polecenie edycji na obiekcie, który obsługuje polecenie.  
  
 Na potrzeby tego przykładu <xref:System.Windows.Controls.RichTextBox> służy jako obiekt docelowy polecenia.  Należy pamiętać <xref:System.Windows.Controls.RichTextBox> , że <xref:System.Windows.IInputElement> implementuje interfejs (Dziedziczony <xref:System.Windows.FrameworkElement>z) i zawiera natywną obsługę wielu poleceń edycji.  
  
 Pierwszym argumentem dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metody jest parametr polecenia.  Większość poleceń edycji ignoruje parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien `null` dotyczyć poleceń edycji.  
  
 Drugi argument określa obiekt, do którego zostanie rozesłane polecenie.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinien zawierać procedurę obsługi dla określonego polecenia.  Ogólnie rzecz biorąc, polecenie jest ignorowane w przypadku wywołania na obiekcie, który nie obsługuje tego polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleItalic" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleUnderline" />
      </Docs>
    </Member>
    <Member MemberName="ToggleBullets">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleBullets { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleBullets" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleBullets" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleBullets As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleBullets { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToggleBullets : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.ToggleBullets" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.EditingCommands.ToggleBullets" /> Reprezentuje polecenie, które żąda, aby formatowanie listy nieuporządkowanej (nazywanej także listą punktowaną) było przełączane w bieżącym zaznaczeniu.</summary>
        <value>Żądane polecenie.  Domyślnym <see langword="Ctrl" />gestem dla tego polecenia jest. + <see langword="Shift" /> + <see langword="L" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To polecenie działa na <xref:System.Windows.Documents.Paragraph> poziomie.  Jeśli to polecenie jest wywoływane dla częściowego zaznaczenia zawartości w obrębie akapitu (w tym pustego zaznaczenia, gdzie karetka znajduje się w akapicie), żądany efekt jest stosowany do całego akapitu.  Jeśli to polecenie jest wywoływane w zaznaczeniu obejmującym wiele akapitów, efekt jest stosowany do całej zawartości każdego akapitu, który uczestniczy w zaznaczeniu.  
  
 Nie jest konieczna rzeczywista implementacja, która reaguje na to polecenie na żadnym z określonych obiektów; w wielu przypadkach implementacja, która reaguje na polecenie, jest odpowiedzialna za moduł zapisujący aplikacji.  
  
 To polecenie jest natywnie obsługiwane przez <xref:System.Windows.Controls.RichTextBox>program.  
  
<a name="xamlAttributeUsage_ToggleBullets"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="ToggleBullets"/>  
```  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać polecenie edycji na obiekcie, który obsługuje polecenie.  
  
 Na potrzeby tego przykładu <xref:System.Windows.Controls.RichTextBox> służy jako obiekt docelowy polecenia.  Należy pamiętać <xref:System.Windows.Controls.RichTextBox> , że <xref:System.Windows.IInputElement> implementuje interfejs (Dziedziczony <xref:System.Windows.FrameworkElement>z) i zawiera natywną obsługę wielu poleceń edycji.  
  
 Pierwszym argumentem dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metody jest parametr polecenia.  Większość poleceń edycji ignoruje parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien `null` dotyczyć poleceń edycji.  
  
 Drugi argument określa obiekt, do którego zostanie rozesłane polecenie.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinien zawierać procedurę obsługi dla określonego polecenia.  Ogólnie rzecz biorąc, polecenie jest ignorowane w przypadku wywołania na obiekcie, który nie obsługuje tego polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleNumbering" />
      </Docs>
    </Member>
    <Member MemberName="ToggleInsert">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleInsert { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleInsert" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleInsert" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleInsert As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleInsert { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToggleInsert : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.ToggleInsert" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.EditingCommands.ToggleInsert" /> Reprezentuje polecenie, które przełącza tryb wpisywania między wstawianiem i zastępowaniem.</summary>
        <value>Żądane polecenie.  Domyślnym gestem dla tego polecenia jest <see langword="Insert" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest konieczna rzeczywista implementacja, która reaguje na to polecenie na żadnym z określonych obiektów; w wielu przypadkach implementacja, która reaguje na polecenie, jest odpowiedzialna za moduł zapisujący aplikacji.  
  
 To polecenie jest natywnie obsługiwane przez <xref:System.Windows.Controls.RichTextBox>, <xref:System.Windows.Controls.TextBox>i <xref:System.Windows.Controls.PasswordBox>.  
  
<a name="xamlAttributeUsage_ToggleInsert"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="ToggleInsert"/>  
```  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać polecenie edycji na obiekcie, który obsługuje polecenie.  
  
 Na potrzeby tego przykładu <xref:System.Windows.Controls.RichTextBox> służy jako obiekt docelowy polecenia.  Należy pamiętać <xref:System.Windows.Controls.RichTextBox> , że <xref:System.Windows.IInputElement> implementuje interfejs (Dziedziczony <xref:System.Windows.FrameworkElement>z) i zawiera natywną obsługę wielu poleceń edycji.  
  
 Pierwszym argumentem dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metody jest parametr polecenia.  Większość poleceń edycji ignoruje parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien `null` dotyczyć poleceń edycji.  
  
 Drugi argument określa obiekt, do którego zostanie rozesłane polecenie.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinien zawierać procedurę obsługi dla określonego polecenia.  Ogólnie rzecz biorąc, polecenie jest ignorowane w przypadku wywołania na obiekcie, który nie obsługuje tego polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToggleItalic">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleItalic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleItalic" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleItalic" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleItalic As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleItalic { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToggleItalic : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.ToggleItalic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje polecenie, które żąda przełączenia <see cref="T:System.Windows.Documents.Italic" /> formatowania w bieżącym zaznaczeniu. <see cref="P:System.Windows.Documents.EditingCommands.ToggleItalic" /></summary>
        <value>Żądane polecenie.  Domyślnym gestem dla tego polecenia jest <see langword="Ctrl" />. + <see langword="I" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli dla bieżącego <xref:System.Windows.FontStyles.Normal%2A> zaznaczenia<xref:System.Windows.FontStyles.Italic%2A> jest stosowane do bieżącego zaznaczenia. <xref:System.Windows.FontStyle>  W przeciwnym razie jest stosowane. <xref:System.Windows.FontStyles.Normal%2A>  
  
 Gdy zaznaczenie jest puste, a karetka znajduje się w obrębie słowa, zaznaczenie zostanie rozwinięte, aby uwzględnić całe słowo.  
  
 Nie jest konieczna rzeczywista implementacja, która reaguje na to polecenie na żadnym z określonych obiektów; w wielu przypadkach implementacja, która reaguje na polecenie, jest odpowiedzialna za moduł zapisujący aplikacji.  
  
 To polecenie jest natywnie obsługiwane przez <xref:System.Windows.Controls.RichTextBox>program.  
  
<a name="xamlAttributeUsage_ToggleItalic"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="ToggleItalic"/>  
```  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać polecenie edycji na obiekcie, który obsługuje polecenie.  
  
 Na potrzeby tego przykładu <xref:System.Windows.Controls.RichTextBox> służy jako obiekt docelowy polecenia.  Należy pamiętać <xref:System.Windows.Controls.RichTextBox> , że <xref:System.Windows.IInputElement> implementuje interfejs (Dziedziczony <xref:System.Windows.FrameworkElement>z) i zawiera natywną obsługę wielu poleceń edycji.  
  
 Pierwszym argumentem dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metody jest parametr polecenia.  Większość poleceń edycji ignoruje parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien `null` dotyczyć poleceń edycji.  
  
 Drugi argument określa obiekt, do którego zostanie rozesłane polecenie.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinien zawierać procedurę obsługi dla określonego polecenia.  Ogólnie rzecz biorąc, polecenie jest ignorowane w przypadku wywołania na obiekcie, który nie obsługuje tego polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleBold" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleUnderline" />
      </Docs>
    </Member>
    <Member MemberName="ToggleNumbering">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleNumbering { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleNumbering" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleNumbering" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleNumbering As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleNumbering { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToggleNumbering : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.ToggleNumbering" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.EditingCommands.ToggleNumbering" /> Reprezentuje polecenie, które wymaga przełączenia formatowania uporządkowanej listy (nazywanej także listą numerowaną) w bieżącym zaznaczeniu.</summary>
        <value>Żądane polecenie.  Domyślnym <see langword="Ctrl" />gestem dla tego polecenia jest. + <see langword="Shift" /> + <see langword="N" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To polecenie działa na <xref:System.Windows.Documents.Paragraph> poziomie.  Jeśli to polecenie jest wywoływane dla częściowego zaznaczenia zawartości w obrębie akapitu (w tym pustego zaznaczenia, gdzie karetka znajduje się w akapicie), żądany efekt jest stosowany do całego akapitu.  Jeśli to polecenie jest wywoływane w zaznaczeniu obejmującym wiele akapitów, efekt jest stosowany do całej zawartości każdego akapitu, który uczestniczy w zaznaczeniu.  
  
 Nie jest konieczna rzeczywista implementacja, która reaguje na to polecenie na żadnym z określonych obiektów; w wielu przypadkach implementacja, która reaguje na polecenie, jest odpowiedzialna za moduł zapisujący aplikacji.  
  
 To polecenie jest natywnie obsługiwane przez <xref:System.Windows.Controls.RichTextBox>program.  
  
<a name="xamlAttributeUsage_ToggleNumbering"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="ToggleNumbering"/>  
```  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać polecenie edycji na obiekcie, który obsługuje polecenie.  
  
 Na potrzeby tego przykładu <xref:System.Windows.Controls.RichTextBox> służy jako obiekt docelowy polecenia.  Należy pamiętać <xref:System.Windows.Controls.RichTextBox> , że <xref:System.Windows.IInputElement> implementuje interfejs (Dziedziczony <xref:System.Windows.FrameworkElement>z) i zawiera natywną obsługę wielu poleceń edycji.  
  
 Pierwszym argumentem dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metody jest parametr polecenia.  Większość poleceń edycji ignoruje parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien `null` dotyczyć poleceń edycji.  
  
 Drugi argument określa obiekt, do którego zostanie rozesłane polecenie.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinien zawierać procedurę obsługi dla określonego polecenia.  Ogólnie rzecz biorąc, polecenie jest ignorowane w przypadku wywołania na obiekcie, który nie obsługuje tego polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleItalic" />
      </Docs>
    </Member>
    <Member MemberName="ToggleSubscript">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleSubscript { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleSubscript" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleSubscript" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleSubscript As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleSubscript { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToggleSubscript : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.ToggleSubscript" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.EditingCommands.ToggleSubscript" /> Reprezentuje polecenie, które żąda przełączenia formatowania indeksu w bieżącym zaznaczeniu.</summary>
        <value>Żądane polecenie.  Domyślnym gestem dla tego polecenia jest <see langword="Ctrl" />. + <see langword="OemPlus" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest konieczna rzeczywista implementacja, która reaguje na to polecenie na żadnym z określonych obiektów; w wielu przypadkach implementacja, która reaguje na polecenie, jest odpowiedzialna za moduł zapisujący aplikacji.  
  
<a name="xamlAttributeUsage_ToggleSubscript"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="ToggleSubscript"/>  
```  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać polecenie edycji na obiekcie, który obsługuje polecenie.  
  
 Na potrzeby tego przykładu <xref:System.Windows.Controls.RichTextBox> służy jako obiekt docelowy polecenia.  Należy pamiętać <xref:System.Windows.Controls.RichTextBox> , że <xref:System.Windows.IInputElement> implementuje interfejs (Dziedziczony <xref:System.Windows.FrameworkElement>z) i zawiera natywną obsługę wielu poleceń edycji.  
  
 Pierwszym argumentem dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metody jest parametr polecenia.  Większość poleceń edycji ignoruje parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien `null` dotyczyć poleceń edycji.  
  
 Drugi argument określa obiekt, do którego zostanie rozesłane polecenie.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinien zawierać procedurę obsługi dla określonego polecenia.  Ogólnie rzecz biorąc, polecenie jest ignorowane w przypadku wywołania na obiekcie, który nie obsługuje tego polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleSuperscript" />
      </Docs>
    </Member>
    <Member MemberName="ToggleSuperscript">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleSuperscript { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleSuperscript" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleSuperscript" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleSuperscript As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleSuperscript { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToggleSuperscript : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.ToggleSuperscript" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Documents.EditingCommands.ToggleSuperscript" /> Reprezentuje polecenie, które żąda przełączenia formatowania indeksu górnego w bieżącym zaznaczeniu.</summary>
        <value>Żądane polecenie.  Domyślnym <see langword="Ctrl" />gestem dla tego polecenia jest. + <see langword="Shift" /> + <see langword="OemPlus" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest konieczna rzeczywista implementacja, która reaguje na to polecenie na żadnym z określonych obiektów; w wielu przypadkach implementacja, która reaguje na polecenie, jest odpowiedzialna za moduł zapisujący aplikacji.  
  
<a name="xamlAttributeUsage_ToggleSuperscript"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="ToggleSuperscript"/>  
```  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać polecenie edycji na obiekcie, który obsługuje polecenie.  
  
 Na potrzeby tego przykładu <xref:System.Windows.Controls.RichTextBox> służy jako obiekt docelowy polecenia.  Należy pamiętać <xref:System.Windows.Controls.RichTextBox> , że <xref:System.Windows.IInputElement> implementuje interfejs (Dziedziczony <xref:System.Windows.FrameworkElement>z) i zawiera natywną obsługę wielu poleceń edycji.  
  
 Pierwszym argumentem dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metody jest parametr polecenia.  Większość poleceń edycji ignoruje parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien `null` dotyczyć poleceń edycji.  
  
 Drugi argument określa obiekt, do którego zostanie rozesłane polecenie.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinien zawierać procedurę obsługi dla określonego polecenia.  Ogólnie rzecz biorąc, polecenie jest ignorowane w przypadku wywołania na obiekcie, który nie obsługuje tego polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleSubscript" />
      </Docs>
    </Member>
    <Member MemberName="ToggleUnderline">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.RoutedUICommand ToggleUnderline { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.RoutedUICommand ToggleUnderline" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.EditingCommands.ToggleUnderline" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ToggleUnderline As RoutedUICommand" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::RoutedUICommand ^ ToggleUnderline { System::Windows::Input::RoutedUICommand ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToggleUnderline : System.Windows.Input.RoutedUICommand" Usage="System.Windows.Documents.EditingCommands.ToggleUnderline" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RoutedUICommand</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Reprezentuje polecenie, które żąda przełączenia <see cref="T:System.Windows.Documents.Underline" /> formatowania w bieżącym zaznaczeniu. <see cref="P:System.Windows.Documents.EditingCommands.ToggleUnderline" /></summary>
        <value>Żądane polecenie.  Domyślnym gestem dla tego polecenia jest <see langword="Ctrl" />. + <see langword="U" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy zaznaczenie jest puste, a karetka znajduje się w obrębie słowa, zaznaczenie zostanie rozwinięte, aby uwzględnić całe słowo.  
  
 Nie jest konieczna rzeczywista implementacja, która reaguje na to polecenie na żadnym z określonych obiektów; w wielu przypadkach implementacja, która reaguje na polecenie, jest odpowiedzialna za moduł zapisujący aplikacji.  
  
 To polecenie jest natywnie obsługiwane przez <xref:System.Windows.Controls.RichTextBox>program.  
  
<a name="xamlAttributeUsage_ToggleUnderline"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object property="ToggleUnderline"/>  
```  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak wywołać polecenie edycji na obiekcie, który obsługuje polecenie.  
  
 Na potrzeby tego przykładu <xref:System.Windows.Controls.RichTextBox> służy jako obiekt docelowy polecenia.  Należy pamiętać <xref:System.Windows.Controls.RichTextBox> , że <xref:System.Windows.IInputElement> implementuje interfejs (Dziedziczony <xref:System.Windows.FrameworkElement>z) i zawiera natywną obsługę wielu poleceń edycji.  
  
 Pierwszym argumentem dla <xref:System.Windows.Input.RoutedCommand.Execute%2A> metody jest parametr polecenia.  Większość poleceń edycji ignoruje parametr polecenia; Ogólnie rzecz biorąc, ten parametr powinien `null` dotyczyć poleceń edycji.  
  
 Drugi argument określa obiekt, do którego zostanie rozesłane polecenie.  Ten obiekt musi implementować <xref:System.Windows.IInputElement> interfejs i powinien zawierać procedurę obsługi dla określonego polecenia.  Ogólnie rzecz biorąc, polecenie jest ignorowane w przypadku wywołania na obiekcie, który nie obsługuje tego polecenia.  
  
 [!code-csharp[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBoxSnippets/CSharp/Window1.xaml.cs#_editingcommands_invoke)]
 [!code-vb[RichTextBoxSnippets#_EditingCommands_Invoke](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RichTextBoxSnippets/visualbasic/window1.xaml.vb#_editingcommands_invoke)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleBold" />
        <altmember cref="P:System.Windows.Documents.EditingCommands.ToggleItalic" />
      </Docs>
    </Member>
  </Members>
</Type>

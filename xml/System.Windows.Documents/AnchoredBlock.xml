<Type Name="AnchoredBlock" FullName="System.Windows.Documents.AnchoredBlock">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e4fcbd11dedcaaa3ff79684a5bd19820e5d388db" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69209072" /></Metadata><TypeSignature Language="C#" Value="public abstract class AnchoredBlock : System.Windows.Documents.Inline" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit AnchoredBlock extends System.Windows.Documents.Inline" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Documents.AnchoredBlock" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class AnchoredBlock&#xA;Inherits Inline" />
  <TypeSignature Language="C++ CLI" Value="public ref class AnchoredBlock abstract : System::Windows::Documents::Inline" />
  <TypeSignature Language="F#" Value="type AnchoredBlock = class&#xA;    inherit Inline" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Documents.Inline</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Markup.ContentProperty("Blocks")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Klasa abstrakcyjna, która stanowi podstawę <see cref="T:System.Windows.Documents.Inline" /> dla elementów, które są używane <see cref="T:System.Windows.Documents.Block" /> do zakotwiczenia elementów do przepływu zawartości.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected AnchoredBlock (System.Windows.Documents.Block block, System.Windows.Documents.TextPointer insertionPosition);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Windows.Documents.Block block, class System.Windows.Documents.TextPointer insertionPosition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.AnchoredBlock.#ctor(System.Windows.Documents.Block,System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; AnchoredBlock(System::Windows::Documents::Block ^ block, System::Windows::Documents::TextPointer ^ insertionPosition);" />
      <MemberSignature Language="F#" Value="new System.Windows.Documents.AnchoredBlock : System.Windows.Documents.Block * System.Windows.Documents.TextPointer -&gt; System.Windows.Documents.AnchoredBlock" Usage="new System.Windows.Documents.AnchoredBlock (block, insertionPosition)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="block" Type="System.Windows.Documents.Block" />
        <Parameter Name="insertionPosition" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="block"><see cref="T:System.Windows.Documents.Block" /> Obiekt określający początkową zawartość nowego elementu.  Ten parametr może mieć <see langword="null" />stan, w którym nie <see cref="T:System.Windows.Documents.Block" /> wstawiono żadnego przypadku.</param>
        <param name="insertionPosition">Określenie pozycji wstawiania, w której ma zostać wstawiony element po utworzeniu lub <see langword="null" /> bez automatycznego wstawiania. <see cref="T:System.Windows.Documents.TextPointer" /></param>
        <summary>Inicjuje wartości klasy bazowej, gdy są wywoływane przez klasę pochodną, pobierając <see cref="T:System.Windows.Documents.Block" /> określony obiekt jako początkową zawartość nowego <see cref="T:System.Windows.Documents.AnchoredBlock" />elementu podrzędnego i <see cref="T:System.Windows.Documents.TextPointer" /> określając pozycję wstawiania dla nowego <see cref="T:System.Windows.Documents.AnchoredBlock" /> elementu podrzędnego.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Blocks">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.BlockCollection Blocks { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.BlockCollection Blocks" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.AnchoredBlock.Blocks" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Blocks As BlockCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::BlockCollection ^ Blocks { System::Windows::Documents::BlockCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Blocks : System.Windows.Documents.BlockCollection" Usage="System.Windows.Documents.AnchoredBlock.Blocks" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.BlockCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera zawierający elementy najwyższego poziomu <see cref="T:System.Windows.Documents.Block" /> , które tworzą zawartość elementu. <see cref="T:System.Windows.Documents.BlockCollection" /></summary>
        <value><see cref="T:System.Windows.Documents.BlockCollection" /> Element<see cref="T:System.Windows.Documents.Block" /> zawierający elementy, które składają się na zawartość elementu.  
  
Ta właściwość nie ma wartości domyślnej.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BorderBrush">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Brush BorderBrush { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Brush BorderBrush" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.AnchoredBlock.BorderBrush" />
      <MemberSignature Language="VB.NET" Value="Public Property BorderBrush As Brush" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Brush ^ BorderBrush { System::Windows::Media::Brush ^ get(); void set(System::Windows::Media::Brush ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BorderBrush : System.Windows.Media.Brush with get, set" Usage="System.Windows.Documents.AnchoredBlock.BorderBrush" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Brush</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość <see cref="T:System.Windows.Media.Brush" /> do użycia podczas rysowania obramowania elementu.</summary>
        <value>Pędzel używany do zastosowania do obramowania elementu. Wartość domyślna to <see langword="null" /> pędzel.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać tabelę próbek pokazującą dostępne wstępnie zdefiniowane kolory pędzla, zobacz <xref:System.Windows.Media.Brushes>.  
  
<a name="dependencyPropertyInfo_BorderBrush"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Documents.AnchoredBlock.BorderBrushProperty>|  
|Właściwości metadanych ustawione na`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>|  
  
   
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.Windows.Documents.Block.BorderBrush%2A> jak ustawić atrybut elementu (<xref:System.Windows.Documents.Paragraph>).  
  
 [!code-xaml[BlockSnippets#_Block_BordersXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/BlockSnippets/CSharp/Window1.xaml#_block_bordersxaml)]  
  
 Na poniższej ilustracji przedstawiono sposób renderowania tego przykładu.  
  
 ![Zrzut ekranu Niebieskie, 1&#47;4inch obramowanie wokół]zrzutu ekranu blokowego(~/add/media/block-borders.png ": Niebieskie, 1/4inch obramowanie wokół bloku")  
  
 Poniższy przykład pokazuje, <xref:System.Windows.Documents.Block.BorderBrush%2A> jak ustawić właściwości programowo.  
  
 [!code-csharp[BlockSnippets#_Block_Borders](~/samples/snippets/csharp/VS_Snippets_Wpf/BlockSnippets/CSharp/Window1.xaml.cs#_block_borders)]
 [!code-vb[BlockSnippets#_Block_Borders](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BlockSnippets/visualbasic/window1.xaml.vb#_block_borders)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.AnchoredBlock.BorderThickness" />
      </Docs>
    </Member>
    <Member MemberName="BorderBrushProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BorderBrushProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BorderBrushProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Documents.AnchoredBlock.BorderBrushProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BorderBrushProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BorderBrushProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable BorderBrushProperty : System.Windows.DependencyProperty" Usage="System.Windows.Documents.AnchoredBlock.BorderBrushProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.Documents.AnchoredBlock.BorderBrush" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BorderThickness">
      <MemberSignature Language="C#" Value="public System.Windows.Thickness BorderThickness { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Thickness BorderThickness" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.AnchoredBlock.BorderThickness" />
      <MemberSignature Language="VB.NET" Value="Public Property BorderThickness As Thickness" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Thickness BorderThickness { System::Windows::Thickness get(); void set(System::Windows::Thickness value); };" />
      <MemberSignature Language="F#" Value="member this.BorderThickness : System.Windows.Thickness with get, set" Usage="System.Windows.Documents.AnchoredBlock.BorderThickness" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Thickness</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia grubość obramowania elementu.</summary>
        <value><see cref="T:System.Windows.Thickness" /> Struktura określająca ilość obramowania do zastosowania w pikselach niezależnych od urządzenia.  
  
Wartość domyślna to Jednolita grubość równa zero (**0,0**).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="xamlAttributeUsage_BorderThickness"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object BorderThickness="uniformThickness"/>  
- or -  
<object BorderThickness="independentThickness"/>  
- or -  
<object BorderThickness="qualifiedUniformThickness"/>  
- or -  
<object BorderThickness="qualifiedIndependentThickness"/>  
```  
  
<a name="xamlValues_BorderThickness"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *uniformThickness*  
 Reprezentacja pojedynczej <xref:System.Double> wartości w postaci ciągu, która ma być jednolicie stosowana do wszystkich wymiarów z czterema grubościami.  Na przykład wartość `"10"` jest równa `"10,10,10,10"`wartości.  Niekwalifikowana wartość jest mierzona w pikselach niezależnych od urządzenia. Ciągi nie muszą jawnie zawierać punktów dziesiętnych.  
  
 *independentThickness*  
 Ciąg reprezentujący cztery uporządkowane <xref:System.Double> wartości, które odpowiadają niezależnym wymiarom grubości dla lewego, górnego, prawego i dolnego, w tej kolejności.  Cztery wartości muszą być oddzielone przecinkami; spacje są niedozwolone.  Na przykład "5, 10, 15, 20" powoduje 5 pikseli obramowania z lewej strony zawartości, 10 pikseli obramowania powyżej zawartości, 15 pikseli obramowania z prawej strony zawartości i 20 pikseli obramowania poniżej zawartości.  
  
 *qualifiedUniformThickness*  
 Wartość opisana przez *uniformThickness* , po której następuje jeden z następujących specyfikatorów jednostek: `px`, `in`.  
  
 `px`(wartość domyślna) to[!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` is inches; 1in==96px  
  
 Na przykład program `"1in"` zapewnia jednolite obramowanie 1 cala we wszystkich kierunkach.  
  
 *qualifiedIndependentThickness*  
 Wartość opisana przez *independentThickness*, z każdą niezależną wartością, a po niej jeden z następujących specyfikatorów `px`jednostek `in`:,.  
  
 `px`(wartość domyślna) to[!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` is inches; 1in==96px  
  
 Na przykład `"1.5in,0.8in,1.5in,0.8in"`.  Specyfikatory jednostek mogą być mieszane lub pomijane z co najmniej jednej wartości.  
  
<a name="dependencyPropertyInfo_BorderThickness"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Documents.AnchoredBlock.BorderThicknessProperty>|  
|Właściwości metadanych ustawione na`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.Windows.Documents.Block.BorderThickness%2A> jak ustawić atrybut <xref:System.Windows.Documents.Block> elementu (<xref:System.Windows.Documents.Paragraph>).  
  
 [!code-xaml[BlockSnippets#_Block_BordersXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/BlockSnippets/CSharp/Window1.xaml#_block_bordersxaml)]  
  
 Na poniższej ilustracji przedstawiono sposób renderowania tego przykładu.  
  
 ![Zrzut ekranu Niebieskie, 1&#47;4inch obramowanie wokół]zrzutu ekranu blokowego(~/add/media/block-borders.png ": Niebieskie, 1/4inch obramowanie wokół bloku")  
  
 Poniższy przykład pokazuje, <xref:System.Windows.Documents.Block.BorderThickness%2A> jak ustawić właściwości programowo.  
  
 [!code-csharp[BlockSnippets#_Block_Borders](~/samples/snippets/csharp/VS_Snippets_Wpf/BlockSnippets/CSharp/Window1.xaml.cs#_block_borders)]
 [!code-vb[BlockSnippets#_Block_Borders](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BlockSnippets/visualbasic/window1.xaml.vb#_block_borders)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.AnchoredBlock.BorderBrush" />
      </Docs>
    </Member>
    <Member MemberName="BorderThicknessProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BorderThicknessProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BorderThicknessProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Documents.AnchoredBlock.BorderThicknessProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BorderThicknessProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BorderThicknessProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable BorderThicknessProperty : System.Windows.DependencyProperty" Usage="System.Windows.Documents.AnchoredBlock.BorderThicknessProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.Documents.AnchoredBlock.BorderThickness" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LineHeight">
      <MemberSignature Language="C#" Value="public double LineHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 LineHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.AnchoredBlock.LineHeight" />
      <MemberSignature Language="VB.NET" Value="Public Property LineHeight As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double LineHeight { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.LineHeight : double with get, set" Usage="System.Windows.Documents.AnchoredBlock.LineHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wysokość każdego wiersza zawartości.</summary>
        <value>Wartość podwójnej precyzji określająca wysokość linii w pikselach niezależnych od urządzenia.  <see cref="P:System.Windows.Documents.AnchoredBlock.LineHeight" />musi mieć wartość równą lub większą niż <c>0,0034</c> i równą lub mniejszą od <c>160000</c>.  
  
Wartość <see cref="F:System.Double.NaN" /> (równoważnej wartości atrybutu "Auto") powoduje<c></c>, że wysokość linii jest ustalana automatycznie z bieżącej charakterystyki czcionki.  
  
Wartość domyślna to <see cref="F:System.Double.NaN" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zmiana tej wartości nie powoduje zmiany wysokości skojarzonego tekstu; Zamiast tego zmienia wysokość linii zawierającej tekst.  
  
 Oprócz tej właściwości ma wpływ <xref:System.Windows.Documents.AnchoredBlock> <xref:System.Windows.Documents.AnchoredBlock.LineStackingStrategy%2A> na układ wierszy w elemencie.  
  
<a name="xamlAttributeUsage_LineHeight"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object LineHeight="double"/>  
- or -  
<object LineHeight="qualifiedDouble"/>  
- or -  
<object LineHeight="Auto"/>  
```  
  
<a name="xamlValues_LineHeight"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *double*  
 Ciąg reprezentujący <xref:System.Double> wartość równą lub większą niż `0.0034` , ale równą lub mniejszą niż `160000`. Niekwalifikowana wartość jest mierzona w pikselach niezależnych od urządzenia. Ciągi nie muszą jawnie zawierać punktów dziesiętnych.  
  
 *qualifiedDouble*  
 Wartość *Podwójna* , jak opisano powyżej (z wyjątkiem `Auto`), po której następuje jeden z następujących specyfikatorów jednostek `px`: `in`, `cm`, `pt`,.  
  
 `px`(wartość domyślna) to[!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` is inches; 1in==96px  
  
 `cm`jest centymetry; 1cm = = (96/2.54) px  
  
 `pt`to punkty; 1 pkt = = (96/72) px  
  
 Auto  
 Powoduje, że wysokość linii jest ustalana automatycznie z obecnej charakterystyki czcionki.  Odpowiednik wartości <xref:System.Double.NaN>właściwości.  
  
<a name="dependencyPropertyInfo_LineHeight"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Documents.AnchoredBlock.LineHeightProperty>|  
|Właściwości metadanych ustawione na`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.Windows.Documents.AnchoredBlock.LineHeight%2A> jak ustawić atrybut <xref:System.Windows.Documents.Block> elementu.  
  
 [!code-xaml[BlockSnippets#_Block_LineHeightXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/BlockSnippets/CSharp/Window1.xaml#_block_lineheightxaml)]  
  
 Na poniższej ilustracji przedstawiono sposób renderowania poprzedniego przykładu.  
  
 ![Zrzut ekranu Zrzut ekranu]FlowDocument LineHeight:(~/add/media/flowdocument-lineheight.png " FlowDocument LineHeight")  
  
 Na poniższej ilustracji przedstawiono sposób renderowania tego samego przykładu z ustawieniem <xref:System.Windows.Documents.AnchoredBlock.LineHeight%2A> = <xref:System.Double.NaN>domyślnym.  
  
 ![Zrzut ekranu ]Domyślny(~/add/media/flowdocument-lineheightdefault.png "zrzut ekranu FlowDocument LineHeight: FlowDocument LineHeight domyślne")  
  
 Poniższy przykład pokazuje, <xref:System.Windows.Documents.AnchoredBlock.LineHeight%2A> jak ustawić właściwości programowo.  
  
 [!code-csharp[BlockSnippets#_Block_LineHeight](~/samples/snippets/csharp/VS_Snippets_Wpf/BlockSnippets/CSharp/Window1.xaml.cs#_block_lineheight)]
 [!code-vb[BlockSnippets#_Block_LineHeight](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BlockSnippets/visualbasic/window1.xaml.vb#_block_lineheight)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Uruchamiany, Jeśli podjęto próbę ustawienia <see cref="P:System.Windows.Controls.TextBlock.LineHeight" /> wartości niedodatniej.</exception>
      </Docs>
    </Member>
    <Member MemberName="LineHeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LineHeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LineHeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Documents.AnchoredBlock.LineHeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LineHeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LineHeightProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable LineHeightProperty : System.Windows.DependencyProperty" Usage="System.Windows.Documents.AnchoredBlock.LineHeightProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.Documents.AnchoredBlock.LineHeight" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LineStackingStrategy">
      <MemberSignature Language="C#" Value="public System.Windows.LineStackingStrategy LineStackingStrategy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.LineStackingStrategy LineStackingStrategy" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.AnchoredBlock.LineStackingStrategy" />
      <MemberSignature Language="VB.NET" Value="Public Property LineStackingStrategy As LineStackingStrategy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::LineStackingStrategy LineStackingStrategy { System::Windows::LineStackingStrategy get(); void set(System::Windows::LineStackingStrategy value); };" />
      <MemberSignature Language="F#" Value="member this.LineStackingStrategy : System.Windows.LineStackingStrategy with get, set" Usage="System.Windows.Documents.AnchoredBlock.LineStackingStrategy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.LineStackingStrategy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia mechanizm, za pomocą którego pole wiersza jest ustalane dla każdego wiersza tekstu w elemencie tekstowym.</summary>
        <value>Mechanizm, za pomocą którego pole wiersza jest ustalane dla każdego wiersza tekstu w elemencie tekstowym. Wartość domyślna to <see cref="F:System.Windows.LineStackingStrategy.MaxHeight" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_LineStackingStrategyProperty"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Documents.AnchoredBlock.LineStackingStrategyProperty>|  
|Właściwości metadanych ustawione na`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.Windows.Controls.TextBlock.LineStackingStrategy%2A> jak używać właściwości, aby określić sposób tworzenia pól liniowych dla wierszy <xref:System.Windows.Controls.TextBlock>tekstu. Pierwszy <xref:System.Windows.Controls.TextBlock> <xref:System.Windows.LineStackingStrategy.BlockLineHeight>ma wartość ,<xref:System.Windows.LineStackingStrategy.MaxHeight> a drugi<xref:System.Windows.Controls.TextBlock>mawartość. <xref:System.Windows.Controls.TextBlock.LineStackingStrategy%2A>  
  
 [!code-xaml[FlowMiscSnippets_snip#LineStackingStrategyExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/FlowMiscSnippets_snip/cs/linestackingstrategyexample.xaml#linestackingstrategyexamplewholepage)]  
  
 Na poniższej ilustracji przedstawiono wynik powyższego kodu.  
  
 ![Zrzut ekranu Porównuje LineStackingStrategy]wartości(~/add/media/flow-linestackingstrategy.gif "zrzutu ekranu: Porównaj wartości LineStackingStrategy")  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LineStackingStrategyProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LineStackingStrategyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LineStackingStrategyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Documents.AnchoredBlock.LineStackingStrategyProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LineStackingStrategyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LineStackingStrategyProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable LineStackingStrategyProperty : System.Windows.DependencyProperty" Usage="System.Windows.Documents.AnchoredBlock.LineStackingStrategyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.Documents.AnchoredBlock.LineStackingStrategy" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Margin">
      <MemberSignature Language="C#" Value="public System.Windows.Thickness Margin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Thickness Margin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.AnchoredBlock.Margin" />
      <MemberSignature Language="VB.NET" Value="Public Property Margin As Thickness" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Thickness Margin { System::Windows::Thickness get(); void set(System::Windows::Thickness value); };" />
      <MemberSignature Language="F#" Value="member this.Margin : System.Windows.Thickness with get, set" Usage="System.Windows.Documents.AnchoredBlock.Margin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Thickness</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia grubość marginesu dla elementu.</summary>
        <value><see cref="T:System.Windows.Thickness" /> Struktura określająca ilość marginesu do zastosowania w pikselach niezależnych od urządzenia.  
  
Wartość domyślna to Jednolita grubość równa zero (**0,0**).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Documents.ListItem.Margin%2A>jest przestrzenią buforową, która znajduje się poza obszarem zawartości elementu, między krawędziami obszaru zawartości elementu a krawędziami elementu nadrzędnego.  Kontrast z <xref:System.Windows.Documents.ListItem.Padding%2A>, czyli przestrzenią buforową, która znajduje się wewnątrz obszaru zawartości elementu, między zawartością elementu a wewnętrzną krawędzią elementu.  
  
<a name="xamlAttributeUsage_Margin"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object Margin="uniformThickness"/>  
- or -  
<object Margin="independentThickness"/>  
- or -  
<object Margin="qualifiedUniformThickness"/>  
- or -  
<object Margin="qualifiedIndependentThickness"/>  
```  
  
<a name="xamlValues_Margin"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *uniformThickness*  
 Reprezentacja pojedynczej <xref:System.Double> wartości w postaci ciągu, która ma być jednolicie stosowana do wszystkich wymiarów z czterema grubościami.  Na przykład wartość `"10"` jest równa `"10,10,10,10"`wartości.  Niekwalifikowana wartość jest mierzona w pikselach niezależnych od urządzenia. Ciągi nie muszą jawnie zawierać punktów dziesiętnych.  
  
 *independentThickness*  
 Ciąg reprezentujący cztery uporządkowane <xref:System.Double> wartości, które odpowiadają niezależnym wymiarom grubości dla lewego, górnego, prawego i dolnego, w tej kolejności.  Cztery wartości muszą być oddzielone przecinkami; spacje są niedozwolone.  Na przykład "5, 10, 15, 20" powoduje 5 pikseli marginesu na lewo od zawartości, 10 pikseli marginesu powyżej zawartości, 15 pikseli marginesu po prawej stronie zawartości oraz 20 pikseli marginesu poniżej zawartości.  
  
 *qualifiedUniformThickness*  
 Wartość opisana przez *uniformThickness* , po której następuje jeden z następujących specyfikatorów jednostek: `px`, `in`.  
  
 `px`(wartość domyślna) to[!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` is inches; 1in==96px  
  
 Na przykład program `"1in"` zapewnia jednolity margines 1 cal we wszystkich kierunkach.  
  
 *qualifiedIndependentThickness*  
 Wartość opisana przez *independentThickness*, z każdą niezależną wartością, a po niej jeden z następujących specyfikatorów `px`jednostek `in`:,.  
  
 `px`(wartość domyślna) to[!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` is inches; 1in==96px  
  
 Na przykład `"1.5in,0.8in,1.5in,0.8in"`.  Specyfikatory jednostek mogą być mieszane lub pomijane z co najmniej jednej wartości.  
  
<a name="dependencyPropertyInfo_Margin"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Documents.AnchoredBlock.MarginProperty>|  
|Właściwości metadanych ustawione na`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.Windows.Documents.AnchoredBlock.Margin%2A> jak ustawić atrybut <xref:System.Windows.Documents.Block> elementu (<xref:System.Windows.Documents.Paragraph>).  
  
 [!code-xaml[BlockSnippets#_Block_MarginPaddingXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/BlockSnippets/CSharp/Window1.xaml#_block_marginpaddingxaml)]  
  
 Na poniższej ilustracji przedstawiono sposób renderowania tego przykładu.  Do ilustracji są używane Exaggeratedki i kolory.  
  
 ![Zrzut ekranu Akapity z zrzutem]ekranu wypełnienia i marginesów(~/add/media/block-marginpadding.png ": Akapity z dopełnieniem i marginesami")  
  
 Poniższy przykład pokazuje, <xref:System.Windows.Documents.AnchoredBlock.Margin%2A> jak ustawić właściwości programowo.  
  
 [!code-csharp[BlockSnippets#_Block_MarginPadding](~/samples/snippets/csharp/VS_Snippets_Wpf/BlockSnippets/CSharp/Window1.xaml.cs#_block_marginpadding)]
 [!code-vb[BlockSnippets#_Block_MarginPadding](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BlockSnippets/visualbasic/window1.xaml.vb#_block_marginpadding)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MarginProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MarginProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MarginProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Documents.AnchoredBlock.MarginProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MarginProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MarginProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable MarginProperty : System.Windows.DependencyProperty" Usage="System.Windows.Documents.AnchoredBlock.MarginProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.Documents.AnchoredBlock.Margin" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Padding">
      <MemberSignature Language="C#" Value="public System.Windows.Thickness Padding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Thickness Padding" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.AnchoredBlock.Padding" />
      <MemberSignature Language="VB.NET" Value="Public Property Padding As Thickness" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Thickness Padding { System::Windows::Thickness get(); void set(System::Windows::Thickness value); };" />
      <MemberSignature Language="F#" Value="member this.Padding : System.Windows.Thickness with get, set" Usage="System.Windows.Documents.AnchoredBlock.Padding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Thickness</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia grubość wypełnienia dla elementu.</summary>
        <value><see cref="T:System.Windows.Thickness" /> Struktura określająca ilość dopełnienia do zastosowania w pikselach niezależnych od urządzenia.  
  
Wartość domyślna to Jednolita grubość równa zero (**0,0**).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Documents.ListItem.Padding%2A>jest przestrzenią buforową, która znajduje się wewnątrz obszaru zawartości elementu, między zawartością elementu a wewnętrzną krawędzią elementu.  Kontrast z <xref:System.Windows.Documents.ListItem.Margin%2A>, czyli przestrzenią buforową, która znajduje się poza obszarem zawartości elementu, między krawędziami obszaru zawartości elementu a krawędziami elementu nadrzędnego.  
  
<a name="xamlAttributeUsage_Padding"></a>   
## <a name="xaml-attribute-usage"></a>Użycie atrybutu języka XAML  
  
```  
<object Padding="uniformThickness"/>  
- or -  
<object Padding="independentThickness"/>  
- or -  
<object Padding="qualifiedUniformThickness"/>  
- or -  
<object Padding="qualifiedIndependentThickness"/>  
```  
  
<a name="xamlValues_Padding"></a>   
## <a name="xaml-values"></a>Wartości XAML  
 *uniformThickness*  
 Reprezentacja pojedynczej <xref:System.Double> wartości w postaci ciągu, która ma być jednolicie stosowana do wszystkich wymiarów z czterema grubościami.  Na przykład wartość `"10"` jest równa `"10,10,10,10"`wartości.  Niekwalifikowana wartość jest mierzona w pikselach niezależnych od urządzenia. Ciągi nie muszą jawnie zawierać punktów dziesiętnych.  
  
 *independentThickness*  
 Ciąg reprezentujący cztery uporządkowane <xref:System.Double> wartości, które odpowiadają niezależnym wymiarom grubości dla lewego, górnego, prawego i dolnego, w tej kolejności.  Cztery wartości muszą być oddzielone przecinkami; spacje są niedozwolone.  Na przykład "5, 10, 15, 20" skutkuje dopełnieniem do lewej strony zawartości, 10 pikselami wypełnienia powyżej zawartości, 15 pikselami wypełnienia po prawej stronie zawartości oraz 20 pikseli wypełnienia poniżej zawartości.  
  
 *qualifiedUniformThickness*  
 Wartość opisana przez *uniformThickness* , po której następuje jeden z następujących specyfikatorów jednostek: `px`, `in`.  
  
 `px`(wartość domyślna) to[!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` is inches; 1in==96px  
  
 Na przykład program `"1in"` zapewnia jednolite uzupełnienie 1 cala we wszystkich kierunkach.  
  
 *qualifiedIndependentThickness*  
 Wartość opisana przez *independentThickness*, z każdą niezależną wartością, a po niej jeden z następujących specyfikatorów `px`jednostek `in`:,.  
  
 `px`(wartość domyślna) to[!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` is inches; 1in==96px  
  
 Na przykład `"1.5in,0.8in,1.5in,0.8in"`.  Specyfikatory jednostek mogą być mieszane lub pomijane z co najmniej jednej wartości.  
  
<a name="dependencyPropertyInfo_Padding"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Documents.AnchoredBlock.PaddingProperty>|  
|Właściwości metadanych ustawione na`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.Windows.Documents.AnchoredBlock.Padding%2A> jak ustawić atrybut <xref:System.Windows.Documents.Block> elementu (<xref:System.Windows.Documents.Paragraph>).  
  
 [!code-xaml[BlockSnippets#_Block_MarginPaddingXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/BlockSnippets/CSharp/Window1.xaml#_block_marginpaddingxaml)]  
  
 Na poniższej ilustracji przedstawiono sposób renderowania tego przykładu.  Do ilustracji są używane Exaggeratedki i kolory.  
  
 ![Zrzut ekranu Akapity z zrzutem]ekranu wypełnienia i marginesów(~/add/media/block-marginpadding.png ": Akapity z dopełnieniem i marginesami")  
  
 Poniższy przykład pokazuje, <xref:System.Windows.Documents.AnchoredBlock.Padding%2A> jak ustawić właściwości programowo.  
  
 [!code-csharp[BlockSnippets#_Block_MarginPadding](~/samples/snippets/csharp/VS_Snippets_Wpf/BlockSnippets/CSharp/Window1.xaml.cs#_block_marginpadding)]
 [!code-vb[BlockSnippets#_Block_MarginPadding](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BlockSnippets/visualbasic/window1.xaml.vb#_block_marginpadding)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PaddingProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty PaddingProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty PaddingProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Documents.AnchoredBlock.PaddingProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PaddingProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ PaddingProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable PaddingProperty : System.Windows.DependencyProperty" Usage="System.Windows.Documents.AnchoredBlock.PaddingProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.Documents.AnchoredBlock.Padding" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeBlocks">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeBlocks (System.Windows.Markup.XamlDesignerSerializationManager manager);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeBlocks(class System.Windows.Markup.XamlDesignerSerializationManager manager) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.AnchoredBlock.ShouldSerializeBlocks(System.Windows.Markup.XamlDesignerSerializationManager)" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeBlocks (manager As XamlDesignerSerializationManager) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeBlocks(System::Windows::Markup::XamlDesignerSerializationManager ^ manager);" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeBlocks : System.Windows.Markup.XamlDesignerSerializationManager -&gt; bool" Usage="anchoredBlock.ShouldSerializeBlocks manager" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="manager" Type="System.Windows.Markup.XamlDesignerSerializationManager" />
      </Parameters>
      <Docs>
        <param name="manager">Obiekt Menedżera usługi serializacji dla tego obiektu.</param>
        <summary>Zwraca wartość wskazującą, czy obowiązująca wartość <see cref="P:System.Windows.Documents.AnchoredBlock.Blocks" /> właściwości powinna być serializowana podczas serializacji obiektu pochodnego od. <see cref="T:System.Windows.Documents.AnchoredBlock" /></summary>
        <returns><see langword="true" />Jeśli właściwość powinna być serializowana; <see langword="false" />w przeciwnym razie. <see cref="P:System.Windows.Documents.AnchoredBlock.Blocks" /></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NullReferenceException">Uruchamiany, <paramref name="manager" /> gdy <see langword="null" />jest.</exception>
      </Docs>
    </Member>
    <Member MemberName="TextAlignment">
      <MemberSignature Language="C#" Value="public System.Windows.TextAlignment TextAlignment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.TextAlignment TextAlignment" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.AnchoredBlock.TextAlignment" />
      <MemberSignature Language="VB.NET" Value="Public Property TextAlignment As TextAlignment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::TextAlignment TextAlignment { System::Windows::TextAlignment get(); void set(System::Windows::TextAlignment value); };" />
      <MemberSignature Language="F#" Value="member this.TextAlignment : System.Windows.TextAlignment with get, set" Usage="System.Windows.Documents.AnchoredBlock.TextAlignment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.TextAlignment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą poziome wyrównanie zawartości tekstowej.</summary>
        <value>Element członkowski <see cref="T:System.Windows.TextAlignment" /> wyliczenia określający żądane wyrównanie.  
  
Wartość domyślna to <see cref="F:System.Windows.TextAlignment.Left" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_TextAlignment"></a>   
## <a name="dependency-property-information"></a>Informacje dotyczące właściwości zależności  
  
|||  
|-|-|  
|Pole identyfikatora|<xref:System.Windows.Documents.AnchoredBlock.TextAlignmentProperty>|  
|Właściwości metadanych ustawione na`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.Windows.Documents.AnchoredBlock.TextAlignment%2A> jak ustawić atrybut <xref:System.Windows.Documents.Block> elementu.  
  
 [!code-xaml[BlockSnippets#_Block_TextAlignmentXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/BlockSnippets/CSharp/Window1.xaml#_block_textalignmentxaml)]  
  
 Na poniższej ilustracji pokazano, jak poprzedni przykład renderuje z wyrównaniem tekstu wyrównanym do **lewej** (domyślnie).  
  
 ![Zrzut ekranu Wartość właściwości TextAlign dla]lewego(~/add/media/flowdoc-textalign-left.png "zrzutu ekranu: Wartość właściwości TextAlign z lewej")  
  
 Na poniższej ilustracji przedstawiono sposób renderowania tego samego przykładu z wyrównaniem **właściwym** tekstu.  
  
 ![Zrzut ekranu Wartość TextAlign na]prawym(~/add/media/flowdoc-textalign-right.png "zrzucie ekranu: Wartość TextAlign z prawej")  
  
 Na poniższej ilustracji przedstawiono sposób renderowania tego samego przykładu **** przy wyrównaniu tekstu środkowego.  
  
 ![Zrzut ekranu Wartość właściwości TextAlign środka](~/add/media/flowdoc-textalign-center.png "zrzutu ekranu: Wartość właściwości TextAlign środka")  
  
 Poniższy przykład pokazuje, <xref:System.Windows.Documents.AnchoredBlock.TextAlignment%2A> jak ustawić właściwości programowo.  
  
 [!code-csharp[BlockSnippets#_Block_TextAlignment](~/samples/snippets/csharp/VS_Snippets_Wpf/BlockSnippets/CSharp/Window1.xaml.cs#_block_textalignment)]
 [!code-vb[BlockSnippets#_Block_TextAlignment](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BlockSnippets/visualbasic/window1.xaml.vb#_block_textalignment)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextAlignmentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TextAlignmentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TextAlignmentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Documents.AnchoredBlock.TextAlignmentProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TextAlignmentProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TextAlignmentProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TextAlignmentProperty : System.Windows.DependencyProperty" Usage="System.Windows.Documents.AnchoredBlock.TextAlignmentProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identyfikuje właściwość <see cref="P:System.Windows.Documents.AnchoredBlock.TextAlignment" /> zależności.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

<Type Name="ServiceBase" FullName="System.ServiceProcess.ServiceBase">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="53bbd364d4631270a83db7b7c157b68be55a3382" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36410025" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ServiceBase : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ServiceBase extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.ServiceProcess.ServiceBase" />
  <TypeSignature Language="VB.NET" Value="Public Class ServiceBase&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class ServiceBase : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type ServiceBase = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceProcess</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.ServiceProcess.ServiceProcessInstaller))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Udostępnia klasę podstawową dla usługi, która będzie istnieć w ramach aplikacji usługi. <see cref="T:System.ServiceProcess.ServiceBase" /> musi być pochodną podczas tworzenia nowej klasy usługi.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pochodzić od <xref:System.ServiceProcess.ServiceBase> podczas definiowania klasy usługi w aplikacji usługi. Wszystkie zastąpienia przydatne usługi <xref:System.ServiceProcess.ServiceBase.OnStart%2A> i <xref:System.ServiceProcess.ServiceBase.OnStop%2A> metody. Aby włączyć dodatkowe funkcje, można zastąpić <xref:System.ServiceProcess.ServiceBase.OnPause%2A> i <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> z określone zachowanie w odpowiedzi na zmiany w stan usługi.  
  
 Usługa jest długotrwałe plik wykonywalny, który nie obsługuje interfejs użytkownika i które mogą nie działać w ramach konta zalogowanego użytkownika. Usługa może działać bez każdemu użytkownikowi zalogowanie się do komputera.  
  
 Domyślnie usługi uruchamiane na koncie systemu, który nie jest taka sama jak konto administratora. Nie można zmienić uprawnień konta System. Alternatywnie można użyć <xref:System.ServiceProcess.ServiceProcessInstaller> Aby określić konto użytkownika, na którym będzie uruchamiana usługa.  
  
 Plik wykonywalny może zawierać więcej niż jedna usługa, ale musi zawierać oddzielne <xref:System.ServiceProcess.ServiceInstaller> dla każdej usługi. <xref:System.ServiceProcess.ServiceInstaller> Wystąpienia rejestruje usługę w systemie. Instalator powoduje również skojarzenie poszczególnych usług z dziennika zdarzeń, który służy do rejestrowania poleceń usługi. `main()` Funkcji w pliku wykonywalnego, który definiuje usług, które powinno być ono uruchomione. Bieżący katalog roboczy usługi jest katalogiem systemu, a nie katalog, w którym znajduje się plik wykonywalny.  
  
 Po uruchomieniu usługi systemu lokalizuje plik wykonywalny i uruchamia <xref:System.ServiceProcess.ServiceBase.OnStart%2A> metody dla tej usługi, zawarty w pliku wykonywalnego. Jednak uruchomienie usługi nie jest taki sam jak uruchamianie pliku wykonywalnego. Plik wykonywalny ładuje tylko usługi. Usługa jest dostępna (na przykład, uruchamiania i zatrzymywania) za pośrednictwem Menedżera sterowania usługami.  
  
 Wykonywalny wywołania <xref:System.ServiceProcess.ServiceBase> pochodzi z klasy konstruktora pierwszy czasu wywołania rozpoczęcia w usłudze. <xref:System.ServiceProcess.ServiceBase.OnStart%2A> Obsługi polecenia metoda jest wywoływana natychmiast po wykonuje konstruktora. Konstruktor nie jest wykonywany ponownie po pierwszej usługi został załadowany, więc oddzielne przetwarzanie wykonywane przez konstruktora z wykonywane przez <xref:System.ServiceProcess.ServiceBase.OnStart%2A>. Wszystkie zasoby, które może być zwolnione przez <xref:System.ServiceProcess.ServiceBase.OnStop%2A> powinny zostać utworzone w <xref:System.ServiceProcess.ServiceBase.OnStart%2A>. Tworzenie zasobów w Konstruktorze zapobiega ich są poprawnie utworzony, jeśli usługa jest uruchomiona ponownie po <xref:System.ServiceProcess.ServiceBase.OnStop%2A> wydała zasobów.  
  
 Menedżer sterowania usługami (SCM) zapewnia sposób interakcji z usługą. Menedżer sterowania usługami służy do przekazywania Uruchom, Zatrzymaj, Wstrzymaj, Kontynuuj lub polecenia niestandardowych w usłudze. Menedżer sterowania usługami używa wartości <xref:System.ServiceProcess.ServiceBase.CanStop%2A> i <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> Aby ustalić, czy usługa akceptuje zatrzymanie, wstrzymanie lub kontynuować poleceń. Zatrzymaj, Wstrzymaj i Kontynuuj są włączone w SCM kontekstu menu tylko w przypadku odpowiadających im właściwości <xref:System.ServiceProcess.ServiceBase.CanStop%2A> lub <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> jest `true` w klasie usługi. U możliwia polecenia są przekazywane do usługi, i <xref:System.ServiceProcess.ServiceBase.OnStop%2A>, <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, lub <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> jest wywoływana. Jeśli <xref:System.ServiceProcess.ServiceBase.CanStop%2A>, <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A>, lub <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> jest `false`, odpowiedniej metody obsługi polecenia (takich jak <xref:System.ServiceProcess.ServiceBase.OnStop%2A>) nie będą przetwarzane, nawet jeśli zaimplementowano metody.  
  
 Można użyć <xref:System.ServiceProcess.ServiceController> klasę, aby wykonać programowo jakie SCM jest przy użyciu interfejsu użytkownika. Można automatyzować zadania dostępne w konsoli. Jeśli <xref:System.ServiceProcess.ServiceBase.CanStop%2A>, <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A>, lub <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> jest `true` , ale nie zostały zaimplementowane odpowiedniej metody obsługi polecenia (takich jak <xref:System.ServiceProcess.ServiceBase.OnStop%2A>) system zgłasza wyjątek i ignoruje polecenia.  
  
 Nie masz do zaimplementowania <xref:System.ServiceProcess.ServiceBase.OnStart%2A>, <xref:System.ServiceProcess.ServiceBase.OnStop%2A>, lub innej metody w <xref:System.ServiceProcess.ServiceBase>. Jednak zachowanie usługi jest opisane w <xref:System.ServiceProcess.ServiceBase.OnStart%2A>, więc co najmniej powinna zostać zastąpiona tego elementu członkowskiego. `main()` Funkcja pliku wykonywalnego, który rejestruje usługę w pliku wykonywalnego z Menedżerem sterowania usługami przez wywołanie metody <xref:System.ServiceProcess.ServiceBase.Run%2A> metody. <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> Właściwość <xref:System.ServiceProcess.ServiceBase> obiekt przekazywany do <xref:System.ServiceProcess.ServiceBase.Run%2A> musi być zgodna metoda <xref:System.ServiceProcess.ServiceInstaller.ServiceName%2A> właściwości Instalatora usługi dla tej usługi.  
  
 Można użyć `InstallUtil.exe` do instalowania usług w systemie.  
  
> [!NOTE]
>  Dziennik niż dziennik zdarzeń aplikacji, aby otrzymać powiadomienie o wywołaniach usług, ale nie można określić <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> ani <xref:System.ServiceProcess.ServiceBase.EventLog%2A> właściwości może zapisywać do dziennika niestandardowego. Ustaw <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> do `false` , jeśli nie chcesz używać automatycznego rejestrowania.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.ServiceProcess.ServiceProcessInstaller" />
    <altmember cref="T:System.ServiceProcess.ServiceInstaller" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ServiceBase ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ServiceBase();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Tworzy nowe wystąpienie klasy <see cref="T:System.ServiceProcess.ServiceBase" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie twórz wystąpienia <xref:System.ServiceProcess.ServiceBase> klasy. Zamiast tego pochodzi od <xref:System.ServiceProcess.ServiceBase> i utworzenia wystąpienia klasy pochodnej. Minimalna należy wdrożyć w Konstruktorze dla odziedziczone po klasie <xref:System.ServiceProcess.ServiceBase> jest skonfigurowanie <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> na składnika. Nie inne przetwarzania jest wymagany w szczególności w konstruktorze. Powinna obsługiwać większość inicjowania w <xref:System.ServiceProcess.ServiceBase.OnStart%2A> , a nie w konstruktorze. W przeciwnym razie nie ma żadnej gwarancji, które obiekty zostanie zainicjowana ponownie po ponownym uruchomieniu usługi po została zatrzymana.  
  
 Jeśli w Konstruktorze przesłonięcia w klasie pochodnej, wywołanie konstruktora klasy podstawowej w kodzie.  
  
 <xref:System.ServiceProcess.ServiceBase> Ustawia konstruktora <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> do `true`. Jeśli nie chcesz automatycznie logować wywołań do usługi z Menedżera sterowania usługami (SCM), należy ustawić <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> do `false`.  
  
 Jeśli pliku wykonywalnego zawiera pojedynczą usługę, system wywołuje konstruktor usługi podczas uruchamiania wybrano SCM i uruchamia destruktor, gdy Stop została wywołana.  
  
 Jeśli pliku wykonywalnego zawiera wiele usług, wywoływania rozpoczęcia w jednej usługi powoduje, że konstruktorów ma być wywoływana dla wszystkich usług w pliku wykonywalnego, ale tylko określona usługa jest uruchomiona. Destruktory dla usług są uruchamiane razem gdy wszystkie usługi została zatrzymana, nie pojedynczo po zatrzymaniu każdej usługi.  
  
> [!NOTE]
>  Jeśli zastąpienie konstruktora klasy podstawowej, użytkownik powinien jawnie wywołać w konstruktorze klasy pochodnej.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.AutoLog" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase[])" />
      </Docs>
    </Member>
    <Member MemberName="AutoLog">
      <MemberSignature Language="C#" Value="public bool AutoLog { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoLog" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.AutoLog" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoLog As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutoLog { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoLog : bool with get, set" Usage="System.ServiceProcess.ServiceBase.AutoLog" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ServiceProcess.ServiceProcessDescription("SBAutoLog")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wskazuje, czy zgłaszać polecenia Start, Zatrzymaj, Wstrzymaj i Kontynuuj w dzienniku zdarzeń.</summary>
        <value>
          <see langword="true" /> do informacji w raporcie w dzienniku zdarzeń; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustawienie <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> do `true` powoduje, że usługa Dziennik zdarzeń aplikacji, aby niepowodzenia polecenia raportu, a także informacje o zmianie stanu na użytek Uruchom, Zatrzymaj, Wstrzymaj i Kontynuuj zdarzeń w usłudze. Nazwa usługi jest używana do logowania <xref:System.Diagnostics.EventLog.Source%2A?displayProperty=nameWithType>.  
  
 Aby przekazać informacje niestandardowe dziennika zdarzeń, a nie w dzienniku aplikacji, ustaw <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> do `false` i pisanie instrukcji w obrębie metody obsługi polecenia <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>, <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, lub <xref:System.ServiceProcess.ServiceBase.OnStop%2A> do wysłania do odpowiedniego dziennika.  
  
> [!NOTE]
>  <xref:System.ServiceProcess.ServiceBase.ServiceName%2A>, Który dostarcza ciąg źródłowy dla dziennika zdarzeń, należy ustawić przed usługa próbuje dokonać zapisu w dzienniku zdarzeń. Próby dostępu do dziennika zdarzeń, przed skonfigurowaniem nazwę źródła zgłasza wyjątek.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.EventLog" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
    <Member MemberName="CanHandlePowerEvent">
      <MemberSignature Language="C#" Value="public bool CanHandlePowerEvent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanHandlePowerEvent" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      <MemberSignature Language="VB.NET" Value="Public Property CanHandlePowerEvent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanHandlePowerEvent { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanHandlePowerEvent : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy usługa może obsłużyć powiadomienia o zmianie stanu zasilania komputera.</summary>
        <value>
          <see langword="true" /> Jeśli usługa obsługuje stan zasilania komputera zmiany w oznaczone <see cref="T:System.ServiceProcess.PowerBroadcastStatus" /> klasy, w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas zmiany stanu zasilania komputera, Menedżer sterowania usługami (SCM) sprawdza, czy usługa akceptuje zasilania poleceń zdarzeń przy użyciu wartości <xref:System.ServiceProcess.ServiceBase.CanHandlePowerEvent%2A>.  
  
 Jeśli <xref:System.ServiceProcess.ServiceBase.CanHandlePowerEvent%2A> jest `true`, polecenie jest przekazywany do usługi i <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A> metoda jest wywoływana, jeśli została zdefiniowana. Jeśli <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A> nie jest zaimplementowana w klasie pochodnej SCM obsługuje zdarzenie zasilania za pośrednictwem pustą klasę podstawową <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ta właściwość jest modyfikowana po usługa została uruchomiona.</exception>
        <altmember cref="T:System.ServiceProcess.PowerBroadcastStatus" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
      </Docs>
    </Member>
    <Member MemberName="CanHandleSessionChangeEvent">
      <MemberSignature Language="C#" Value="public bool CanHandleSessionChangeEvent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanHandleSessionChangeEvent" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Property CanHandleSessionChangeEvent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanHandleSessionChangeEvent { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanHandleSessionChangeEvent : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy usługa może obsłużyć zdarzenia zmiany sesji odebrane w sesji serwera terminali.</summary>
        <value>
          <see langword="true" /> Jeśli usługa może obsłużyć zdarzenia zmiany sesji serwera terminali; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Ta właściwość jest modyfikowana po usługa została uruchomiona.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnSessionChange(System.ServiceProcess.SessionChangeDescription)" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="CanPauseAndContinue">
      <MemberSignature Language="C#" Value="public bool CanPauseAndContinue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanPauseAndContinue" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
      <MemberSignature Language="VB.NET" Value="Public Property CanPauseAndContinue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanPauseAndContinue { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanPauseAndContinue : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy usługa może wstrzymany i ponownie uruchomiony.</summary>
        <value>
          <see langword="true" /> Jeśli usługa może zostać wstrzymana; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustaw wartość <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> właściwości w Konstruktorze dla usługi.  
  
 Gdy usługa jest wstrzymana, zatrzymuje wykonywania. Jeśli nadal (lub za pośrednictwem Menedżera sterowania usługami programowo), usługa <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> uruchamia.  
  
 Wysyła żądanie wstrzymania do usługi, można zaoszczędzić zasoby systemowe. Wstrzymaj może nie zwalnia wszystkie zasoby systemowe, ale nie Stop. <xref:System.ServiceProcess.ServiceBase.OnPause%2A> i <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> są często stosowane do przetwarzania mniej niż <xref:System.ServiceProcess.ServiceBase.OnStop%2A> i <xref:System.ServiceProcess.ServiceBase.OnStart%2A>.  
  
 Gdy <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> jest `true`, Zastąp <xref:System.ServiceProcess.ServiceBase.OnPause%2A> i <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> do określenia przetwarzania, który powinien wystąpić, gdy Menedżer sterowania usługami (SCM) przekazuje żądanie wstrzymania lub kontynuować z usługą. <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> powinny zostać wdrożone cofnąć przetwarzania w <xref:System.ServiceProcess.ServiceBase.OnPause%2A>.  
  
 Jeśli <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> jest `false`SCM nie przejdą Wstrzymaj i Kontynuuj żądania do usługi, więc <xref:System.ServiceProcess.ServiceBase.OnPause%2A> i <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> metody nie zostanie wywołany, nawet jeśli są one wykonywane. W SCM `Pause` i `Continue` formanty są wyłączone, gdy <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> jest `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Usługa została już uruchomiona. <see cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" /> Nie można zmienić właściwości, gdy usługa została uruchomiona.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="CanShutdown">
      <MemberSignature Language="C#" Value="public bool CanShutdown { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanShutdown" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanShutdown" />
      <MemberSignature Language="VB.NET" Value="Public Property CanShutdown As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanShutdown { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanShutdown : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanShutdown" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy Usługa powiadamiania, gdy system jest zamykany.</summary>
        <value>
          <see langword="true" /> Jeśli usługa powiadamiania, gdy system jest zamykany; w przeciwnym razie <see langword="false" />.  Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A> jest `true`, usługa jest powiadomienie, gdy system jest zamykany. Podczas zamykania systemu <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A> metoda jest wywoływana, gdy została ona zaimplementowana w klasie pochodnej.  
  
> [!NOTE]
>  Tylko system powinno powodować <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A> metodę można wykonać; usługi można wywołać ją, ale nie jest to zalecane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Usługa została już uruchomiona. <see cref="P:System.ServiceProcess.ServiceBase.CanShutdown" /> Nie można zmienić właściwości, gdy usługa została uruchomiona.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="CanStop">
      <MemberSignature Language="C#" Value="public bool CanStop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanStop" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanStop" />
      <MemberSignature Language="VB.NET" Value="Public Property CanStop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanStop { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanStop : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanStop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy usługa może zostać zatrzymana, gdy została ona uruchomiona.</summary>
        <value>
          <see langword="true" /> Jeśli usługa może zostać zatrzymana i <see cref="M:System.ServiceProcess.ServiceBase.OnStop" /> metody o nazwie; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zatrzymaj wywołanego w usłudze Menedżer sterowania usługami (SCM) sprawdza, czy usługa akceptuje polecenia Stop przy użyciu wartości <xref:System.ServiceProcess.ServiceBase.CanStop%2A>. W przypadku większości usług wartość <xref:System.ServiceProcess.ServiceBase.CanStop%2A> jest `true`, ale niektóre usługi systemu operacyjnego, na przykład nie Zezwalaj użytkownikowi na ich zatrzymania.  
  
 Jeśli <xref:System.ServiceProcess.ServiceBase.CanStop%2A> jest `true`, polecenia zatrzymania jest przekazywany do usługi i <xref:System.ServiceProcess.ServiceBase.OnStop%2A> metoda jest wywoływana, gdy jest zdefiniowana. Jeśli <xref:System.ServiceProcess.ServiceBase.OnStop%2A> nie jest zaimplementowana w klasie pochodnej uchwytów SCM polecenie zatrzymania za pośrednictwem pustą klasę podstawową <xref:System.ServiceProcess.ServiceBase.OnStop%2A?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Usługa została już uruchomiona. <see cref="P:System.ServiceProcess.ServiceBase.CanStop" /> Nie można zmienić właściwości, gdy usługa została uruchomiona.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="serviceBase.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> aby zwolnić tylko zasoby niezarządzane.</param>
        <summary>Usuwa zasoby (inne niż pamięć) używany przez <see cref="T:System.ServiceProcess.ServiceBase" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie <xref:System.ServiceProcess.ServiceBase.Dispose%2A> w klasie pochodnej (oraz za jego pośrednictwem w <xref:System.ServiceProcess.ServiceBase> klasy) po zakończeniu korzystania z klasy pochodnej. <xref:System.ServiceProcess.ServiceBase.Dispose%2A> — Metoda pozostawia klasy pochodnej w stanie uniemożliwiającym jego używanie. Po wywołaniu <xref:System.ServiceProcess.ServiceBase.Dispose%2A>, konieczne jest zwolnienie wszystkich odwołań do klasy pochodnej i <xref:System.ServiceProcess.ServiceBase> , można odzyskać pamięci, zostały one zajmujące przez wyrzucanie elementów bezużytecznych.  
  
> [!NOTE]
>  Wywoływanie zawsze <xref:System.ServiceProcess.ServiceBase.Dispose%2A> przed zwolnieniem ostatniego odwołania do klasy pochodnej z <xref:System.ServiceProcess.ServiceBase>. W przeciwnym razie zasoby <xref:System.ServiceProcess.ServiceBase> i korzystają z klasy pochodnej zostanie nie zwolniona dopóki wyrzucanie elementów bezużytecznych wywołuj destruktory obiektów.  
  
 <xref:System.ServiceProcess.ServiceBase.OnStop%2A> często jest stosowane do przetwarzania kodu w <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, połączony z wywołaniem do <xref:System.ServiceProcess.ServiceBase.Dispose%2A>. Jeśli chcesz to zrobić w klasie pochodnej jest zwyczajowe do zaimplementowania <xref:System.ServiceProcess.ServiceBase.OnStart%2A> przydzielić niezależnie od <xref:System.ServiceProcess.ServiceBase.Dispose%2A> wydane.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="EventLog">
      <MemberSignature Language="C#" Value="public virtual System.Diagnostics.EventLog EventLog { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.EventLog EventLog" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.EventLog" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EventLog As EventLog" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Diagnostics::EventLog ^ EventLog { System::Diagnostics::EventLog ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EventLog : System.Diagnostics.EventLog" Usage="System.ServiceProcess.ServiceBase.EventLog" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLog</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera dziennika zdarzeń, który służy do zapisania powiadomień wywołania polecenia usługi, takie jak uruchamianie i zatrzymywanie, w dzienniku zdarzeń aplikacji.</summary>
        <value>
          <see cref="T:System.Diagnostics.EventLog" /> Wystąpienie, którego źródłem jest zarejestrowany w dzienniku aplikacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Konstruktor inicjuje <xref:System.ServiceProcess.ServiceBase.EventLog%2A> dla właściwości wystąpienia o <xref:System.Diagnostics.EventLog.Source%2A?displayProperty=nameWithType> i <xref:System.Diagnostics.EventLog.Log%2A?displayProperty=nameWithType> zestawu właściwości. Źródło jest <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> usługi, i dziennik jest dziennika aplikacji z komputera. Te wartości są ustawiane automatycznie i nie można zmienić dla automatycznego rejestrowania poleceń usługi.  
  
 Gdy <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> jest `true`, Start, Zatrzymaj, Wstrzymaj, Kontynuuj i polecenia niestandardowych są automatycznie rejestrowane w dzienniku zdarzeń aplikacji. Można użyć <xref:System.ServiceProcess.ServiceBase.EventLog%2A> właściwość do zapisania w tym dzienniku również przejrzeć dodatkowe komunikaty. Wywołania składnika <xref:System.Diagnostics.EventLog.WriteEntry%2A?displayProperty=nameWithType> za pomocą tej <xref:System.ServiceProcess.ServiceBase.EventLog%2A> elementu członkowskiego.  
  
 Aby przekazać informacje niestandardowe dziennika zdarzeń, a nie w dzienniku aplikacji, ustaw <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> do `false` i pisanie instrukcji w obrębie metody obsługi polecenia <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>, <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, lub <xref:System.ServiceProcess.ServiceBase.OnStop%2A> do wysłania do odpowiedniego dziennika.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.AutoLog" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="T:System.Diagnostics.EventLog" />
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public int ExitCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.ExitCode" />
      <MemberSignature Language="VB.NET" Value="Public Property ExitCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ExitCode { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ExitCode : int with get, set" Usage="System.ServiceProcess.ServiceBase.ExitCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kod zakończenia usługi.</summary>
        <value>Kod zakończenia usługi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustaw <xref:System.ServiceProcess.ServiceBase.ExitCode%2A> właściwości na wartość inną niż zero, przed zatrzymaniem usługi wystąpił błąd menedżera kontroli usług.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxNameLength">
      <MemberSignature Language="C#" Value="public const int MaxNameLength = 80;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 MaxNameLength = (80)" />
      <MemberSignature Language="DocId" Value="F:System.ServiceProcess.ServiceBase.MaxNameLength" />
      <MemberSignature Language="VB.NET" Value="Public Const MaxNameLength As Integer  = 80" />
      <MemberSignature Language="C++ CLI" Value="public: int MaxNameLength = 80;" />
      <MemberSignature Language="F#" Value="val mutable MaxNameLength : int" Usage="System.ServiceProcess.ServiceBase.MaxNameLength" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>80</MemberValue>
      <Docs>
        <summary>Określa maksymalny rozmiar nazwy usługi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Elementy ServiceName i DisplayName mają rozmiar ograniczenia, które muszą przestrzegać podczas ustawiania właściwości w klasie usługi.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.ServiceName" />
      </Docs>
    </Member>
    <Member MemberName="OnContinue">
      <MemberSignature Language="C#" Value="protected virtual void OnContinue ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContinue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnContinue" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContinue ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContinue();" />
      <MemberSignature Language="F#" Value="abstract member OnContinue : unit -&gt; unit&#xA;override this.OnContinue : unit -&gt; unit" Usage="serviceBase.OnContinue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Po zaimplementowaniu w klasie pochodnej <see cref="M:System.ServiceProcess.ServiceBase.OnContinue" /> jest uruchamiany, gdy polecenie Kontynuuj, jest wysyłane do usługi przez Menedżera sterowania usługami (SCM). Określa akcje w sytuacji, gdy usługa wznawia normalne działanie po wstrzymaniu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Implementowanie <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> dublowanego odpowiedzi aplikacji <xref:System.ServiceProcess.ServiceBase.OnPause%2A>. Jeśli nadal (lub za pośrednictwem konsoli usługi programowo), usługa <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> przetwarzania działa i usługa stanie się ponownie aktywna.  
  
 <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> powinien zostać zastąpiona po <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> jest właściwość `true`.  
  
 Jeśli <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> jest `false`SCM nie przejdą Wstrzymaj i Kontynuuj żądania do usługi, więc <xref:System.ServiceProcess.ServiceBase.OnPause%2A> i <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> metody nie zostanie wywołany, nawet jeśli są one wykonywane. W SCM `Pause` i `Continue` formanty są wyłączone, gdy <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> jest `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnCustomCommand">
      <MemberSignature Language="C#" Value="protected virtual void OnCustomCommand (int command);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCustomCommand(int32 command) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCustomCommand (command As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCustomCommand(int command);" />
      <MemberSignature Language="F#" Value="abstract member OnCustomCommand : int -&gt; unit&#xA;override this.OnCustomCommand : int -&gt; unit" Usage="serviceBase.OnCustomCommand command" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="command" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="command">Komunikat polecenia wysyłane do usługi.</param>
        <summary>Po zaimplementowaniu w klasie pochodnej <see cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" /> wykonuje się, gdy Menedżer sterowania usługami (SCM) przekazuje polecenia niestandardowych do usługi. Określa akcje do wykonania po wystąpieniu polecenia podana wartość parametru.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceProcess.ServiceBase.OnCustomCommand%2A> Pozwala określić dodatkowe funkcje oprócz uruchamianie, zatrzymywanie, wstrzymywanie i kontynuowanie usługi.  
  
 Menedżer sterowania usługami nie bada niestandardowe polecenia, aby sprawdzić, czy usługa obsługuje `command` przekazany parametr. Przekazuje ono polecenia niestandardowych bezpośrednio do usługi. Jeśli usługa nie rozpoznaje `command` parametru go nie działają.  
  
 Polecenia niestandardowe są wywoływane przez <xref:System.ServiceProcess.ServiceController.ExecuteCommand%2A> instrukcji w <xref:System.ServiceProcess.ServiceController> składnika. Użyj instrukcji switch lub, jeśli... następnie warunek do obsługi polecenia niestandardowych, które należy zdefiniować w usłudze.  
  
 Tylko wartości dla polecenia niestandardowych, które można zdefiniować w aplikacji lub użyć w <xref:System.ServiceProcess.ServiceBase.OnCustomCommand%2A> są od 128 do 255. Liczby całkowite poniżej 128 odpowiadają wartościom zarezerwowana przez system.  
  
 Jeśli <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> właściwość jest `true`, niestandardowych poleceń, takich jak wszystkie inne polecenia tworzyć wpisy w dzienniku zdarzeń do raportowania, czy wykonanie metody powodzeniem lub niepowodzeniem.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
    <Member MemberName="OnPause">
      <MemberSignature Language="C#" Value="protected virtual void OnPause ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPause() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnPause" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPause ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPause();" />
      <MemberSignature Language="F#" Value="abstract member OnPause : unit -&gt; unit&#xA;override this.OnPause : unit -&gt; unit" Usage="serviceBase.OnPause " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Po zaimplementowaniu w klasie pochodnej, wykonuje się, gdy polecenia Wstrzymaj jest wysyłane do usługi przez Menedżera sterowania usługami (SCM). Określa akcje w sytuacji, gdy wstrzymuje usługę.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.ServiceProcess.ServiceBase.OnPause%2A> do określenia przetwarzania, które występuje, gdy usługa odbierze polecenie wstrzymania. <xref:System.ServiceProcess.ServiceBase.OnPause%2A> powinien zostać zastąpiona po <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> jest właściwość `true`.  
  
 Jeśli będziesz kontynuować wstrzymanej usługi (lub za pośrednictwem konsoli usługi programowo), <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> przetwarzania jest uruchamiane, a usługa stanie się ponownie aktywna.  
  
 Polecenie Wstrzymaj umożliwia tylko aplikację do reagowania na zdarzenia. <xref:System.ServiceProcess.ServiceBase.OnPause%2A> nie działa z usługą nie definiują zrobić.  
  
 Wysyła żądanie wstrzymania do usługi można zaoszczędzić zasoby systemowe, ponieważ Wstrzymaj muszą zwalnia wszystkie zasoby systemowe. Na przykład jeśli zostały otwarte wątków w procesie, wstrzymanie usługi, a nie jej zatrzymania umożliwiają wątków pozostają otwarte, co eliminuje konieczność ich ponowne przydzielenie, gdy usługa będzie. W przypadku definiowania Wstrzymaj, aby zwolnić wszystkie zasoby systemowe, zachowuje się jak polecenia zatrzymania.  
  
 Ustaw <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> do `true`i Zastąp <xref:System.ServiceProcess.ServiceBase.OnPause%2A> i <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> do określenia przetwarzania, który powinien wystąpić, gdy Menedżer sterowania usługami przekazuje żądanie wstrzymania lub kontynuować z usługą. <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> powinny zostać wdrożone cofnąć przetwarzania w <xref:System.ServiceProcess.ServiceBase.OnPause%2A>.  
  
 Jeśli <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> jest `false`SCM nie przejdą Wstrzymaj i Kontynuuj żądania do usługi, więc <xref:System.ServiceProcess.ServiceBase.OnPause%2A> i <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> metody nie zostanie wywołany, nawet jeśli zaimplementowane. W SCM `Pause` i `Continue` formanty są wyłączone, gdy <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> jest `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnPowerEvent">
      <MemberSignature Language="C#" Value="protected virtual bool OnPowerEvent (System.ServiceProcess.PowerBroadcastStatus powerStatus);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool OnPowerEvent(valuetype System.ServiceProcess.PowerBroadcastStatus powerStatus) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function OnPowerEvent (powerStatus As PowerBroadcastStatus) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool OnPowerEvent(System::ServiceProcess::PowerBroadcastStatus powerStatus);" />
      <MemberSignature Language="F#" Value="abstract member OnPowerEvent : System.ServiceProcess.PowerBroadcastStatus -&gt; bool&#xA;override this.OnPowerEvent : System.ServiceProcess.PowerBroadcastStatus -&gt; bool" Usage="serviceBase.OnPowerEvent powerStatus" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="powerStatus" Type="System.ServiceProcess.PowerBroadcastStatus" />
      </Parameters>
      <Docs>
        <param name="powerStatus">A <see cref="T:System.ServiceProcess.PowerBroadcastStatus" /> wskazujące powiadomienie z systemu o jego stan zasilania.</param>
        <summary>Po zaimplementowaniu w klasie pochodnej, wykonuje po zmianie stanu zasilania komputera. Dotyczy to komputerów przenośnych gdy przejdą w tryb wstrzymania, który nie jest taka sama jak zamknięcia systemu.</summary>
        <returns>Po zaimplementowaniu w klasie pochodnej, wymagań aplikacji ustalić, jakie wartości do zwrócenia. Na przykład jeśli <see langword="QuerySuspend" /> emisji stanu jest przekazywana, może spowodować, że aplikacja do odrzucania zapytanie zwróciła <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A> do określenia przetwarzania, które występuje, gdy zdarzenie systemowe <xref:System.ServiceProcess.PowerBroadcastStatus> występuje wyliczenie — na przykład gdy komputer znajduje się w trybie wstrzymania lub wskazuje na niskim poziomie naładowania baterii zasilania.  
  
 <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A> powinien zostać zastąpiona po <xref:System.ServiceProcess.ServiceBase.CanHandlePowerEvent%2A> jest właściwość `true`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnSessionChange">
      <MemberSignature Language="C#" Value="protected virtual void OnSessionChange (System.ServiceProcess.SessionChangeDescription changeDescription);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSessionChange(valuetype System.ServiceProcess.SessionChangeDescription changeDescription) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnSessionChange(System.ServiceProcess.SessionChangeDescription)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSessionChange (changeDescription As SessionChangeDescription)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSessionChange(System::ServiceProcess::SessionChangeDescription changeDescription);" />
      <MemberSignature Language="F#" Value="abstract member OnSessionChange : System.ServiceProcess.SessionChangeDescription -&gt; unit&#xA;override this.OnSessionChange : System.ServiceProcess.SessionChangeDescription -&gt; unit" Usage="serviceBase.OnSessionChange changeDescription" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="changeDescription" Type="System.ServiceProcess.SessionChangeDescription" />
      </Parameters>
      <Docs>
        <param name="changeDescription">Struktura, która identyfikuje typ zmiany.</param>
        <summary>Wykonywana po odebraniu zdarzenia zmiany z sesji serwera terminali.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy ustawić <xref:System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent%2A> właściwości `true` umożliwiające wykonanie tej metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent" />
        <altmember cref="T:System.ServiceProcess.SessionChangeDescription" />
      </Docs>
    </Member>
    <Member MemberName="OnShutdown">
      <MemberSignature Language="C#" Value="protected virtual void OnShutdown ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnShutdown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnShutdown" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnShutdown ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnShutdown();" />
      <MemberSignature Language="F#" Value="abstract member OnShutdown : unit -&gt; unit&#xA;override this.OnShutdown : unit -&gt; unit" Usage="serviceBase.OnShutdown " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Po zaimplementowaniu w klasie pochodnej, wykonuje się, gdy system jest zamykany. Określa, jakie powinny występować bezpośrednio przed zamykanie systemu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A> do określenia przetwarzania, które występuje, gdy system będzie zamykany.  
  
 To zdarzenie występuje tylko wtedy, gdy system operacyjny jest zamknięta, nie w przypadku, gdy komputer jest wyłączony.  
  
 <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A> powinien zostać zastąpiona po <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A> jest właściwość `true`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnStart">
      <MemberSignature Language="C#" Value="protected virtual void OnStart (string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStart(string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStart (args As String())" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStart(cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member OnStart : string[] -&gt; unit&#xA;override this.OnStart : string[] -&gt; unit" Usage="serviceBase.OnStart args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="args">Dane przekazywane przez polecenia uruchomienia.</param>
        <summary>Po zaimplementowaniu w klasie pochodnej, wykonuje po wysłaniu polecenia Start z usługą przez Menedżera sterowania usługami (SCM) lub podczas uruchamiania systemu operacyjnego (dla usługi, które jest uruchamiane automatycznie). Określa akcje do wykonania podczas uruchamiania usługi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.ServiceProcess.ServiceBase.OnStart%2A> do określenia przetwarzania, które występuje, gdy usługa odbiera polecenia uruchomienia. <xref:System.ServiceProcess.ServiceBase.OnStart%2A> jest to metoda, w którym można określić zachowania usługi. <xref:System.ServiceProcess.ServiceBase.OnStart%2A> Możliwe argumenty jako sposób przekazywania danych, ale to użycie jest rzadko.  
  
> [!CAUTION]
>  Konstruktor nie jest używany do przetwarzania, który powinien być w <xref:System.ServiceProcess.ServiceBase.OnStart%2A>. Użyj <xref:System.ServiceProcess.ServiceBase.OnStart%2A> do obsługi wszystkich inicjowania usługi. Konstruktor jest wywoływane, gdy aplikacja elementu wykonywalnego działa, a nie w przypadku, gdy usługa jest uruchamiana. Plik wykonywalny uruchamiany przed <xref:System.ServiceProcess.ServiceBase.OnStart%2A>. Jeśli będziesz kontynuować, na przykład konstruktora nie jest wywoływany ponownie, ponieważ Menedżer sterowania usługami zawiera już obiekt w pamięci. Jeśli <xref:System.ServiceProcess.ServiceBase.OnStop%2A> zwalnia zasoby przydzielone w konstruktorze, a nie w <xref:System.ServiceProcess.ServiceBase.OnStart%2A>, niezbędnych zasobów nie będzie można utworzyć ponownie po raz drugi nosi nazwę usługi.  
  
 Usługi może być ustawiony na uruchamiane automatycznie po ponownym uruchomieniu komputera przez ustawienie <xref:System.ServiceProcess.ServiceInstaller.StartType%2A> na Instalatora usługi <xref:System.ServiceProcess.ServiceStartMode.Automatic>. W takiej sytuacji <xref:System.ServiceProcess.ServiceBase.OnStart%2A> będzie wywoływana podczas uruchamiania systemu.  
  
 <xref:System.ServiceProcess.ServiceBase.OnStart%2A> powinien zostać zastąpiony w klasie pochodnej. Dla usługi powinna być użyteczna <xref:System.ServiceProcess.ServiceBase.OnStart%2A> i <xref:System.ServiceProcess.ServiceBase.OnStop%2A> powinny być zarówno implementowane w klasie usługi.  
  
 Przetwarzanie argumentów inicjowania usługi w <xref:System.ServiceProcess.ServiceBase.OnStart%2A> metody, nie znajduje się w metody Main. Argumenty `args` tablicy parametrów można ustawić ręcznie w oknie dialogowym właściwości usługi w konsoli usługi. Argumenty wprowadzony w konsoli nie są zapisywane; są one przekazywane do usługi jednorazowo po uruchomieniu usługi w Panelu sterowania. Argumenty, które musi być obecny, jeśli usługa zostanie automatycznie uruchomiony można umieścić w wartości ciągu ImagePath dla klucza rejestru usługi (HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\\ * \< Nazwa usługi >*). Argumenty można uzyskać z rejestru przy użyciu <xref:System.Environment.GetCommandLineArgs%2A> metody, na przykład: `string[] imagePathArgs = Environment.GetCommandLineArgs();`.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnStop">
      <MemberSignature Language="C#" Value="protected virtual void OnStop ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnStop" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStop ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStop();" />
      <MemberSignature Language="F#" Value="abstract member OnStop : unit -&gt; unit&#xA;override this.OnStop : unit -&gt; unit" Usage="serviceBase.OnStop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Po zaimplementowaniu w klasie pochodnej, wykonuje się, gdy polecenie zatrzymania jest wysyłane do usługi przez Menedżera sterowania usługami (SCM). Określa akcje do podjęcia, gdy usługa przestanie działać.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.ServiceProcess.ServiceBase.OnStop%2A> do określenia przetwarzania, które występuje, gdy usługa odbiera polecenia zatrzymania.  
  
 Menedżer sterowania usługami odebrania polecenia zatrzymania używa wartości <xref:System.ServiceProcess.ServiceBase.CanStop%2A> Aby sprawdzić, czy usługa akceptuje polecenia zatrzymania. Jeśli <xref:System.ServiceProcess.ServiceBase.CanStop%2A> jest `true`, polecenia zatrzymania jest przekazywany do usługi i <xref:System.ServiceProcess.ServiceBase.OnStop%2A> metoda jest wywoływana, gdy jest zdefiniowana. Jeśli <xref:System.ServiceProcess.ServiceBase.OnStop%2A> nie jest zaimplementowana w usłudze Menedżer sterowania usługami obsługuje polecenia zatrzymania.  
  
 Jeśli <xref:System.ServiceProcess.ServiceBase.CanStop%2A> jest `false`, SCM ignoruje polecenia zatrzymania. Nie jest przekazywany do usługi. Polecenie zatrzymania zwraca i zgłasza wyjątek.  
  
 <xref:System.ServiceProcess.ServiceBase.OnStop%2A> powinien zostać zastąpiony w klasie pochodnej. Dla usługi powinna być użyteczna <xref:System.ServiceProcess.ServiceBase.OnStart%2A> i <xref:System.ServiceProcess.ServiceBase.OnStop%2A> powinny być zarówno implementowane w klasie usługi.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="RequestAdditionalTime">
      <MemberSignature Language="C#" Value="public void RequestAdditionalTime (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RequestAdditionalTime(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.RequestAdditionalTime(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RequestAdditionalTime (milliseconds As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RequestAdditionalTime(int milliseconds);" />
      <MemberSignature Language="F#" Value="member this.RequestAdditionalTime : int -&gt; unit" Usage="serviceBase.RequestAdditionalTime milliseconds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="milliseconds">Żądany czas w milisekundach.</param>
        <summary>Dodatkowy czas żądań oczekujących operacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceProcess.ServiceBase.RequestAdditionalTime%2A> Metoda jest przeznaczona do wywoływania przez przesłoniętych <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>, <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, <xref:System.ServiceProcess.ServiceBase.OnStart%2A>, lub <xref:System.ServiceProcess.ServiceBase.OnStop%2A> metod do żądania dodatkowego czasu oczekująca operacja, aby zapobiec Menedżera sterowania usługami (SCM) oznaczanie Usługa nie odpowiada.  Jeśli nie jest oczekująca operacja Kontynuuj, Wstrzymaj, uruchomienia lub zatrzymania, <xref:System.InvalidOperationException> jest generowany.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Usługa nie jest w stanie oczekiwania.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zawiera główny punkt wejścia dla pliku wykonywalnego usługi.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.ServiceProcess.ServiceBase service);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.ServiceProcess.ServiceBase service) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (service As ServiceBase)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(System::ServiceProcess::ServiceBase ^ service);" />
      <MemberSignature Language="F#" Value="static member Run : System.ServiceProcess.ServiceBase -&gt; unit" Usage="System.ServiceProcess.ServiceBase.Run service" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="service" Type="System.ServiceProcess.ServiceBase" />
      </Parameters>
      <Docs>
        <param name="service">A <see cref="T:System.ServiceProcess.ServiceBase" /> co oznacza usługi, aby rozpocząć.</param>
        <summary>Rejestruje plik wykonywalny usługi z Menedżera sterowania usługami (SCM).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołać tego przeciążenia `main()` funkcja plik wykonywalny, aby zarejestrować usługę z Menedżerem sterowania usługami usługi. Po wywołaniu metody <xref:System.ServiceProcess.ServiceBase.Run%28System.ServiceProcess.ServiceBase%29>, Menedżer sterowania usługami wystawia polecenie Start, co powoduje wywołanie <xref:System.ServiceProcess.ServiceBase.OnStart%2A> metody w usłudze. Usługa nie jest uruchomiona do momentu rozpoczęcia polecenie zostanie wykonane.  
  
 <xref:System.ServiceProcess.ServiceBase.Run%2A?displayProperty=nameWithType> Metoda jest wywoływana w znacznie taki sam sposób jak <xref:System.Windows.Forms.Application.Run%2A?displayProperty=nameWithType> dla aplikacji formularzy systemu Windows.  
  
 Jeśli <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> jest `true`, wpis są zapisywane w dzienniku zdarzeń, jeśli usługa określony przez `service` parametru nie powiedzie się.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="service" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.#ctor" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.ServiceProcess.ServiceBase[] services);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.ServiceProcess.ServiceBase[] services) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (services As ServiceBase())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(cli::array &lt;System::ServiceProcess::ServiceBase ^&gt; ^ services);" />
      <MemberSignature Language="F#" Value="static member Run : System.ServiceProcess.ServiceBase[] -&gt; unit" Usage="System.ServiceProcess.ServiceBase.Run services" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="services" Type="System.ServiceProcess.ServiceBase[]" />
      </Parameters>
      <Docs>
        <param name="services">Tablica wystąpień elementu ServiceBase, które wskazują uruchomienie usług.</param>
        <summary>Rejestruje plik wykonywalny dla wielu usług z Menedżera sterowania usługami (SCM).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołać tego przeciążenia `main()` funkcja plik wykonywalny do rejestrowania usług z Menedżerem sterowania usługami usługi. Po wywołaniu metody <xref:System.ServiceProcess.ServiceBase.Run%28System.ServiceProcess.ServiceBase%5B%5D%29>, Menedżera sterowania usługami wydaje polecenia Start, których wynikiem wywołania <xref:System.ServiceProcess.ServiceBase.OnStart%2A> metod w usługach. Nie są uruchomione usługi, do momentu rozpoczęcia polecenia są wykonywane.  
  
 <xref:System.ServiceProcess.ServiceBase.Run%2A?displayProperty=nameWithType> Metoda jest wywoływana w znacznie taki sam sposób jak <xref:System.Windows.Forms.Application.Run%2A?displayProperty=nameWithType> metodę dla aplikacji formularzy systemu Windows.  
  
 Jeśli <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> jest `true`, wpis są zapisywane w dzienniku zdarzeń, jeśli nie można uruchomić wszystkie usługi w tablicy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Nie dostarczył usługi, aby rozpocząć. Tablica może być <see langword="null" /> lub jest pusty.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.#ctor" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="ServiceHandle">
      <MemberSignature Language="C#" Value="protected IntPtr ServiceHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ServiceHandle" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.ServiceHandle" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property ServiceHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property IntPtr ServiceHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.ServiceHandle : nativeint" Usage="System.ServiceProcess.ServiceBase.ServiceHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera uchwyt formantu usługi dla usługi.</summary>
        <value>
          <see cref="T:System.IntPtr" /> Strukturę, która zawiera uchwyt formantu usługi dla usługi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uchwyt formantu usługi jest używany do komunikacji z Menedżera sterowania usługami (SCM).  Dojście można zaktualizować informacji o stanie menedżera kontroli usług dla wywołania usługi za pomocą niezarządzanych `SetServiceStatus` funkcji.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać dostęp do kodu niezarządzanego. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ServiceMainCallback">
      <MemberSignature Language="C#" Value="public void ServiceMainCallback (int argCount, IntPtr argPointer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ServiceMainCallback(int32 argCount, native int argPointer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.ServiceMainCallback(System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ServiceMainCallback (argCount As Integer, argPointer As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ServiceMainCallback(int argCount, IntPtr argPointer);" />
      <MemberSignature Language="F#" Value="member this.ServiceMainCallback : int * nativeint -&gt; unit" Usage="serviceBase.ServiceMainCallback (argCount, argPointer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argCount" Type="System.Int32" />
        <Parameter Name="argPointer" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="argCount">Liczba argumentów w tablicy argumentu.</param>
        <param name="argPointer">
          <see cref="T:System.IntPtr" /> Strukturę, która odwołuje się do tablicy argumentów.</param>
        <summary>Rejestruje program obsługi poleceń i uruchamia usługę.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ServiceName">
      <MemberSignature Language="C#" Value="public string ServiceName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ServiceName" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.ServiceName" />
      <MemberSignature Language="VB.NET" Value="Public Property ServiceName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ServiceName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ServiceName : string with get, set" Usage="System.ServiceProcess.ServiceBase.ServiceName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ServiceProcess.ServiceProcessDescription("SBServiceName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia krótką nazwę, używany do identyfikowania usługi do systemu.</summary>
        <value>Nazwa usługi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> Identyfikuje usługę menedżera kontroli usług. Wartość tej właściwości musi być taka sama jak nazwa zarejestrowane w usłudze <xref:System.ServiceProcess.ServiceInstaller.ServiceName%2A?displayProperty=nameWithType> właściwość odpowiadającą klasę Instalatora. W kodzie <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> usługi jest zwykle ustawiana `main()` funkcja pliku wykonywalnego.  
  
 <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> Również służy do określania <xref:System.Diagnostics.EventLog.Source%2A?displayProperty=nameWithType> skojarzone z <xref:System.ServiceProcess.ServiceBase.EventLog%2A> właściwości. To <xref:System.ServiceProcess.ServiceBase.EventLog%2A> jest wystąpieniem, który zapisuje informacje dotyczące poleceń usługi do dziennika aplikacji.  
  
 <xref:System.ServiceProcess.ServiceBase.ServiceName%2A>, Który dostarcza ciąg źródłowy dla dziennika zdarzeń, należy skonfigurować usługę zapisuje w dzienniku zdarzeń. Próby dostępu do dziennika zdarzeń, przed skonfigurowaniem nazwę źródła powoduje, że wyjątek zostanie wygenerowany.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Usługa została już uruchomiona. <see cref="P:System.ServiceProcess.ServiceBase.ServiceName" /> Nie można zmienić właściwości, gdy usługa została uruchomiona.</exception>
        <exception cref="T:System.ArgumentException">Podana nazwa jest ciągiem o zerowej długości lub jej długość przekracza <see cref="F:System.ServiceProcess.ServiceBase.MaxNameLength" />, albo określona nazwa zawiera znaki, do przodu ukośnika ani ukośnika odwrotnego.</exception>
        <altmember cref="P:System.ServiceProcess.ServiceInstaller.ServiceName" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop();" />
      <MemberSignature Language="F#" Value="member this.Stop : unit -&gt; unit" Usage="serviceBase.Stop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zatrzymuje usługę wykonywania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceProcess.ServiceBase.Stop%2A> Metoda ustawia stan usługi, aby wskazać Trwa oczekiwanie na zatrzymanie i wywołania <xref:System.ServiceProcess.ServiceBase.OnStop%2A> metody.  Po wyłączeniu aplikacji stan usługi jest ustawiony do zatrzymania. Jeśli aplikacja jest hostowana usługa, nie jest załadowany domeny aplikacji.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
  </Members>
</Type>
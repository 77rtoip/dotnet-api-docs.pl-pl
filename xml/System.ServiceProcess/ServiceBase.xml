<Type Name="ServiceBase" FullName="System.ServiceProcess.ServiceBase">
  <Metadata><Meta Name="ms.openlocfilehash" Value="2dbc0f7ae686463d4772e0cdd1f503f889472ddd" /><Meta Name="ms.sourcegitcommit" Value="220917117f9d774aaa482439aa7324e39dc1f5b6" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="02/25/2019" /><Meta Name="ms.locfileid" Value="56779385" /></Metadata><TypeSignature Language="C#" Value="public class ServiceBase : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ServiceBase extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.ServiceProcess.ServiceBase" />
  <TypeSignature Language="VB.NET" Value="Public Class ServiceBase&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class ServiceBase : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type ServiceBase = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceProcess</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.ServiceProcess.ServiceProcessInstaller))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VisualStudio.Install.UserNTServiceDesigner, Microsoft.VisualStudio, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.IRootDesigner")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Udostępnia klasę bazową dla usługi, który istnieje w ramach aplikacji usługi. <see cref="T:System.ServiceProcess.ServiceBase" /> musi pochodzić od podczas tworzenia nowej klasy usługi.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pochodzi od <xref:System.ServiceProcess.ServiceBase> podczas definiowania klasy usługi w aplikacji usługi. Wszelkie przesłonięcia usługa przydatna <xref:System.ServiceProcess.ServiceBase.OnStart%2A> i <xref:System.ServiceProcess.ServiceBase.OnStop%2A> metody. Dodatkowe funkcje, można zastąpić <xref:System.ServiceProcess.ServiceBase.OnPause%2A> i <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> z działaniem określonym w odpowiedzi na zmiany stanu usługi.  
  
 Usługa jest długotrwałe plik wykonywalny, który nie obsługuje interfejsu użytkownika, i które mogą nie działać w ramach konta zalogowanego użytkownika. Usługa może działać bez każdy użytkownik jest zalogowany do komputera.  
  
 Domyślnie usługi uruchamiane na koncie systemu, który nie jest taka sama jak konto administratora. Nie można zmienić uprawnienia kontu System. Alternatywnie, można użyć <xref:System.ServiceProcess.ServiceProcessInstaller> Aby określić konto użytkownika, na którym usługa będzie uruchamiana.  
  
 Plik wykonywalny może zawierać więcej niż jedna usługa, lecz musi zawierać oddzielny <xref:System.ServiceProcess.ServiceInstaller> dla każdej usługi. <xref:System.ServiceProcess.ServiceInstaller> Rejestruje wystąpienie usługi w systemie. Instalator powoduje również skojarzenie poszczególnych usług z dziennika zdarzeń, który służy do rejestrowania poleceń usługi. `main()` Funkcji w pliku wykonywalnego, który definiuje, usług, które należy uruchomić. Bieżący katalog roboczy usługi jest katalogu systemowym, a nie do katalogu, w którym znajduje się plik wykonywalny.  
  
 Podczas uruchamiania usługi system wyszukuje plik wykonywalny i uruchamia <xref:System.ServiceProcess.ServiceBase.OnStart%2A> metody dla tej usługi, który jest zawarty w pliku wykonywalnym. Jednak uruchomienie usługi nie jest taka sama jak uruchamiając plik wykonywalny. Plik wykonywalny ładowane są tylko usługi. Usługa jest dostępna (na przykład, uruchamiać i zatrzymywać) za pośrednictwem Menedżera kontroli usług.  
  
 Wykonywalny wywołuje <xref:System.ServiceProcess.ServiceBase> pochodne klasy Konstruktor pierwszego czasu wywołania uruchamiania w usłudze. <xref:System.ServiceProcess.ServiceBase.OnStart%2A> Natychmiast po zakończeniu Konstruktor wykonuje, wywoływana jest metoda obsługi polecenia. Konstruktor nie jest wykonywane ponownie po załadowaniu usługi po raz pierwszy, więc rozdzielić przetwarzania wykonywane przez konstruktora przy jego użyciu wykonywane przez <xref:System.ServiceProcess.ServiceBase.OnStart%2A>. Wszystkie zasoby, które będą dostępne przez <xref:System.ServiceProcess.ServiceBase.OnStop%2A> powinny zostać utworzone w <xref:System.ServiceProcess.ServiceBase.OnStart%2A>. Tworzenie zasobów w Konstruktorze uniemożliwia im Trwa tworzenie poprawnie, jeśli usługa jest uruchomiona ponownie po <xref:System.ServiceProcess.ServiceBase.OnStop%2A> wydała zasobów.  
  
 Menedżer sterowania usługami (SCM) zapewnia sposób interakcji z usługą. Menedżer sterowania usługami służy do przekazywania Uruchom, Zatrzymaj, Wstrzymaj, Kontynuuj lub niestandardowych poleceń w usłudze. Menedżer sterowania usługami używa wartości <xref:System.ServiceProcess.ServiceBase.CanStop%2A> i <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> Aby ustalić, czy usługa akceptuje zatrzymać, wstrzymać lub kontynuować poleceń. Zatrzymaj, Wstrzymaj i Kontynuuj są włączone w funkcji SCM kontekstu menu tylko wtedy, gdy odpowiednia właściwość <xref:System.ServiceProcess.ServiceBase.CanStop%2A> lub <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> jest `true` w klasie usługi. Jeśli włączona, polecenie jest przekazywany do usługi, i <xref:System.ServiceProcess.ServiceBase.OnStop%2A>, <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, lub <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> jest wywoływana. Jeśli <xref:System.ServiceProcess.ServiceBase.CanStop%2A>, <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A>, lub <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> jest `false`, odpowiednia metoda obsługi polecenia (takich jak <xref:System.ServiceProcess.ServiceBase.OnStop%2A>) nie zostaną przetworzone, nawet jeśli zaimplementowano metody.  
  
 Możesz użyć <xref:System.ServiceProcess.ServiceController> klasie w celu wykonania programowo jakie Menedżer sterowania usługami jest przy użyciu interfejsu użytkownika. Można zautomatyzować zadania dostępne w konsoli. Jeśli <xref:System.ServiceProcess.ServiceBase.CanStop%2A>, <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A>, lub <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> jest `true` , ale nie zaimplementowano odpowiadającą im metodę obsługi polecenia (takich jak <xref:System.ServiceProcess.ServiceBase.OnStop%2A>) system zgłasza wyjątek i ignoruje polecenia.  
  
 Nie trzeba implementować <xref:System.ServiceProcess.ServiceBase.OnStart%2A>, <xref:System.ServiceProcess.ServiceBase.OnStop%2A>, lub innej metody w <xref:System.ServiceProcess.ServiceBase>. Jednak zachowanie usługi jest opisane w <xref:System.ServiceProcess.ServiceBase.OnStart%2A>, więc minimum, powinna zostać zastąpiona tego elementu członkowskiego. `main()` Funkcja pliku wykonywalnego, który rejestruje usługi w pliku wykonywalnym z Menedżerem sterowania usługami, wywołując <xref:System.ServiceProcess.ServiceBase.Run%2A> metody. <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> Właściwość <xref:System.ServiceProcess.ServiceBase> obiekt przekazany do <xref:System.ServiceProcess.ServiceBase.Run%2A> metoda musi odpowiadać <xref:System.ServiceProcess.ServiceInstaller.ServiceName%2A> właściwość Instalatora usługi dla tej usługi.  
  
 Możesz użyć `InstallUtil.exe` do zainstalowania usług w systemie.  
  
> [!NOTE]
>  Dziennik innego niż dziennik zdarzeń aplikacji, aby otrzymać powiadomienie o wywołań usługi, ale nie można określić <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> ani <xref:System.ServiceProcess.ServiceBase.EventLog%2A> właściwość może zapisywać do dziennika niestandardowego. Ustaw <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> do `false` , jeśli nie chcesz używać rejestrowania automatycznego.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.ServiceProcess.ServiceProcessInstaller" />
    <altmember cref="T:System.ServiceProcess.ServiceInstaller" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ServiceBase ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ServiceBase();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Tworzy nowe wystąpienie klasy <see cref="T:System.ServiceProcess.ServiceBase" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie należy tworzyć wystąpienia <xref:System.ServiceProcess.ServiceBase> klasy. Zamiast tego dziedziczyć <xref:System.ServiceProcess.ServiceBase> i utworzyć wystąpienie klasy pochodnej. Minimum, którą należy wdrożyć w Konstruktorze dla klasy dziedziczone z <xref:System.ServiceProcess.ServiceBase> polega na ustawieniu <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> na składnik. Nie inne procesy przetwarzania są wyraźnie wymagane w konstruktorze. Powinna obsługiwać większość inicjowania w <xref:System.ServiceProcess.ServiceBase.OnStart%2A> , a nie w konstruktorze. W przeciwnym razie nie ma żadnej gwarancji, które obiekty zostanie zainicjowana ponownie po ponownym uruchomieniu usługi po jej zatrzymaniu.  
  
 Jeśli zastąpisz Konstruktor w klasie pochodnej, należy wywołać konstruktora klasy bazowej, w kodzie.  
  
 <xref:System.ServiceProcess.ServiceBase> Zestawy Konstruktor <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> do `true`. Jeśli nie chcesz automatycznie Rejestruj wywołań do usługi z Menedżera sterowania usługami (SCM), ustaw <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> do `false`.  
  
 Jeśli pliku wykonywalnego, który zawiera pojedynczą usługę, system wywołuje konstruktor usługi rozpoczęcia jest wybrana w zaufanym Menedżer sterowania usługami, gdy jest wykonywany destruktor, gdy zatrzymanie jest wywoływana.  
  
 Jeśli pliku wykonywalnego, który zawiera wiele usług, wywołanie rozpoczniesz pracę z jednej usługi powoduje, że konstruktory będzie wywoływana dla wszystkich usług w pliku wykonywalnym, ale określona usługa jest uruchomiona. Destruktory dla usług są uruchamiane razem, gdy wszystkie usługi zostały zatrzymane, indywidualnie gdy każda usługa jest zatrzymana.  
  
> [!NOTE]
>  Jeśli zastąpisz konstruktora klasy bazowej, należy jawnie wywołać go w konstruktorze klasy pochodnej.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.AutoLog" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase[])" />
      </Docs>
    </Member>
    <Member MemberName="AutoLog">
      <MemberSignature Language="C#" Value="public bool AutoLog { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoLog" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.AutoLog" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoLog As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutoLog { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoLog : bool with get, set" Usage="System.ServiceProcess.ServiceBase.AutoLog" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ServiceProcess.ServiceProcessDescription("SBAutoLog")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wskazuje, czy raport polecenia Start, Zatrzymaj, Wstrzymaj i Kontynuuj w dzienniku zdarzeń.</summary>
        <value><see langword="true" /> do informacji w raporcie w dzienniku zdarzeń; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustawienie <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> do `true` powoduje, że usługa Dziennik zdarzeń aplikacji, aby zgłaszać awarie polecenia, a także informacje o zmianach stanu na użytek Uruchom, Zatrzymaj, Wstrzymaj i Kontynuuj zdarzenia w usłudze. Nazwa usługi jest używana do logowania <xref:System.Diagnostics.EventLog.Source%2A?displayProperty=nameWithType>.  
  
 Aby raportuje niestandardowy dziennik zdarzeń, a nie w dzienniku aplikacji, ustaw <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> do `false` i zapisywanie instrukcje w metodach obsługi polecenia <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>, <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, lub <xref:System.ServiceProcess.ServiceBase.OnStop%2A> do wysłania do odpowiedniego dziennika.  
  
> [!NOTE]
>  <xref:System.ServiceProcess.ServiceBase.ServiceName%2A>, Który dostarcza ciąg źródłowy dla dziennika zdarzeń, należy skonfigurować usługę podejmuje próbę zapisu w dzienniku zdarzeń. Próby dostępu do dziennika zdarzeń, przed ustawieniem nazwę źródła zgłasza wyjątek.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.EventLog" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
    <Member MemberName="CanHandlePowerEvent">
      <MemberSignature Language="C#" Value="public bool CanHandlePowerEvent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanHandlePowerEvent" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      <MemberSignature Language="VB.NET" Value="Public Property CanHandlePowerEvent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanHandlePowerEvent { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanHandlePowerEvent : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy usługa może obsługiwać powiadomienia o zmianach stanu zasilania komputera.</summary>
        <value><see langword="true" /> Jeśli usługa obsługuje stan zasilania komputera, zmiany w oznaczone <see cref="T:System.ServiceProcess.PowerBroadcastStatus" /> klasy, w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas zmiany stanu zasilania komputera, Menedżer sterowania usługami (SCM) sprawdza, czy usługa akceptuje power poleceń zdarzeń przy użyciu wartości <xref:System.ServiceProcess.ServiceBase.CanHandlePowerEvent%2A>.  
  
 Jeśli <xref:System.ServiceProcess.ServiceBase.CanHandlePowerEvent%2A> jest `true`, polecenie jest przekazywany do usługi i <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A> metoda jest wywoływana, jeśli została zdefiniowana. Jeśli <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A> nie jest zaimplementowana w klasie pochodnej, Menedżer sterowania usługami obsługuje zdarzenie zasilania, za pośrednictwem pusta klasa bazowa <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ta właściwość jest modyfikowana po uruchomienia usługi.</exception>
        <altmember cref="T:System.ServiceProcess.PowerBroadcastStatus" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
      </Docs>
    </Member>
    <Member MemberName="CanHandleSessionChangeEvent">
      <MemberSignature Language="C#" Value="public bool CanHandleSessionChangeEvent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanHandleSessionChangeEvent" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Property CanHandleSessionChangeEvent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanHandleSessionChangeEvent { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanHandleSessionChangeEvent : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy usługa może obsługiwać zdarzenia zmiany sesji odebrane w sesji serwera terminali.</summary>
        <value><see langword="true" /> Jeśli usługa może obsługiwać zdarzenia zmiany sesji serwera terminali; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Ta właściwość jest modyfikowana po uruchomienia usługi.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnSessionChange(System.ServiceProcess.SessionChangeDescription)" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="CanPauseAndContinue">
      <MemberSignature Language="C#" Value="public bool CanPauseAndContinue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanPauseAndContinue" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
      <MemberSignature Language="VB.NET" Value="Public Property CanPauseAndContinue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanPauseAndContinue { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanPauseAndContinue : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy usługa może być wstrzymywane i wznowić.</summary>
        <value><see langword="true" /> Jeśli usługa może być wstrzymana; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustaw wartość <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> właściwość w Konstruktorze dla usługi.  
  
 Usługa jest wstrzymana, zatrzymuje, jakie jest zastosowanie. W przypadku nadal (lub za pośrednictwem Menedżera sterowania usługami programowo), usługa <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> działa.  
  
 Wysyła żądanie wstrzymania do usługi mogą zaoszczędzić zasoby systemowe. Wstrzymaj nie może zwolnić wszystkie zasoby systemu, ale nie zatrzymania. <xref:System.ServiceProcess.ServiceBase.OnPause%2A> i <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> są często stosowane w celu wykonywania przetwarzania, mniej niż <xref:System.ServiceProcess.ServiceBase.OnStop%2A> i <xref:System.ServiceProcess.ServiceBase.OnStart%2A>.  
  
 Gdy <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> jest `true`, Zastąp <xref:System.ServiceProcess.ServiceBase.OnPause%2A> i <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> do określenia przetwarzania, które powinny być wykonywane, gdy Menedżer sterowania usługami (SCM) przekazuje żądanie wstrzymania lub Kontynuuj z usługą. <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> powinny być zrealizowane cofnąć przetwarzania w <xref:System.ServiceProcess.ServiceBase.OnPause%2A>.  
  
 Jeśli <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> jest `false`Menedżer sterowania usługami nie przejdzie Wstrzymaj i Kontynuuj żądań do usługi, więc <xref:System.ServiceProcess.ServiceBase.OnPause%2A> i <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> metody nie zostaną wywołane, nawet wtedy, gdy są one wykonywane. W funkcji SCM `Pause` i `Continue` formanty są wyłączone, gdy <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> jest `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Usługa została już uruchomiona. <see cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" /> Nie można zmienić właściwości, gdy usługa została uruchomiona.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="CanShutdown">
      <MemberSignature Language="C#" Value="public bool CanShutdown { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanShutdown" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanShutdown" />
      <MemberSignature Language="VB.NET" Value="Public Property CanShutdown As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanShutdown { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanShutdown : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanShutdown" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy usługa otrzymają powiadomienie, gdy system jest zamykany.</summary>
        <value><see langword="true" /> Jeśli usługa otrzymają powiadomienie, gdy system jest zamykany; w przeciwnym razie <see langword="false" />.  Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A> jest `true`, usługa zostanie powiadomiony, gdy system jest zamykany. Podczas zamykania systemu <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A> metoda jest wywoływana, jeśli został zaimplementowany w klasie pochodnej.  
  
> [!NOTE]
>  Tylko system powinien powodować <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A> metodę, aby wykonać; usługa może wywołać go, ale nie jest to zalecane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Usługa została już uruchomiona. <see cref="P:System.ServiceProcess.ServiceBase.CanShutdown" /> Nie można zmienić właściwości, gdy usługa została uruchomiona.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="CanStop">
      <MemberSignature Language="C#" Value="public bool CanStop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanStop" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanStop" />
      <MemberSignature Language="VB.NET" Value="Public Property CanStop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanStop { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanStop : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanStop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy usługa może zostać zatrzymana, po jego uruchomieniu.</summary>
        <value><see langword="true" /> zatrzymanie usługi i <see cref="M:System.ServiceProcess.ServiceBase.OnStop" /> metodę o nazwie; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zatrzymaj wywołanego w usłudze Menedżer sterowania usługami (SCM) sprawdza, czy usługa akceptuje polecenia Stop przy użyciu wartości <xref:System.ServiceProcess.ServiceBase.CanStop%2A>. Dla większości usług, wartość <xref:System.ServiceProcess.ServiceBase.CanStop%2A> jest `true`, ale niektóre usługi systemu operacyjnego, na przykład nie Zezwalaj użytkownikowi na zatrzymania ich przez użytkownika.  
  
 Jeśli <xref:System.ServiceProcess.ServiceBase.CanStop%2A> jest `true`, polecenie zatrzymania jest przekazywany do usługi i <xref:System.ServiceProcess.ServiceBase.OnStop%2A> metoda jest wywoływana, jeśli jest zdefiniowana. Jeśli <xref:System.ServiceProcess.ServiceBase.OnStop%2A> nie jest zaimplementowana w klasie pochodnej obsługuje SCM polecenia zatrzymania za pośrednictwem pusta klasa bazowa <xref:System.ServiceProcess.ServiceBase.OnStop%2A?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Usługa została już uruchomiona. <see cref="P:System.ServiceProcess.ServiceBase.CanStop" /> Nie można zmienić właściwości, gdy usługa została uruchomiona.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="serviceBase.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" /> Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> aby zwolnić tylko niezarządzane zasoby.</param>
        <summary>Usuwa zasoby (inne niż pamięć) używane przez <see cref="T:System.ServiceProcess.ServiceBase" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj <xref:System.ServiceProcess.ServiceBase.Dispose%2A> w klasie pochodnej (i za jego pośrednictwem w <xref:System.ServiceProcess.ServiceBase> klasy) po zakończeniu korzystania z klasy pochodnej. <xref:System.ServiceProcess.ServiceBase.Dispose%2A> Metoda pozostawia klasy pochodnej w stanie uniemożliwiającym jego używanie. Po wywołaniu <xref:System.ServiceProcess.ServiceBase.Dispose%2A>, trzeba zwolnić wszystkie odwołania do klasy pochodnej i <xref:System.ServiceProcess.ServiceBase> , dzięki czemu można odzyskać pamięci zostały one zajmuje przez wyrzucanie elementów bezużytecznych.  
  
> [!NOTE]
>  Zawsze wywołuj <xref:System.ServiceProcess.ServiceBase.Dispose%2A> przed publikacją swoje ostatnie odwołanie do klasy pochodzącej od <xref:System.ServiceProcess.ServiceBase>. W przeciwnym razie zasoby <xref:System.ServiceProcess.ServiceBase> i korzystania z klasy pochodnej będzie nie być zwolniona, dopóki wyrzucania elementów bezużytecznych wywołuj destruktory obiektów.  
  
 <xref:System.ServiceProcess.ServiceBase.OnStop%2A> często jest implementowane w celu przetwarzania kodu w <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, połączone z wywołaniem <xref:System.ServiceProcess.ServiceBase.Dispose%2A>. Jeśli chcesz to zrobić w klasie pochodnej jest zwyczajowego do zaimplementowania <xref:System.ServiceProcess.ServiceBase.OnStart%2A> do przydzielenia, niezależnie od rodzaju <xref:System.ServiceProcess.ServiceBase.Dispose%2A> wydane.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="EventLog">
      <MemberSignature Language="C#" Value="public virtual System.Diagnostics.EventLog EventLog { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.EventLog EventLog" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.EventLog" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EventLog As EventLog" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Diagnostics::EventLog ^ EventLog { System::Diagnostics::EventLog ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EventLog : System.Diagnostics.EventLog" Usage="System.ServiceProcess.ServiceBase.EventLog" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLog</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera dziennika zdarzeń, który służy do zapisywania powiadomień wywołania polecenia usługi, takie jak uruchamianie i zatrzymywanie, w dzienniku zdarzeń aplikacji.</summary>
        <value><see cref="T:System.Diagnostics.EventLog" /> Wystąpienie, którego źródłem jest zarejestrowany w dzienniku aplikacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Konstruktor inicjuje <xref:System.ServiceProcess.ServiceBase.EventLog%2A> właściwości wystąpienia o <xref:System.Diagnostics.EventLog.Source%2A?displayProperty=nameWithType> i <xref:System.Diagnostics.EventLog.Log%2A?displayProperty=nameWithType> zestawu właściwości. Obiekt źródłowy ma <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> usługi, i dziennika w dzienniku aplikacji na komputerze. Te wartości są ustawiane automatycznie i nie można zmienić dla automatycznego rejestrowania poleceń usługi.  
  
 Gdy <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> jest `true`, uruchamianie, Zatrzymaj, Wstrzymaj, Kontynuuj i niestandardowe polecenia są automatycznie rejestrowane w dzienniku zdarzeń aplikacji. Możesz użyć <xref:System.ServiceProcess.ServiceBase.EventLog%2A> właściwość do zapisania dodatkowe komunikaty do tego dziennika, jak również. Wywołuje składnik <xref:System.Diagnostics.EventLog.WriteEntry%2A?displayProperty=nameWithType> za pomocą tego <xref:System.ServiceProcess.ServiceBase.EventLog%2A> elementu członkowskiego.  
  
 Aby raportuje niestandardowy dziennik zdarzeń, a nie w dzienniku aplikacji, ustaw <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> do `false` i zapisywanie instrukcje w metodach obsługi polecenia <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>, <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, lub <xref:System.ServiceProcess.ServiceBase.OnStop%2A> do wysłania do odpowiedniego dziennika.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.AutoLog" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="T:System.Diagnostics.EventLog" />
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public int ExitCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.ExitCode" />
      <MemberSignature Language="VB.NET" Value="Public Property ExitCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ExitCode { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ExitCode : int with get, set" Usage="System.ServiceProcess.ServiceBase.ExitCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kod zakończenia usługi.</summary>
        <value>Kod zakończenia usługi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustaw <xref:System.ServiceProcess.ServiceBase.ExitCode%2A> właściwość z wartością niezerową przed zatrzymaniem usługi, aby wskazać błąd menedżera kontroli usług.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxNameLength">
      <MemberSignature Language="C#" Value="public const int MaxNameLength = 80;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 MaxNameLength = (80)" />
      <MemberSignature Language="DocId" Value="F:System.ServiceProcess.ServiceBase.MaxNameLength" />
      <MemberSignature Language="VB.NET" Value="Public Const MaxNameLength As Integer  = 80" />
      <MemberSignature Language="C++ CLI" Value="public: int MaxNameLength = 80;" />
      <MemberSignature Language="F#" Value="val mutable MaxNameLength : int" Usage="System.ServiceProcess.ServiceBase.MaxNameLength" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>80</MemberValue>
      <Docs>
        <summary>Określa maksymalny rozmiar nazwy usługi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Równocześnie wartości ServiceName i DisplayName mają ograniczenia rozmiaru, które muszą być spełnione, podczas ustawiania właściwości w klasie usługi.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.ServiceName" />
      </Docs>
    </Member>
    <Member MemberName="OnContinue">
      <MemberSignature Language="C#" Value="protected virtual void OnContinue ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContinue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnContinue" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContinue ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContinue();" />
      <MemberSignature Language="F#" Value="abstract member OnContinue : unit -&gt; unit&#xA;override this.OnContinue : unit -&gt; unit" Usage="serviceBase.OnContinue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Po zaimplementowaniu w klasie pochodnej <see cref="M:System.ServiceProcess.ServiceBase.OnContinue" /> jest uruchamiany, gdy polecenie Kontynuuj są wysyłane do usługi przez Menedżera sterowania usługami (SCM). Określa akcje do podjęcia, gdy usługa wznawia normalnego funkcjonowania po wstrzymaniu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Implementowanie <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> duplikatów odpowiedzi aplikacji <xref:System.ServiceProcess.ServiceBase.OnPause%2A>. W przypadku nadal (lub za pośrednictwem konsoli usługi programowo), usługa <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> przetwarzania działa i usługa stanie się aktywny ponownie.  
  
 <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> powinien zostać zastąpiona po <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> właściwość `true`.  
  
 Jeśli <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> jest `false`Menedżer sterowania usługami nie przejdzie Wstrzymaj i Kontynuuj żądań do usługi, więc <xref:System.ServiceProcess.ServiceBase.OnPause%2A> i <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> metody nie zostaną wywołane, nawet wtedy, gdy są one wykonywane. W funkcji SCM `Pause` i `Continue` formanty są wyłączone, gdy <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> jest `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnCustomCommand">
      <MemberSignature Language="C#" Value="protected virtual void OnCustomCommand (int command);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCustomCommand(int32 command) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCustomCommand (command As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCustomCommand(int command);" />
      <MemberSignature Language="F#" Value="abstract member OnCustomCommand : int -&gt; unit&#xA;override this.OnCustomCommand : int -&gt; unit" Usage="serviceBase.OnCustomCommand command" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="command" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="command">Komunikat polecenia wysyłane do usługi.</param>
        <summary>Po zaimplementowaniu w klasie pochodnej <see cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" /> wykonuje, gdy Menedżer sterowania usługami (SCM) przekazuje polecenia niestandardowego do usługi. Określa akcje do wykonania w przypadku polecenia o określona wartość parametru.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceProcess.ServiceBase.OnCustomCommand%2A> Pozwala określić dodatkowe funkcje oprócz uruchamianie, zatrzymywanie, wstrzymywanie i kontynuowanie usług.  
  
 Menedżer sterowania usługami, nie analizuje polecenie niestandardowe, aby sprawdzić, czy usługa obsługuje `command` przekazany parametr. Przekazuje ono polecenie niestandardowe bezpośrednio do usługi. Jeśli usługa nie rozpoznaje `command` parametru, nic nie robi.  
  
 Polecenia niestandardowe są inicjowane przez <xref:System.ServiceProcess.ServiceController.ExecuteCommand%2A> instrukcji w <xref:System.ServiceProcess.ServiceController> składnika. Korzystanie z instrukcji switch lub, jeśli... następnie warunek do obsługi poleceń niestandardowych, zdefiniowanych w usłudze.  
  
 Tylko wartości dla polecenia niestandardowego, który można zdefiniować w swojej aplikacji lub w <xref:System.ServiceProcess.ServiceBase.OnCustomCommand%2A> dotyczą od 128 do 255. Liczby całkowite poniżej 128 odpowiadają wartościom zastrzeżone przez system.  
  
 Jeśli <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> właściwość `true`, niestandardowych poleceń, podobnie jak wszystkie inne polecenia zapisywanie wpisów w dzienniku zdarzeń, aby zgłosić, czy podczas wykonywania metody zakończonych powodzeniem lub niepowodzeniem.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
    <Member MemberName="OnPause">
      <MemberSignature Language="C#" Value="protected virtual void OnPause ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPause() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnPause" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPause ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPause();" />
      <MemberSignature Language="F#" Value="abstract member OnPause : unit -&gt; unit&#xA;override this.OnPause : unit -&gt; unit" Usage="serviceBase.OnPause " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Po zaimplementowaniu w klasie pochodnej, wykonuje, gdy polecenie wstrzymania są wysyłane do usługi przez Menedżera sterowania usługami (SCM). Określa akcje do wykonania w przypadku wstrzymuje usługę.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.ServiceProcess.ServiceBase.OnPause%2A> do określenia przetwarzania, które występuje, gdy usługa odbiera polecenie wstrzymania. <xref:System.ServiceProcess.ServiceBase.OnPause%2A> powinien zostać zastąpiona po <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> właściwość `true`.  
  
 W przypadku nadal wstrzymanej usługi (lub za pośrednictwem konsoli usługi programowo), <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> przetwarzania jest uruchamiane, a usługa stanie się aktywny ponownie.  
  
 Polecenie wstrzymania zezwala tylko aplikacji reagować na zdarzenia. <xref:System.ServiceProcess.ServiceBase.OnPause%2A> nie działają z usługą nie definiują celu.  
  
 Wysyła żądanie wstrzymania do usługi mogą oszczędzania zasobów systemu, ponieważ Wstrzymaj muszą zwalnia wszystkie zasoby systemowe. Na przykład jeśli zostały otwarte wątki w procesie, wstrzymanie usługi, a nie jej zatrzymania można zezwolić na wątki pozostają otwarte, co eliminuje konieczność ich ponowne przydzielenie, gdy usługa będzie. Jeśli zdefiniujesz Wstrzymaj, aby zwolnić wszystkie zasoby systemowe, zachowuje się jak polecenie zatrzymania.  
  
 Ustaw <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> do `true`i zastępowania <xref:System.ServiceProcess.ServiceBase.OnPause%2A> i <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> do określenia przetwarzania, które powinny być wykonywane, gdy Menedżer sterowania usługami przekazuje żądanie wstrzymania lub Kontynuuj z usługą. <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> powinny być zrealizowane cofnąć przetwarzania w <xref:System.ServiceProcess.ServiceBase.OnPause%2A>.  
  
 Jeśli <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> jest `false`Menedżer sterowania usługami nie przejdzie Wstrzymaj i Kontynuuj żądań do usługi, więc <xref:System.ServiceProcess.ServiceBase.OnPause%2A> i <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> metody nie zostaną wywołane, nawet wtedy, gdy zaimplementowane. W funkcji SCM `Pause` i `Continue` formanty są wyłączone, gdy <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> jest `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnPowerEvent">
      <MemberSignature Language="C#" Value="protected virtual bool OnPowerEvent (System.ServiceProcess.PowerBroadcastStatus powerStatus);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool OnPowerEvent(valuetype System.ServiceProcess.PowerBroadcastStatus powerStatus) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function OnPowerEvent (powerStatus As PowerBroadcastStatus) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool OnPowerEvent(System::ServiceProcess::PowerBroadcastStatus powerStatus);" />
      <MemberSignature Language="F#" Value="abstract member OnPowerEvent : System.ServiceProcess.PowerBroadcastStatus -&gt; bool&#xA;override this.OnPowerEvent : System.ServiceProcess.PowerBroadcastStatus -&gt; bool" Usage="serviceBase.OnPowerEvent powerStatus" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="powerStatus" Type="System.ServiceProcess.PowerBroadcastStatus" />
      </Parameters>
      <Docs>
        <param name="powerStatus">A <see cref="T:System.ServiceProcess.PowerBroadcastStatus" /> oznacza powiadomienie z systemu o jego stanu zasilania.</param>
        <summary>Po zaimplementowaniu w klasie pochodnej, wykonuje, gdy zmieniono stan zasilania komputera. Dotyczy to komputerów przenośnych po przejściu w tryb wstrzymania, który nie jest taka sama jak zamknięcia systemu.</summary>
        <returns>Po zaimplementowaniu w klasie pochodnej, wymagań aplikacji ustalić, jaka wartość do zwrócenia. Na przykład jeśli <see langword="QuerySuspend" /> emisji stan jest przekazywany, może spowodować aplikację, aby odrzucić zapytania, zwracając <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A> do określenia przetwarzania, które występuje, gdy zdarzenie systemowe czcionką <xref:System.ServiceProcess.PowerBroadcastStatus> występuje wyliczenie — na przykład, gdy komputer znajduje się w trybie wstrzymania lub wskazuje na niskim poziomie energii baterii.  
  
 <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A> powinien zostać zastąpiona po <xref:System.ServiceProcess.ServiceBase.CanHandlePowerEvent%2A> właściwość `true`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnSessionChange">
      <MemberSignature Language="C#" Value="protected virtual void OnSessionChange (System.ServiceProcess.SessionChangeDescription changeDescription);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSessionChange(valuetype System.ServiceProcess.SessionChangeDescription changeDescription) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnSessionChange(System.ServiceProcess.SessionChangeDescription)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSessionChange (changeDescription As SessionChangeDescription)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSessionChange(System::ServiceProcess::SessionChangeDescription changeDescription);" />
      <MemberSignature Language="F#" Value="abstract member OnSessionChange : System.ServiceProcess.SessionChangeDescription -&gt; unit&#xA;override this.OnSessionChange : System.ServiceProcess.SessionChangeDescription -&gt; unit" Usage="serviceBase.OnSessionChange changeDescription" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="changeDescription" Type="System.ServiceProcess.SessionChangeDescription" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="changeDescription">Struktura, która identyfikuje typ zmiany.</param>
        <summary>Wykonuje po odebraniu zdarzenia zmiany w sesji serwera terminali.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy ustawić <xref:System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent%2A> właściwość `true` umożliwiające wykonanie tej metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent" />
        <altmember cref="T:System.ServiceProcess.SessionChangeDescription" />
      </Docs>
    </Member>
    <Member MemberName="OnShutdown">
      <MemberSignature Language="C#" Value="protected virtual void OnShutdown ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnShutdown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnShutdown" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnShutdown ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnShutdown();" />
      <MemberSignature Language="F#" Value="abstract member OnShutdown : unit -&gt; unit&#xA;override this.OnShutdown : unit -&gt; unit" Usage="serviceBase.OnShutdown " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Po zaimplementowaniu w klasie pochodnej, wykonuje, gdy system jest zamykany. Określa, co powinno nastąpić bezpośrednio przed system zamykanie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A> do określenia przetwarzania, które występuje, gdy system będzie zamykany.  
  
 To zdarzenie występuje tylko wtedy, gdy system operacyjny jest zamknięta, nie wtedy, gdy komputer jest wyłączony.  
  
 <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A> powinien zostać zastąpiona po <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A> właściwość `true`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnStart">
      <MemberSignature Language="C#" Value="protected virtual void OnStart (string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStart(string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStart (args As String())" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStart(cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member OnStart : string[] -&gt; unit&#xA;override this.OnStart : string[] -&gt; unit" Usage="serviceBase.OnStart args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="args">Dane przekazywane przez polecenia uruchomienia.</param>
        <summary>Po zaimplementowaniu w klasie pochodnej, wykonuje, gdy polecenia uruchamiania są wysyłane do usługi przez Menedżera sterowania usługami (SCM) lub podczas uruchamiania systemu operacyjnego (w przypadku usługi, która jest uruchamiana automatycznie). Określa akcje do wykonania po uruchomieniu usługi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.ServiceProcess.ServiceBase.OnStart%2A> do określenia przetwarzania, które występuje, gdy usługa odbiera polecenia uruchamiania. <xref:System.ServiceProcess.ServiceBase.OnStart%2A> jest to metoda, w której zostaną określone zachowanie usługi. <xref:System.ServiceProcess.ServiceBase.OnStart%2A> może potrwać argumenty jako sposobu przekazywania danych, ale to użycie jest rzadkie.  
  
> [!CAUTION]
>  Konstruktor nie jest używany do wykonywania przetwarzania, który powinien być w <xref:System.ServiceProcess.ServiceBase.OnStart%2A>. Użyj <xref:System.ServiceProcess.ServiceBase.OnStart%2A> do obsługi wszystkich inicjowania usługi. Konstruktor jest wywoływana, gdy w pliku wykonywalnym aplikacji działa, nie wtedy, gdy usługa jest uruchamiana. Plik wykonywalny, który jest uruchamiany przed <xref:System.ServiceProcess.ServiceBase.OnStart%2A>. Jeśli będziesz kontynuować, na przykład, Konstruktor nie jest wywoływana ponownie, ponieważ Menedżer sterowania usługami zawiera już obiekt w pamięci. Jeśli <xref:System.ServiceProcess.ServiceBase.OnStop%2A> zwalnia zasoby przydzielone w konstruktorze, a nie w <xref:System.ServiceProcess.ServiceBase.OnStart%2A>, niezbędnych zasobów nie będzie można utworzyć ponownie po raz drugi nosi nazwę usługi.  
  
 Usługi można ustawić automatyczne uruchamianie po ponownym uruchomieniu komputera, ustawiając <xref:System.ServiceProcess.ServiceInstaller.StartType%2A> Instalatora usługi do <xref:System.ServiceProcess.ServiceStartMode.Automatic>. W takiej sytuacji <xref:System.ServiceProcess.ServiceBase.OnStart%2A> będą wywoływane podczas uruchamiania systemu.  
  
 <xref:System.ServiceProcess.ServiceBase.OnStart%2A> powinna zostać zastąpiona w klasie pochodnej. Usługi były przydatne <xref:System.ServiceProcess.ServiceBase.OnStart%2A> i <xref:System.ServiceProcess.ServiceBase.OnStop%2A> powinny można zaimplementować w klasie usługi.  
  
 Przetwarzanie argumentów inicjowania usługi w <xref:System.ServiceProcess.ServiceBase.OnStart%2A> metody, nie w metody Main. Argumenty w `args` tablicy parametrów można ręcznie ustawić w oknie dialogowym właściwości usługi w konsoli usługi. Argumenty, wprowadzona w konsoli nie są zapisywane; są one przekazywane do usługi na jednorazowe podczas uruchamiania usługi z poziomu Panelu sterowania. Argumenty, które muszą być obecne, kiedy usługa zostanie automatycznie uruchomiony można umieścić w wartości ciągu ImagePath dla klucza rejestru usługi (HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\\  *\< Nazwa usługi >*). Argumenty można uzyskać z rejestru przy użyciu <xref:System.Environment.GetCommandLineArgs%2A> metody, na przykład: `string[] imagePathArgs = Environment.GetCommandLineArgs();`.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnStop">
      <MemberSignature Language="C#" Value="protected virtual void OnStop ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnStop" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStop ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStop();" />
      <MemberSignature Language="F#" Value="abstract member OnStop : unit -&gt; unit&#xA;override this.OnStop : unit -&gt; unit" Usage="serviceBase.OnStop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Po zaimplementowaniu w klasie pochodnej, wykonuje, gdy polecenie zatrzymania są wysyłane do usługi przez Menedżera sterowania usługami (SCM). Określa akcje do wykonania, gdy usługa przestanie działać.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.ServiceProcess.ServiceBase.OnStop%2A> do określenia przetwarzania, które występuje, gdy usługa odbiera polecenie zatrzymania.  
  
 Gdy Menedżer sterowania usługami otrzymuje polecenie zatrzymania, wykorzystuje wartość <xref:System.ServiceProcess.ServiceBase.CanStop%2A> Aby sprawdzić, czy usługa akceptuje polecenia zatrzymania. Jeśli <xref:System.ServiceProcess.ServiceBase.CanStop%2A> jest `true`, polecenie zatrzymania jest przekazywany do usługi i <xref:System.ServiceProcess.ServiceBase.OnStop%2A> metoda jest wywoływana, jeśli jest zdefiniowana. Jeśli <xref:System.ServiceProcess.ServiceBase.OnStop%2A> nie jest zaimplementowana w usłudze Menedżer sterowania usługami obsługuje polecenie zatrzymania.  
  
 Jeśli <xref:System.ServiceProcess.ServiceBase.CanStop%2A> jest `false`, Menedżer sterowania usługami ignoruje polecenie zatrzymania. Nie zostanie przekazany do usługi. Polecenie zatrzymania zwraca i zgłasza wyjątek.  
  
 <xref:System.ServiceProcess.ServiceBase.OnStop%2A> powinna zostać zastąpiona w klasie pochodnej. Usługi były przydatne <xref:System.ServiceProcess.ServiceBase.OnStart%2A> i <xref:System.ServiceProcess.ServiceBase.OnStop%2A> powinny można zaimplementować w klasie usługi.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="RequestAdditionalTime">
      <MemberSignature Language="C#" Value="public void RequestAdditionalTime (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RequestAdditionalTime(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.RequestAdditionalTime(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RequestAdditionalTime (milliseconds As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RequestAdditionalTime(int milliseconds);" />
      <MemberSignature Language="F#" Value="member this.RequestAdditionalTime : int -&gt; unit" Usage="serviceBase.RequestAdditionalTime milliseconds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="milliseconds">Żądany czas w milisekundach.</param>
        <summary>Żądania dodatkowego czasu dla oczekujących operacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceProcess.ServiceBase.RequestAdditionalTime%2A> Metoda jest przeznaczona do wywoływania przez zastąpione <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>, <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, <xref:System.ServiceProcess.ServiceBase.OnStart%2A>, lub <xref:System.ServiceProcess.ServiceBase.OnStop%2A> metody, aby zażądać dodatkowego czasu dla oczekujących operacji, aby zapobiec Menedżera sterowania usługami (SCM) oznaczenia Usługa nie odpowiada.  Jeśli nie jest oczekująca operacja Kontynuuj Wstrzymaj, uruchamianie lub zatrzymywanie, <xref:System.InvalidOperationException> zgłaszany.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Usługa nie jest w stanie oczekiwania.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zawiera główny punkt wejścia dla pliku wykonywalnego usługi.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.ServiceProcess.ServiceBase service);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.ServiceProcess.ServiceBase service) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (service As ServiceBase)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(System::ServiceProcess::ServiceBase ^ service);" />
      <MemberSignature Language="F#" Value="static member Run : System.ServiceProcess.ServiceBase -&gt; unit" Usage="System.ServiceProcess.ServiceBase.Run service" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="service" Type="System.ServiceProcess.ServiceBase" />
      </Parameters>
      <Docs>
        <param name="service">A <see cref="T:System.ServiceProcess.ServiceBase" /> co oznacza usługi, aby rozpocząć.</param>
        <summary>Rejestruje plik wykonywalny dla usługi przy użyciu Menedżera sterowania usługami (SCM).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołać tego przeciążenia w `main()` funkcji usługi pliku wykonywalnego, aby zarejestrować usługę z Menedżera kontroli usług. Po wywołaniu metody <xref:System.ServiceProcess.ServiceBase.Run%28System.ServiceProcess.ServiceBase%29>, Menedżer sterowania usługami wydaje polecenie Start, co powoduje wywołanie <xref:System.ServiceProcess.ServiceBase.OnStart%2A> metody w usłudze. Usługa nie jest uruchomiona, dopóki nie jest wykonywane polecenia uruchomienia.  
  
 <xref:System.ServiceProcess.ServiceBase.Run%2A?displayProperty=nameWithType> Metoda jest wywoływana w podobny sposób jak <xref:System.Windows.Forms.Application.Run%2A?displayProperty=nameWithType> dla aplikacji Windows Forms.  
  
 Jeśli <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> jest `true`, wpis są zapisywane w dzienniku zdarzeń, jeśli usługa określony przez `service` parametr nie zostanie uruchomiona.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="service" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.#ctor" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.ServiceProcess.ServiceBase[] services);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.ServiceProcess.ServiceBase[] services) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (services As ServiceBase())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(cli::array &lt;System::ServiceProcess::ServiceBase ^&gt; ^ services);" />
      <MemberSignature Language="F#" Value="static member Run : System.ServiceProcess.ServiceBase[] -&gt; unit" Usage="System.ServiceProcess.ServiceBase.Run services" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="services" Type="System.ServiceProcess.ServiceBase[]" />
      </Parameters>
      <Docs>
        <param name="services">Tablica ServiceBase — wystąpień, które wskazują uruchomienie usług.</param>
        <summary>Rejestruje plik wykonywalny dla wielu usług za pomocą Menedżera sterowania usługami (SCM).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołać tego przeciążenia w `main()` funkcja pliku wykonywalnego do rejestrowania usług z Menedżerem sterowania usługami usługi. Po wywołaniu metody <xref:System.ServiceProcess.ServiceBase.Run%28System.ServiceProcess.ServiceBase%5B%5D%29>, Menedżer sterowania usługami wystawia uruchamiania poleceń, które powodować wysyłanie wywołań do <xref:System.ServiceProcess.ServiceBase.OnStart%2A> metod w usługach. Usługi nie zostały uruchomione, dopóki polecenia uruchamiania są wykonywane.  
  
 <xref:System.ServiceProcess.ServiceBase.Run%2A?displayProperty=nameWithType> Metoda jest wywoływana w podobny sposób jak <xref:System.Windows.Forms.Application.Run%2A?displayProperty=nameWithType> metodę dla aplikacji Windows Forms.  
  
 Jeśli <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> jest `true`, wpis są zapisywane w dzienniku zdarzeń, jeśli nie można uruchomić wszystkie usługi w tablicy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Uruchamianie usługi nie zostały dostarczone. Tablica może być <see langword="null" /> lub jest pusty.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.#ctor" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="ServiceHandle">
      <MemberSignature Language="C#" Value="protected IntPtr ServiceHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ServiceHandle" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.ServiceHandle" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property ServiceHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property IntPtr ServiceHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.ServiceHandle : nativeint" Usage="System.ServiceProcess.ServiceBase.ServiceHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;dotnet-plat-ext-2.1;netcore-2.1;netcore-2.2;dotnet-plat-ext-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera uchwyt formantu usługi dla usługi.</summary>
        <value><see cref="T:System.IntPtr" /> Strukturę, która zawiera dojście kontroli usługi dla usługi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dojście do sterowania usługi jest używane do komunikacji z Menedżera sterowania usługami (SCM).  Dojście można zaktualizować informacje o stanie menedżera kontroli usług dla wywołania usługi przy użyciu niezarządzanych `SetServiceStatus` funkcji.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać dostęp do kodu niezarządzanego. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ServiceMainCallback">
      <MemberSignature Language="C#" Value="public void ServiceMainCallback (int argCount, IntPtr argPointer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ServiceMainCallback(int32 argCount, native int argPointer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.ServiceMainCallback(System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ServiceMainCallback (argCount As Integer, argPointer As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ServiceMainCallback(int argCount, IntPtr argPointer);" />
      <MemberSignature Language="F#" Value="member this.ServiceMainCallback : int * nativeint -&gt; unit" Usage="serviceBase.ServiceMainCallback (argCount, argPointer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;dotnet-plat-ext-2.1;netcore-2.1;netcore-2.2;dotnet-plat-ext-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argCount" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="argPointer" Type="System.IntPtr" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="argCount">Liczba argumentów w tablicy argumentów.</param>
        <param name="argPointer"><see cref="T:System.IntPtr" /> Struktury, który wskazuje na tablicę argumentów.</param>
        <summary>Rejestruje program obsługi poleceń i uruchamia usługę.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ServiceName">
      <MemberSignature Language="C#" Value="public string ServiceName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ServiceName" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.ServiceName" />
      <MemberSignature Language="VB.NET" Value="Public Property ServiceName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ServiceName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ServiceName : string with get, set" Usage="System.ServiceProcess.ServiceBase.ServiceName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ServiceProcess.ServiceProcessDescription("SBServiceName")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia krótką nazwę, używany do identyfikowania usług do systemu.</summary>
        <value>Nazwa usługi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> Identyfikuje usługę Menedżer sterowania usługami. Wartość tej właściwości musi być taka sama jak nazwa, rejestrowane dla usługi w <xref:System.ServiceProcess.ServiceInstaller.ServiceName%2A?displayProperty=nameWithType> właściwość klasy odpowiedniego Instalatora. W kodzie <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> usługi jest zwykle ustawiana `main()` funkcja pliku wykonywalnego.  
  
 <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> Również służy do określania <xref:System.Diagnostics.EventLog.Source%2A?displayProperty=nameWithType> skojarzony <xref:System.ServiceProcess.ServiceBase.EventLog%2A> właściwości. To <xref:System.ServiceProcess.ServiceBase.EventLog%2A> to wystąpienie, który zapisuje informacje o poleceniu usługi w dzienniku aplikacji.  
  
 <xref:System.ServiceProcess.ServiceBase.ServiceName%2A>, Który dostarcza ciąg źródłowy dla dziennika zdarzeń, należy skonfigurować usługę zapisuje w dzienniku zdarzeń. Próby dostępu do dziennika zdarzeń, przed ustawieniem nazwę źródła powoduje zgłoszenie wyjątku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Usługa została już uruchomiona. <see cref="P:System.ServiceProcess.ServiceBase.ServiceName" /> Nie można zmienić właściwości, gdy usługa została uruchomiona.</exception>
        <exception cref="T:System.ArgumentException">Podana nazwa jest ciągiem o zerowej długości lub jej długość przekracza <see cref="F:System.ServiceProcess.ServiceBase.MaxNameLength" />, albo określona nazwa zawiera znaki do przodu, ukośnikiem lub ukośnikiem odwrotnym.</exception>
        <altmember cref="P:System.ServiceProcess.ServiceInstaller.ServiceName" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop();" />
      <MemberSignature Language="F#" Value="member this.Stop : unit -&gt; unit" Usage="serviceBase.Stop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zatrzymuje wykonywanie usługę.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceProcess.ServiceBase.Stop%2A> Metoda ustawia stan usługi, aby wskazać, zatrzymania jest w stanie oczekiwania i wywołania <xref:System.ServiceProcess.ServiceBase.OnStop%2A> metody.  Po zatrzymaniu aplikacji stan usługi jest ustawiony do zatrzymania. Jeśli aplikacja jest hostowana usługa, domena aplikacji jest zwalniana.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="ServiceBase" FullName="System.ServiceProcess.ServiceBase">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a9f9c0589c228e3c4dfc0dcc9de08488d92bee1b" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69231936" /></Metadata><TypeSignature Language="C#" Value="public class ServiceBase : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ServiceBase extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.ServiceProcess.ServiceBase" />
  <TypeSignature Language="VB.NET" Value="Public Class ServiceBase&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class ServiceBase : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type ServiceBase = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceProcess</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.ServiceProcess.ServiceProcessInstaller))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VisualStudio.Install.UserNTServiceDesigner, Microsoft.VisualStudio, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.IRootDesigner")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Udostępnia klasę bazową dla usługi, która będzie istnieć jako część aplikacji usługi. <see cref="T:System.ServiceProcess.ServiceBase" />musi być pochodny podczas tworzenia nowej klasy usługi.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pochodny <xref:System.ServiceProcess.ServiceBase> podczas definiowania klasy usługi w aplikacji usługi. Dowolna przydatna usługa zastępuje <xref:System.ServiceProcess.ServiceBase.OnStart%2A> metody <xref:System.ServiceProcess.ServiceBase.OnStop%2A> i. Aby uzyskać dodatkowe funkcje, można przesłonić <xref:System.ServiceProcess.ServiceBase.OnPause%2A> i <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> z określonym zachowaniem w odpowiedzi na zmiany stanu usługi.  
  
 Usługa to długotrwały plik wykonywalny, który nie obsługuje interfejsu użytkownika i może nie działać na koncie zalogowanego użytkownika. Usługa może działać bez żadnego użytkownika zalogowanego na komputerze.  
  
 Domyślnie usługi są uruchamiane na koncie systemowym, które nie jest takie samo jak konto administratora. Nie można zmienić uprawnień konta systemowego. Alternatywnie możesz użyć <xref:System.ServiceProcess.ServiceProcessInstaller> , aby określić konto użytkownika, pod którym zostanie uruchomiona usługa.  
  
 Plik wykonywalny może zawierać więcej niż jedną usługę, ale musi zawierać <xref:System.ServiceProcess.ServiceInstaller> oddzielne dla każdej usługi. <xref:System.ServiceProcess.ServiceInstaller> Wystąpienie rejestruje usługę w systemie. Instalator kojarzy również każdą usługę z dziennikiem zdarzeń, którego można użyć do rejestrowania poleceń usługi. `main()` Funkcja w pliku wykonywalnym określa, które usługi powinny być uruchamiane. Bieżącym katalogiem roboczym usługi jest katalog systemowy, a nie katalog, w którym znajduje się plik wykonywalny.  
  
 Po uruchomieniu usługi system lokalizuje plik wykonywalny i uruchamia <xref:System.ServiceProcess.ServiceBase.OnStart%2A> metodę dla tej usługi, która znajduje się w pliku wykonywalnym. Jednak uruchomienie usługi nie jest takie samo jak w przypadku uruchamiania pliku wykonywalnego. Plik wykonywalny ładuje tylko usługę. Dostęp do usługi (na przykład uruchomiono i zatrzymano) za pomocą Menedżera kontroli usług.  
  
 Plik wykonywalny wywołuje <xref:System.ServiceProcess.ServiceBase> konstruktora klasy pochodnej przy pierwszym wywołaniu metody Start w usłudze. Metoda <xref:System.ServiceProcess.ServiceBase.OnStart%2A> obsługi poleceń jest wywoływana natychmiast po wykonaniu konstruktora. Konstruktor nie jest wykonywany ponownie po pierwszym załadowaniu usługi, dlatego konieczne jest oddzielenie przetwarzania wykonywanego przez konstruktora z tego wykonywanego przez <xref:System.ServiceProcess.ServiceBase.OnStart%2A>. Wszystkie zasoby, które mogą być wydane <xref:System.ServiceProcess.ServiceBase.OnStop%2A> przez program, powinny <xref:System.ServiceProcess.ServiceBase.OnStart%2A>być utworzone w programie. Tworzenie zasobów w konstruktorze uniemożliwia ich utworzenie prawidłowo, jeśli usługa zostanie uruchomiona ponownie po <xref:System.ServiceProcess.ServiceBase.OnStop%2A> wydaniu zasobów.  
  
 Menedżer sterowania usługami (SCM) zapewnia możliwość korzystania z usługi. Menedżer SCM służy do przekazywania poleceń uruchamiania, zatrzymywania, wstrzymywania, kontynuowania lub niestandardowych do usługi. Menedżer SCM używa wartości <xref:System.ServiceProcess.ServiceBase.CanStop%2A> i, <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> aby określić, czy usługa akceptuje polecenia Zatrzymaj, Wstrzymaj lub Kontynuuj. Zatrzymaj, Wstrzymaj i Kontynuuj są włączone w menu kontekstowym SCM tylko wtedy, gdy odpowiednia właściwość <xref:System.ServiceProcess.ServiceBase.CanStop%2A> lub <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> znajduje `true` się w klasie usługi. Jeśli ta funkcja jest włączona, polecenie jest przesyłane do usługi, <xref:System.ServiceProcess.ServiceBase.OnStop%2A>a <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, lub <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> jest wywoływana. Jeśli <xref:System.ServiceProcess.ServiceBase.CanStop%2A>, <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A>, lub <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> jest <xref:System.ServiceProcess.ServiceBase.OnStop%2A>, odpowiadająca metoda obsługi poleceń (taka jak) nie zostanie przetworzona, nawet jeśli zaimplementowano `false`metodę.  
  
 <xref:System.ServiceProcess.ServiceController> Klasy można użyć do programistycznego działania usługi SCM korzystającej z interfejsu użytkownika. Można zautomatyzować zadania dostępne w konsoli programu. Jeśli <xref:System.ServiceProcess.ServiceBase.CanStop%2A>, <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A>, lub <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> jest <xref:System.ServiceProcess.ServiceBase.OnStop%2A>, ale nie zaimplementowano odpowiedniej metody obsługi poleceń (na przykład) system zgłasza wyjątek i ignoruje `true` polecenie.  
  
 Nie jest konieczne implementowanie <xref:System.ServiceProcess.ServiceBase.OnStart%2A>, <xref:System.ServiceProcess.ServiceBase.OnStop%2A>ani żadnej innej metody w <xref:System.ServiceProcess.ServiceBase>. Jednak zachowanie usługi jest opisane w <xref:System.ServiceProcess.ServiceBase.OnStart%2A>, dlatego należy je przesłonić co najmniej na poziomie tego elementu członkowskiego. Funkcja pliku wykonywalnego rejestruje usługę w pliku wykonywalnym przy użyciu Menedżera kontroli usług przez <xref:System.ServiceProcess.ServiceBase.Run%2A> wywołanie metody. `main()` Właściwość obiektu przeniesiona do <xref:System.ServiceProcess.ServiceBase.Run%2A> metody musi być zgodna z <xref:System.ServiceProcess.ServiceInstaller.ServiceName%2A> właściwością Instalatora usługi dla tej usługi. <xref:System.ServiceProcess.ServiceBase> <xref:System.ServiceProcess.ServiceBase.ServiceName%2A>  
  
 Programu można użyć `InstallUtil.exe` do zainstalowania usług w systemie.  
  
> [!NOTE]
>  Możesz określić dziennik inny niż dziennik zdarzeń aplikacji, aby otrzymywać powiadomienia o wywołaniach usług, ale <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> ani <xref:System.ServiceProcess.ServiceBase.EventLog%2A> Właściwość ani nie może zapisywać w dzienniku niestandardowym. Ustaw <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> na`false` , jeśli nie chcesz używać automatycznego rejestrowania.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.ServiceProcess.ServiceProcessInstaller" />
    <altmember cref="T:System.ServiceProcess.ServiceInstaller" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ServiceBase ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ServiceBase();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Tworzy nowe wystąpienie <see cref="T:System.ServiceProcess.ServiceBase" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie twórz wystąpienia <xref:System.ServiceProcess.ServiceBase> klasy. Zamiast tego należy <xref:System.ServiceProcess.ServiceBase> utworzyć i utworzyć wystąpienie klasy pochodnej. Minimalnym wymaganiem do zaimplementowania w konstruktorze klasy dziedziczonej <xref:System.ServiceProcess.ServiceBase> z jest <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> ustawienie elementu na składniku. W konstruktorze nie jest wymagane żadne inne przetwarzanie. Należy obsłużyć większość inicjacji w <xref:System.ServiceProcess.ServiceBase.OnStart%2A> , a nie w konstruktorze. W przeciwnym razie nie ma gwarancji, że obiekty zostaną zainicjowane ponownie po ponownym uruchomieniu usługi po jej zatrzymaniu.  
  
 Jeśli zastąpisz konstruktora w klasie pochodnej, Wywołaj konstruktora klasy bazowej w kodzie.  
  
 Konstruktor <xref:System.ServiceProcess.ServiceBase> ustawia<xref:System.ServiceProcess.ServiceBase.AutoLog%2A> wartość .`true` Jeśli nie chcesz automatycznie rejestrować wywołań do usługi z Menedżera sterowania usługami (SCM), ustaw <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> opcję na. `false`  
  
 Jeśli plik wykonywalny zawiera pojedynczą usługę, system wywołuje konstruktora usługi, gdy zostanie wybrany przycisk Uruchom z SCM, i uruchamia destruktor, jeśli jest wywoływana wartość Stop.  
  
 Jeśli plik wykonywalny zawiera wiele usług, wywołanie metody Start dla jednej usługi powoduje, że konstruktory mają być wywoływane dla wszystkich usług w pliku wykonywalnym, ale uruchomiona jest tylko określona usługa. Destruktory dla usług są uruchamiane razem, gdy wszystkie usługi zostały zatrzymane, a nie indywidualnie, gdy każda usługa zostanie zatrzymana.  
  
> [!NOTE]
>  Jeśli zastąpisz konstruktora klasy bazowej, należy jawnie wywołać go w konstruktorze klasy pochodnej.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.AutoLog" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase[])" />
      </Docs>
    </Member>
    <Member MemberName="AutoLog">
      <MemberSignature Language="C#" Value="public bool AutoLog { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoLog" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.AutoLog" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoLog As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutoLog { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoLog : bool with get, set" Usage="System.ServiceProcess.ServiceBase.AutoLog" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ServiceProcess.ServiceProcessDescription("SBAutoLog")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wskazuje, czy w dzienniku zdarzeń mają być zgłaszane polecenia Uruchom, Zatrzymaj, Wstrzymaj i Kontynuuj.</summary>
        <value><see langword="true" />Aby zgłosić informacje w dzienniku zdarzeń; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustawienie <xref:System.ServiceProcess.ServiceBase.AutoLog%2A>powoduje , że usługa używa dziennika zdarzeń aplikacji do zgłaszania błędów poleceń, a także informacji o zmianie stanu dla zdarzeń uruchamiania, zatrzymywania, wstrzymywania i kontynuowania w usłudze. `true` Nazwa usługi jest używana jako dziennik <xref:System.Diagnostics.EventLog.Source%2A?displayProperty=nameWithType>.  
  
 Aby zgłosić informacje do niestandardowego dziennika zdarzeń, a nie dziennika aplikacji, należy ustawić <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> na `false` i zapisać instrukcje w metodach <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> <xref:System.ServiceProcess.ServiceBase.OnPause%2A>obsługi poleceń, lub <xref:System.ServiceProcess.ServiceBase.OnStop%2A> w celu opublikowania w odpowiednim dzienniku.  
  
> [!NOTE]
>  <xref:System.ServiceProcess.ServiceBase.ServiceName%2A>, Która dostarcza ciąg źródłowy dziennika zdarzeń, musi być ustawiona przed próbą zapisu w dzienniku zdarzeń przez usługę. Próba uzyskania dostępu do dziennika zdarzeń przed ustawieniem nazwy źródła zgłasza wyjątek.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.EventLog" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
    <Member MemberName="CanHandlePowerEvent">
      <MemberSignature Language="C#" Value="public bool CanHandlePowerEvent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanHandlePowerEvent" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      <MemberSignature Language="VB.NET" Value="Public Property CanHandlePowerEvent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanHandlePowerEvent { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanHandlePowerEvent : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy usługa może obsługiwać powiadomienia o zmianach stanu komputera.</summary>
        <value><see langword="true" />Jeśli usługa obsługuje zmiany stanu baterii komputera wskazane w <see cref="T:System.ServiceProcess.PowerBroadcastStatus" /> klasie, <see langword="false" />w przeciwnym razie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy stan komputera ulegnie zmianie, Menedżer kontroli usług (SCM) sprawdza, czy usługa akceptuje polecenia zdarzeń, <xref:System.ServiceProcess.ServiceBase.CanHandlePowerEvent%2A>korzystając z wartości.  
  
 Jeśli <xref:System.ServiceProcess.ServiceBase.CanHandlePowerEvent%2A> <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A> jest `true`, polecenie jest przesyłane do usługi, a metoda jest wywoływana, jeśli zdefiniowana. Jeśli <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A> nie jest zaimplementowany w klasie pochodnej, menedżer SCM obsługuje zdarzenie zasilające przez pustą metodę klasy <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A?displayProperty=nameWithType> bazowej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ta właściwość jest modyfikowana po uruchomieniu usługi.</exception>
        <altmember cref="T:System.ServiceProcess.PowerBroadcastStatus" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
      </Docs>
    </Member>
    <Member MemberName="CanHandleSessionChangeEvent">
      <MemberSignature Language="C#" Value="public bool CanHandleSessionChangeEvent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanHandleSessionChangeEvent" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Property CanHandleSessionChangeEvent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanHandleSessionChangeEvent { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanHandleSessionChangeEvent : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy usługa może obsługiwać zdarzenia zmiany sesji odebrane z sesji serwera terminali.</summary>
        <value><see langword="true" />Jeśli usługa może obsłużyć zdarzenia zmiany sesji serwera terminali; w przeciwnym razie. <see langword="false" /></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Ta właściwość jest modyfikowana po uruchomieniu usługi.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnSessionChange(System.ServiceProcess.SessionChangeDescription)" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="CanPauseAndContinue">
      <MemberSignature Language="C#" Value="public bool CanPauseAndContinue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanPauseAndContinue" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
      <MemberSignature Language="VB.NET" Value="Public Property CanPauseAndContinue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanPauseAndContinue { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanPauseAndContinue : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy można wstrzymywać i wznawiać usługę.</summary>
        <value><see langword="true" />Jeśli usługa może zostać wstrzymana; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustaw wartość <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> właściwości w konstruktorze dla usługi.  
  
 Gdy usługa jest wstrzymana, zatrzymuje jej działanie. W przypadku kontynuowania usługi (za pomocą Menedżera kontroli usług lub programowo) program <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> działa.  
  
 Wysyłanie żądania wstrzymania do usługi może zaoszczędzić zasoby systemowe. Wstrzymanie może nie zwalniać wszystkich zasobów systemowych, ale zatrzymać działanie. <xref:System.ServiceProcess.ServiceBase.OnPause%2A>i <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> są często zaimplementowane w celu przeprowadzenia mniejszego <xref:System.ServiceProcess.ServiceBase.OnStart%2A>przetwarzania niż <xref:System.ServiceProcess.ServiceBase.OnStop%2A> i.  
  
 Gdy <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> ma `true`wartość, <xref:System.ServiceProcess.ServiceBase.OnPause%2A> przesłonić i <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> określić przetwarzanie, które powinno wystąpić, gdy Menedżer sterowania usługami przejdzie do usługi żądanie wstrzymania lub kontynuacji. <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>należy zaimplementować, aby cofnąć przetwarzanie w <xref:System.ServiceProcess.ServiceBase.OnPause%2A>.  
  
 Jeśli <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>tak <xref:System.ServiceProcess.ServiceBase.OnPause%2A> <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> , menedżer SCM nie przekaże do usługi żądań wstrzymania ani kontynuowania, więc metody i nie zostaną wywołane nawet wtedy, gdy są zaimplementowane. `false` `Pause` W SCM `Continue` formantyi<xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> są wyłączone .`false`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Usługa została już uruchomiona. Nie można zmienić właściwości po rozpoczęciu usługi. <see cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" /></exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="CanShutdown">
      <MemberSignature Language="C#" Value="public bool CanShutdown { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanShutdown" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanShutdown" />
      <MemberSignature Language="VB.NET" Value="Public Property CanShutdown As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanShutdown { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanShutdown : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanShutdown" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy usługa powinna być powiadamiana o zamknięciu systemu.</summary>
        <value><see langword="true" />Jeśli usługa powinna zostać powiadomiona o zamknięciu systemu; w przeciwnym razie. <see langword="false" />  Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A> jest`true`, usługa zostanie powiadomiona, gdy system jest zamykany. Przy zamykaniu <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A> Metoda jest wywoływana, jeśli została zaimplementowana w klasie pochodnej.  
  
> [!NOTE]
>  Tylko system powinien spowodować <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A> wykonanie metody; usługa może ją wywołać, ale nie jest to zalecane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Usługa została już uruchomiona. Nie można zmienić właściwości po rozpoczęciu usługi. <see cref="P:System.ServiceProcess.ServiceBase.CanShutdown" /></exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="CanStop">
      <MemberSignature Language="C#" Value="public bool CanStop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanStop" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanStop" />
      <MemberSignature Language="VB.NET" Value="Public Property CanStop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanStop { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanStop : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanStop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy usługa może zostać zatrzymana po jej uruchomieniu.</summary>
        <value><see langword="true" />Jeśli usługa może być zatrzymana i <see cref="M:System.ServiceProcess.ServiceBase.OnStop" /> wywoływana metoda; w przeciwnym razie,. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po wywołaniu opcji Zatrzymaj w usłudze Menedżer kontroli usług (SCM) sprawdza, czy usługa akceptuje polecenia zatrzymania przy użyciu wartości <xref:System.ServiceProcess.ServiceBase.CanStop%2A>. W przypadku większości usług wartość <xref:System.ServiceProcess.ServiceBase.CanStop%2A> jest `true`, ale niektórych usług systemu operacyjnego, na przykład, nie zezwala użytkownikowi na ich zatrzymanie.  
  
 Jeśli <xref:System.ServiceProcess.ServiceBase.CanStop%2A> <xref:System.ServiceProcess.ServiceBase.OnStop%2A> jest `true`, polecenie zatrzymania jest przesyłane do usługi, a metoda jest wywoływana, jeśli jest zdefiniowana. Jeśli <xref:System.ServiceProcess.ServiceBase.OnStop%2A> nie jest zaimplementowany w klasie pochodnej, menedżer SCM obsługuje polecenie zatrzymania przez pustą metodę klasy <xref:System.ServiceProcess.ServiceBase.OnStop%2A?displayProperty=nameWithType> bazowej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Usługa została już uruchomiona. Nie można zmienić właściwości po rozpoczęciu usługi. <see cref="P:System.ServiceProcess.ServiceBase.CanStop" /></exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="serviceBase.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" />Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> do zwolnienia tylko zasobów niezarządzanych.</param>
        <summary>Usuwa zasoby (inne niż pamięć) używane przez <see cref="T:System.ServiceProcess.ServiceBase" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj <xref:System.ServiceProcess.ServiceBase.Dispose%2A> w klasie pochodnej (i za pośrednictwem <xref:System.ServiceProcess.ServiceBase> klasy), gdy skończysz korzystać z klasy pochodnej. <xref:System.ServiceProcess.ServiceBase.Dispose%2A> Metoda pozostawia klasę pochodną w stanie niezdatnym do użytku. Po wywołaniu <xref:System.ServiceProcess.ServiceBase.Dispose%2A>należy wydać wszystkie odwołania do <xref:System.ServiceProcess.ServiceBase> klasy pochodnej, tak aby pamięć, w której zajmowała się, mogła być odzyskiwana przez wyrzucanie elementów bezużytecznych.  
  
> [!NOTE]
>  Zawsze wywołuj <xref:System.ServiceProcess.ServiceBase.Dispose%2A> przed wydaniem ostatniego odwołania do klasy pochodzącej od <xref:System.ServiceProcess.ServiceBase>. W przeciwnym razie użycie <xref:System.ServiceProcess.ServiceBase> zasobów i klasy pochodnej nie zostanie zwolnione do momentu wywołania destruktorów obiektów przez wyrzucanie elementów bezużytecznych.  
  
 <xref:System.ServiceProcess.ServiceBase.OnStop%2A>jest często zaimplementowany do przetwarzania kodu w <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, łącznie z wywołaniem do. <xref:System.ServiceProcess.ServiceBase.Dispose%2A> Jeśli zdecydujesz się to zrobić w klasie pochodnej, będzie ona niestandardowa do wdrożenia <xref:System.ServiceProcess.ServiceBase.OnStart%2A> w celu przydzielenia dowolnego <xref:System.ServiceProcess.ServiceBase.Dispose%2A> wydanego elementu.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="EventLog">
      <MemberSignature Language="C#" Value="public virtual System.Diagnostics.EventLog EventLog { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.EventLog EventLog" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.EventLog" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EventLog As EventLog" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Diagnostics::EventLog ^ EventLog { System::Diagnostics::EventLog ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EventLog : System.Diagnostics.EventLog" Usage="System.ServiceProcess.ServiceBase.EventLog" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLog</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera dziennik zdarzeń, którego można użyć do zapisu powiadomień o wywołaniach poleceń usługi, takich jak uruchamianie i zatrzymywanie, w dzienniku zdarzeń aplikacji.</summary>
        <value><see cref="T:System.Diagnostics.EventLog" /> Wystąpienie, którego źródło jest zarejestrowane w dzienniku aplikacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Konstruktor inicjuje <xref:System.ServiceProcess.ServiceBase.EventLog%2A> właściwość do wystąpienia <xref:System.Diagnostics.EventLog.Source%2A?displayProperty=nameWithType> z ustawionymi właściwościami i <xref:System.Diagnostics.EventLog.Log%2A?displayProperty=nameWithType> . Źródłem jest <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> usługa, a dziennik jest dziennikiem aplikacji komputera. Te wartości są ustawiane automatycznie i nie można ich zmienić na potrzeby automatycznego rejestrowania poleceń usługi.  
  
 Gdy <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> jest`true`, Uruchom, Zatrzymaj, Wstrzymaj, Kontynuuj i polecenia niestandardowe są automatycznie rejestrowane w dzienniku zdarzeń aplikacji. Możesz użyć <xref:System.ServiceProcess.ServiceBase.EventLog%2A> właściwości, aby zapisać dodatkowe komunikaty również do tego dziennika. Składnik wywołuje <xref:System.Diagnostics.EventLog.WriteEntry%2A?displayProperty=nameWithType> użycie tego <xref:System.ServiceProcess.ServiceBase.EventLog%2A> elementu członkowskiego.  
  
 Aby zgłosić informacje do niestandardowego dziennika zdarzeń, a nie dziennika aplikacji, należy ustawić <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> na `false` i zapisać instrukcje w metodach <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> <xref:System.ServiceProcess.ServiceBase.OnPause%2A>obsługi poleceń, lub <xref:System.ServiceProcess.ServiceBase.OnStop%2A> w celu opublikowania w odpowiednim dzienniku.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.AutoLog" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="T:System.Diagnostics.EventLog" />
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public int ExitCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.ExitCode" />
      <MemberSignature Language="VB.NET" Value="Public Property ExitCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ExitCode { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ExitCode : int with get, set" Usage="System.ServiceProcess.ServiceBase.ExitCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kod zakończenia usługi.</summary>
        <value>Kod zakończenia usługi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przed zatrzymaniem usługi Ustaw Właściwośćnawartośćróżnąodzera,abywskazaćbłądMenedżerakontroliusług.<xref:System.ServiceProcess.ServiceBase.ExitCode%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxNameLength">
      <MemberSignature Language="C#" Value="public const int MaxNameLength = 80;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 MaxNameLength = (80)" />
      <MemberSignature Language="DocId" Value="F:System.ServiceProcess.ServiceBase.MaxNameLength" />
      <MemberSignature Language="VB.NET" Value="Public Const MaxNameLength As Integer  = 80" />
      <MemberSignature Language="C++ CLI" Value="public: int MaxNameLength = 80;" />
      <MemberSignature Language="F#" Value="val mutable MaxNameLength : int" Usage="System.ServiceProcess.ServiceBase.MaxNameLength" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>80</MemberValue>
      <Docs>
        <summary>Wskazuje maksymalny rozmiar nazwy usługi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nazwy ServiceName i DisplayName mają ograniczenia rozmiaru, które muszą być przestrzegane podczas ustawiania właściwości w klasie usługi.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.ServiceName" />
      </Docs>
    </Member>
    <Member MemberName="OnContinue">
      <MemberSignature Language="C#" Value="protected virtual void OnContinue ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContinue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnContinue" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContinue ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContinue();" />
      <MemberSignature Language="F#" Value="abstract member OnContinue : unit -&gt; unit&#xA;override this.OnContinue : unit -&gt; unit" Usage="serviceBase.OnContinue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Po zaimplementowaniu w klasie pochodnej <see cref="M:System.ServiceProcess.ServiceBase.OnContinue" /> program jest uruchamiany, gdy do usługi jest wysyłane polecenie Continue przez Menedżera sterowania usługami (SCM). Określa akcje, które należy wykonać, gdy usługa wznawia normalne działanie po jego wstrzymaniu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zaimplementuj <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> , aby zdublować odpowiedź aplikacji na <xref:System.ServiceProcess.ServiceBase.OnPause%2A>. W przypadku kontynuowania usługi (za pomocą konsoli usług lub programowo) <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> przetwarzanie zostanie uruchomione, a usługa znów zostanie uaktywniona.  
  
 <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>powinien być przesłonięty, <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> gdy właściwość jest. `true`  
  
 Jeśli <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>tak <xref:System.ServiceProcess.ServiceBase.OnPause%2A> <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> , menedżer SCM nie przekaże do usługi żądań wstrzymania ani kontynuowania, więc metody i nie zostaną wywołane nawet wtedy, gdy są zaimplementowane. `false` `Pause` W SCM `Continue` formantyi<xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> są wyłączone .`false`  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnCustomCommand">
      <MemberSignature Language="C#" Value="protected virtual void OnCustomCommand (int command);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCustomCommand(int32 command) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCustomCommand (command As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCustomCommand(int command);" />
      <MemberSignature Language="F#" Value="abstract member OnCustomCommand : int -&gt; unit&#xA;override this.OnCustomCommand : int -&gt; unit" Usage="serviceBase.OnCustomCommand command" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="command" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="command">Komunikat polecenia wysłany do usługi.</param>
        <summary>Po zaimplementowaniu w klasie pochodnej <see cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" /> wykonuje się, gdy Menedżer sterowania usługami przekazuje polecenie niestandardowe do usługi. Określa akcje do wykonania, gdy występuje polecenie o określonej wartości parametru.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceProcess.ServiceBase.OnCustomCommand%2A>umożliwia określenie dodatkowych funkcji poza uruchamianiem, zatrzymywaniem, wstrzymywaniem i kontynuowaniem usług.  
  
 Menedżer SCM nie bada polecenia niestandardowego, aby sprawdzić, czy usługa obsługuje przekazaną wartość `command` parametru. Przekazuje polecenie niestandardowe bezpośrednio do usługi. Jeśli usługa nie rozpoznaje `command` parametru, nic nie robi.  
  
 Polecenia niestandardowe są wywoływane przez <xref:System.ServiceProcess.ServiceController.ExecuteCommand%2A> instrukcję <xref:System.ServiceProcess.ServiceController> w składniku. Użyj instrukcji switch lub if.. następnie warunek obsługi niestandardowych poleceń zdefiniowanych w usłudze.  
  
 Jedyne wartości dla polecenia niestandardowego, które można zdefiniować w aplikacji lub użyć w programie <xref:System.ServiceProcess.ServiceBase.OnCustomCommand%2A> to między 128 a 255. Liczby całkowite poniżej 128 odpowiadają wartościom zarezerwowanym przez system.  
  
 Jeśli właściwość jest `true`, polecenia niestandardowe, podobnie jak wszystkie inne polecenia, zapisują wpisy w dzienniku zdarzeń, aby zgłosić, czy wykonywanie metody zakończyło się powodzeniem czy niepowodzeniem. <xref:System.ServiceProcess.ServiceBase.AutoLog%2A>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
    <Member MemberName="OnPause">
      <MemberSignature Language="C#" Value="protected virtual void OnPause ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPause() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnPause" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPause ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPause();" />
      <MemberSignature Language="F#" Value="abstract member OnPause : unit -&gt; unit&#xA;override this.OnPause : unit -&gt; unit" Usage="serviceBase.OnPause " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Po zaimplementowaniu w klasie pochodnej jest wykonywane, gdy polecenie Pause jest wysyłane do usługi przez menedżera kontroli usług (SCM). Określa akcje do wykonania w przypadku wstrzymania usługi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.ServiceProcess.ServiceBase.OnPause%2A> , aby określić przetwarzanie wykonywane, gdy usługa odbierze polecenie pauzy. <xref:System.ServiceProcess.ServiceBase.OnPause%2A>powinien być przesłonięty, <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> gdy właściwość jest. `true`  
  
 W przypadku kontynuowania wstrzymanej usługi (za pomocą konsoli usług lub programowo) <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> przetwarzanie zostanie uruchomione, a usługa znów stanie się aktywna.  
  
 Polecenie Pause pozwala aplikacji na reagowanie na konkretne zdarzenie. <xref:System.ServiceProcess.ServiceBase.OnPause%2A>nie ma nic do usługi, która nie została zdefiniowana do wykonania.  
  
 Wysyłanie żądania wstrzymania do usługi może zaoszczędzić zasoby systemowe, ponieważ wstrzymanie nie wymaga zwolnienia wszystkich zasobów systemowych. Na przykład jeśli procesy zostały otwarte przez proces, wstrzymywanie usługi zamiast zatrzymywania może pozwolić, aby wątki pozostały otwarte, co eliminuje konieczność ponownego przydzielenia ich w przypadku kontynuowania usługi. Jeśli zdefiniujesz pauzę do zwolnienia wszystkich zasobów systemowych, zachowuje się to jak polecenie zatrzymania.  
  
 Ustaw <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> wartość `true`na i <xref:System.ServiceProcess.ServiceBase.OnPause%2A> Przesłoń <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> i, aby określić przetwarzanie, które powinno wystąpić, gdy menedżer SCM przekaże żądanie wstrzymania lub kontynuowania do usługi. <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>należy zaimplementować, aby cofnąć przetwarzanie w <xref:System.ServiceProcess.ServiceBase.OnPause%2A>.  
  
 Jeśli <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>tak <xref:System.ServiceProcess.ServiceBase.OnPause%2A> <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> , menedżer SCM nie przekaże do usługi żądań wstrzymania ani kontynuowania, więc metody i nie zostaną wywołane nawet w przypadku zaimplementowania. `false` `Pause` W SCM `Continue` formantyi<xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> są wyłączone .`false`  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnPowerEvent">
      <MemberSignature Language="C#" Value="protected virtual bool OnPowerEvent (System.ServiceProcess.PowerBroadcastStatus powerStatus);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool OnPowerEvent(valuetype System.ServiceProcess.PowerBroadcastStatus powerStatus) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function OnPowerEvent (powerStatus As PowerBroadcastStatus) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool OnPowerEvent(System::ServiceProcess::PowerBroadcastStatus powerStatus);" />
      <MemberSignature Language="F#" Value="abstract member OnPowerEvent : System.ServiceProcess.PowerBroadcastStatus -&gt; bool&#xA;override this.OnPowerEvent : System.ServiceProcess.PowerBroadcastStatus -&gt; bool" Usage="serviceBase.OnPowerEvent powerStatus" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="powerStatus" Type="System.ServiceProcess.PowerBroadcastStatus" />
      </Parameters>
      <Docs>
        <param name="powerStatus">A <see cref="T:System.ServiceProcess.PowerBroadcastStatus" /> wskazujące powiadomienie z systemu o stanie mocy.</param>
        <summary>Po zaimplementowaniu w klasie pochodnej wykonuje się, gdy zmienił się stan zasilacza komputera. Dotyczy to komputerów przenośnych, gdy przechodzą w tryb wstrzymania, który nie jest taki sam jak w przypadku zamknięcia systemu.</summary>
        <returns>W przypadku wdrożenia w klasie pochodnej, potrzeby aplikacji określają, która wartość ma zostać zwrócona. Na przykład w przypadku <see langword="QuerySuspend" /> przekazywania stanu emisji można spowodować odrzucenie zapytania <see langword="false" />przez aplikację.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A> , aby określić przetwarzanie, które ma miejsce w przypadku wystąpienia zdarzenia systemowego wskazanego <xref:System.ServiceProcess.PowerBroadcastStatus> w wyliczeniu — na przykład gdy komputer jest w trybie wstrzymania lub wskazuje na niską siłę baterii.  
  
 <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A>powinien być przesłonięty, <xref:System.ServiceProcess.ServiceBase.CanHandlePowerEvent%2A> gdy właściwość jest. `true`  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnSessionChange">
      <MemberSignature Language="C#" Value="protected virtual void OnSessionChange (System.ServiceProcess.SessionChangeDescription changeDescription);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSessionChange(valuetype System.ServiceProcess.SessionChangeDescription changeDescription) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnSessionChange(System.ServiceProcess.SessionChangeDescription)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSessionChange (changeDescription As SessionChangeDescription)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSessionChange(System::ServiceProcess::SessionChangeDescription changeDescription);" />
      <MemberSignature Language="F#" Value="abstract member OnSessionChange : System.ServiceProcess.SessionChangeDescription -&gt; unit&#xA;override this.OnSessionChange : System.ServiceProcess.SessionChangeDescription -&gt; unit" Usage="serviceBase.OnSessionChange changeDescription" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="changeDescription" Type="System.ServiceProcess.SessionChangeDescription" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="changeDescription">Struktura, która identyfikuje typ zmiany.</param>
        <summary>Wykonuje się po odebraniu zdarzenia zmiany z sesji serwera terminali.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy ustawić <xref:System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent%2A> właściwość na `true` , aby włączyć tę metodę.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent" />
        <altmember cref="T:System.ServiceProcess.SessionChangeDescription" />
      </Docs>
    </Member>
    <Member MemberName="OnShutdown">
      <MemberSignature Language="C#" Value="protected virtual void OnShutdown ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnShutdown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnShutdown" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnShutdown ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnShutdown();" />
      <MemberSignature Language="F#" Value="abstract member OnShutdown : unit -&gt; unit&#xA;override this.OnShutdown : unit -&gt; unit" Usage="serviceBase.OnShutdown " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Po zaimplementowaniu w klasie pochodnej wykonuje się, gdy system jest zamykany. Określa, co powinno następować bezpośrednio przed zamknięciem systemu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A> , aby określić przetwarzanie, które ma miejsce, gdy system zostanie zamknięty.  
  
 To zdarzenie występuje tylko wtedy, gdy system operacyjny jest wyłączony, a nie gdy komputer jest wyłączony.  
  
 <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A>powinien być przesłonięty, <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A> gdy właściwość jest. `true`  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnStart">
      <MemberSignature Language="C#" Value="protected virtual void OnStart (string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStart(string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStart (args As String())" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStart(cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member OnStart : string[] -&gt; unit&#xA;override this.OnStart : string[] -&gt; unit" Usage="serviceBase.OnStart args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="args">Dane przesłane przez polecenie uruchomienia.</param>
        <summary>Po zaimplementowaniu w klasie pochodnej jest wykonywane, gdy polecenie uruchamiania jest wysyłane do usługi przez menedżera kontroli usług (SCM) lub podczas uruchamiania systemu operacyjnego (w przypadku usługi, która jest uruchamiana automatycznie). Określa akcje, które należy wykonać, gdy usługa zostanie uruchomiona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.ServiceProcess.ServiceBase.OnStart%2A> , aby określić przetwarzanie, które ma miejsce, gdy usługa odbierze polecenie uruchomienia. <xref:System.ServiceProcess.ServiceBase.OnStart%2A>to metoda, w której należy określić zachowanie usługi. <xref:System.ServiceProcess.ServiceBase.OnStart%2A>może przyjmować argumenty jako sposób przekazywania danych, ale to użycie jest rzadkie.  
  
> [!CAUTION]
>  Nie używaj konstruktora do przeprowadzenia przetwarzania, które powinno znajdować <xref:System.ServiceProcess.ServiceBase.OnStart%2A>się w. Użyj <xref:System.ServiceProcess.ServiceBase.OnStart%2A> , aby obsłużyć wszystkie inicjalizacje usługi. Konstruktor jest wywoływany, gdy jest uruchamiany plik wykonywalny aplikacji, a nie w momencie uruchomienia usługi. Plik wykonywalny jest <xref:System.ServiceProcess.ServiceBase.OnStart%2A>uruchamiany przed. W przypadku kontynuowania, na przykład, Konstruktor nie jest wywoływany ponownie, ponieważ menedżer SCM już utrzymuje obiekt w pamięci. Jeśli <xref:System.ServiceProcess.ServiceBase.OnStop%2A> zwalnia zasoby przydzieloną w konstruktorze, a <xref:System.ServiceProcess.ServiceBase.OnStart%2A>nie w, wymagane zasoby nie zostaną utworzone ponownie podczas drugiego wywołania usługi.  
  
 Usługi można skonfigurować tak, aby uruchamiały się automatycznie po ponownym uruchomieniu komputera przez <xref:System.ServiceProcess.ServiceInstaller.StartType%2A> ustawienie ustawienia w <xref:System.ServiceProcess.ServiceStartMode.Automatic>instalatorze usługi na. W takiej sytuacji <xref:System.ServiceProcess.ServiceBase.OnStart%2A> jest wywoływana podczas uruchamiania systemu.  
  
 <xref:System.ServiceProcess.ServiceBase.OnStart%2A>powinien zostać przesłonięty w klasie pochodnej. Aby usługa była użyteczna <xref:System.ServiceProcess.ServiceBase.OnStart%2A> i <xref:System.ServiceProcess.ServiceBase.OnStop%2A> powinna być zaimplementowana w klasie usługi.  
  
 Argumenty inicjowania procesu dla usługi w metodzie <xref:System.ServiceProcess.ServiceBase.OnStart%2A> , a nie w metodzie Main. Argumenty w `args` tablicy parametrów można ustawić ręcznie w oknie właściwości dla usługi w konsoli usługi. Argumenty wprowadzone w konsoli nie są zapisywane; są one przenoszone do usługi w jeden raz, gdy usługa jest uruchamiana z poziomu panelu sterowania. Argumenty, które muszą być obecne, gdy usługa jest uruchamiana automatycznie, można umieścić w wartości ciągu ImagePath dla klucza rejestru usługi (HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\\*\<>* ). Argumenty można uzyskać z rejestru przy użyciu <xref:System.Environment.GetCommandLineArgs%2A> metody, na przykład:. `string[] imagePathArgs = Environment.GetCommandLineArgs();`  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnStop">
      <MemberSignature Language="C#" Value="protected virtual void OnStop ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnStop" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStop ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStop();" />
      <MemberSignature Language="F#" Value="abstract member OnStop : unit -&gt; unit&#xA;override this.OnStop : unit -&gt; unit" Usage="serviceBase.OnStop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Po zaimplementowaniu w klasie pochodnej jest wykonywane, gdy polecenie zatrzymania jest wysyłane do usługi przez menedżera kontroli usług (SCM). Określa akcje do wykonania, gdy usługa zostanie zatrzymana.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.ServiceProcess.ServiceBase.OnStop%2A> , aby określić przetwarzanie, które ma miejsce, gdy usługa odbierze polecenie zatrzymania.  
  
 Gdy menedżer SCM odbiera polecenie zatrzymania, używa wartości <xref:System.ServiceProcess.ServiceBase.CanStop%2A> , aby sprawdzić, czy usługa akceptuje polecenia zatrzymania. Jeśli <xref:System.ServiceProcess.ServiceBase.CanStop%2A> <xref:System.ServiceProcess.ServiceBase.OnStop%2A> jest `true`, polecenie zatrzymania jest przesyłane do usługi, a metoda jest wywoływana, jeśli jest zdefiniowana. Jeśli <xref:System.ServiceProcess.ServiceBase.OnStop%2A> usługa nie jest zaimplementowana w usłudze, menedżer SCM obsługuje polecenie zatrzymania.  
  
 Jeśli <xref:System.ServiceProcess.ServiceBase.CanStop%2A> ma`false`wartość, menedżer SCM ignoruje polecenie zatrzymania. Nie jest ona przenoszona do usługi. Polecenie zatrzymania zwraca i zgłasza wyjątek.  
  
 <xref:System.ServiceProcess.ServiceBase.OnStop%2A>powinien zostać przesłonięty w klasie pochodnej. Aby usługa była użyteczna <xref:System.ServiceProcess.ServiceBase.OnStart%2A> i <xref:System.ServiceProcess.ServiceBase.OnStop%2A> powinna być zaimplementowana w klasie usługi.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="RequestAdditionalTime">
      <MemberSignature Language="C#" Value="public void RequestAdditionalTime (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RequestAdditionalTime(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.RequestAdditionalTime(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RequestAdditionalTime (milliseconds As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RequestAdditionalTime(int milliseconds);" />
      <MemberSignature Language="F#" Value="member this.RequestAdditionalTime : int -&gt; unit" Usage="serviceBase.RequestAdditionalTime milliseconds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="milliseconds">Żądany czas w milisekundach.</param>
        <summary>Żąda dodatkowego czasu dla oczekującej operacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceProcess.ServiceBase.OnPause%2A> <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> <xref:System.ServiceProcess.ServiceBase.OnStop%2A> <xref:System.ServiceProcess.ServiceBase.OnStart%2A>Metoda jest przeznaczona do wywołania przez zastąpione metody,, lub, aby zażądać dodatkowego czasu dla oczekującej operacji, aby zapobiec oznaczeniu przez Menedżera sterowania usługami (SCM) <xref:System.ServiceProcess.ServiceBase.RequestAdditionalTime%2A> Usługa nie odpowiada.  Jeśli oczekująca operacja nie jest kontynuowana, Wstrzymaj, Uruchom lub Zatrzymaj, <xref:System.InvalidOperationException> zostanie zgłoszony.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Usługa nie jest w stanie oczekiwania.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Udostępnia główny punkt wejścia dla pliku wykonywalnego usługi.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.ServiceProcess.ServiceBase service);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.ServiceProcess.ServiceBase service) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (service As ServiceBase)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(System::ServiceProcess::ServiceBase ^ service);" />
      <MemberSignature Language="F#" Value="static member Run : System.ServiceProcess.ServiceBase -&gt; unit" Usage="System.ServiceProcess.ServiceBase.Run service" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="service" Type="System.ServiceProcess.ServiceBase" />
      </Parameters>
      <Docs>
        <param name="service">Wskazuje <see cref="T:System.ServiceProcess.ServiceBase" /> , że usługa ma zostać uruchomiona.</param>
        <summary>Rejestruje plik wykonywalny dla usługi przy użyciu Menedżera kontroli usług (SCM).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj to Przeciążenie w `main()` funkcji pliku wykonywalnego usługi, aby zarejestrować usługę za pomocą Menedżera kontroli usług. Po wywołaniu <xref:System.ServiceProcess.ServiceBase.Run%28System.ServiceProcess.ServiceBase%29>Menedżer sterowania usługami wystawia polecenie uruchomienia, które powoduje wywołanie <xref:System.ServiceProcess.ServiceBase.OnStart%2A> metody w usłudze. Usługa nie jest uruchomiona, dopóki nie zostanie wykonane polecenie uruchomienia.  
  
 Metoda jest wywoływana w taki sam sposób jak <xref:System.Windows.Forms.Application.Run%2A?displayProperty=nameWithType> w przypadku aplikacji Windows Forms. <xref:System.ServiceProcess.ServiceBase.Run%2A?displayProperty=nameWithType>  
  
 Jeśli <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> `service` jest `true`, wpis jest zapisywana w dzienniku zdarzeń, jeśli nie można uruchomić usługi określonej przez parametr.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="service" />jest <see langword="null" />.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.#ctor" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.ServiceProcess.ServiceBase[] services);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.ServiceProcess.ServiceBase[] services) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (services As ServiceBase())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(cli::array &lt;System::ServiceProcess::ServiceBase ^&gt; ^ services);" />
      <MemberSignature Language="F#" Value="static member Run : System.ServiceProcess.ServiceBase[] -&gt; unit" Usage="System.ServiceProcess.ServiceBase.Run services" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="services" Type="System.ServiceProcess.ServiceBase[]" />
      </Parameters>
      <Docs>
        <param name="services">Tablica wystąpień ServiceBase, która wskazuje usługi do uruchomienia.</param>
        <summary>Rejestruje plik wykonywalny dla wielu usług za pomocą Menedżera sterowania usługami (SCM).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj to Przeciążenie w `main()` funkcji pliku wykonywalnego usługi, aby zarejestrować usługi przy użyciu Menedżera kontroli usług. Po wywołaniu <xref:System.ServiceProcess.ServiceBase.Run%28System.ServiceProcess.ServiceBase%5B%5D%29>programu Menedżer sterowania usługami wystawia polecenia uruchomienia, które powodują wywoływanie <xref:System.ServiceProcess.ServiceBase.OnStart%2A> metod w usługach. Usługi nie są uruchamiane do momentu wykonania poleceń startowych.  
  
 Metoda jest wywoływana w podobny sposób <xref:System.Windows.Forms.Application.Run%2A?displayProperty=nameWithType> jak Metoda Windows Forms aplikacji. <xref:System.ServiceProcess.ServiceBase.Run%2A?displayProperty=nameWithType>  
  
 Jeśli <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> jest`true`, wpis jest zapisywana w dzienniku zdarzeń, jeśli nie można uruchomić żadnej usługi w tablicy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Nie podano usługi do uruchomienia. Tablica może być <see langword="null" /> lub pusta.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.#ctor" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="ServiceHandle">
      <MemberSignature Language="C#" Value="protected IntPtr ServiceHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ServiceHandle" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.ServiceHandle" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property ServiceHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property IntPtr ServiceHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.ServiceHandle : nativeint" Usage="System.ServiceProcess.ServiceBase.ServiceHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;dotnet-plat-ext-2.1;netcore-2.1;netcore-2.2;dotnet-plat-ext-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera uchwyt kontroli usługi dla usługi.</summary>
        <value><see cref="T:System.IntPtr" /> Struktura, która zawiera uchwyt kontroli usługi dla usługi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uchwyt kontroli usług służy do komunikowania się z menedżerem sterowania usługami (SCM).  Uchwyt może służyć do aktualizowania informacji o stanie Menedżera kontroli usług dla usługi wywołującej za pomocą funkcji niezarządzanej `SetServiceStatus` .  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">w celu uzyskania dostępu do kodu niezarządzanego. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ServiceMainCallback">
      <MemberSignature Language="C#" Value="public void ServiceMainCallback (int argCount, IntPtr argPointer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ServiceMainCallback(int32 argCount, native int argPointer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.ServiceMainCallback(System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ServiceMainCallback (argCount As Integer, argPointer As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ServiceMainCallback(int argCount, IntPtr argPointer);" />
      <MemberSignature Language="F#" Value="member this.ServiceMainCallback : int * nativeint -&gt; unit" Usage="serviceBase.ServiceMainCallback (argCount, argPointer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;dotnet-plat-ext-2.1;netcore-2.1;netcore-2.2;dotnet-plat-ext-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argCount" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="argPointer" Type="System.IntPtr" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="argCount">Liczba argumentów w tablicy argumentów.</param>
        <param name="argPointer"><see cref="T:System.IntPtr" /> Struktura, która wskazuje na tablicę argumentów.</param>
        <summary>Rejestruje procedurę obsługi poleceń i uruchamia usługę.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ServiceName">
      <MemberSignature Language="C#" Value="public string ServiceName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ServiceName" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.ServiceName" />
      <MemberSignature Language="VB.NET" Value="Public Property ServiceName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ServiceName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ServiceName : string with get, set" Usage="System.ServiceProcess.ServiceBase.ServiceName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ServiceProcess.ServiceProcessDescription("SBServiceName")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia krótką nazwę używaną do identyfikowania usługi w systemie.</summary>
        <value>Nazwa usługi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> Identyfikuje usługę dla menedżera kontroli usług. Wartość tej właściwości musi być taka sama jak nazwa zarejestrowana dla usługi we <xref:System.ServiceProcess.ServiceInstaller.ServiceName%2A?displayProperty=nameWithType> właściwości odpowiedniej klasy Instalatora. W kodzie <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> usługa jest zazwyczaj ustawiana `main()` w funkcji pliku wykonywalnego.  
  
 Jest również używany do <xref:System.Diagnostics.EventLog.Source%2A?displayProperty=nameWithType> określenia skojarzone z <xref:System.ServiceProcess.ServiceBase.EventLog%2A> właściwością. <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> Jest <xref:System.ServiceProcess.ServiceBase.EventLog%2A> to wystąpienie, które zapisuje informacje o poleceniu usługi w dzienniku aplikacji.  
  
 <xref:System.ServiceProcess.ServiceBase.ServiceName%2A>, Która dostarcza ciąg źródłowy dziennika zdarzeń, musi być ustawiona przed zapisem usługi do dziennika zdarzeń. Próba uzyskania dostępu do dziennika zdarzeń przed ustawieniem nazwy źródła powoduje zgłoszenie wyjątku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Usługa została już uruchomiona. Nie można zmienić właściwości po rozpoczęciu usługi. <see cref="P:System.ServiceProcess.ServiceBase.ServiceName" /></exception>
        <exception cref="T:System.ArgumentException">Określona nazwa jest ciągiem o zerowej długości lub jest dłuższa lub <see cref="F:System.ServiceProcess.ServiceBase.MaxNameLength" />większa niż lub określona nazwa zawiera ukośnik lub ukośnik odwrotny.</exception>
        <altmember cref="P:System.ServiceProcess.ServiceInstaller.ServiceName" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop();" />
      <MemberSignature Language="F#" Value="member this.Stop : unit -&gt; unit" Usage="serviceBase.Stop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Kończy usługę wykonywania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda ustawia stan usługi w taki sposób, aby wskazywał oczekiwanie na zatrzymanie i <xref:System.ServiceProcess.ServiceBase.OnStop%2A> wywołuje metodę. <xref:System.ServiceProcess.ServiceBase.Stop%2A>  Po zatrzymaniu aplikacji stan usługi jest ustawiony na zatrzymane. Jeśli aplikacja jest usługą hostowaną, domena aplikacji jest zwalniana.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
  </Members>
</Type>

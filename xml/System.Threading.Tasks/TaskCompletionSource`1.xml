<Type Name="TaskCompletionSource&lt;TResult&gt;" FullName="System.Threading.Tasks.TaskCompletionSource&lt;TResult&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="bc9b76ac45a3adba3b58c992af42343621829666" />
    <Meta Name="ms.sourcegitcommit" Value="9dda17222b9f7d3edf130133bfb1370d5b410a4b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="09/22/2018" />
    <Meta Name="ms.locfileid" Value="46605335" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class TaskCompletionSource&lt;TResult&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TaskCompletionSource`1&lt;TResult&gt; extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.TaskCompletionSource`1" />
  <TypeSignature Language="VB.NET" Value="Public Class TaskCompletionSource(Of TResult)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TResult&gt;&#xA;public ref class TaskCompletionSource" />
  <TypeSignature Language="F#" Value="type TaskCompletionSource&lt;'Result&gt; = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TResult" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <typeparam name="TResult">Typ assocatied wartość wyniku z tym <see cref="T:System.Threading.Tasks.TaskCompletionSource`1" />.</typeparam>
    <summary>Reprezentuje stronę producentów <see cref="T:System.Threading.Tasks.Task`1" /> niepowiązany z delegatem, zapewniając dostęp do strony klienta przez <see cref="P:System.Threading.Tasks.TaskCompletionSource`1.Task" /> właściwości.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W wielu scenariuszach, warto włączyć <xref:System.Threading.Tasks.Task%601> reprezentujący zewnętrzne operację asynchroniczną. <xref:System.Threading.Tasks.TaskCompletionSource%601> znajduje się w tym celu. Umożliwia utworzenie zadania, które można przekazać do klientów. Klienci mogą korzystać z elementów członkowskich zadania taki sam sposób tak samo jak w innym scenariuszu obsługi zmiennych składowych zadania. Jednak w przeciwieństwie do większości zadań, stan zadania utworzone przez TaskCompletionSource jest kontrolowana jawnie za pomocą metod na TaskCompletionSource. Dzięki temu zakończenia operacji asynchronicznej zewnętrzne są propagowane do zadania podstawowego. Oddzielenie gwarantuje również, że odbiorcy nie będą mogli przejście stanu bez dostępu do odpowiednich TaskCompletionSource. Aby uzyskać więcej informacji, zobacz wpis [charakter TaskCompletionSource\<TResult >](http://blogs.msdn.com/b/pfxteam/archive/2009/06/02/9685804.aspx) w Programowanie równoległe z bloga platformy .NET.  
  
 [Przykłady rozszerzenia równoległe](http://go.microsoft.com/fwlink/?LinkID=165717) również zawierają przykłady dotyczące używania <xref:System.Threading.Tasks.TaskCompletionSource%601>.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać <xref:System.Threading.Tasks.TaskCompletionSource%601>:  
  
 [!code-csharp[System.Threading.Tasks.TaskCompletionSource#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.taskcompletionsource/cs/taskcompletionsource.cs#01)]
 [!code-vb[System.Threading.Tasks.TaskCompletionSource#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.taskcompletionsource/vb/taskcompletionsource.vb#01)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Wszystkie elementy członkowskie <see cref="T:System.Threading.Tasks.TaskCompletionSource`1" /> są odporne na wątki i mogą być używane jednocześnie z wielu wątków.</threadsafe>
    <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Korzystanie z modelu TPL z innymi wzorami asynchronicznymi</related>
    <related type="Article" href="~/docs/standard/parallel-programming/how-to-wrap-eap-patterns-in-a-task.md">Porady: zawijanie wzorów EAP w zadanie</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Threading.Tasks.TaskCompletionSource`1" /> obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TaskCompletionSource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskCompletionSource`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TaskCompletionSource();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Tworzy <see cref="T:System.Threading.Tasks.TaskCompletionSource`1" />.</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Korzystanie z modelu TPL z innymi wzorami asynchronicznymi</related>
        <related type="Article" href="~/docs/standard/parallel-programming/how-to-wrap-eap-patterns-in-a-task.md">Porady: zawijanie wzorów EAP w zadanie</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TaskCompletionSource (object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskCompletionSource`1.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (state As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TaskCompletionSource(System::Object ^ state);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.TaskCompletionSource&lt;'Result&gt; : obj -&gt; System.Threading.Tasks.TaskCompletionSource&lt;'Result&gt;" Usage="new System.Threading.Tasks.TaskCompletionSource&lt;'Result&gt; state" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="state">Stan do użycia jako bazowego <see cref="T:System.Threading.Tasks.Task`1" />firmy AsyncState.</param>
        <summary>Tworzy <see cref="T:System.Threading.Tasks.TaskCompletionSource`1" /> z określonym stanem.</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Korzystanie z modelu TPL z innymi wzorami asynchronicznymi</related>
        <related type="Article" href="~/docs/standard/parallel-programming/how-to-wrap-eap-patterns-in-a-task.md">Porady: zawijanie wzorów EAP w zadanie</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TaskCompletionSource (System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskCompletionSource`1.#ctor(System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (creationOptions As TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TaskCompletionSource(System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.TaskCompletionSource&lt;'Result&gt; : System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.TaskCompletionSource&lt;'Result&gt;" Usage="new System.Threading.Tasks.TaskCompletionSource&lt;'Result&gt; creationOptions" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="creationOptions">Opcje do użycia podczas tworzenia podstawowych <see cref="T:System.Threading.Tasks.Task`1" />.</param>
        <summary>Tworzy <see cref="T:System.Threading.Tasks.TaskCompletionSource`1" /> z określonymi opcjami.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task%601> Utworzony przez to wystąpienie i dostępne za pośrednictwem jego <xref:System.Threading.Tasks.TaskCompletionSource%601.Task%2A> właściwość zostanie uruchomiony, przy użyciu określonego `creationOptions`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="creationOptions" /> Reprezentują opcje nieprawidłowa do użycia z usługą <see cref="T:System.Threading.Tasks.TaskCompletionSource`1" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Korzystanie z modelu TPL z innymi wzorami asynchronicznymi</related>
        <related type="Article" href="~/docs/standard/parallel-programming/how-to-wrap-eap-patterns-in-a-task.md">Porady: zawijanie wzorów EAP w zadanie</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TaskCompletionSource (object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskCompletionSource`1.#ctor(System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (state As Object, creationOptions As TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TaskCompletionSource(System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.TaskCompletionSource&lt;'Result&gt; : obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.TaskCompletionSource&lt;'Result&gt;" Usage="new System.Threading.Tasks.TaskCompletionSource&lt;'Result&gt; (state, creationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="state">Stan do użycia jako bazowego <see cref="T:System.Threading.Tasks.Task`1" />firmy AsyncState.</param>
        <param name="creationOptions">Opcje do użycia podczas tworzenia podstawowych <see cref="T:System.Threading.Tasks.Task`1" />.</param>
        <summary>Tworzy <see cref="T:System.Threading.Tasks.TaskCompletionSource`1" /> o określonym stanie i opcje.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="creationOptions" /> Reprezentują opcje nieprawidłowa do użycia z usługą <see cref="T:System.Threading.Tasks.TaskCompletionSource`1" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Korzystanie z modelu TPL z innymi wzorami asynchronicznymi</related>
        <related type="Article" href="~/docs/standard/parallel-programming/how-to-wrap-eap-patterns-in-a-task.md">Porady: zawijanie wzorów EAP w zadanie</related>
      </Docs>
    </Member>
    <Member MemberName="SetCanceled">
      <MemberSignature Language="C#" Value="public void SetCanceled ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCanceled() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskCompletionSource`1.SetCanceled" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCanceled ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCanceled();" />
      <MemberSignature Language="F#" Value="member this.SetCanceled : unit -&gt; unit" Usage="taskCompletionSource.SetCanceled " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zmienia podstawową <see cref="T:System.Threading.Tasks.Task`1" /> do <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" /> stanu.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Podstawowe <see cref="T:System.Threading.Tasks.Task`1" /> jest już w jednym z trzech stanów końcowe: <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" />, <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" />, lub <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" />, lub jeśli bazowego <see cref="T:System.Threading.Tasks.Task`1" /> został już usunięty.</exception>
        <altmember cref="M:System.Threading.Tasks.TaskCompletionSource`1.TrySetCanceled" />
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Korzystanie z modelu TPL z innymi wzorami asynchronicznymi</related>
        <related type="Article" href="~/docs/standard/parallel-programming/how-to-wrap-eap-patterns-in-a-task.md">Porady: zawijanie wzorów EAP w zadanie</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Anulowanie zadania</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetException">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zmienia podstawową <see cref="T:System.Threading.Tasks.Task`1" /> do obiektu <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> stanu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetException">
      <MemberSignature Language="C#" Value="public void SetException (System.Collections.Generic.IEnumerable&lt;Exception&gt; exceptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetException(class System.Collections.Generic.IEnumerable`1&lt;class System.Exception&gt; exceptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskCompletionSource`1.SetException(System.Collections.Generic.IEnumerable{System.Exception})" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetException (exceptions As IEnumerable(Of Exception))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetException(System::Collections::Generic::IEnumerable&lt;Exception ^&gt; ^ exceptions);" />
      <MemberSignature Language="F#" Value="member this.SetException : seq&lt;Exception&gt; -&gt; unit" Usage="taskCompletionSource.SetException exceptions" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exceptions" Type="System.Collections.Generic.IEnumerable&lt;System.Exception&gt;" />
      </Parameters>
      <Docs>
        <param name="exceptions">Zbieranie wyjątków, które chcesz powiązać to <see cref="T:System.Threading.Tasks.Task`1" />.</param>
        <summary>Zmienia podstawową <see cref="T:System.Threading.Tasks.Task`1" /> do <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> stanu i powiąże kolekcję obiektów wyjątków.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="P:System.Threading.Tasks.TaskCompletionSource`1.Task" /> Został usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="exceptions" /> Argument ma wartość null.</exception>
        <exception cref="T:System.ArgumentException">Istnieją co najmniej jeden element o wartości null w <paramref name="exceptions" />.</exception>
        <exception cref="T:System.InvalidOperationException">Podstawowe <see cref="T:System.Threading.Tasks.Task`1" /> jest już w jednym z trzech stanów końcowe: <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" />, <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" />, lub <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Korzystanie z modelu TPL z innymi wzorami asynchronicznymi</related>
        <related type="Article" href="~/docs/standard/parallel-programming/how-to-wrap-eap-patterns-in-a-task.md">Porady: zawijanie wzorów EAP w zadanie</related>
      </Docs>
    </Member>
    <Member MemberName="SetException">
      <MemberSignature Language="C#" Value="public void SetException (Exception exception);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetException(class System.Exception exception) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskCompletionSource`1.SetException(System.Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetException(Exception ^ exception);" />
      <MemberSignature Language="F#" Value="member this.SetException : Exception -&gt; unit" Usage="taskCompletionSource.SetException exception" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exception" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="exception">Wyjątek, aby powiązać to <see cref="T:System.Threading.Tasks.Task`1" />.</param>
        <summary>Zmienia podstawową <see cref="T:System.Threading.Tasks.Task`1" /> do <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> stanu i wiąże go z określonym wyjątkiem.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="P:System.Threading.Tasks.TaskCompletionSource`1.Task" /> Został usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="exception" /> Argument ma wartość null.</exception>
        <exception cref="T:System.InvalidOperationException">Podstawowe <see cref="T:System.Threading.Tasks.Task`1" /> jest już w jednym z trzech stanów końcowe: <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" />, <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" />, lub <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Korzystanie z modelu TPL z innymi wzorami asynchronicznymi</related>
        <related type="Article" href="~/docs/standard/parallel-programming/how-to-wrap-eap-patterns-in-a-task.md">Porady: zawijanie wzorów EAP w zadanie</related>
      </Docs>
    </Member>
    <Member MemberName="SetResult">
      <MemberSignature Language="C#" Value="public void SetResult (TResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetResult(!TResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskCompletionSource`1.SetResult(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetResult (result As TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetResult(TResult result);" />
      <MemberSignature Language="F#" Value="member this.SetResult : 'Result -&gt; unit" Usage="taskCompletionSource.SetResult result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="TResult" />
      </Parameters>
      <Docs>
        <param name="result">Wartość wyniku, który chcesz powiązać to <see cref="T:System.Threading.Tasks.Task`1" />.</param>
        <summary>Zmienia podstawową <see cref="T:System.Threading.Tasks.Task`1" /> do <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" /> stanu.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="P:System.Threading.Tasks.TaskCompletionSource`1.Task" /> Został usunięty.</exception>
        <exception cref="T:System.InvalidOperationException">Podstawowe <see cref="T:System.Threading.Tasks.Task`1" /> jest już w jednym z trzech stanów końcowe: <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" />, <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" />, lub <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Korzystanie z modelu TPL z innymi wzorami asynchronicznymi</related>
        <related type="Article" href="~/docs/standard/parallel-programming/how-to-wrap-eap-patterns-in-a-task.md">Porady: zawijanie wzorów EAP w zadanie</related>
      </Docs>
    </Member>
    <Member MemberName="Task">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; Task { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.Tasks.Task`1&lt;!TResult&gt; Task" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskCompletionSource`1.Task" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Task As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::Task&lt;TResult&gt; ^ Task { System::Threading::Tasks::Task&lt;TResult&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Task : System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.TaskCompletionSource&lt;'Result&gt;.Task" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Threading.Tasks.Task`1" /> utworzył <see cref="T:System.Threading.Tasks.TaskCompletionSource`1" />.</summary>
        <value>Zwraca <see cref="T:System.Threading.Tasks.Task`1" /> utworzył <see cref="T:System.Threading.Tasks.TaskCompletionSource`1" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość umożliwia konsumentowi dostępu <xref:System.Threading.Tasks.Task%601> , jest kontrolowane przez to wystąpienie. Po utworzeniu <xref:System.Threading.Tasks.TaskCompletionSource%601> obiektu <xref:System.Threading.Tasks.Task.Status%2A> właściwość to <xref:System.Threading.Tasks.Task%601> zwraca obiekt <xref:System.Threading.Tasks.TaskStatus.WaitingForActivation>  
  
 <xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetException%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetException%2A>, I <xref:System.Threading.Tasks.TaskCompletionSource%601.SetCanceled%2A> metod (i ich warianty "Try"), w tym wystąpienia wszystkich wynik na liście odpowiednimi stanami w tym podstawowe zadania.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Korzystanie z modelu TPL z innymi wzorami asynchronicznymi</related>
        <related type="Article" href="~/docs/standard/parallel-programming/how-to-wrap-eap-patterns-in-a-task.md">Porady: zawijanie wzorów EAP w zadanie</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">Programowanie asynchroniczne oparte na zadanie</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TrySetCanceled">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Podejmuje próbę przejścia bazowego <see cref="T:System.Threading.Tasks.Task`1" /> do <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" /> stanu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TrySetCanceled">
      <MemberSignature Language="C#" Value="public bool TrySetCanceled ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TrySetCanceled() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskCompletionSource`1.TrySetCanceled" />
      <MemberSignature Language="VB.NET" Value="Public Function TrySetCanceled () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TrySetCanceled();" />
      <MemberSignature Language="F#" Value="member this.TrySetCanceled : unit -&gt; bool" Usage="taskCompletionSource.TrySetCanceled " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Podejmuje próbę przejścia bazowego <see cref="T:System.Threading.Tasks.Task`1" /> do <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" /> stanu.</summary>
        <returns>Wartość true, jeśli operacja się powiodła. wartość false, jeśli operacja nie powiodła się albo ten obiekt został już usunięty.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta operacja zostanie zwrócona wartość FAŁSZ, jeśli <xref:System.Threading.Tasks.Task%601> jest już w jednym z trzech stanów końcowe: <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>, <xref:System.Threading.Tasks.TaskStatus.Faulted>, lub <xref:System.Threading.Tasks.TaskStatus.Canceled>.  
  
 Ta metoda również zwraca wartość false, jeśli podstawowa <xref:System.Threading.Tasks.Task%601> został już usunięty.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Korzystanie z modelu TPL z innymi wzorami asynchronicznymi</related>
        <related type="Article" href="~/docs/standard/parallel-programming/how-to-wrap-eap-patterns-in-a-task.md">Porady: zawijanie wzorów EAP w zadanie</related>
      </Docs>
    </Member>
    <Member MemberName="TrySetCanceled">
      <MemberSignature Language="C#" Value="public bool TrySetCanceled (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TrySetCanceled(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskCompletionSource`1.TrySetCanceled(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TrySetCanceled(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.TrySetCanceled : System.Threading.CancellationToken -&gt; bool" Usage="taskCompletionSource.TrySetCanceled cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">Token anulowania.</param>
        <summary>Podejmuje próbę przejścia bazowego <see cref="T:System.Threading.Tasks.Task`1" /> do <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" /> stanu i umożliwia token anulowania, który ma być przechowywany w anulowanych zadań.</summary>
        <returns>
          <see langword="true" /> Jeśli operacja się powiedzie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda zwraca wartość false, jeśli podstawowa <xref:System.Threading.Tasks.Task%601> obiekt jest już w jeden z następujących trzech stanów końcowej.  
  
-   <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType>  
  
-   <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=nameWithType>  
  
-   <xref:System.Threading.Tasks.TaskStatus.RanToCompletion?displayProperty=nameWithType>  
  
 Ta metoda zwraca też wartość `false` Jeśli bazowego <xref:System.Threading.Tasks.Task%601> obiekt został już usunięty.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TrySetException">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Podejmuje próbę przejścia bazowego <see cref="T:System.Threading.Tasks.Task`1" /> do obiektu <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> stanu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TrySetException">
      <MemberSignature Language="C#" Value="public bool TrySetException (System.Collections.Generic.IEnumerable&lt;Exception&gt; exceptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TrySetException(class System.Collections.Generic.IEnumerable`1&lt;class System.Exception&gt; exceptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskCompletionSource`1.TrySetException(System.Collections.Generic.IEnumerable{System.Exception})" />
      <MemberSignature Language="VB.NET" Value="Public Function TrySetException (exceptions As IEnumerable(Of Exception)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TrySetException(System::Collections::Generic::IEnumerable&lt;Exception ^&gt; ^ exceptions);" />
      <MemberSignature Language="F#" Value="member this.TrySetException : seq&lt;Exception&gt; -&gt; bool" Usage="taskCompletionSource.TrySetException exceptions" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exceptions" Type="System.Collections.Generic.IEnumerable&lt;System.Exception&gt;" />
      </Parameters>
      <Docs>
        <param name="exceptions">Zbieranie wyjątków, które chcesz powiązać to <see cref="T:System.Threading.Tasks.Task`1" />.</param>
        <summary>Podejmuje próbę przejścia bazowego <see cref="T:System.Threading.Tasks.Task`1" /> do <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> stanu i powiąże kolekcję obiektów wyjątków.</summary>
        <returns>Wartość true, jeśli operacja się powiodła. w przeciwnym razie wartość false.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta operacja zostanie zwrócona wartość FAŁSZ, jeśli <xref:System.Threading.Tasks.Task%601> jest już w jednym z trzech stanów końcowe: <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>, <xref:System.Threading.Tasks.TaskStatus.Faulted>, lub <xref:System.Threading.Tasks.TaskStatus.Canceled>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="P:System.Threading.Tasks.TaskCompletionSource`1.Task" /> Został usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="exceptions" /> Argument ma wartość null.</exception>
        <exception cref="T:System.ArgumentException">Istnieją co najmniej jeden element o wartości null w <paramref name="exceptions" />.  
  
—lub— 
<paramref name="exceptions" /> Kolekcja jest pusta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Korzystanie z modelu TPL z innymi wzorami asynchronicznymi</related>
        <related type="Article" href="~/docs/standard/parallel-programming/how-to-wrap-eap-patterns-in-a-task.md">Porady: zawijanie wzorów EAP w zadanie</related>
      </Docs>
    </Member>
    <Member MemberName="TrySetException">
      <MemberSignature Language="C#" Value="public bool TrySetException (Exception exception);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TrySetException(class System.Exception exception) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskCompletionSource`1.TrySetException(System.Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TrySetException(Exception ^ exception);" />
      <MemberSignature Language="F#" Value="member this.TrySetException : Exception -&gt; bool" Usage="taskCompletionSource.TrySetException exception" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exception" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="exception">Wyjątek, aby powiązać to <see cref="T:System.Threading.Tasks.Task`1" />.</param>
        <summary>Podejmuje próbę przejścia bazowego <see cref="T:System.Threading.Tasks.Task`1" /> do <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> stanu i wiąże go z określonym wyjątkiem.</summary>
        <returns>Wartość true, jeśli operacja się powiodła. w przeciwnym razie wartość false.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta operacja zostanie zwrócona wartość FAŁSZ, jeśli <xref:System.Threading.Tasks.Task%601> jest już w jednym z trzech stanów końcowe: <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>, <xref:System.Threading.Tasks.TaskStatus.Faulted>, lub <xref:System.Threading.Tasks.TaskStatus.Canceled>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="P:System.Threading.Tasks.TaskCompletionSource`1.Task" /> Został usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="exception" /> Argument ma wartość null.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Korzystanie z modelu TPL z innymi wzorami asynchronicznymi</related>
        <related type="Article" href="~/docs/standard/parallel-programming/how-to-wrap-eap-patterns-in-a-task.md">Porady: zawijanie wzorów EAP w zadanie</related>
      </Docs>
    </Member>
    <Member MemberName="TrySetResult">
      <MemberSignature Language="C#" Value="public bool TrySetResult (TResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TrySetResult(!TResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskCompletionSource`1.TrySetResult(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrySetResult (result As TResult) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TrySetResult(TResult result);" />
      <MemberSignature Language="F#" Value="member this.TrySetResult : 'Result -&gt; bool" Usage="taskCompletionSource.TrySetResult result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="TResult" />
      </Parameters>
      <Docs>
        <param name="result">Wartość wyniku, który chcesz powiązać to <see cref="T:System.Threading.Tasks.Task`1" />.</param>
        <summary>Podejmuje próbę przejścia bazowego <see cref="T:System.Threading.Tasks.Task`1" /> do <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" /> stanu.</summary>
        <returns>Wartość true, jeśli operacja się powiodła. w przeciwnym razie wartość false.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta operacja zostanie zwrócona wartość FAŁSZ, jeśli <xref:System.Threading.Tasks.Task%601> jest już w jednym z trzech stanów końcowe: <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>, <xref:System.Threading.Tasks.TaskStatus.Faulted>, lub <xref:System.Threading.Tasks.TaskStatus.Canceled>.  
  
 Ta metoda również zwraca wartość false, jeśli podstawowa <xref:System.Threading.Tasks.Task%601> został już usunięty.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Korzystanie z modelu TPL z innymi wzorami asynchronicznymi</related>
        <related type="Article" href="~/docs/standard/parallel-programming/how-to-wrap-eap-patterns-in-a-task.md">Porady: zawijanie wzorów EAP w zadanie</related>
      </Docs>
    </Member>
  </Members>
</Type>
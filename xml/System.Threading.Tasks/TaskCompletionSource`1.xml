<Type Name="TaskCompletionSource&lt;TResult&gt;" FullName="System.Threading.Tasks.TaskCompletionSource&lt;TResult&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="8b926954190b6d88f6d5bd63ec87ef9b0f2e61bb" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69229987" /></Metadata><TypeSignature Language="C#" Value="public class TaskCompletionSource&lt;TResult&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TaskCompletionSource`1&lt;TResult&gt; extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.TaskCompletionSource`1" />
  <TypeSignature Language="VB.NET" Value="Public Class TaskCompletionSource(Of TResult)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TResult&gt;&#xA;public ref class TaskCompletionSource" />
  <TypeSignature Language="F#" Value="type TaskCompletionSource&lt;'Result&gt; = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TResult" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <typeparam name="TResult">Typ wartości wyniku skojarzonej z tym <see cref="T:System.Threading.Tasks.TaskCompletionSource`1" />elementem.</typeparam>
    <summary>Reprezentuje stronę <see cref="T:System.Threading.Tasks.Task`1" /> producenta niepowiązanego z delegatem, zapewniając dostęp do niego po stronie klienta <see cref="P:System.Threading.Tasks.TaskCompletionSource`1.Task" /> za pomocą właściwości.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W wielu scenariuszach warto włączyć <xref:System.Threading.Tasks.Task%601> do reprezentowania zewnętrznej operacji asynchronicznej. <xref:System.Threading.Tasks.TaskCompletionSource%601>jest dostępny do tego celu. Umożliwia tworzenie zadań, które mogą być przekazywane do klientów. Odbiorcy mogą używać elementów członkowskich zadania w taki sam sposób jak w przypadku innych zmiennych składowych zadania obsługi scenariuszy. Jednak, w przeciwieństwie do większości zadań, stan zadania utworzonego przez TaskCompletionSource jest kontrolowany jawnie przez metody w TaskCompletionSource. Umożliwia to ukończenie zewnętrznej operacji asynchronicznej do propagowania do zadania bazowego. Oddzielenie gwarantuje także, że konsumenci nie mogą przejść do stanu bez dostępu do odpowiednich TaskCompletionSource. Aby uzyskać więcej informacji, zapoznaj się z wpisem [natura TaskCompletionSource\<TResult >](https://devblogs.microsoft.com/pfxteam/the-nature-of-taskcompletionsourcetresult/) w blogu programowanie równoległe przy użyciu platformy .NET.  
  
 Przykłady [rozszerzeń równoległych](https://go.microsoft.com/fwlink/?LinkID=165717) zawierają również przykłady użycia <xref:System.Threading.Tasks.TaskCompletionSource%601>.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.Threading.Tasks.TaskCompletionSource%601>jak używać:  
  
 [!code-csharp[System.Threading.Tasks.TaskCompletionSource#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.taskcompletionsource/cs/taskcompletionsource.cs#01)]
 [!code-vb[System.Threading.Tasks.TaskCompletionSource#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.taskcompletionsource/vb/taskcompletionsource.vb#01)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Wszystkie elementy członkowskie <see cref="T:System.Threading.Tasks.TaskCompletionSource`1" /> są bezpieczne dla wątków i mogą być używane jednocześnie z wielu wątków.</threadsafe>
    <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Korzystanie z modelu TPL z innymi wzorami asynchronicznymi</related>
    <related type="Article" href="~/docs/standard/parallel-programming/how-to-wrap-eap-patterns-in-a-task.md">Instrukcje: Opakowywanie wzorców EAP w zadaniu</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Threading.Tasks.TaskCompletionSource`1" /> Tworzy obiekt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TaskCompletionSource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskCompletionSource`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TaskCompletionSource();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Threading.Tasks.TaskCompletionSource`1" />Tworzy.</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Korzystanie z modelu TPL z innymi wzorami asynchronicznymi</related>
        <related type="Article" href="~/docs/standard/parallel-programming/how-to-wrap-eap-patterns-in-a-task.md">Instrukcje: Opakowywanie wzorców EAP w zadaniu</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TaskCompletionSource (object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskCompletionSource`1.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (state As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TaskCompletionSource(System::Object ^ state);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.TaskCompletionSource&lt;'Result&gt; : obj -&gt; System.Threading.Tasks.TaskCompletionSource&lt;'Result&gt;" Usage="new System.Threading.Tasks.TaskCompletionSource&lt;'Result&gt; state" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="state">Stan, który ma być używany jako <see cref="T:System.Threading.Tasks.Task`1" />AsyncState podstawowy.</param>
        <summary><see cref="T:System.Threading.Tasks.TaskCompletionSource`1" /> Tworzy z określonym stanem.</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Korzystanie z modelu TPL z innymi wzorami asynchronicznymi</related>
        <related type="Article" href="~/docs/standard/parallel-programming/how-to-wrap-eap-patterns-in-a-task.md">Instrukcje: Opakowywanie wzorców EAP w zadaniu</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TaskCompletionSource (System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskCompletionSource`1.#ctor(System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (creationOptions As TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TaskCompletionSource(System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.TaskCompletionSource&lt;'Result&gt; : System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.TaskCompletionSource&lt;'Result&gt;" Usage="new System.Threading.Tasks.TaskCompletionSource&lt;'Result&gt; creationOptions" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="creationOptions">Opcje, które mają być używane podczas tworzenia <see cref="T:System.Threading.Tasks.Task`1" />źródłowej.</param>
        <summary><see cref="T:System.Threading.Tasks.TaskCompletionSource`1" /> Tworzy przy użyciu określonych opcji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utworzone przez to wystąpienie i dostępne za pośrednictwem <xref:System.Threading.Tasks.TaskCompletionSource%601.Task%2A> jego właściwości zostanie utworzone przy użyciu określonego `creationOptions`elementu. <xref:System.Threading.Tasks.Task%601>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Opcje <paramref name="creationOptions" /> reprezentowania są nieprawidłowe do użycia <see cref="T:System.Threading.Tasks.TaskCompletionSource`1" />z.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Korzystanie z modelu TPL z innymi wzorami asynchronicznymi</related>
        <related type="Article" href="~/docs/standard/parallel-programming/how-to-wrap-eap-patterns-in-a-task.md">Instrukcje: Opakowywanie wzorców EAP w zadaniu</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TaskCompletionSource (object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskCompletionSource`1.#ctor(System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (state As Object, creationOptions As TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TaskCompletionSource(System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.TaskCompletionSource&lt;'Result&gt; : obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.TaskCompletionSource&lt;'Result&gt;" Usage="new System.Threading.Tasks.TaskCompletionSource&lt;'Result&gt; (state, creationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="state">Stan, który ma być używany jako <see cref="T:System.Threading.Tasks.Task`1" />AsyncState podstawowy.</param>
        <param name="creationOptions">Opcje, które mają być używane podczas tworzenia <see cref="T:System.Threading.Tasks.Task`1" />źródłowej.</param>
        <summary><see cref="T:System.Threading.Tasks.TaskCompletionSource`1" /> Tworzy przy użyciu określonego stanu i opcji.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Opcje <paramref name="creationOptions" /> reprezentowania są nieprawidłowe do użycia <see cref="T:System.Threading.Tasks.TaskCompletionSource`1" />z.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Korzystanie z modelu TPL z innymi wzorami asynchronicznymi</related>
        <related type="Article" href="~/docs/standard/parallel-programming/how-to-wrap-eap-patterns-in-a-task.md">Instrukcje: Opakowywanie wzorców EAP w zadaniu</related>
      </Docs>
    </Member>
    <Member MemberName="SetCanceled">
      <MemberSignature Language="C#" Value="public void SetCanceled ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCanceled() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskCompletionSource`1.SetCanceled" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCanceled ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCanceled();" />
      <MemberSignature Language="F#" Value="member this.SetCanceled : unit -&gt; unit" Usage="taskCompletionSource.SetCanceled " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Przechodzi do <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" /> stanu <see cref="T:System.Threading.Tasks.Task`1" /> źródłowego.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Bazowa <see cref="T:System.Threading.Tasks.Task`1" /> jest już w jednym z trzech stanów końcowych: <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" />, <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" />, lub <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" />, lub jeśli bazowy <see cref="T:System.Threading.Tasks.Task`1" /> został już usunięty.</exception>
        <altmember cref="M:System.Threading.Tasks.TaskCompletionSource`1.TrySetCanceled" />
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Korzystanie z modelu TPL z innymi wzorami asynchronicznymi</related>
        <related type="Article" href="~/docs/standard/parallel-programming/how-to-wrap-eap-patterns-in-a-task.md">Instrukcje: Opakowywanie wzorców EAP w zadaniu</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Anulowanie zadania</related>
        <exception cref="T:System.ObjectDisposedException"><see cref="P:System.Threading.Tasks.TaskCompletionSource`1.Task" /> Został usunięty.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetException">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Przechodzi do <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> stanu <see cref="T:System.Threading.Tasks.Task`1" /> obiektu źródłowego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetException">
      <MemberSignature Language="C#" Value="public void SetException (System.Collections.Generic.IEnumerable&lt;Exception&gt; exceptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetException(class System.Collections.Generic.IEnumerable`1&lt;class System.Exception&gt; exceptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskCompletionSource`1.SetException(System.Collections.Generic.IEnumerable{System.Exception})" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetException (exceptions As IEnumerable(Of Exception))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetException(System::Collections::Generic::IEnumerable&lt;Exception ^&gt; ^ exceptions);" />
      <MemberSignature Language="F#" Value="member this.SetException : seq&lt;Exception&gt; -&gt; unit" Usage="taskCompletionSource.SetException exceptions" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exceptions" Type="System.Collections.Generic.IEnumerable&lt;System.Exception&gt;" />
      </Parameters>
      <Docs>
        <param name="exceptions">Kolekcja wyjątków do powiązania <see cref="T:System.Threading.Tasks.Task`1" />.</param>
        <summary><see cref="T:System.Threading.Tasks.Task`1" /> Przechodzidostanuiwiążesięz<see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> kolekcją obiektów wyjątków.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="P:System.Threading.Tasks.TaskCompletionSource`1.Task" /> Został usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">Argument ma wartość <see langword="null" />. <paramref name="exceptions" /></exception>
        <exception cref="T:System.ArgumentException">W elemencie istnieje co najmniej jeden element o <paramref name="exceptions" />wartości null.</exception>
        <exception cref="T:System.InvalidOperationException">Bazowa <see cref="T:System.Threading.Tasks.Task`1" /> jest już w jednym z trzech stanów końcowych: <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" />, <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" />, lub <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Korzystanie z modelu TPL z innymi wzorami asynchronicznymi</related>
        <related type="Article" href="~/docs/standard/parallel-programming/how-to-wrap-eap-patterns-in-a-task.md">Instrukcje: Opakowywanie wzorców EAP w zadaniu</related>
      </Docs>
    </Member>
    <Member MemberName="SetException">
      <MemberSignature Language="C#" Value="public void SetException (Exception exception);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetException(class System.Exception exception) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskCompletionSource`1.SetException(System.Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetException(Exception ^ exception);" />
      <MemberSignature Language="F#" Value="member this.SetException : Exception -&gt; unit" Usage="taskCompletionSource.SetException exception" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exception" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="exception">Wyjątek, który należy powiązać z <see cref="T:System.Threading.Tasks.Task`1" />tym.</param>
        <summary>Przechodzi do <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> stanu <see cref="T:System.Threading.Tasks.Task`1" /> źródłowego i wiąże go z określonym wyjątkem.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="P:System.Threading.Tasks.TaskCompletionSource`1.Task" /> Został usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">Argument ma wartość <see langword="null" />. <paramref name="exception" /></exception>
        <exception cref="T:System.InvalidOperationException">Bazowa <see cref="T:System.Threading.Tasks.Task`1" /> jest już w jednym z trzech stanów końcowych: <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" />, <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" />, lub <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Korzystanie z modelu TPL z innymi wzorami asynchronicznymi</related>
        <related type="Article" href="~/docs/standard/parallel-programming/how-to-wrap-eap-patterns-in-a-task.md">Instrukcje: Opakowywanie wzorców EAP w zadaniu</related>
      </Docs>
    </Member>
    <Member MemberName="SetResult">
      <MemberSignature Language="C#" Value="public void SetResult (TResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetResult(!TResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskCompletionSource`1.SetResult(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetResult (result As TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetResult(TResult result);" />
      <MemberSignature Language="F#" Value="member this.SetResult : 'Result -&gt; unit" Usage="taskCompletionSource.SetResult result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="TResult" />
      </Parameters>
      <Docs>
        <param name="result">Wartość wynikowa, z którą ma <see cref="T:System.Threading.Tasks.Task`1" />zostać utworzone powiązanie.</param>
        <summary>Przechodzi do <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" /> stanu <see cref="T:System.Threading.Tasks.Task`1" /> źródłowego.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="P:System.Threading.Tasks.TaskCompletionSource`1.Task" /> Został usunięty.</exception>
        <exception cref="T:System.InvalidOperationException">Bazowa <see cref="T:System.Threading.Tasks.Task`1" /> jest już w jednym z trzech stanów końcowych: <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" />, <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" />, lub <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Korzystanie z modelu TPL z innymi wzorami asynchronicznymi</related>
        <related type="Article" href="~/docs/standard/parallel-programming/how-to-wrap-eap-patterns-in-a-task.md">Instrukcje: Opakowywanie wzorców EAP w zadaniu</related>
      </Docs>
    </Member>
    <Member MemberName="Task">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; Task { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.Tasks.Task`1&lt;!TResult&gt; Task" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskCompletionSource`1.Task" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Task As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::Task&lt;TResult&gt; ^ Task { System::Threading::Tasks::Task&lt;TResult&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Task : System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.TaskCompletionSource&lt;'Result&gt;.Task" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość <see cref="T:System.Threading.Tasks.Task`1" /> utworzoną <see cref="T:System.Threading.Tasks.TaskCompletionSource`1" />przez.</summary>
        <value>Zwraca wartość <see cref="T:System.Threading.Tasks.TaskCompletionSource`1" />utworzoną przez. <see cref="T:System.Threading.Tasks.Task`1" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość umożliwia konsumentowi dostęp do programu <xref:System.Threading.Tasks.Task%601> , który jest kontrolowany przez to wystąpienie. Podczas tworzenia <xref:System.Threading.Tasks.TaskCompletionSource%601> obiektu <xref:System.Threading.Tasks.Task.Status%2A> Właściwość tego <xref:System.Threading.Tasks.Task%601> obiektu zwraca<xref:System.Threading.Tasks.TaskStatus.WaitingForActivation>  
  
 Metody <xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetException%2A>, ,<xref:System.Threading.Tasks.TaskCompletionSource%601.SetException%2A> i<xref:System.Threading.Tasks.TaskCompletionSource%601.SetCanceled%2A> (i ich "try") dla tego wystąpienia powodują, że wszystkie zmiany stanu tego zadania bazowego są odpowiednie.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Korzystanie z modelu TPL z innymi wzorami asynchronicznymi</related>
        <related type="Article" href="~/docs/standard/parallel-programming/how-to-wrap-eap-patterns-in-a-task.md">Instrukcje: Opakowywanie wzorców EAP w zadaniu</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">Programowanie asynchroniczne oparte na zadaniach</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TrySetCanceled">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Podejmuje próbę przejścia <see cref="T:System.Threading.Tasks.Task`1" /> podstawowego <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" /> do stanu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TrySetCanceled">
      <MemberSignature Language="C#" Value="public bool TrySetCanceled ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TrySetCanceled() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskCompletionSource`1.TrySetCanceled" />
      <MemberSignature Language="VB.NET" Value="Public Function TrySetCanceled () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TrySetCanceled();" />
      <MemberSignature Language="F#" Value="member this.TrySetCanceled : unit -&gt; bool" Usage="taskCompletionSource.TrySetCanceled " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Podejmuje próbę przejścia <see cref="T:System.Threading.Tasks.Task`1" /> podstawowego <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" /> do stanu.</summary>
        <returns>Ma wartość true, jeśli operacja zakończyła się pomyślnie. wartość false, jeśli operacja zakończyła się niepowodzeniem lub obiekt został już usunięty.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta operacja zwróci wartość false, jeśli <xref:System.Threading.Tasks.Task%601> jest już w jednym z trzech stanów końcowych <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>: <xref:System.Threading.Tasks.TaskStatus.Faulted>,, <xref:System.Threading.Tasks.TaskStatus.Canceled>lub.  
  
 Ta metoda również zwraca wartość false, jeśli <xref:System.Threading.Tasks.Task%601> bazowy został już usunięty.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Korzystanie z modelu TPL z innymi wzorami asynchronicznymi</related>
        <related type="Article" href="~/docs/standard/parallel-programming/how-to-wrap-eap-patterns-in-a-task.md">Instrukcje: Opakowywanie wzorców EAP w zadaniu</related>
        <exception cref="T:System.ObjectDisposedException"><see cref="P:System.Threading.Tasks.TaskCompletionSource`1.Task" /> Został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="TrySetCanceled">
      <MemberSignature Language="C#" Value="public bool TrySetCanceled (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TrySetCanceled(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskCompletionSource`1.TrySetCanceled(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TrySetCanceled(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.TrySetCanceled : System.Threading.CancellationToken -&gt; bool" Usage="taskCompletionSource.TrySetCanceled cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">Token anulowania.</param>
        <summary>Próbuje przejść do <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" /> stanu <see cref="T:System.Threading.Tasks.Task`1" /> źródłowego i umożliwia zapisanie tokenu anulowania w anulowanym zadaniu.</summary>
        <returns><see langword="true" />Jeśli operacja się powiedzie; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda zwraca wartość false, jeśli obiekt <xref:System.Threading.Tasks.Task%601> źródłowy jest już w jednym z trzech następujących stanów końcowych.  
  
-   <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType>  
  
-   <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=nameWithType>  
  
-   <xref:System.Threading.Tasks.TaskStatus.RanToCompletion?displayProperty=nameWithType>  
  
 Ta metoda zwraca `false` również jeśli obiekt źródłowy <xref:System.Threading.Tasks.Task%601> został już usunięty.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TrySetException">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Próbuje przenieść obiekt źródłowy <see cref="T:System.Threading.Tasks.Task`1" /> <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> do stanu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TrySetException">
      <MemberSignature Language="C#" Value="public bool TrySetException (System.Collections.Generic.IEnumerable&lt;Exception&gt; exceptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TrySetException(class System.Collections.Generic.IEnumerable`1&lt;class System.Exception&gt; exceptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskCompletionSource`1.TrySetException(System.Collections.Generic.IEnumerable{System.Exception})" />
      <MemberSignature Language="VB.NET" Value="Public Function TrySetException (exceptions As IEnumerable(Of Exception)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TrySetException(System::Collections::Generic::IEnumerable&lt;Exception ^&gt; ^ exceptions);" />
      <MemberSignature Language="F#" Value="member this.TrySetException : seq&lt;Exception&gt; -&gt; bool" Usage="taskCompletionSource.TrySetException exceptions" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exceptions" Type="System.Collections.Generic.IEnumerable&lt;System.Exception&gt;" />
      </Parameters>
      <Docs>
        <param name="exceptions">Kolekcja wyjątków do powiązania <see cref="T:System.Threading.Tasks.Task`1" />.</param>
        <summary>Próbuje przejść do <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> stanu <see cref="T:System.Threading.Tasks.Task`1" /> źródłowego i tworzy powiązanie kolekcji obiektów wyjątków.</summary>
        <returns>Ma wartość true, jeśli operacja zakończyła się pomyślnie. w przeciwnym razie false.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta operacja zwróci wartość false, jeśli <xref:System.Threading.Tasks.Task%601> jest już w jednym z trzech stanów końcowych <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>: <xref:System.Threading.Tasks.TaskStatus.Faulted>,, <xref:System.Threading.Tasks.TaskStatus.Canceled>lub.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="P:System.Threading.Tasks.TaskCompletionSource`1.Task" /> Został usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">Argument ma wartość <see langword="null" />. <paramref name="exceptions" /></exception>
        <exception cref="T:System.ArgumentException">W elemencie istnieje co najmniej jeden element o <paramref name="exceptions" />wartości null.  
  
—lub— 
<paramref name="exceptions" /> Kolekcja jest pusta.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Korzystanie z modelu TPL z innymi wzorami asynchronicznymi</related>
        <related type="Article" href="~/docs/standard/parallel-programming/how-to-wrap-eap-patterns-in-a-task.md">Instrukcje: Opakowywanie wzorców EAP w zadaniu</related>
      </Docs>
    </Member>
    <Member MemberName="TrySetException">
      <MemberSignature Language="C#" Value="public bool TrySetException (Exception exception);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TrySetException(class System.Exception exception) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskCompletionSource`1.TrySetException(System.Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TrySetException(Exception ^ exception);" />
      <MemberSignature Language="F#" Value="member this.TrySetException : Exception -&gt; bool" Usage="taskCompletionSource.TrySetException exception" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exception" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="exception">Wyjątek, który należy powiązać z <see cref="T:System.Threading.Tasks.Task`1" />tym.</param>
        <summary>Próbuje przejść do <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> stanu <see cref="T:System.Threading.Tasks.Task`1" /> źródłowego i powiązać go z określonym wyjątkem.</summary>
        <returns>Ma wartość true, jeśli operacja zakończyła się pomyślnie. w przeciwnym razie false.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta operacja zwróci wartość false, jeśli <xref:System.Threading.Tasks.Task%601> jest już w jednym z trzech stanów końcowych <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>: <xref:System.Threading.Tasks.TaskStatus.Faulted>,, <xref:System.Threading.Tasks.TaskStatus.Canceled>lub.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="P:System.Threading.Tasks.TaskCompletionSource`1.Task" /> Został usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">Argument ma wartość <see langword="null" />. <paramref name="exception" /></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Korzystanie z modelu TPL z innymi wzorami asynchronicznymi</related>
        <related type="Article" href="~/docs/standard/parallel-programming/how-to-wrap-eap-patterns-in-a-task.md">Instrukcje: Opakowywanie wzorców EAP w zadaniu</related>
      </Docs>
    </Member>
    <Member MemberName="TrySetResult">
      <MemberSignature Language="C#" Value="public bool TrySetResult (TResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TrySetResult(!TResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskCompletionSource`1.TrySetResult(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrySetResult (result As TResult) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TrySetResult(TResult result);" />
      <MemberSignature Language="F#" Value="member this.TrySetResult : 'Result -&gt; bool" Usage="taskCompletionSource.TrySetResult result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="TResult" />
      </Parameters>
      <Docs>
        <param name="result">Wartość wynikowa, z którą ma <see cref="T:System.Threading.Tasks.Task`1" />zostać utworzone powiązanie.</param>
        <summary>Podejmuje próbę przejścia <see cref="T:System.Threading.Tasks.Task`1" /> podstawowego <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" /> do stanu.</summary>
        <returns>Ma wartość true, jeśli operacja zakończyła się pomyślnie. w przeciwnym razie false.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta operacja zwróci wartość false, jeśli <xref:System.Threading.Tasks.Task%601> jest już w jednym z trzech stanów końcowych <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>: <xref:System.Threading.Tasks.TaskStatus.Faulted>,, <xref:System.Threading.Tasks.TaskStatus.Canceled>lub.  
  
 Ta metoda również zwraca wartość false, jeśli <xref:System.Threading.Tasks.Task%601> bazowy został już usunięty.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md">Korzystanie z modelu TPL z innymi wzorami asynchronicznymi</related>
        <related type="Article" href="~/docs/standard/parallel-programming/how-to-wrap-eap-patterns-in-a-task.md">Instrukcje: Opakowywanie wzorców EAP w zadaniu</related>
        <exception cref="T:System.ObjectDisposedException"><see cref="P:System.Threading.Tasks.TaskCompletionSource`1.Task" /> Został usunięty.</exception>
      </Docs>
    </Member>
  </Members>
</Type>

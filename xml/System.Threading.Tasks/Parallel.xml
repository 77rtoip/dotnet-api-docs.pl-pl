<Type Name="Parallel" FullName="System.Threading.Tasks.Parallel">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="5cecfa2ccfb0c078816afadda63313ffb6ac73cf" />
    <Meta Name="ms.sourcegitcommit" Value="01f28caab7b3f23878dd07b402a8dd48b9478c8c" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="07/19/2018" />
    <Meta Name="ms.locfileid" Value="39140722" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Parallel" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Parallel extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.Parallel" />
  <TypeSignature Language="VB.NET" Value="Public Class Parallel" />
  <TypeSignature Language="C++ CLI" Value="public ref class Parallel abstract sealed" />
  <TypeSignature Language="F#" Value="type Parallel = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Zapewnia obsługę równoległych pętli i regionach.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Parallel> Klasa udostępnia danych oparty na bibliotece równoległych elementy zastępcze typowych operacji takich jak pętle, dla każdej pętli i wykonanie zestawu instrukcji.  
  
   
  
## Examples  
 Ten przykład demonstruje różne podejścia do implementowania pętlę równoległą przy użyciu wielu konstrukcji językowych.  
  
 [!code-csharp[System.Threading.Tasks.Parallel#07](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelintro.cs#07)]
 [!code-vb[System.Threading.Tasks.Parallel#07](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelintro.vb#07)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Wszystkie publiczne i chronione elementy członkowskie <see cref="T:System.Threading.Tasks.Parallel" /> są odporne na wątki i mogą być używane jednocześnie z wielu wątków.</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName="For">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wykonuje <see langword="for" /> (<see langword="For" /> w języku Visual Basic) pętli, w którym iteracje mogą być wykonywane równolegle.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, Action&lt;int,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Action`2&lt;int32, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Action{System.Int32,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Integer, toExclusive As Integer, body As Action(Of Integer, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, Action&lt;int, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * Action&lt;int, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Indeks początkowy, włącznie.</param>
        <param name="toExclusive">Końcowy indeks, wyłączności.</param>
        <param name="body">Delegat, który jest wywoływana jeden raz na iterację.</param>
        <summary>Wykonuje <see langword="for" /> (<see langword="For" /> w języku Visual Basic) pętli, w którym iteracje mogą być wykonywane równolegle i stan pętli dało się monitorować i manipulować.</summary>
        <returns>Struktura, która zawiera informacje o część pętli ukończone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body` Obiekt delegowany jest wywoływany raz dla każdej wartości w zakresie iteracji (`fromInclusive`, `toExclusive`). Znajduje się w przypadku dwóch argumentów:  
  
-   <xref:System.Int32> Wartość, która reprezentuje liczbę iteracji.  
  
-   A <xref:System.Threading.Tasks.ParallelLoopState> wystąpienie, które można zerwać pętlę przedwcześnie. <xref:System.Threading.Tasks.ParallelLoopState> Obiekt zostanie utworzony przez kompilator; nie można utworzyć wystąpienia w kodzie użytkownika.  
  
 Wywoływanie <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> informuje metoda `for` operacji, która iteracji po bieżącym nie trzeba wykonać. Wszystkie iteracje przed bieżącą jeden będzie nadal jednak do wykonania, jeśli jeszcze tego nie.  
  
 Dlatego wywołanie <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> jest podobne do operacji podziału, w ramach konwencjonalnej `for` , takich jak pętli w języku C#, ale nie jest doskonały zastępuje: na przykład, nie ma żadnej gwarancji, że iteracji po bieżącym zdecydowanie nie będzie wykonywanie.  
  
 Jeśli wykonanie wszystkich iteracji, przed bieżącym nie jest konieczne, należy użyć <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> metody zamiast <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>. Wywoływanie <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> informuje `for` pętli, może to porzucić wszystkie pozostałe iteracji, niezależnie od tego, czy są one przed lub po bieżącej iteracji, ponieważ wszystkie wymagane pracy będzie już zakończone. Jednak, tak jak przy użyciu <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>, nie ma żadnej gwarancji odnośnie do których nie zostanie wykonany innych iteracji.  
  
 Jeśli pętla jest zakończona przedwcześnie, <xref:System.Threading.Tasks.ParallelLoopResult> strukturę, która jest zwracana będzie zawierać informacje dotyczące zakończenia pętli.  
  
 Jeśli `fromInclusive` jest większa niż lub równa `toExclusive`, metoda zwraca natychmiast bez przeprowadzania żadnych iteracji.  
  
   
  
## Examples  
 Poniższy przykład wykonuje maksymalnie 100 iteracji pętli równolegle. Każda iteracja zatrzymuje się na losowo wybranym interwałem z zakresu od 1 do 1000 milisekund. Określa losowo wygenerowaną wartość, na które iteracji pętli <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> metoda jest wywoływana. Jak wynika z przykładzie nie iteracji, w której indeks jest większy niż <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A?displayProperty=nameWithType> początek wartości właściwości po wywołaniu <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> metody.  
  
 [!code-csharp[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/cs/break1.cs#2)]
 [!code-vb[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/vb/break1.vb#2)]  
  
 Ponieważ iteracje pętli będzie prawdopodobnie nadal wykonywać kiedy <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> metoda jest wywoływana, wywołania każdej iteracji <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A?displayProperty=nameWithType> właściwość do sprawdzenia, czy innej iteracji została wywołana <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> metody. Jeśli wartość właściwości jest `true`, iteracji sprawdza wartość <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A?displayProperty=nameWithType> właściwości i, jeśli jest większa niż wartość indeksu bieżącej iteracji, zwraca natychmiast.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="body" /> Argument jest <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątki generowane we wszystkich wątkach.</exception>
        <altmember cref="T:System.Threading.Tasks.ParallelLoopState" />
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, Action&lt;int&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Action`1&lt;int32&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Action{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Integer, toExclusive As Integer, body As Action(Of Integer)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, Action&lt;int&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * Action&lt;int&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Indeks początkowy, włącznie.</param>
        <param name="toExclusive">Końcowy indeks, wyłączności.</param>
        <param name="body">Delegat, który jest wywoływana jeden raz na iterację.</param>
        <summary>Wykonuje <see langword="for" /> (<see langword="For" /> w języku Visual Basic) pętli, w którym iteracje mogą być wykonywane równolegle.</summary>
        <returns>Struktura, która zawiera informacje o część pętli ukończone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body` Obiekt delegowany jest wywoływany raz dla każdej wartości w zakresie iteracji (`fromInclusive`, `toExclusive`). Jest ona udostępniana z liczbą iteracji (<xref:System.Int32>) jako parametr.  
  
 Jeśli `fromInclusive` jest większa niż lub równa `toExclusive`, metoda zwraca natychmiast bez przeprowadzania żadnych iteracji.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Threading.Tasks.Parallel.For%2A> metodę 100 wywołania delegata, która generuje losowe bajt wartości i oblicza ich suma.  
  
 [!code-csharp[System.Threading.Tasks.Parallel.For#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel.for/cs/for1.cs#1)]
 [!code-vb[System.Threading.Tasks.Parallel.For#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel.for/vb/for1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="body" /> Argument jest <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątki generowane we wszystkich wątkach.</exception>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, Action&lt;long,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Action`2&lt;int64, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Action{System.Int64,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Long, toExclusive As Long, body As Action(Of Long, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, Action&lt;long, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * Action&lt;int64, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Indeks początkowy, włącznie.</param>
        <param name="toExclusive">Końcowy indeks, wyłączności.</param>
        <param name="body">Delegat, który jest wywoływana jeden raz na iterację.</param>
        <summary>Wykonuje <see langword="for" /> (<see langword="For" /> w języku Visual Basic) pętli z indeksami 64-bitowe, w których iteracje mogą być wykonywane równolegle i stan pętli dało się monitorować i manipulować.</summary>
        <returns>A <see cref="T:System.Threading.Tasks.ParallelLoopResult" /> strukturę, która zawiera informacje na temat jaka część pętli ukończone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body` Obiekt delegowany jest wywoływany raz dla każdej wartości w zakresie iteracji (`fromInclusive`, `toExclusive`). Jest ona udostępniana z następującymi parametrami: liczba iteracji (<xref:System.Int64>), a <xref:System.Threading.Tasks.ParallelLoopState> wystąpienie, które mogą służyć do zerwać pętlę przedwcześnie.  
  
 Wywoływanie <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> informuje metoda `for` operacji, która iteracji po bieżącej nie muszą być wykonywane, ale czy wszystkich iteracji przed bieżącym.  
  
 W związku z tym, wywołanie przerwania jest podobne do operacji podziału, w ramach konwencjonalnej `for` , takich jak pętli w języku C#, ale nie jest doskonały zastępuje: na przykład, nie ma żadnej gwarancji tej iteracji po bieżącej nie zdecydowanie będą wykonywane.  
  
 Jeśli wykonanie wszystkich iteracji, przed bieżącym nie jest konieczne, należy użyć <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> metody zamiast <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>. Wywoływanie <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> informuje `for` pętli, może to porzucić wszystkie pozostałe iteracji, niezależnie od tego, czy są one przed lub po bieżącej iteracji, ponieważ wszystkie wymagane pracy będzie już zakończone. Jednak, tak jak przy użyciu <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>, nie ma żadnej gwarancji odnośnie do których nie zostanie wykonany innych iteracji.  
  
 Jeśli pętla jest zakończona przedwcześnie, <xref:System.Threading.Tasks.ParallelLoopResult> strukturę, która jest zwracana będzie zawierać informacje dotyczące zakończenia pętli.  
  
 Jeśli `fromInclusive` jest większa niż lub równa `toExclusive`, a następnie metoda zwraca natychmiast bez przeprowadzania żadnych iteracji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="body" /> Argument jest <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątki generowane we wszystkich wątkach.</exception>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, Action&lt;long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Action`1&lt;int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Action{System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Long, toExclusive As Long, body As Action(Of Long)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, Action&lt;long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * Action&lt;int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Indeks początkowy, włącznie.</param>
        <param name="toExclusive">Końcowy indeks, wyłączności.</param>
        <param name="body">Delegat, który jest wywoływana jeden raz na iterację.</param>
        <summary>Wykonuje <see langword="for" /> (<see langword="For" /> w języku Visual Basic) pętli z indeksami 64-bitowe, w których iteracje mogą być wykonywane równolegle.</summary>
        <returns>Struktura, która zawiera informacje o część pętli ukończone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body` Obiekt delegowany jest wywoływany raz dla każdej wartości w zakresie iteracji (`fromInclusive`, `toExclusive`). Jest ona udostępniana z liczbą iteracji (<xref:System.Int64>) jako parametr.  
  
 Jeśli `fromInclusive` jest większa niż lub równa `toExclusive`, metoda zwraca natychmiast bez przeprowadzania żadnych iteracji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="body" /> Argument jest <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątki generowane we wszystkich wątkach.</exception>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;int,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;int32, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Action{System.Int32,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;int, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * System.Threading.Tasks.ParallelOptions * Action&lt;int, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Indeks początkowy, włącznie.</param>
        <param name="toExclusive">Końcowy indeks, wyłączności.</param>
        <param name="parallelOptions">Obiekt, który służy do konfigurowania zachowania tej operacji.</param>
        <param name="body">Delegat, który jest wywoływana jeden raz na iterację.</param>
        <summary>Wykonuje <see langword="for" /> (<see langword="For" /> w języku Visual Basic) pętli w iteracji, które mogą być wykonywane równolegle, można skonfigurować opcje pętli i stan pętli dało się monitorować i manipulować.</summary>
        <returns>Struktura, która zawiera informacje o część pętli ukończone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body` Obiekt delegowany jest wywoływany raz dla każdej wartości w zakresie iteracji (`fromInclusive`, `toExclusive`). Jest ona udostępniana z następującymi parametrami: liczba iteracji (<xref:System.Int32>), a <xref:System.Threading.Tasks.ParallelLoopState> wystąpienie, które mogą służyć do zerwać pętlę przedwcześnie.  
  
 Jeśli `fromInclusive` jest większa niż lub równa `toExclusive`, metoda zwraca natychmiast bez przeprowadzania żadnych iteracji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <see cref="T:System.Threading.CancellationToken" /> w <paramref name="parallelOptions" /> argument zostanie anulowane.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="body" /> Argument jest <see langword="null" />.  - lub - <paramref name="parallelOptions" /> argument jest <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątki generowane we wszystkich wątkach.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.CancellationTokenSource" /> Skojarzone z <see cref="T:System.Threading.CancellationToken" /> w <paramref name="parallelOptions" /> został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;int&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;int32&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Action{System.Int32})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;int&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * System.Threading.Tasks.ParallelOptions * Action&lt;int&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Indeks początkowy, włącznie.</param>
        <param name="toExclusive">Końcowy indeks, wyłączności.</param>
        <param name="parallelOptions">Obiekt, który służy do konfigurowania zachowania tej operacji.</param>
        <param name="body">Delegat, który jest wywoływana jeden raz na iterację.</param>
        <summary>Wykonuje <see langword="for" /> (<see langword="For" /> w języku Visual Basic) pętli, w której iteracje mogą być wykonywane równolegle i można skonfigurować opcje pętli.</summary>
        <returns>Struktura, która zawiera informacje o część pętli ukończone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body` Obiekt delegowany jest wywoływany raz dla każdej wartości w zakresie iteracji (`fromInclusive`, `toExclusive`). Jest ona udostępniana z liczbą iteracji (<xref:System.Int32>) jako parametr.  
  
 Jeśli `fromInclusive` jest większa niż lub równa `toExclusive`, a następnie metoda zwraca natychmiast bez przeprowadzania żadnych iteracji.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak można anulować pętlę równoległą:  
  
 [!code-csharp[System.Threading.Tasks.Parallel#05](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelforcancel.cs#05)]
 [!code-vb[System.Threading.Tasks.Parallel#05](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelforcancel.vb#05)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <see cref="T:System.Threading.CancellationToken" /> w <paramref name="parallelOptions" /> argument zostanie anulowane.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="body" /> Argument jest <see langword="null" />.  - lub - <paramref name="parallelOptions" /> argument jest <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątki generowane we wszystkich wątkach.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.CancellationTokenSource" /> Skojarzone z <see cref="T:System.Threading.CancellationToken" /> w <paramref name="parallelOptions" /> został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;long,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;int64, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Action{System.Int64,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;long, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * System.Threading.Tasks.ParallelOptions * Action&lt;int64, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Indeks początkowy, włącznie.</param>
        <param name="toExclusive">Końcowy indeks, wyłączności.</param>
        <param name="parallelOptions">Obiekt, który służy do konfigurowania zachowania tej operacji.</param>
        <param name="body">Delegat, który jest wywoływana jeden raz na iterację.</param>
        <summary>Wykonuje <see langword="for" /> (<see langword="For" /> w języku Visual Basic) pętli z indeksami 64-bitowych w iteracji, które mogą być wykonywane równolegle, można skonfigurować opcje pętli i stan pętli dało się monitorować i manipulować.</summary>
        <returns>Struktura, która zawiera informacje o część pętli ukończone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body` Obiekt delegowany jest wywoływany raz dla każdej wartości w zakresie iteracji (`fromInclusive`, `toExclusive`). Jest ona udostępniana z następującymi parametrami: liczba iteracji (<xref:System.Int64>), a <xref:System.Threading.Tasks.ParallelLoopState> wystąpienie, które mogą służyć do zerwać pętlę przedwcześnie.  
  
 Jeśli `fromInclusive` jest większa niż lub równa `toExclusive`, metoda zwraca natychmiast bez przeprowadzania żadnych iteracji.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> metody <xref:System.Threading.Tasks.ParallelOptions> obiektu:  
  
 [!code-csharp[System.Threading.Tasks.Parallel#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelfor.cs#03)]
 [!code-vb[System.Threading.Tasks.Parallel#03](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelfor.vb#03)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <see cref="T:System.Threading.CancellationToken" /> w <paramref name="parallelOptions" /> argument zostanie anulowane.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="body" /> Argument jest <see langword="null" />.  - lub - <paramref name="parallelOptions" /> argument jest <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątki generowane we wszystkich wątkach.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.CancellationTokenSource" /> Skojarzone z <see cref="T:System.Threading.CancellationToken" /> w <paramref name="parallelOptions" /> został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Action{System.Int64})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * System.Threading.Tasks.ParallelOptions * Action&lt;int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Indeks początkowy, włącznie.</param>
        <param name="toExclusive">Końcowy indeks, wyłączności.</param>
        <param name="parallelOptions">Obiekt, który służy do konfigurowania zachowania tej operacji.</param>
        <param name="body">Delegat, który jest wywoływana jeden raz na iterację.</param>
        <summary>Wykonuje <see langword="for" /> (<see langword="For" /> w języku Visual Basic) pętli z indeksami 64-bitowe, w których iteracje mogą być wykonywane równolegle i można skonfigurować opcje pętli.</summary>
        <returns>Struktura, która zawiera informacje o część pętli ukończone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obsługuje 64-bitowych indeksów. `body` Obiekt delegowany jest wywoływany raz dla każdej wartości w zakresie iteracji (`fromInclusive`, `toExclusive`). Jest ona udostępniana z liczbą iteracji (<xref:System.Int64>) jako parametr.  
  
 Jeśli `fromInclusive` jest większa niż lub równa `toExclusive`, a następnie metoda zwraca natychmiast bez przeprowadzania żadnych iteracji.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać <xref:System.Threading.Tasks.ParallelOptions> do określenia harmonogramu niestandardowego zadania:  
  
 [!code-csharp[System.Threading.Tasks.Parallel#06](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelforwithscheduler.cs#06)]
 [!code-vb[System.Threading.Tasks.Parallel#06](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelforwithscheduler.vb#06)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <see cref="T:System.Threading.CancellationToken" /> w <paramref name="parallelOptions" /> argument zostanie anulowane.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="body" /> Argument jest <see langword="null" />.  - lub - <paramref name="parallelOptions" /> argument jest <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątki generowane we wszystkich wątkach.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.CancellationTokenSource" /> Skojarzone z <see cref="T:System.Threading.CancellationToken" /> w <paramref name="parallelOptions" /> został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (int fromInclusive, int toExclusive, Func&lt;TLocal&gt; localInit, Func&lt;int,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int32 fromInclusive, int32 toExclusive, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int32, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int32,System.Int32,System.Func{``0},System.Func{System.Int32,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For(Of TLocal) (fromInclusive As Integer, toExclusive As Integer, localInit As Func(Of TLocal), body As Func(Of Integer, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, Func&lt;TLocal&gt; ^ localInit, Func&lt;int, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int * int * Func&lt;'Local&gt; * Func&lt;int, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int32,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal">Typ danych lokalnej wątku.</typeparam>
        <param name="fromInclusive">Indeks początkowy, włącznie.</param>
        <param name="toExclusive">Końcowy indeks, wyłączności.</param>
        <param name="localInit">Delegat funkcji, która zwraca stan początkowy danych lokalnych dla każdego zadania.</param>
        <param name="body">Delegat, który jest wywoływana jeden raz na iterację.</param>
        <param name="localFinally">Delegat, który wykonuje końcowe akcję dla lokalnych stan każdego zadania.</param>
        <summary>Wykonuje <see langword="for" /> (<see langword="For" /> w języku Visual Basic) pętli za pomocą danych lokalnej wątku, w której iteracje mogą być wykonywane równolegle, a stan pętli dało się monitorować i manipulować.</summary>
        <returns>Struktura, która zawiera informacje o część pętli ukończone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body` Obiekt delegowany jest wywoływany raz dla każdej wartości w zakresie iteracji (`fromInclusive`, `toExclusive`). Jest ona udostępniana z następującymi parametrami: liczba iteracji (<xref:System.Int32>), <xref:System.Threading.Tasks.ParallelLoopState> wystąpienie, które mogą służyć do zerwać pętlę przedwcześnie i niektóre stan lokalnego, który może być współużytkowany przez iteracje, które są wykonywane na tym samym wątku.  
  
 `localInit` Obiekt delegowany jest wywoływany raz dla każdego zadania, które uczestniczy w wykonywanie pętli i zwraca początkowy stan lokalnego dla każdego z tych zadań. Te stany początkowej są przekazywane do pierwszego `body` wywołań dla każdego zadania. Każdego wywołania w treści kolejnych zwraca wartość stanu prawdopodobnie modyfikacji, który jest przekazywany do następnego wywołania treści. Na koniec ostatniego wywołania treści na każde zadanie podrzędne zwraca wartość stanu, który jest przekazywany do `localFinally` delegować. `localFinally` Obiekt delegowany jest wywoływany po poszczególnych zadań do wykonania akcji końcowego na stan lokalnego dla każdego zadania. Ten delegat może być wywoływany współbieżnie na wiele zadań; w związku z tym należy zsynchronizować dostępu do żadnych zmiennych udostępnionych.  
  
 <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> Metoda może używać większej liczby zadań niż wątki, w okresie istnienia działania jako istniejące zadania i są zastępowane przez nowe zadania. Dzięki temu bazowego <xref:System.Threading.Tasks.TaskScheduler> obiektu szansę, aby dodać, zmienić lub usunąć wątki, które usługa pętli.  
  
 Jeśli `fromInclusive` jest większa niż lub równa `toExclusive`, a następnie metoda zwraca natychmiast bez przeprowadzania żadnych iteracji.  
  
 Na przykład, który używa tej metody, zobacz [porady: zapisywanie pętli Parallel.For ze zmiennymi lokalnymi wątku](~/docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="body" /> Argument jest <see langword="null" />.  - lub - <paramref name="localInit" /> argument jest <see langword="null" />.  - lub - <paramref name="localFinally" /> argument jest <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątki generowane we wszystkich wątkach.</exception>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (long fromInclusive, long toExclusive, Func&lt;TLocal&gt; localInit, Func&lt;long,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int64 fromInclusive, int64 toExclusive, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int64, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int64,System.Int64,System.Func{``0},System.Func{System.Int64,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For(Of TLocal) (fromInclusive As Long, toExclusive As Long, localInit As Func(Of TLocal), body As Func(Of Long, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, Func&lt;TLocal&gt; ^ localInit, Func&lt;long, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * Func&lt;'Local&gt; * Func&lt;int64, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int64,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal">Typ danych lokalnej wątku.</typeparam>
        <param name="fromInclusive">Indeks początkowy, włącznie.</param>
        <param name="toExclusive">Końcowy indeks, wyłączności.</param>
        <param name="localInit">Delegat funkcji, która zwraca stan początkowy danych lokalnych dla każdego zadania.</param>
        <param name="body">Delegat, który jest wywoływana jeden raz na iterację.</param>
        <param name="localFinally">Delegat, który wykonuje końcowe akcję dla lokalnych stan każdego zadania.</param>
        <summary>Wykonuje <see langword="for" /> (<see langword="For" /> w języku Visual Basic) pętli za pomocą 64-bitowych, indeksy i wątków lokalnych danych, w której iteracje mogą być wykonywane równolegle, a stan pętli dało się monitorować i manipulować.</summary>
        <returns>Struktura, która zawiera informacje o część pętli ukończone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body` Obiekt delegowany jest wywoływany raz dla każdej wartości w zakresie iteracji (`fromInclusive`, `toExclusive`). Jest ona udostępniana z następującymi parametrami: liczba iteracji (<xref:System.Int64>), <xref:System.Threading.Tasks.ParallelLoopState> wystąpienie, które mogą służyć do zerwać pętlę przedwcześnie i niektóre stan lokalnego, który może być współużytkowany przez iteracje, które są wykonywane w tym samym zadaniu.  
  
 `localInit` Obiekt delegowany jest wywoływany raz dla każdego zadania, które uczestniczy w wykonywanie pętli i zwraca początkowy stan lokalnego dla każdego z tych zadań. Te stany początkowej są przekazywane do pierwszego `body` wywołań dla każdego zadania. Każdego wywołania w treści kolejnych zwraca wartość stanu prawdopodobnie modyfikacji, który jest przekazywany do następnego wywołania treści. Na koniec ostatniego wywołania treści na każde zadanie podrzędne zwraca wartość stanu, który jest przekazywany do `localFinally` delegować. `localFinally` Obiekt delegowany jest wywoływany po poszczególnych zadań do wykonania akcji końcowego na stan lokalnego dla każdego zadania. Ten delegat może być wywoływany współbieżnie na wiele zadań; w związku z tym należy zsynchronizować dostępu do żadnych zmiennych udostępnionych.  
  
 <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> Metoda może używać większej liczby zadań niż wątki, w okresie istnienia działania jako istniejące zadania i są zastępowane przez nowe zadania. Dzięki temu bazowego <xref:System.Threading.Tasks.TaskScheduler> obiektu szansę, aby dodać, zmienić lub usunąć wątki, które usługa pętli.  
  
 Jeśli `fromInclusive` jest większa niż lub równa `toExclusive`, a następnie metoda zwraca natychmiast bez przeprowadzania żadnych iteracji.  
  
 Na przykład, który używa tej metody, zobacz [porady: zapisywanie pętli Parallel.For ze zmiennymi lokalnymi wątku](~/docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="body" /> Argument jest <see langword="null" />.  - lub - <paramref name="localInit" /> argument jest <see langword="null" />.  - lub - <paramref name="localFinally" /> argument jest <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątki generowane we wszystkich wątkach.</exception>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (int fromInclusive, int toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;int,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int32 fromInclusive, int32 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int32, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Func{``0},System.Func{System.Int32,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;int, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int * int * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;int, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int32,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal">Typ danych lokalnej wątku.</typeparam>
        <param name="fromInclusive">Indeks początkowy, włącznie.</param>
        <param name="toExclusive">Końcowy indeks, wyłączności.</param>
        <param name="parallelOptions">Obiekt, który służy do konfigurowania zachowania tej operacji.</param>
        <param name="localInit">Delegat funkcji, która zwraca stan początkowy danych lokalnych dla każdego zadania.</param>
        <param name="body">Delegat, który jest wywoływana jeden raz na iterację.</param>
        <param name="localFinally">Delegat, który wykonuje końcowe akcję dla lokalnych stan każdego zadania.</param>
        <summary>Wykonuje <see langword="for" /> (<see langword="For" /> w języku Visual Basic) pętli za pomocą danych lokalnych wątków w iteracji, które mogą być wykonywane równolegle, można skonfigurować opcje pętli i stan pętli dało się monitorować i manipulować.</summary>
        <returns>Struktura, która zawiera informacje o część pętli ukończone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body` Obiekt delegowany jest wywoływany raz dla każdej wartości w zakresie iteracji (`fromInclusive`, `toExclusive`). Jest ona udostępniana z następującymi parametrami: liczba iteracji (<xref:System.Int32>), <xref:System.Threading.Tasks.ParallelLoopState> wystąpienie, które mogą służyć do zerwać pętlę przedwcześnie i niektóre stan lokalnego, który może być współużytkowany przez iteracje, które są wykonywane w tym samym zadaniu.  
  
 `localInit` Obiekt delegowany jest wywoływany raz dla każdego zadania, które uczestniczy w wykonywanie pętli i zwraca początkowy stan lokalnego dla każdego z tych zadań. Te stany początkowej są przekazywane do pierwszego `body` wywołań dla każdego zadania. Każdego wywołania w treści kolejnych zwraca wartość stanu prawdopodobnie modyfikacji, który jest przekazywany do następnego wywołania treści. Na koniec ostatniego wywołania treści na każde zadanie podrzędne zwraca wartość stanu, który jest przekazywany do `localFinally` delegować. `localFinally` Obiekt delegowany jest wywoływany po poszczególnych zadań do wykonania akcji końcowego na stan lokalnego dla każdego zadania. Ten delegat może być wywoływany współbieżnie w wielu wątkach; w związku z tym należy zsynchronizować dostępu do żadnych zmiennych udostępnionych.  
  
 <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> Metoda może używać większej liczby zadań niż wątki, w okresie istnienia działania jako istniejące zadania i są zastępowane przez nowe zadania. Dzięki temu bazowego <xref:System.Threading.Tasks.TaskScheduler> obiektu szansę, aby dodać, zmienić lub usunąć wątki, które usługa pętli.  
  
 Jeśli `fromInclusive` jest większa niż lub równa `toExclusive`, a następnie metoda zwraca natychmiast bez przeprowadzania żadnych iteracji.  
  
   
  
## Examples  
 W poniższym przykładzie użyto zmiennych thread-local, aby obliczyć sumę wyników wiele operacji długotrwałej. W tym przykładzie ogranicza stopień równoległości na cztery.  
  
 [!code-csharp[System.Threading.Tasks.Parallel#04](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/threadlocalforwithoptions.cs#04)]
 [!code-vb[System.Threading.Tasks.Parallel#04](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/threadlocalforwithoptions.vb#04)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="body" /> Argument jest <see langword="null" />.  - lub - <paramref name="localInit" /> argument jest <see langword="null" />.  - lub - <paramref name="localFinally" /> argument jest <see langword="null" />.  - lub - <paramref name="parallelOptions" /> argument jest <see langword="null" />.</exception>
        <exception cref="T:System.OperationCanceledException">
          <see cref="T:System.Threading.CancellationToken" /> w <paramref name="parallelOptions" /> argument zostanie anulowane.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.CancellationTokenSource" /> Skojarzone z <see cref="T:System.Threading.CancellationToken" /> w <paramref name="parallelOptions" /> został usunięty.</exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątki generowane we wszystkich wątkach.</exception>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (long fromInclusive, long toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;long,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int64 fromInclusive, int64 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int64, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Func{``0},System.Func{System.Int64,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;long, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;int64, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int64,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal">Typ danych lokalnej wątku.</typeparam>
        <param name="fromInclusive">Indeks początkowy, włącznie.</param>
        <param name="toExclusive">Końcowy indeks, wyłączności.</param>
        <param name="parallelOptions">Obiekt, który służy do konfigurowania zachowania tej operacji.</param>
        <param name="localInit">Delegat funkcji, która zwraca stan początkowy danych lokalnych dla każdego wątku.</param>
        <param name="body">Delegat, który jest wywoływana jeden raz na iterację.</param>
        <param name="localFinally">Delegat, który wykonuje końcowe akcję dla lokalnych stanu każdego wątku.</param>
        <summary>Wykonuje <see langword="for" /> (<see langword="For" /> w języku Visual Basic) pętli z indeksami 64-bitowych i danych lokalnej wątku, w którym iteracje mogą być wykonywane równolegle, można skonfigurować opcje pętli, a stan pętli dało się monitorować i manipulować.</summary>
        <returns>Struktura, która zawiera informacje o część pętli ukończone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body` Obiekt delegowany jest wywoływany raz dla każdej wartości w zakresie iteracji (`fromInclusive`, `toExclusive`). Jest ona udostępniana z następującymi parametrami: liczba iteracji (<xref:System.Int64>), <xref:System.Threading.Tasks.ParallelLoopState> wystąpienie, które mogą służyć do zerwać pętlę przedwcześnie i niektóre stan lokalnego, który może być współużytkowany przez iteracje, które są wykonywane na tym samym wątku.  
  
 `localInit` Obiekt delegowany jest wywoływany raz dla każdego wątku, który uczestniczy w wykonywanie pętli i zwraca początkowy stan lokalnego dla każdego z tych wątkach. Te stany początkowej są przekazywane do pierwszego `body` wywołań w każdym wątku. Każdego wywołania w treści kolejnych zwraca wartość stanu prawdopodobnie modyfikacji, który jest przekazywany do następnego wywołania treści. Na koniec, ostatni wywołania treści w każdym wątku zwraca wartość stanu, który jest przekazywany do `localFinally` delegować. `localFinally` Obiekt delegowany jest wywoływany raz na wątek do wykonania akcji końcowego na stan lokalnego dla każdego wątku. Ten delegat może być wywoływany współbieżnie w wielu wątkach; w związku z tym należy zsynchronizować dostępu do żadnych zmiennych udostępnionych.  
  
 <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> Metoda może używać większej liczby zadań niż wątki, w okresie istnienia działania jako istniejące zadania i są zastępowane przez nowe zadania. Dzięki temu bazowego <xref:System.Threading.Tasks.TaskScheduler> obiektu szansę, aby dodać, zmienić lub usunąć wątki, które usługa pętli.  
  
 Jeśli `fromInclusive` jest większa niż lub równa `toExclusive`, a następnie metoda zwraca natychmiast bez przeprowadzania żadnych iteracji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="body" /> Argument jest <see langword="null" />.  - lub - <paramref name="localInit" /> argument jest <see langword="null" />.  - lub - <paramref name="localFinally" /> argument jest <see langword="null" />.  - lub - <paramref name="parallelOptions" /> argument jest <see langword="null" />.</exception>
        <exception cref="T:System.OperationCanceledException">
          <see cref="T:System.Threading.CancellationToken" /> w <paramref name="parallelOptions" /> argument zostanie anulowane.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.CancellationTokenSource" /> Skojarzone z <see cref="T:System.Threading.CancellationToken" /> w <paramref name="parallelOptions" /> został usunięty.</exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątki generowane we wszystkich wątkach.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ForEach&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wykonuje <see langword="foreach" /> (<see langword="For Each " /> w języku Visual Basic) operacji, w którym iteracje mogą być wykonywane równolegle.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.OrderablePartitioner{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As OrderablePartitioner(Of TSource), body As Action(Of TSource, ParallelLoopState, Long)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów w <c>źródła</c>.</typeparam>
        <param name="source">Prędkości partycjonera, który zawiera oryginalnego źródła danych.</param>
        <param name="body">Delegat, który jest wywoływana jeden raz na iterację.</param>
        <summary>Wykonuje <see langword="foreach" /> (<see langword="For Each" /> w języku Visual Basic) Operacja <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> w którym iteracje mogą być wykonywane równolegle i stan pętli dało się monitorować i manipulować.</summary>
        <returns>Struktura, która zawiera informacje o część pętli ukończone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie jest udostępniana dla scenariuszy, w której chcesz przesłonić domyślny schemat partycji. Na przykład małych jednostek pętli mogą skorzystać z partycjonowania zakresu. <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Metoda oczekuje niestandardowe partycjonery umożliwiają dynamiczne partycjonowanie. Aby uzyskać więcej informacji, zobacz [niestandardowe Partycjonery dla PLINQ i TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) i [porady: Implementowanie partycji dynamicznych](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> Argument jest <see langword="null" />.  - lub - <paramref name="body" /> argument jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> Właściwość <paramref name="source" /> zwraca prędkości partycjonera <see langword="false" />.  - lub - <see cref="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysNormalized" /> zwraca wartość właściwości w partycjonera prędkości źródła <see langword="false" />.  Zwróć wszystkie metody w partycjonera prędkości źródła - lub - <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As Partitioner(Of TSource), body As Action(Of TSource, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów w <c>źródła</c>.</typeparam>
        <param name="source">Partycjonera, który zawiera oryginalnego źródła danych.</param>
        <param name="body">Delegat, który jest wywoływana jeden raz na iterację.</param>
        <summary>Wykonuje <see langword="foreach" /> (<see langword="For Each" /> w języku Visual Basic) Operacja <see cref="T:System.Collections.Concurrent.Partitioner" /> w której iteracje mogą być wykonywane równolegle, a stan pętli dało się monitorować i manipulować.</summary>
        <returns>Struktura, która zawiera informacje o część pętli ukończone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie jest udostępniana dla scenariuszy, w której chcesz przesłonić domyślny schemat partycji. Na przykład małych jednostek pętli mogą skorzystać z partycjonowania zakresu. <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Metoda oczekuje niestandardowe partycjonery umożliwiają dynamiczne partycjonowanie. Aby uzyskać więcej informacji, zobacz [niestandardowe Partycjonery dla PLINQ i TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) i [porady: Implementowanie partycji dynamicznych](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> Argument jest <see langword="null" />.  - lub - <paramref name="body" /> argument jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> Właściwość <paramref name="source" /> zwraca partycjonera <see langword="false" />.  - lub - metoda w <paramref name="source" /> zwraca partycjonera <see langword="null" />.  - lub - <see cref="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)" /> method in Class metoda <paramref name="source" /> partycjonera nie zwraca poprawną liczbę partycji.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As Partitioner(Of TSource), body As Action(Of TSource)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów w <c>źródła</c>.</typeparam>
        <param name="source">Partycjonera, który zawiera oryginalnego źródła danych.</param>
        <param name="body">Delegat, który jest wywoływana jeden raz na iterację.</param>
        <summary>Wykonuje <see langword="foreach" /> (<see langword="For Each" /> w języku Visual Basic) Operacja <see cref="T:System.Collections.Concurrent.Partitioner" /> w iteracji, które mogą być wykonywane równolegle.</summary>
        <returns>Struktura, która zawiera informacje o część pętli ukończone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie jest udostępniana dla scenariuszy, w której chcesz przesłonić domyślny schemat partycji. Na przykład małych jednostek pętli mogą skorzystać z partycjonowania zakresu. <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Metoda oczekuje niestandardowe partycjonery umożliwiają dynamiczne partycjonowanie. Aby uzyskać więcej informacji, zobacz [niestandardowe Partycjonery dla PLINQ i TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) i [porady: Implementowanie partycji dynamicznych](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak Implementowanie partycjonera zakresu do użytku z programem <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>:  
  
 [!code-csharp[System.Threading.Tasks.Parallel_RangePartitioners#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel_rangepartitioners/cs/rangepartitioner.cs#01)]
 [!code-vb[System.Threading.Tasks.Parallel_RangePartitioners#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel_rangepartitioners/vb/rangepart.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> Argument jest <see langword="null" />.  - lub - <paramref name="body" /> argument jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> Właściwość <paramref name="source" /> zwraca partycjonera <see langword="false" />.  - lub - wyjątku, który jest generowany, gdy wszystkie metody w <paramref name="source" /> partycjonera zwracany <see langword="null" />.  - lub - <see cref="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)" /> method in Class metoda <paramref name="source" /> partycjonera nie zwraca poprawną liczbę partycji.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As IEnumerable(Of TSource), body As Action(Of TSource, ParallelLoopState, Long)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ danych w źródle.</typeparam>
        <param name="source">Źródło danych wyliczalny.</param>
        <param name="body">Delegat, który jest wywoływana jeden raz na iterację.</param>
        <summary>Wykonuje <see langword="foreach" /> (<see langword="For Each" /> w języku Visual Basic) operację, używając 64-bitowych indeksów w <see cref="T:System.Collections.IEnumerable" /> w której iteracje mogą być wykonywane równolegle, a stan pętli dało się monitorować i manipulować.</summary>
        <returns>Struktura, która zawiera informacje o część pętli ukończone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body` Obiekt delegowany jest wywoływany raz dla każdego elementu w `source` wyliczalny. Jest ona udostępniana z następującymi parametrami: bieżący element <xref:System.Threading.Tasks.ParallelLoopState> wystąpienie, które mogą służyć do zerwać pętlę przedwcześnie i indeks bieżącego elementu (<xref:System.Int64>).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> Argument jest <see langword="null" />.  - lub - <paramref name="body" /> argument jest <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątki generowane we wszystkich wątkach.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As IEnumerable(Of TSource), body As Action(Of TSource, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ danych w źródle.</typeparam>
        <param name="source">Źródło danych wyliczalny.</param>
        <param name="body">Delegat, który jest wywoływana jeden raz na iterację.</param>
        <summary>Wykonuje <see langword="foreach" /> (<see langword="For Each" /> w języku Visual Basic) Operacja <see cref="T:System.Collections.IEnumerable" /> w której iteracje mogą być wykonywane równolegle, a stan pętli dało się monitorować i manipulować.</summary>
        <returns>Struktura, która zawiera informacje o część pętli ukończone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body` Obiekt delegowany jest wywoływany raz dla każdego elementu w `source` wyliczalny. Jest ona udostępniana z następującymi parametrami: bieżącego elementu i <xref:System.Threading.Tasks.ParallelLoopState> wystąpienie, które mogą służyć do zerwać pętlę przedwcześnie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> Argument jest <see langword="null" />.  - lub - <paramref name="body" /> argument jest <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątki generowane we wszystkich wątkach.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As IEnumerable(Of TSource), body As Action(Of TSource)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ danych w źródle.</typeparam>
        <param name="source">Źródło danych wyliczalny.</param>
        <param name="body">Delegat, który jest wywoływana jeden raz na iterację.</param>
        <summary>Wykonuje <see langword="foreach" /> (<see langword="For Each" /> w języku Visual Basic) Operacja <see cref="T:System.Collections.IEnumerable" /> w iteracji, które mogą być wykonywane równolegle.</summary>
        <returns>Struktura, która zawiera informacje o część pętli ukończone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body` Obiekt delegowany jest wywoływany raz dla każdego elementu w `source` wyliczalny. Jest ona udostępniana z bieżącego elementu jako parametr.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Threading.Tasks.Parallel.ForEach%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Action%7B%60%600%7D%29> metodę, aby określić liczbę samogłosek i znaki inne niż odstępu w pliku tekstowym. W tym przypadku <xref:System.Threading.Tasks.ParallelLoopResult> wartości zwracanej przez metodę jest ignorowana. Należy zauważyć, że ponieważ operacje można uruchomić równolegle, upewnij się, że zmienne liczników przyrostu o wartości jest operacją niepodzielną i że wiele wątków nie należy próbować uzyskać dostęp do zmiennych licznik jednocześnie. W tym celu w przykładzie użyto `lock` — instrukcja (w języku C#) i `SyncLock` — instrukcja (w języku Visual Basic).  
  
 [!code-csharp[System.Threading.Tasks.Parallel.ForEach#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel.foreach/cs/foreach1.cs#1)]
 [!code-vb[System.Threading.Tasks.Parallel.ForEach#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel.foreach/vb/foreach1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> Argument jest <see langword="null" />.  - lub - <paramref name="body" /> argument jest <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątki generowane we wszystkich wątkach.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.OrderablePartitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów w <c>źródła</c>.</typeparam>
        <param name="source">Prędkości partycjonera, który zawiera oryginalnego źródła danych.</param>
        <param name="parallelOptions">Obiekt, który służy do konfigurowania zachowania tej operacji.</param>
        <param name="body">Delegat, który jest wywoływana jeden raz na iterację.</param>
        <summary>Wykonuje <see langword="foreach" /> (<see langword="For Each" /> w języku Visual Basic) Operacja <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> w iteracji, które mogą być wykonywane równolegle, można skonfigurować opcje pętli, a stan pętli dało się monitorować i manipulować.</summary>
        <returns>Struktura, która zawiera informacje o część pętli ukończone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie jest udostępniana dla scenariuszy, w której chcesz przesłonić domyślny schemat partycji. Na przykład małych jednostek pętli mogą skorzystać z partycjonowania zakresu. <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Metoda oczekuje niestandardowe partycjonery umożliwiają dynamiczne partycjonowanie. Aby uzyskać więcej informacji, zobacz [niestandardowe Partycjonery dla PLINQ i TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) i [porady: Implementowanie partycji dynamicznych](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <see cref="T:System.Threading.CancellationToken" /> w <paramref name="parallelOptions" /> argument zostanie anulowane.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> Argument jest <see langword="null" />.  - lub - <paramref name="parallelOptions" /> argument jest <see langword="null" />.  - lub - <paramref name="body" /> argument jest <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.CancellationTokenSource" /> Skojarzone z <see cref="T:System.Threading.CancellationToken" /> w <paramref name="parallelOptions" /> został usunięty.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> Właściwość <paramref name="source" /> zwraca prędkości partycjonera <see langword="false" />.  - lub - <see cref="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysNormalized" /> właściwość <paramref name="source" /> zwraca prędkości partycjonera <see langword="false" />.  - lub - wyjątku, który jest generowany, gdy wszystkie metody w <paramref name="source" /> prędkości partycjonera zwracany <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów w <c>źródła</c>.</typeparam>
        <param name="source">Partycjonera, który zawiera oryginalnego źródła danych.</param>
        <param name="parallelOptions">Obiekt, który służy do konfigurowania zachowania tej operacji.</param>
        <param name="body">Delegat, który jest wywoływana jeden raz na iterację.</param>
        <summary>Wykonuje <see langword="foreach" /> (<see langword="For Each" /> w języku Visual Basic) Operacja <see cref="T:System.Collections.Concurrent.Partitioner" /> w iteracji, które mogą być wykonywane równolegle, można skonfigurować opcje pętli, a stan pętli dało się monitorować i manipulować.</summary>
        <returns>Struktura, która zawiera informacje o część pętli ukończone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie jest udostępniana dla scenariuszy, w której chcesz przesłonić domyślny schemat partycji. Na przykład małych jednostek pętli mogą skorzystać z partycjonowania zakresu. <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Metoda oczekuje niestandardowe partycjonery umożliwiają dynamiczne partycjonowanie. Aby uzyskać więcej informacji, zobacz [niestandardowe Partycjonery dla PLINQ i TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) i [porady: Implementowanie partycji dynamicznych](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <see cref="T:System.Threading.CancellationToken" /> w <paramref name="parallelOptions" /> argument zostanie anulowane.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.CancellationTokenSource" /> Skojarzone z <see cref="T:System.Threading.CancellationToken" /> w <paramref name="parallelOptions" /> został usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> Argument jest <see langword="null" />.  - lub - <paramref name="parallelOptions" /> argument jest <see langword="null" />.  - lub - <paramref name="body" /> argument jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> Właściwość <paramref name="source" /> zwraca partycjonera <see langword="false" />.  - lub - wyjątku, który jest generowany, gdy wszystkie metody w <paramref name="source" /> partycjonera zwracany <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów w <c>źródła</c>.</typeparam>
        <param name="source">Partycjonera, który zawiera oryginalnego źródła danych.</param>
        <param name="parallelOptions">Obiekt, który służy do konfigurowania zachowania tej operacji.</param>
        <param name="body">Delegat, który jest wywoływana jeden raz na iterację.</param>
        <summary>Wykonuje <see langword="foreach" /> (<see langword="For Each" /> w języku Visual Basic) Operacja <see cref="T:System.Collections.Concurrent.Partitioner" /> w którym iteracje mogą być wykonywane równolegle i można skonfigurować opcje pętli.</summary>
        <returns>Struktura, która zawiera informacje o część pętli ukończone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie jest udostępniana dla scenariuszy, w której chcesz przesłonić domyślny schemat partycji. Na przykład małych jednostek pętli mogą skorzystać z partycjonowania zakresu. <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Metoda oczekuje niestandardowe partycjonery umożliwiają dynamiczne partycjonowanie. Aby uzyskać więcej informacji, zobacz [niestandardowe Partycjonery dla PLINQ i TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) i [porady: Implementowanie partycji dynamicznych](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <see cref="T:System.Threading.CancellationToken" /> w <paramref name="parallelOptions" /> argument zostanie anulowane.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.CancellationTokenSource" /> Skojarzone z <see cref="T:System.Threading.CancellationToken" /> w <paramref name="parallelOptions" /> został usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> Argument jest <see langword="null" />.  - lub - <paramref name="parallelOptions" /> argument jest <see langword="null" />.  - lub - <paramref name="body" /> argument jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> Właściwość <paramref name="source" /> zwraca partycjonera <see langword="false" />.  - lub - wyjątku, który jest generowany, gdy wszystkie metody w <paramref name="source" /> partycjonera zwracany <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ danych w źródle.</typeparam>
        <param name="source">Źródło danych wyliczalny.</param>
        <param name="parallelOptions">Obiekt, który służy do konfigurowania zachowania tej operacji.</param>
        <param name="body">Delegat, który jest wywoływana jeden raz na iterację.</param>
        <summary>Wykonuje <see langword="foreach" /> (<see langword="For Each" /> w języku Visual Basic) operację, używając 64-bitowych indeksów w <see cref="T:System.Collections.IEnumerable" /> w iteracji, które mogą być wykonywane równolegle, można skonfigurować opcje pętli, a stan pętli dało się monitorować i manipulować.</summary>
        <returns>Struktura, która zawiera informacje o część pętli ukończone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body` Obiekt delegowany jest wywoływany raz dla każdego elementu w `source` wyliczalny. Jest ona udostępniana z następującymi parametrami: bieżący element <xref:System.Threading.Tasks.ParallelLoopState> wystąpienie, które mogą służyć do zerwać pętlę przedwcześnie i indeks bieżącego elementu (<xref:System.Int64>).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <see cref="T:System.Threading.CancellationToken" /> w <paramref name="parallelOptions" /> argument zostanie anulowane.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> Argument jest <see langword="null" />.  - lub - <paramref name="parallelOptions" /> argument jest <see langword="null" />.  - lub - <paramref name="body" /> argument jest <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątki generowane we wszystkich wątkach.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.CancellationTokenSource" /> Skojarzone z <see cref="T:System.Threading.CancellationToken" /> w <paramref name="parallelOptions" /> został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ danych w źródle.</typeparam>
        <param name="source">Źródło danych wyliczalny.</param>
        <param name="parallelOptions">Obiekt, który służy do konfigurowania zachowania tej operacji.</param>
        <param name="body">Delegat, który jest wywoływana jeden raz na iterację.</param>
        <summary>Wykonuje <see langword="foreach" /> (<see langword="For Each" /> w języku Visual Basic) Operacja <see cref="T:System.Collections.IEnumerable" /> w iteracji, które mogą być wykonywane równolegle, można skonfigurować opcje pętli, a stan pętli dało się monitorować i manipulować.</summary>
        <returns>Struktura, która zawiera informacje o część pętli ukończone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body` Obiekt delegowany jest wywoływany raz dla każdego elementu w `source` wyliczalny. Jest ona udostępniana z następującymi parametrami: bieżącego elementu i <xref:System.Threading.Tasks.ParallelLoopState> wystąpienie, które mogą służyć do zerwać pętlę przedwcześnie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <see cref="T:System.Threading.CancellationToken" /> w <paramref name="parallelOptions" /> argument zostanie anulowane.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> Argument jest <see langword="null" />.  - lub - <paramref name="parallelOptions" /> argument jest <see langword="null" />.  - lub - <paramref name="body" /> argument jest <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątki generowane we wszystkich wątkach.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.CancellationTokenSource" /> Skojarzone z <see cref="T:System.Threading.CancellationToken" /> w <paramref name="parallelOptions" /> został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ danych w źródle.</typeparam>
        <param name="source">Źródło danych wyliczalny.</param>
        <param name="parallelOptions">Obiekt, który służy do konfigurowania zachowania tej operacji.</param>
        <param name="body">Delegat, który jest wywoływana jeden raz na iterację.</param>
        <summary>Wykonuje <see langword="foreach" /> (<see langword="For Each" /> w języku Visual Basic) Operacja <see cref="T:System.Collections.IEnumerable" /> w którym iteracje mogą być wykonywane równolegle i można skonfigurować opcje pętli.</summary>
        <returns>Struktura, która zawiera informacje o część pętli ukończone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body` Obiekt delegowany jest wywoływany raz dla każdego elementu w `source` wyliczalny. Jest ona udostępniana z bieżącego elementu jako parametr.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <see cref="T:System.Threading.CancellationToken" /> w <paramref name="parallelOptions" /> argument zostanie anulowane.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> Argument jest <see langword="null" />.  - lub - <paramref name="parallelOptions" /> argument jest <see langword="null" />.  - lub - <paramref name="body" /> argument jest <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątki generowane we wszystkich wątkach.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.CancellationTokenSource" /> Skojarzone z <see cref="T:System.Threading.CancellationToken" /> w <paramref name="parallelOptions" /> został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.OrderablePartitioner{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As OrderablePartitioner(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, Long, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów w <c>źródła</c>.</typeparam>
        <typeparam name="TLocal">Typ danych lokalnej wątku.</typeparam>
        <param name="source">Prędkości partycjonera, który zawiera oryginalnego źródła danych.</param>
        <param name="localInit">Delegat funkcji, która zwraca stan początkowy danych lokalnych dla każdego zadania.</param>
        <param name="body">Delegat, który jest wywoływana jeden raz na iterację.</param>
        <param name="localFinally">Delegat, który wykonuje końcowe akcję dla lokalnych stan każdego zadania.</param>
        <summary>Wykonuje <see langword="foreach" /> (<see langword="For Each" /> w języku Visual Basic) operacja z danymi lokalnymi wątku na <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> w iteracji, które mogą być wykonywane równolegle, można skonfigurować opcje pętli, a stan pętli dało się monitorować i manipulować.</summary>
        <returns>Struktura, która zawiera informacje o część pętli ukończone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie jest udostępniana dla scenariuszy, w której chcesz przesłonić domyślny schemat partycji. Na przykład małych jednostek pętli mogą skorzystać z partycjonowania zakresu. <xref:System.Threading.Tasks.Parallel.ForEach%2A> Metoda oczekuje niestandardowe partycjonery umożliwiają dynamiczne partycjonowanie. Aby uzyskać więcej informacji, zobacz [niestandardowe Partycjonery dla PLINQ i TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) i [porady: Implementowanie partycji dynamicznych](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 `localInit` Obiekt delegowany jest wywoływany raz dla każdego zadania, które uczestniczy w wykonywanie pętli i zwraca początkowy stan lokalnego dla każdego z tych zadań. Te stany początkowej są przekazywane do pierwszego `body` wywołań dla każdego zadania. Każdego wywołania w treści kolejnych zwraca wartość stanu prawdopodobnie modyfikacji, który jest przekazywany do następnego wywołania treści. Na koniec ostatniego wywołania treści na każde zadanie podrzędne zwraca wartość stanu, który jest przekazywany do `localFinally` delegować. `localFinally` Obiekt delegowany jest wywoływany po poszczególnych zadań do wykonania akcji końcowego na stan lokalnego dla każdego zadania. Ten delegat może być wywoływany współbieżnie na wiele zadań; w związku z tym należy zsynchronizować dostępu do żadnych zmiennych udostępnionych.  
  
 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Metoda może używać większej liczby zadań niż wątki, w okresie istnienia działania jako istniejące zadania i są zastępowane przez nowe zadania. Dzięki temu bazowego <xref:System.Threading.Tasks.TaskScheduler> obiektu szansę, aby dodać, zmienić lub usunąć wątki, które usługa pętli.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> Argument jest <see langword="null" />.  - lub - <paramref name="body" /> argument jest <see langword="null" />.  - lub - <paramref name="localInit" /> argument jest <see langword="null" />.  - lub - <paramref name="localFinally" /> argument jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> Właściwość <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> zwraca <see langword="false" /> lub zwraca partycjonera <see langword="null" /> partycji.</exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątki generowane we wszystkich wątkach.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.Partitioner{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As Partitioner(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów w <c>źródła</c>.</typeparam>
        <typeparam name="TLocal">Typ danych lokalnej wątku.</typeparam>
        <param name="source">Partycjonera, który zawiera oryginalnego źródła danych.</param>
        <param name="localInit">Delegat funkcji, która zwraca stan początkowy danych lokalnych dla każdego zadania.</param>
        <param name="body">Delegat, który jest wywoływana jeden raz na iterację.</param>
        <param name="localFinally">Delegat, który wykonuje końcowe akcję dla lokalnych stan każdego zadania.</param>
        <summary>Wykonuje <see langword="foreach" /> (<see langword="For Each" /> w języku Visual Basic) operacja z danymi lokalnymi wątku na <see cref="T:System.Collections.Concurrent.Partitioner" /> w którym iteracje mogą być wykonywane równolegle i stan pętli dało się monitorować i manipulować.</summary>
        <returns>Struktura, która zawiera informacje o część pętli ukończone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie jest udostępniana dla scenariuszy, w której chcesz przesłonić domyślny schemat partycji. Na przykład małych jednostek pętli mogą skorzystać z partycjonowania zakresu. <xref:System.Threading.Tasks.Parallel.ForEach%2A> Metoda oczekuje niestandardowe partycjonery umożliwiają dynamiczne partycjonowanie. Aby uzyskać więcej informacji, zobacz [niestandardowe Partycjonery dla PLINQ i TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) i [porady: Implementowanie partycji dynamicznych](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 `localInit` Obiekt delegowany jest wywoływany raz dla każdego wątku, który uczestniczy w wykonywanie pętli i zwraca początkowy stan lokalnego dla każdego z tych zadań. Te stany początkowej są przekazywane do pierwszego `body` wywołań dla każdego zadania. Każdego wywołania w treści kolejnych zwraca wartość stanu prawdopodobnie modyfikacji, który jest przekazywany do następnego wywołania treści. Na koniec ostatniego wywołania treści na każde zadanie podrzędne zwraca wartość stanu, który jest przekazywany do `localFinally` delegować. `localFinally` Obiekt delegowany jest wywoływany po poszczególnych zadań do wykonania akcji końcowego na stan lokalnego dla każdego zadania. Ten delegat może być wywoływany współbieżnie na wiele zadań; w związku z tym należy zsynchronizować dostępu do żadnych zmiennych udostępnionych.  
  
 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Metoda może używać większej liczby zadań niż wątki, w okresie istnienia działania jako istniejące zadania i są zastępowane przez nowe zadania. Dzięki temu bazowego <xref:System.Threading.Tasks.TaskScheduler> obiektu szansę, aby dodać, zmienić lub usunąć wątki, które usługa pętli.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> Argument jest <see langword="null" />.  - lub - <paramref name="body" /> argument jest <see langword="null" />.  - lub - <paramref name="localInit" /> argument jest <see langword="null" />.  - lub - <paramref name="localFinally" /> argument jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> Właściwość <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> zwraca <see langword="false" /> lub zwraca partycjonera <see langword="null" /> partycji.</exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątki generowane we wszystkich wątkach.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As IEnumerable(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, Long, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ danych w źródle.</typeparam>
        <typeparam name="TLocal">Typ danych lokalnej wątku.</typeparam>
        <param name="source">Źródło danych wyliczalny.</param>
        <param name="localInit">Delegat funkcji, która zwraca stan początkowy danych lokalnych dla każdego zadania.</param>
        <param name="body">Delegat, który jest wywoływana jeden raz na iterację.</param>
        <param name="localFinally">Delegat, który wykonuje końcowe akcję dla lokalnych stan każdego zadania.</param>
        <summary>Wykonuje <see langword="foreach" /> (<see langword="For Each" /> w języku Visual Basic) operacja z danymi lokalnymi wątku na <see cref="T:System.Collections.IEnumerable" /> w którym iteracje mogą być wykonywane równolegle i stan pętli dało się monitorować i manipulować.</summary>
        <returns>Struktura, która zawiera informacje o część pętli ukończone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body` Obiekt delegowany jest wywoływany raz dla każdego elementu w `source` wyliczalny. Znajduje się z następującymi parametrami: bieżący element <xref:System.Threading.Tasks.ParallelLoopState> wystąpienie, które mogą służyć do przedwcześnie zerwać pętlę, indeks bieżącego elementu (<xref:System.Int64>), a niektóre stan lokalnego, który może być współużytkowany przez iteracje, które są wykonywane w tym samym wątku.  
  
 `localInit` Obiekt delegowany jest wywoływany raz dla każdego zadania, które uczestniczy w wykonywanie pętli i zwraca początkowy stan lokalnego dla każdego z tych zadań. Te stany początkowej są przekazywane do pierwszego `body` wywołań dla każdego zadania. Każdego wywołania w treści kolejnych zwraca wartość stanu prawdopodobnie modyfikacji, który jest przekazywany do następnego wywołania treści. Na koniec ostatniego wywołania treści na każde zadanie podrzędne zwraca wartość stanu, który jest przekazywany do `localFinally` delegować. `localFinally` Obiekt delegowany jest wywoływany po poszczególnych zadań do wykonania akcji końcowego na stan lokalnego dla każdego zadania. Ten delegat może być wywoływany współbieżnie na wiele zadań; w związku z tym należy zsynchronizować dostępu do żadnych zmiennych udostępnionych.  
  
 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Metoda może używać większej liczby zadań niż wątki, w okresie istnienia działania jako istniejące zadania i są zastępowane przez nowe zadania. Dzięki temu bazowego <xref:System.Threading.Tasks.TaskScheduler> obiektu szansę, aby dodać, zmienić lub usunąć wątki, które usługa pętli.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> Argument jest <see langword="null" />.  - lub - <paramref name="body" /> argument jest <see langword="null" />.  - lub - <paramref name="localInit" /> argument jest <see langword="null" />.  - lub - <paramref name="localFinally" /> argument jest <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątki generowane we wszystkich wątkach.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As IEnumerable(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ danych w źródle.</typeparam>
        <typeparam name="TLocal">Typ danych lokalnej wątku.</typeparam>
        <param name="source">Źródło danych wyliczalny.</param>
        <param name="localInit">Delegat funkcji, która zwraca stan początkowy danych lokalnych dla każdego zadania.</param>
        <param name="body">Delegat, który jest wywoływana jeden raz na iterację.</param>
        <param name="localFinally">Delegat, który wykonuje końcowe akcję dla lokalnych stan każdego zadania.</param>
        <summary>Wykonuje <see langword="foreach" /> (<see langword="For Each" /> w języku Visual Basic) operacja z danymi lokalnymi wątku na <see cref="T:System.Collections.IEnumerable" /> w której iteracje mogą być wykonywane równolegle, a stan pętli dało się monitorować i manipulować.</summary>
        <returns>Struktura, która zawiera informacje o część pętli ukończone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body` Obiekt delegowany jest wywoływany raz dla każdego elementu w `source` wyliczalny. Jest ona udostępniana z następującymi parametrami: bieżący element <xref:System.Threading.Tasks.ParallelLoopState> wystąpienie, które mogą służyć do zerwać pętlę przedwcześnie i niektóre stan lokalnego, który może być współużytkowany przez iteracje, które są wykonywane na tym samym wątku.  
  
 `localInit` Obiekt delegowany jest wywoływany raz dla każdego zadania, które uczestniczy w wykonywanie pętli i zwraca początkowy stan lokalnego dla każdego z tych zadań. Te stany początkowej są przekazywane do pierwszego `body` wywołań dla każdego zadania. Każdego wywołania w treści kolejnych zwraca wartość stanu prawdopodobnie modyfikacji, który jest przekazywany do następnego wywołania treści. Na koniec ostatniego wywołania treści na każde zadanie podrzędne zwraca wartość stanu, który jest przekazywany do `localFinally` delegować. `localFinally` Obiekt delegowany jest wywoływany raz na wątek do wykonania akcji końcowego na stan lokalnego dla każdego zadania. Ten delegat może być wywoływany współbieżnie na wiele zadań; w związku z tym należy zsynchronizować dostępu do żadnych zmiennych udostępnionych.  
  
 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Metoda może używać większej liczby zadań niż wątki, w okresie istnienia działania jako istniejące zadania i są zastępowane przez nowe zadania. Dzięki temu bazowego <xref:System.Threading.Tasks.TaskScheduler> obiektu szansę, aby dodać, zmienić lub usunąć wątki, które usługa pętli.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać <xref:System.Threading.Tasks.Parallel.ForEach%2A> metoda ze stanem lokalnego:  
  
 [!code-csharp[System.Threading.Tasks.Parallel#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelforeach.cs#02)]
 [!code-vb[System.Threading.Tasks.Parallel#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelforeach.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> Argument jest <see langword="null" />.  - lub - <paramref name="body" /> argument jest <see langword="null" />.  - lub - <paramref name="localInit" /> argument jest <see langword="null" />.  - lub - <paramref name="localFinally" /> argument jest <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątki generowane we wszystkich wątkach.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.OrderablePartitioner{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów w <c>źródła</c>.</typeparam>
        <typeparam name="TLocal">Typ danych lokalnej wątku.</typeparam>
        <param name="source">Prędkości partycjonera, który zawiera oryginalnego źródła danych.</param>
        <param name="parallelOptions">Obiekt, który służy do konfigurowania zachowania tej operacji.</param>
        <param name="localInit">Delegat funkcji, która zwraca stan początkowy danych lokalnych dla każdego zadania.</param>
        <param name="body">Delegat, który jest wywoływana jeden raz na iterację.</param>
        <param name="localFinally">Delegat, który wykonuje końcowe akcję dla lokalnych stan każdego zadania.</param>
        <summary>Wykonuje <see langword="foreach" /> (<see langword="For Each" /> w języku Visual Basic) operacji z indeksami 64-bitowych, jak i z danymi lokalnymi wątku na <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> w iteracji, które mogą być wykonywane równolegle, można skonfigurować opcje pętli i można monitorować stan pętli i manipulować.</summary>
        <returns>Struktura, która zawiera informacje o część pętli ukończone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie jest udostępniana dla scenariuszy, w której chcesz przesłonić domyślny schemat partycji. Na przykład małych jednostek pętli mogą skorzystać z partycjonowania zakresu. <xref:System.Threading.Tasks.Parallel.ForEach%2A> Metoda oczekuje niestandardowe partycjonery umożliwiają dynamiczne partycjonowanie. Aby uzyskać więcej informacji, zobacz [niestandardowe Partycjonery dla PLINQ i TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) i [porady: Implementowanie partycji dynamicznych](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 `localInit` Obiekt delegowany jest wywoływany raz dla każdego zadania, które uczestniczy w wykonywanie pętli i zwraca początkowy stan lokalnego dla każdego z tych zadań. Te stany początkowej są przekazywane do pierwszego `body` wywołań dla każdego zadania. Każdego wywołania w treści kolejnych zwraca wartość stanu prawdopodobnie modyfikacji, który jest przekazywany do następnego wywołania treści. Na koniec, ostatni wywołania treści w każdym wątku zwraca wartość stanu, który jest przekazywany do `localFinally` delegować. `localFinally` Obiekt delegowany jest wywoływany po poszczególnych zadań do wykonania akcji końcowego na stan lokalnego dla każdego zadania. Ten delegat może być wywoływany współbieżnie na wiele zadań; w związku z tym należy zsynchronizować dostępu do żadnych zmiennych udostępnionych.  
  
 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Metoda może używać większej liczby zadań niż wątki, w okresie istnienia działania jako istniejące zadania i są zastępowane przez nowe zadania. Dzięki temu bazowego <xref:System.Threading.Tasks.TaskScheduler> obiektu szansę, aby dodać, zmienić lub usunąć wątki, które usługa pętli.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> Argument jest <see langword="null" />.  - lub - <paramref name="parallelOptions" /> argument jest <see langword="null" />.  - lub - <paramref name="body" /> argument jest <see langword="null" />.  - lub - <paramref name="localInit" /> lub <paramref name="localFinally" /> argument jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> Właściwość <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> zwraca <see langword="false" /> lub zwraca partycjonera <see langword="null" /> partycji.</exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątki generowane we wszystkich wątkach.</exception>
        <exception cref="T:System.OperationCanceledException">
          <see cref="T:System.Threading.CancellationToken" /> w <paramref name="parallelOptions" /> argument zostanie anulowane.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.CancellationTokenSource" /> Skojarzone z <see cref="T:System.Threading.CancellationToken" /> w <paramref name="parallelOptions" /> został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów w <c>źródła</c>.</typeparam>
        <typeparam name="TLocal">Typ danych lokalnej wątku.</typeparam>
        <param name="source">Partycjonera, który zawiera oryginalnego źródła danych.</param>
        <param name="parallelOptions">Obiekt, który służy do konfigurowania zachowania tej operacji.</param>
        <param name="localInit">Delegat funkcji, która zwraca stan początkowy danych lokalnych dla każdego zadania.</param>
        <param name="body">Delegat, który jest wywoływana jeden raz na iterację.</param>
        <param name="localFinally">Delegat, który wykonuje końcowe akcję dla lokalnych stan każdego zadania.</param>
        <summary>Wykonuje <see langword="foreach" /> (<see langword="For Each" /> w języku Visual Basic) operacja z danymi lokalnymi wątku na <see cref="T:System.Collections.Concurrent.Partitioner" /> w iteracji, które mogą być wykonywane równolegle, można skonfigurować opcje pętli, a stan pętli dało się monitorować i manipulować.</summary>
        <returns>Struktura, która zawiera informacje o część pętli ukończone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie jest udostępniana dla scenariuszy, w której chcesz przesłonić domyślny schemat partycji. Na przykład małych jednostek pętli mogą skorzystać z partycjonowania zakresu. <xref:System.Threading.Tasks.Parallel.ForEach%2A> Metoda oczekuje niestandardowe partycjonery umożliwiają dynamiczne partycjonowanie. To przeciążenie jest udostępniana dla scenariuszy z małych jednostek pętli, które mogą skorzystać z partycjonowania statycznego zakresu. Partycjonery musi obsługiwać partycji dynamicznych.  Aby uzyskać więcej informacji, zobacz [niestandardowe Partycjonery dla PLINQ i TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) i [porady: Implementowanie partycji dynamicznych](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 `localInit` Obiekt delegowany jest wywoływany raz dla każdego zadania, które uczestniczy w wykonywanie pętli i zwraca początkowy stan lokalnego dla każdego z tych zadań. Te stany początkowej są przekazywane do pierwszego `body` wywołań dla każdego zadania. Każdego wywołania w treści kolejnych zwraca wartość stanu prawdopodobnie modyfikacji, który jest przekazywany do następnego wywołania treści. Na koniec ostatniego wywołania treści na każde zadanie podrzędne zwraca wartość stanu, który jest przekazywany do `localFinally` delegować. `localFinally` Obiekt delegowany jest wywoływany po poszczególnych zadań do wykonania akcji końcowego na stan lokalnego dla każdego zadania. Ten delegat może być wywoływany współbieżnie na wiele zadań; w związku z tym należy zsynchronizować dostępu do żadnych zmiennych udostępnionych.  
  
 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Metoda może używać większej liczby zadań niż wątki, w okresie istnienia działania jako istniejące zadania i są zastępowane przez nowe zadania. Dzięki temu bazowego <xref:System.Threading.Tasks.TaskScheduler> obiektu szansę, aby dodać, zmienić lub usunąć wątki, które usługa pętli.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> Argument jest <see langword="null" />.  - lub - <paramref name="parallelOptions" /> argument jest <see langword="null" />.  - lub - <paramref name="body" /> argument jest <see langword="null" />.  - lub - <paramref name="localInit" /> argument jest <see langword="null" />.  - lub - <paramref name="localFinally" /> argument jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> Właściwość <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> zwraca <see langword="false" /> lub zwraca partycjonera <see langword="null" /> partycji.</exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątki generowane we wszystkich wątkach.</exception>
        <exception cref="T:System.OperationCanceledException">
          <see cref="T:System.Threading.CancellationToken" /> w <paramref name="parallelOptions" /> argument zostanie anulowane.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.CancellationTokenSource" /> Skojarzone z <see cref="T:System.Threading.CancellationToken" /> w <paramref name="parallelOptions" /> został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ danych w źródle.</typeparam>
        <typeparam name="TLocal">Typ danych lokalnej wątku.</typeparam>
        <param name="source">Źródło danych wyliczalny.</param>
        <param name="parallelOptions">Obiekt, który służy do konfigurowania zachowania tej operacji.</param>
        <param name="localInit">Delegat funkcji, która zwraca stan początkowy danych lokalnych dla każdego zadania.</param>
        <param name="body">Delegat, który jest wywoływana jeden raz na iterację.</param>
        <param name="localFinally">Delegat, który wykonuje końcowe akcję dla lokalnych stan każdego zadania.</param>
        <summary>Wykonuje <see langword="foreach" /> (<see langword="For Each" /> w języku Visual Basic) operację, podając wątków lokalnych danych i indeksów 64-bitowych w <see cref="T:System.Collections.IEnumerable" /> w iteracji, które mogą być wykonywane równolegle, można skonfigurować opcje pętli, a stan pętli dało się monitorować i manipulować.</summary>
        <returns>Struktura, która zawiera informacje o część pętli ukończone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body` Obiekt delegowany jest wywoływany raz dla każdego elementu w `source` wyliczalny. Znajduje się z następującymi parametrami: bieżący element <xref:System.Threading.Tasks.ParallelLoopState> wystąpienie, które mogą służyć do przedwcześnie zerwać pętlę, indeks bieżącego elementu (<xref:System.Int64>), a niektóre stan lokalnego, który może być współużytkowany przez iteracje, które są wykonywane w tym samym wątku.  
  
 `localInit` Obiekt delegowany jest wywoływany raz dla każdego zadania, które uczestniczy w wykonywanie pętli i zwraca początkowy stan lokalnego dla każdego z tych zadań. Te stany początkowej są przekazywane do pierwszego `body` wywołań dla każdego zadania. Każdego wywołania w treści kolejnych zwraca wartość stanu prawdopodobnie modyfikacji, który jest przekazywany do następnego wywołania treści. Na koniec ostatniego wywołania treści na każde zadanie podrzędne zwraca wartość stanu, który jest przekazywany do `localFinally` delegować. `localFinally` Obiekt delegowany jest wywoływany raz na wątek do wykonania akcji końcowego na stan lokalnego dla każdego zadania. Ten delegat może być wywoływany współbieżnie na wiele zadań; w związku z tym należy zsynchronizować dostępu do żadnych zmiennych udostępnionych.  
  
 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Metoda może używać większej liczby zadań niż wątki, w okresie istnienia działania jako istniejące zadania i są zastępowane przez nowe zadania. Dzięki temu bazowego <xref:System.Threading.Tasks.TaskScheduler> obiektu szansę, aby dodać, zmienić lub usunąć wątki, które usługa pętli.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> Argument jest <see langword="null" />.  - lub - <paramref name="parallelOptions" /> argument jest <see langword="null" />.  - lub - <paramref name="body" /> argument jest <see langword="null" />.  - lub - <paramref name="localInit" /> argument jest <see langword="null" />.  - lub - <paramref name="localFinally" /> argument jest <see langword="null" />.</exception>
        <exception cref="T:System.OperationCanceledException">
          <see cref="T:System.Threading.CancellationToken" /> w <paramref name="parallelOptions" /> argument zostanie anulowane.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.CancellationTokenSource" /> Skojarzone z <see cref="T:System.Threading.CancellationToken" /> w <paramref name="parallelOptions" /> został usunięty.</exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątki generowane we wszystkich wątkach.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ danych w źródle.</typeparam>
        <typeparam name="TLocal">Typ danych lokalnej wątku.</typeparam>
        <param name="source">Źródło danych wyliczalny.</param>
        <param name="parallelOptions">Obiekt, który służy do konfigurowania zachowania tej operacji.</param>
        <param name="localInit">Delegat funkcji, która zwraca stan początkowy danych lokalnych dla każdego zadania.</param>
        <param name="body">Delegat, który jest wywoływana jeden raz na iterację.</param>
        <param name="localFinally">Delegat, który wykonuje końcowe akcję dla lokalnych stan każdego zadania.</param>
        <summary>Wykonuje <see langword="foreach" /> (<see langword="For Each" /> w języku Visual Basic) operacja z danymi lokalnymi wątku na <see cref="T:System.Collections.IEnumerable" /> w iteracji, które mogą być wykonywane równolegle, można skonfigurować opcje pętli, a stan pętli dało się monitorować i manipulować...</summary>
        <returns>Struktura, która zawiera informacje o część pętli ukończone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body` Obiekt delegowany jest wywoływany raz dla każdego elementu w `source` wyliczalny. Jest ona udostępniana z następującymi parametrami: bieżący element <xref:System.Threading.Tasks.ParallelLoopState> wystąpienie, które mogą służyć do zerwać pętlę przedwcześnie i niektóre stan lokalnego, który może być współużytkowany przez iteracje, które są wykonywane na tym samym wątku.  
  
 `localInit` Obiekt delegowany jest wywoływany raz dla każdego zadania, które uczestniczy w wykonywanie pętli i zwraca początkowy stan lokalnego dla każdego z tych zadań. Te stany początkowej są przekazywane do pierwszego `body` wywołań dla każdego zadania. Każdego wywołania w treści kolejnych zwraca wartość stanu prawdopodobnie modyfikacji, który jest przekazywany do następnego wywołania treści. Na koniec ostatniego wywołania treści na każde zadanie podrzędne zwraca wartość stanu, który jest przekazywany do `localFinally` delegować. `localFinally` Obiekt delegowany jest wywoływany raz na wątek do wykonania akcji końcowego na stan lokalnego dla każdego zadania. Ten delegat może być wywoływany współbieżnie na wiele zadań; w związku z tym należy zsynchronizować dostępu do żadnych zmiennych udostępnionych.  
  
 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Metoda może używać większej liczby zadań niż wątki, w okresie istnienia działania jako istniejące zadania i są zastępowane przez nowe zadania. Dzięki temu bazowego <xref:System.Threading.Tasks.TaskScheduler> obiektu szansę, aby dodać, zmienić lub usunąć wątki, które usługa pętli.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> Argument jest <see langword="null" />.  - lub - <paramref name="parallelOptions" /> argument jest <see langword="null" />.  - lub - <paramref name="body" /> argument jest <see langword="null" />.  - lub - <paramref name="localInit" /> argument jest <see langword="null" />.  - lub - <paramref name="localFinally" /> argument jest <see langword="null" />.</exception>
        <exception cref="T:System.OperationCanceledException">
          <see cref="T:System.Threading.CancellationToken" /> w <paramref name="parallelOptions" /> argument zostanie anulowane.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.CancellationTokenSource" /> Skojarzone z <see cref="T:System.Threading.CancellationToken" /> w <paramref name="parallelOptions" /> został usunięty.</exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątki generowane we wszystkich wątkach.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Invoke">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wykonuje każdego z podanych akcji prawdopodobnie równolegle.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static void Invoke (params Action[] actions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Invoke(class System.Action[] actions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.Invoke(System.Action[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Invoke (ParamArray actions As Action())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Invoke(... cli::array &lt;Action ^&gt; ^ actions);" />
      <MemberSignature Language="F#" Value="static member Invoke : Action[] -&gt; unit" Usage="System.Threading.Tasks.Parallel.Invoke actions" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="actions" Type="System.Action[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="actions">Tablica <see cref="T:System.Action" /> do wykonania.</param>
        <summary>Wykonuje każdego z podanych akcji prawdopodobnie równolegle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może służyć do wykonywania zestawu działań, potencjalnie równolegle.  
  
 Nie gwarancji są wprowadzane dotyczące zamówienia, w którym wykonywanie operacji lub czy są wykonywane równolegle. Ta metoda nie zwraca dopóki nie zakończy się każdej z podanych operacji, niezależnie od tego, czy Zakończenie występuje ze względu na zakończenie normalnych i wyjątkowych.  
  
 Aby uzyskać więcej informacji, zobacz [porady: użycie parallel_invoke podczas przeprowadzania do operacji równoległych](~/docs/standard/parallel-programming/how-to-use-parallel-invoke-to-execute-parallel-operations.md).  
  
   
  
## Examples  
 W tym przykładzie przedstawiono sposób użycia <xref:System.Threading.Tasks.Parallel.Invoke%2A> metody za pomocą innych metod, anonimowe delegaci i wyrażenia lambda.  
  
 [!code-csharp[System.Threading.Tasks.Parallel#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelinvoke.cs#01)]
 [!code-vb[System.Threading.Tasks.Parallel#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelinvoke.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="actions" /> Argument jest <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Wyjątek, który jest generowany, gdy wszystkie działania w <paramref name="actions" /> tablicy zgłasza wyjątek.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="actions" /> Tablica zawiera <see langword="null" /> elementu.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static void Invoke (System.Threading.Tasks.ParallelOptions parallelOptions, params Action[] actions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Invoke(class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action[] actions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.Invoke(System.Threading.Tasks.ParallelOptions,System.Action[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Invoke(System::Threading::Tasks::ParallelOptions ^ parallelOptions, ... cli::array &lt;Action ^&gt; ^ actions);" />
      <MemberSignature Language="F#" Value="static member Invoke : System.Threading.Tasks.ParallelOptions * Action[] -&gt; unit" Usage="System.Threading.Tasks.Parallel.Invoke (parallelOptions, actions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="actions" Type="System.Action[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="parallelOptions">Obiekt, który służy do konfigurowania zachowania tej operacji.</param>
        <param name="actions">Tablica akcje do wykonania.</param>
        <summary>Wykonuje każdego z podanych akcji, być może w sposób równoległy, chyba, że operacja została anulowana przez użytkownika.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może służyć do wykonywania zestawu działań, potencjalnie równolegle. Token anulowania przekazywany przy użyciu <xref:System.Threading.Tasks.ParallelOptions> struktura zapewnia obiekt wywołujący, aby anulować całej operacji. Aby uzyskać więcej informacji, zobacz [anulowanie w zarządzanych wątkach](~/docs/standard/threading/cancellation-in-managed-threads.md).  
  
 Nie gwarancji są wprowadzane dotyczące zamówienia, w którym wykonywanie operacji lub czy są wykonywane równolegle. Ta metoda nie zwraca dopóki nie zakończy się każdej z podanych operacji, niezależnie od tego, czy Zakończenie występuje ze względu na zakończenie normalnych i wyjątkowych.  
  
 Aby uzyskać więcej informacji, zobacz [porady: użycie parallel_invoke podczas przeprowadzania do operacji równoległych](~/docs/standard/parallel-programming/how-to-use-parallel-invoke-to-execute-parallel-operations.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <see cref="T:System.Threading.CancellationToken" /> w <paramref name="parallelOptions" /> jest ustawiona.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="actions" /> Argument jest <see langword="null" />.  - lub - <paramref name="parallelOptions" /> argument jest <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Wyjątek, który jest generowany, gdy wszystkie działania w <paramref name="actions" /> tablicy zgłasza wyjątek.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="actions" /> Tablica zawiera <see langword="null" /> elementu.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.CancellationTokenSource" /> Skojarzone z <see cref="T:System.Threading.CancellationToken" /> w <paramref name="parallelOptions" /> został usunięty.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="Parallel" FullName="System.Threading.Tasks.Parallel">
  <Metadata><Meta Name="ms.openlocfilehash" Value="9969ebfed1c4d5ee33c68817c29ef43bc01f7aa4" /><Meta Name="ms.sourcegitcommit" Value="ea104bc7868886a205b1df30baed6ca34ff70ecb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="07/20/2019" /><Meta Name="ms.locfileid" Value="68369009" /></Metadata><TypeSignature Language="C#" Value="public static class Parallel" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Parallel extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.Parallel" />
  <TypeSignature Language="VB.NET" Value="Public Class Parallel" />
  <TypeSignature Language="C++ CLI" Value="public ref class Parallel abstract sealed" />
  <TypeSignature Language="F#" Value="type Parallel = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Zapewnia obsługę pętli równoległych i regionów.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Parallel> Klasa zawiera równoległe zamienniki danych opartych na bibliotece dla typowych operacji, takich jak pętle, dla każdej pętli, i wykonywania zestawu instrukcji.  
  
   
  
## Examples  
 Ten przykład ilustruje kilka podejścia do implementowania pętli równoległej przy użyciu wielu konstrukcji językowych.  
  
 [!code-csharp[System.Threading.Tasks.Parallel#07](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelintro.cs#07)]
 [!code-vb[System.Threading.Tasks.Parallel#07](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelintro.vb#07)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Wszystkie publiczne i chronione elementy członkowskie <see cref="T:System.Threading.Tasks.Parallel" /> są bezpieczne dla wątków i mogą być używane współbieżnie z wielu wątków.</threadsafe>
    <related type="Article" href="~/docs/standard/parallel-programming/data-parallelism-task-parallel-library.md">Równoległość danych (Biblioteka zadań równoległych)</related>
    <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/Samples-for-Parallel-b4b76364">Przykłady programowania równoległego przy użyciu .NET Framework</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="For">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see langword="for" /> Wykonuje pętlę, w której iteracje mogą działać równolegle.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, Action&lt;int,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Action`2&lt;int32, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Action{System.Int32,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Integer, toExclusive As Integer, body As Action(Of Integer, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, Action&lt;int, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * Action&lt;int, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Indeks początkowy włącznie.</param>
        <param name="toExclusive">Indeks końcowy, na wyłączność.</param>
        <param name="body">Delegat, który jest wywoływany raz na iterację.</param>
        <summary><see langword="for" /> Wykonuje pętlę, w której iteracje mogą działać równolegle, a stan pętli może być monitorowany i manipulowany.</summary>
        <returns>Struktura, która zawiera informacje o tym, która część pętli została ukończona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Delegat jest wywoływany raz dla każdej wartości w zakresie iteracji (`fromInclusive`, `toExclusive`). `body` Jest on dostarczany z dwoma argumentami:  
  
-   <xref:System.Int32> Wartość, która reprezentuje liczbę iteracji.  
  
-   <xref:System.Threading.Tasks.ParallelLoopState> Wystąpienie, które może służyć do przedwczesnego przerwania pętli. <xref:System.Threading.Tasks.ParallelLoopState> Obiekt jest tworzony przez kompilator; nie można utworzyć jego wystąpienia w kodzie użytkownika.  
  
 Wywołanie metody informuje, że iteracje `for` po bieżącej operacji nie muszą zostać wykonane. <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> Jednak wszystkie iteracje przed bieżącą, będą nadal musiały zostać wykonane, jeśli jeszcze nie.  
  
 W związku z <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> tym, wywołanie jest podobne do użycia operacji Break w `for` obrębie konwencjonalnej pętli w C#języku takim jak, ale nie jest to idealne zamiennik: Na przykład nie ma gwarancji, że iteracje po bieżącej dacie nie będą wykonywane w nieskończoność.  
  
 Jeśli wykonywanie wszystkich iteracji przed bieżącą, nie jest konieczne, użyj <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> metody zamiast używać. <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> Wywołanie <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A>informujepętlę , że może porzucić wszystkie pozostałe iteracje, niezależnie od tego, czy są one przed lub po bieżącej iteracji, ponieważ wszystkie wymagane zadania zostaną już wykonane. `for` Jednak podobnie jak w <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>przypadku, nie ma gwarancji dotyczących tego, które inne iteracje nie zostaną wykonane.  
  
 Jeśli pętla kończy się przedwcześnie, <xref:System.Threading.Tasks.ParallelLoopResult> zwracana struktura będzie zawierać istotne informacje dotyczące uzupełniania pętli.  
  
 Jeśli `fromInclusive` jest większa lub `toExclusive`równa, metoda zwraca natychmiast bez wykonywania jakichkolwiek iteracji.  
  
   
  
## Examples  
 Poniższy przykład wykonuje równolegle do 100 iteracji pętli. Każda iteracja wstrzymuje się dla losowego interwału od 1 do 1 000 milisekund. Generowana losowo wartość określa, na której iteracji pętli <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> wywoływana jest metoda. Dane wyjściowe z przykładu pokazują, że żadne iteracje, których indeks jest większy niż <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A?displayProperty=nameWithType> wartość właściwości, rozpocznie się po wywołaniu <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> metody.  
  
 [!code-csharp[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/cs/break1.cs#2)]
 [!code-vb[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/vb/break1.vb#2)]  
  
 Ponieważ iteracje pętli nadal mogą być wykonywane, gdy <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> wywoływana jest metoda, każda iteracja wywołuje właściwość, aby sprawdzić, <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A?displayProperty=nameWithType> czy <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> inna iteracja nazywa metodę. Jeśli wartość właściwości jest `true`, iteracji sprawdza wartość <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A?displayProperty=nameWithType> właściwości i, jeśli jest większa niż bieżąca wartość indeksu bieżącej iteracji, zwraca natychmiast.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Argument ma wartość <see langword="null" />. <paramref name="body" /></exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątki zgłoszone we wszystkich wątkach.</exception>
        <altmember cref="T:System.Threading.Tasks.ParallelLoopState" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Pętle równoległe</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, Action&lt;int&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Action`1&lt;int32&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Action{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Integer, toExclusive As Integer, body As Action(Of Integer)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, Action&lt;int&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * Action&lt;int&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Indeks początkowy włącznie.</param>
        <param name="toExclusive">Indeks końcowy, na wyłączność.</param>
        <param name="body">Delegat, który jest wywoływany raz na iterację.</param>
        <summary><see langword="for" /> Wykonuje pętlę, w której iteracje mogą działać równolegle.</summary>
        <returns>Struktura, która zawiera informacje o tym, która część pętli została ukończona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Delegat jest wywoływany raz dla każdej wartości w zakresie iteracji (`fromInclusive`, `toExclusive`). `body` Jest on dostarczany z liczbą iteracji (<xref:System.Int32>) jako parametr.  
  
 Jeśli `fromInclusive` jest większa lub `toExclusive`równa, metoda zwraca natychmiast bez wykonywania jakichkolwiek iteracji.  
  
   
  
## Examples  
 W poniższym przykładzie zastosowano <xref:System.Threading.Tasks.Parallel.For%2A> metodę dla 100 wywołań delegata, który generuje losowe wartości bajtów i oblicza ich sumę.  
  
 [!code-csharp[System.Threading.Tasks.Parallel.For#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel.for/cs/for1.cs#1)]
 [!code-vb[System.Threading.Tasks.Parallel.For#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel.for/vb/for1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Argument ma wartość <see langword="null" />. <paramref name="body" /></exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątki zgłoszone we wszystkich wątkach.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Pętle równoległe</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, Action&lt;long,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Action`2&lt;int64, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Action{System.Int64,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Long, toExclusive As Long, body As Action(Of Long, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, Action&lt;long, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * Action&lt;int64, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Indeks początkowy włącznie.</param>
        <param name="toExclusive">Indeks końcowy, na wyłączność.</param>
        <param name="body">Delegat, który jest wywoływany raz na iterację.</param>
        <summary><see langword="for" /> Wykonuje pętlę z 64-bitowymi indeksami, w których iteracje mogą działać równolegle, a stan pętli może być monitorowany i manipulowany.</summary>
        <returns><see cref="T:System.Threading.Tasks.ParallelLoopResult" /> Struktura, która zawiera informacje na temat wykonanej części pętli.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Delegat jest wywoływany raz dla każdej wartości w zakresie iteracji (`fromInclusive`, `toExclusive`). `body` Jest on dostarczany z następującymi parametrami: liczbą iteracji (<xref:System.Int64>) <xref:System.Threading.Tasks.ParallelLoopState> i wystąpieniem, które może służyć do wcześniejszego przerwania pętli.  
  
 Wywołanie metody informuje, że iteracje `for` po bieżącej operacji nie muszą zostać wykonane, ale wszystkie iteracje przed bieżącym. <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>  
  
 W związku z tym wywołanie Break jest podobne do użycia operacji Break w obrębie `for` konwencjonalnej pętli w języku C#takim jak, ale nie jest idealnym substytutem: Na przykład nie ma gwarancji, że iteracje po bieżącej dacie nie będą wykonywane w nieskończoność.  
  
 Jeśli wykonywanie wszystkich iteracji przed bieżącą, nie jest konieczne, użyj <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> metody zamiast używać. <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> Wywołanie <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A>informujepętlę , że może porzucić wszystkie pozostałe iteracje, niezależnie od tego, czy są one przed lub po bieżącej iteracji, ponieważ wszystkie wymagane zadania zostaną już wykonane. `for` Jednak podobnie jak w <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>przypadku, nie ma gwarancji dotyczących tego, które inne iteracje nie zostaną wykonane.  
  
 Jeśli pętla kończy się przedwcześnie, <xref:System.Threading.Tasks.ParallelLoopResult> zwracana struktura będzie zawierać istotne informacje dotyczące uzupełniania pętli.  
  
 Jeśli `fromInclusive` jest większa lub `toExclusive`równa, metoda zwraca natychmiast bez wykonywania jakichkolwiek iteracji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Argument ma wartość <see langword="null" />. <paramref name="body" /></exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątki zgłoszone we wszystkich wątkach.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Pętle równoległe</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, Action&lt;long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Action`1&lt;int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Action{System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Long, toExclusive As Long, body As Action(Of Long)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, Action&lt;long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * Action&lt;int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Indeks początkowy włącznie.</param>
        <param name="toExclusive">Indeks końcowy, na wyłączność.</param>
        <param name="body">Delegat, który jest wywoływany raz na iterację.</param>
        <summary><see langword="for" /> Wykonuje pętlę z 64-bitowymi indeksami, w których iteracje mogą działać równolegle.</summary>
        <returns>Struktura, która zawiera informacje o tym, która część pętli została ukończona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Delegat jest wywoływany raz dla każdej wartości w zakresie iteracji (`fromInclusive`, `toExclusive`). `body` Jest on dostarczany z liczbą iteracji (<xref:System.Int64>) jako parametr.  
  
 Jeśli `fromInclusive` jest większa lub `toExclusive`równa, metoda zwraca natychmiast bez wykonywania jakichkolwiek iteracji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Argument ma wartość <see langword="null" />. <paramref name="body" /></exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątki zgłoszone we wszystkich wątkach.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Pętle równoległe</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;int,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;int32, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Action{System.Int32,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;int, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * System.Threading.Tasks.ParallelOptions * Action&lt;int, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Indeks początkowy włącznie.</param>
        <param name="toExclusive">Indeks końcowy, na wyłączność.</param>
        <param name="parallelOptions">Obiekt, który konfiguruje zachowanie tej operacji.</param>
        <param name="body">Delegat, który jest wywoływany raz na iterację.</param>
        <summary><see langword="for" /> Wykonuje pętlę, w której iteracje mogą działać równolegle, można skonfigurować opcje pętli, a stan pętli może być monitorowany i manipulowany.</summary>
        <returns>Struktura, która zawiera informacje o tym, która część pętli została ukończona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Delegat jest wywoływany raz dla każdej wartości w zakresie iteracji (`fromInclusive`, `toExclusive`). `body` Jest on dostarczany z następującymi parametrami: liczbą iteracji (<xref:System.Int32>) <xref:System.Threading.Tasks.ParallelLoopState> i wystąpieniem, które może służyć do wcześniejszego przerwania pętli.  
  
 Jeśli `fromInclusive` jest większa lub `toExclusive`równa, metoda zwraca natychmiast bez wykonywania jakichkolwiek iteracji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><see cref="T:System.Threading.CancellationToken" /> W<paramref name="parallelOptions" /> argumencie zostanie anulowana.</exception>
        <exception cref="T:System.ArgumentNullException">Argument ma wartość <see langword="null" />. <paramref name="body" />  
  
—lub— 
Argument ma wartość <see langword="null" />. <paramref name="parallelOptions" /></exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątki zgłoszone we wszystkich wątkach.</exception>
        <exception cref="T:System.ObjectDisposedException">Skojarzona z elementem <paramref name="parallelOptions" /> w został usunięty. <see cref="T:System.Threading.CancellationToken" /> <see cref="T:System.Threading.CancellationTokenSource" /></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Pętle równoległe</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;int&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;int32&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Action{System.Int32})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;int&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * System.Threading.Tasks.ParallelOptions * Action&lt;int&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Indeks początkowy włącznie.</param>
        <param name="toExclusive">Indeks końcowy, na wyłączność.</param>
        <param name="parallelOptions">Obiekt, który konfiguruje zachowanie tej operacji.</param>
        <param name="body">Delegat, który jest wywoływany raz na iterację.</param>
        <summary><see langword="for" /> Wykonuje pętlę, w której iteracje mogą działać równolegle i można skonfigurować opcje pętli.</summary>
        <returns>Struktura, która zawiera informacje o tym, która część pętli została ukończona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Delegat jest wywoływany raz dla każdej wartości w zakresie iteracji (`fromInclusive`, `toExclusive`). `body` Jest on dostarczany z liczbą iteracji (<xref:System.Int32>) jako parametr.  
  
 Jeśli `fromInclusive` jest większa lub `toExclusive`równa, metoda zwraca natychmiast bez wykonywania jakichkolwiek iteracji.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak anulować pętlę równoległą:  
  
 [!code-csharp[System.Threading.Tasks.Parallel#05](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelforcancel.cs#05)]
 [!code-vb[System.Threading.Tasks.Parallel#05](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelforcancel.vb#05)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><see cref="T:System.Threading.CancellationToken" /> W<paramref name="parallelOptions" /> argumencie zostanie anulowana.</exception>
        <exception cref="T:System.ArgumentNullException">Argument ma wartość <see langword="null" />. <paramref name="body" />  
  
—lub— 
Argument ma wartość <see langword="null" />. <paramref name="parallelOptions" /></exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątki zgłoszone we wszystkich wątkach.</exception>
        <exception cref="T:System.ObjectDisposedException">Skojarzona z elementem <paramref name="parallelOptions" /> w został usunięty. <see cref="T:System.Threading.CancellationToken" /> <see cref="T:System.Threading.CancellationTokenSource" /></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Pętle równoległe</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;long,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;int64, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Action{System.Int64,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;long, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * System.Threading.Tasks.ParallelOptions * Action&lt;int64, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Indeks początkowy włącznie.</param>
        <param name="toExclusive">Indeks końcowy, na wyłączność.</param>
        <param name="parallelOptions">Obiekt, który konfiguruje zachowanie tej operacji.</param>
        <param name="body">Delegat, który jest wywoływany raz na iterację.</param>
        <summary><see langword="for" /> Wykonuje pętlę z 64-bitowymi indeksami, w których iteracje mogą działać równolegle, można skonfigurować opcje pętli, a stan pętli może być monitorowany i manipulowany.</summary>
        <returns>Struktura, która zawiera informacje o tym, która część pętli została ukończona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Delegat jest wywoływany raz dla każdej wartości w zakresie iteracji (`fromInclusive`, `toExclusive`). `body` Jest on dostarczany z następującymi parametrami: liczbą iteracji (<xref:System.Int64>) <xref:System.Threading.Tasks.ParallelLoopState> i wystąpieniem, które może służyć do wcześniejszego przerwania pętli.  
  
 Jeśli `fromInclusive` jest większa lub `toExclusive`równa, metoda zwraca natychmiast bez wykonywania jakichkolwiek iteracji.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> jak używać metody <xref:System.Threading.Tasks.ParallelOptions> z obiektem:  
  
 [!code-csharp[System.Threading.Tasks.Parallel#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelfor.cs#03)]
 [!code-vb[System.Threading.Tasks.Parallel#03](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelfor.vb#03)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><see cref="T:System.Threading.CancellationToken" /> W<paramref name="parallelOptions" /> argumencie zostanie anulowana.</exception>
        <exception cref="T:System.ArgumentNullException">Argument ma wartość <see langword="null" />. <paramref name="body" />  
  
—lub— 
Argument ma wartość <see langword="null" />. <paramref name="parallelOptions" /></exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątki zgłoszone we wszystkich wątkach.</exception>
        <exception cref="T:System.ObjectDisposedException">Skojarzona z elementem <paramref name="parallelOptions" /> w został usunięty. <see cref="T:System.Threading.CancellationToken" /> <see cref="T:System.Threading.CancellationTokenSource" /></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Pętle równoległe</related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Action{System.Int64})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * System.Threading.Tasks.ParallelOptions * Action&lt;int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Indeks początkowy włącznie.</param>
        <param name="toExclusive">Indeks końcowy, na wyłączność.</param>
        <param name="parallelOptions">Obiekt, który konfiguruje zachowanie tej operacji.</param>
        <param name="body">Delegat, który jest wywoływany raz na iterację.</param>
        <summary><see langword="for" /> Wykonuje pętlę z 64-bitowymi indeksami, w których iteracje mogą być uruchamiane równolegle i można skonfigurować opcje pętli.</summary>
        <returns>Struktura, która zawiera informacje o tym, która część pętli została ukończona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obsługuje indeksy 64-bitowe. Delegat jest wywoływany raz dla każdej wartości w zakresie iteracji (`fromInclusive`, `toExclusive`). `body` Jest on dostarczany z liczbą iteracji (<xref:System.Int64>) jako parametr.  
  
 Jeśli `fromInclusive` jest większa lub `toExclusive`równa, metoda zwraca natychmiast bez wykonywania jakichkolwiek iteracji.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać <xref:System.Threading.Tasks.ParallelOptions> do określania niestandardowego harmonogramu zadań:  
  
 [!code-csharp[System.Threading.Tasks.Parallel#06](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelforwithscheduler.cs#06)]
 [!code-vb[System.Threading.Tasks.Parallel#06](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelforwithscheduler.vb#06)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><see cref="T:System.Threading.CancellationToken" /> W<paramref name="parallelOptions" /> argumencie zostanie anulowana.</exception>
        <exception cref="T:System.ArgumentNullException">Argument ma wartość <see langword="null" />. <paramref name="body" />  
  
—lub— 
Argument ma wartość <see langword="null" />. <paramref name="parallelOptions" /></exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątki zgłoszone we wszystkich wątkach.</exception>
        <exception cref="T:System.ObjectDisposedException">Skojarzona z elementem <paramref name="parallelOptions" /> w został usunięty. <see cref="T:System.Threading.CancellationToken" /> <see cref="T:System.Threading.CancellationTokenSource" /></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Pętle równoległe</related>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (int fromInclusive, int toExclusive, Func&lt;TLocal&gt; localInit, Func&lt;int,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int32 fromInclusive, int32 toExclusive, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int32, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int32,System.Int32,System.Func{``0},System.Func{System.Int32,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For(Of TLocal) (fromInclusive As Integer, toExclusive As Integer, localInit As Func(Of TLocal), body As Func(Of Integer, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, Func&lt;TLocal&gt; ^ localInit, Func&lt;int, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int * int * Func&lt;'Local&gt; * Func&lt;int, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int32,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal">Typ danych lokalnych wątku.</typeparam>
        <param name="fromInclusive">Indeks początkowy włącznie.</param>
        <param name="toExclusive">Indeks końcowy, na wyłączność.</param>
        <param name="localInit">Delegat funkcji, który zwraca początkowy stan danych lokalnych dla każdego zadania.</param>
        <param name="body">Delegat, który jest wywoływany raz na iterację.</param>
        <param name="localFinally">Delegat, który wykonuje ostateczną akcję na lokalnym stanie każdego zadania.</param>
        <summary><see langword="for" /> Wykonuje pętlę z danymi lokalnymi wątku, w których iteracje mogą działać równolegle, a stan pętli może być monitorowany i manipulowany.</summary>
        <returns>Struktura, która zawiera informacje o tym, która część pętli została ukończona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Delegat jest wywoływany raz dla każdej wartości w zakresie iteracji (`fromInclusive`, `toExclusive`). `body` Jest on dostarczany z następującymi parametrami: licznik iteracji (<xref:System.Int32>) <xref:System.Threading.Tasks.ParallelLoopState> , wystąpienie, które może służyć do wypełniania pętli przedwcześnie i niektórych stanów lokalnych, które mogą być współużytkowane przez iteracje wykonywane w tym samym wątku.  
  
 `localInit` Delegat jest wywoływany jednokrotnie dla każdego zadania, które uczestniczy w wykonaniu pętli i zwraca początkowy stan lokalny dla każdego z tych zadań. Te Stany początkowe są przesyłane do pierwszych `body` wywołań każdego zadania. Następnie każde kolejne wywołanie treści zwróci prawdopodobnie zmodyfikowaną wartość stanu, która jest przenoszona do następnego wywołania treści. Na koniec ostatnie wywołanie treści dla każdego zadania zwraca wartość stanu, która jest przenoszona do `localFinally` delegata. `localFinally` Delegat jest wywoływany raz na zadanie w celu wykonania końcowej akcji na lokalnym stanie każdego zadania. Ten delegat może być wywoływany współbieżnie dla wielu zadań; w związku z tym należy synchronizować dostęp do dowolnych zmiennych udostępnionych.  
  
 <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> Metoda może korzystać z większej liczby zadań niż wątki w okresie istnienia wykonywania, ponieważ istniejące zadania zostały ukończone i są zastępowane przez nowe zadania. Dzięki temu obiekt źródłowy <xref:System.Threading.Tasks.TaskScheduler> może dodawać, zmieniać lub usuwać wątki obsługujące pętlę.  
  
 Jeśli `fromInclusive` jest większa lub `toExclusive`równa, metoda zwraca natychmiast bez wykonywania jakichkolwiek iteracji.  
  
 Aby zapoznać się z przykładem korzystającym z [tej metody, zobacz How to: Napisz Parallel. for pętlę ze zmiennymi](~/docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md)lokalnymi wątku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Argument ma wartość <see langword="null" />. <paramref name="body" />  
  
—lub— 
Argument ma wartość <see langword="null" />. <paramref name="localInit" />  
  
—lub— 
Argument ma wartość <see langword="null" />. <paramref name="localFinally" /></exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątki zgłoszone we wszystkich wątkach.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Pętle równoległe</related>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (long fromInclusive, long toExclusive, Func&lt;TLocal&gt; localInit, Func&lt;long,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int64 fromInclusive, int64 toExclusive, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int64, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int64,System.Int64,System.Func{``0},System.Func{System.Int64,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For(Of TLocal) (fromInclusive As Long, toExclusive As Long, localInit As Func(Of TLocal), body As Func(Of Long, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, Func&lt;TLocal&gt; ^ localInit, Func&lt;long, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * Func&lt;'Local&gt; * Func&lt;int64, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int64,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal">Typ danych lokalnych wątku.</typeparam>
        <param name="fromInclusive">Indeks początkowy włącznie.</param>
        <param name="toExclusive">Indeks końcowy, na wyłączność.</param>
        <param name="localInit">Delegat funkcji, który zwraca początkowy stan danych lokalnych dla każdego zadania.</param>
        <param name="body">Delegat, który jest wywoływany raz na iterację.</param>
        <param name="localFinally">Delegat, który wykonuje ostateczną akcję na lokalnym stanie każdego zadania.</param>
        <summary><see langword="for" /> Wykonuje pętlę z 64-bitowymi indeksami i danymi lokalnymi wątku, w których iteracje mogą działać równolegle, a stan pętli może być monitorowany i manipulowany.</summary>
        <returns>Struktura, która zawiera informacje o tym, która część pętli została ukończona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Delegat jest wywoływany raz dla każdej wartości w zakresie iteracji (`fromInclusive`, `toExclusive`). `body` Jest on dostarczany z następującymi parametrami: licznik iteracji (<xref:System.Int64>) <xref:System.Threading.Tasks.ParallelLoopState> , wystąpienie, które może służyć do wypełniania pętli przedwcześnie i niektórych stanów lokalnych, które mogą być współużytkowane przez iteracje wykonywane w ramach tego samego zadania.  
  
 `localInit` Delegat jest wywoływany jednokrotnie dla każdego zadania, które uczestniczy w wykonaniu pętli i zwraca początkowy stan lokalny dla każdego z tych zadań. Te Stany początkowe są przesyłane do pierwszych `body` wywołań każdego zadania. Następnie każde kolejne wywołanie treści zwróci prawdopodobnie zmodyfikowaną wartość stanu, która jest przenoszona do następnego wywołania treści. Na koniec ostatnie wywołanie treści dla każdego zadania zwraca wartość stanu, która jest przenoszona do `localFinally` delegata. `localFinally` Delegat jest wywoływany raz na zadanie w celu wykonania końcowej akcji na lokalnym stanie każdego zadania. Ten delegat może być wywoływany współbieżnie dla wielu zadań; w związku z tym należy synchronizować dostęp do dowolnych zmiennych udostępnionych.  
  
 <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> Metoda może korzystać z większej liczby zadań niż wątki w okresie istnienia wykonywania, ponieważ istniejące zadania zostały ukończone i są zastępowane przez nowe zadania. Dzięki temu obiekt źródłowy <xref:System.Threading.Tasks.TaskScheduler> może dodawać, zmieniać lub usuwać wątki obsługujące pętlę.  
  
 Jeśli `fromInclusive` jest większa lub `toExclusive`równa, metoda zwraca natychmiast bez wykonywania jakichkolwiek iteracji.  
  
 Aby zapoznać się z przykładem korzystającym z [tej metody, zobacz How to: Napisz Parallel. for pętlę ze zmiennymi](~/docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md)lokalnymi wątku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Argument ma wartość <see langword="null" />. <paramref name="body" />  
  
—lub— 
Argument ma wartość <see langword="null" />. <paramref name="localInit" />  
  
—lub— 
Argument ma wartość <see langword="null" />. <paramref name="localFinally" /></exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątki zgłoszone we wszystkich wątkach.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Pętle równoległe</related>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (int fromInclusive, int toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;int,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int32 fromInclusive, int32 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int32, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Func{``0},System.Func{System.Int32,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;int, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int * int * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;int, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int32,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal">Typ danych lokalnych wątku.</typeparam>
        <param name="fromInclusive">Indeks początkowy włącznie.</param>
        <param name="toExclusive">Indeks końcowy, na wyłączność.</param>
        <param name="parallelOptions">Obiekt, który konfiguruje zachowanie tej operacji.</param>
        <param name="localInit">Delegat funkcji, który zwraca początkowy stan danych lokalnych dla każdego zadania.</param>
        <param name="body">Delegat, który jest wywoływany raz na iterację.</param>
        <param name="localFinally">Delegat, który wykonuje ostateczną akcję na lokalnym stanie każdego zadania.</param>
        <summary><see langword="for" /> Wykonuje pętlę z danymi lokalnymi wątku, w których iteracje mogą działać równolegle, można skonfigurować opcje pętli, a stan pętli może być monitorowany i manipulowany.</summary>
        <returns>Struktura, która zawiera informacje o tym, która część pętli została ukończona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Delegat jest wywoływany raz dla każdej wartości w zakresie iteracji (`fromInclusive`, `toExclusive`). `body` Jest on dostarczany z następującymi parametrami: licznik iteracji (<xref:System.Int32>) <xref:System.Threading.Tasks.ParallelLoopState> , wystąpienie, które może służyć do wypełniania pętli przedwcześnie i niektórych stanów lokalnych, które mogą być współużytkowane przez iteracje wykonywane w ramach tego samego zadania.  
  
 `localInit` Delegat jest wywoływany jednokrotnie dla każdego zadania, które uczestniczy w wykonaniu pętli i zwraca początkowy stan lokalny dla każdego z tych zadań. Te Stany początkowe są przesyłane do pierwszych `body` wywołań każdego zadania. Następnie każde kolejne wywołanie treści zwróci prawdopodobnie zmodyfikowaną wartość stanu, która jest przenoszona do następnego wywołania treści. Na koniec ostatnie wywołanie treści dla każdego zadania zwraca wartość stanu, która jest przenoszona do `localFinally` delegata. `localFinally` Delegat jest wywoływany raz na zadanie w celu wykonania końcowej akcji na lokalnym stanie każdego zadania. Ten delegat może być wywoływany współbieżnie w wielu wątkach; w związku z tym należy synchronizować dostęp do dowolnych zmiennych udostępnionych.  
  
 <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> Metoda może korzystać z większej liczby zadań niż wątki w okresie istnienia wykonywania, ponieważ istniejące zadania zostały ukończone i są zastępowane przez nowe zadania. Dzięki temu obiekt źródłowy <xref:System.Threading.Tasks.TaskScheduler> może dodawać, zmieniać lub usuwać wątki obsługujące pętlę.  
  
 Jeśli `fromInclusive` jest większa lub `toExclusive`równa, metoda zwraca natychmiast bez wykonywania jakichkolwiek iteracji.  
  
   
  
## Examples  
 W poniższym przykładzie zastosowano zmienne lokalne wątku w celu obliczenia sumy wyników wielu długotrwałych operacji. Ten przykład ogranicza stopień równoległości do czterech.  
  
 [!code-csharp[System.Threading.Tasks.Parallel#04](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/threadlocalforwithoptions.cs#04)]
 [!code-vb[System.Threading.Tasks.Parallel#04](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/threadlocalforwithoptions.vb#04)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Argument ma wartość <see langword="null" />. <paramref name="body" />  
  
—lub— 
Argument ma wartość <see langword="null" />. <paramref name="localInit" />  
  
—lub— 
Argument ma wartość <see langword="null" />. <paramref name="localFinally" />  
  
—lub— 
Argument ma wartość <see langword="null" />. <paramref name="parallelOptions" /></exception>
        <exception cref="T:System.OperationCanceledException"><see cref="T:System.Threading.CancellationToken" /> W<paramref name="parallelOptions" /> argumencie zostanie anulowana.</exception>
        <exception cref="T:System.ObjectDisposedException">Skojarzona z elementem <paramref name="parallelOptions" /> w został usunięty. <see cref="T:System.Threading.CancellationToken" /> <see cref="T:System.Threading.CancellationTokenSource" /></exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątki zgłoszone we wszystkich wątkach.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Pętle równoległe</related>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (long fromInclusive, long toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;long,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int64 fromInclusive, int64 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int64, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Func{``0},System.Func{System.Int64,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;long, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;int64, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int64,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal">Typ danych lokalnych wątku.</typeparam>
        <param name="fromInclusive">Indeks początkowy włącznie.</param>
        <param name="toExclusive">Indeks końcowy, na wyłączność.</param>
        <param name="parallelOptions">Obiekt, który konfiguruje zachowanie tej operacji.</param>
        <param name="localInit">Delegat funkcji, który zwraca początkowy stan danych lokalnych dla każdego wątku.</param>
        <param name="body">Delegat, który jest wywoływany raz na iterację.</param>
        <param name="localFinally">Delegat wykonujący ostateczną akcję dla stanu lokalnego każdego wątku.</param>
        <summary><see langword="for" /> Wykonuje pętlę z 64-bitowymi indeksami i danymi lokalnymi wątku, w których iteracje mogą działać równolegle, można skonfigurować opcje pętli, a stan pętli można monitorować i manipulować.</summary>
        <returns>Struktura, która zawiera informacje o tym, która część pętli została ukończona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Delegat jest wywoływany raz dla każdej wartości w zakresie iteracji (`fromInclusive`, `toExclusive`). `body` Jest on dostarczany z następującymi parametrami: licznik iteracji (<xref:System.Int64>) <xref:System.Threading.Tasks.ParallelLoopState> , wystąpienie, które może służyć do wypełniania pętli przedwcześnie i niektórych stanów lokalnych, które mogą być współużytkowane przez iteracje wykonywane w tym samym wątku.  
  
 `localInit` Delegat jest wywoływany raz dla każdego wątku, który uczestniczy w wykonaniu pętli i zwraca początkowy stan lokalny dla każdego z tych wątków. Te Stany początkowe są przesyłane do pierwszego `body` wywołania w każdym wątku. Następnie każde kolejne wywołanie treści zwróci prawdopodobnie zmodyfikowaną wartość stanu, która jest przenoszona do następnego wywołania treści. Na koniec ostatnie wywołanie treści dla każdego wątku zwraca wartość stanu, która jest przenoszona do `localFinally` delegata. `localFinally` Delegat jest wywoływany raz na wątek, aby wykonać ostateczną akcję na stanie lokalnym każdego wątku. Ten delegat może być wywoływany współbieżnie w wielu wątkach; w związku z tym należy synchronizować dostęp do dowolnych zmiennych udostępnionych.  
  
 <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> Metoda może korzystać z większej liczby zadań niż wątki w okresie istnienia wykonywania, ponieważ istniejące zadania zostały ukończone i są zastępowane przez nowe zadania. Dzięki temu obiekt źródłowy <xref:System.Threading.Tasks.TaskScheduler> może dodawać, zmieniać lub usuwać wątki obsługujące pętlę.  
  
 Jeśli `fromInclusive` jest większa lub `toExclusive`równa, metoda zwraca natychmiast bez wykonywania jakichkolwiek iteracji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Argument ma wartość <see langword="null" />. <paramref name="body" />  
  
—lub— 
Argument ma wartość <see langword="null" />. <paramref name="localInit" />  
  
—lub— 
Argument ma wartość <see langword="null" />. <paramref name="localFinally" />  
  
—lub— 
Argument ma wartość <see langword="null" />. <paramref name="parallelOptions" /></exception>
        <exception cref="T:System.OperationCanceledException"><see cref="T:System.Threading.CancellationToken" /> W<paramref name="parallelOptions" /> argumencie zostanie anulowana.</exception>
        <exception cref="T:System.ObjectDisposedException">Skojarzona z elementem <paramref name="parallelOptions" /> w został usunięty. <see cref="T:System.Threading.CancellationToken" /> <see cref="T:System.Threading.CancellationTokenSource" /></exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątki zgłoszone we wszystkich wątkach.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Pętle równoległe</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ForEach&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wykonuje operację<see langword="For Each " /> (w Visual Basic), w której iteracje mogą być uruchamiane równolegle. <see langword="foreach" /></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.OrderablePartitioner{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As OrderablePartitioner(Of TSource), body As Action(Of TSource, ParallelLoopState, Long)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów w <paramref name="source" />.</typeparam>
        <param name="source">Uporządkowana partycja, która zawiera oryginalne źródło danych.</param>
        <param name="body">Delegat, który jest wywoływany raz na iterację.</param>
        <summary>Wykonuje operację<see langword="For Each" /> <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> (w Visual Basic), w której iteracje mogą działać równolegle, a stan pętli może być monitorowany i manipulowany. <see langword="foreach" /></summary>
        <returns>Struktura, która zawiera informacje o tym, która część pętli została ukończona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie jest dostępne dla scenariuszy, w których chcesz przesłonić domyślny schemat partycjonowania. Na przykład małe treści pętli mogą korzystać z partycjonowania zakresu. Metoda <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> oczekuje, że niestandardowe partycje obsługują partycjonowanie dynamiczne. Aby uzyskać więcej informacji, zobacz [niestandardowe partycje dla PLINQ i TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) i [instrukcje: Implementowanie partycji](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)dynamicznych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Argument ma wartość <see langword="null" />. <paramref name="source" />  
  
—lub— 
Argument ma wartość <see langword="null" />. <paramref name="body" /></exception>
        <exception cref="T:System.InvalidOperationException">Właściwość w <paramref name="source" /> powrocie<see langword="false" />do kolejności partycjonowania. <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" />  
  
—lub— 
Właściwość w źródłowym partycjonowanym partycji zwraca <see langword="false" />. <see cref="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysNormalized" />  
  
—lub— 
Wszelkie metody w powrocie <see langword="null" />do pożądanej partycji.</exception>
        <exception cref="T:System.AggregateException">Wyjątek zgłoszony przez jednego z określonych delegatów.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Pętle równoległe</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As Partitioner(Of TSource), body As Action(Of TSource, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów w <paramref name="source" />.</typeparam>
        <param name="source">Partycja zawierająca oryginalne źródło danych.</param>
        <param name="body">Delegat, który jest wywoływany raz na iterację.</param>
        <summary>Wykonuje operację<see langword="For Each" /> <see cref="T:System.Collections.Concurrent.Partitioner" /> (w Visual Basic) na, w której iteracje mogą działać równolegle, a stan pętli może być monitorowany i manipulowany. <see langword="foreach" /></summary>
        <returns>Struktura, która zawiera informacje o tym, która część pętli została ukończona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie jest dostępne dla scenariuszy, w których chcesz przesłonić domyślny schemat partycjonowania. Na przykład małe treści pętli mogą korzystać z partycjonowania zakresu. Metoda <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> oczekuje, że niestandardowe partycje obsługują partycjonowanie dynamiczne. Aby uzyskać więcej informacji, zobacz [niestandardowe partycje dla PLINQ i TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) i [instrukcje: Implementowanie partycji](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)dynamicznych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Argument ma wartość <see langword="null" />. <paramref name="source" />  
  
—lub— 
Argument ma wartość <see langword="null" />. <paramref name="body" /></exception>
        <exception cref="T:System.InvalidOperationException">Właściwość w programie Partitioner<see langword="false" />zwraca wartość. <paramref name="source" /> <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" />  
  
—lub— 
Metoda w programie <paramref name="source" /> Partitioner zwraca wartość <see langword="null" />.  
  
—lub— 
<see cref="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)" /> Metoda<paramref name="source" /> w programie partitioner nie zwraca poprawnej liczby partycji.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Pętle równoległe</related>
        <exception cref="T:System.AggregateException">Wyjątek, który jest generowany, zawiera wyjątek zgłoszony z jednego z określonych delegatów.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As Partitioner(Of TSource), body As Action(Of TSource)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów w <paramref name="source" />.</typeparam>
        <param name="source">Partycja zawierająca oryginalne źródło danych.</param>
        <param name="body">Delegat, który jest wywoływany raz na iterację.</param>
        <summary>Wykonuje operację<see langword="For Each" /> <see cref="T:System.Collections.Concurrent.Partitioner" /> (w Visual Basic) na, w której iteracje mogą być uruchamiane równolegle. <see langword="foreach" /></summary>
        <returns>Struktura, która zawiera informacje o tym, która część pętli została ukończona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie jest dostępne dla scenariuszy, w których chcesz przesłonić domyślny schemat partycjonowania. Na przykład małe treści pętli mogą korzystać z partycjonowania zakresu. Metoda <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> oczekuje, że niestandardowe partycje obsługują partycjonowanie dynamiczne. Aby uzyskać więcej informacji, zobacz [niestandardowe partycje dla PLINQ i TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) i [instrukcje: Implementowanie partycji](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)dynamicznych.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak zaimplementować zakres partycji do użycia z <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>:  
  
 [!code-csharp[System.Threading.Tasks.Parallel_RangePartitioners#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel_rangepartitioners/cs/rangepartitioner.cs#01)]
 [!code-vb[System.Threading.Tasks.Parallel_RangePartitioners#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel_rangepartitioners/vb/rangepart.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Argument ma wartość <see langword="null" />. <paramref name="source" />  
  
—lub— 
Argument ma wartość <see langword="null" />. <paramref name="body" /></exception>
        <exception cref="T:System.InvalidOperationException">Właściwość w programie Partitioner<see langword="false" />zwraca wartość. <paramref name="source" /> <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" />  
  
—lub— 
Wyjątek, który jest generowany, gdy wszystkie metody w <paramref name="source" /> programie Partitioner <see langword="null" />zwracają.  
  
—lub— 
<see cref="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)" /> Metoda<paramref name="source" /> w programie partitioner nie zwraca poprawnej liczby partycji.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Pętle równoległe</related>
        <exception cref="T:System.AggregateException">Wyjątek, który jest generowany, zawiera wyjątek zgłoszony z jednego z określonych delegatów.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As IEnumerable(Of TSource), body As Action(Of TSource, ParallelLoopState, Long)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ danych w źródle.</typeparam>
        <param name="source">Wyliczalne źródło danych.</param>
        <param name="body">Delegat, który jest wywoływany raz na iterację.</param>
        <summary>Wykonuje operację<see langword="For Each" /> <see cref="T:System.Collections.IEnumerable" /> (w Visual Basic) z indeksami 64-bitowymi, w których iteracje mogą działać równolegle, a stan pętli może być monitorowany i manipulowany. <see langword="foreach" /></summary>
        <returns>Struktura, która zawiera informacje o tym, która część pętli została ukończona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Delegat jest wywoływany jednokrotnie dla każdego elementu `source` w wyliczalnym. `body` Jest on dostarczany z następującymi parametrami: bieżącym elementem, <xref:System.Threading.Tasks.ParallelLoopState> wystąpieniem, które może być używane do wypełniania pętli przedwcześnie i indeksu bieżącego elementu (<xref:System.Int64>).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Argument ma wartość <see langword="null" />. <paramref name="source" />  
  
—lub— 
Argument ma wartość <see langword="null" />. <paramref name="body" /></exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątki zgłoszone we wszystkich wątkach.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Pętle równoległe</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As IEnumerable(Of TSource), body As Action(Of TSource, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ danych w źródle.</typeparam>
        <param name="source">Wyliczalne źródło danych.</param>
        <param name="body">Delegat, który jest wywoływany raz na iterację.</param>
        <summary>Wykonuje operację <see langword="foreach" /> (<see langword="For Each" /> w<see cref="T:System.Collections.IEnumerable" /> Visual Basic), w której iteracje mogą działać równolegle, a stan pętli może być monitorowany i manipulowany.</summary>
        <returns>Struktura, która zawiera informacje o tym, która część pętli została ukończona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Delegat jest wywoływany jednokrotnie dla każdego elementu `source` w wyliczalnym. `body` Jest on dostarczany z następującymi parametrami: bieżącym elementem oraz <xref:System.Threading.Tasks.ParallelLoopState> wystąpieniem, które może służyć do wcześniejszego przerwania pętli.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Argument ma wartość <see langword="null" />. <paramref name="source" />  
  
—lub— 
Argument ma wartość <see langword="null" />. <paramref name="body" /></exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątki zgłoszone we wszystkich wątkach.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Pętle równoległe</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As IEnumerable(Of TSource), body As Action(Of TSource)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ danych w źródle.</typeparam>
        <param name="source">Wyliczalne źródło danych.</param>
        <param name="body">Delegat, który jest wywoływany raz na iterację.</param>
        <summary>Wykonuje operację <see langword="foreach" /> (<see langword="For Each" /> w<see cref="T:System.Collections.IEnumerable" /> Visual Basic), w której iteracje mogą działać równolegle.</summary>
        <returns>Struktura, która zawiera informacje o tym, która część pętli została ukończona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Delegat jest wywoływany jednokrotnie dla każdego elementu `source` w wyliczalnym. `body` Jest on dostarczany z bieżącym elementem jako parametr.  
  
   
  
## Examples  
 W poniższym przykładzie zastosowano <xref:System.Threading.Tasks.Parallel.ForEach%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Action%7B%60%600%7D%29> metodę, aby policzyć liczbę samogłosek i niebiałych znaków w pliku tekstowym. W takim przypadku <xref:System.Threading.Tasks.ParallelLoopResult> wartość zwracana przez metodę jest ignorowana. Należy pamiętać, że ponieważ operacje mogą działać równolegle, należy się upewnić, że zwiększanie zmiennych licznika jest operacją niepodzielną, a wiele wątków nie próbuje uzyskać dostępu do zmiennych licznika jednocześnie. W tym celu przykład używa `lock` instrukcji (in C#) i `SyncLock` instrukcji (w Visual Basic).  
  
 [!code-csharp[System.Threading.Tasks.Parallel.ForEach#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel.foreach/cs/foreach1.cs#1)]
 [!code-vb[System.Threading.Tasks.Parallel.ForEach#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel.foreach/vb/foreach1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Argument ma wartość <see langword="null" />. <paramref name="source" />  
  
—lub— 
Argument ma wartość <see langword="null" />. <paramref name="body" /></exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątki zgłoszone we wszystkich wątkach.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Pętle równoległe</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.OrderablePartitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów w <paramref name="source" />.</typeparam>
        <param name="source">Uporządkowana partycja, która zawiera oryginalne źródło danych.</param>
        <param name="parallelOptions">Obiekt, który konfiguruje zachowanie tej operacji.</param>
        <param name="body">Delegat, który jest wywoływany raz na iterację.</param>
        <summary>Wykonuje operację<see langword="For Each" /> <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> (w Visual Basic) na, w której iteracje mogą działać równolegle, można skonfigurować opcje pętli, a stan pętli może być monitorowany i manipulowany. <see langword="foreach" /></summary>
        <returns>Struktura, która zawiera informacje o tym, która część pętli została ukończona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie jest dostępne dla scenariuszy, w których chcesz przesłonić domyślny schemat partycjonowania. Na przykład małe treści pętli mogą korzystać z partycjonowania zakresu. Metoda <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> oczekuje, że niestandardowe partycje obsługują partycjonowanie dynamiczne. Aby uzyskać więcej informacji, zobacz [niestandardowe partycje dla PLINQ i TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) i [instrukcje: Implementowanie partycji](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)dynamicznych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><see cref="T:System.Threading.CancellationToken" /> W<paramref name="parallelOptions" /> argumencie zostanie anulowana</exception>
        <exception cref="T:System.ArgumentNullException">Argument ma wartość <see langword="null" />. <paramref name="source" />  
  
—lub— 
Argument ma wartość <see langword="null" />. <paramref name="parallelOptions" />  
  
—lub— 
Argument ma wartość <see langword="null" />. <paramref name="body" /></exception>
        <exception cref="T:System.ObjectDisposedException">Skojarzona z elementem <paramref name="parallelOptions" /> w został usunięty. <see cref="T:System.Threading.CancellationToken" /> <see cref="T:System.Threading.CancellationTokenSource" /></exception>
        <exception cref="T:System.InvalidOperationException">Właściwość w <paramref name="source" /> powrocie<see langword="false" />do kolejności partycjonowania. <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" />  
  
—lub— 
Właściwość w <paramref name="source" /> powrocie<see langword="false" />do kolejności partycjonowania. <see cref="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysNormalized" />  
  
—lub— 
Wyjątek, który jest generowany, gdy wszystkie metody w <paramref name="source" /> powrocie do podzielenia na partycje są zwracane. <see langword="null" /></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Pętle równoległe</related>
        <exception cref="T:System.AggregateException">Wyjątek, który jest generowany, zawiera wyjątek zgłoszony z jednego z określonych delegatów.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów w <paramref name="source" />.</typeparam>
        <param name="source">Partycja zawierająca oryginalne źródło danych.</param>
        <param name="parallelOptions">Obiekt, który konfiguruje zachowanie tej operacji.</param>
        <param name="body">Delegat, który jest wywoływany raz na iterację.</param>
        <summary>Wykonuje operację<see langword="For Each" /> <see cref="T:System.Collections.Concurrent.Partitioner" /> (w Visual Basic) na, w której iteracje mogą działać równolegle, można skonfigurować opcje pętli, a stan pętli może być monitorowany i manipulowany. <see langword="foreach" /></summary>
        <returns>Struktura, która zawiera informacje o tym, która część pętli została ukończona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie jest dostępne dla scenariuszy, w których chcesz przesłonić domyślny schemat partycjonowania. Na przykład małe treści pętli mogą korzystać z partycjonowania zakresu. Metoda <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> oczekuje, że niestandardowe partycje obsługują partycjonowanie dynamiczne. Aby uzyskać więcej informacji, zobacz [niestandardowe partycje dla PLINQ i TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) i [instrukcje: Implementowanie partycji](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)dynamicznych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><see cref="T:System.Threading.CancellationToken" /> W<paramref name="parallelOptions" /> argumencie zostanie anulowana.</exception>
        <exception cref="T:System.ObjectDisposedException">Skojarzona z elementem <paramref name="parallelOptions" /> w został usunięty. <see cref="T:System.Threading.CancellationToken" /> <see cref="T:System.Threading.CancellationTokenSource" /></exception>
        <exception cref="T:System.ArgumentNullException">Argument ma wartość <see langword="null" />. <paramref name="source" />  
  
—lub— 
Argument ma wartość <see langword="null" />. <paramref name="parallelOptions" />  
  
—lub— 
Argument ma wartość <see langword="null" />. <paramref name="body" /></exception>
        <exception cref="T:System.InvalidOperationException">Właściwość w programie Partitioner<see langword="false" />zwraca wartość. <paramref name="source" /> <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" />  
  
—lub— 
Wyjątek, który jest generowany, gdy wszystkie metody w <paramref name="source" /> programie Partitioner <see langword="null" />zwracają.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Pętle równoległe</related>
        <exception cref="T:System.AggregateException">Wyjątek, który jest generowany, zawiera wyjątek zgłoszony z jednego z określonych delegatów.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów w <paramref name="source" />.</typeparam>
        <param name="source">Partycja zawierająca oryginalne źródło danych.</param>
        <param name="parallelOptions">Obiekt, który konfiguruje zachowanie tej operacji.</param>
        <param name="body">Delegat, który jest wywoływany raz na iterację.</param>
        <summary>Wykonuje operację<see langword="For Each" /> <see cref="T:System.Collections.Concurrent.Partitioner" /> (w Visual Basic) na, w której iteracje mogą być uruchamiane równolegle, i można skonfigurować opcje pętli. <see langword="foreach" /></summary>
        <returns>Struktura, która zawiera informacje o tym, która część pętli została ukończona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie jest dostępne dla scenariuszy, w których chcesz przesłonić domyślny schemat partycjonowania. Na przykład małe treści pętli mogą korzystać z partycjonowania zakresu. Metoda <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> oczekuje, że niestandardowe partycje obsługują partycjonowanie dynamiczne. Aby uzyskać więcej informacji, zobacz [niestandardowe partycje dla PLINQ i TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) i [instrukcje: Implementowanie partycji](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)dynamicznych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><see cref="T:System.Threading.CancellationToken" /> W<paramref name="parallelOptions" /> argumencie zostanie anulowana.</exception>
        <exception cref="T:System.ObjectDisposedException">Skojarzona z elementem <paramref name="parallelOptions" /> w został usunięty. <see cref="T:System.Threading.CancellationToken" /> <see cref="T:System.Threading.CancellationTokenSource" /></exception>
        <exception cref="T:System.ArgumentNullException">Argument ma wartość <see langword="null" />. <paramref name="source" />  
  
—lub— 
Argument ma wartość <see langword="null" />. <paramref name="parallelOptions" />  
  
—lub— 
Argument ma wartość <see langword="null" />. <paramref name="body" /></exception>
        <exception cref="T:System.InvalidOperationException">Właściwość w programie Partitioner<see langword="false" />zwraca wartość. <paramref name="source" /> <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" />  
  
—lub— 
Wyjątek, który jest generowany, gdy wszystkie metody w <paramref name="source" /> programie Partitioner <see langword="null" />zwracają.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Pętle równoległe</related>
        <exception cref="T:System.AggregateException">Wyjątek, który jest generowany, zawiera wyjątek zgłoszony z jednego z określonych delegatów.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ danych w źródle.</typeparam>
        <param name="source">Wyliczalne źródło danych.</param>
        <param name="parallelOptions">Obiekt, który konfiguruje zachowanie tej operacji.</param>
        <param name="body">Delegat, który jest wywoływany raz na iterację.</param>
        <summary>Wykonuje operację<see langword="For Each" /> <see cref="T:System.Collections.IEnumerable" /> (w Visual Basic) z indeksami 64-bitowymi w, w których iteracje mogą działać równolegle, można skonfigurować opcje pętli, a stan pętli można monitorować i manipulować. <see langword="foreach" /></summary>
        <returns>Struktura, która zawiera informacje o tym, która część pętli została ukończona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Delegat jest wywoływany jednokrotnie dla każdego elementu `source` w wyliczalnym. `body` Jest on dostarczany z następującymi parametrami: bieżącym elementem, <xref:System.Threading.Tasks.ParallelLoopState> wystąpieniem, które może być używane do wypełniania pętli przedwcześnie i indeksu bieżącego elementu (<xref:System.Int64>).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><see cref="T:System.Threading.CancellationToken" /> W<paramref name="parallelOptions" /> argumencie zostanie anulowana</exception>
        <exception cref="T:System.ArgumentNullException">Argument ma wartość <see langword="null" />. <paramref name="source" />  
  
—lub— 
Argument ma wartość <see langword="null" />. <paramref name="parallelOptions" />  
  
—lub— 
Argument ma wartość <see langword="null" />. <paramref name="body" /></exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątki zgłoszone we wszystkich wątkach.</exception>
        <exception cref="T:System.ObjectDisposedException">Skojarzona z elementem <paramref name="parallelOptions" /> w został usunięty. <see cref="T:System.Threading.CancellationToken" /> <see cref="T:System.Threading.CancellationTokenSource" /></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Pętle równoległe</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ danych w źródle.</typeparam>
        <param name="source">Wyliczalne źródło danych.</param>
        <param name="parallelOptions">Obiekt, który konfiguruje zachowanie tej operacji.</param>
        <param name="body">Delegat, który jest wywoływany raz na iterację.</param>
        <summary>Wykonuje operację <see langword="foreach" /> (<see langword="For Each" /> w<see cref="T:System.Collections.IEnumerable" /> Visual Basic) na, w której iteracje mogą działać równolegle, można skonfigurować opcje pętli, a stan pętli może być monitorowany i manipulowany.</summary>
        <returns>Struktura, która zawiera informacje o tym, która część pętli została ukończona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Delegat jest wywoływany jednokrotnie dla każdego elementu `source` w wyliczalnym. `body` Jest on dostarczany z następującymi parametrami: bieżącym elementem oraz <xref:System.Threading.Tasks.ParallelLoopState> wystąpieniem, które może służyć do wcześniejszego przerwania pętli.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><see cref="T:System.Threading.CancellationToken" /> W<paramref name="parallelOptions" /> argumencie zostanie anulowana</exception>
        <exception cref="T:System.ArgumentNullException">Argument ma wartość <see langword="null" />. <paramref name="source" />  
  
—lub— 
Argument ma wartość <see langword="null" />. <paramref name="parallelOptions" />  
  
—lub— 
Argument ma wartość <see langword="null" />. <paramref name="body" /></exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątki zgłoszone we wszystkich wątkach.</exception>
        <exception cref="T:System.ObjectDisposedException">Skojarzona z elementem <paramref name="parallelOptions" /> w został usunięty. <see cref="T:System.Threading.CancellationToken" /> <see cref="T:System.Threading.CancellationTokenSource" /></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Pętle równoległe</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ danych w źródle.</typeparam>
        <param name="source">Wyliczalne źródło danych.</param>
        <param name="parallelOptions">Obiekt, który konfiguruje zachowanie tej operacji.</param>
        <param name="body">Delegat, który jest wywoływany raz na iterację.</param>
        <summary>Wykonuje operację <see langword="foreach" /> (<see langword="For Each" /> w<see cref="T:System.Collections.IEnumerable" /> Visual Basic) na, w której iteracje mogą być uruchamiane równolegle, i można skonfigurować opcje pętli.</summary>
        <returns>Struktura, która zawiera informacje o tym, która część pętli została ukończona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Delegat jest wywoływany jednokrotnie dla każdego elementu `source` w wyliczalnym. `body` Jest on dostarczany z bieżącym elementem jako parametr.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><see cref="T:System.Threading.CancellationToken" /> W<paramref name="parallelOptions" /> argumencie zostanie anulowana</exception>
        <exception cref="T:System.ArgumentNullException">Argument ma wartość <see langword="null" />. <paramref name="source" />  
  
—lub— 
Argument ma wartość <see langword="null" />. <paramref name="parallelOptions" />  
  
—lub— 
Argument ma wartość <see langword="null" />. <paramref name="body" /></exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątki zgłoszone we wszystkich wątkach.</exception>
        <exception cref="T:System.ObjectDisposedException">Skojarzona z elementem <paramref name="parallelOptions" /> w został usunięty. <see cref="T:System.Threading.CancellationToken" /> <see cref="T:System.Threading.CancellationTokenSource" /></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Pętle równoległe</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.OrderablePartitioner{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As OrderablePartitioner(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, Long, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów w <paramref name="source" />.</typeparam>
        <typeparam name="TLocal">Typ danych lokalnych wątku.</typeparam>
        <param name="source">Uporządkowana partycja, która zawiera oryginalne źródło danych.</param>
        <param name="localInit">Delegat funkcji, który zwraca początkowy stan danych lokalnych dla każdego zadania.</param>
        <param name="body">Delegat, który jest wywoływany raz na iterację.</param>
        <param name="localFinally">Delegat, który wykonuje ostateczną akcję na lokalnym stanie każdego zadania.</param>
        <summary>Wykonuje operację<see langword="For Each" /> <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> (w Visual Basic) przy użyciu danych z wątku lokalnego, w którym iteracje mogą działać równolegle, można skonfigurować opcje pętli, a stan pętli można monitorować i manipulować. <see langword="foreach" /></summary>
        <returns>Struktura, która zawiera informacje o tym, która część pętli została ukończona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie jest dostępne dla scenariuszy, w których chcesz przesłonić domyślny schemat partycjonowania. Na przykład małe treści pętli mogą korzystać z partycjonowania zakresu. Metoda <xref:System.Threading.Tasks.Parallel.ForEach%2A> oczekuje, że niestandardowe partycje obsługują partycjonowanie dynamiczne. Aby uzyskać więcej informacji, zobacz [niestandardowe partycje dla PLINQ i TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) i [instrukcje: Implementowanie partycji](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)dynamicznych.  
  
 `localInit` Delegat jest wywoływany jednokrotnie dla każdego zadania, które uczestniczy w wykonaniu pętli i zwraca początkowy stan lokalny dla każdego z tych zadań. Te Stany początkowe są przesyłane do pierwszych `body` wywołań każdego zadania. Następnie każde kolejne wywołanie treści zwróci prawdopodobnie zmodyfikowaną wartość stanu, która jest przenoszona do następnego wywołania treści. Na koniec ostatnie wywołanie treści dla każdego zadania zwraca wartość stanu, która jest przenoszona do `localFinally` delegata. `localFinally` Delegat jest wywoływany raz na zadanie w celu wykonania końcowej akcji na lokalnym stanie każdego zadania. Ten delegat może być wywoływany współbieżnie dla wielu zadań; w związku z tym należy synchronizować dostęp do dowolnych zmiennych udostępnionych.  
  
 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Metoda może korzystać z większej liczby zadań niż wątki w okresie istnienia wykonywania, ponieważ istniejące zadania zostały ukończone i są zastępowane przez nowe zadania. Dzięki temu obiekt źródłowy <xref:System.Threading.Tasks.TaskScheduler> może dodawać, zmieniać lub usuwać wątki obsługujące pętlę.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Argument ma wartość <see langword="null" />. <paramref name="source" />  
  
—lub— 
Argument ma wartość <see langword="null" />. <paramref name="body" />  
  
—lub— 
Argument ma wartość <see langword="null" />. <paramref name="localInit" />  
  
—lub— 
Argument ma wartość <see langword="null" />. <paramref name="localFinally" /></exception>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> Właściwość w<paramref name="source" /> zwracaniu<see langword="false" /> lub partycji zwraca<see langword="null" /> partycje. <see cref="T:System.Collections.Concurrent.Partitioner" /></exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątki zgłoszone we wszystkich wątkach.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Pętle równoległe</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.Partitioner{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As Partitioner(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów w <paramref name="source" />.</typeparam>
        <typeparam name="TLocal">Typ danych lokalnych wątku.</typeparam>
        <param name="source">Partycja zawierająca oryginalne źródło danych.</param>
        <param name="localInit">Delegat funkcji, który zwraca początkowy stan danych lokalnych dla każdego zadania.</param>
        <param name="body">Delegat, który jest wywoływany raz na iterację.</param>
        <param name="localFinally">Delegat, który wykonuje ostateczną akcję na lokalnym stanie każdego zadania.</param>
        <summary>Wykonuje operację<see langword="For Each" /> <see cref="T:System.Collections.Concurrent.Partitioner" /> (w Visual Basic) za pomocą danych lokalnych wątku, w których iteracje mogą działać równolegle, a stan pętli może być monitorowany i manipulowany. <see langword="foreach" /></summary>
        <returns>Struktura, która zawiera informacje o tym, która część pętli została ukończona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie jest dostępne dla scenariuszy, w których chcesz przesłonić domyślny schemat partycjonowania. Na przykład małe treści pętli mogą korzystać z partycjonowania zakresu. Metoda <xref:System.Threading.Tasks.Parallel.ForEach%2A> oczekuje, że niestandardowe partycje obsługują partycjonowanie dynamiczne. Aby uzyskać więcej informacji, zobacz [niestandardowe partycje dla PLINQ i TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) i [instrukcje: Implementowanie partycji](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)dynamicznych.  
  
 `localInit` Delegat jest wywoływany raz dla każdego wątku, który uczestniczy w wykonaniu pętli i zwraca początkowy stan lokalny dla każdego z tych zadań. Te Stany początkowe są przesyłane do pierwszych `body` wywołań każdego zadania. Następnie każde kolejne wywołanie treści zwróci prawdopodobnie zmodyfikowaną wartość stanu, która jest przenoszona do następnego wywołania treści. Na koniec ostatnie wywołanie treści dla każdego zadania zwraca wartość stanu, która jest przenoszona do `localFinally` delegata. `localFinally` Delegat jest wywoływany raz na zadanie w celu wykonania końcowej akcji na lokalnym stanie każdego zadania. Ten delegat może być wywoływany współbieżnie dla wielu zadań; w związku z tym należy synchronizować dostęp do dowolnych zmiennych udostępnionych.  
  
 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Metoda może korzystać z większej liczby zadań niż wątki w okresie istnienia wykonywania, ponieważ istniejące zadania zostały ukończone i są zastępowane przez nowe zadania. Dzięki temu obiekt źródłowy <xref:System.Threading.Tasks.TaskScheduler> może dodawać, zmieniać lub usuwać wątki obsługujące pętlę.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Argument ma wartość <see langword="null" />. <paramref name="source" />  
  
—lub— 
Argument ma wartość <see langword="null" />. <paramref name="body" />  
  
—lub— 
Argument ma wartość <see langword="null" />. <paramref name="localInit" />  
  
—lub— 
Argument ma wartość <see langword="null" />. <paramref name="localFinally" /></exception>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> Właściwość w<paramref name="source" /> zwracaniu<see langword="false" /> lub partycji zwraca<see langword="null" /> partycje. <see cref="T:System.Collections.Concurrent.Partitioner" /></exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątki zgłoszone we wszystkich wątkach.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Pętle równoległe</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As IEnumerable(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, Long, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ danych w źródle.</typeparam>
        <typeparam name="TLocal">Typ danych lokalnych wątku.</typeparam>
        <param name="source">Wyliczalne źródło danych.</param>
        <param name="localInit">Delegat funkcji, który zwraca początkowy stan danych lokalnych dla każdego zadania.</param>
        <param name="body">Delegat, który jest wywoływany raz na iterację.</param>
        <param name="localFinally">Delegat, który wykonuje ostateczną akcję na lokalnym stanie każdego zadania.</param>
        <summary>Wykonuje operację<see langword="For Each" /> <see cref="T:System.Collections.IEnumerable" /> (w Visual Basic) z danymi lokalnymi wątku, w których iteracje mogą działać równolegle, a stan pętli może być monitorowany i manipulowany. <see langword="foreach" /></summary>
        <returns>Struktura, która zawiera informacje o tym, która część pętli została ukończona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Delegat jest wywoływany jednokrotnie dla każdego elementu `source` w wyliczalnym. `body` Jest on dostarczany z następującymi parametrami: bieżącym elementem, <xref:System.Threading.Tasks.ParallelLoopState> wystąpieniem, które może być używane do wypełniania pętli przedwcześnie, indeks bieżącego elementu (<xref:System.Int64>) i część stanu lokalnego, które mogą być współużytkowane przez iteracje, które wykonuje w tym samym wątku.  
  
 `localInit` Delegat jest wywoływany jednokrotnie dla każdego zadania, które uczestniczy w wykonaniu pętli i zwraca początkowy stan lokalny dla każdego z tych zadań. Te Stany początkowe są przesyłane do pierwszych `body` wywołań każdego zadania. Następnie każde kolejne wywołanie treści zwróci prawdopodobnie zmodyfikowaną wartość stanu, która jest przenoszona do następnego wywołania treści. Na koniec ostatnie wywołanie treści dla każdego zadania zwraca wartość stanu, która jest przenoszona do `localFinally` delegata. `localFinally` Delegat jest wywoływany raz na zadanie w celu wykonania końcowej akcji na lokalnym stanie każdego zadania. Ten delegat może być wywoływany współbieżnie dla wielu zadań; w związku z tym należy synchronizować dostęp do dowolnych zmiennych udostępnionych.  
  
 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Metoda może korzystać z większej liczby zadań niż wątki w okresie istnienia wykonywania, ponieważ istniejące zadania zostały ukończone i są zastępowane przez nowe zadania. Dzięki temu obiekt źródłowy <xref:System.Threading.Tasks.TaskScheduler> może dodawać, zmieniać lub usuwać wątki obsługujące pętlę.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Argument ma wartość <see langword="null" />. <paramref name="source" />  
  
—lub— 
Argument ma wartość <see langword="null" />. <paramref name="body" />  
  
—lub— 
Argument ma wartość <see langword="null" />. <paramref name="localInit" />  
  
—lub— 
Argument ma wartość <see langword="null" />. <paramref name="localFinally" /></exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątki zgłoszone we wszystkich wątkach.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Pętle równoległe</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As IEnumerable(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ danych w źródle.</typeparam>
        <typeparam name="TLocal">Typ danych lokalnych wątku.</typeparam>
        <param name="source">Wyliczalne źródło danych.</param>
        <param name="localInit">Delegat funkcji, który zwraca początkowy stan danych lokalnych dla każdego zadania.</param>
        <param name="body">Delegat, który jest wywoływany raz na iterację.</param>
        <param name="localFinally">Delegat, który wykonuje ostateczną akcję na lokalnym stanie każdego zadania.</param>
        <summary>Wykonuje operację<see langword="For Each" /> <see cref="T:System.Collections.IEnumerable" /> (w Visual Basic) z danymi lokalnymi wątku w przypadku, w którym iteracje mogą działać równolegle, a stan pętli może być monitorowany i manipulowany. <see langword="foreach" /></summary>
        <returns>Struktura, która zawiera informacje o tym, która część pętli została ukończona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Delegat jest wywoływany jednokrotnie dla każdego elementu `source` w wyliczalnym. `body` Jest on dostarczany z następującymi parametrami: bieżącym elementem, <xref:System.Threading.Tasks.ParallelLoopState> wystąpieniem, które może służyć do wypełniania pętli przedwcześnie i niektórych stanów lokalnych, które mogą być współużytkowane przez iteracje wykonywane w tym samym wątku.  
  
 `localInit` Delegat jest wywoływany jednokrotnie dla każdego zadania, które uczestniczy w wykonaniu pętli i zwraca początkowy stan lokalny dla każdego z tych zadań. Te Stany początkowe są przesyłane do pierwszych `body` wywołań każdego zadania. Następnie każde kolejne wywołanie treści zwróci prawdopodobnie zmodyfikowaną wartość stanu, która jest przenoszona do następnego wywołania treści. Na koniec ostatnie wywołanie treści dla każdego zadania zwraca wartość stanu, która jest przenoszona do `localFinally` delegata. `localFinally` Delegat jest wywoływany raz na wątek, aby wykonać ostateczną akcję na lokalnym stanie każdego zadania. Ten delegat może być wywoływany współbieżnie dla wielu zadań; w związku z tym należy synchronizować dostęp do dowolnych zmiennych udostępnionych.  
  
 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Metoda może korzystać z większej liczby zadań niż wątki w okresie istnienia wykonywania, ponieważ istniejące zadania zostały ukończone i są zastępowane przez nowe zadania. Dzięki temu obiekt źródłowy <xref:System.Threading.Tasks.TaskScheduler> może dodawać, zmieniać lub usuwać wątki obsługujące pętlę.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.Threading.Tasks.Parallel.ForEach%2A> jak używać metody ze stanem lokalnym:  
  
 [!code-csharp[System.Threading.Tasks.Parallel#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelforeach.cs#02)]
 [!code-vb[System.Threading.Tasks.Parallel#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelforeach.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Argument ma wartość <see langword="null" />. <paramref name="source" />  
  
—lub— 
Argument ma wartość <see langword="null" />. <paramref name="body" />  
  
—lub— 
Argument ma wartość <see langword="null" />. <paramref name="localInit" />  
  
—lub— 
Argument ma wartość <see langword="null" />. <paramref name="localFinally" /></exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątki zgłoszone we wszystkich wątkach.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Pętle równoległe</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.OrderablePartitioner{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów w <paramref name="source" />.</typeparam>
        <typeparam name="TLocal">Typ danych lokalnych wątku.</typeparam>
        <param name="source">Uporządkowana partycja, która zawiera oryginalne źródło danych.</param>
        <param name="parallelOptions">Obiekt, który konfiguruje zachowanie tej operacji.</param>
        <param name="localInit">Delegat funkcji, który zwraca początkowy stan danych lokalnych dla każdego zadania.</param>
        <param name="body">Delegat, który jest wywoływany raz na iterację.</param>
        <param name="localFinally">Delegat, który wykonuje ostateczną akcję na lokalnym stanie każdego zadania.</param>
        <summary>Wykonuje operację<see langword="For Each" /> <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> (w Visual Basic) z indeksami 64-bitowymi i danymi lokalnymi wątku w, w których iteracje mogą działać równolegle, można skonfigurować opcje pętli, a stan pętli można monitorować i <see langword="foreach" /> manipulować.</summary>
        <returns>Struktura, która zawiera informacje o tym, która część pętli została ukończona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie jest dostępne dla scenariuszy, w których chcesz przesłonić domyślny schemat partycjonowania. Na przykład małe treści pętli mogą korzystać z partycjonowania zakresu. Metoda <xref:System.Threading.Tasks.Parallel.ForEach%2A> oczekuje, że niestandardowe partycje obsługują partycjonowanie dynamiczne. Aby uzyskać więcej informacji, zobacz [niestandardowe partycje dla PLINQ i TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) i [instrukcje: Implementowanie partycji](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)dynamicznych.  
  
 `localInit` Delegat jest wywoływany jednokrotnie dla każdego zadania, które uczestniczy w wykonaniu pętli i zwraca początkowy stan lokalny dla każdego z tych zadań. Te Stany początkowe są przesyłane do pierwszych `body` wywołań każdego zadania. Następnie każde kolejne wywołanie treści zwróci prawdopodobnie zmodyfikowaną wartość stanu, która jest przenoszona do następnego wywołania treści. Na koniec ostatnie wywołanie treści dla każdego wątku zwraca wartość stanu, która jest przenoszona do `localFinally` delegata. `localFinally` Delegat jest wywoływany raz na zadanie w celu wykonania końcowej akcji na lokalnym stanie każdego zadania. Ten delegat może być wywoływany współbieżnie dla wielu zadań; w związku z tym należy synchronizować dostęp do dowolnych zmiennych udostępnionych.  
  
 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Metoda może korzystać z większej liczby zadań niż wątki w okresie istnienia wykonywania, ponieważ istniejące zadania zostały ukończone i są zastępowane przez nowe zadania. Dzięki temu obiekt źródłowy <xref:System.Threading.Tasks.TaskScheduler> może dodawać, zmieniać lub usuwać wątki obsługujące pętlę.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Argument ma wartość <see langword="null" />. <paramref name="source" />  
  
—lub— 
Argument ma wartość <see langword="null" />. <paramref name="parallelOptions" />  
  
—lub— 
Argument ma wartość <see langword="null" />. <paramref name="body" />  
  
—lub— 
Argument <paramref name="localInit" /> or <paramref name="localFinally" /> ma<see langword="null" />wartość.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> Właściwość w<paramref name="source" /> zwracaniu<see langword="false" /> lub partycji zwraca<see langword="null" /> partycje. <see cref="T:System.Collections.Concurrent.Partitioner" /></exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątki zgłoszone we wszystkich wątkach.</exception>
        <exception cref="T:System.OperationCanceledException"><see cref="T:System.Threading.CancellationToken" /> W<paramref name="parallelOptions" /> argumencie zostanie anulowana.</exception>
        <exception cref="T:System.ObjectDisposedException">Skojarzona z elementem <paramref name="parallelOptions" /> w został usunięty. <see cref="T:System.Threading.CancellationToken" /> <see cref="T:System.Threading.CancellationTokenSource" /></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Pętle równoległe</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów w <paramref name="source" />.</typeparam>
        <typeparam name="TLocal">Typ danych lokalnych wątku.</typeparam>
        <param name="source">Partycja zawierająca oryginalne źródło danych.</param>
        <param name="parallelOptions">Obiekt, który konfiguruje zachowanie tej operacji.</param>
        <param name="localInit">Delegat funkcji, który zwraca początkowy stan danych lokalnych dla każdego zadania.</param>
        <param name="body">Delegat, który jest wywoływany raz na iterację.</param>
        <param name="localFinally">Delegat, który wykonuje ostateczną akcję na lokalnym stanie każdego zadania.</param>
        <summary>Wykonuje operację<see langword="For Each" /> <see cref="T:System.Collections.Concurrent.Partitioner" /> (w Visual Basic) przy użyciu danych z wątku lokalnego, w którym iteracje mogą działać równolegle, można skonfigurować opcje pętli, a stan pętli można monitorować i manipulować. <see langword="foreach" /></summary>
        <returns>Struktura, która zawiera informacje o tym, która część pętli została ukończona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie jest dostępne dla scenariuszy, w których chcesz przesłonić domyślny schemat partycjonowania. Na przykład małe treści pętli mogą korzystać z partycjonowania zakresu. Metoda <xref:System.Threading.Tasks.Parallel.ForEach%2A> oczekuje, że niestandardowe partycje obsługują partycjonowanie dynamiczne. To przeciążenie jest zapewnione w scenariuszach z małymi ciałami pętli, które mogą korzystać z partycjonowania zakresu statycznego. Partycje muszą obsługiwać partycje dynamiczne.  Aby uzyskać więcej informacji, zobacz [niestandardowe partycje dla PLINQ i TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) i [instrukcje: Implementowanie partycji](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)dynamicznych.  
  
 `localInit` Delegat jest wywoływany jednokrotnie dla każdego zadania, które uczestniczy w wykonaniu pętli i zwraca początkowy stan lokalny dla każdego z tych zadań. Te Stany początkowe są przesyłane do pierwszych `body` wywołań każdego zadania. Następnie każde kolejne wywołanie treści zwróci prawdopodobnie zmodyfikowaną wartość stanu, która jest przenoszona do następnego wywołania treści. Na koniec ostatnie wywołanie treści dla każdego zadania zwraca wartość stanu, która jest przenoszona do `localFinally` delegata. `localFinally` Delegat jest wywoływany raz na zadanie w celu wykonania końcowej akcji na lokalnym stanie każdego zadania. Ten delegat może być wywoływany współbieżnie dla wielu zadań; w związku z tym należy synchronizować dostęp do dowolnych zmiennych udostępnionych.  
  
 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Metoda może korzystać z większej liczby zadań niż wątki w okresie istnienia wykonywania, ponieważ istniejące zadania zostały ukończone i są zastępowane przez nowe zadania. Dzięki temu obiekt źródłowy <xref:System.Threading.Tasks.TaskScheduler> może dodawać, zmieniać lub usuwać wątki obsługujące pętlę.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Argument ma wartość <see langword="null" />. <paramref name="source" />  
  
—lub— 
Argument ma wartość <see langword="null" />. <paramref name="parallelOptions" />  
  
—lub— 
Argument ma wartość <see langword="null" />. <paramref name="body" />  
  
—lub— 
Argument ma wartość <see langword="null" />. <paramref name="localInit" />  
  
—lub— 
Argument ma wartość <see langword="null" />. <paramref name="localFinally" /></exception>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> Właściwość w<paramref name="source" /> zwracaniu<see langword="false" /> lub partycji zwraca<see langword="null" /> partycje. <see cref="T:System.Collections.Concurrent.Partitioner" /></exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątki zgłoszone we wszystkich wątkach.</exception>
        <exception cref="T:System.OperationCanceledException"><see cref="T:System.Threading.CancellationToken" /> W<paramref name="parallelOptions" /> argumencie zostanie anulowana.</exception>
        <exception cref="T:System.ObjectDisposedException">Skojarzona z elementem <paramref name="parallelOptions" /> w został usunięty. <see cref="T:System.Threading.CancellationToken" /> <see cref="T:System.Threading.CancellationTokenSource" /></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Pętle równoległe</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ danych w źródle.</typeparam>
        <typeparam name="TLocal">Typ danych lokalnych wątku.</typeparam>
        <param name="source">Wyliczalne źródło danych.</param>
        <param name="parallelOptions">Obiekt, który konfiguruje zachowanie tej operacji.</param>
        <param name="localInit">Delegat funkcji, który zwraca początkowy stan danych lokalnych dla każdego zadania.</param>
        <param name="body">Delegat, który jest wywoływany raz na iterację.</param>
        <param name="localFinally">Delegat, który wykonuje ostateczną akcję na lokalnym stanie każdego zadania.</param>
        <summary>Wykonuje operację<see langword="For Each" /> <see cref="T:System.Collections.IEnumerable" /> (w Visual Basic) z danymi lokalnymi wątku i 64-bitowymi indeksami dla, w których iteracje mogą działać równolegle, można skonfigurować opcje pętli, a stan pętli można monitorować i manipulować. <see langword="foreach" /></summary>
        <returns>Struktura, która zawiera informacje o tym, która część pętli została ukończona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Delegat jest wywoływany jednokrotnie dla każdego elementu `source` w wyliczalnym. `body` Jest on dostarczany z następującymi parametrami: bieżącym elementem, <xref:System.Threading.Tasks.ParallelLoopState> wystąpieniem, które może być używane do wypełniania pętli przedwcześnie, indeks bieżącego elementu (<xref:System.Int64>) i część stanu lokalnego, które mogą być współużytkowane przez iteracje, które wykonuje w tym samym wątku.  
  
 `localInit` Delegat jest wywoływany jednokrotnie dla każdego zadania, które uczestniczy w wykonaniu pętli i zwraca początkowy stan lokalny dla każdego z tych zadań. Te Stany początkowe są przesyłane do pierwszych `body` wywołań każdego zadania. Następnie każde kolejne wywołanie treści zwróci prawdopodobnie zmodyfikowaną wartość stanu, która jest przenoszona do następnego wywołania treści. Na koniec ostatnie wywołanie treści dla każdego zadania zwraca wartość stanu, która jest przenoszona do `localFinally` delegata. `localFinally` Delegat jest wywoływany raz na wątek, aby wykonać ostateczną akcję na lokalnym stanie każdego zadania. Ten delegat może być wywoływany współbieżnie dla wielu zadań; w związku z tym należy synchronizować dostęp do dowolnych zmiennych udostępnionych.  
  
 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Metoda może korzystać z większej liczby zadań niż wątki w okresie istnienia wykonywania, ponieważ istniejące zadania zostały ukończone i są zastępowane przez nowe zadania. Dzięki temu obiekt źródłowy <xref:System.Threading.Tasks.TaskScheduler> może dodawać, zmieniać lub usuwać wątki obsługujące pętlę.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Argument ma wartość <see langword="null" />. <paramref name="source" />  
  
—lub— 
Argument ma wartość <see langword="null" />. <paramref name="parallelOptions" />  
  
—lub— 
Argument ma wartość <see langword="null" />. <paramref name="body" />  
  
—lub— 
Argument ma wartość <see langword="null" />. <paramref name="localInit" />  
  
—lub— 
Argument ma wartość <see langword="null" />. <paramref name="localFinally" /></exception>
        <exception cref="T:System.OperationCanceledException"><see cref="T:System.Threading.CancellationToken" /> W<paramref name="parallelOptions" /> argumencie zostanie anulowana.</exception>
        <exception cref="T:System.ObjectDisposedException">Skojarzona z elementem <paramref name="parallelOptions" /> w został usunięty. <see cref="T:System.Threading.CancellationToken" /> <see cref="T:System.Threading.CancellationTokenSource" /></exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątki zgłoszone we wszystkich wątkach.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Pętle równoległe</related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ danych w źródle.</typeparam>
        <typeparam name="TLocal">Typ danych lokalnych wątku.</typeparam>
        <param name="source">Wyliczalne źródło danych.</param>
        <param name="parallelOptions">Obiekt, który konfiguruje zachowanie tej operacji.</param>
        <param name="localInit">Delegat funkcji, który zwraca początkowy stan danych lokalnych dla każdego zadania.</param>
        <param name="body">Delegat, który jest wywoływany raz na iterację.</param>
        <param name="localFinally">Delegat, który wykonuje ostateczną akcję na lokalnym stanie każdego zadania.</param>
        <summary>Wykonuje operację<see langword="For Each" /> <see cref="T:System.Collections.IEnumerable" /> (w Visual Basic) z danymi lokalnymi wątku w przypadku, w którym iteracje mogą działać równolegle, można skonfigurować opcje pętli, a stan pętli można monitorować i manipulować. <see langword="foreach" /></summary>
        <returns>Struktura, która zawiera informacje o tym, która część pętli została ukończona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Delegat jest wywoływany jednokrotnie dla każdego elementu `source` w wyliczalnym. `body` Jest on dostarczany z następującymi parametrami: bieżącym elementem, <xref:System.Threading.Tasks.ParallelLoopState> wystąpieniem, które może służyć do wypełniania pętli przedwcześnie i niektórych stanów lokalnych, które mogą być współużytkowane przez iteracje wykonywane w tym samym wątku.  
  
 `localInit` Delegat jest wywoływany jednokrotnie dla każdego zadania, które uczestniczy w wykonaniu pętli i zwraca początkowy stan lokalny dla każdego z tych zadań. Te Stany początkowe są przesyłane do pierwszych `body` wywołań każdego zadania. Następnie każde kolejne wywołanie treści zwróci prawdopodobnie zmodyfikowaną wartość stanu, która jest przenoszona do następnego wywołania treści. Na koniec ostatnie wywołanie treści dla każdego zadania zwraca wartość stanu, która jest przenoszona do `localFinally` delegata. `localFinally` Delegat jest wywoływany raz na wątek, aby wykonać ostateczną akcję na lokalnym stanie każdego zadania. Ten delegat może być wywoływany współbieżnie dla wielu zadań; w związku z tym należy synchronizować dostęp do dowolnych zmiennych udostępnionych.  
  
 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Metoda może korzystać z większej liczby zadań niż wątki w okresie istnienia wykonywania, ponieważ istniejące zadania zostały ukończone i są zastępowane przez nowe zadania. Dzięki temu obiekt źródłowy <xref:System.Threading.Tasks.TaskScheduler> może dodawać, zmieniać lub usuwać wątki obsługujące pętlę.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Argument ma wartość <see langword="null" />. <paramref name="source" />  
  
—lub— 
Argument ma wartość <see langword="null" />. <paramref name="parallelOptions" />  
  
—lub— 
Argument ma wartość <see langword="null" />. <paramref name="body" />  
  
—lub— 
Argument ma wartość <see langword="null" />. <paramref name="localInit" />  
  
—lub— 
Argument ma wartość <see langword="null" />. <paramref name="localFinally" /></exception>
        <exception cref="T:System.OperationCanceledException"><see cref="T:System.Threading.CancellationToken" /> W<paramref name="parallelOptions" /> argumencie zostanie anulowana.</exception>
        <exception cref="T:System.ObjectDisposedException">Skojarzona z elementem <paramref name="parallelOptions" /> w został usunięty. <see cref="T:System.Threading.CancellationToken" /> <see cref="T:System.Threading.CancellationTokenSource" /></exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątki zgłoszone we wszystkich wątkach.</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)">Pętle równoległe</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Invoke">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wykonuje każdą z podanych akcji, prawdopodobnie równolegle.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static void Invoke (params Action[] actions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Invoke(class System.Action[] actions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.Invoke(System.Action[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Invoke (ParamArray actions As Action())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Invoke(... cli::array &lt;Action ^&gt; ^ actions);" />
      <MemberSignature Language="F#" Value="static member Invoke : Action[] -&gt; unit" Usage="System.Threading.Tasks.Parallel.Invoke actions" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="actions" Type="System.Action[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="actions">Tablica <see cref="T:System.Action" /> do wykonania.</param>
        <summary>Wykonuje każdą z podanych akcji, prawdopodobnie równolegle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może być używana do wykonywania zestawu operacji, potencjalnie równolegle.  
  
 Nie są wykonywane żadne gwarancje dotyczące kolejności wykonywania operacji lub wykonywania ich równolegle. Ta metoda nie jest zwracana do momentu ukończenia każdej z podanych operacji, niezależnie od tego, czy następuje zakończenie lub wyjątkowe zakończenie.  
  
 Aby uzyskać więcej informacji, zobacz [jak: Użyj metody Parallel. Invoke, aby wykonać](~/docs/standard/parallel-programming/how-to-use-parallel-invoke-to-execute-parallel-operations.md)operacje równoległe.  
  
   
  
## Examples  
 W tym przykładzie pokazano, jak używać <xref:System.Threading.Tasks.Parallel.Invoke%2A> metody z innymi metodami, delegatów anonimowych i wyrażeniami lambda.  
  
 [!code-csharp[System.Threading.Tasks.Parallel#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelinvoke.cs#01)]
 [!code-vb[System.Threading.Tasks.Parallel#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelinvoke.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Argument ma wartość <see langword="null" />. <paramref name="actions" /></exception>
        <exception cref="T:System.AggregateException">Wyjątek, który jest generowany, gdy którakolwiek akcja w <paramref name="actions" /> tablicy zgłosi wyjątek.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="actions" /> Tablica<see langword="null" /> zawiera element.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static void Invoke (System.Threading.Tasks.ParallelOptions parallelOptions, params Action[] actions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Invoke(class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action[] actions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.Invoke(System.Threading.Tasks.ParallelOptions,System.Action[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Invoke(System::Threading::Tasks::ParallelOptions ^ parallelOptions, ... cli::array &lt;Action ^&gt; ^ actions);" />
      <MemberSignature Language="F#" Value="static member Invoke : System.Threading.Tasks.ParallelOptions * Action[] -&gt; unit" Usage="System.Threading.Tasks.Parallel.Invoke (parallelOptions, actions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="actions" Type="System.Action[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="parallelOptions">Obiekt, który konfiguruje zachowanie tej operacji.</param>
        <param name="actions">Tablica akcji do wykonania.</param>
        <summary>Wykonuje każdą z podanych akcji, prawdopodobnie równolegle, chyba że operacja zostanie anulowana przez użytkownika.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może być używana do wykonywania zestawu operacji, potencjalnie równolegle. Token anulowania przeszedł przy użyciu <xref:System.Threading.Tasks.ParallelOptions> struktury umożliwia obiektowi wywołującemu anulowanie całej operacji. Aby uzyskać więcej informacji, zobacz [Anulowanie w zarządzanych wątkach](~/docs/standard/threading/cancellation-in-managed-threads.md).  
  
 Nie są wykonywane żadne gwarancje dotyczące kolejności wykonywania operacji lub wykonywania ich równolegle. Ta metoda nie jest zwracana do momentu ukończenia każdej z podanych operacji, niezależnie od tego, czy następuje zakończenie lub wyjątkowe zakończenie.  
  
 Aby uzyskać więcej informacji, zobacz [jak: Użyj metody Parallel. Invoke, aby wykonać](~/docs/standard/parallel-programming/how-to-use-parallel-invoke-to-execute-parallel-operations.md)operacje równoległe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><see cref="T:System.Threading.CancellationToken" /> Jest ustawiony<paramref name="parallelOptions" /> .</exception>
        <exception cref="T:System.ArgumentNullException">Argument ma wartość <see langword="null" />. <paramref name="actions" />  
  
—lub— 
Argument ma wartość <see langword="null" />. <paramref name="parallelOptions" /></exception>
        <exception cref="T:System.AggregateException">Wyjątek, który jest generowany, gdy którakolwiek akcja w <paramref name="actions" /> tablicy zgłosi wyjątek.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="actions" /> Tablica<see langword="null" /> zawiera element.</exception>
        <exception cref="T:System.ObjectDisposedException">Skojarzona z elementem <paramref name="parallelOptions" /> w został usunięty. <see cref="T:System.Threading.CancellationToken" /> <see cref="T:System.Threading.CancellationTokenSource" /></exception>
      </Docs>
    </Member>
  </Members>
</Type>

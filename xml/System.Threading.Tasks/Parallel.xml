<Type Name="Parallel" FullName="System.Threading.Tasks.Parallel">
  <Metadata><Meta Name="ms.openlocfilehash" Value="9969ebfed1c4d5ee33c68817c29ef43bc01f7aa4" /><Meta Name="ms.sourcegitcommit" Value="ea104bc7868886a205b1df30baed6ca34ff70ecb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="07/20/2019" /><Meta Name="ms.locfileid" Value="68369009" /></Metadata><TypeSignature Language="C#" Value="public static class Parallel" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Parallel extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.Parallel" />
  <TypeSignature Language="VB.NET" Value="Public Class Parallel" />
  <TypeSignature Language="C++ CLI" Value="public ref class Parallel abstract sealed" />
  <TypeSignature Language="F#" Value="type Parallel = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="dd0f0-101">Zapewnia obsługę pętli równoległych i regionów.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-101">Provides support for parallel loops and regions.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd0f0-102"><xref:System.Threading.Tasks.Parallel> Klasa zawiera równoległe zamienniki danych opartych na bibliotece dla typowych operacji, takich jak pętle, dla każdej pętli, i wykonywania zestawu instrukcji.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-102">The <xref:System.Threading.Tasks.Parallel> class provides library-based data parallel replacements for common operations such as for loops, for each loops, and execution of a set of statements.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd0f0-103">Ten przykład ilustruje kilka podejścia do implementowania pętli równoległej przy użyciu wielu konstrukcji językowych.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-103">This example demonstrates several approaches to implementing a parallel loop using multiple language constructs.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Parallel#07](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelintro.cs#07)]
 [!code-vb[System.Threading.Tasks.Parallel#07](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelintro.vb#07)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="dd0f0-104">Wszystkie publiczne i chronione elementy członkowskie <see cref="T:System.Threading.Tasks.Parallel" /> są bezpieczne dla wątków i mogą być używane współbieżnie z wielu wątków.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-104">All public and protected members of <see cref="T:System.Threading.Tasks.Parallel" /> are thread-safe and may be used concurrently from multiple threads.</span></span></threadsafe>
    <related type="Article" href="~/docs/standard/parallel-programming/data-parallelism-task-parallel-library.md"><span data-ttu-id="dd0f0-105">Równoległość danych (Biblioteka zadań równoległych)</span><span class="sxs-lookup"><span data-stu-id="dd0f0-105">Data Parallelism (Task Parallel Library)</span></span></related>
    <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/Samples-for-Parallel-b4b76364"><span data-ttu-id="dd0f0-106">Przykłady programowania równoległego przy użyciu .NET Framework</span><span class="sxs-lookup"><span data-stu-id="dd0f0-106">Samples for Parallel Programming with the .NET Framework</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName="For">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="dd0f0-107"><see langword="for" /> Wykonuje pętlę, w której iteracje mogą działać równolegle.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-107">Executes a <see langword="for" /> loop in which iterations may run in parallel.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, Action&lt;int,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Action`2&lt;int32, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Action{System.Int32,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Integer, toExclusive As Integer, body As Action(Of Integer, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, Action&lt;int, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * Action&lt;int, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive"><span data-ttu-id="dd0f0-108">Indeks początkowy włącznie.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-108">The start index, inclusive.</span></span></param>
        <param name="toExclusive"><span data-ttu-id="dd0f0-109">Indeks końcowy, na wyłączność.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-109">The end index, exclusive.</span></span></param>
        <param name="body"><span data-ttu-id="dd0f0-110">Delegat, który jest wywoływany raz na iterację.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-110">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="dd0f0-111"><see langword="for" /> Wykonuje pętlę, w której iteracje mogą działać równolegle, a stan pętli może być monitorowany i manipulowany.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-111">Executes a <see langword="for" /> loop in which iterations may run in parallel and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="dd0f0-112">Struktura, która zawiera informacje o tym, która część pętli została ukończona.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-112">A  structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd0f0-113">Delegat jest wywoływany raz dla każdej wartości w zakresie iteracji (`fromInclusive`, `toExclusive`). `body`</span><span class="sxs-lookup"><span data-stu-id="dd0f0-113">The `body` delegate is invoked once for each value in the iteration range (`fromInclusive`, `toExclusive`).</span></span> <span data-ttu-id="dd0f0-114">Jest on dostarczany z dwoma argumentami:</span><span class="sxs-lookup"><span data-stu-id="dd0f0-114">It is provided with two arguments:</span></span>  
  
-   <span data-ttu-id="dd0f0-115"><xref:System.Int32> Wartość, która reprezentuje liczbę iteracji.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-115">An <xref:System.Int32> value that represents the iteration count.</span></span>  
  
-   <span data-ttu-id="dd0f0-116"><xref:System.Threading.Tasks.ParallelLoopState> Wystąpienie, które może służyć do przedwczesnego przerwania pętli.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-116">A <xref:System.Threading.Tasks.ParallelLoopState> instance that can be used to break out of the loop prematurely.</span></span> <span data-ttu-id="dd0f0-117"><xref:System.Threading.Tasks.ParallelLoopState> Obiekt jest tworzony przez kompilator; nie można utworzyć jego wystąpienia w kodzie użytkownika.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-117">The <xref:System.Threading.Tasks.ParallelLoopState> object is created by the compiler; it cannot be instantiated in user code.</span></span>  
  
 <span data-ttu-id="dd0f0-118">Wywołanie metody informuje, że iteracje `for` po bieżącej operacji nie muszą zostać wykonane. <xref:System.Threading.Tasks.ParallelLoopState.Break%2A></span><span class="sxs-lookup"><span data-stu-id="dd0f0-118">Calling the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> method informs the `for` operation that iterations after the current one don't have to execute.</span></span> <span data-ttu-id="dd0f0-119">Jednak wszystkie iteracje przed bieżącą, będą nadal musiały zostać wykonane, jeśli jeszcze nie.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-119">However, all iterations before the current one will still have to be executed if they haven't already.</span></span>  
  
 <span data-ttu-id="dd0f0-120">W związku z <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> tym, wywołanie jest podobne do użycia operacji Break w `for` obrębie konwencjonalnej pętli w C#języku takim jak, ale nie jest to idealne zamiennik: Na przykład nie ma gwarancji, że iteracje po bieżącej dacie nie będą wykonywane w nieskończoność.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-120">Therefore, calling <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> is similar to using a break operation within a conventional `for` loop in a language like C#, but it is not a perfect substitute: For example, there is no guarantee that iterations after the current one will definitely not execute.</span></span>  
  
 <span data-ttu-id="dd0f0-121">Jeśli wykonywanie wszystkich iteracji przed bieżącą, nie jest konieczne, użyj <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> metody zamiast używać. <xref:System.Threading.Tasks.ParallelLoopState.Break%2A></span><span class="sxs-lookup"><span data-stu-id="dd0f0-121">If executing all iterations before the current one is not necessary, use the <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> method instead of using <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>.</span></span> <span data-ttu-id="dd0f0-122">Wywołanie <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A>informujepętlę , że może porzucić wszystkie pozostałe iteracje, niezależnie od tego, czy są one przed lub po bieżącej iteracji, ponieważ wszystkie wymagane zadania zostaną już wykonane. `for`</span><span class="sxs-lookup"><span data-stu-id="dd0f0-122">Calling <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> informs the `for` loop that it may abandon all remaining iterations, regardless of whether they're before or after the current iteration, because all required work will have already been completed.</span></span> <span data-ttu-id="dd0f0-123">Jednak podobnie jak w <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>przypadku, nie ma gwarancji dotyczących tego, które inne iteracje nie zostaną wykonane.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-123">However, as with <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>, there are no guarantees regarding which other iterations will not execute.</span></span>  
  
 <span data-ttu-id="dd0f0-124">Jeśli pętla kończy się przedwcześnie, <xref:System.Threading.Tasks.ParallelLoopResult> zwracana struktura będzie zawierać istotne informacje dotyczące uzupełniania pętli.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-124">If a loop is ended prematurely, the <xref:System.Threading.Tasks.ParallelLoopResult> structure that is returned will contain relevant information about the loop's completion.</span></span>  
  
 <span data-ttu-id="dd0f0-125">Jeśli `fromInclusive` jest większa lub `toExclusive`równa, metoda zwraca natychmiast bez wykonywania jakichkolwiek iteracji.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-125">If `fromInclusive` is greater than or equal to `toExclusive`, the method returns immediately without performing any iterations.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd0f0-126">Poniższy przykład wykonuje równolegle do 100 iteracji pętli.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-126">The following example executes up to 100 iterations of a loop in parallel.</span></span> <span data-ttu-id="dd0f0-127">Każda iteracja wstrzymuje się dla losowego interwału od 1 do 1 000 milisekund.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-127">Each iteration pauses for a random interval from 1 to 1,000 milliseconds.</span></span> <span data-ttu-id="dd0f0-128">Generowana losowo wartość określa, na której iteracji pętli <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> wywoływana jest metoda.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-128">A randomly generated value determines on which iteration of the loop the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> method is called.</span></span> <span data-ttu-id="dd0f0-129">Dane wyjściowe z przykładu pokazują, że żadne iteracje, których indeks jest większy niż <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A?displayProperty=nameWithType> wartość właściwości, rozpocznie się po wywołaniu <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-129">As the output from the example shows, no iterations whose index is greater than the <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A?displayProperty=nameWithType> property value start after the call to the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> method.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/cs/break1.cs#2)]
 [!code-vb[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/vb/break1.vb#2)]  
  
 <span data-ttu-id="dd0f0-130">Ponieważ iteracje pętli nadal mogą być wykonywane, gdy <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> wywoływana jest metoda, każda iteracja wywołuje właściwość, aby sprawdzić, <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A?displayProperty=nameWithType> czy <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> inna iteracja nazywa metodę.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-130">Because iterations of the loop are still likely to be executing when the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> method is called, each iteration calls the <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A?displayProperty=nameWithType> property to check whether another iteration has called the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="dd0f0-131">Jeśli wartość właściwości jest `true`, iteracji sprawdza wartość <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A?displayProperty=nameWithType> właściwości i, jeśli jest większa niż bieżąca wartość indeksu bieżącej iteracji, zwraca natychmiast.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-131">If  the property value is `true`, the iteration checks the value of the <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A?displayProperty=nameWithType> property and, if it is greater than the current iteration's index value, returns immediately.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd0f0-132">Argument ma wartość <see langword="null" />. <paramref name="body" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-132">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="dd0f0-133">Wyjątek, który zawiera wszystkie poszczególne wyjątki zgłoszone we wszystkich wątkach.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-133">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <altmember cref="T:System.Threading.Tasks.ParallelLoopState" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="dd0f0-134">Pętle równoległe</span><span class="sxs-lookup"><span data-stu-id="dd0f0-134">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, Action&lt;int&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Action`1&lt;int32&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Action{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Integer, toExclusive As Integer, body As Action(Of Integer)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, Action&lt;int&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * Action&lt;int&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive"><span data-ttu-id="dd0f0-135">Indeks początkowy włącznie.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-135">The start index, inclusive.</span></span></param>
        <param name="toExclusive"><span data-ttu-id="dd0f0-136">Indeks końcowy, na wyłączność.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-136">The end index, exclusive.</span></span></param>
        <param name="body"><span data-ttu-id="dd0f0-137">Delegat, który jest wywoływany raz na iterację.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-137">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="dd0f0-138"><see langword="for" /> Wykonuje pętlę, w której iteracje mogą działać równolegle.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-138">Executes a <see langword="for" /> loop in which iterations may run in parallel.</span></span></summary>
        <returns><span data-ttu-id="dd0f0-139">Struktura, która zawiera informacje o tym, która część pętli została ukończona.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-139">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd0f0-140">Delegat jest wywoływany raz dla każdej wartości w zakresie iteracji (`fromInclusive`, `toExclusive`). `body`</span><span class="sxs-lookup"><span data-stu-id="dd0f0-140">The `body` delegate is invoked once for each value in the iteration range (`fromInclusive`, `toExclusive`).</span></span> <span data-ttu-id="dd0f0-141">Jest on dostarczany z liczbą iteracji (<xref:System.Int32>) jako parametr.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-141">It is provided with the iteration count (<xref:System.Int32>) as a parameter.</span></span>  
  
 <span data-ttu-id="dd0f0-142">Jeśli `fromInclusive` jest większa lub `toExclusive`równa, metoda zwraca natychmiast bez wykonywania jakichkolwiek iteracji.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-142">If `fromInclusive` is greater than or equal to `toExclusive`, the method returns immediately without performing any iterations.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd0f0-143">W poniższym przykładzie zastosowano <xref:System.Threading.Tasks.Parallel.For%2A> metodę dla 100 wywołań delegata, który generuje losowe wartości bajtów i oblicza ich sumę.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-143">The following example uses the <xref:System.Threading.Tasks.Parallel.For%2A> method for 100 invocations of a delegate that generates random byte values and computes their sum.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Parallel.For#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel.for/cs/for1.cs#1)]
 [!code-vb[System.Threading.Tasks.Parallel.For#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel.for/vb/for1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd0f0-144">Argument ma wartość <see langword="null" />. <paramref name="body" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-144">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="dd0f0-145">Wyjątek, który zawiera wszystkie poszczególne wyjątki zgłoszone we wszystkich wątkach.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-145">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="dd0f0-146">Pętle równoległe</span><span class="sxs-lookup"><span data-stu-id="dd0f0-146">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, Action&lt;long,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Action`2&lt;int64, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Action{System.Int64,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Long, toExclusive As Long, body As Action(Of Long, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, Action&lt;long, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * Action&lt;int64, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive"><span data-ttu-id="dd0f0-147">Indeks początkowy włącznie.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-147">The start index, inclusive.</span></span></param>
        <param name="toExclusive"><span data-ttu-id="dd0f0-148">Indeks końcowy, na wyłączność.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-148">The end index, exclusive.</span></span></param>
        <param name="body"><span data-ttu-id="dd0f0-149">Delegat, który jest wywoływany raz na iterację.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-149">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="dd0f0-150"><see langword="for" /> Wykonuje pętlę z 64-bitowymi indeksami, w których iteracje mogą działać równolegle, a stan pętli może być monitorowany i manipulowany.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-150">Executes a <see langword="for" /> loop with 64-bit indexes in which iterations may run in parallel and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="dd0f0-151"><see cref="T:System.Threading.Tasks.ParallelLoopResult" /> Struktura, która zawiera informacje na temat wykonanej części pętli.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-151">A <see cref="T:System.Threading.Tasks.ParallelLoopResult" /> structure that contains information on what portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd0f0-152">Delegat jest wywoływany raz dla każdej wartości w zakresie iteracji (`fromInclusive`, `toExclusive`). `body`</span><span class="sxs-lookup"><span data-stu-id="dd0f0-152">The `body` delegate is invoked once for each value in the iteration range (`fromInclusive`, `toExclusive`).</span></span> <span data-ttu-id="dd0f0-153">Jest on dostarczany z następującymi parametrami: liczbą iteracji (<xref:System.Int64>) <xref:System.Threading.Tasks.ParallelLoopState> i wystąpieniem, które może służyć do wcześniejszego przerwania pętli.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-153">It is provided with the following parameters: the iteration count (<xref:System.Int64>), and a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely.</span></span>  
  
 <span data-ttu-id="dd0f0-154">Wywołanie metody informuje, że iteracje `for` po bieżącej operacji nie muszą zostać wykonane, ale wszystkie iteracje przed bieżącym. <xref:System.Threading.Tasks.ParallelLoopState.Break%2A></span><span class="sxs-lookup"><span data-stu-id="dd0f0-154">Calling the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> method informs the `for` operation that iterations after the current one don't have to be executed, but all iterations before the current one do.</span></span>  
  
 <span data-ttu-id="dd0f0-155">W związku z tym wywołanie Break jest podobne do użycia operacji Break w obrębie `for` konwencjonalnej pętli w języku C#takim jak, ale nie jest idealnym substytutem: Na przykład nie ma gwarancji, że iteracje po bieżącej dacie nie będą wykonywane w nieskończoność.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-155">Therefore, calling Break is similar to using a break operation within a conventional `for` loop in a language like C#, but it is not a perfect substitute: For example, there is no guarantee that iterations after the current one will definitely not execute.</span></span>  
  
 <span data-ttu-id="dd0f0-156">Jeśli wykonywanie wszystkich iteracji przed bieżącą, nie jest konieczne, użyj <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> metody zamiast używać. <xref:System.Threading.Tasks.ParallelLoopState.Break%2A></span><span class="sxs-lookup"><span data-stu-id="dd0f0-156">If executing all iterations before the current one is not necessary, use the <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> method instead of using <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>.</span></span> <span data-ttu-id="dd0f0-157">Wywołanie <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A>informujepętlę , że może porzucić wszystkie pozostałe iteracje, niezależnie od tego, czy są one przed lub po bieżącej iteracji, ponieważ wszystkie wymagane zadania zostaną już wykonane. `for`</span><span class="sxs-lookup"><span data-stu-id="dd0f0-157">Calling <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> informs the `for` loop that it may abandon all remaining iterations, regardless of whether they're before or after the current iteration, because all required work will have already been completed.</span></span> <span data-ttu-id="dd0f0-158">Jednak podobnie jak w <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>przypadku, nie ma gwarancji dotyczących tego, które inne iteracje nie zostaną wykonane.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-158">However, as with <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>, there are no guarantees regarding which other iterations will not execute.</span></span>  
  
 <span data-ttu-id="dd0f0-159">Jeśli pętla kończy się przedwcześnie, <xref:System.Threading.Tasks.ParallelLoopResult> zwracana struktura będzie zawierać istotne informacje dotyczące uzupełniania pętli.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-159">If a loop is ended prematurely, the <xref:System.Threading.Tasks.ParallelLoopResult> structure that is returned will contain relevant information about the loop's completion.</span></span>  
  
 <span data-ttu-id="dd0f0-160">Jeśli `fromInclusive` jest większa lub `toExclusive`równa, metoda zwraca natychmiast bez wykonywania jakichkolwiek iteracji.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-160">If `fromInclusive` is greater than or equal to `toExclusive`, then the method returns immediately without performing any iterations.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd0f0-161">Argument ma wartość <see langword="null" />. <paramref name="body" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-161">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="dd0f0-162">Wyjątek, który zawiera wszystkie poszczególne wyjątki zgłoszone we wszystkich wątkach.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-162">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="dd0f0-163">Pętle równoległe</span><span class="sxs-lookup"><span data-stu-id="dd0f0-163">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, Action&lt;long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Action`1&lt;int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Action{System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Long, toExclusive As Long, body As Action(Of Long)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, Action&lt;long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * Action&lt;int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive"><span data-ttu-id="dd0f0-164">Indeks początkowy włącznie.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-164">The start index, inclusive.</span></span></param>
        <param name="toExclusive"><span data-ttu-id="dd0f0-165">Indeks końcowy, na wyłączność.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-165">The end index, exclusive.</span></span></param>
        <param name="body"><span data-ttu-id="dd0f0-166">Delegat, który jest wywoływany raz na iterację.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-166">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="dd0f0-167"><see langword="for" /> Wykonuje pętlę z 64-bitowymi indeksami, w których iteracje mogą działać równolegle.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-167">Executes a <see langword="for" /> loop with 64-bit indexes in which iterations may run in parallel.</span></span></summary>
        <returns><span data-ttu-id="dd0f0-168">Struktura, która zawiera informacje o tym, która część pętli została ukończona.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-168">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd0f0-169">Delegat jest wywoływany raz dla każdej wartości w zakresie iteracji (`fromInclusive`, `toExclusive`). `body`</span><span class="sxs-lookup"><span data-stu-id="dd0f0-169">The `body` delegate is invoked once for each value in the iteration range (`fromInclusive`, `toExclusive`).</span></span> <span data-ttu-id="dd0f0-170">Jest on dostarczany z liczbą iteracji (<xref:System.Int64>) jako parametr.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-170">It is provided with the iteration count (<xref:System.Int64>) as a parameter.</span></span>  
  
 <span data-ttu-id="dd0f0-171">Jeśli `fromInclusive` jest większa lub `toExclusive`równa, metoda zwraca natychmiast bez wykonywania jakichkolwiek iteracji.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-171">If `fromInclusive` is greater than or equal to `toExclusive`, the method returns immediately without performing any iterations.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd0f0-172">Argument ma wartość <see langword="null" />. <paramref name="body" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-172">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="dd0f0-173">Wyjątek, który zawiera wszystkie poszczególne wyjątki zgłoszone we wszystkich wątkach.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-173">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="dd0f0-174">Pętle równoległe</span><span class="sxs-lookup"><span data-stu-id="dd0f0-174">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;int,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;int32, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Action{System.Int32,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;int, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * System.Threading.Tasks.ParallelOptions * Action&lt;int, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive"><span data-ttu-id="dd0f0-175">Indeks początkowy włącznie.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-175">The start index, inclusive.</span></span></param>
        <param name="toExclusive"><span data-ttu-id="dd0f0-176">Indeks końcowy, na wyłączność.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-176">The end index, exclusive.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="dd0f0-177">Obiekt, który konfiguruje zachowanie tej operacji.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-177">An object that configures the behavior of this operation.</span></span></param>
        <param name="body"><span data-ttu-id="dd0f0-178">Delegat, który jest wywoływany raz na iterację.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-178">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="dd0f0-179"><see langword="for" /> Wykonuje pętlę, w której iteracje mogą działać równolegle, można skonfigurować opcje pętli, a stan pętli może być monitorowany i manipulowany.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-179">Executes a <see langword="for" /> loop in which iterations may run in parallel, loop options can be configured, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="dd0f0-180">Struktura, która zawiera informacje o tym, która część pętli została ukończona.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-180">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd0f0-181">Delegat jest wywoływany raz dla każdej wartości w zakresie iteracji (`fromInclusive`, `toExclusive`). `body`</span><span class="sxs-lookup"><span data-stu-id="dd0f0-181">The `body` delegate is invoked once for each value in the iteration range (`fromInclusive`, `toExclusive`).</span></span> <span data-ttu-id="dd0f0-182">Jest on dostarczany z następującymi parametrami: liczbą iteracji (<xref:System.Int32>) <xref:System.Threading.Tasks.ParallelLoopState> i wystąpieniem, które może służyć do wcześniejszego przerwania pętli.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-182">It is provided with the following parameters: the iteration count (<xref:System.Int32>), and a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely.</span></span>  
  
 <span data-ttu-id="dd0f0-183">Jeśli `fromInclusive` jest większa lub `toExclusive`równa, metoda zwraca natychmiast bez wykonywania jakichkolwiek iteracji.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-183">If `fromInclusive` is greater than or equal to `toExclusive`, the method returns immediately without performing any iterations.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="dd0f0-184"><see cref="T:System.Threading.CancellationToken" /> W<paramref name="parallelOptions" /> argumencie zostanie anulowana.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-184">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd0f0-185">Argument ma wartość <see langword="null" />. <paramref name="body" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-185">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd0f0-186">—lub—</span><span class="sxs-lookup"><span data-stu-id="dd0f0-186">-or-</span></span> 
<span data-ttu-id="dd0f0-187">Argument ma wartość <see langword="null" />. <paramref name="parallelOptions" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-187">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="dd0f0-188">Wyjątek, który zawiera wszystkie poszczególne wyjątki zgłoszone we wszystkich wątkach.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-188">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="dd0f0-189">Skojarzona z elementem <paramref name="parallelOptions" /> w został usunięty. <see cref="T:System.Threading.CancellationToken" /> <see cref="T:System.Threading.CancellationTokenSource" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-189">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="dd0f0-190">Pętle równoległe</span><span class="sxs-lookup"><span data-stu-id="dd0f0-190">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;int&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;int32&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Action{System.Int32})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;int&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * System.Threading.Tasks.ParallelOptions * Action&lt;int&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive"><span data-ttu-id="dd0f0-191">Indeks początkowy włącznie.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-191">The start index, inclusive.</span></span></param>
        <param name="toExclusive"><span data-ttu-id="dd0f0-192">Indeks końcowy, na wyłączność.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-192">The end index, exclusive.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="dd0f0-193">Obiekt, który konfiguruje zachowanie tej operacji.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-193">An object that configures the behavior of this operation.</span></span></param>
        <param name="body"><span data-ttu-id="dd0f0-194">Delegat, który jest wywoływany raz na iterację.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-194">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="dd0f0-195"><see langword="for" /> Wykonuje pętlę, w której iteracje mogą działać równolegle i można skonfigurować opcje pętli.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-195">Executes a <see langword="for" /> loop in which iterations may run in parallel and loop options can be configured.</span></span></summary>
        <returns><span data-ttu-id="dd0f0-196">Struktura, która zawiera informacje o tym, która część pętli została ukończona.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-196">A  structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd0f0-197">Delegat jest wywoływany raz dla każdej wartości w zakresie iteracji (`fromInclusive`, `toExclusive`). `body`</span><span class="sxs-lookup"><span data-stu-id="dd0f0-197">The `body` delegate is invoked once for each value in the iteration range (`fromInclusive`, `toExclusive`).</span></span> <span data-ttu-id="dd0f0-198">Jest on dostarczany z liczbą iteracji (<xref:System.Int32>) jako parametr.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-198">It is provided with the iteration count (<xref:System.Int32>) as a parameter.</span></span>  
  
 <span data-ttu-id="dd0f0-199">Jeśli `fromInclusive` jest większa lub `toExclusive`równa, metoda zwraca natychmiast bez wykonywania jakichkolwiek iteracji.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-199">If `fromInclusive` is greater than or equal to `toExclusive`, then the method returns immediately without performing any iterations.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd0f0-200">Poniższy przykład pokazuje, jak anulować pętlę równoległą:</span><span class="sxs-lookup"><span data-stu-id="dd0f0-200">The following example shows how to cancel a parallel loop:</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Parallel#05](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelforcancel.cs#05)]
 [!code-vb[System.Threading.Tasks.Parallel#05](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelforcancel.vb#05)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="dd0f0-201"><see cref="T:System.Threading.CancellationToken" /> W<paramref name="parallelOptions" /> argumencie zostanie anulowana.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-201">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd0f0-202">Argument ma wartość <see langword="null" />. <paramref name="body" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-202">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd0f0-203">—lub—</span><span class="sxs-lookup"><span data-stu-id="dd0f0-203">-or-</span></span> 
<span data-ttu-id="dd0f0-204">Argument ma wartość <see langword="null" />. <paramref name="parallelOptions" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-204">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="dd0f0-205">Wyjątek, który zawiera wszystkie poszczególne wyjątki zgłoszone we wszystkich wątkach.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-205">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="dd0f0-206">Skojarzona z elementem <paramref name="parallelOptions" /> w został usunięty. <see cref="T:System.Threading.CancellationToken" /> <see cref="T:System.Threading.CancellationTokenSource" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-206">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="dd0f0-207">Pętle równoległe</span><span class="sxs-lookup"><span data-stu-id="dd0f0-207">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;long,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;int64, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Action{System.Int64,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;long, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * System.Threading.Tasks.ParallelOptions * Action&lt;int64, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive"><span data-ttu-id="dd0f0-208">Indeks początkowy włącznie.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-208">The start index, inclusive.</span></span></param>
        <param name="toExclusive"><span data-ttu-id="dd0f0-209">Indeks końcowy, na wyłączność.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-209">The end index, exclusive.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="dd0f0-210">Obiekt, który konfiguruje zachowanie tej operacji.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-210">An object that configures the behavior of this operation.</span></span></param>
        <param name="body"><span data-ttu-id="dd0f0-211">Delegat, który jest wywoływany raz na iterację.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-211">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="dd0f0-212"><see langword="for" /> Wykonuje pętlę z 64-bitowymi indeksami, w których iteracje mogą działać równolegle, można skonfigurować opcje pętli, a stan pętli może być monitorowany i manipulowany.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-212">Executes a <see langword="for" /> loop with 64-bit indexes in which iterations may run in parallel, loop options can be configured, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="dd0f0-213">Struktura, która zawiera informacje o tym, która część pętli została ukończona.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-213">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd0f0-214">Delegat jest wywoływany raz dla każdej wartości w zakresie iteracji (`fromInclusive`, `toExclusive`). `body`</span><span class="sxs-lookup"><span data-stu-id="dd0f0-214">The `body` delegate is invoked once for each value in the iteration range (`fromInclusive`, `toExclusive`).</span></span> <span data-ttu-id="dd0f0-215">Jest on dostarczany z następującymi parametrami: liczbą iteracji (<xref:System.Int64>) <xref:System.Threading.Tasks.ParallelLoopState> i wystąpieniem, które może służyć do wcześniejszego przerwania pętli.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-215">It is provided with the following parameters: the iteration count (<xref:System.Int64>), and a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely.</span></span>  
  
 <span data-ttu-id="dd0f0-216">Jeśli `fromInclusive` jest większa lub `toExclusive`równa, metoda zwraca natychmiast bez wykonywania jakichkolwiek iteracji.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-216">If `fromInclusive` is greater than or equal to `toExclusive`, the method returns immediately without performing any iterations.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd0f0-217">Poniższy przykład pokazuje, <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> jak używać metody <xref:System.Threading.Tasks.ParallelOptions> z obiektem:</span><span class="sxs-lookup"><span data-stu-id="dd0f0-217">The following example shows how to use the <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> method with a <xref:System.Threading.Tasks.ParallelOptions> object:</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Parallel#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelfor.cs#03)]
 [!code-vb[System.Threading.Tasks.Parallel#03](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelfor.vb#03)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="dd0f0-218"><see cref="T:System.Threading.CancellationToken" /> W<paramref name="parallelOptions" /> argumencie zostanie anulowana.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-218">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd0f0-219">Argument ma wartość <see langword="null" />. <paramref name="body" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-219">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd0f0-220">—lub—</span><span class="sxs-lookup"><span data-stu-id="dd0f0-220">-or-</span></span> 
<span data-ttu-id="dd0f0-221">Argument ma wartość <see langword="null" />. <paramref name="parallelOptions" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-221">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="dd0f0-222">Wyjątek, który zawiera wszystkie poszczególne wyjątki zgłoszone we wszystkich wątkach.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-222">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="dd0f0-223">Skojarzona z elementem <paramref name="parallelOptions" /> w został usunięty. <see cref="T:System.Threading.CancellationToken" /> <see cref="T:System.Threading.CancellationTokenSource" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-223">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="dd0f0-224">Pętle równoległe</span><span class="sxs-lookup"><span data-stu-id="dd0f0-224">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Action{System.Int64})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * System.Threading.Tasks.ParallelOptions * Action&lt;int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive"><span data-ttu-id="dd0f0-225">Indeks początkowy włącznie.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-225">The start index, inclusive.</span></span></param>
        <param name="toExclusive"><span data-ttu-id="dd0f0-226">Indeks końcowy, na wyłączność.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-226">The end index, exclusive.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="dd0f0-227">Obiekt, który konfiguruje zachowanie tej operacji.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-227">An object that configures the behavior of this operation.</span></span></param>
        <param name="body"><span data-ttu-id="dd0f0-228">Delegat, który jest wywoływany raz na iterację.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-228">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="dd0f0-229"><see langword="for" /> Wykonuje pętlę z 64-bitowymi indeksami, w których iteracje mogą być uruchamiane równolegle i można skonfigurować opcje pętli.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-229">Executes a <see langword="for" /> loop with 64-bit indexes in which iterations may run in parallel and loop options can be configured.</span></span></summary>
        <returns><span data-ttu-id="dd0f0-230">Struktura, która zawiera informacje o tym, która część pętli została ukończona.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-230">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd0f0-231">Obsługuje indeksy 64-bitowe.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-231">Supports 64-bit indexes.</span></span> <span data-ttu-id="dd0f0-232">Delegat jest wywoływany raz dla każdej wartości w zakresie iteracji (`fromInclusive`, `toExclusive`). `body`</span><span class="sxs-lookup"><span data-stu-id="dd0f0-232">The `body` delegate is invoked once for each value in the iteration range (`fromInclusive`, `toExclusive`).</span></span> <span data-ttu-id="dd0f0-233">Jest on dostarczany z liczbą iteracji (<xref:System.Int64>) jako parametr.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-233">It is provided with the iteration count (<xref:System.Int64>) as a parameter.</span></span>  
  
 <span data-ttu-id="dd0f0-234">Jeśli `fromInclusive` jest większa lub `toExclusive`równa, metoda zwraca natychmiast bez wykonywania jakichkolwiek iteracji.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-234">If `fromInclusive` is greater than or equal to `toExclusive`, then the method returns immediately without performing any iterations.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd0f0-235">Poniższy przykład pokazuje, jak używać <xref:System.Threading.Tasks.ParallelOptions> do określania niestandardowego harmonogramu zadań:</span><span class="sxs-lookup"><span data-stu-id="dd0f0-235">The following example shows how to use <xref:System.Threading.Tasks.ParallelOptions> to specify a custom task scheduler:</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Parallel#06](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelforwithscheduler.cs#06)]
 [!code-vb[System.Threading.Tasks.Parallel#06](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelforwithscheduler.vb#06)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="dd0f0-236"><see cref="T:System.Threading.CancellationToken" /> W<paramref name="parallelOptions" /> argumencie zostanie anulowana.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-236">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd0f0-237">Argument ma wartość <see langword="null" />. <paramref name="body" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-237">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd0f0-238">—lub—</span><span class="sxs-lookup"><span data-stu-id="dd0f0-238">-or-</span></span> 
<span data-ttu-id="dd0f0-239">Argument ma wartość <see langword="null" />. <paramref name="parallelOptions" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-239">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="dd0f0-240">Wyjątek, który zawiera wszystkie poszczególne wyjątki zgłoszone we wszystkich wątkach.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-240">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="dd0f0-241">Skojarzona z elementem <paramref name="parallelOptions" /> w został usunięty. <see cref="T:System.Threading.CancellationToken" /> <see cref="T:System.Threading.CancellationTokenSource" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-241">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="dd0f0-242">Pętle równoległe</span><span class="sxs-lookup"><span data-stu-id="dd0f0-242">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (int fromInclusive, int toExclusive, Func&lt;TLocal&gt; localInit, Func&lt;int,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int32 fromInclusive, int32 toExclusive, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int32, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int32,System.Int32,System.Func{``0},System.Func{System.Int32,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For(Of TLocal) (fromInclusive As Integer, toExclusive As Integer, localInit As Func(Of TLocal), body As Func(Of Integer, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, Func&lt;TLocal&gt; ^ localInit, Func&lt;int, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int * int * Func&lt;'Local&gt; * Func&lt;int, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int32,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal"><span data-ttu-id="dd0f0-243">Typ danych lokalnych wątku.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-243">The type of the thread-local data.</span></span></typeparam>
        <param name="fromInclusive"><span data-ttu-id="dd0f0-244">Indeks początkowy włącznie.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-244">The start index, inclusive.</span></span></param>
        <param name="toExclusive"><span data-ttu-id="dd0f0-245">Indeks końcowy, na wyłączność.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-245">The end index, exclusive.</span></span></param>
        <param name="localInit"><span data-ttu-id="dd0f0-246">Delegat funkcji, który zwraca początkowy stan danych lokalnych dla każdego zadania.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-246">The function delegate that returns the initial state of the local data for each task.</span></span></param>
        <param name="body"><span data-ttu-id="dd0f0-247">Delegat, który jest wywoływany raz na iterację.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-247">The delegate that is invoked once per iteration.</span></span></param>
        <param name="localFinally"><span data-ttu-id="dd0f0-248">Delegat, który wykonuje ostateczną akcję na lokalnym stanie każdego zadania.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-248">The delegate that performs a final action on the local state of each task.</span></span></param>
        <summary><span data-ttu-id="dd0f0-249"><see langword="for" /> Wykonuje pętlę z danymi lokalnymi wątku, w których iteracje mogą działać równolegle, a stan pętli może być monitorowany i manipulowany.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-249">Executes a <see langword="for" /> loop with thread-local data in which iterations may run in parallel, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="dd0f0-250">Struktura, która zawiera informacje o tym, która część pętli została ukończona.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-250">A  structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd0f0-251">Delegat jest wywoływany raz dla każdej wartości w zakresie iteracji (`fromInclusive`, `toExclusive`). `body`</span><span class="sxs-lookup"><span data-stu-id="dd0f0-251">The `body` delegate is invoked once for each value in the iteration range (`fromInclusive`, `toExclusive`).</span></span> <span data-ttu-id="dd0f0-252">Jest on dostarczany z następującymi parametrami: licznik iteracji (<xref:System.Int32>) <xref:System.Threading.Tasks.ParallelLoopState> , wystąpienie, które może służyć do wypełniania pętli przedwcześnie i niektórych stanów lokalnych, które mogą być współużytkowane przez iteracje wykonywane w tym samym wątku.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-252">It is provided with the following parameters: the iteration count (<xref:System.Int32>), a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely, and some local state that may be shared amongst iterations that execute on the same thread.</span></span>  
  
 <span data-ttu-id="dd0f0-253">`localInit` Delegat jest wywoływany jednokrotnie dla każdego zadania, które uczestniczy w wykonaniu pętli i zwraca początkowy stan lokalny dla każdego z tych zadań.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-253">The `localInit` delegate is invoked once for each task that participates in the loop's execution and returns the initial local state for each of those tasks.</span></span> <span data-ttu-id="dd0f0-254">Te Stany początkowe są przesyłane do pierwszych `body` wywołań każdego zadania.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-254">These initial states are passed to the first `body` invocations on each task.</span></span> <span data-ttu-id="dd0f0-255">Następnie każde kolejne wywołanie treści zwróci prawdopodobnie zmodyfikowaną wartość stanu, która jest przenoszona do następnego wywołania treści.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-255">Then, every subsequent body invocation returns a possibly modified state value that is passed to the next body invocation.</span></span> <span data-ttu-id="dd0f0-256">Na koniec ostatnie wywołanie treści dla każdego zadania zwraca wartość stanu, która jest przenoszona do `localFinally` delegata.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-256">Finally, the last body invocation on each task returns a state value that is passed to the `localFinally` delegate.</span></span> <span data-ttu-id="dd0f0-257">`localFinally` Delegat jest wywoływany raz na zadanie w celu wykonania końcowej akcji na lokalnym stanie każdego zadania.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-257">The `localFinally` delegate is invoked once per task to perform a final action on each task's local state.</span></span> <span data-ttu-id="dd0f0-258">Ten delegat może być wywoływany współbieżnie dla wielu zadań; w związku z tym należy synchronizować dostęp do dowolnych zmiennych udostępnionych.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-258">This delegate might be invoked concurrently on multiple tasks; therefore, you must synchronize access to any shared variables.</span></span>  
  
 <span data-ttu-id="dd0f0-259"><xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> Metoda może korzystać z większej liczby zadań niż wątki w okresie istnienia wykonywania, ponieważ istniejące zadania zostały ukończone i są zastępowane przez nowe zadania.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-259">The <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> method may use more tasks than threads over the lifetime of its execution, as existing tasks complete and are replaced by new tasks.</span></span> <span data-ttu-id="dd0f0-260">Dzięki temu obiekt źródłowy <xref:System.Threading.Tasks.TaskScheduler> może dodawać, zmieniać lub usuwać wątki obsługujące pętlę.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-260">This gives the underlying <xref:System.Threading.Tasks.TaskScheduler> object the chance to add, change, or remove threads that service the loop.</span></span>  
  
 <span data-ttu-id="dd0f0-261">Jeśli `fromInclusive` jest większa lub `toExclusive`równa, metoda zwraca natychmiast bez wykonywania jakichkolwiek iteracji.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-261">If `fromInclusive` is greater than or equal to `toExclusive`, then the method returns immediately without performing any iterations.</span></span>  
  
 <span data-ttu-id="dd0f0-262">Aby zapoznać się z przykładem korzystającym z [tej metody, zobacz How to: Napisz Parallel. for pętlę ze zmiennymi](~/docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md)lokalnymi wątku.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-262">For an example that uses this method, see [How to: Write a Parallel.For Loop with Thread-Local Variables](~/docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd0f0-263">Argument ma wartość <see langword="null" />. <paramref name="body" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-263">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd0f0-264">—lub—</span><span class="sxs-lookup"><span data-stu-id="dd0f0-264">-or-</span></span> 
<span data-ttu-id="dd0f0-265">Argument ma wartość <see langword="null" />. <paramref name="localInit" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-265">The <paramref name="localInit" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd0f0-266">—lub—</span><span class="sxs-lookup"><span data-stu-id="dd0f0-266">-or-</span></span> 
<span data-ttu-id="dd0f0-267">Argument ma wartość <see langword="null" />. <paramref name="localFinally" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-267">The <paramref name="localFinally" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="dd0f0-268">Wyjątek, który zawiera wszystkie poszczególne wyjątki zgłoszone we wszystkich wątkach.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-268">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="dd0f0-269">Pętle równoległe</span><span class="sxs-lookup"><span data-stu-id="dd0f0-269">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (long fromInclusive, long toExclusive, Func&lt;TLocal&gt; localInit, Func&lt;long,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int64 fromInclusive, int64 toExclusive, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int64, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int64,System.Int64,System.Func{``0},System.Func{System.Int64,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For(Of TLocal) (fromInclusive As Long, toExclusive As Long, localInit As Func(Of TLocal), body As Func(Of Long, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, Func&lt;TLocal&gt; ^ localInit, Func&lt;long, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * Func&lt;'Local&gt; * Func&lt;int64, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int64,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal"><span data-ttu-id="dd0f0-270">Typ danych lokalnych wątku.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-270">The type of the thread-local data.</span></span></typeparam>
        <param name="fromInclusive"><span data-ttu-id="dd0f0-271">Indeks początkowy włącznie.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-271">The start index, inclusive.</span></span></param>
        <param name="toExclusive"><span data-ttu-id="dd0f0-272">Indeks końcowy, na wyłączność.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-272">The end index, exclusive.</span></span></param>
        <param name="localInit"><span data-ttu-id="dd0f0-273">Delegat funkcji, który zwraca początkowy stan danych lokalnych dla każdego zadania.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-273">The function delegate that returns the initial state of the local data for each task.</span></span></param>
        <param name="body"><span data-ttu-id="dd0f0-274">Delegat, który jest wywoływany raz na iterację.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-274">The delegate that is invoked once per iteration.</span></span></param>
        <param name="localFinally"><span data-ttu-id="dd0f0-275">Delegat, który wykonuje ostateczną akcję na lokalnym stanie każdego zadania.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-275">The delegate that performs a final action on the local state of each task.</span></span></param>
        <summary><span data-ttu-id="dd0f0-276"><see langword="for" /> Wykonuje pętlę z 64-bitowymi indeksami i danymi lokalnymi wątku, w których iteracje mogą działać równolegle, a stan pętli może być monitorowany i manipulowany.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-276">Executes a <see langword="for" /> loop with 64-bit indexes and thread-local data in which iterations may run in parallel, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="dd0f0-277">Struktura, która zawiera informacje o tym, która część pętli została ukończona.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-277">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd0f0-278">Delegat jest wywoływany raz dla każdej wartości w zakresie iteracji (`fromInclusive`, `toExclusive`). `body`</span><span class="sxs-lookup"><span data-stu-id="dd0f0-278">The `body` delegate is invoked once for each value in the iteration range (`fromInclusive`, `toExclusive`).</span></span> <span data-ttu-id="dd0f0-279">Jest on dostarczany z następującymi parametrami: licznik iteracji (<xref:System.Int64>) <xref:System.Threading.Tasks.ParallelLoopState> , wystąpienie, które może służyć do wypełniania pętli przedwcześnie i niektórych stanów lokalnych, które mogą być współużytkowane przez iteracje wykonywane w ramach tego samego zadania.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-279">It is provided with the following parameters: the iteration count (<xref:System.Int64>), a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely, and some local state that may be shared amongst iterations that execute on the same task.</span></span>  
  
 <span data-ttu-id="dd0f0-280">`localInit` Delegat jest wywoływany jednokrotnie dla każdego zadania, które uczestniczy w wykonaniu pętli i zwraca początkowy stan lokalny dla każdego z tych zadań.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-280">The `localInit` delegate is invoked once for each task that participates in the loop's execution and returns the initial local state for each of those tasks.</span></span> <span data-ttu-id="dd0f0-281">Te Stany początkowe są przesyłane do pierwszych `body` wywołań każdego zadania.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-281">These initial states are passed to the first `body` invocations on each task.</span></span> <span data-ttu-id="dd0f0-282">Następnie każde kolejne wywołanie treści zwróci prawdopodobnie zmodyfikowaną wartość stanu, która jest przenoszona do następnego wywołania treści.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-282">Then, every subsequent body invocation returns a possibly modified state value that is passed to the next body invocation.</span></span> <span data-ttu-id="dd0f0-283">Na koniec ostatnie wywołanie treści dla każdego zadania zwraca wartość stanu, która jest przenoszona do `localFinally` delegata.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-283">Finally, the last body invocation on each task returns a state value that is passed to the `localFinally` delegate.</span></span> <span data-ttu-id="dd0f0-284">`localFinally` Delegat jest wywoływany raz na zadanie w celu wykonania końcowej akcji na lokalnym stanie każdego zadania.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-284">The `localFinally` delegate is invoked once per task to perform a final action on each task's local state.</span></span> <span data-ttu-id="dd0f0-285">Ten delegat może być wywoływany współbieżnie dla wielu zadań; w związku z tym należy synchronizować dostęp do dowolnych zmiennych udostępnionych.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-285">This delegate might be invoked concurrently on multiple tasks; therefore, you must synchronize access to any shared variables.</span></span>  
  
 <span data-ttu-id="dd0f0-286"><xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> Metoda może korzystać z większej liczby zadań niż wątki w okresie istnienia wykonywania, ponieważ istniejące zadania zostały ukończone i są zastępowane przez nowe zadania.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-286">The <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> method may use more tasks than threads over the lifetime of its execution, as existing tasks complete and are replaced by new tasks.</span></span> <span data-ttu-id="dd0f0-287">Dzięki temu obiekt źródłowy <xref:System.Threading.Tasks.TaskScheduler> może dodawać, zmieniać lub usuwać wątki obsługujące pętlę.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-287">This gives the underlying <xref:System.Threading.Tasks.TaskScheduler> object the chance to add, change, or remove threads that service the loop.</span></span>  
  
 <span data-ttu-id="dd0f0-288">Jeśli `fromInclusive` jest większa lub `toExclusive`równa, metoda zwraca natychmiast bez wykonywania jakichkolwiek iteracji.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-288">If `fromInclusive` is greater than or equal to `toExclusive`, then the method returns immediately without performing any iterations.</span></span>  
  
 <span data-ttu-id="dd0f0-289">Aby zapoznać się z przykładem korzystającym z [tej metody, zobacz How to: Napisz Parallel. for pętlę ze zmiennymi](~/docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md)lokalnymi wątku.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-289">For an example that uses this method, see [How to: Write a Parallel.For Loop with Thread-Local Variables](~/docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd0f0-290">Argument ma wartość <see langword="null" />. <paramref name="body" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-290">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd0f0-291">—lub—</span><span class="sxs-lookup"><span data-stu-id="dd0f0-291">-or-</span></span> 
<span data-ttu-id="dd0f0-292">Argument ma wartość <see langword="null" />. <paramref name="localInit" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-292">The <paramref name="localInit" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd0f0-293">—lub—</span><span class="sxs-lookup"><span data-stu-id="dd0f0-293">-or-</span></span> 
<span data-ttu-id="dd0f0-294">Argument ma wartość <see langword="null" />. <paramref name="localFinally" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-294">The <paramref name="localFinally" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="dd0f0-295">Wyjątek, który zawiera wszystkie poszczególne wyjątki zgłoszone we wszystkich wątkach.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-295">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="dd0f0-296">Pętle równoległe</span><span class="sxs-lookup"><span data-stu-id="dd0f0-296">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (int fromInclusive, int toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;int,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int32 fromInclusive, int32 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int32, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Func{``0},System.Func{System.Int32,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;int, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int * int * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;int, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int32,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal"><span data-ttu-id="dd0f0-297">Typ danych lokalnych wątku.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-297">The type of the thread-local data.</span></span></typeparam>
        <param name="fromInclusive"><span data-ttu-id="dd0f0-298">Indeks początkowy włącznie.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-298">The start index, inclusive.</span></span></param>
        <param name="toExclusive"><span data-ttu-id="dd0f0-299">Indeks końcowy, na wyłączność.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-299">The end index, exclusive.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="dd0f0-300">Obiekt, który konfiguruje zachowanie tej operacji.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-300">An object that configures the behavior of this operation.</span></span></param>
        <param name="localInit"><span data-ttu-id="dd0f0-301">Delegat funkcji, który zwraca początkowy stan danych lokalnych dla każdego zadania.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-301">The function delegate that returns the initial state of the local data for each task.</span></span></param>
        <param name="body"><span data-ttu-id="dd0f0-302">Delegat, który jest wywoływany raz na iterację.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-302">The delegate that is invoked once per iteration.</span></span></param>
        <param name="localFinally"><span data-ttu-id="dd0f0-303">Delegat, który wykonuje ostateczną akcję na lokalnym stanie każdego zadania.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-303">The delegate that performs a final action on the local state of each task.</span></span></param>
        <summary><span data-ttu-id="dd0f0-304"><see langword="for" /> Wykonuje pętlę z danymi lokalnymi wątku, w których iteracje mogą działać równolegle, można skonfigurować opcje pętli, a stan pętli może być monitorowany i manipulowany.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-304">Executes a <see langword="for" /> loop with thread-local data in which iterations may run in parallel, loop options can be configured, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="dd0f0-305">Struktura, która zawiera informacje o tym, która część pętli została ukończona.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-305">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd0f0-306">Delegat jest wywoływany raz dla każdej wartości w zakresie iteracji (`fromInclusive`, `toExclusive`). `body`</span><span class="sxs-lookup"><span data-stu-id="dd0f0-306">The `body` delegate is invoked once for each value in the iteration range (`fromInclusive`, `toExclusive`).</span></span> <span data-ttu-id="dd0f0-307">Jest on dostarczany z następującymi parametrami: licznik iteracji (<xref:System.Int32>) <xref:System.Threading.Tasks.ParallelLoopState> , wystąpienie, które może służyć do wypełniania pętli przedwcześnie i niektórych stanów lokalnych, które mogą być współużytkowane przez iteracje wykonywane w ramach tego samego zadania.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-307">It is provided with the following parameters: the iteration count (<xref:System.Int32>), a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely, and some local state that may be shared amongst iterations that execute on the same task.</span></span>  
  
 <span data-ttu-id="dd0f0-308">`localInit` Delegat jest wywoływany jednokrotnie dla każdego zadania, które uczestniczy w wykonaniu pętli i zwraca początkowy stan lokalny dla każdego z tych zadań.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-308">The `localInit` delegate is invoked once for each task that participates in the loop's execution and returns the initial local state for each of those tasks.</span></span> <span data-ttu-id="dd0f0-309">Te Stany początkowe są przesyłane do pierwszych `body` wywołań każdego zadania.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-309">These initial states are passed to the first `body` invocations on each task.</span></span> <span data-ttu-id="dd0f0-310">Następnie każde kolejne wywołanie treści zwróci prawdopodobnie zmodyfikowaną wartość stanu, która jest przenoszona do następnego wywołania treści.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-310">Then, every subsequent body invocation returns a possibly modified state value that is passed to the next body invocation.</span></span> <span data-ttu-id="dd0f0-311">Na koniec ostatnie wywołanie treści dla każdego zadania zwraca wartość stanu, która jest przenoszona do `localFinally` delegata.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-311">Finally, the last body invocation on each task returns a state value that is passed to the `localFinally` delegate.</span></span> <span data-ttu-id="dd0f0-312">`localFinally` Delegat jest wywoływany raz na zadanie w celu wykonania końcowej akcji na lokalnym stanie każdego zadania.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-312">The `localFinally` delegate is invoked once per task to perform a final action on each task's local state.</span></span> <span data-ttu-id="dd0f0-313">Ten delegat może być wywoływany współbieżnie w wielu wątkach; w związku z tym należy synchronizować dostęp do dowolnych zmiennych udostępnionych.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-313">This delegate might be invoked concurrently on multiple threads; therefore, you must synchronize access to any shared variables.</span></span>  
  
 <span data-ttu-id="dd0f0-314"><xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> Metoda może korzystać z większej liczby zadań niż wątki w okresie istnienia wykonywania, ponieważ istniejące zadania zostały ukończone i są zastępowane przez nowe zadania.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-314">The <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> method may use more tasks than threads over the lifetime of its execution, as existing tasks complete and are replaced by new tasks.</span></span> <span data-ttu-id="dd0f0-315">Dzięki temu obiekt źródłowy <xref:System.Threading.Tasks.TaskScheduler> może dodawać, zmieniać lub usuwać wątki obsługujące pętlę.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-315">This gives the underlying <xref:System.Threading.Tasks.TaskScheduler> object the chance to add, change, or remove threads that service the loop.</span></span>  
  
 <span data-ttu-id="dd0f0-316">Jeśli `fromInclusive` jest większa lub `toExclusive`równa, metoda zwraca natychmiast bez wykonywania jakichkolwiek iteracji.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-316">If `fromInclusive` is greater than or equal to `toExclusive`, then the method returns immediately without performing any iterations.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd0f0-317">W poniższym przykładzie zastosowano zmienne lokalne wątku w celu obliczenia sumy wyników wielu długotrwałych operacji.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-317">The following example uses thread-local variables to compute the sum of the results of many lengthy operations.</span></span> <span data-ttu-id="dd0f0-318">Ten przykład ogranicza stopień równoległości do czterech.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-318">This example limits the degree of parallelism to four.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Parallel#04](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/threadlocalforwithoptions.cs#04)]
 [!code-vb[System.Threading.Tasks.Parallel#04](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/threadlocalforwithoptions.vb#04)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd0f0-319">Argument ma wartość <see langword="null" />. <paramref name="body" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-319">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd0f0-320">—lub—</span><span class="sxs-lookup"><span data-stu-id="dd0f0-320">-or-</span></span> 
<span data-ttu-id="dd0f0-321">Argument ma wartość <see langword="null" />. <paramref name="localInit" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-321">The <paramref name="localInit" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd0f0-322">—lub—</span><span class="sxs-lookup"><span data-stu-id="dd0f0-322">-or-</span></span> 
<span data-ttu-id="dd0f0-323">Argument ma wartość <see langword="null" />. <paramref name="localFinally" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-323">The <paramref name="localFinally" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd0f0-324">—lub—</span><span class="sxs-lookup"><span data-stu-id="dd0f0-324">-or-</span></span> 
<span data-ttu-id="dd0f0-325">Argument ma wartość <see langword="null" />. <paramref name="parallelOptions" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-325">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="dd0f0-326"><see cref="T:System.Threading.CancellationToken" /> W<paramref name="parallelOptions" /> argumencie zostanie anulowana.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-326">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="dd0f0-327">Skojarzona z elementem <paramref name="parallelOptions" /> w został usunięty. <see cref="T:System.Threading.CancellationToken" /> <see cref="T:System.Threading.CancellationTokenSource" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-327">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="dd0f0-328">Wyjątek, który zawiera wszystkie poszczególne wyjątki zgłoszone we wszystkich wątkach.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-328">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="dd0f0-329">Pętle równoległe</span><span class="sxs-lookup"><span data-stu-id="dd0f0-329">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (long fromInclusive, long toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;long,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int64 fromInclusive, int64 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int64, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Func{``0},System.Func{System.Int64,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;long, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;int64, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int64,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal"><span data-ttu-id="dd0f0-330">Typ danych lokalnych wątku.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-330">The type of the thread-local data.</span></span></typeparam>
        <param name="fromInclusive"><span data-ttu-id="dd0f0-331">Indeks początkowy włącznie.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-331">The start index, inclusive.</span></span></param>
        <param name="toExclusive"><span data-ttu-id="dd0f0-332">Indeks końcowy, na wyłączność.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-332">The end index, exclusive.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="dd0f0-333">Obiekt, który konfiguruje zachowanie tej operacji.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-333">An object that configures the behavior of this operation.</span></span></param>
        <param name="localInit"><span data-ttu-id="dd0f0-334">Delegat funkcji, który zwraca początkowy stan danych lokalnych dla każdego wątku.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-334">The function delegate that returns the initial state of the local data for each thread.</span></span></param>
        <param name="body"><span data-ttu-id="dd0f0-335">Delegat, który jest wywoływany raz na iterację.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-335">The delegate that is invoked once per iteration.</span></span></param>
        <param name="localFinally"><span data-ttu-id="dd0f0-336">Delegat wykonujący ostateczną akcję dla stanu lokalnego każdego wątku.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-336">The delegate that performs a final action on the local state of each thread.</span></span></param>
        <summary><span data-ttu-id="dd0f0-337"><see langword="for" /> Wykonuje pętlę z 64-bitowymi indeksami i danymi lokalnymi wątku, w których iteracje mogą działać równolegle, można skonfigurować opcje pętli, a stan pętli można monitorować i manipulować.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-337">Executes a <see langword="for" /> loop with 64-bit indexes and thread-local data in which iterations may run in parallel, loop options can be configured, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="dd0f0-338">Struktura, która zawiera informacje o tym, która część pętli została ukończona.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-338">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd0f0-339">Delegat jest wywoływany raz dla każdej wartości w zakresie iteracji (`fromInclusive`, `toExclusive`). `body`</span><span class="sxs-lookup"><span data-stu-id="dd0f0-339">The `body` delegate is invoked once for each value in the iteration range (`fromInclusive`, `toExclusive`).</span></span> <span data-ttu-id="dd0f0-340">Jest on dostarczany z następującymi parametrami: licznik iteracji (<xref:System.Int64>) <xref:System.Threading.Tasks.ParallelLoopState> , wystąpienie, które może służyć do wypełniania pętli przedwcześnie i niektórych stanów lokalnych, które mogą być współużytkowane przez iteracje wykonywane w tym samym wątku.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-340">It is provided with the following parameters: the iteration count (<xref:System.Int64>), a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely, and some local state that may be shared amongst iterations that execute on the same thread.</span></span>  
  
 <span data-ttu-id="dd0f0-341">`localInit` Delegat jest wywoływany raz dla każdego wątku, który uczestniczy w wykonaniu pętli i zwraca początkowy stan lokalny dla każdego z tych wątków.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-341">The `localInit` delegate is invoked once for each thread that participates in the loop's execution and returns the initial local state for each of those threads.</span></span> <span data-ttu-id="dd0f0-342">Te Stany początkowe są przesyłane do pierwszego `body` wywołania w każdym wątku.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-342">These initial states are passed to the first `body` invocations on each thread.</span></span> <span data-ttu-id="dd0f0-343">Następnie każde kolejne wywołanie treści zwróci prawdopodobnie zmodyfikowaną wartość stanu, która jest przenoszona do następnego wywołania treści.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-343">Then, every subsequent body invocation returns a possibly modified state value that is passed to the next body invocation.</span></span> <span data-ttu-id="dd0f0-344">Na koniec ostatnie wywołanie treści dla każdego wątku zwraca wartość stanu, która jest przenoszona do `localFinally` delegata.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-344">Finally, the last body invocation on each thread returns a state value that is passed to the `localFinally` delegate.</span></span> <span data-ttu-id="dd0f0-345">`localFinally` Delegat jest wywoływany raz na wątek, aby wykonać ostateczną akcję na stanie lokalnym każdego wątku.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-345">The `localFinally` delegate is invoked once per thread to perform a final action on each thread's local state.</span></span> <span data-ttu-id="dd0f0-346">Ten delegat może być wywoływany współbieżnie w wielu wątkach; w związku z tym należy synchronizować dostęp do dowolnych zmiennych udostępnionych.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-346">This delegate might be invoked concurrently on multiple threads; therefore, you must synchronize access to any shared variables.</span></span>  
  
 <span data-ttu-id="dd0f0-347"><xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> Metoda może korzystać z większej liczby zadań niż wątki w okresie istnienia wykonywania, ponieważ istniejące zadania zostały ukończone i są zastępowane przez nowe zadania.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-347">The <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> method may use more tasks than threads over the lifetime of its execution, as existing tasks complete and are replaced by new tasks.</span></span> <span data-ttu-id="dd0f0-348">Dzięki temu obiekt źródłowy <xref:System.Threading.Tasks.TaskScheduler> może dodawać, zmieniać lub usuwać wątki obsługujące pętlę.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-348">This gives the underlying <xref:System.Threading.Tasks.TaskScheduler> object the chance to add, change, or remove threads that service the loop.</span></span>  
  
 <span data-ttu-id="dd0f0-349">Jeśli `fromInclusive` jest większa lub `toExclusive`równa, metoda zwraca natychmiast bez wykonywania jakichkolwiek iteracji.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-349">If `fromInclusive` is greater than or equal to `toExclusive`, then the method returns immediately without performing any iterations.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd0f0-350">Argument ma wartość <see langword="null" />. <paramref name="body" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-350">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd0f0-351">—lub—</span><span class="sxs-lookup"><span data-stu-id="dd0f0-351">-or-</span></span> 
<span data-ttu-id="dd0f0-352">Argument ma wartość <see langword="null" />. <paramref name="localInit" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-352">The <paramref name="localInit" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd0f0-353">—lub—</span><span class="sxs-lookup"><span data-stu-id="dd0f0-353">-or-</span></span> 
<span data-ttu-id="dd0f0-354">Argument ma wartość <see langword="null" />. <paramref name="localFinally" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-354">The <paramref name="localFinally" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd0f0-355">—lub—</span><span class="sxs-lookup"><span data-stu-id="dd0f0-355">-or-</span></span> 
<span data-ttu-id="dd0f0-356">Argument ma wartość <see langword="null" />. <paramref name="parallelOptions" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-356">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="dd0f0-357"><see cref="T:System.Threading.CancellationToken" /> W<paramref name="parallelOptions" /> argumencie zostanie anulowana.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-357">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="dd0f0-358">Skojarzona z elementem <paramref name="parallelOptions" /> w został usunięty. <see cref="T:System.Threading.CancellationToken" /> <see cref="T:System.Threading.CancellationTokenSource" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-358">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="dd0f0-359">Wyjątek, który zawiera wszystkie poszczególne wyjątki zgłoszone we wszystkich wątkach.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-359">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="dd0f0-360">Pętle równoległe</span><span class="sxs-lookup"><span data-stu-id="dd0f0-360">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ForEach&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="dd0f0-361">Wykonuje operację<see langword="For Each " /> (w Visual Basic), w której iteracje mogą być uruchamiane równolegle. <see langword="foreach" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-361">Executes a <see langword="foreach" /> (<see langword="For Each " /> in Visual Basic) operation in which iterations may run in parallel.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.OrderablePartitioner{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As OrderablePartitioner(Of TSource), body As Action(Of TSource, ParallelLoopState, Long)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="dd0f0-362">Typ elementów w <paramref name="source" />.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-362">The type of the elements in <paramref name="source" />.</span></span></typeparam>
        <param name="source"><span data-ttu-id="dd0f0-363">Uporządkowana partycja, która zawiera oryginalne źródło danych.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-363">The orderable partitioner that contains the original data source.</span></span></param>
        <param name="body"><span data-ttu-id="dd0f0-364">Delegat, który jest wywoływany raz na iterację.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-364">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="dd0f0-365">Wykonuje operację<see langword="For Each" /> <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> (w Visual Basic), w której iteracje mogą działać równolegle, a stan pętli może być monitorowany i manipulowany. <see langword="foreach" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-365">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation on a <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> in which iterations may run in parallel and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="dd0f0-366">Struktura, która zawiera informacje o tym, która część pętli została ukończona.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-366">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd0f0-367">To przeciążenie jest dostępne dla scenariuszy, w których chcesz przesłonić domyślny schemat partycjonowania.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-367">This overload is provided for scenarios where you want to override the default partitioning scheme.</span></span> <span data-ttu-id="dd0f0-368">Na przykład małe treści pętli mogą korzystać z partycjonowania zakresu.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-368">For example, small loop bodies might benefit from partitioning the range.</span></span> <span data-ttu-id="dd0f0-369">Metoda <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> oczekuje, że niestandardowe partycje obsługują partycjonowanie dynamiczne.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-369">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method expects custom partitioners to support dynamic partitioning.</span></span> <span data-ttu-id="dd0f0-370">Aby uzyskać więcej informacji, zobacz [niestandardowe partycje dla PLINQ i TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) i [instrukcje: Implementowanie partycji](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)dynamicznych.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-370">For more information, see [Custom Partitioners for PLINQ and TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) and [How to: Implement Dynamic Partitions](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd0f0-371">Argument ma wartość <see langword="null" />. <paramref name="source" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-371">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd0f0-372">—lub—</span><span class="sxs-lookup"><span data-stu-id="dd0f0-372">-or-</span></span> 
<span data-ttu-id="dd0f0-373">Argument ma wartość <see langword="null" />. <paramref name="body" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-373">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="dd0f0-374">Właściwość w <paramref name="source" /> powrocie<see langword="false" />do kolejności partycjonowania. <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-374">The <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> property in the <paramref name="source" /> orderable partitioner returns <see langword="false" />.</span></span>  
  
<span data-ttu-id="dd0f0-375">—lub—</span><span class="sxs-lookup"><span data-stu-id="dd0f0-375">-or-</span></span> 
<span data-ttu-id="dd0f0-376">Właściwość w źródłowym partycjonowanym partycji zwraca <see langword="false" />. <see cref="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysNormalized" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-376">The <see cref="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysNormalized" /> property in the source orderable partitioner returns <see langword="false" />.</span></span>  
  
<span data-ttu-id="dd0f0-377">—lub—</span><span class="sxs-lookup"><span data-stu-id="dd0f0-377">-or-</span></span> 
<span data-ttu-id="dd0f0-378">Wszelkie metody w powrocie <see langword="null" />do pożądanej partycji.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-378">Any methods in the source orderable partitioner return <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="dd0f0-379">Wyjątek zgłoszony przez jednego z określonych delegatów.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-379">The exception thrown from one of the specified delegates.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="dd0f0-380">Pętle równoległe</span><span class="sxs-lookup"><span data-stu-id="dd0f0-380">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As Partitioner(Of TSource), body As Action(Of TSource, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="dd0f0-381">Typ elementów w <paramref name="source" />.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-381">The type of the elements in <paramref name="source" />.</span></span></typeparam>
        <param name="source"><span data-ttu-id="dd0f0-382">Partycja zawierająca oryginalne źródło danych.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-382">The partitioner that contains the original data source.</span></span></param>
        <param name="body"><span data-ttu-id="dd0f0-383">Delegat, który jest wywoływany raz na iterację.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-383">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="dd0f0-384">Wykonuje operację<see langword="For Each" /> <see cref="T:System.Collections.Concurrent.Partitioner" /> (w Visual Basic) na, w której iteracje mogą działać równolegle, a stan pętli może być monitorowany i manipulowany. <see langword="foreach" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-384">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation on a <see cref="T:System.Collections.Concurrent.Partitioner" /> in which iterations may run in parallel, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="dd0f0-385">Struktura, która zawiera informacje o tym, która część pętli została ukończona.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-385">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd0f0-386">To przeciążenie jest dostępne dla scenariuszy, w których chcesz przesłonić domyślny schemat partycjonowania.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-386">This overload is provided for scenarios where you want to override the default partitioning scheme.</span></span> <span data-ttu-id="dd0f0-387">Na przykład małe treści pętli mogą korzystać z partycjonowania zakresu.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-387">For example, small loop bodies might benefit from partitioning the range.</span></span> <span data-ttu-id="dd0f0-388">Metoda <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> oczekuje, że niestandardowe partycje obsługują partycjonowanie dynamiczne.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-388">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method expects custom partitioners to support dynamic partitioning.</span></span> <span data-ttu-id="dd0f0-389">Aby uzyskać więcej informacji, zobacz [niestandardowe partycje dla PLINQ i TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) i [instrukcje: Implementowanie partycji](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)dynamicznych.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-389">For more information, see [Custom Partitioners for PLINQ and TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) and [How to: Implement Dynamic Partitions](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd0f0-390">Argument ma wartość <see langword="null" />. <paramref name="source" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-390">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd0f0-391">—lub—</span><span class="sxs-lookup"><span data-stu-id="dd0f0-391">-or-</span></span> 
<span data-ttu-id="dd0f0-392">Argument ma wartość <see langword="null" />. <paramref name="body" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-392">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="dd0f0-393">Właściwość w programie Partitioner<see langword="false" />zwraca wartość. <paramref name="source" /> <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-393">The <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> property in the <paramref name="source" /> partitioner returns <see langword="false" />.</span></span>  
  
<span data-ttu-id="dd0f0-394">—lub—</span><span class="sxs-lookup"><span data-stu-id="dd0f0-394">-or-</span></span> 
<span data-ttu-id="dd0f0-395">Metoda w programie <paramref name="source" /> Partitioner zwraca wartość <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-395">A method in the <paramref name="source" /> partitioner returns <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd0f0-396">—lub—</span><span class="sxs-lookup"><span data-stu-id="dd0f0-396">-or-</span></span> 
<span data-ttu-id="dd0f0-397"><see cref="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)" /> Metoda<paramref name="source" /> w programie partitioner nie zwraca poprawnej liczby partycji.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-397">The <see cref="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)" /> method in the <paramref name="source" /> partitioner does not return the correct number of partitions.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="dd0f0-398">Pętle równoległe</span><span class="sxs-lookup"><span data-stu-id="dd0f0-398">Parallel Loops</span></span></related>
        <exception cref="T:System.AggregateException"><span data-ttu-id="dd0f0-399">Wyjątek, który jest generowany, zawiera wyjątek zgłoszony z jednego z określonych delegatów.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-399">The exception that is thrown to contain an exception thrown from one of the specified delegates.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As Partitioner(Of TSource), body As Action(Of TSource)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="dd0f0-400">Typ elementów w <paramref name="source" />.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-400">The type of the elements in <paramref name="source" />.</span></span></typeparam>
        <param name="source"><span data-ttu-id="dd0f0-401">Partycja zawierająca oryginalne źródło danych.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-401">The partitioner that contains the original data source.</span></span></param>
        <param name="body"><span data-ttu-id="dd0f0-402">Delegat, który jest wywoływany raz na iterację.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-402">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="dd0f0-403">Wykonuje operację<see langword="For Each" /> <see cref="T:System.Collections.Concurrent.Partitioner" /> (w Visual Basic) na, w której iteracje mogą być uruchamiane równolegle. <see langword="foreach" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-403">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation on a <see cref="T:System.Collections.Concurrent.Partitioner" /> in which iterations may run in parallel.</span></span></summary>
        <returns><span data-ttu-id="dd0f0-404">Struktura, która zawiera informacje o tym, która część pętli została ukończona.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-404">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd0f0-405">To przeciążenie jest dostępne dla scenariuszy, w których chcesz przesłonić domyślny schemat partycjonowania.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-405">This overload is provided for scenarios where you want to override the default partitioning scheme.</span></span> <span data-ttu-id="dd0f0-406">Na przykład małe treści pętli mogą korzystać z partycjonowania zakresu.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-406">For example, small loop bodies might benefit from partitioning the range.</span></span> <span data-ttu-id="dd0f0-407">Metoda <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> oczekuje, że niestandardowe partycje obsługują partycjonowanie dynamiczne.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-407">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method expects custom partitioners to support dynamic partitioning.</span></span> <span data-ttu-id="dd0f0-408">Aby uzyskać więcej informacji, zobacz [niestandardowe partycje dla PLINQ i TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) i [instrukcje: Implementowanie partycji](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)dynamicznych.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-408">For more information, see [Custom Partitioners for PLINQ and TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) and [How to: Implement Dynamic Partitions](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd0f0-409">Poniższy przykład pokazuje, jak zaimplementować zakres partycji do użycia z <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>:</span><span class="sxs-lookup"><span data-stu-id="dd0f0-409">The following example shows how to implement a range partitioner for use with <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>:</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Parallel_RangePartitioners#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel_rangepartitioners/cs/rangepartitioner.cs#01)]
 [!code-vb[System.Threading.Tasks.Parallel_RangePartitioners#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel_rangepartitioners/vb/rangepart.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd0f0-410">Argument ma wartość <see langword="null" />. <paramref name="source" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-410">The <paramref name="source" /> argument is  <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd0f0-411">—lub—</span><span class="sxs-lookup"><span data-stu-id="dd0f0-411">-or-</span></span> 
<span data-ttu-id="dd0f0-412">Argument ma wartość <see langword="null" />. <paramref name="body" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-412">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="dd0f0-413">Właściwość w programie Partitioner<see langword="false" />zwraca wartość. <paramref name="source" /> <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-413">The <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> property in the <paramref name="source" /> partitioner returns <see langword="false" />.</span></span>  
  
<span data-ttu-id="dd0f0-414">—lub—</span><span class="sxs-lookup"><span data-stu-id="dd0f0-414">-or-</span></span> 
<span data-ttu-id="dd0f0-415">Wyjątek, który jest generowany, gdy wszystkie metody w <paramref name="source" /> programie Partitioner <see langword="null" />zwracają.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-415">The exception that is thrown when any methods in the <paramref name="source" /> partitioner return <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd0f0-416">—lub—</span><span class="sxs-lookup"><span data-stu-id="dd0f0-416">-or-</span></span> 
<span data-ttu-id="dd0f0-417"><see cref="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)" /> Metoda<paramref name="source" /> w programie partitioner nie zwraca poprawnej liczby partycji.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-417">The <see cref="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)" /> method in the <paramref name="source" /> partitioner does not return the correct number of partitions.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="dd0f0-418">Pętle równoległe</span><span class="sxs-lookup"><span data-stu-id="dd0f0-418">Parallel Loops</span></span></related>
        <exception cref="T:System.AggregateException"><span data-ttu-id="dd0f0-419">Wyjątek, który jest generowany, zawiera wyjątek zgłoszony z jednego z określonych delegatów.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-419">The exception that is thrown to contain an exception thrown from one of the specified delegates.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As IEnumerable(Of TSource), body As Action(Of TSource, ParallelLoopState, Long)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="dd0f0-420">Typ danych w źródle.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-420">The type of the data in the source.</span></span></typeparam>
        <param name="source"><span data-ttu-id="dd0f0-421">Wyliczalne źródło danych.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-421">An enumerable data source.</span></span></param>
        <param name="body"><span data-ttu-id="dd0f0-422">Delegat, który jest wywoływany raz na iterację.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-422">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="dd0f0-423">Wykonuje operację<see langword="For Each" /> <see cref="T:System.Collections.IEnumerable" /> (w Visual Basic) z indeksami 64-bitowymi, w których iteracje mogą działać równolegle, a stan pętli może być monitorowany i manipulowany. <see langword="foreach" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-423">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation with 64-bit indexes on an <see cref="T:System.Collections.IEnumerable" /> in which iterations may run in parallel, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="dd0f0-424">Struktura, która zawiera informacje o tym, która część pętli została ukończona.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-424">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd0f0-425">Delegat jest wywoływany jednokrotnie dla każdego elementu `source` w wyliczalnym. `body`</span><span class="sxs-lookup"><span data-stu-id="dd0f0-425">The `body` delegate is invoked once for each element in the `source` enumerable.</span></span> <span data-ttu-id="dd0f0-426">Jest on dostarczany z następującymi parametrami: bieżącym elementem, <xref:System.Threading.Tasks.ParallelLoopState> wystąpieniem, które może być używane do wypełniania pętli przedwcześnie i indeksu bieżącego elementu (<xref:System.Int64>).</span><span class="sxs-lookup"><span data-stu-id="dd0f0-426">It is provided with the following parameters: the current element, a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely, and the current element's index (<xref:System.Int64>).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd0f0-427">Argument ma wartość <see langword="null" />. <paramref name="source" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-427">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd0f0-428">—lub—</span><span class="sxs-lookup"><span data-stu-id="dd0f0-428">-or-</span></span> 
<span data-ttu-id="dd0f0-429">Argument ma wartość <see langword="null" />. <paramref name="body" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-429">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="dd0f0-430">Wyjątek, który zawiera wszystkie poszczególne wyjątki zgłoszone we wszystkich wątkach.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-430">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="dd0f0-431">Pętle równoległe</span><span class="sxs-lookup"><span data-stu-id="dd0f0-431">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As IEnumerable(Of TSource), body As Action(Of TSource, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="dd0f0-432">Typ danych w źródle.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-432">The type of the data in the source.</span></span></typeparam>
        <param name="source"><span data-ttu-id="dd0f0-433">Wyliczalne źródło danych.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-433">An enumerable data source.</span></span></param>
        <param name="body"><span data-ttu-id="dd0f0-434">Delegat, który jest wywoływany raz na iterację.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-434">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="dd0f0-435">Wykonuje operację <see langword="foreach" /> (<see langword="For Each" /> w<see cref="T:System.Collections.IEnumerable" /> Visual Basic), w której iteracje mogą działać równolegle, a stan pętli może być monitorowany i manipulowany.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-435">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation on an <see cref="T:System.Collections.IEnumerable" /> in which iterations may run in parallel, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="dd0f0-436">Struktura, która zawiera informacje o tym, która część pętli została ukończona.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-436">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd0f0-437">Delegat jest wywoływany jednokrotnie dla każdego elementu `source` w wyliczalnym. `body`</span><span class="sxs-lookup"><span data-stu-id="dd0f0-437">The `body` delegate is invoked once for each element in the `source` enumerable.</span></span> <span data-ttu-id="dd0f0-438">Jest on dostarczany z następującymi parametrami: bieżącym elementem oraz <xref:System.Threading.Tasks.ParallelLoopState> wystąpieniem, które może służyć do wcześniejszego przerwania pętli.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-438">It is provided with the following parameters: the current element, and a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd0f0-439">Argument ma wartość <see langword="null" />. <paramref name="source" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-439">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd0f0-440">—lub—</span><span class="sxs-lookup"><span data-stu-id="dd0f0-440">-or-</span></span> 
<span data-ttu-id="dd0f0-441">Argument ma wartość <see langword="null" />. <paramref name="body" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-441">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="dd0f0-442">Wyjątek, który zawiera wszystkie poszczególne wyjątki zgłoszone we wszystkich wątkach.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-442">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="dd0f0-443">Pętle równoległe</span><span class="sxs-lookup"><span data-stu-id="dd0f0-443">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As IEnumerable(Of TSource), body As Action(Of TSource)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="dd0f0-444">Typ danych w źródle.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-444">The type of the data in the source.</span></span></typeparam>
        <param name="source"><span data-ttu-id="dd0f0-445">Wyliczalne źródło danych.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-445">An enumerable data source.</span></span></param>
        <param name="body"><span data-ttu-id="dd0f0-446">Delegat, który jest wywoływany raz na iterację.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-446">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="dd0f0-447">Wykonuje operację <see langword="foreach" /> (<see langword="For Each" /> w<see cref="T:System.Collections.IEnumerable" /> Visual Basic), w której iteracje mogą działać równolegle.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-447">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation on an <see cref="T:System.Collections.IEnumerable" /> in which iterations may run in parallel.</span></span></summary>
        <returns><span data-ttu-id="dd0f0-448">Struktura, która zawiera informacje o tym, która część pętli została ukończona.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-448">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd0f0-449">Delegat jest wywoływany jednokrotnie dla każdego elementu `source` w wyliczalnym. `body`</span><span class="sxs-lookup"><span data-stu-id="dd0f0-449">The `body` delegate is invoked once for each element in the `source` enumerable.</span></span> <span data-ttu-id="dd0f0-450">Jest on dostarczany z bieżącym elementem jako parametr.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-450">It is provided with the current element as a parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd0f0-451">W poniższym przykładzie zastosowano <xref:System.Threading.Tasks.Parallel.ForEach%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Action%7B%60%600%7D%29> metodę, aby policzyć liczbę samogłosek i niebiałych znaków w pliku tekstowym.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-451">The following example uses the <xref:System.Threading.Tasks.Parallel.ForEach%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Action%7B%60%600%7D%29> method to count the number of vowels and non-white-space characters in a text file.</span></span> <span data-ttu-id="dd0f0-452">W takim przypadku <xref:System.Threading.Tasks.ParallelLoopResult> wartość zwracana przez metodę jest ignorowana.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-452">In this case, the <xref:System.Threading.Tasks.ParallelLoopResult> value returned by the method is ignored.</span></span> <span data-ttu-id="dd0f0-453">Należy pamiętać, że ponieważ operacje mogą działać równolegle, należy się upewnić, że zwiększanie zmiennych licznika jest operacją niepodzielną, a wiele wątków nie próbuje uzyskać dostępu do zmiennych licznika jednocześnie.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-453">Note that, because operations can run in parallel, you must ensure that incrementing the counter variables is an atomic operation, and that multiple threads do not attempt to access the counter variables simultaneously.</span></span> <span data-ttu-id="dd0f0-454">W tym celu przykład używa `lock` instrukcji (in C#) i `SyncLock` instrukcji (w Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="dd0f0-454">For this purpose, the example uses the `lock` statement (in C#) and the `SyncLock` statement (in Visual Basic).</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Parallel.ForEach#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel.foreach/cs/foreach1.cs#1)]
 [!code-vb[System.Threading.Tasks.Parallel.ForEach#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel.foreach/vb/foreach1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd0f0-455">Argument ma wartość <see langword="null" />. <paramref name="source" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-455">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd0f0-456">—lub—</span><span class="sxs-lookup"><span data-stu-id="dd0f0-456">-or-</span></span> 
<span data-ttu-id="dd0f0-457">Argument ma wartość <see langword="null" />. <paramref name="body" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-457">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="dd0f0-458">Wyjątek, który zawiera wszystkie poszczególne wyjątki zgłoszone we wszystkich wątkach.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-458">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="dd0f0-459">Pętle równoległe</span><span class="sxs-lookup"><span data-stu-id="dd0f0-459">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.OrderablePartitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="dd0f0-460">Typ elementów w <paramref name="source" />.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-460">The type of the elements in <paramref name="source" />.</span></span></typeparam>
        <param name="source"><span data-ttu-id="dd0f0-461">Uporządkowana partycja, która zawiera oryginalne źródło danych.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-461">The orderable partitioner that contains the original data source.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="dd0f0-462">Obiekt, który konfiguruje zachowanie tej operacji.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-462">An object that configures the behavior of this operation.</span></span></param>
        <param name="body"><span data-ttu-id="dd0f0-463">Delegat, który jest wywoływany raz na iterację.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-463">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="dd0f0-464">Wykonuje operację<see langword="For Each" /> <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> (w Visual Basic) na, w której iteracje mogą działać równolegle, można skonfigurować opcje pętli, a stan pętli może być monitorowany i manipulowany. <see langword="foreach" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-464">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation on a <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> in which iterations may run in parallel, loop options can be configured, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="dd0f0-465">Struktura, która zawiera informacje o tym, która część pętli została ukończona.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-465">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd0f0-466">To przeciążenie jest dostępne dla scenariuszy, w których chcesz przesłonić domyślny schemat partycjonowania.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-466">This overload is provided for scenarios where you want to override the default partitioning scheme.</span></span> <span data-ttu-id="dd0f0-467">Na przykład małe treści pętli mogą korzystać z partycjonowania zakresu.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-467">For example, small loop bodies might benefit from partitioning the range.</span></span> <span data-ttu-id="dd0f0-468">Metoda <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> oczekuje, że niestandardowe partycje obsługują partycjonowanie dynamiczne.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-468">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method expects custom partitioners to support dynamic partitioning.</span></span> <span data-ttu-id="dd0f0-469">Aby uzyskać więcej informacji, zobacz [niestandardowe partycje dla PLINQ i TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) i [instrukcje: Implementowanie partycji](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)dynamicznych.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-469">For more information, see [Custom Partitioners for PLINQ and TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) and [How to: Implement Dynamic Partitions](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="dd0f0-470"><see cref="T:System.Threading.CancellationToken" /> W<paramref name="parallelOptions" /> argumencie zostanie anulowana</span><span class="sxs-lookup"><span data-stu-id="dd0f0-470">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd0f0-471">Argument ma wartość <see langword="null" />. <paramref name="source" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-471">The <paramref name="source" /> argument is  <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd0f0-472">—lub—</span><span class="sxs-lookup"><span data-stu-id="dd0f0-472">-or-</span></span> 
<span data-ttu-id="dd0f0-473">Argument ma wartość <see langword="null" />. <paramref name="parallelOptions" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-473">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd0f0-474">—lub—</span><span class="sxs-lookup"><span data-stu-id="dd0f0-474">-or-</span></span> 
<span data-ttu-id="dd0f0-475">Argument ma wartość <see langword="null" />. <paramref name="body" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-475">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="dd0f0-476">Skojarzona z elementem <paramref name="parallelOptions" /> w został usunięty. <see cref="T:System.Threading.CancellationToken" /> <see cref="T:System.Threading.CancellationTokenSource" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-476">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="dd0f0-477">Właściwość w <paramref name="source" /> powrocie<see langword="false" />do kolejności partycjonowania. <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-477">The <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> property in the <paramref name="source" /> orderable partitioner returns <see langword="false" />.</span></span>  
  
<span data-ttu-id="dd0f0-478">—lub—</span><span class="sxs-lookup"><span data-stu-id="dd0f0-478">-or-</span></span> 
<span data-ttu-id="dd0f0-479">Właściwość w <paramref name="source" /> powrocie<see langword="false" />do kolejności partycjonowania. <see cref="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysNormalized" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-479">The <see cref="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysNormalized" /> property in the <paramref name="source" /> orderable partitioner returns <see langword="false" />.</span></span>  
  
<span data-ttu-id="dd0f0-480">—lub—</span><span class="sxs-lookup"><span data-stu-id="dd0f0-480">-or-</span></span> 
<span data-ttu-id="dd0f0-481">Wyjątek, który jest generowany, gdy wszystkie metody w <paramref name="source" /> powrocie do podzielenia na partycje są zwracane. <see langword="null" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-481">The exception that is thrown when any methods in the <paramref name="source" /> orderable partitioner return <see langword="null" />.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="dd0f0-482">Pętle równoległe</span><span class="sxs-lookup"><span data-stu-id="dd0f0-482">Parallel Loops</span></span></related>
        <exception cref="T:System.AggregateException"><span data-ttu-id="dd0f0-483">Wyjątek, który jest generowany, zawiera wyjątek zgłoszony z jednego z określonych delegatów.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-483">The exception that is thrown to contain an exception thrown from one of the specified delegates.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="dd0f0-484">Typ elementów w <paramref name="source" />.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-484">The type of the elements in <paramref name="source" />.</span></span></typeparam>
        <param name="source"><span data-ttu-id="dd0f0-485">Partycja zawierająca oryginalne źródło danych.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-485">The partitioner that contains the original data source.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="dd0f0-486">Obiekt, który konfiguruje zachowanie tej operacji.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-486">An object that configures the behavior of this operation.</span></span></param>
        <param name="body"><span data-ttu-id="dd0f0-487">Delegat, który jest wywoływany raz na iterację.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-487">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="dd0f0-488">Wykonuje operację<see langword="For Each" /> <see cref="T:System.Collections.Concurrent.Partitioner" /> (w Visual Basic) na, w której iteracje mogą działać równolegle, można skonfigurować opcje pętli, a stan pętli może być monitorowany i manipulowany. <see langword="foreach" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-488">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation on a <see cref="T:System.Collections.Concurrent.Partitioner" /> in which iterations may run in parallel, loop options can be configured, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="dd0f0-489">Struktura, która zawiera informacje o tym, która część pętli została ukończona.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-489">A  structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd0f0-490">To przeciążenie jest dostępne dla scenariuszy, w których chcesz przesłonić domyślny schemat partycjonowania.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-490">This overload is provided for scenarios where you want to override the default partitioning scheme.</span></span> <span data-ttu-id="dd0f0-491">Na przykład małe treści pętli mogą korzystać z partycjonowania zakresu.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-491">For example, small loop bodies might benefit from partitioning the range.</span></span> <span data-ttu-id="dd0f0-492">Metoda <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> oczekuje, że niestandardowe partycje obsługują partycjonowanie dynamiczne.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-492">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method expects custom partitioners to support dynamic partitioning.</span></span> <span data-ttu-id="dd0f0-493">Aby uzyskać więcej informacji, zobacz [niestandardowe partycje dla PLINQ i TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) i [instrukcje: Implementowanie partycji](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)dynamicznych.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-493">For more information, see [Custom Partitioners for PLINQ and TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) and [How to: Implement Dynamic Partitions](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="dd0f0-494"><see cref="T:System.Threading.CancellationToken" /> W<paramref name="parallelOptions" /> argumencie zostanie anulowana.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-494">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="dd0f0-495">Skojarzona z elementem <paramref name="parallelOptions" /> w został usunięty. <see cref="T:System.Threading.CancellationToken" /> <see cref="T:System.Threading.CancellationTokenSource" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-495">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd0f0-496">Argument ma wartość <see langword="null" />. <paramref name="source" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-496">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd0f0-497">—lub—</span><span class="sxs-lookup"><span data-stu-id="dd0f0-497">-or-</span></span> 
<span data-ttu-id="dd0f0-498">Argument ma wartość <see langword="null" />. <paramref name="parallelOptions" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-498">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd0f0-499">—lub—</span><span class="sxs-lookup"><span data-stu-id="dd0f0-499">-or-</span></span> 
<span data-ttu-id="dd0f0-500">Argument ma wartość <see langword="null" />. <paramref name="body" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-500">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="dd0f0-501">Właściwość w programie Partitioner<see langword="false" />zwraca wartość. <paramref name="source" /> <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-501">The <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> property in the <paramref name="source" /> partitioner returns <see langword="false" />.</span></span>  
  
<span data-ttu-id="dd0f0-502">—lub—</span><span class="sxs-lookup"><span data-stu-id="dd0f0-502">-or-</span></span> 
<span data-ttu-id="dd0f0-503">Wyjątek, który jest generowany, gdy wszystkie metody w <paramref name="source" /> programie Partitioner <see langword="null" />zwracają.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-503">The exception that is thrown when any methods in the <paramref name="source" /> partitioner return <see langword="null" />.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="dd0f0-504">Pętle równoległe</span><span class="sxs-lookup"><span data-stu-id="dd0f0-504">Parallel Loops</span></span></related>
        <exception cref="T:System.AggregateException"><span data-ttu-id="dd0f0-505">Wyjątek, który jest generowany, zawiera wyjątek zgłoszony z jednego z określonych delegatów.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-505">The exception that is thrown to contain an exception thrown from one of the specified delegates.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="dd0f0-506">Typ elementów w <paramref name="source" />.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-506">The type of the elements in <paramref name="source" />.</span></span></typeparam>
        <param name="source"><span data-ttu-id="dd0f0-507">Partycja zawierająca oryginalne źródło danych.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-507">The partitioner that contains the original data source.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="dd0f0-508">Obiekt, który konfiguruje zachowanie tej operacji.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-508">An object that configures the behavior of this operation.</span></span></param>
        <param name="body"><span data-ttu-id="dd0f0-509">Delegat, który jest wywoływany raz na iterację.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-509">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="dd0f0-510">Wykonuje operację<see langword="For Each" /> <see cref="T:System.Collections.Concurrent.Partitioner" /> (w Visual Basic) na, w której iteracje mogą być uruchamiane równolegle, i można skonfigurować opcje pętli. <see langword="foreach" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-510">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation on a <see cref="T:System.Collections.Concurrent.Partitioner" /> in which iterations may run in parallel and loop options can be configured.</span></span></summary>
        <returns><span data-ttu-id="dd0f0-511">Struktura, która zawiera informacje o tym, która część pętli została ukończona.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-511">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd0f0-512">To przeciążenie jest dostępne dla scenariuszy, w których chcesz przesłonić domyślny schemat partycjonowania.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-512">This overload is provided for scenarios where you want to override the default partitioning scheme.</span></span> <span data-ttu-id="dd0f0-513">Na przykład małe treści pętli mogą korzystać z partycjonowania zakresu.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-513">For example, small loop bodies might benefit from partitioning the range.</span></span> <span data-ttu-id="dd0f0-514">Metoda <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> oczekuje, że niestandardowe partycje obsługują partycjonowanie dynamiczne.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-514">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method expects custom partitioners to support dynamic partitioning.</span></span> <span data-ttu-id="dd0f0-515">Aby uzyskać więcej informacji, zobacz [niestandardowe partycje dla PLINQ i TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) i [instrukcje: Implementowanie partycji](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)dynamicznych.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-515">For more information, see [Custom Partitioners for PLINQ and TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) and [How to: Implement Dynamic Partitions](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="dd0f0-516"><see cref="T:System.Threading.CancellationToken" /> W<paramref name="parallelOptions" /> argumencie zostanie anulowana.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-516">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="dd0f0-517">Skojarzona z elementem <paramref name="parallelOptions" /> w został usunięty. <see cref="T:System.Threading.CancellationToken" /> <see cref="T:System.Threading.CancellationTokenSource" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-517">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd0f0-518">Argument ma wartość <see langword="null" />. <paramref name="source" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-518">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd0f0-519">—lub—</span><span class="sxs-lookup"><span data-stu-id="dd0f0-519">-or-</span></span> 
<span data-ttu-id="dd0f0-520">Argument ma wartość <see langword="null" />. <paramref name="parallelOptions" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-520">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd0f0-521">—lub—</span><span class="sxs-lookup"><span data-stu-id="dd0f0-521">-or-</span></span> 
<span data-ttu-id="dd0f0-522">Argument ma wartość <see langword="null" />. <paramref name="body" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-522">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="dd0f0-523">Właściwość w programie Partitioner<see langword="false" />zwraca wartość. <paramref name="source" /> <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-523">The <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> property in the <paramref name="source" /> partitioner returns <see langword="false" />.</span></span>  
  
<span data-ttu-id="dd0f0-524">—lub—</span><span class="sxs-lookup"><span data-stu-id="dd0f0-524">-or-</span></span> 
<span data-ttu-id="dd0f0-525">Wyjątek, który jest generowany, gdy wszystkie metody w <paramref name="source" /> programie Partitioner <see langword="null" />zwracają.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-525">The exception that is thrown when any methods in the <paramref name="source" /> partitioner return <see langword="null" />.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="dd0f0-526">Pętle równoległe</span><span class="sxs-lookup"><span data-stu-id="dd0f0-526">Parallel Loops</span></span></related>
        <exception cref="T:System.AggregateException"><span data-ttu-id="dd0f0-527">Wyjątek, który jest generowany, zawiera wyjątek zgłoszony z jednego z określonych delegatów.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-527">The exception that is thrown to contain an exception thrown from one of the specified delegates.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="dd0f0-528">Typ danych w źródle.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-528">The type of the data in the source.</span></span></typeparam>
        <param name="source"><span data-ttu-id="dd0f0-529">Wyliczalne źródło danych.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-529">An enumerable data source.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="dd0f0-530">Obiekt, który konfiguruje zachowanie tej operacji.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-530">An object that configures the behavior of this operation.</span></span></param>
        <param name="body"><span data-ttu-id="dd0f0-531">Delegat, który jest wywoływany raz na iterację.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-531">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="dd0f0-532">Wykonuje operację<see langword="For Each" /> <see cref="T:System.Collections.IEnumerable" /> (w Visual Basic) z indeksami 64-bitowymi w, w których iteracje mogą działać równolegle, można skonfigurować opcje pętli, a stan pętli można monitorować i manipulować. <see langword="foreach" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-532">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation with 64-bit indexes on an <see cref="T:System.Collections.IEnumerable" /> in which iterations may run in parallel, loop options can be configured, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="dd0f0-533">Struktura, która zawiera informacje o tym, która część pętli została ukończona.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-533">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd0f0-534">Delegat jest wywoływany jednokrotnie dla każdego elementu `source` w wyliczalnym. `body`</span><span class="sxs-lookup"><span data-stu-id="dd0f0-534">The `body` delegate is invoked once for each element in the `source` enumerable.</span></span> <span data-ttu-id="dd0f0-535">Jest on dostarczany z następującymi parametrami: bieżącym elementem, <xref:System.Threading.Tasks.ParallelLoopState> wystąpieniem, które może być używane do wypełniania pętli przedwcześnie i indeksu bieżącego elementu (<xref:System.Int64>).</span><span class="sxs-lookup"><span data-stu-id="dd0f0-535">It is provided with the following parameters: the current element, a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely, and the current element's index (<xref:System.Int64>).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="dd0f0-536"><see cref="T:System.Threading.CancellationToken" /> W<paramref name="parallelOptions" /> argumencie zostanie anulowana</span><span class="sxs-lookup"><span data-stu-id="dd0f0-536">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd0f0-537">Argument ma wartość <see langword="null" />. <paramref name="source" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-537">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd0f0-538">—lub—</span><span class="sxs-lookup"><span data-stu-id="dd0f0-538">-or-</span></span> 
<span data-ttu-id="dd0f0-539">Argument ma wartość <see langword="null" />. <paramref name="parallelOptions" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-539">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd0f0-540">—lub—</span><span class="sxs-lookup"><span data-stu-id="dd0f0-540">-or-</span></span> 
<span data-ttu-id="dd0f0-541">Argument ma wartość <see langword="null" />. <paramref name="body" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-541">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="dd0f0-542">Wyjątek, który zawiera wszystkie poszczególne wyjątki zgłoszone we wszystkich wątkach.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-542">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="dd0f0-543">Skojarzona z elementem <paramref name="parallelOptions" /> w został usunięty. <see cref="T:System.Threading.CancellationToken" /> <see cref="T:System.Threading.CancellationTokenSource" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-543">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="dd0f0-544">Pętle równoległe</span><span class="sxs-lookup"><span data-stu-id="dd0f0-544">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="dd0f0-545">Typ danych w źródle.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-545">The type of the data in the source.</span></span></typeparam>
        <param name="source"><span data-ttu-id="dd0f0-546">Wyliczalne źródło danych.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-546">An enumerable data source.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="dd0f0-547">Obiekt, który konfiguruje zachowanie tej operacji.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-547">An object that configures the behavior of this operation.</span></span></param>
        <param name="body"><span data-ttu-id="dd0f0-548">Delegat, który jest wywoływany raz na iterację.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-548">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="dd0f0-549">Wykonuje operację <see langword="foreach" /> (<see langword="For Each" /> w<see cref="T:System.Collections.IEnumerable" /> Visual Basic) na, w której iteracje mogą działać równolegle, można skonfigurować opcje pętli, a stan pętli może być monitorowany i manipulowany.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-549">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation on an <see cref="T:System.Collections.IEnumerable" /> in which iterations may run in parallel, loop options can be configured, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="dd0f0-550">Struktura, która zawiera informacje o tym, która część pętli została ukończona.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-550">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd0f0-551">Delegat jest wywoływany jednokrotnie dla każdego elementu `source` w wyliczalnym. `body`</span><span class="sxs-lookup"><span data-stu-id="dd0f0-551">The `body` delegate is invoked once for each element in the `source` enumerable.</span></span> <span data-ttu-id="dd0f0-552">Jest on dostarczany z następującymi parametrami: bieżącym elementem oraz <xref:System.Threading.Tasks.ParallelLoopState> wystąpieniem, które może służyć do wcześniejszego przerwania pętli.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-552">It is provided with the following parameters: the current element, and a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="dd0f0-553"><see cref="T:System.Threading.CancellationToken" /> W<paramref name="parallelOptions" /> argumencie zostanie anulowana</span><span class="sxs-lookup"><span data-stu-id="dd0f0-553">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd0f0-554">Argument ma wartość <see langword="null" />. <paramref name="source" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-554">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd0f0-555">—lub—</span><span class="sxs-lookup"><span data-stu-id="dd0f0-555">-or-</span></span> 
<span data-ttu-id="dd0f0-556">Argument ma wartość <see langword="null" />. <paramref name="parallelOptions" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-556">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd0f0-557">—lub—</span><span class="sxs-lookup"><span data-stu-id="dd0f0-557">-or-</span></span> 
<span data-ttu-id="dd0f0-558">Argument ma wartość <see langword="null" />. <paramref name="body" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-558">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="dd0f0-559">Wyjątek, który zawiera wszystkie poszczególne wyjątki zgłoszone we wszystkich wątkach.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-559">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="dd0f0-560">Skojarzona z elementem <paramref name="parallelOptions" /> w został usunięty. <see cref="T:System.Threading.CancellationToken" /> <see cref="T:System.Threading.CancellationTokenSource" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-560">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="dd0f0-561">Pętle równoległe</span><span class="sxs-lookup"><span data-stu-id="dd0f0-561">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="dd0f0-562">Typ danych w źródle.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-562">The type of the data in the source.</span></span></typeparam>
        <param name="source"><span data-ttu-id="dd0f0-563">Wyliczalne źródło danych.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-563">An enumerable data source.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="dd0f0-564">Obiekt, który konfiguruje zachowanie tej operacji.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-564">An object that configures the behavior of this operation.</span></span></param>
        <param name="body"><span data-ttu-id="dd0f0-565">Delegat, który jest wywoływany raz na iterację.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-565">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="dd0f0-566">Wykonuje operację <see langword="foreach" /> (<see langword="For Each" /> w<see cref="T:System.Collections.IEnumerable" /> Visual Basic) na, w której iteracje mogą być uruchamiane równolegle, i można skonfigurować opcje pętli.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-566">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation on an <see cref="T:System.Collections.IEnumerable" /> in which iterations may run in parallel and loop options can be configured.</span></span></summary>
        <returns><span data-ttu-id="dd0f0-567">Struktura, która zawiera informacje o tym, która część pętli została ukończona.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-567">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd0f0-568">Delegat jest wywoływany jednokrotnie dla każdego elementu `source` w wyliczalnym. `body`</span><span class="sxs-lookup"><span data-stu-id="dd0f0-568">The `body` delegate is invoked once for each element in the `source` enumerable.</span></span> <span data-ttu-id="dd0f0-569">Jest on dostarczany z bieżącym elementem jako parametr.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-569">It is provided with the current element as a parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="dd0f0-570"><see cref="T:System.Threading.CancellationToken" /> W<paramref name="parallelOptions" /> argumencie zostanie anulowana</span><span class="sxs-lookup"><span data-stu-id="dd0f0-570">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd0f0-571">Argument ma wartość <see langword="null" />. <paramref name="source" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-571">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd0f0-572">—lub—</span><span class="sxs-lookup"><span data-stu-id="dd0f0-572">-or-</span></span> 
<span data-ttu-id="dd0f0-573">Argument ma wartość <see langword="null" />. <paramref name="parallelOptions" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-573">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd0f0-574">—lub—</span><span class="sxs-lookup"><span data-stu-id="dd0f0-574">-or-</span></span> 
<span data-ttu-id="dd0f0-575">Argument ma wartość <see langword="null" />. <paramref name="body" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-575">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="dd0f0-576">Wyjątek, który zawiera wszystkie poszczególne wyjątki zgłoszone we wszystkich wątkach.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-576">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="dd0f0-577">Skojarzona z elementem <paramref name="parallelOptions" /> w został usunięty. <see cref="T:System.Threading.CancellationToken" /> <see cref="T:System.Threading.CancellationTokenSource" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-577">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="dd0f0-578">Pętle równoległe</span><span class="sxs-lookup"><span data-stu-id="dd0f0-578">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.OrderablePartitioner{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As OrderablePartitioner(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, Long, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="dd0f0-579">Typ elementów w <paramref name="source" />.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-579">The type of the elements in <paramref name="source" />.</span></span></typeparam>
        <typeparam name="TLocal"><span data-ttu-id="dd0f0-580">Typ danych lokalnych wątku.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-580">The type of the thread-local data.</span></span></typeparam>
        <param name="source"><span data-ttu-id="dd0f0-581">Uporządkowana partycja, która zawiera oryginalne źródło danych.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-581">The orderable partitioner that contains the original data source.</span></span></param>
        <param name="localInit"><span data-ttu-id="dd0f0-582">Delegat funkcji, który zwraca początkowy stan danych lokalnych dla każdego zadania.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-582">The function delegate that returns the initial state of the local data for each task.</span></span></param>
        <param name="body"><span data-ttu-id="dd0f0-583">Delegat, który jest wywoływany raz na iterację.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-583">The delegate that is invoked once per iteration.</span></span></param>
        <param name="localFinally"><span data-ttu-id="dd0f0-584">Delegat, który wykonuje ostateczną akcję na lokalnym stanie każdego zadania.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-584">The delegate that performs a final action on the local state of each task.</span></span></param>
        <summary><span data-ttu-id="dd0f0-585">Wykonuje operację<see langword="For Each" /> <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> (w Visual Basic) przy użyciu danych z wątku lokalnego, w którym iteracje mogą działać równolegle, można skonfigurować opcje pętli, a stan pętli można monitorować i manipulować. <see langword="foreach" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-585">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation with thread-local data on a <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> in which iterations may run in parallel, loop options can be configured, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="dd0f0-586">Struktura, która zawiera informacje o tym, która część pętli została ukończona.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-586">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd0f0-587">To przeciążenie jest dostępne dla scenariuszy, w których chcesz przesłonić domyślny schemat partycjonowania.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-587">This overload is provided for scenarios where you want to override the default partitioning scheme.</span></span> <span data-ttu-id="dd0f0-588">Na przykład małe treści pętli mogą korzystać z partycjonowania zakresu.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-588">For example, small loop bodies might benefit from partitioning the range.</span></span> <span data-ttu-id="dd0f0-589">Metoda <xref:System.Threading.Tasks.Parallel.ForEach%2A> oczekuje, że niestandardowe partycje obsługują partycjonowanie dynamiczne.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-589">The <xref:System.Threading.Tasks.Parallel.ForEach%2A> method expects custom partitioners to support dynamic partitioning.</span></span> <span data-ttu-id="dd0f0-590">Aby uzyskać więcej informacji, zobacz [niestandardowe partycje dla PLINQ i TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) i [instrukcje: Implementowanie partycji](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)dynamicznych.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-590">For more information, see [Custom Partitioners for PLINQ and TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) and [How to: Implement Dynamic Partitions](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>  
  
 <span data-ttu-id="dd0f0-591">`localInit` Delegat jest wywoływany jednokrotnie dla każdego zadania, które uczestniczy w wykonaniu pętli i zwraca początkowy stan lokalny dla każdego z tych zadań.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-591">The `localInit` delegate is invoked once for each task that participates in the loop's execution and returns the initial local state for each of those tasks.</span></span> <span data-ttu-id="dd0f0-592">Te Stany początkowe są przesyłane do pierwszych `body` wywołań każdego zadania.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-592">These initial states are passed to the first `body` invocations on each task.</span></span> <span data-ttu-id="dd0f0-593">Następnie każde kolejne wywołanie treści zwróci prawdopodobnie zmodyfikowaną wartość stanu, która jest przenoszona do następnego wywołania treści.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-593">Then, every subsequent body invocation returns a possibly modified state value that is passed to the next body invocation.</span></span> <span data-ttu-id="dd0f0-594">Na koniec ostatnie wywołanie treści dla każdego zadania zwraca wartość stanu, która jest przenoszona do `localFinally` delegata.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-594">Finally, the last body invocation on each task returns a state value that is passed to the `localFinally` delegate.</span></span> <span data-ttu-id="dd0f0-595">`localFinally` Delegat jest wywoływany raz na zadanie w celu wykonania końcowej akcji na lokalnym stanie każdego zadania.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-595">The `localFinally` delegate is invoked once per task to perform a final action on each task's local state.</span></span> <span data-ttu-id="dd0f0-596">Ten delegat może być wywoływany współbieżnie dla wielu zadań; w związku z tym należy synchronizować dostęp do dowolnych zmiennych udostępnionych.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-596">This delegate might be invoked concurrently on multiple tasks; therefore, you must synchronize access to any shared variables.</span></span>  
  
 <span data-ttu-id="dd0f0-597"><xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Metoda może korzystać z większej liczby zadań niż wątki w okresie istnienia wykonywania, ponieważ istniejące zadania zostały ukończone i są zastępowane przez nowe zadania.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-597">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method may use more tasks than threads over the lifetime of its execution, as existing tasks complete and are replaced by new tasks.</span></span> <span data-ttu-id="dd0f0-598">Dzięki temu obiekt źródłowy <xref:System.Threading.Tasks.TaskScheduler> może dodawać, zmieniać lub usuwać wątki obsługujące pętlę.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-598">This gives the underlying <xref:System.Threading.Tasks.TaskScheduler> object the chance to add, change, or remove threads that service the loop.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd0f0-599">Argument ma wartość <see langword="null" />. <paramref name="source" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-599">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd0f0-600">—lub—</span><span class="sxs-lookup"><span data-stu-id="dd0f0-600">-or-</span></span> 
<span data-ttu-id="dd0f0-601">Argument ma wartość <see langword="null" />. <paramref name="body" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-601">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd0f0-602">—lub—</span><span class="sxs-lookup"><span data-stu-id="dd0f0-602">-or-</span></span> 
<span data-ttu-id="dd0f0-603">Argument ma wartość <see langword="null" />. <paramref name="localInit" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-603">The <paramref name="localInit" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd0f0-604">—lub—</span><span class="sxs-lookup"><span data-stu-id="dd0f0-604">-or-</span></span> 
<span data-ttu-id="dd0f0-605">Argument ma wartość <see langword="null" />. <paramref name="localFinally" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-605">The <paramref name="localFinally" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="dd0f0-606"><see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> Właściwość w<paramref name="source" /> zwracaniu<see langword="false" /> lub partycji zwraca<see langword="null" /> partycje. <see cref="T:System.Collections.Concurrent.Partitioner" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-606">The <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> property in the <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> returns <see langword="false" /> or the partitioner returns <see langword="null" /> partitions.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="dd0f0-607">Wyjątek, który zawiera wszystkie poszczególne wyjątki zgłoszone we wszystkich wątkach.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-607">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="dd0f0-608">Pętle równoległe</span><span class="sxs-lookup"><span data-stu-id="dd0f0-608">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.Partitioner{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As Partitioner(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="dd0f0-609">Typ elementów w <paramref name="source" />.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-609">The type of the elements in <paramref name="source" />.</span></span></typeparam>
        <typeparam name="TLocal"><span data-ttu-id="dd0f0-610">Typ danych lokalnych wątku.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-610">The type of the thread-local data.</span></span></typeparam>
        <param name="source"><span data-ttu-id="dd0f0-611">Partycja zawierająca oryginalne źródło danych.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-611">The partitioner that contains the original data source.</span></span></param>
        <param name="localInit"><span data-ttu-id="dd0f0-612">Delegat funkcji, który zwraca początkowy stan danych lokalnych dla każdego zadania.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-612">The function delegate that returns the initial state of the local data for each task.</span></span></param>
        <param name="body"><span data-ttu-id="dd0f0-613">Delegat, który jest wywoływany raz na iterację.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-613">The delegate that is invoked once per iteration.</span></span></param>
        <param name="localFinally"><span data-ttu-id="dd0f0-614">Delegat, który wykonuje ostateczną akcję na lokalnym stanie każdego zadania.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-614">The delegate that performs a final action on the local state of each task.</span></span></param>
        <summary><span data-ttu-id="dd0f0-615">Wykonuje operację<see langword="For Each" /> <see cref="T:System.Collections.Concurrent.Partitioner" /> (w Visual Basic) za pomocą danych lokalnych wątku, w których iteracje mogą działać równolegle, a stan pętli może być monitorowany i manipulowany. <see langword="foreach" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-615">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation with thread-local data on a <see cref="T:System.Collections.Concurrent.Partitioner" /> in which iterations may run in parallel and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="dd0f0-616">Struktura, która zawiera informacje o tym, która część pętli została ukończona.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-616">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd0f0-617">To przeciążenie jest dostępne dla scenariuszy, w których chcesz przesłonić domyślny schemat partycjonowania.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-617">This overload is provided for scenarios where you want to override the default partitioning scheme.</span></span> <span data-ttu-id="dd0f0-618">Na przykład małe treści pętli mogą korzystać z partycjonowania zakresu.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-618">For example, small loop bodies might benefit from partitioning the range.</span></span> <span data-ttu-id="dd0f0-619">Metoda <xref:System.Threading.Tasks.Parallel.ForEach%2A> oczekuje, że niestandardowe partycje obsługują partycjonowanie dynamiczne.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-619">The <xref:System.Threading.Tasks.Parallel.ForEach%2A> method expects custom partitioners to support dynamic partitioning.</span></span> <span data-ttu-id="dd0f0-620">Aby uzyskać więcej informacji, zobacz [niestandardowe partycje dla PLINQ i TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) i [instrukcje: Implementowanie partycji](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)dynamicznych.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-620">For more information, see [Custom Partitioners for PLINQ and TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) and [How to: Implement Dynamic Partitions](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>  
  
 <span data-ttu-id="dd0f0-621">`localInit` Delegat jest wywoływany raz dla każdego wątku, który uczestniczy w wykonaniu pętli i zwraca początkowy stan lokalny dla każdego z tych zadań.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-621">The `localInit` delegate is invoked once for each thread that participates in the loop's execution and returns the initial local state for each of those tasks.</span></span> <span data-ttu-id="dd0f0-622">Te Stany początkowe są przesyłane do pierwszych `body` wywołań każdego zadania.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-622">These initial states are passed to the first `body` invocations on each task.</span></span> <span data-ttu-id="dd0f0-623">Następnie każde kolejne wywołanie treści zwróci prawdopodobnie zmodyfikowaną wartość stanu, która jest przenoszona do następnego wywołania treści.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-623">Then, every subsequent body invocation returns a possibly modified state value that is passed to the next body invocation.</span></span> <span data-ttu-id="dd0f0-624">Na koniec ostatnie wywołanie treści dla każdego zadania zwraca wartość stanu, która jest przenoszona do `localFinally` delegata.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-624">Finally, the last body invocation on each task returns a state value that is passed to the `localFinally` delegate.</span></span> <span data-ttu-id="dd0f0-625">`localFinally` Delegat jest wywoływany raz na zadanie w celu wykonania końcowej akcji na lokalnym stanie każdego zadania.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-625">The `localFinally` delegate is invoked once per task to perform a final action on each task's local state.</span></span> <span data-ttu-id="dd0f0-626">Ten delegat może być wywoływany współbieżnie dla wielu zadań; w związku z tym należy synchronizować dostęp do dowolnych zmiennych udostępnionych.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-626">This delegate might be invoked concurrently on multiple tasks; therefore, you must synchronize access to any shared variables.</span></span>  
  
 <span data-ttu-id="dd0f0-627"><xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Metoda może korzystać z większej liczby zadań niż wątki w okresie istnienia wykonywania, ponieważ istniejące zadania zostały ukończone i są zastępowane przez nowe zadania.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-627">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method may use more tasks than threads over the lifetime of its execution, as existing tasks complete and are replaced by new tasks.</span></span> <span data-ttu-id="dd0f0-628">Dzięki temu obiekt źródłowy <xref:System.Threading.Tasks.TaskScheduler> może dodawać, zmieniać lub usuwać wątki obsługujące pętlę.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-628">This gives the underlying <xref:System.Threading.Tasks.TaskScheduler> object the chance to add, change, or remove threads that service the loop.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd0f0-629">Argument ma wartość <see langword="null" />. <paramref name="source" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-629">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd0f0-630">—lub—</span><span class="sxs-lookup"><span data-stu-id="dd0f0-630">-or-</span></span> 
<span data-ttu-id="dd0f0-631">Argument ma wartość <see langword="null" />. <paramref name="body" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-631">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd0f0-632">—lub—</span><span class="sxs-lookup"><span data-stu-id="dd0f0-632">-or-</span></span> 
<span data-ttu-id="dd0f0-633">Argument ma wartość <see langword="null" />. <paramref name="localInit" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-633">The <paramref name="localInit" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd0f0-634">—lub—</span><span class="sxs-lookup"><span data-stu-id="dd0f0-634">-or-</span></span> 
<span data-ttu-id="dd0f0-635">Argument ma wartość <see langword="null" />. <paramref name="localFinally" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-635">The <paramref name="localFinally" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="dd0f0-636"><see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> Właściwość w<paramref name="source" /> zwracaniu<see langword="false" /> lub partycji zwraca<see langword="null" /> partycje. <see cref="T:System.Collections.Concurrent.Partitioner" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-636">The <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> property in the <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> returns <see langword="false" /> or the partitioner returns <see langword="null" /> partitions.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="dd0f0-637">Wyjątek, który zawiera wszystkie poszczególne wyjątki zgłoszone we wszystkich wątkach.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-637">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="dd0f0-638">Pętle równoległe</span><span class="sxs-lookup"><span data-stu-id="dd0f0-638">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As IEnumerable(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, Long, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="dd0f0-639">Typ danych w źródle.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-639">The type of the data in the source.</span></span></typeparam>
        <typeparam name="TLocal"><span data-ttu-id="dd0f0-640">Typ danych lokalnych wątku.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-640">The type of the thread-local data.</span></span></typeparam>
        <param name="source"><span data-ttu-id="dd0f0-641">Wyliczalne źródło danych.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-641">An enumerable data source.</span></span></param>
        <param name="localInit"><span data-ttu-id="dd0f0-642">Delegat funkcji, który zwraca początkowy stan danych lokalnych dla każdego zadania.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-642">The function delegate that returns the initial state of the local data for each task.</span></span></param>
        <param name="body"><span data-ttu-id="dd0f0-643">Delegat, który jest wywoływany raz na iterację.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-643">The delegate that is invoked once per iteration.</span></span></param>
        <param name="localFinally"><span data-ttu-id="dd0f0-644">Delegat, który wykonuje ostateczną akcję na lokalnym stanie każdego zadania.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-644">The delegate that performs a final action on the local state of each task.</span></span></param>
        <summary><span data-ttu-id="dd0f0-645">Wykonuje operację<see langword="For Each" /> <see cref="T:System.Collections.IEnumerable" /> (w Visual Basic) z danymi lokalnymi wątku, w których iteracje mogą działać równolegle, a stan pętli może być monitorowany i manipulowany. <see langword="foreach" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-645">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation with thread-local data on an <see cref="T:System.Collections.IEnumerable" /> in which iterations may run in parallel and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="dd0f0-646">Struktura, która zawiera informacje o tym, która część pętli została ukończona.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-646">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd0f0-647">Delegat jest wywoływany jednokrotnie dla każdego elementu `source` w wyliczalnym. `body`</span><span class="sxs-lookup"><span data-stu-id="dd0f0-647">The `body` delegate is invoked once for each element in the `source` enumerable.</span></span> <span data-ttu-id="dd0f0-648">Jest on dostarczany z następującymi parametrami: bieżącym elementem, <xref:System.Threading.Tasks.ParallelLoopState> wystąpieniem, które może być używane do wypełniania pętli przedwcześnie, indeks bieżącego elementu (<xref:System.Int64>) i część stanu lokalnego, które mogą być współużytkowane przez iteracje, które wykonuje w tym samym wątku.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-648">It is provided with the following parameters: the current element, a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely, the current element's index (<xref:System.Int64>), and some local state that may be shared amongst iterations that execute on the same thread.</span></span>  
  
 <span data-ttu-id="dd0f0-649">`localInit` Delegat jest wywoływany jednokrotnie dla każdego zadania, które uczestniczy w wykonaniu pętli i zwraca początkowy stan lokalny dla każdego z tych zadań.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-649">The `localInit` delegate is invoked once for each task that participates in the loop's execution and returns the initial local state for each of those tasks.</span></span> <span data-ttu-id="dd0f0-650">Te Stany początkowe są przesyłane do pierwszych `body` wywołań każdego zadania.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-650">These initial states are passed to the first `body` invocations on each task.</span></span> <span data-ttu-id="dd0f0-651">Następnie każde kolejne wywołanie treści zwróci prawdopodobnie zmodyfikowaną wartość stanu, która jest przenoszona do następnego wywołania treści.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-651">Then, every subsequent body invocation returns a possibly modified state value that is passed to the next body invocation.</span></span> <span data-ttu-id="dd0f0-652">Na koniec ostatnie wywołanie treści dla każdego zadania zwraca wartość stanu, która jest przenoszona do `localFinally` delegata.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-652">Finally, the last body invocation on each task returns a state value that is passed to the `localFinally` delegate.</span></span> <span data-ttu-id="dd0f0-653">`localFinally` Delegat jest wywoływany raz na zadanie w celu wykonania końcowej akcji na lokalnym stanie każdego zadania.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-653">The `localFinally` delegate is invoked once per task to perform a final action on each task's local state.</span></span> <span data-ttu-id="dd0f0-654">Ten delegat może być wywoływany współbieżnie dla wielu zadań; w związku z tym należy synchronizować dostęp do dowolnych zmiennych udostępnionych.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-654">This delegate might be invoked concurrently on multiple tasks; therefore, you must synchronize access to any shared variables.</span></span>  
  
 <span data-ttu-id="dd0f0-655"><xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Metoda może korzystać z większej liczby zadań niż wątki w okresie istnienia wykonywania, ponieważ istniejące zadania zostały ukończone i są zastępowane przez nowe zadania.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-655">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method may use more tasks than threads over the lifetime of its execution, as existing tasks complete and are replaced by new tasks.</span></span> <span data-ttu-id="dd0f0-656">Dzięki temu obiekt źródłowy <xref:System.Threading.Tasks.TaskScheduler> może dodawać, zmieniać lub usuwać wątki obsługujące pętlę.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-656">This gives the underlying <xref:System.Threading.Tasks.TaskScheduler> object the chance to add, change, or remove threads that service the loop.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd0f0-657">Argument ma wartość <see langword="null" />. <paramref name="source" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-657">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd0f0-658">—lub—</span><span class="sxs-lookup"><span data-stu-id="dd0f0-658">-or-</span></span> 
<span data-ttu-id="dd0f0-659">Argument ma wartość <see langword="null" />. <paramref name="body" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-659">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd0f0-660">—lub—</span><span class="sxs-lookup"><span data-stu-id="dd0f0-660">-or-</span></span> 
<span data-ttu-id="dd0f0-661">Argument ma wartość <see langword="null" />. <paramref name="localInit" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-661">The <paramref name="localInit" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd0f0-662">—lub—</span><span class="sxs-lookup"><span data-stu-id="dd0f0-662">-or-</span></span> 
<span data-ttu-id="dd0f0-663">Argument ma wartość <see langword="null" />. <paramref name="localFinally" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-663">The <paramref name="localFinally" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="dd0f0-664">Wyjątek, który zawiera wszystkie poszczególne wyjątki zgłoszone we wszystkich wątkach.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-664">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="dd0f0-665">Pętle równoległe</span><span class="sxs-lookup"><span data-stu-id="dd0f0-665">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As IEnumerable(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="dd0f0-666">Typ danych w źródle.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-666">The type of the data in the source.</span></span></typeparam>
        <typeparam name="TLocal"><span data-ttu-id="dd0f0-667">Typ danych lokalnych wątku.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-667">The type of the thread-local data.</span></span></typeparam>
        <param name="source"><span data-ttu-id="dd0f0-668">Wyliczalne źródło danych.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-668">An enumerable data source.</span></span></param>
        <param name="localInit"><span data-ttu-id="dd0f0-669">Delegat funkcji, który zwraca początkowy stan danych lokalnych dla każdego zadania.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-669">The function delegate that returns the initial state of the local data for each task.</span></span></param>
        <param name="body"><span data-ttu-id="dd0f0-670">Delegat, który jest wywoływany raz na iterację.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-670">The delegate that is invoked once per iteration.</span></span></param>
        <param name="localFinally"><span data-ttu-id="dd0f0-671">Delegat, który wykonuje ostateczną akcję na lokalnym stanie każdego zadania.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-671">The delegate that performs a final action on the local state of each task.</span></span></param>
        <summary><span data-ttu-id="dd0f0-672">Wykonuje operację<see langword="For Each" /> <see cref="T:System.Collections.IEnumerable" /> (w Visual Basic) z danymi lokalnymi wątku w przypadku, w którym iteracje mogą działać równolegle, a stan pętli może być monitorowany i manipulowany. <see langword="foreach" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-672">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation with thread-local data on an <see cref="T:System.Collections.IEnumerable" /> in which iterations may run in parallel, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="dd0f0-673">Struktura, która zawiera informacje o tym, która część pętli została ukończona.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-673">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd0f0-674">Delegat jest wywoływany jednokrotnie dla każdego elementu `source` w wyliczalnym. `body`</span><span class="sxs-lookup"><span data-stu-id="dd0f0-674">The `body` delegate is invoked once for each element in the `source` enumerable.</span></span> <span data-ttu-id="dd0f0-675">Jest on dostarczany z następującymi parametrami: bieżącym elementem, <xref:System.Threading.Tasks.ParallelLoopState> wystąpieniem, które może służyć do wypełniania pętli przedwcześnie i niektórych stanów lokalnych, które mogą być współużytkowane przez iteracje wykonywane w tym samym wątku.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-675">It is provided with the following parameters: the current element, a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely, and some local state that may be shared amongst iterations that execute on the same thread.</span></span>  
  
 <span data-ttu-id="dd0f0-676">`localInit` Delegat jest wywoływany jednokrotnie dla każdego zadania, które uczestniczy w wykonaniu pętli i zwraca początkowy stan lokalny dla każdego z tych zadań.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-676">The `localInit` delegate is invoked once for each task that participates in the loop's execution and returns the initial local state for each of those tasks.</span></span> <span data-ttu-id="dd0f0-677">Te Stany początkowe są przesyłane do pierwszych `body` wywołań każdego zadania.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-677">These initial states are passed to the first `body` invocations on each task.</span></span> <span data-ttu-id="dd0f0-678">Następnie każde kolejne wywołanie treści zwróci prawdopodobnie zmodyfikowaną wartość stanu, która jest przenoszona do następnego wywołania treści.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-678">Then, every subsequent body invocation returns a possibly modified state value that is passed to the next body invocation.</span></span> <span data-ttu-id="dd0f0-679">Na koniec ostatnie wywołanie treści dla każdego zadania zwraca wartość stanu, która jest przenoszona do `localFinally` delegata.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-679">Finally, the last body invocation on each task returns a state value that is passed to the `localFinally` delegate.</span></span> <span data-ttu-id="dd0f0-680">`localFinally` Delegat jest wywoływany raz na wątek, aby wykonać ostateczną akcję na lokalnym stanie każdego zadania.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-680">The `localFinally` delegate is invoked once per thread to perform a final action on each task's local state.</span></span> <span data-ttu-id="dd0f0-681">Ten delegat może być wywoływany współbieżnie dla wielu zadań; w związku z tym należy synchronizować dostęp do dowolnych zmiennych udostępnionych.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-681">This delegate might be invoked concurrently on multiple tasks; therefore, you must synchronize access to any shared variables.</span></span>  
  
 <span data-ttu-id="dd0f0-682"><xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Metoda może korzystać z większej liczby zadań niż wątki w okresie istnienia wykonywania, ponieważ istniejące zadania zostały ukończone i są zastępowane przez nowe zadania.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-682">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method may use more tasks than threads over the lifetime of its execution, as existing tasks complete and are replaced by new tasks.</span></span> <span data-ttu-id="dd0f0-683">Dzięki temu obiekt źródłowy <xref:System.Threading.Tasks.TaskScheduler> może dodawać, zmieniać lub usuwać wątki obsługujące pętlę.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-683">This gives the underlying <xref:System.Threading.Tasks.TaskScheduler> object the chance to add, change, or remove threads that service the loop.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd0f0-684">Poniższy przykład pokazuje, <xref:System.Threading.Tasks.Parallel.ForEach%2A> jak używać metody ze stanem lokalnym:</span><span class="sxs-lookup"><span data-stu-id="dd0f0-684">The following example shows how to use a <xref:System.Threading.Tasks.Parallel.ForEach%2A> method with local state:</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Parallel#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelforeach.cs#02)]
 [!code-vb[System.Threading.Tasks.Parallel#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelforeach.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd0f0-685">Argument ma wartość <see langword="null" />. <paramref name="source" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-685">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd0f0-686">—lub—</span><span class="sxs-lookup"><span data-stu-id="dd0f0-686">-or-</span></span> 
<span data-ttu-id="dd0f0-687">Argument ma wartość <see langword="null" />. <paramref name="body" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-687">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd0f0-688">—lub—</span><span class="sxs-lookup"><span data-stu-id="dd0f0-688">-or-</span></span> 
<span data-ttu-id="dd0f0-689">Argument ma wartość <see langword="null" />. <paramref name="localInit" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-689">The <paramref name="localInit" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd0f0-690">—lub—</span><span class="sxs-lookup"><span data-stu-id="dd0f0-690">-or-</span></span> 
<span data-ttu-id="dd0f0-691">Argument ma wartość <see langword="null" />. <paramref name="localFinally" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-691">The <paramref name="localFinally" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="dd0f0-692">Wyjątek, który zawiera wszystkie poszczególne wyjątki zgłoszone we wszystkich wątkach.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-692">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="dd0f0-693">Pętle równoległe</span><span class="sxs-lookup"><span data-stu-id="dd0f0-693">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.OrderablePartitioner{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="dd0f0-694">Typ elementów w <paramref name="source" />.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-694">The type of the elements in <paramref name="source" />.</span></span></typeparam>
        <typeparam name="TLocal"><span data-ttu-id="dd0f0-695">Typ danych lokalnych wątku.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-695">The type of the thread-local data.</span></span></typeparam>
        <param name="source"><span data-ttu-id="dd0f0-696">Uporządkowana partycja, która zawiera oryginalne źródło danych.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-696">The orderable partitioner that contains the original data source.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="dd0f0-697">Obiekt, który konfiguruje zachowanie tej operacji.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-697">An object that configures the behavior of this operation.</span></span></param>
        <param name="localInit"><span data-ttu-id="dd0f0-698">Delegat funkcji, który zwraca początkowy stan danych lokalnych dla każdego zadania.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-698">The function delegate that returns the initial state of the local data for each task.</span></span></param>
        <param name="body"><span data-ttu-id="dd0f0-699">Delegat, który jest wywoływany raz na iterację.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-699">The delegate that is invoked once per iteration.</span></span></param>
        <param name="localFinally"><span data-ttu-id="dd0f0-700">Delegat, który wykonuje ostateczną akcję na lokalnym stanie każdego zadania.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-700">The delegate that performs a final action on the local state of each task.</span></span></param>
        <summary><span data-ttu-id="dd0f0-701">Wykonuje operację<see langword="For Each" /> <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> (w Visual Basic) z indeksami 64-bitowymi i danymi lokalnymi wątku w, w których iteracje mogą działać równolegle, można skonfigurować opcje pętli, a stan pętli można monitorować i <see langword="foreach" /> manipulować.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-701">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation with 64-bit indexes and  with thread-local data on a <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> in which iterations may run in parallel , loop options can be configured, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="dd0f0-702">Struktura, która zawiera informacje o tym, która część pętli została ukończona.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-702">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd0f0-703">To przeciążenie jest dostępne dla scenariuszy, w których chcesz przesłonić domyślny schemat partycjonowania.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-703">This overload is provided for scenarios where you want to override the default partitioning scheme.</span></span> <span data-ttu-id="dd0f0-704">Na przykład małe treści pętli mogą korzystać z partycjonowania zakresu.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-704">For example, small loop bodies might benefit from partitioning the range.</span></span> <span data-ttu-id="dd0f0-705">Metoda <xref:System.Threading.Tasks.Parallel.ForEach%2A> oczekuje, że niestandardowe partycje obsługują partycjonowanie dynamiczne.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-705">The <xref:System.Threading.Tasks.Parallel.ForEach%2A> method expects custom partitioners to support dynamic partitioning.</span></span> <span data-ttu-id="dd0f0-706">Aby uzyskać więcej informacji, zobacz [niestandardowe partycje dla PLINQ i TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) i [instrukcje: Implementowanie partycji](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)dynamicznych.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-706">For more information, see [Custom Partitioners for PLINQ and TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) and [How to: Implement Dynamic Partitions](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>  
  
 <span data-ttu-id="dd0f0-707">`localInit` Delegat jest wywoływany jednokrotnie dla każdego zadania, które uczestniczy w wykonaniu pętli i zwraca początkowy stan lokalny dla każdego z tych zadań.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-707">The `localInit` delegate is invoked once for each task that participates in the loop's execution and returns the initial local state for each of those tasks.</span></span> <span data-ttu-id="dd0f0-708">Te Stany początkowe są przesyłane do pierwszych `body` wywołań każdego zadania.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-708">These initial states are passed to the first `body` invocations on each task.</span></span> <span data-ttu-id="dd0f0-709">Następnie każde kolejne wywołanie treści zwróci prawdopodobnie zmodyfikowaną wartość stanu, która jest przenoszona do następnego wywołania treści.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-709">Then, every subsequent body invocation returns a possibly modified state value that is passed to the next body invocation.</span></span> <span data-ttu-id="dd0f0-710">Na koniec ostatnie wywołanie treści dla każdego wątku zwraca wartość stanu, która jest przenoszona do `localFinally` delegata.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-710">Finally, the last body invocation on each thread returns a state value that is passed to the `localFinally` delegate.</span></span> <span data-ttu-id="dd0f0-711">`localFinally` Delegat jest wywoływany raz na zadanie w celu wykonania końcowej akcji na lokalnym stanie każdego zadania.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-711">The `localFinally` delegate is invoked once per task to perform a final action on each task's local state.</span></span> <span data-ttu-id="dd0f0-712">Ten delegat może być wywoływany współbieżnie dla wielu zadań; w związku z tym należy synchronizować dostęp do dowolnych zmiennych udostępnionych.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-712">This delegate might be invoked concurrently on multiple tasks; therefore, you must synchronize access to any shared variables.</span></span>  
  
 <span data-ttu-id="dd0f0-713"><xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Metoda może korzystać z większej liczby zadań niż wątki w okresie istnienia wykonywania, ponieważ istniejące zadania zostały ukończone i są zastępowane przez nowe zadania.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-713">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method may use more tasks than threads over the lifetime of its execution, as existing tasks complete and are replaced by new tasks.</span></span> <span data-ttu-id="dd0f0-714">Dzięki temu obiekt źródłowy <xref:System.Threading.Tasks.TaskScheduler> może dodawać, zmieniać lub usuwać wątki obsługujące pętlę.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-714">This gives the underlying <xref:System.Threading.Tasks.TaskScheduler> object the chance to add, change, or remove threads that service the loop.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd0f0-715">Argument ma wartość <see langword="null" />. <paramref name="source" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-715">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd0f0-716">—lub—</span><span class="sxs-lookup"><span data-stu-id="dd0f0-716">-or-</span></span> 
<span data-ttu-id="dd0f0-717">Argument ma wartość <see langword="null" />. <paramref name="parallelOptions" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-717">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd0f0-718">—lub—</span><span class="sxs-lookup"><span data-stu-id="dd0f0-718">-or-</span></span> 
<span data-ttu-id="dd0f0-719">Argument ma wartość <see langword="null" />. <paramref name="body" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-719">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd0f0-720">—lub—</span><span class="sxs-lookup"><span data-stu-id="dd0f0-720">-or-</span></span> 
<span data-ttu-id="dd0f0-721">Argument <paramref name="localInit" /> or <paramref name="localFinally" /> ma<see langword="null" />wartość.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-721">The <paramref name="localInit" /> or <paramref name="localFinally" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="dd0f0-722"><see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> Właściwość w<paramref name="source" /> zwracaniu<see langword="false" /> lub partycji zwraca<see langword="null" /> partycje. <see cref="T:System.Collections.Concurrent.Partitioner" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-722">The <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> property in the <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> returns <see langword="false" /> or the partitioner returns <see langword="null" /> partitions.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="dd0f0-723">Wyjątek, który zawiera wszystkie poszczególne wyjątki zgłoszone we wszystkich wątkach.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-723">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="dd0f0-724"><see cref="T:System.Threading.CancellationToken" /> W<paramref name="parallelOptions" /> argumencie zostanie anulowana.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-724">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="dd0f0-725">Skojarzona z elementem <paramref name="parallelOptions" /> w został usunięty. <see cref="T:System.Threading.CancellationToken" /> <see cref="T:System.Threading.CancellationTokenSource" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-725">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="dd0f0-726">Pętle równoległe</span><span class="sxs-lookup"><span data-stu-id="dd0f0-726">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="dd0f0-727">Typ elementów w <paramref name="source" />.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-727">The type of the elements in <paramref name="source" />.</span></span></typeparam>
        <typeparam name="TLocal"><span data-ttu-id="dd0f0-728">Typ danych lokalnych wątku.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-728">The type of the thread-local data.</span></span></typeparam>
        <param name="source"><span data-ttu-id="dd0f0-729">Partycja zawierająca oryginalne źródło danych.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-729">The partitioner that contains the original data source.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="dd0f0-730">Obiekt, który konfiguruje zachowanie tej operacji.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-730">An object that configures the behavior of this operation.</span></span></param>
        <param name="localInit"><span data-ttu-id="dd0f0-731">Delegat funkcji, który zwraca początkowy stan danych lokalnych dla każdego zadania.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-731">The function delegate that returns the initial state of the local data for each task.</span></span></param>
        <param name="body"><span data-ttu-id="dd0f0-732">Delegat, który jest wywoływany raz na iterację.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-732">The delegate that is invoked once per iteration.</span></span></param>
        <param name="localFinally"><span data-ttu-id="dd0f0-733">Delegat, który wykonuje ostateczną akcję na lokalnym stanie każdego zadania.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-733">The delegate that performs a final action on the local state of each task.</span></span></param>
        <summary><span data-ttu-id="dd0f0-734">Wykonuje operację<see langword="For Each" /> <see cref="T:System.Collections.Concurrent.Partitioner" /> (w Visual Basic) przy użyciu danych z wątku lokalnego, w którym iteracje mogą działać równolegle, można skonfigurować opcje pętli, a stan pętli można monitorować i manipulować. <see langword="foreach" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-734">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation  with thread-local data on a <see cref="T:System.Collections.Concurrent.Partitioner" /> in which iterations may run in parallel, loop options can be configured, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="dd0f0-735">Struktura, która zawiera informacje o tym, która część pętli została ukończona.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-735">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd0f0-736">To przeciążenie jest dostępne dla scenariuszy, w których chcesz przesłonić domyślny schemat partycjonowania.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-736">This overload is provided for scenarios where you want to override the default partitioning scheme.</span></span> <span data-ttu-id="dd0f0-737">Na przykład małe treści pętli mogą korzystać z partycjonowania zakresu.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-737">For example, small loop bodies might benefit from partitioning the range.</span></span> <span data-ttu-id="dd0f0-738">Metoda <xref:System.Threading.Tasks.Parallel.ForEach%2A> oczekuje, że niestandardowe partycje obsługują partycjonowanie dynamiczne.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-738">The <xref:System.Threading.Tasks.Parallel.ForEach%2A> method expects custom partitioners to support dynamic partitioning.</span></span> <span data-ttu-id="dd0f0-739">To przeciążenie jest zapewnione w scenariuszach z małymi ciałami pętli, które mogą korzystać z partycjonowania zakresu statycznego.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-739">This overload is provided for scenarios with small loop bodies that might benefit from static range partitioning.</span></span> <span data-ttu-id="dd0f0-740">Partycje muszą obsługiwać partycje dynamiczne.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-740">Partitioners must support dynamic partitions.</span></span>  <span data-ttu-id="dd0f0-741">Aby uzyskać więcej informacji, zobacz [niestandardowe partycje dla PLINQ i TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) i [instrukcje: Implementowanie partycji](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)dynamicznych.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-741">For more information, see [Custom Partitioners for PLINQ and TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) and [How to: Implement Dynamic Partitions](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>  
  
 <span data-ttu-id="dd0f0-742">`localInit` Delegat jest wywoływany jednokrotnie dla każdego zadania, które uczestniczy w wykonaniu pętli i zwraca początkowy stan lokalny dla każdego z tych zadań.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-742">The `localInit` delegate is invoked once for each task that participates in the loop's execution and returns the initial local state for each of those tasks.</span></span> <span data-ttu-id="dd0f0-743">Te Stany początkowe są przesyłane do pierwszych `body` wywołań każdego zadania.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-743">These initial states are passed to the first `body` invocations on each task.</span></span> <span data-ttu-id="dd0f0-744">Następnie każde kolejne wywołanie treści zwróci prawdopodobnie zmodyfikowaną wartość stanu, która jest przenoszona do następnego wywołania treści.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-744">Then, every subsequent body invocation returns a possibly modified state value that is passed to the next body invocation.</span></span> <span data-ttu-id="dd0f0-745">Na koniec ostatnie wywołanie treści dla każdego zadania zwraca wartość stanu, która jest przenoszona do `localFinally` delegata.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-745">Finally, the last body invocation on each task returns a state value that is passed to the `localFinally` delegate.</span></span> <span data-ttu-id="dd0f0-746">`localFinally` Delegat jest wywoływany raz na zadanie w celu wykonania końcowej akcji na lokalnym stanie każdego zadania.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-746">The `localFinally` delegate is invoked once per task to perform a final action on each task's local state.</span></span> <span data-ttu-id="dd0f0-747">Ten delegat może być wywoływany współbieżnie dla wielu zadań; w związku z tym należy synchronizować dostęp do dowolnych zmiennych udostępnionych.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-747">This delegate might be invoked concurrently on multiple tasks; therefore, you must synchronize access to any shared variables.</span></span>  
  
 <span data-ttu-id="dd0f0-748"><xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Metoda może korzystać z większej liczby zadań niż wątki w okresie istnienia wykonywania, ponieważ istniejące zadania zostały ukończone i są zastępowane przez nowe zadania.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-748">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method may use more tasks than threads over the lifetime of its execution, as existing tasks complete and are replaced by new tasks.</span></span> <span data-ttu-id="dd0f0-749">Dzięki temu obiekt źródłowy <xref:System.Threading.Tasks.TaskScheduler> może dodawać, zmieniać lub usuwać wątki obsługujące pętlę.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-749">This gives the underlying <xref:System.Threading.Tasks.TaskScheduler> object the chance to add, change, or remove threads that service the loop.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd0f0-750">Argument ma wartość <see langword="null" />. <paramref name="source" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-750">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd0f0-751">—lub—</span><span class="sxs-lookup"><span data-stu-id="dd0f0-751">-or-</span></span> 
<span data-ttu-id="dd0f0-752">Argument ma wartość <see langword="null" />. <paramref name="parallelOptions" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-752">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd0f0-753">—lub—</span><span class="sxs-lookup"><span data-stu-id="dd0f0-753">-or-</span></span> 
<span data-ttu-id="dd0f0-754">Argument ma wartość <see langword="null" />. <paramref name="body" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-754">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd0f0-755">—lub—</span><span class="sxs-lookup"><span data-stu-id="dd0f0-755">-or-</span></span> 
<span data-ttu-id="dd0f0-756">Argument ma wartość <see langword="null" />. <paramref name="localInit" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-756">The <paramref name="localInit" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd0f0-757">—lub—</span><span class="sxs-lookup"><span data-stu-id="dd0f0-757">-or-</span></span> 
<span data-ttu-id="dd0f0-758">Argument ma wartość <see langword="null" />. <paramref name="localFinally" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-758">The <paramref name="localFinally" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="dd0f0-759"><see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> Właściwość w<paramref name="source" /> zwracaniu<see langword="false" /> lub partycji zwraca<see langword="null" /> partycje. <see cref="T:System.Collections.Concurrent.Partitioner" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-759">The <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> property in the <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> returns <see langword="false" /> or the partitioner returns <see langword="null" /> partitions.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="dd0f0-760">Wyjątek, który zawiera wszystkie poszczególne wyjątki zgłoszone we wszystkich wątkach.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-760">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="dd0f0-761"><see cref="T:System.Threading.CancellationToken" /> W<paramref name="parallelOptions" /> argumencie zostanie anulowana.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-761">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="dd0f0-762">Skojarzona z elementem <paramref name="parallelOptions" /> w został usunięty. <see cref="T:System.Threading.CancellationToken" /> <see cref="T:System.Threading.CancellationTokenSource" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-762">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="dd0f0-763">Pętle równoległe</span><span class="sxs-lookup"><span data-stu-id="dd0f0-763">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="dd0f0-764">Typ danych w źródle.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-764">The type of the data in the source.</span></span></typeparam>
        <typeparam name="TLocal"><span data-ttu-id="dd0f0-765">Typ danych lokalnych wątku.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-765">The type of the thread-local data.</span></span></typeparam>
        <param name="source"><span data-ttu-id="dd0f0-766">Wyliczalne źródło danych.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-766">An enumerable data source.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="dd0f0-767">Obiekt, który konfiguruje zachowanie tej operacji.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-767">An object that configures the behavior of this operation.</span></span></param>
        <param name="localInit"><span data-ttu-id="dd0f0-768">Delegat funkcji, który zwraca początkowy stan danych lokalnych dla każdego zadania.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-768">The function delegate that returns the initial state of the local data for each task.</span></span></param>
        <param name="body"><span data-ttu-id="dd0f0-769">Delegat, który jest wywoływany raz na iterację.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-769">The delegate that is invoked once per iteration.</span></span></param>
        <param name="localFinally"><span data-ttu-id="dd0f0-770">Delegat, który wykonuje ostateczną akcję na lokalnym stanie każdego zadania.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-770">The delegate that performs a final action on the local state of each task.</span></span></param>
        <summary><span data-ttu-id="dd0f0-771">Wykonuje operację<see langword="For Each" /> <see cref="T:System.Collections.IEnumerable" /> (w Visual Basic) z danymi lokalnymi wątku i 64-bitowymi indeksami dla, w których iteracje mogą działać równolegle, można skonfigurować opcje pętli, a stan pętli można monitorować i manipulować. <see langword="foreach" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-771">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation with thread-local data and 64-bit indexes on an <see cref="T:System.Collections.IEnumerable" /> in which iterations may run in parallel, loop options can be configured, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="dd0f0-772">Struktura, która zawiera informacje o tym, która część pętli została ukończona.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-772">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd0f0-773">Delegat jest wywoływany jednokrotnie dla każdego elementu `source` w wyliczalnym. `body`</span><span class="sxs-lookup"><span data-stu-id="dd0f0-773">The `body` delegate is invoked once for each element in the `source` enumerable.</span></span> <span data-ttu-id="dd0f0-774">Jest on dostarczany z następującymi parametrami: bieżącym elementem, <xref:System.Threading.Tasks.ParallelLoopState> wystąpieniem, które może być używane do wypełniania pętli przedwcześnie, indeks bieżącego elementu (<xref:System.Int64>) i część stanu lokalnego, które mogą być współużytkowane przez iteracje, które wykonuje w tym samym wątku.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-774">It is provided with the following parameters: the current element, a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely, the current element's index (<xref:System.Int64>), and some local state that may be shared amongst iterations that execute on the same thread.</span></span>  
  
 <span data-ttu-id="dd0f0-775">`localInit` Delegat jest wywoływany jednokrotnie dla każdego zadania, które uczestniczy w wykonaniu pętli i zwraca początkowy stan lokalny dla każdego z tych zadań.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-775">The `localInit` delegate is invoked once for each task that participates in the loop's execution and returns the initial local state for each of those tasks.</span></span> <span data-ttu-id="dd0f0-776">Te Stany początkowe są przesyłane do pierwszych `body` wywołań każdego zadania.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-776">These initial states are passed to the first `body` invocations on each task.</span></span> <span data-ttu-id="dd0f0-777">Następnie każde kolejne wywołanie treści zwróci prawdopodobnie zmodyfikowaną wartość stanu, która jest przenoszona do następnego wywołania treści.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-777">Then, every subsequent body invocation returns a possibly modified state value that is passed to the next body invocation.</span></span> <span data-ttu-id="dd0f0-778">Na koniec ostatnie wywołanie treści dla każdego zadania zwraca wartość stanu, która jest przenoszona do `localFinally` delegata.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-778">Finally, the last body invocation on each task returns a state value that is passed to the `localFinally` delegate.</span></span> <span data-ttu-id="dd0f0-779">`localFinally` Delegat jest wywoływany raz na wątek, aby wykonać ostateczną akcję na lokalnym stanie każdego zadania.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-779">The `localFinally` delegate is invoked once per thread to perform a final action on each task's local state.</span></span> <span data-ttu-id="dd0f0-780">Ten delegat może być wywoływany współbieżnie dla wielu zadań; w związku z tym należy synchronizować dostęp do dowolnych zmiennych udostępnionych.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-780">This delegate might be invoked concurrently on multiple tasks; therefore, you must synchronize access to any shared variables.</span></span>  
  
 <span data-ttu-id="dd0f0-781"><xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Metoda może korzystać z większej liczby zadań niż wątki w okresie istnienia wykonywania, ponieważ istniejące zadania zostały ukończone i są zastępowane przez nowe zadania.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-781">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method may use more tasks than threads over the lifetime of its execution, as existing tasks complete and are replaced by new tasks.</span></span> <span data-ttu-id="dd0f0-782">Dzięki temu obiekt źródłowy <xref:System.Threading.Tasks.TaskScheduler> może dodawać, zmieniać lub usuwać wątki obsługujące pętlę.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-782">This gives the underlying <xref:System.Threading.Tasks.TaskScheduler> object the chance to add, change, or remove threads that service the loop.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd0f0-783">Argument ma wartość <see langword="null" />. <paramref name="source" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-783">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd0f0-784">—lub—</span><span class="sxs-lookup"><span data-stu-id="dd0f0-784">-or-</span></span> 
<span data-ttu-id="dd0f0-785">Argument ma wartość <see langword="null" />. <paramref name="parallelOptions" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-785">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd0f0-786">—lub—</span><span class="sxs-lookup"><span data-stu-id="dd0f0-786">-or-</span></span> 
<span data-ttu-id="dd0f0-787">Argument ma wartość <see langword="null" />. <paramref name="body" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-787">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd0f0-788">—lub—</span><span class="sxs-lookup"><span data-stu-id="dd0f0-788">-or-</span></span> 
<span data-ttu-id="dd0f0-789">Argument ma wartość <see langword="null" />. <paramref name="localInit" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-789">The <paramref name="localInit" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd0f0-790">—lub—</span><span class="sxs-lookup"><span data-stu-id="dd0f0-790">-or-</span></span> 
<span data-ttu-id="dd0f0-791">Argument ma wartość <see langword="null" />. <paramref name="localFinally" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-791">The <paramref name="localFinally" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="dd0f0-792"><see cref="T:System.Threading.CancellationToken" /> W<paramref name="parallelOptions" /> argumencie zostanie anulowana.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-792">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="dd0f0-793">Skojarzona z elementem <paramref name="parallelOptions" /> w został usunięty. <see cref="T:System.Threading.CancellationToken" /> <see cref="T:System.Threading.CancellationTokenSource" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-793">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="dd0f0-794">Wyjątek, który zawiera wszystkie poszczególne wyjątki zgłoszone we wszystkich wątkach.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-794">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="dd0f0-795">Pętle równoległe</span><span class="sxs-lookup"><span data-stu-id="dd0f0-795">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="dd0f0-796">Typ danych w źródle.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-796">The type of the data in the source.</span></span></typeparam>
        <typeparam name="TLocal"><span data-ttu-id="dd0f0-797">Typ danych lokalnych wątku.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-797">The type of the thread-local data.</span></span></typeparam>
        <param name="source"><span data-ttu-id="dd0f0-798">Wyliczalne źródło danych.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-798">An enumerable data source.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="dd0f0-799">Obiekt, który konfiguruje zachowanie tej operacji.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-799">An object that configures the behavior of this operation.</span></span></param>
        <param name="localInit"><span data-ttu-id="dd0f0-800">Delegat funkcji, który zwraca początkowy stan danych lokalnych dla każdego zadania.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-800">The function delegate that returns the initial state of the local data for each task.</span></span></param>
        <param name="body"><span data-ttu-id="dd0f0-801">Delegat, który jest wywoływany raz na iterację.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-801">The delegate that is invoked once per iteration.</span></span></param>
        <param name="localFinally"><span data-ttu-id="dd0f0-802">Delegat, który wykonuje ostateczną akcję na lokalnym stanie każdego zadania.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-802">The delegate that performs a final action on the local state of each task.</span></span></param>
        <summary><span data-ttu-id="dd0f0-803">Wykonuje operację<see langword="For Each" /> <see cref="T:System.Collections.IEnumerable" /> (w Visual Basic) z danymi lokalnymi wątku w przypadku, w którym iteracje mogą działać równolegle, można skonfigurować opcje pętli, a stan pętli można monitorować i manipulować. <see langword="foreach" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-803">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation with thread-local data on an <see cref="T:System.Collections.IEnumerable" /> in which iterations may run in parallel, loop options can be configured, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="dd0f0-804">Struktura, która zawiera informacje o tym, która część pętli została ukończona.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-804">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd0f0-805">Delegat jest wywoływany jednokrotnie dla każdego elementu `source` w wyliczalnym. `body`</span><span class="sxs-lookup"><span data-stu-id="dd0f0-805">The `body` delegate is invoked once for each element in the `source` enumerable.</span></span> <span data-ttu-id="dd0f0-806">Jest on dostarczany z następującymi parametrami: bieżącym elementem, <xref:System.Threading.Tasks.ParallelLoopState> wystąpieniem, które może służyć do wypełniania pętli przedwcześnie i niektórych stanów lokalnych, które mogą być współużytkowane przez iteracje wykonywane w tym samym wątku.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-806">It is provided with the following parameters: the current element, a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely, and some local state that may be shared amongst iterations that execute on the same thread.</span></span>  
  
 <span data-ttu-id="dd0f0-807">`localInit` Delegat jest wywoływany jednokrotnie dla każdego zadania, które uczestniczy w wykonaniu pętli i zwraca początkowy stan lokalny dla każdego z tych zadań.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-807">The `localInit` delegate is invoked once for each task that participates in the loop's execution and returns the initial local state for each of those tasks.</span></span> <span data-ttu-id="dd0f0-808">Te Stany początkowe są przesyłane do pierwszych `body` wywołań każdego zadania.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-808">These initial states are passed to the first `body` invocations on each task.</span></span> <span data-ttu-id="dd0f0-809">Następnie każde kolejne wywołanie treści zwróci prawdopodobnie zmodyfikowaną wartość stanu, która jest przenoszona do następnego wywołania treści.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-809">Then, every subsequent body invocation returns a possibly modified state value that is passed to the next body invocation.</span></span> <span data-ttu-id="dd0f0-810">Na koniec ostatnie wywołanie treści dla każdego zadania zwraca wartość stanu, która jest przenoszona do `localFinally` delegata.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-810">Finally, the last body invocation on each task returns a state value that is passed to the `localFinally` delegate.</span></span> <span data-ttu-id="dd0f0-811">`localFinally` Delegat jest wywoływany raz na wątek, aby wykonać ostateczną akcję na lokalnym stanie każdego zadania.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-811">The `localFinally` delegate is invoked once per thread to perform a final action on each task's local state.</span></span> <span data-ttu-id="dd0f0-812">Ten delegat może być wywoływany współbieżnie dla wielu zadań; w związku z tym należy synchronizować dostęp do dowolnych zmiennych udostępnionych.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-812">This delegate might be invoked concurrently on multiple tasks; therefore, you must synchronize access to any shared variables.</span></span>  
  
 <span data-ttu-id="dd0f0-813"><xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Metoda może korzystać z większej liczby zadań niż wątki w okresie istnienia wykonywania, ponieważ istniejące zadania zostały ukończone i są zastępowane przez nowe zadania.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-813">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method may use more tasks than threads over the lifetime of its execution, as existing tasks complete and are replaced by new tasks.</span></span> <span data-ttu-id="dd0f0-814">Dzięki temu obiekt źródłowy <xref:System.Threading.Tasks.TaskScheduler> może dodawać, zmieniać lub usuwać wątki obsługujące pętlę.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-814">This gives the underlying <xref:System.Threading.Tasks.TaskScheduler> object the chance to add, change, or remove threads that service the loop.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd0f0-815">Argument ma wartość <see langword="null" />. <paramref name="source" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-815">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd0f0-816">—lub—</span><span class="sxs-lookup"><span data-stu-id="dd0f0-816">-or-</span></span> 
<span data-ttu-id="dd0f0-817">Argument ma wartość <see langword="null" />. <paramref name="parallelOptions" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-817">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd0f0-818">—lub—</span><span class="sxs-lookup"><span data-stu-id="dd0f0-818">-or-</span></span> 
<span data-ttu-id="dd0f0-819">Argument ma wartość <see langword="null" />. <paramref name="body" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-819">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd0f0-820">—lub—</span><span class="sxs-lookup"><span data-stu-id="dd0f0-820">-or-</span></span> 
<span data-ttu-id="dd0f0-821">Argument ma wartość <see langword="null" />. <paramref name="localInit" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-821">The <paramref name="localInit" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd0f0-822">—lub—</span><span class="sxs-lookup"><span data-stu-id="dd0f0-822">-or-</span></span> 
<span data-ttu-id="dd0f0-823">Argument ma wartość <see langword="null" />. <paramref name="localFinally" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-823">The <paramref name="localFinally" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="dd0f0-824"><see cref="T:System.Threading.CancellationToken" /> W<paramref name="parallelOptions" /> argumencie zostanie anulowana.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-824">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="dd0f0-825">Skojarzona z elementem <paramref name="parallelOptions" /> w został usunięty. <see cref="T:System.Threading.CancellationToken" /> <see cref="T:System.Threading.CancellationTokenSource" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-825">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="dd0f0-826">Wyjątek, który zawiera wszystkie poszczególne wyjątki zgłoszone we wszystkich wątkach.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-826">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="dd0f0-827">Pętle równoległe</span><span class="sxs-lookup"><span data-stu-id="dd0f0-827">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Invoke">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="dd0f0-828">Wykonuje każdą z podanych akcji, prawdopodobnie równolegle.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-828">Executes each of the provided actions, possibly in parallel.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static void Invoke (params Action[] actions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Invoke(class System.Action[] actions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.Invoke(System.Action[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Invoke (ParamArray actions As Action())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Invoke(... cli::array &lt;Action ^&gt; ^ actions);" />
      <MemberSignature Language="F#" Value="static member Invoke : Action[] -&gt; unit" Usage="System.Threading.Tasks.Parallel.Invoke actions" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="actions" Type="System.Action[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="actions"><span data-ttu-id="dd0f0-829">Tablica <see cref="T:System.Action" /> do wykonania.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-829">An array of <see cref="T:System.Action" /> to execute.</span></span></param>
        <summary><span data-ttu-id="dd0f0-830">Wykonuje każdą z podanych akcji, prawdopodobnie równolegle.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-830">Executes each of the provided actions, possibly in parallel.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd0f0-831">Ta metoda może być używana do wykonywania zestawu operacji, potencjalnie równolegle.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-831">This method can be used to execute a set of operations, potentially in parallel.</span></span>  
  
 <span data-ttu-id="dd0f0-832">Nie są wykonywane żadne gwarancje dotyczące kolejności wykonywania operacji lub wykonywania ich równolegle.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-832">No guarantees are made about the order in which the operations execute or whether they execute in parallel.</span></span> <span data-ttu-id="dd0f0-833">Ta metoda nie jest zwracana do momentu ukończenia każdej z podanych operacji, niezależnie od tego, czy następuje zakończenie lub wyjątkowe zakończenie.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-833">This method does not return until each of the provided operations has completed, regardless of whether completion occurs due to normal or exceptional termination.</span></span>  
  
 <span data-ttu-id="dd0f0-834">Aby uzyskać więcej informacji, zobacz [jak: Użyj metody Parallel. Invoke, aby wykonać](~/docs/standard/parallel-programming/how-to-use-parallel-invoke-to-execute-parallel-operations.md)operacje równoległe.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-834">For more information, see [How to: Use Parallel.Invoke to Execute Parallel Operations](~/docs/standard/parallel-programming/how-to-use-parallel-invoke-to-execute-parallel-operations.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="dd0f0-835">W tym przykładzie pokazano, jak używać <xref:System.Threading.Tasks.Parallel.Invoke%2A> metody z innymi metodami, delegatów anonimowych i wyrażeniami lambda.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-835">This example demonstrates how to use the <xref:System.Threading.Tasks.Parallel.Invoke%2A> method with other methods, anonymous delegates, and lambda expressions.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Parallel#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelinvoke.cs#01)]
 [!code-vb[System.Threading.Tasks.Parallel#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelinvoke.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd0f0-836">Argument ma wartość <see langword="null" />. <paramref name="actions" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-836">The <paramref name="actions" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="dd0f0-837">Wyjątek, który jest generowany, gdy którakolwiek akcja w <paramref name="actions" /> tablicy zgłosi wyjątek.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-837">The exception that is thrown when any action in the <paramref name="actions" /> array throws an exception.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="dd0f0-838"><paramref name="actions" /> Tablica<see langword="null" /> zawiera element.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-838">The <paramref name="actions" /> array contains a <see langword="null" /> element.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static void Invoke (System.Threading.Tasks.ParallelOptions parallelOptions, params Action[] actions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Invoke(class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action[] actions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.Invoke(System.Threading.Tasks.ParallelOptions,System.Action[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Invoke(System::Threading::Tasks::ParallelOptions ^ parallelOptions, ... cli::array &lt;Action ^&gt; ^ actions);" />
      <MemberSignature Language="F#" Value="static member Invoke : System.Threading.Tasks.ParallelOptions * Action[] -&gt; unit" Usage="System.Threading.Tasks.Parallel.Invoke (parallelOptions, actions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="actions" Type="System.Action[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="parallelOptions"><span data-ttu-id="dd0f0-839">Obiekt, który konfiguruje zachowanie tej operacji.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-839">An object that configures the behavior of this operation.</span></span></param>
        <param name="actions"><span data-ttu-id="dd0f0-840">Tablica akcji do wykonania.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-840">An array of actions to execute.</span></span></param>
        <summary><span data-ttu-id="dd0f0-841">Wykonuje każdą z podanych akcji, prawdopodobnie równolegle, chyba że operacja zostanie anulowana przez użytkownika.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-841">Executes each of the provided actions, possibly in parallel, unless the operation is cancelled by the user.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="dd0f0-842">Ta metoda może być używana do wykonywania zestawu operacji, potencjalnie równolegle.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-842">This method can be used to execute a set of operations, potentially in parallel.</span></span> <span data-ttu-id="dd0f0-843">Token anulowania przeszedł przy użyciu <xref:System.Threading.Tasks.ParallelOptions> struktury umożliwia obiektowi wywołującemu anulowanie całej operacji.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-843">The cancellation token passed in with the <xref:System.Threading.Tasks.ParallelOptions> structure enables the caller to cancel the entire operation.</span></span> <span data-ttu-id="dd0f0-844">Aby uzyskać więcej informacji, zobacz [Anulowanie w zarządzanych wątkach](~/docs/standard/threading/cancellation-in-managed-threads.md).</span><span class="sxs-lookup"><span data-stu-id="dd0f0-844">For more information, see [Cancellation in Managed Threads](~/docs/standard/threading/cancellation-in-managed-threads.md).</span></span>  
  
 <span data-ttu-id="dd0f0-845">Nie są wykonywane żadne gwarancje dotyczące kolejności wykonywania operacji lub wykonywania ich równolegle.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-845">No guarantees are made about the order in which the operations execute or whether they execute in parallel.</span></span> <span data-ttu-id="dd0f0-846">Ta metoda nie jest zwracana do momentu ukończenia każdej z podanych operacji, niezależnie od tego, czy następuje zakończenie lub wyjątkowe zakończenie.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-846">This method does not return until each of the provided operations has completed, regardless of whether completion occurs due to normal or exceptional termination.</span></span>  
  
 <span data-ttu-id="dd0f0-847">Aby uzyskać więcej informacji, zobacz [jak: Użyj metody Parallel. Invoke, aby wykonać](~/docs/standard/parallel-programming/how-to-use-parallel-invoke-to-execute-parallel-operations.md)operacje równoległe.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-847">For more information, see [How to: Use Parallel.Invoke to Execute Parallel Operations](~/docs/standard/parallel-programming/how-to-use-parallel-invoke-to-execute-parallel-operations.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="dd0f0-848"><see cref="T:System.Threading.CancellationToken" /> Jest ustawiony<paramref name="parallelOptions" /> .</span><span class="sxs-lookup"><span data-stu-id="dd0f0-848">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> is set.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="dd0f0-849">Argument ma wartość <see langword="null" />. <paramref name="actions" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-849">The <paramref name="actions" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="dd0f0-850">—lub—</span><span class="sxs-lookup"><span data-stu-id="dd0f0-850">-or-</span></span> 
<span data-ttu-id="dd0f0-851">Argument ma wartość <see langword="null" />. <paramref name="parallelOptions" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-851">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="dd0f0-852">Wyjątek, który jest generowany, gdy którakolwiek akcja w <paramref name="actions" /> tablicy zgłosi wyjątek.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-852">The exception that is thrown when any action in the <paramref name="actions" /> array throws an exception.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="dd0f0-853"><paramref name="actions" /> Tablica<see langword="null" /> zawiera element.</span><span class="sxs-lookup"><span data-stu-id="dd0f0-853">The <paramref name="actions" /> array contains a <see langword="null" /> element.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="dd0f0-854">Skojarzona z elementem <paramref name="parallelOptions" /> w został usunięty. <see cref="T:System.Threading.CancellationToken" /> <see cref="T:System.Threading.CancellationTokenSource" /></span><span class="sxs-lookup"><span data-stu-id="dd0f0-854">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>

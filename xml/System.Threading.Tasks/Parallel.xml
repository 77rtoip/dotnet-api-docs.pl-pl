<Type Name="Parallel" FullName="System.Threading.Tasks.Parallel">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="0ccd8e8796d91623d453ef299472d90582525e77" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36407714" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Parallel" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Parallel extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.Parallel" />
  <TypeSignature Language="VB.NET" Value="Public Class Parallel" />
  <TypeSignature Language="C++ CLI" Value="public ref class Parallel abstract sealed" />
  <TypeSignature Language="F#" Value="type Parallel = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Zapewnia obsługę pętle równoległe i regionów.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Parallel> Klasa udostępnia dane oparte na bibliotece równoległych elementy zastępcze typowych operacji takich jak pętle, dla każdej pętli i wykonywania zbiór instrukcji.  
  
   
  
## Examples  
 W tym przykładzie przedstawiono różne podejścia do wykonania pętli równoległej przy użyciu wielu konstrukcji języka.  
  
 [!code-csharp[System.Threading.Tasks.Parallel#07](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelintro.cs#07)]
 [!code-vb[System.Threading.Tasks.Parallel#07](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelintro.vb#07)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Wszystkie publiczne i chronione elementy członkowskie <see cref="T:System.Threading.Tasks.Parallel" /> są wątkowo i mogą być używane jednocześnie wiele wątków.</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName="For">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wykonuje <see langword="for" /> (<see langword="For" /> w języku Visual Basic) pętli, w którym iteracji może działać równolegle.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, Action&lt;int,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Action`2&lt;int32, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Action{System.Int32,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Integer, toExclusive As Integer, body As Action(Of Integer, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, Action&lt;int, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * Action&lt;int, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Indeks początkowy, włącznie.</param>
        <param name="toExclusive">Końcowy indeks, wyłącznego.</param>
        <param name="body">Delegat, które jest wywoływane raz na iterację.</param>
        <summary>Wykonuje <see langword="for" /> (<see langword="For" /> w języku Visual Basic) pętli, w którym iteracji może działać równolegle i monitorowania stanu pętli i manipulowanie.</summary>
        <returns>Struktura, która zawiera informacje o część pętlę ukończone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body` Delegata jest wywoływana raz dla każdej wartości w zakresie iteracji (`fromInclusive`, `toExclusive`). Są dostarczane z dwoma argumentami:  
  
-   <xref:System.Int32> Wartość, która reprezentuje liczby iteracji.  
  
-   A <xref:System.Threading.Tasks.ParallelLoopState> wystąpienia, który może służyć do przedwcześnie wyjścia z pętli. <xref:System.Threading.Tasks.ParallelLoopState> Obiekt jest tworzony przez kompilator; nie można utworzyć wystąpienia w kodzie użytkownika.  
  
 Wywoływanie <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> informuje metody `for` iteracji po bieżącym nie ma do wykonania operacji. Wszystkie iteracje przed bieżącą jedną będzie nadal jednak do wykonania, jeśli jeszcze tego nie.  
  
 W związku z tym wywołaniem <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> jest podobny do przy użyciu operacji podziału w ramach konwencjonalnej `for` , takich jak pętli w języku C#, ale nie jest idealne substitute: na przykład, nie ma żadnej gwarancji, że iteracji po bieżącym ostatecznie nie będzie wykonanie.  
  
 Jeśli wykonywania wszystkich iteracji, zanim bieżący nie jest konieczne, użyj <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> metody zamiast <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>. Wywoływanie <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> informuje o `for` pętli czy mogą porzucić wszystkie pozostałe iteracji, niezależnie od tego, czy są one przed lub po bieżącej iteracji, ponieważ wszystkie wymagane pracy będzie jeszcze zakończone. Jednak z <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>, nie ma żadnych gwarancji, wskazujące, którzy nie zostanie wykonany innych iteracji.  
  
 Jeśli pętla jest zakończył pracę przedwcześnie, <xref:System.Threading.Tasks.ParallelLoopResult> struktury, która jest zwracana będzie zawierać informacje dotyczące zakończenia pętli.  
  
 Jeśli `fromInclusive` jest większa niż lub równa `toExclusive`, metoda zwraca się natychmiast bez wykonywania żadnych iteracji.  
  
   
  
## Examples  
 Poniższy przykład wykonuje maksymalnie 100 iteracji pętli równolegle. Wstrzymuje każdej iteracji dla losowo wybranym interwałem z zakresu od 1 do 1000 milisekund. Określa losowo generowanej wartości, na które iteracji pętli <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> metoda jest wywoływana. Jako dane wyjściowe w przykładzie pokazano, nie iteracji, którego indeks jest większy niż <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A?displayProperty=nameWithType> początek wartości właściwości po wywołaniu <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> metody.  
  
 [!code-csharp[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/cs/break1.cs#2)]
 [!code-vb[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/vb/break1.vb#2)]  
  
 Ponieważ iteracji pętli są nadal mogą być wykonywane podczas <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> metoda jest wywoływana, wywołuje każdej iteracji <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A?displayProperty=nameWithType> właściwość do sprawdzenia, czy inny iteracji została wywołana <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> metody. Jeśli wartość właściwości jest `true`, iteracji sprawdza wartość <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A?displayProperty=nameWithType> właściwości i, jeśli jest większa niż wartość indeksu bieżącej iteracji, zwraca natychmiast.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="body" /> Argument jest <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątków zgłaszanych na wszystkie wątki.</exception>
        <altmember cref="T:System.Threading.Tasks.ParallelLoopState" />
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, Action&lt;int&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Action`1&lt;int32&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Action{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Integer, toExclusive As Integer, body As Action(Of Integer)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, Action&lt;int&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * Action&lt;int&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Indeks początkowy, włącznie.</param>
        <param name="toExclusive">Końcowy indeks, wyłącznego.</param>
        <param name="body">Delegat, które jest wywoływane raz na iterację.</param>
        <summary>Wykonuje <see langword="for" /> (<see langword="For" /> w języku Visual Basic) pętli, w którym iteracji może działać równolegle.</summary>
        <returns>Struktura, która zawiera informacje o część pętlę ukończone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body` Delegata jest wywoływana raz dla każdej wartości w zakresie iteracji (`fromInclusive`, `toExclusive`). Jest podana liczba iteracji (<xref:System.Int32>) jako parametr.  
  
 Jeśli `fromInclusive` jest większa niż lub równa `toExclusive`, metoda zwraca się natychmiast bez wykonywania żadnych iteracji.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Threading.Tasks.Parallel.For%2A> metodę 100 wywołania delegata, który generuje losowe bajtów wartości i oblicza sumę ich.  
  
 [!code-csharp[System.Threading.Tasks.Parallel.For#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel.for/cs/for1.cs#1)]
 [!code-vb[System.Threading.Tasks.Parallel.For#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel.for/vb/for1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="body" /> Argument jest <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątków zgłaszanych na wszystkie wątki.</exception>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, Action&lt;long,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Action`2&lt;int64, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Action{System.Int64,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Long, toExclusive As Long, body As Action(Of Long, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, Action&lt;long, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * Action&lt;int64, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Indeks początkowy, włącznie.</param>
        <param name="toExclusive">Końcowy indeks, wyłącznego.</param>
        <param name="body">Delegat, które jest wywoływane raz na iterację.</param>
        <summary>Wykonuje <see langword="for" /> (<see langword="For" /> w języku Visual Basic) pętli z indeksami 64-bitowych, w których iteracji może działać równolegle i monitorowania stanu pętli i manipulowanie.</summary>
        <returns>A <see cref="T:System.Threading.Tasks.ParallelLoopResult" /> strukturę, która zawiera informacje na temat jaka część pętlę ukończone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body` Delegata jest wywoływana raz dla każdej wartości w zakresie iteracji (`fromInclusive`, `toExclusive`). Znajduje się z następującymi parametrami: liczba iteracji (<xref:System.Int64>), a <xref:System.Threading.Tasks.ParallelLoopState> wystąpienia, który może służyć do przedwcześnie wyjścia z pętli.  
  
 Wywoływanie <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> informuje metody `for` operacji iteracji po bieżącej nie muszą być wykonywane, ale wszystkie iteracje przed bieżącym czy.  
  
 W związku z tym wywoływania przerwania jest podobny do przy użyciu operacji podziału w ramach konwencjonalnej `for` , takich jak pętli w języku C#, ale nie jest idealne substitute: na przykład, nie ma żadnej gwarancji tej iteracji po bieżącej zdecydowanie nie wykona.  
  
 Jeśli wykonywania wszystkich iteracji, zanim bieżący nie jest konieczne, użyj <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> metody zamiast <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>. Wywoływanie <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> informuje o `for` pętli czy mogą porzucić wszystkie pozostałe iteracji, niezależnie od tego, czy są one przed lub po bieżącej iteracji, ponieważ wszystkie wymagane pracy będzie jeszcze zakończone. Jednak z <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>, nie ma żadnych gwarancji, wskazujące, którzy nie zostanie wykonany innych iteracji.  
  
 Jeśli pętla jest zakończył pracę przedwcześnie, <xref:System.Threading.Tasks.ParallelLoopResult> struktury, która jest zwracana będzie zawierać informacje dotyczące zakończenia pętli.  
  
 Jeśli `fromInclusive` jest większa niż lub równa `toExclusive`, a następnie metoda zwraca się natychmiast bez wykonywania żadnych iteracji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="body" /> Argument jest <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątków zgłaszanych na wszystkie wątki.</exception>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, Action&lt;long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Action`1&lt;int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Action{System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Long, toExclusive As Long, body As Action(Of Long)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, Action&lt;long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * Action&lt;int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Indeks początkowy, włącznie.</param>
        <param name="toExclusive">Końcowy indeks, wyłącznego.</param>
        <param name="body">Delegat, które jest wywoływane raz na iterację.</param>
        <summary>Wykonuje <see langword="for" /> (<see langword="For" /> w języku Visual Basic) pętli z indeksami 64-bitowych, w których iteracji może być uruchamiane równolegle.</summary>
        <returns>Struktura, która zawiera informacje o część pętlę ukończone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body` Delegata jest wywoływana raz dla każdej wartości w zakresie iteracji (`fromInclusive`, `toExclusive`). Jest podana liczba iteracji (<xref:System.Int64>) jako parametr.  
  
 Jeśli `fromInclusive` jest większa niż lub równa `toExclusive`, metoda zwraca się natychmiast bez wykonywania żadnych iteracji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="body" /> Argument jest <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątków zgłaszanych na wszystkie wątki.</exception>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;int,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;int32, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Action{System.Int32,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;int, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * System.Threading.Tasks.ParallelOptions * Action&lt;int, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Indeks początkowy, włącznie.</param>
        <param name="toExclusive">Końcowy indeks, wyłącznego.</param>
        <param name="parallelOptions">Obiekt, który konfiguruje działanie tej operacji.</param>
        <param name="body">Delegat, które jest wywoływane raz na iterację.</param>
        <summary>Wykonuje <see langword="for" /> (<see langword="For" /> w języku Visual Basic) pętli w iteracji, które może działać równolegle, można skonfigurować opcje pętli i monitorowania stanu pętli i manipulowanie.</summary>
        <returns>Struktura, która zawiera informacje o część pętlę ukończone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body` Delegata jest wywoływana raz dla każdej wartości w zakresie iteracji (`fromInclusive`, `toExclusive`). Znajduje się z następującymi parametrami: liczba iteracji (<xref:System.Int32>), a <xref:System.Threading.Tasks.ParallelLoopState> wystąpienia, który może służyć do przedwcześnie wyjścia z pętli.  
  
 Jeśli `fromInclusive` jest większa niż lub równa `toExclusive`, metoda zwraca się natychmiast bez wykonywania żadnych iteracji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <see cref="T:System.Threading.CancellationToken" /> w <paramref name="parallelOptions" /> argument zostało anulowane.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="body" /> Argument jest <see langword="null" />.  - lub - <paramref name="parallelOptions" /> argument jest <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątków zgłaszanych na wszystkie wątki.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.CancellationTokenSource" /> Skojarzone z <see cref="T:System.Threading.CancellationToken" /> w <paramref name="parallelOptions" /> został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;int&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;int32&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Action{System.Int32})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;int&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * System.Threading.Tasks.ParallelOptions * Action&lt;int&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Indeks początkowy, włącznie.</param>
        <param name="toExclusive">Końcowy indeks, wyłącznego.</param>
        <param name="parallelOptions">Obiekt, który konfiguruje działanie tej operacji.</param>
        <param name="body">Delegat, które jest wywoływane raz na iterację.</param>
        <summary>Wykonuje <see langword="for" /> (<see langword="For" /> w języku Visual Basic) pętli, w którym iteracji może działać równolegle i można skonfigurować opcje pętli.</summary>
        <returns>Struktura, która zawiera informacje o część pętlę ukończone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body` Delegata jest wywoływana raz dla każdej wartości w zakresie iteracji (`fromInclusive`, `toExclusive`). Jest podana liczba iteracji (<xref:System.Int32>) jako parametr.  
  
 Jeśli `fromInclusive` jest większa niż lub równa `toExclusive`, a następnie metoda zwraca się natychmiast bez wykonywania żadnych iteracji.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób anulowanie równoległej pętli:  
  
 [!code-csharp[System.Threading.Tasks.Parallel#05](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelforcancel.cs#05)]
 [!code-vb[System.Threading.Tasks.Parallel#05](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelforcancel.vb#05)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <see cref="T:System.Threading.CancellationToken" /> w <paramref name="parallelOptions" /> argument zostało anulowane.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="body" /> Argument jest <see langword="null" />.  - lub - <paramref name="parallelOptions" /> argument jest <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątków zgłaszanych na wszystkie wątki.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.CancellationTokenSource" /> Skojarzone z <see cref="T:System.Threading.CancellationToken" /> w <paramref name="parallelOptions" /> został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;long,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;int64, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Action{System.Int64,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;long, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * System.Threading.Tasks.ParallelOptions * Action&lt;int64, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Indeks początkowy, włącznie.</param>
        <param name="toExclusive">Końcowy indeks, wyłącznego.</param>
        <param name="parallelOptions">Obiekt, który konfiguruje działanie tej operacji.</param>
        <param name="body">Delegat, które jest wywoływane raz na iterację.</param>
        <summary>Wykonuje <see langword="for" /> (<see langword="For" /> w języku Visual Basic) pętli z 64-bitowe indeksy w iteracji, które może działać równolegle, można skonfigurować opcje pętli i monitorowania stanu pętli i manipulowanie.</summary>
        <returns>Struktura, która zawiera informacje o część pętlę ukończone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body` Delegata jest wywoływana raz dla każdej wartości w zakresie iteracji (`fromInclusive`, `toExclusive`). Znajduje się z następującymi parametrami: liczba iteracji (<xref:System.Int64>), a <xref:System.Threading.Tasks.ParallelLoopState> wystąpienia, który może służyć do przedwcześnie wyjścia z pętli.  
  
 Jeśli `fromInclusive` jest większa niż lub równa `toExclusive`, metoda zwraca się natychmiast bez wykonywania żadnych iteracji.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> metody z <xref:System.Threading.Tasks.ParallelOptions> obiektu:  
  
 [!code-csharp[System.Threading.Tasks.Parallel#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelfor.cs#03)]
 [!code-vb[System.Threading.Tasks.Parallel#03](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelfor.vb#03)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <see cref="T:System.Threading.CancellationToken" /> w <paramref name="parallelOptions" /> argument zostało anulowane.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="body" /> Argument jest <see langword="null" />.  - lub - <paramref name="parallelOptions" /> argument jest <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątków zgłaszanych na wszystkie wątki.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.CancellationTokenSource" /> Skojarzone z <see cref="T:System.Threading.CancellationToken" /> w <paramref name="parallelOptions" /> został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Action{System.Int64})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * System.Threading.Tasks.ParallelOptions * Action&lt;int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">Indeks początkowy, włącznie.</param>
        <param name="toExclusive">Końcowy indeks, wyłącznego.</param>
        <param name="parallelOptions">Obiekt, który konfiguruje działanie tej operacji.</param>
        <param name="body">Delegat, które jest wywoływane raz na iterację.</param>
        <summary>Wykonuje <see langword="for" /> (<see langword="For" /> w języku Visual Basic) pętli z indeksami 64-bitowych, w których iteracji może działać równolegle i można skonfigurować opcje pętli.</summary>
        <returns>Struktura, która zawiera informacje o część pętlę ukończone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obsługuje 64-bitowe indeksy. `body` Delegata jest wywoływana raz dla każdej wartości w zakresie iteracji (`fromInclusive`, `toExclusive`). Jest podana liczba iteracji (<xref:System.Int64>) jako parametr.  
  
 Jeśli `fromInclusive` jest większa niż lub równa `toExclusive`, a następnie metoda zwraca się natychmiast bez wykonywania żadnych iteracji.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie <xref:System.Threading.Tasks.ParallelOptions> na określanie harmonogramu zadań niestandardowych:  
  
 [!code-csharp[System.Threading.Tasks.Parallel#06](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelforwithscheduler.cs#06)]
 [!code-vb[System.Threading.Tasks.Parallel#06](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelforwithscheduler.vb#06)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <see cref="T:System.Threading.CancellationToken" /> w <paramref name="parallelOptions" /> argument zostało anulowane.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="body" /> Argument jest <see langword="null" />.  - lub - <paramref name="parallelOptions" /> argument jest <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątków zgłaszanych na wszystkie wątki.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.CancellationTokenSource" /> Skojarzone z <see cref="T:System.Threading.CancellationToken" /> w <paramref name="parallelOptions" /> został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (int fromInclusive, int toExclusive, Func&lt;TLocal&gt; localInit, Func&lt;int,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int32 fromInclusive, int32 toExclusive, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int32, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int32,System.Int32,System.Func{``0},System.Func{System.Int32,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For(Of TLocal) (fromInclusive As Integer, toExclusive As Integer, localInit As Func(Of TLocal), body As Func(Of Integer, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, Func&lt;TLocal&gt; ^ localInit, Func&lt;int, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int * int * Func&lt;'Local&gt; * Func&lt;int, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int32,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal">Typ danych lokalnych wątku.</typeparam>
        <param name="fromInclusive">Indeks początkowy, włącznie.</param>
        <param name="toExclusive">Końcowy indeks, wyłącznego.</param>
        <param name="localInit">Delegat funkcji, która zwraca stan początkowy danych lokalnych dla każdego zadania.</param>
        <param name="body">Delegat, które jest wywoływane raz na iterację.</param>
        <param name="localFinally">Delegat, który wykonuje ostateczne działania na lokalnym stan każdego zadania.</param>
        <summary>Wykonuje <see langword="for" /> (<see langword="For" /> w języku Visual Basic) pętli z danymi lokalnymi wątku, w którym iteracji może działać równolegle i monitorowania stanu pętli i manipulowanie.</summary>
        <returns>Struktura, która zawiera informacje o część pętlę ukończone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body` Delegata jest wywoływana raz dla każdej wartości w zakresie iteracji (`fromInclusive`, `toExclusive`). Znajduje się z następującymi parametrami: liczba iteracji (<xref:System.Int32>), <xref:System.Threading.Tasks.ParallelLoopState> wystąpienia, który może służyć do wyjścia z pętli przedwcześnie i niektóre stanu lokalnego, który może być udostępniana między iteracji, które są wykonywane na tym samym wątku.  
  
 `localInit` Delegata jest wywoływana raz dla każdego zadania, które uczestniczy w wykonywania pętli i zwraca stan początkowy lokalnego dla każdego z tych zadań. Te stany początkowej są przekazywane do pierwszej `body` wywołania dla każdego zadania. Co wywołanie treści kolejnych zwraca wartość stanu prawdopodobnie modyfikacji przekazywany do następnego wywołania treści. Na koniec ostatniego wywołania treści dla każdego zadania zwraca wartość stanu, który jest przekazywany do `localFinally` delegowanie. `localFinally` Delegata jest wywoływana raz na zadanie do wykonania akcji końcowego na stan lokalnego każdego zadania. Ten delegat może wywołać jednocześnie na wielu zadań; w związku z tym należy zsynchronizować dostęp do zmiennych udostępnionego.  
  
 <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> Metoda może używać zadania więcej niż wątków w okresie istnienia działania jako ukończone istniejącego zadania i zostały zastąpione przez nowe zadania. Dzięki temu odpowiadającego <xref:System.Threading.Tasks.TaskScheduler> obiekt możliwość dodawania, zmieniania lub usuwania wątków, które usługa pętli.  
  
 Jeśli `fromInclusive` jest większa niż lub równa `toExclusive`, a następnie metoda zwraca się natychmiast bez wykonywania żadnych iteracji.  
  
 Na przykład, który używa tej metody, zobacz [porady: zapisywanie równoległej pętli for ze zmiennymi lokalnymi wątku](~/docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="body" /> Argument jest <see langword="null" />.  - lub - <paramref name="localInit" /> argument jest <see langword="null" />.  - lub - <paramref name="localFinally" /> argument jest <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątków zgłaszanych na wszystkie wątki.</exception>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (long fromInclusive, long toExclusive, Func&lt;TLocal&gt; localInit, Func&lt;long,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int64 fromInclusive, int64 toExclusive, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int64, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int64,System.Int64,System.Func{``0},System.Func{System.Int64,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For(Of TLocal) (fromInclusive As Long, toExclusive As Long, localInit As Func(Of TLocal), body As Func(Of Long, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, Func&lt;TLocal&gt; ^ localInit, Func&lt;long, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * Func&lt;'Local&gt; * Func&lt;int64, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int64,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal">Typ danych lokalnych wątku.</typeparam>
        <param name="fromInclusive">Indeks początkowy, włącznie.</param>
        <param name="toExclusive">Końcowy indeks, wyłącznego.</param>
        <param name="localInit">Delegat funkcji, która zwraca stan początkowy danych lokalnych dla każdego zadania.</param>
        <param name="body">Delegat, które jest wywoływane raz na iterację.</param>
        <param name="localFinally">Delegat, który wykonuje ostateczne działania na lokalnym stan każdego zadania.</param>
        <summary>Wykonuje <see langword="for" /> (<see langword="For" /> w języku Visual Basic) pętli z 64-bitowe indeksy i danymi lokalnymi wątku w którym iteracji może działać równolegle i monitorowania stanu pętli i manipulowanie.</summary>
        <returns>Struktura, która zawiera informacje o część pętlę ukończone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body` Delegata jest wywoływana raz dla każdej wartości w zakresie iteracji (`fromInclusive`, `toExclusive`). Znajduje się z następującymi parametrami: liczba iteracji (<xref:System.Int64>), <xref:System.Threading.Tasks.ParallelLoopState> wystąpienia, który może służyć do wyjścia z pętli przedwcześnie i niektóre stan lokalnego, który może być udostępniana między iteracji, które są wykonywane na tym samym zadaniem.  
  
 `localInit` Delegata jest wywoływana raz dla każdego zadania, które uczestniczy w wykonywania pętli i zwraca stan początkowy lokalnego dla każdego z tych zadań. Te stany początkowej są przekazywane do pierwszej `body` wywołania dla każdego zadania. Co wywołanie treści kolejnych zwraca wartość stanu prawdopodobnie modyfikacji przekazywany do następnego wywołania treści. Na koniec ostatniego wywołania treści dla każdego zadania zwraca wartość stanu, który jest przekazywany do `localFinally` delegowanie. `localFinally` Delegata jest wywoływana raz na zadanie do wykonania akcji końcowego na stan lokalnego każdego zadania. Ten delegat może wywołać jednocześnie na wielu zadań; w związku z tym należy zsynchronizować dostęp do zmiennych udostępnionego.  
  
 <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> Metoda może używać zadania więcej niż wątków w okresie istnienia działania jako ukończone istniejącego zadania i zostały zastąpione przez nowe zadania. Dzięki temu odpowiadającego <xref:System.Threading.Tasks.TaskScheduler> obiekt możliwość dodawania, zmieniania lub usuwania wątków, które usługa pętli.  
  
 Jeśli `fromInclusive` jest większa niż lub równa `toExclusive`, a następnie metoda zwraca się natychmiast bez wykonywania żadnych iteracji.  
  
 Na przykład, który używa tej metody, zobacz [porady: zapisywanie równoległej pętli for ze zmiennymi lokalnymi wątku](~/docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="body" /> Argument jest <see langword="null" />.  - lub - <paramref name="localInit" /> argument jest <see langword="null" />.  - lub - <paramref name="localFinally" /> argument jest <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątków zgłaszanych na wszystkie wątki.</exception>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (int fromInclusive, int toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;int,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int32 fromInclusive, int32 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int32, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Func{``0},System.Func{System.Int32,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;int, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int * int * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;int, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int32,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal">Typ danych lokalnych wątku.</typeparam>
        <param name="fromInclusive">Indeks początkowy, włącznie.</param>
        <param name="toExclusive">Końcowy indeks, wyłącznego.</param>
        <param name="parallelOptions">Obiekt, który konfiguruje działanie tej operacji.</param>
        <param name="localInit">Delegat funkcji, która zwraca stan początkowy danych lokalnych dla każdego zadania.</param>
        <param name="body">Delegat, które jest wywoływane raz na iterację.</param>
        <param name="localFinally">Delegat, który wykonuje ostateczne działania na lokalnym stan każdego zadania.</param>
        <summary>Wykonuje <see langword="for" /> (<see langword="For" /> w języku Visual Basic) pętli z danymi lokalnymi wątku, w których iteracji może działać równolegle, można skonfigurować opcje pętli i monitorowania stanu pętli i manipulowanie.</summary>
        <returns>Struktura, która zawiera informacje o część pętlę ukończone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body` Delegata jest wywoływana raz dla każdej wartości w zakresie iteracji (`fromInclusive`, `toExclusive`). Znajduje się z następującymi parametrami: liczba iteracji (<xref:System.Int32>), <xref:System.Threading.Tasks.ParallelLoopState> wystąpienia, który może służyć do wyjścia z pętli przedwcześnie i niektóre stan lokalnego, który może być udostępniana między iteracji, które są wykonywane na tym samym zadaniem.  
  
 `localInit` Delegata jest wywoływana raz dla każdego zadania, które uczestniczy w wykonywania pętli i zwraca stan początkowy lokalnego dla każdego z tych zadań. Te stany początkowej są przekazywane do pierwszej `body` wywołania dla każdego zadania. Co wywołanie treści kolejnych zwraca wartość stanu prawdopodobnie modyfikacji przekazywany do następnego wywołania treści. Na koniec ostatniego wywołania treści dla każdego zadania zwraca wartość stanu, który jest przekazywany do `localFinally` delegowanie. `localFinally` Delegata jest wywoływana raz na zadanie do wykonania akcji końcowego na stan lokalnego każdego zadania. Ten delegat może wywołać jednocześnie na wielu wątków; w związku z tym należy zsynchronizować dostęp do zmiennych udostępnionego.  
  
 <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> Metoda może używać zadania więcej niż wątków w okresie istnienia działania jako ukończone istniejącego zadania i zostały zastąpione przez nowe zadania. Dzięki temu odpowiadającego <xref:System.Threading.Tasks.TaskScheduler> obiekt możliwość dodawania, zmieniania lub usuwania wątków, które usługa pętli.  
  
 Jeśli `fromInclusive` jest większa niż lub równa `toExclusive`, a następnie metoda zwraca się natychmiast bez wykonywania żadnych iteracji.  
  
   
  
## Examples  
 W poniższym przykładzie użyto zmiennych thread-local można obliczyć sumę wyniki wiele długich operacji. W tym przykładzie ogranicza stopień równoległości cztery.  
  
 [!code-csharp[System.Threading.Tasks.Parallel#04](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/threadlocalforwithoptions.cs#04)]
 [!code-vb[System.Threading.Tasks.Parallel#04](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/threadlocalforwithoptions.vb#04)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="body" /> Argument jest <see langword="null" />.  - lub - <paramref name="localInit" /> argument jest <see langword="null" />.  - lub - <paramref name="localFinally" /> argument jest <see langword="null" />.  - lub - <paramref name="parallelOptions" /> argument jest <see langword="null" />.</exception>
        <exception cref="T:System.OperationCanceledException">
          <see cref="T:System.Threading.CancellationToken" /> w <paramref name="parallelOptions" /> argument zostało anulowane.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.CancellationTokenSource" /> Skojarzone z <see cref="T:System.Threading.CancellationToken" /> w <paramref name="parallelOptions" /> został usunięty.</exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątków zgłaszanych na wszystkie wątki.</exception>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (long fromInclusive, long toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;long,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int64 fromInclusive, int64 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int64, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Func{``0},System.Func{System.Int64,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;long, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;int64, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int64,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal">Typ danych lokalnych wątku.</typeparam>
        <param name="fromInclusive">Indeks początkowy, włącznie.</param>
        <param name="toExclusive">Końcowy indeks, wyłącznego.</param>
        <param name="parallelOptions">Obiekt, który konfiguruje działanie tej operacji.</param>
        <param name="localInit">Delegat funkcji, która zwraca dane lokalne dla każdego wątku stanu początkowego.</param>
        <param name="body">Delegat, które jest wywoływane raz na iterację.</param>
        <param name="localFinally">Delegat, który wykonuje czynność końcowego na stan lokalnego każdy wątek.</param>
        <summary>Wykonuje <see langword="for" /> (<see langword="For" /> w języku Visual Basic) z 64-bitowe indeksy w pętli i danych lokalnej wątku, w którym iteracji może działać równolegle, można skonfigurować opcje pętli i monitorowania stanu pętli i manipulowanie.</summary>
        <returns>Struktura, która zawiera informacje o część pętlę ukończone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body` Delegata jest wywoływana raz dla każdej wartości w zakresie iteracji (`fromInclusive`, `toExclusive`). Znajduje się z następującymi parametrami: liczba iteracji (<xref:System.Int64>), <xref:System.Threading.Tasks.ParallelLoopState> wystąpienia, który może służyć do wyjścia z pętli przedwcześnie i niektóre stanu lokalnego, który może być udostępniana między iteracji, które są wykonywane na tym samym wątku.  
  
 `localInit` Delegata jest wywoływana raz dla każdego wątku, który uczestniczy w wykonywania pętli i zwraca stan początkowy lokalnego dla każdego z tych wątków. Te stany początkowej są przekazywane do pierwszej `body` wywołań w każdym wątku. Co wywołanie treści kolejnych zwraca wartość stanu prawdopodobnie modyfikacji przekazywany do następnego wywołania treści. Na koniec ostatniego wywołania treści na każdy wątek zwraca wartość stanu, który jest przekazywany do `localFinally` delegowanie. `localFinally` Delegata jest wywoływana raz na wątku w celu wykonania akcji końcowego na stan lokalnego dla każdego wątku. Ten delegat może wywołać jednocześnie na wielu wątków; w związku z tym należy zsynchronizować dostęp do zmiennych udostępnionego.  
  
 <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> Metoda może używać zadania więcej niż wątków w okresie istnienia działania jako ukończone istniejącego zadania i zostały zastąpione przez nowe zadania. Dzięki temu odpowiadającego <xref:System.Threading.Tasks.TaskScheduler> obiekt możliwość dodawania, zmieniania lub usuwania wątków, które usługa pętli.  
  
 Jeśli `fromInclusive` jest większa niż lub równa `toExclusive`, a następnie metoda zwraca się natychmiast bez wykonywania żadnych iteracji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="body" /> Argument jest <see langword="null" />.  - lub - <paramref name="localInit" /> argument jest <see langword="null" />.  - lub - <paramref name="localFinally" /> argument jest <see langword="null" />.  - lub - <paramref name="parallelOptions" /> argument jest <see langword="null" />.</exception>
        <exception cref="T:System.OperationCanceledException">
          <see cref="T:System.Threading.CancellationToken" /> w <paramref name="parallelOptions" /> argument zostało anulowane.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.CancellationTokenSource" /> Skojarzone z <see cref="T:System.Threading.CancellationToken" /> w <paramref name="parallelOptions" /> został usunięty.</exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątków zgłaszanych na wszystkie wątki.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ForEach&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wykonuje <see langword="foreach" /> (<see langword="For Each " /> w języku Visual Basic) operacji, w którym iteracji może działać równolegle.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.OrderablePartitioner{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As OrderablePartitioner(Of TSource), body As Action(Of TSource, ParallelLoopState, Long)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów w <c>źródła</c>.</typeparam>
        <param name="source">Prędkości partycjonerem, który zawiera oryginalnego źródła danych.</param>
        <param name="body">Delegat, które jest wywoływane raz na iterację.</param>
        <summary>Wykonuje <see langword="foreach" /> (<see langword="For Each" /> w języku Visual Basic) operacji na <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> w którym iteracji może działać równolegle i monitorowania stanu pętli i manipulowanie.</summary>
        <returns>Struktura, która zawiera informacje o część pętlę ukończone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie jest dostępna dla scenariuszy, w której chcesz przesłonić domyślny schemat partycjonowania. Na przykład małych jednostek pętli mogą korzystać z partycjonowania zakresu. <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Metoda oczekuje niestandardowe partycjonery, aby obsługiwać partycjonowanie dynamiczne. Aby uzyskać więcej informacji, zobacz [niestandardowe Partycjonery dla PLINQ i TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) i [porady: Implementowanie partycji dynamicznych](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> Argument jest <see langword="null" />.  - lub - <paramref name="body" /> argument jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> Właściwości w <paramref name="source" /> zwraca prędkości partycjonera <see langword="false" />.  - lub - <see cref="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysNormalized" /> właściwość w partycjonera prędkości źródła zwraca <see langword="false" />.  - lub - zwracać żadnych metod w partycjonera prędkości źródła <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As Partitioner(Of TSource), body As Action(Of TSource, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów w <c>źródła</c>.</typeparam>
        <param name="source">Partycjonerem, który zawiera oryginalnego źródła danych.</param>
        <param name="body">Delegat, które jest wywoływane raz na iterację.</param>
        <summary>Wykonuje <see langword="foreach" /> (<see langword="For Each" /> w języku Visual Basic) operacji na <see cref="T:System.Collections.Concurrent.Partitioner" /> której iteracji może działać równolegle, a stan pętli podlegający monitorowaniu i wykonywać na nich operacji.</summary>
        <returns>Struktura, która zawiera informacje o część pętlę ukończone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie jest dostępna dla scenariuszy, w której chcesz przesłonić domyślny schemat partycjonowania. Na przykład małych jednostek pętli mogą korzystać z partycjonowania zakresu. <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Metoda oczekuje niestandardowe partycjonery, aby obsługiwać partycjonowanie dynamiczne. Aby uzyskać więcej informacji, zobacz [niestandardowe Partycjonery dla PLINQ i TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) i [porady: Implementowanie partycji dynamicznych](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> Argument jest <see langword="null" />.  - lub - <paramref name="body" /> argument jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> Właściwości w <paramref name="source" /> zwraca obiekt partitioner <see langword="false" />.  - lub - metody w <paramref name="source" /> zwraca obiekt partitioner <see langword="null" />.  - lub - <see cref="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)" /> metody w <paramref name="source" /> partycjoner zwrócił nieprawidłową liczbę partycji.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As Partitioner(Of TSource), body As Action(Of TSource)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów w <c>źródła</c>.</typeparam>
        <param name="source">Partycjonerem, który zawiera oryginalnego źródła danych.</param>
        <param name="body">Delegat, które jest wywoływane raz na iterację.</param>
        <summary>Wykonuje <see langword="foreach" /> (<see langword="For Each" /> w języku Visual Basic) operacji na <see cref="T:System.Collections.Concurrent.Partitioner" /> w iteracji, które może działać równolegle.</summary>
        <returns>Struktura, która zawiera informacje o część pętlę ukończone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie jest dostępna dla scenariuszy, w której chcesz przesłonić domyślny schemat partycjonowania. Na przykład małych jednostek pętli mogą korzystać z partycjonowania zakresu. <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Metoda oczekuje niestandardowe partycjonery, aby obsługiwać partycjonowanie dynamiczne. Aby uzyskać więcej informacji, zobacz [niestandardowe Partycjonery dla PLINQ i TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) i [porady: Implementowanie partycji dynamicznych](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób Implementowanie partycjonera zakresu do używania z <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>:  
  
 [!code-csharp[System.Threading.Tasks.Parallel_RangePartitioners#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel_rangepartitioners/cs/rangepartitioner.cs#01)]
 [!code-vb[System.Threading.Tasks.Parallel_RangePartitioners#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel_rangepartitioners/vb/rangepart.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> Argument jest <see langword="null" />.  - lub - <paramref name="body" /> argument jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> Właściwości w <paramref name="source" /> zwraca obiekt partitioner <see langword="false" />.  - lub - wyjątek zgłaszany, gdy wszystkie metody w <paramref name="source" /> partycjonera zwrotu <see langword="null" />.  - lub - <see cref="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)" /> metody w <paramref name="source" /> partycjoner zwrócił nieprawidłową liczbę partycji.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As IEnumerable(Of TSource), body As Action(Of TSource, ParallelLoopState, Long)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ danych w źródle.</typeparam>
        <param name="source">Źródło danych wyliczenia.</param>
        <param name="body">Delegat, które jest wywoływane raz na iterację.</param>
        <summary>Wykonuje <see langword="foreach" /> (<see langword="For Each" /> w języku Visual Basic) operację z 64-bitowe indeksy na <see cref="T:System.Collections.IEnumerable" /> której iteracji może działać równolegle, a stan pętli podlegający monitorowaniu i wykonywać na nich operacji.</summary>
        <returns>Struktura, która zawiera informacje o część pętlę ukończone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body` Delegata jest wywoływana raz dla każdego elementu w `source` wyliczalny. Znajduje się z następującymi parametrami: bieżący element <xref:System.Threading.Tasks.ParallelLoopState> wystąpienia, który może służyć do wyjścia z pętli przedwcześnie i indeks bieżącego elementu (<xref:System.Int64>).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> Argument jest <see langword="null" />.  - lub - <paramref name="body" /> argument jest <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątków zgłaszanych na wszystkie wątki.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As IEnumerable(Of TSource), body As Action(Of TSource, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ danych w źródle.</typeparam>
        <param name="source">Źródło danych wyliczenia.</param>
        <param name="body">Delegat, które jest wywoływane raz na iterację.</param>
        <summary>Wykonuje <see langword="foreach" /> (<see langword="For Each" /> w języku Visual Basic) operacji na <see cref="T:System.Collections.IEnumerable" /> której iteracji może działać równolegle, a stan pętli podlegający monitorowaniu i wykonywać na nich operacji.</summary>
        <returns>Struktura, która zawiera informacje o część pętlę ukończone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body` Delegata jest wywoływana raz dla każdego elementu w `source` wyliczalny. Znajduje się z następującymi parametrami: bieżący element i <xref:System.Threading.Tasks.ParallelLoopState> wystąpienia, który może służyć do przedwcześnie wyjścia z pętli.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> Argument jest <see langword="null" />.  - lub - <paramref name="body" /> argument jest <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątków zgłaszanych na wszystkie wątki.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As IEnumerable(Of TSource), body As Action(Of TSource)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ danych w źródle.</typeparam>
        <param name="source">Źródło danych wyliczenia.</param>
        <param name="body">Delegat, które jest wywoływane raz na iterację.</param>
        <summary>Wykonuje <see langword="foreach" /> (<see langword="For Each" /> w języku Visual Basic) operacji na <see cref="T:System.Collections.IEnumerable" /> w iteracji, które może działać równolegle.</summary>
        <returns>Struktura, która zawiera informacje o część pętlę ukończone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body` Delegata jest wywoływana raz dla każdego elementu w `source` wyliczalny. Z bieżącego elementu jest podana jako parametr.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Threading.Tasks.Parallel.ForEach%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Action%7B%60%600%7D%29> metodę, aby określić liczbę samogłoski i inny niż odstęp w pliku tekstowym. W takim przypadku <xref:System.Threading.Tasks.ParallelLoopResult> wartość zwrócona przez metodę jest ignorowana. Należy pamiętać, że ponieważ operacje można uruchomić równolegle, musisz zapewnić, że zmienne licznik zwiększany jest operacją niepodzielną, i wiele wątków nie próbuj uzyskać jednocześnie dostęp do zmiennych licznika. W tym celu w przykładzie użyto `lock` instrukcji (w języku C#) i `SyncLock` instrukcji (w języku Visual Basic).  
  
 [!code-csharp[System.Threading.Tasks.Parallel.ForEach#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel.foreach/cs/foreach1.cs#1)]
 [!code-vb[System.Threading.Tasks.Parallel.ForEach#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel.foreach/vb/foreach1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> Argument jest <see langword="null" />.  - lub - <paramref name="body" /> argument jest <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątków zgłaszanych na wszystkie wątki.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.OrderablePartitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów w <c>źródła</c>.</typeparam>
        <param name="source">Prędkości partycjonerem, który zawiera oryginalnego źródła danych.</param>
        <param name="parallelOptions">Obiekt, który konfiguruje działanie tej operacji.</param>
        <param name="body">Delegat, które jest wywoływane raz na iterację.</param>
        <summary>Wykonuje <see langword="foreach" /> (<see langword="For Each" /> w języku Visual Basic) operacji na <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> w iteracji, które może działać równolegle, można skonfigurować opcje pętli i monitorowania stanu pętli i manipulowanie.</summary>
        <returns>Struktura, która zawiera informacje o część pętlę ukończone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie jest dostępna dla scenariuszy, w której chcesz przesłonić domyślny schemat partycjonowania. Na przykład małych jednostek pętli mogą korzystać z partycjonowania zakresu. <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Metoda oczekuje niestandardowe partycjonery, aby obsługiwać partycjonowanie dynamiczne. Aby uzyskać więcej informacji, zobacz [niestandardowe Partycjonery dla PLINQ i TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) i [porady: Implementowanie partycji dynamicznych](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <see cref="T:System.Threading.CancellationToken" /> w <paramref name="parallelOptions" /> argument zostało anulowane.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> Argument jest <see langword="null" />.  - lub - <paramref name="parallelOptions" /> argument jest <see langword="null" />.  - lub - <paramref name="body" /> argument jest <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.CancellationTokenSource" /> Skojarzone z <see cref="T:System.Threading.CancellationToken" /> w <paramref name="parallelOptions" /> został usunięty.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> Właściwości w <paramref name="source" /> zwraca prędkości partycjonera <see langword="false" />.  - lub - <see cref="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysNormalized" /> właściwości w <paramref name="source" /> zwraca prędkości partycjonera <see langword="false" />.  - lub - wyjątek zgłaszany, gdy wszystkie metody w <paramref name="source" /> prędkości partycjonera zwrotu <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów w <c>źródła</c>.</typeparam>
        <param name="source">Partycjonerem, który zawiera oryginalnego źródła danych.</param>
        <param name="parallelOptions">Obiekt, który konfiguruje działanie tej operacji.</param>
        <param name="body">Delegat, które jest wywoływane raz na iterację.</param>
        <summary>Wykonuje <see langword="foreach" /> (<see langword="For Each" /> w języku Visual Basic) operacji na <see cref="T:System.Collections.Concurrent.Partitioner" /> w iteracji, które może działać równolegle, można skonfigurować opcje pętli i monitorowania stanu pętli i manipulowanie.</summary>
        <returns>Struktura, która zawiera informacje o część pętlę ukończone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie jest dostępna dla scenariuszy, w której chcesz przesłonić domyślny schemat partycjonowania. Na przykład małych jednostek pętli mogą korzystać z partycjonowania zakresu. <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Metoda oczekuje niestandardowe partycjonery, aby obsługiwać partycjonowanie dynamiczne. Aby uzyskać więcej informacji, zobacz [niestandardowe Partycjonery dla PLINQ i TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) i [porady: Implementowanie partycji dynamicznych](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <see cref="T:System.Threading.CancellationToken" /> w <paramref name="parallelOptions" /> argument zostało anulowane.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.CancellationTokenSource" /> Skojarzone z <see cref="T:System.Threading.CancellationToken" /> w <paramref name="parallelOptions" /> został usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> Argument jest <see langword="null" />.  - lub - <paramref name="parallelOptions" /> argument jest <see langword="null" />.  - lub - <paramref name="body" /> argument jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> Właściwości w <paramref name="source" /> zwraca obiekt partitioner <see langword="false" />.  - lub - wyjątek zgłaszany, gdy wszystkie metody w <paramref name="source" /> partycjonera zwrotu <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów w <c>źródła</c>.</typeparam>
        <param name="source">Partycjonerem, który zawiera oryginalnego źródła danych.</param>
        <param name="parallelOptions">Obiekt, który konfiguruje działanie tej operacji.</param>
        <param name="body">Delegat, które jest wywoływane raz na iterację.</param>
        <summary>Wykonuje <see langword="foreach" /> (<see langword="For Each" /> w języku Visual Basic) operacji na <see cref="T:System.Collections.Concurrent.Partitioner" /> w którym iteracji może działać równolegle i można skonfigurować opcje pętli.</summary>
        <returns>Struktura, która zawiera informacje o część pętlę ukończone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie jest dostępna dla scenariuszy, w której chcesz przesłonić domyślny schemat partycjonowania. Na przykład małych jednostek pętli mogą korzystać z partycjonowania zakresu. <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Metoda oczekuje niestandardowe partycjonery, aby obsługiwać partycjonowanie dynamiczne. Aby uzyskać więcej informacji, zobacz [niestandardowe Partycjonery dla PLINQ i TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) i [porady: Implementowanie partycji dynamicznych](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <see cref="T:System.Threading.CancellationToken" /> w <paramref name="parallelOptions" /> argument zostało anulowane.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.CancellationTokenSource" /> Skojarzone z <see cref="T:System.Threading.CancellationToken" /> w <paramref name="parallelOptions" /> został usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> Argument jest <see langword="null" />.  - lub - <paramref name="parallelOptions" /> argument jest <see langword="null" />.  - lub - <paramref name="body" /> argument jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> Właściwości w <paramref name="source" /> zwraca obiekt partitioner <see langword="false" />.  - lub - wyjątek zgłaszany, gdy wszystkie metody w <paramref name="source" /> partycjonera zwrotu <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ danych w źródle.</typeparam>
        <param name="source">Źródło danych wyliczenia.</param>
        <param name="parallelOptions">Obiekt, który konfiguruje działanie tej operacji.</param>
        <param name="body">Delegat, które jest wywoływane raz na iterację.</param>
        <summary>Wykonuje <see langword="foreach" /> (<see langword="For Each" /> w języku Visual Basic) operację z 64-bitowe indeksy na <see cref="T:System.Collections.IEnumerable" /> w iteracji, które może działać równolegle, można skonfigurować opcje pętli i monitorowania stanu pętli i manipulowanie.</summary>
        <returns>Struktura, która zawiera informacje o część pętlę ukończone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body` Delegata jest wywoływana raz dla każdego elementu w `source` wyliczalny. Znajduje się z następującymi parametrami: bieżący element <xref:System.Threading.Tasks.ParallelLoopState> wystąpienia, który może służyć do wyjścia z pętli przedwcześnie i indeks bieżącego elementu (<xref:System.Int64>).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <see cref="T:System.Threading.CancellationToken" /> w <paramref name="parallelOptions" /> argument zostało anulowane.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> Argument jest <see langword="null" />.  - lub - <paramref name="parallelOptions" /> argument jest <see langword="null" />.  - lub - <paramref name="body" /> argument jest <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątków zgłaszanych na wszystkie wątki.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.CancellationTokenSource" /> Skojarzone z <see cref="T:System.Threading.CancellationToken" /> w <paramref name="parallelOptions" /> został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ danych w źródle.</typeparam>
        <param name="source">Źródło danych wyliczenia.</param>
        <param name="parallelOptions">Obiekt, który konfiguruje działanie tej operacji.</param>
        <param name="body">Delegat, które jest wywoływane raz na iterację.</param>
        <summary>Wykonuje <see langword="foreach" /> (<see langword="For Each" /> w języku Visual Basic) operacji na <see cref="T:System.Collections.IEnumerable" /> w iteracji, które może działać równolegle, można skonfigurować opcje pętli i monitorowania stanu pętli i manipulowanie.</summary>
        <returns>Struktura, która zawiera informacje o część pętlę ukończone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body` Delegata jest wywoływana raz dla każdego elementu w `source` wyliczalny. Znajduje się z następującymi parametrami: bieżący element i <xref:System.Threading.Tasks.ParallelLoopState> wystąpienia, który może służyć do przedwcześnie wyjścia z pętli.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <see cref="T:System.Threading.CancellationToken" /> w <paramref name="parallelOptions" /> argument zostało anulowane.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> Argument jest <see langword="null" />.  - lub - <paramref name="parallelOptions" /> argument jest <see langword="null" />.  - lub - <paramref name="body" /> argument jest <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątków zgłaszanych na wszystkie wątki.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.CancellationTokenSource" /> Skojarzone z <see cref="T:System.Threading.CancellationToken" /> w <paramref name="parallelOptions" /> został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ danych w źródle.</typeparam>
        <param name="source">Źródło danych wyliczenia.</param>
        <param name="parallelOptions">Obiekt, który konfiguruje działanie tej operacji.</param>
        <param name="body">Delegat, które jest wywoływane raz na iterację.</param>
        <summary>Wykonuje <see langword="foreach" /> (<see langword="For Each" /> w języku Visual Basic) operacji na <see cref="T:System.Collections.IEnumerable" /> w którym iteracji może działać równolegle i można skonfigurować opcje pętli.</summary>
        <returns>Struktura, która zawiera informacje o część pętlę ukończone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body` Delegata jest wywoływana raz dla każdego elementu w `source` wyliczalny. Z bieżącego elementu jest podana jako parametr.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <see cref="T:System.Threading.CancellationToken" /> w <paramref name="parallelOptions" /> argument zostało anulowane.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> Argument jest <see langword="null" />.  - lub - <paramref name="parallelOptions" /> argument jest <see langword="null" />.  - lub - <paramref name="body" /> argument jest <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątków zgłaszanych na wszystkie wątki.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.CancellationTokenSource" /> Skojarzone z <see cref="T:System.Threading.CancellationToken" /> w <paramref name="parallelOptions" /> został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.OrderablePartitioner{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As OrderablePartitioner(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, Long, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów w <c>źródła</c>.</typeparam>
        <typeparam name="TLocal">Typ danych lokalnych wątku.</typeparam>
        <param name="source">Prędkości partycjonerem, który zawiera oryginalnego źródła danych.</param>
        <param name="localInit">Delegat funkcji, która zwraca stan początkowy danych lokalnych dla każdego zadania.</param>
        <param name="body">Delegat, które jest wywoływane raz na iterację.</param>
        <param name="localFinally">Delegat, który wykonuje ostateczne działania na lokalnym stan każdego zadania.</param>
        <summary>Wykonuje <see langword="foreach" /> (<see langword="For Each" /> w języku Visual Basic) operacji z danymi lokalnymi wątku na <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> w iteracji, które może działać równolegle, można skonfigurować opcje pętli i monitorowania stanu pętli i manipulowanie.</summary>
        <returns>Struktura, która zawiera informacje o część pętlę ukończone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie jest dostępna dla scenariuszy, w której chcesz przesłonić domyślny schemat partycjonowania. Na przykład małych jednostek pętli mogą korzystać z partycjonowania zakresu. <xref:System.Threading.Tasks.Parallel.ForEach%2A> Metoda oczekuje niestandardowe partycjonery, aby obsługiwać partycjonowanie dynamiczne. Aby uzyskać więcej informacji, zobacz [niestandardowe Partycjonery dla PLINQ i TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) i [porady: Implementowanie partycji dynamicznych](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 `localInit` Delegata jest wywoływana raz dla każdego zadania, które uczestniczy w wykonywania pętli i zwraca stan początkowy lokalnego dla każdego z tych zadań. Te stany początkowej są przekazywane do pierwszej `body` wywołania dla każdego zadania. Co wywołanie treści kolejnych zwraca wartość stanu prawdopodobnie modyfikacji przekazywany do następnego wywołania treści. Na koniec ostatniego wywołania treści dla każdego zadania zwraca wartość stanu, który jest przekazywany do `localFinally` delegowanie. `localFinally` Delegata jest wywoływana raz na zadanie do wykonania akcji końcowego na stan lokalnego każdego zadania. Ten delegat może wywołać jednocześnie na wielu zadań; w związku z tym należy zsynchronizować dostęp do zmiennych udostępnionego.  
  
 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Metoda może używać zadania więcej niż wątków w okresie istnienia działania jako ukończone istniejącego zadania i zostały zastąpione przez nowe zadania. Dzięki temu odpowiadającego <xref:System.Threading.Tasks.TaskScheduler> obiekt możliwość dodawania, zmieniania lub usuwania wątków, które usługa pętli.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> Argument jest <see langword="null" />.  - lub - <paramref name="body" /> argument jest <see langword="null" />.  - lub - <paramref name="localInit" /> argument jest <see langword="null" />.  - lub - <paramref name="localFinally" /> argument jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> Właściwości w <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> zwraca <see langword="false" /> lub zwraca obiekt partitioner <see langword="null" /> partycji.</exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątków zgłaszanych na wszystkie wątki.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.Partitioner{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As Partitioner(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów w <c>źródła</c>.</typeparam>
        <typeparam name="TLocal">Typ danych lokalnych wątku.</typeparam>
        <param name="source">Partycjonerem, który zawiera oryginalnego źródła danych.</param>
        <param name="localInit">Delegat funkcji, która zwraca stan początkowy danych lokalnych dla każdego zadania.</param>
        <param name="body">Delegat, które jest wywoływane raz na iterację.</param>
        <param name="localFinally">Delegat, który wykonuje ostateczne działania na lokalnym stan każdego zadania.</param>
        <summary>Wykonuje <see langword="foreach" /> (<see langword="For Each" /> w języku Visual Basic) operacji z danymi lokalnymi wątku na <see cref="T:System.Collections.Concurrent.Partitioner" /> w którym iteracji może działać równolegle i monitorowania stanu pętli i manipulowanie.</summary>
        <returns>Struktura, która zawiera informacje o część pętlę ukończone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie jest dostępna dla scenariuszy, w której chcesz przesłonić domyślny schemat partycjonowania. Na przykład małych jednostek pętli mogą korzystać z partycjonowania zakresu. <xref:System.Threading.Tasks.Parallel.ForEach%2A> Metoda oczekuje niestandardowe partycjonery, aby obsługiwać partycjonowanie dynamiczne. Aby uzyskać więcej informacji, zobacz [niestandardowe Partycjonery dla PLINQ i TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) i [porady: Implementowanie partycji dynamicznych](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 `localInit` Delegata jest wywoływana raz dla każdego wątku, który uczestniczy w wykonywania pętli i zwraca stan początkowy lokalnego dla każdego z tych zadań. Te stany początkowej są przekazywane do pierwszej `body` wywołania dla każdego zadania. Co wywołanie treści kolejnych zwraca wartość stanu prawdopodobnie modyfikacji przekazywany do następnego wywołania treści. Na koniec ostatniego wywołania treści dla każdego zadania zwraca wartość stanu, który jest przekazywany do `localFinally` delegowanie. `localFinally` Delegata jest wywoływana raz na zadanie do wykonania akcji końcowego na stan lokalnego każdego zadania. Ten delegat może wywołać jednocześnie na wielu zadań; w związku z tym należy zsynchronizować dostęp do zmiennych udostępnionego.  
  
 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Metoda może używać zadania więcej niż wątków w okresie istnienia działania jako ukończone istniejącego zadania i zostały zastąpione przez nowe zadania. Dzięki temu odpowiadającego <xref:System.Threading.Tasks.TaskScheduler> obiekt możliwość dodawania, zmieniania lub usuwania wątków, które usługa pętli.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> Argument jest <see langword="null" />.  - lub - <paramref name="body" /> argument jest <see langword="null" />.  - lub - <paramref name="localInit" /> argument jest <see langword="null" />.  - lub - <paramref name="localFinally" /> argument jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> Właściwości w <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> zwraca <see langword="false" /> lub zwraca obiekt partitioner <see langword="null" /> partycji.</exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątków zgłaszanych na wszystkie wątki.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As IEnumerable(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, Long, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ danych w źródle.</typeparam>
        <typeparam name="TLocal">Typ danych lokalnych wątku.</typeparam>
        <param name="source">Źródło danych wyliczenia.</param>
        <param name="localInit">Delegat funkcji, która zwraca stan początkowy danych lokalnych dla każdego zadania.</param>
        <param name="body">Delegat, które jest wywoływane raz na iterację.</param>
        <param name="localFinally">Delegat, który wykonuje ostateczne działania na lokalnym stan każdego zadania.</param>
        <summary>Wykonuje <see langword="foreach" /> (<see langword="For Each" /> w języku Visual Basic) operacji z danymi lokalnymi wątku na <see cref="T:System.Collections.IEnumerable" /> w którym iteracji może działać równolegle i monitorowania stanu pętli i manipulowanie.</summary>
        <returns>Struktura, która zawiera informacje o część pętlę ukończone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body` Delegata jest wywoływana raz dla każdego elementu w `source` wyliczalny. Są dostarczane z następującymi parametrami: bieżący element <xref:System.Threading.Tasks.ParallelLoopState> wystąpienia, który może służyć do wyjścia z pętli przedwcześnie, indeks bieżącego elementu (<xref:System.Int64>), a niektóre stanu lokalnego, który może być udostępniana między iteracji, które są wykonywane w tym samym wątku.  
  
 `localInit` Delegata jest wywoływana raz dla każdego zadania, które uczestniczy w wykonywania pętli i zwraca stan początkowy lokalnego dla każdego z tych zadań. Te stany początkowej są przekazywane do pierwszej `body` wywołania dla każdego zadania. Co wywołanie treści kolejnych zwraca wartość stanu prawdopodobnie modyfikacji przekazywany do następnego wywołania treści. Na koniec ostatniego wywołania treści dla każdego zadania zwraca wartość stanu, który jest przekazywany do `localFinally` delegowanie. `localFinally` Delegata jest wywoływana raz na zadanie do wykonania akcji końcowego na stan lokalnego każdego zadania. Ten delegat może wywołać jednocześnie na wielu zadań; w związku z tym należy zsynchronizować dostęp do zmiennych udostępnionego.  
  
 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Metoda może używać zadania więcej niż wątków w okresie istnienia działania jako ukończone istniejącego zadania i zostały zastąpione przez nowe zadania. Dzięki temu odpowiadającego <xref:System.Threading.Tasks.TaskScheduler> obiekt możliwość dodawania, zmieniania lub usuwania wątków, które usługa pętli.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> Argument jest <see langword="null" />.  - lub - <paramref name="body" /> argument jest <see langword="null" />.  - lub - <paramref name="localInit" /> argument jest <see langword="null" />.  - lub - <paramref name="localFinally" /> argument jest <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątków zgłaszanych na wszystkie wątki.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As IEnumerable(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ danych w źródle.</typeparam>
        <typeparam name="TLocal">Typ danych lokalnych wątku.</typeparam>
        <param name="source">Źródło danych wyliczenia.</param>
        <param name="localInit">Delegat funkcji, która zwraca stan początkowy danych lokalnych dla każdego zadania.</param>
        <param name="body">Delegat, które jest wywoływane raz na iterację.</param>
        <param name="localFinally">Delegat, który wykonuje ostateczne działania na lokalnym stan każdego zadania.</param>
        <summary>Wykonuje <see langword="foreach" /> (<see langword="For Each" /> w języku Visual Basic) operacji z danymi lokalnymi wątku na <see cref="T:System.Collections.IEnumerable" /> której iteracji może działać równolegle, a stan pętli podlegający monitorowaniu i wykonywać na nich operacji.</summary>
        <returns>Struktura, która zawiera informacje o część pętlę ukończone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body` Delegata jest wywoływana raz dla każdego elementu w `source` wyliczalny. Znajduje się z następującymi parametrami: bieżący element <xref:System.Threading.Tasks.ParallelLoopState> wystąpienia, który może służyć do wyjścia z pętli przedwcześnie i niektóre stanu lokalnego, który może być udostępniana między iteracji, które są wykonywane na tym samym wątku.  
  
 `localInit` Delegata jest wywoływana raz dla każdego zadania, które uczestniczy w wykonywania pętli i zwraca stan początkowy lokalnego dla każdego z tych zadań. Te stany początkowej są przekazywane do pierwszej `body` wywołania dla każdego zadania. Co wywołanie treści kolejnych zwraca wartość stanu prawdopodobnie modyfikacji przekazywany do następnego wywołania treści. Na koniec ostatniego wywołania treści dla każdego zadania zwraca wartość stanu, który jest przekazywany do `localFinally` delegowanie. `localFinally` Delegata jest wywoływana raz na wątek do wykonywania akcji końcowego na stan lokalnego każdego zadania. Ten delegat może wywołać jednocześnie na wielu zadań; w związku z tym należy zsynchronizować dostęp do zmiennych udostępnionego.  
  
 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Metoda może używać zadania więcej niż wątków w okresie istnienia działania jako ukończone istniejącego zadania i zostały zastąpione przez nowe zadania. Dzięki temu odpowiadającego <xref:System.Threading.Tasks.TaskScheduler> obiekt możliwość dodawania, zmieniania lub usuwania wątków, które usługa pętli.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie <xref:System.Threading.Tasks.Parallel.ForEach%2A> metoda ze stanu lokalnego:  
  
 [!code-csharp[System.Threading.Tasks.Parallel#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelforeach.cs#02)]
 [!code-vb[System.Threading.Tasks.Parallel#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelforeach.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> Argument jest <see langword="null" />.  - lub - <paramref name="body" /> argument jest <see langword="null" />.  - lub - <paramref name="localInit" /> argument jest <see langword="null" />.  - lub - <paramref name="localFinally" /> argument jest <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątków zgłaszanych na wszystkie wątki.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.OrderablePartitioner{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów w <c>źródła</c>.</typeparam>
        <typeparam name="TLocal">Typ danych lokalnych wątku.</typeparam>
        <param name="source">Prędkości partycjonerem, który zawiera oryginalnego źródła danych.</param>
        <param name="parallelOptions">Obiekt, który konfiguruje działanie tej operacji.</param>
        <param name="localInit">Delegat funkcji, która zwraca stan początkowy danych lokalnych dla każdego zadania.</param>
        <param name="body">Delegat, które jest wywoływane raz na iterację.</param>
        <param name="localFinally">Delegat, który wykonuje ostateczne działania na lokalnym stan każdego zadania.</param>
        <summary>Wykonuje <see langword="foreach" /> (<see langword="For Each" /> w języku Visual Basic) operacji z 64-bitowe indeksy i z danymi lokalnymi wątku na <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> w iteracji, które może działać równolegle, można skonfigurować opcje pętli i monitorować stan pętli i manipulowanie.</summary>
        <returns>Struktura, która zawiera informacje o część pętlę ukończone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie jest dostępna dla scenariuszy, w której chcesz przesłonić domyślny schemat partycjonowania. Na przykład małych jednostek pętli mogą korzystać z partycjonowania zakresu. <xref:System.Threading.Tasks.Parallel.ForEach%2A> Metoda oczekuje niestandardowe partycjonery, aby obsługiwać partycjonowanie dynamiczne. Aby uzyskać więcej informacji, zobacz [niestandardowe Partycjonery dla PLINQ i TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) i [porady: Implementowanie partycji dynamicznych](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 `localInit` Delegata jest wywoływana raz dla każdego zadania, które uczestniczy w wykonywania pętli i zwraca stan początkowy lokalnego dla każdego z tych zadań. Te stany początkowej są przekazywane do pierwszej `body` wywołania dla każdego zadania. Co wywołanie treści kolejnych zwraca wartość stanu prawdopodobnie modyfikacji przekazywany do następnego wywołania treści. Na koniec ostatniego wywołania treści na każdy wątek zwraca wartość stanu, który jest przekazywany do `localFinally` delegowanie. `localFinally` Delegata jest wywoływana raz na zadanie do wykonania akcji końcowego na stan lokalnego każdego zadania. Ten delegat może wywołać jednocześnie na wielu zadań; w związku z tym należy zsynchronizować dostęp do zmiennych udostępnionego.  
  
 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Metoda może używać zadania więcej niż wątków w okresie istnienia działania jako ukończone istniejącego zadania i zostały zastąpione przez nowe zadania. Dzięki temu odpowiadającego <xref:System.Threading.Tasks.TaskScheduler> obiekt możliwość dodawania, zmieniania lub usuwania wątków, które usługa pętli.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> Argument jest <see langword="null" />.  - lub - <paramref name="parallelOptions" /> argument jest <see langword="null" />.  - lub - <paramref name="body" /> argument jest <see langword="null" />.  - lub - <paramref name="localInit" /> lub <paramref name="localFinally" /> argument jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> Właściwości w <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> zwraca <see langword="false" /> lub zwraca obiekt partitioner <see langword="null" /> partycji.</exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątków zgłaszanych na wszystkie wątki.</exception>
        <exception cref="T:System.OperationCanceledException">
          <see cref="T:System.Threading.CancellationToken" /> w <paramref name="parallelOptions" /> argument zostało anulowane.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.CancellationTokenSource" /> Skojarzone z <see cref="T:System.Threading.CancellationToken" /> w <paramref name="parallelOptions" /> został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ elementów w <c>źródła</c>.</typeparam>
        <typeparam name="TLocal">Typ danych lokalnych wątku.</typeparam>
        <param name="source">Partycjonerem, który zawiera oryginalnego źródła danych.</param>
        <param name="parallelOptions">Obiekt, który konfiguruje działanie tej operacji.</param>
        <param name="localInit">Delegat funkcji, która zwraca stan początkowy danych lokalnych dla każdego zadania.</param>
        <param name="body">Delegat, które jest wywoływane raz na iterację.</param>
        <param name="localFinally">Delegat, który wykonuje ostateczne działania na lokalnym stan każdego zadania.</param>
        <summary>Wykonuje <see langword="foreach" /> (<see langword="For Each" /> w języku Visual Basic) operacji z danymi lokalnymi wątku na <see cref="T:System.Collections.Concurrent.Partitioner" /> w iteracji, które może działać równolegle, można skonfigurować opcje pętli i monitorowania stanu pętli i manipulowanie.</summary>
        <returns>Struktura, która zawiera informacje o część pętlę ukończone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie jest dostępna dla scenariuszy, w której chcesz przesłonić domyślny schemat partycjonowania. Na przykład małych jednostek pętli mogą korzystać z partycjonowania zakresu. <xref:System.Threading.Tasks.Parallel.ForEach%2A> Metoda oczekuje niestandardowe partycjonery, aby obsługiwać partycjonowanie dynamiczne. To przeciążenie jest dostępna dla scenariuszy o małych jednostek pętli, które mogą korzystać z partycjonowania statycznego zakresu. Partycjonery musi obsługiwać partycje dynamiczne.  Aby uzyskać więcej informacji, zobacz [niestandardowe Partycjonery dla PLINQ i TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) i [porady: Implementowanie partycji dynamicznych](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 `localInit` Delegata jest wywoływana raz dla każdego zadania, które uczestniczy w wykonywania pętli i zwraca stan początkowy lokalnego dla każdego z tych zadań. Te stany początkowej są przekazywane do pierwszej `body` wywołania dla każdego zadania. Co wywołanie treści kolejnych zwraca wartość stanu prawdopodobnie modyfikacji przekazywany do następnego wywołania treści. Na koniec ostatniego wywołania treści dla każdego zadania zwraca wartość stanu, który jest przekazywany do `localFinally` delegowanie. `localFinally` Delegata jest wywoływana raz na zadanie do wykonania akcji końcowego na stan lokalnego każdego zadania. Ten delegat może wywołać jednocześnie na wielu zadań; w związku z tym należy zsynchronizować dostęp do zmiennych udostępnionego.  
  
 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Metoda może używać zadania więcej niż wątków w okresie istnienia działania jako ukończone istniejącego zadania i zostały zastąpione przez nowe zadania. Dzięki temu odpowiadającego <xref:System.Threading.Tasks.TaskScheduler> obiekt możliwość dodawania, zmieniania lub usuwania wątków, które usługa pętli.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> Argument jest <see langword="null" />.  - lub - <paramref name="parallelOptions" /> argument jest <see langword="null" />.  - lub - <paramref name="body" /> argument jest <see langword="null" />.  - lub - <paramref name="localInit" /> argument jest <see langword="null" />.  - lub - <paramref name="localFinally" /> argument jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> Właściwości w <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> zwraca <see langword="false" /> lub zwraca obiekt partitioner <see langword="null" /> partycji.</exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątków zgłaszanych na wszystkie wątki.</exception>
        <exception cref="T:System.OperationCanceledException">
          <see cref="T:System.Threading.CancellationToken" /> w <paramref name="parallelOptions" /> argument zostało anulowane.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.CancellationTokenSource" /> Skojarzone z <see cref="T:System.Threading.CancellationToken" /> w <paramref name="parallelOptions" /> został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ danych w źródle.</typeparam>
        <typeparam name="TLocal">Typ danych lokalnych wątku.</typeparam>
        <param name="source">Źródło danych wyliczenia.</param>
        <param name="parallelOptions">Obiekt, który konfiguruje działanie tej operacji.</param>
        <param name="localInit">Delegat funkcji, która zwraca stan początkowy danych lokalnych dla każdego zadania.</param>
        <param name="body">Delegat, które jest wywoływane raz na iterację.</param>
        <param name="localFinally">Delegat, który wykonuje ostateczne działania na lokalnym stan każdego zadania.</param>
        <summary>Wykonuje <see langword="foreach" /> (<see langword="For Each" /> w języku Visual Basic) operacji z danymi lokalnymi wątku i 64-bitowe indeksy na <see cref="T:System.Collections.IEnumerable" /> w iteracji, które może działać równolegle, można skonfigurować opcje pętli i monitorowania stanu pętli i manipulowanie.</summary>
        <returns>Struktura, która zawiera informacje o część pętlę ukończone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body` Delegata jest wywoływana raz dla każdego elementu w `source` wyliczalny. Są dostarczane z następującymi parametrami: bieżący element <xref:System.Threading.Tasks.ParallelLoopState> wystąpienia, który może służyć do wyjścia z pętli przedwcześnie, indeks bieżącego elementu (<xref:System.Int64>), a niektóre stanu lokalnego, który może być udostępniana między iteracji, które są wykonywane w tym samym wątku.  
  
 `localInit` Delegata jest wywoływana raz dla każdego zadania, które uczestniczy w wykonywania pętli i zwraca stan początkowy lokalnego dla każdego z tych zadań. Te stany początkowej są przekazywane do pierwszej `body` wywołania dla każdego zadania. Co wywołanie treści kolejnych zwraca wartość stanu prawdopodobnie modyfikacji przekazywany do następnego wywołania treści. Na koniec ostatniego wywołania treści dla każdego zadania zwraca wartość stanu, który jest przekazywany do `localFinally` delegowanie. `localFinally` Delegata jest wywoływana raz na wątek do wykonywania akcji końcowego na stan lokalnego każdego zadania. Ten delegat może wywołać jednocześnie na wielu zadań; w związku z tym należy zsynchronizować dostęp do zmiennych udostępnionego.  
  
 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Metoda może używać zadania więcej niż wątków w okresie istnienia działania jako ukończone istniejącego zadania i zostały zastąpione przez nowe zadania. Dzięki temu odpowiadającego <xref:System.Threading.Tasks.TaskScheduler> obiekt możliwość dodawania, zmieniania lub usuwania wątków, które usługa pętli.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> Argument jest <see langword="null" />.  - lub - <paramref name="parallelOptions" /> argument jest <see langword="null" />.  - lub - <paramref name="body" /> argument jest <see langword="null" />.  - lub - <paramref name="localInit" /> argument jest <see langword="null" />.  - lub - <paramref name="localFinally" /> argument jest <see langword="null" />.</exception>
        <exception cref="T:System.OperationCanceledException">
          <see cref="T:System.Threading.CancellationToken" /> w <paramref name="parallelOptions" /> argument zostało anulowane.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.CancellationTokenSource" /> Skojarzone z <see cref="T:System.Threading.CancellationToken" /> w <paramref name="parallelOptions" /> został usunięty.</exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątków zgłaszanych na wszystkie wątki.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">Typ danych w źródle.</typeparam>
        <typeparam name="TLocal">Typ danych lokalnych wątku.</typeparam>
        <param name="source">Źródło danych wyliczenia.</param>
        <param name="parallelOptions">Obiekt, który konfiguruje działanie tej operacji.</param>
        <param name="localInit">Delegat funkcji, która zwraca stan początkowy danych lokalnych dla każdego zadania.</param>
        <param name="body">Delegat, które jest wywoływane raz na iterację.</param>
        <param name="localFinally">Delegat, który wykonuje ostateczne działania na lokalnym stan każdego zadania.</param>
        <summary>Wykonuje <see langword="foreach" /> (<see langword="For Each" /> w języku Visual Basic) operacji z danymi lokalnymi wątku na <see cref="T:System.Collections.IEnumerable" /> w iteracji, które może działać równolegle, można skonfigurować opcje pętli i stan pętli podlegający monitorowaniu i wykonywać na nich operacji...</summary>
        <returns>Struktura, która zawiera informacje o część pętlę ukończone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `body` Delegata jest wywoływana raz dla każdego elementu w `source` wyliczalny. Znajduje się z następującymi parametrami: bieżący element <xref:System.Threading.Tasks.ParallelLoopState> wystąpienia, który może służyć do wyjścia z pętli przedwcześnie i niektóre stanu lokalnego, który może być udostępniana między iteracji, które są wykonywane na tym samym wątku.  
  
 `localInit` Delegata jest wywoływana raz dla każdego zadania, które uczestniczy w wykonywania pętli i zwraca stan początkowy lokalnego dla każdego z tych zadań. Te stany początkowej są przekazywane do pierwszej `body` wywołania dla każdego zadania. Co wywołanie treści kolejnych zwraca wartość stanu prawdopodobnie modyfikacji przekazywany do następnego wywołania treści. Na koniec ostatniego wywołania treści dla każdego zadania zwraca wartość stanu, który jest przekazywany do `localFinally` delegowanie. `localFinally` Delegata jest wywoływana raz na wątek do wykonywania akcji końcowego na stan lokalnego każdego zadania. Ten delegat może wywołać jednocześnie na wielu zadań; w związku z tym należy zsynchronizować dostęp do zmiennych udostępnionego.  
  
 <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Metoda może używać zadania więcej niż wątków w okresie istnienia działania jako ukończone istniejącego zadania i zostały zastąpione przez nowe zadania. Dzięki temu odpowiadającego <xref:System.Threading.Tasks.TaskScheduler> obiekt możliwość dodawania, zmieniania lub usuwania wątków, które usługa pętli.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> Argument jest <see langword="null" />.  - lub - <paramref name="parallelOptions" /> argument jest <see langword="null" />.  - lub - <paramref name="body" /> argument jest <see langword="null" />.  - lub - <paramref name="localInit" /> argument jest <see langword="null" />.  - lub - <paramref name="localFinally" /> argument jest <see langword="null" />.</exception>
        <exception cref="T:System.OperationCanceledException">
          <see cref="T:System.Threading.CancellationToken" /> w <paramref name="parallelOptions" /> argument zostało anulowane.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.CancellationTokenSource" /> Skojarzone z <see cref="T:System.Threading.CancellationToken" /> w <paramref name="parallelOptions" /> został usunięty.</exception>
        <exception cref="T:System.AggregateException">Wyjątek, który zawiera wszystkie poszczególne wyjątków zgłaszanych na wszystkie wątki.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Invoke">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wykonuje każdego z podanych akcji prawdopodobnie równolegle.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static void Invoke (params Action[] actions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Invoke(class System.Action[] actions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.Invoke(System.Action[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Invoke (ParamArray actions As Action())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Invoke(... cli::array &lt;Action ^&gt; ^ actions);" />
      <MemberSignature Language="F#" Value="static member Invoke : Action[] -&gt; unit" Usage="System.Threading.Tasks.Parallel.Invoke actions" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="actions" Type="System.Action[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="actions">Tablica <see cref="T:System.Action" /> do wykonania.</param>
        <summary>Wykonuje każdego z podanych akcji prawdopodobnie równolegle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może służyć do wykonywania zestawu działań, potencjalnie równolegle.  
  
 Gwarancje nie zostały wprowadzone o kolejność wykonywania działań lub czy są one wykonywane równolegle. Ta metoda nie zwraca dopóki nie zakończy się każdego z podanych operacje, niezależnie od tego, czy Zakończenie występuje z powodu zakończenia normalne lub wyjątkowe.  
  
 Aby uzyskać więcej informacji, zobacz [porady: użycie parallel_invoke podczas przeprowadzania do przeprowadzania operacji równoległych](~/docs/standard/parallel-programming/how-to-use-parallel-invoke-to-execute-parallel-operations.md).  
  
   
  
## Examples  
 W tym przykładzie przedstawiono sposób użycia <xref:System.Threading.Tasks.Parallel.Invoke%2A> metody za pomocą innych metod, delegatów anonimowego i wyrażenia lambda.  
  
 [!code-csharp[System.Threading.Tasks.Parallel#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelinvoke.cs#01)]
 [!code-vb[System.Threading.Tasks.Parallel#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelinvoke.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="actions" /> Argument jest <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Wyjątek zgłaszany, gdy wszystkie działania w <paramref name="actions" /> tablicy zgłasza wyjątek.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="actions" /> Tablica zawiera <see langword="null" /> elementu.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static void Invoke (System.Threading.Tasks.ParallelOptions parallelOptions, params Action[] actions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Invoke(class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action[] actions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.Invoke(System.Threading.Tasks.ParallelOptions,System.Action[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Invoke(System::Threading::Tasks::ParallelOptions ^ parallelOptions, ... cli::array &lt;Action ^&gt; ^ actions);" />
      <MemberSignature Language="F#" Value="static member Invoke : System.Threading.Tasks.ParallelOptions * Action[] -&gt; unit" Usage="System.Threading.Tasks.Parallel.Invoke (parallelOptions, actions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="actions" Type="System.Action[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="parallelOptions">Obiekt, który konfiguruje działanie tej operacji.</param>
        <param name="actions">Tablica akcje do wykonania.</param>
        <summary>Wykonuje każdego z podanych akcji prawdopodobnie równolegle, o ile operacja została anulowana przez użytkownika.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może służyć do wykonywania zestawu działań, potencjalnie równolegle. Token anulowania przekazany przy użyciu <xref:System.Threading.Tasks.ParallelOptions> obiekt wywołujący, aby anulować operację całego umożliwia struktury. Aby uzyskać więcej informacji, zobacz [anulowanie w zarządzanych wątkach](~/docs/standard/threading/cancellation-in-managed-threads.md).  
  
 Gwarancje nie zostały wprowadzone o kolejność wykonywania działań lub czy są one wykonywane równolegle. Ta metoda nie zwraca dopóki nie zakończy się każdego z podanych operacje, niezależnie od tego, czy Zakończenie występuje z powodu zakończenia normalne lub wyjątkowe.  
  
 Aby uzyskać więcej informacji, zobacz [porady: użycie parallel_invoke podczas przeprowadzania do przeprowadzania operacji równoległych](~/docs/standard/parallel-programming/how-to-use-parallel-invoke-to-execute-parallel-operations.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <see cref="T:System.Threading.CancellationToken" /> w <paramref name="parallelOptions" /> jest ustawiona.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="actions" /> Argument jest <see langword="null" />.  - lub - <paramref name="parallelOptions" /> argument jest <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Wyjątek zgłaszany, gdy wszystkie działania w <paramref name="actions" /> tablicy zgłasza wyjątek.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="actions" /> Tablica zawiera <see langword="null" /> elementu.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.CancellationTokenSource" /> Skojarzone z <see cref="T:System.Threading.CancellationToken" /> w <paramref name="parallelOptions" /> został usunięty.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
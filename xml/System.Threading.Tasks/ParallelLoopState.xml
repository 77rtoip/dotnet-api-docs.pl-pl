<Type Name="ParallelLoopState" FullName="System.Threading.Tasks.ParallelLoopState">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ce5700b68f4a6ba69f5224dd0dd9b977cbfc8288" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36407493" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ParallelLoopState" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ParallelLoopState extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.ParallelLoopState" />
  <TypeSignature Language="VB.NET" Value="Public Class ParallelLoopState" />
  <TypeSignature Language="C++ CLI" Value="public ref class ParallelLoopState" />
  <TypeSignature Language="F#" Value="type ParallelLoopState = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("ShouldExitCurrentIteration = {ShouldExitCurrentIteration}")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Umożliwia iteracji pętli równoległej na interakcję z innych iteracji. Wystąpienie tej klasy są dostarczane przez <see cref="T:System.Threading.Tasks.Parallel" /> klasy do każdej pętli; nie można utworzyć wystąpienia w kodzie.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy pamiętać, że nie można utworzyć wystąpienia wystąpienia tej klasy. Jest ona generowana automatycznie przez kompilator jako argument w wywołaniu <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> lub <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> metody. Przykład stanowi ilustrację.  
  
 Tworzy, takich jak `for` i `foreach` (w języku C#) i `For` i `For Each` (w języku Visual Basic) wykonaj kolejno z najniższym indeksie jako najwyższe lub z pierwszego obiektu w zestawie do ostatniego. Z kolei <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> i <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> nie metody. Ponieważ poszczególnych iteracji pętli są uruchamiane równolegle, mogą rozpocząć i zakończyć w dowolnej kolejności. <xref:System.Threading.Tasks.ParallelLoopState> Klasa umożliwia poszczególnych iteracji pętli równoległej na interakcję ze sobą. <xref:System.Threading.Tasks.ParallelLoopState> Klasa umożliwia:  
  
-   Zakończ bieżącą iterację i zapobiec wszelkie dodatkowe iteracji uruchamianiu przez wywołanie metody <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> metody. Nie dotyczy to iteracji, które już zostały rozpoczęte wykonywania.  
  
-   Wszystkie iteracje z indeksem większa niż bieżący indeks uniemożliwić wykonywania przez wywołanie metody <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> metody. Nie dotyczy to iteracji, które już zostały rozpoczęte wykonywania.  
  
-   Określić, czy wystąpił wyjątek w dowolnym iteracji pętli pobierając zaletą <xref:System.Threading.Tasks.ParallelLoopState.IsExceptional%2A> właściwości.  
  
-   Określić, czy została wywołana żadnych iteracji pętli <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> metody pobierając zaletą <xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A> właściwości. Ta właściwość służy do zwrócenia z iteracji pętli, które uruchomiona przed wywołanie <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> metody, ale są nadal wykonywane.  
  
-   Określić, czy wszystkie iteracji pętli została wywołana <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> lub <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> metody lub wywołało wyjątek pobierając zaletą <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> właściwości.  
  
-   Wyjście z iteracji długotrwałe, którego indeks jest większy niż indeks iteracji, w którym Break została wywołana przez pobieranie wartości <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykład wykonuje maksymalnie 100 iteracji pętli równolegle. Wstrzymuje każdej iteracji dla losowo wybranym interwałem z zakresu od 1 do 1000 milisekund. Określa losowo generowanej wartości, na które iteracji pętli <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> metoda jest wywoływana. Jako dane wyjściowe w przykładzie pokazano, nie iteracji, którego indeks jest większy niż <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> początek wartości właściwości po wywołaniu <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> metody.  
  
 [!code-csharp[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/cs/break1.cs#2)]
 [!code-vb[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/vb/break1.vb#2)]  
  
 Ponieważ iteracji pętli są nadal mogą być wykonywane podczas <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> metoda jest wywoływana, wywołuje każdej iteracji <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> właściwość do sprawdzenia, czy inny iteracji została wywołana <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> metody. Jeśli wartość właściwości jest `true`, iteracji sprawdza wartość <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> właściwości i, jeśli jest większa niż wartość indeksu bieżącej iteracji, zwraca natychmiast.  
  
 ]]></format>
    </remarks>
    <threadsafe>A <see cref="T:System.Threading.Tasks.ParallelLoopState" /> wystąpienia jest przeznaczona do użycia tylko w treści pętli, do którego podano wystąpienia.  Nie jest bezpieczne użyć podanego <see cref="T:System.Threading.Tasks.ParallelLoopState" /> wystąpienia po pętli skojarzone zostaje zakończona, ani bezpiecznie jawnie oddaniem do innych wątków i mają te wątków do niego dostęp w dowolnym momencie.  Inną <see cref="T:System.Threading.Tasks.ParallelLoopState" /> wystąpienia, które zostaną dostarczone do każdego wątku zaangażowane w pętli.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public void Break ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Break() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.ParallelLoopState.Break" />
      <MemberSignature Language="VB.NET" Value="Public Sub Break ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Break();" />
      <MemberSignature Language="F#" Value="member this.Break : unit -&gt; unit" Usage="parallelLoopState.Break " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Komunikuje się, że <see cref="T:System.Threading.Tasks.Parallel" /> pętla powinna zakończyć wykonywania iteracji poza bieżącą iterację wygodne najwcześniejszą systemu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> Wskazuje nie iteracji po bieżącej iteracji powinna być uruchamiana. Umożliwia anulowanie skutecznie wszelkie dodatkowe iteracji pętli. Jednak nie zatrzymuje wszystkie iteracje już rozpoczęto wykonywanie. Na przykład jeśli <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> jest wywoływana z 100 iteracji pętli równoległej iteracja z zakresu od 0 do 1000, wszystkie iteracje mniej niż 100 powinien nadal wykonywania, ale iteracji od 101 do 1000, które nie zostały uruchomione nie są wykonywane.  
  
 Dla iteracji długotrwałe, które mogą być już wykonuje <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> ustawia <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> indeks bieżącej iteracji, jeśli bieżący indeks jest mniejszy niż bieżąca wartość dla właściwości <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A>. Aby zatrzymać iteracji, którego indeks jest większy niż najniższy iteracji podziału pochodzący z wykonania na konkurencyjnych, należy wykonać następujące:  
  
1.  Sprawdź, czy <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> jest właściwość `true`.  
  
2.  Wyjść z iteracji, jeśli jego indeksu jest większa niż <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> wartości właściwości.  
  
 Przykład stanowi ilustrację.  
  
 <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> Zazwyczaj jest stosowanych w algorytmów na podstawie wyszukiwania, których kolejność znajduje się w źródle danych.  
  
   
  
## Examples  
 Poniższy przykład wykonuje maksymalnie 100 iteracji pętli równolegle. Wstrzymuje każdej iteracji dla losowo wybranym interwałem z zakresu od 1 do 1000 milisekund. Określa losowo generowanej wartości, na które iteracji pętli <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> metoda jest wywoływana. Jako dane wyjściowe w przykładzie pokazano, nie iteracji, którego indeks jest większy niż <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> początek wartości właściwości po wywołaniu <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> metody.  
  
 [!code-csharp[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/cs/break1.cs#2)]
 [!code-vb[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/vb/break1.vb#2)]  
  
 Ponieważ iteracji pętli są nadal mogą być wykonywane podczas <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> metoda jest wywoływana, wywołuje każdej iteracji <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> właściwość do sprawdzenia, czy inny iteracji została wywołana <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> metody. Jeśli wartość właściwości jest `true`, iteracji sprawdza wartość <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> właściwości i, jeśli jest większa niż wartość indeksu bieżącej iteracji, zwraca natychmiast.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Threading.Tasks.ParallelLoopState.Stop" /> Wcześniej wywołano metodę. <see cref="M:System.Threading.Tasks.ParallelLoopState.Break" /> i <see cref="M:System.Threading.Tasks.ParallelLoopState.Stop" /> nie mogą być używane w połączeniu przez iteracji pętli tej samej.</exception>
        <altmember cref="P:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration" />
        <altmember cref="P:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration" />
      </Docs>
    </Member>
    <Member MemberName="IsExceptional">
      <MemberSignature Language="C#" Value="public bool IsExceptional { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsExceptional" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.ParallelLoopState.IsExceptional" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsExceptional As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsExceptional { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsExceptional : bool" Usage="System.Threading.Tasks.ParallelLoopState.IsExceptional" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera informacje, czy wszystkie iteracji pętli zgłosił wyjątek, który wystąpił nieobsługiwany przez ten iteracji.</summary>
        <value>
          <see langword="true" /> Jeśli wystąpił nieobsługiwany wyjątek; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStopped">
      <MemberSignature Language="C#" Value="public bool IsStopped { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStopped" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.ParallelLoopState.IsStopped" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStopped As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStopped { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsStopped : bool" Usage="System.Threading.Tasks.ParallelLoopState.IsStopped" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera informację, czy została wywołana żadnych iteracji pętli <see cref="M:System.Threading.Tasks.ParallelLoopState.Stop" /> metody.</summary>
        <value>
          <see langword="true" /> Jeśli dowolną iterację zatrzymał pętli poprzez wywołanie <see cref="M:System.Threading.Tasks.ParallelLoopState.Stop" /> metody; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dla długotrwałe iteracji pętli, można pobrać wartość <xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A> właściwości w celu określenia, czy wszystkie iteracji pętli rozpoczęcia wykonywania przed wywołaniem do <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> metody są nadal wykonywane. Następnie można użyć wartości <xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A> właściwość, aby ustalić, czy powinien zwrócić natychmiast lub wykonać normalnie.  
  
   
  
## Examples  
 Poniższy przykład wykonuje maksymalnie 10 000 iteracji pętli równolegle. Wstrzymuje każdej iteracji dla losowo wybranym interwałem z zakresu od 1 do 1000 milisekund. Określa losowo generowanej wartości, na które iteracji pętli <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> metoda jest wywoływana. Ponieważ iteracji pętli są nadal mogą być wykonywane podczas <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> metoda jest wywoływana, wywołania wyrażenia lambda <xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A> , aby sprawdzić, czy inny iteracji została wywołana <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> metody. Jeśli zmienna zwraca `true`, iteracji zwraca natychmiast.  
  
 [!code-csharp[System.Threading.Tasks.ParallelLoopState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/cs/stop1.cs#1)]
 [!code-vb[System.Threading.Tasks.ParallelLoopState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/vb/stop1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LowestBreakIteration">
      <MemberSignature Language="C#" Value="public Nullable&lt;long&gt; LowestBreakIteration { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Nullable`1&lt;int64&gt; LowestBreakIteration" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LowestBreakIteration As Nullable(Of Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Nullable&lt;long&gt; LowestBreakIteration { Nullable&lt;long&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.LowestBreakIteration : Nullable&lt;int64&gt;" Usage="System.Threading.Tasks.ParallelLoopState.LowestBreakIteration" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera najniższy iteracji pętli, z którego <see cref="M:System.Threading.Tasks.ParallelLoopState.Break" /> została wywołana.</summary>
        <value>Najniższa iteracji, z którego <see cref="M:System.Threading.Tasks.ParallelLoopState.Break" /> została wywołana. W przypadku liczby <see cref="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Action{``0})" /> pętli, wartość jest oparta na indeks wygenerowane wewnętrznie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użytkownik może przejść przez wiele iteracji pętli równoległej do wywołania <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> metody. Jeśli nie, ta wartość jest najmniejszy indeks iteracji, który wywołał <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>. Jeśli nie iteracji pętli o nazwie <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>, ta właściwość zwraca `null`. Należy pamiętać, że wartość właściwości jest poza zasięgiem wywołania <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> metody.  
  
 W iteracji długotrwałe, w których wszystkie iteracje po iteracji, który wywołuje <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> — metoda nie należy uruchomić, <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> właściwość jest używana do zakończenia iteracji rozpoczęcia wykonywania przed wywołaniem do <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> metody. Aby zatrzymać iteracji, którego indeks jest większy niż najniższy iteracji podziału pochodzący z wykonania na konkurencyjnych, należy wykonać następujące:  
  
1.  Sprawdź, czy <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> jest właściwość `true`.  
  
2.  Wyjść z iteracji, jeśli jego indeksu jest większa niż <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> wartości właściwości.  
  
 Przykład stanowi ilustrację.  
  
   
  
## Examples  
 Poniższy przykład wykonuje maksymalnie 100 iteracji pętli równolegle. Wstrzymuje każdej iteracji dla losowo wybranym interwałem z zakresu od 1 do 1000 milisekund. Określa losowo generowanej wartości, na które iteracji pętli <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> metoda jest wywoływana. Zapobiega to iteracji, którego indeks jest większy niż <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> wartość właściwości uruchomienie po wywołaniu <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> metody, ale nie wpływa na wszystkie iteracje już rozpoczęto wykonywanie. Aby uniknąć tych ukończenie, wywołuje każdej iteracji <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> , aby sprawdzić, czy inny iteracji została wywołana <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> metody. Jeśli tak, iteracji sprawdza wartość <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> właściwości i, jeśli jest większa niż wartość indeksu bieżącej iteracji, zwraca natychmiast.  
  
 [!code-csharp[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/cs/break1.cs#2)]
 [!code-vb[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/vb/break1.vb#2)]  
  
 Należy zauważyć, że ponieważ <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> wartość jest poza zakresem poza pętlą równoległe, należy go przypisać do zmiennej, która jest widoczne na zewnątrz pętli, jeśli chcesz zachować jego wartość.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration" />
        <altmember cref="M:System.Threading.Tasks.ParallelLoopState.Break" />
      </Docs>
    </Member>
    <Member MemberName="ShouldExitCurrentIteration">
      <MemberSignature Language="C#" Value="public bool ShouldExitCurrentIteration { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShouldExitCurrentIteration" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ShouldExitCurrentIteration As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShouldExitCurrentIteration { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ShouldExitCurrentIteration : bool" Usage="System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera informację, czy powinny być kończone bieżącej iteracji pętli oparciu żądań wysyłanych przez to lub inne iteracji.</summary>
        <value>
          <see langword="true" /> Jeśli bieżącą iterację powinny być kończone; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> Właściwość jest ustawiona na `true` we wszystkich następujących warunków:  
  
-   Iteracji pętli wywołań <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> lub <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A>.  
  
-   Iteracji pętli zgłasza wyjątek.  
  
-   Pętla zostało anulowane.  
  
 Gdy ta właściwość jest `true`, <xref:System.Threading.Tasks.Parallel> klasy aktywnego podejmie próbę zabrania rozpoczęcie wykonywania dodatkowych iteracji pętli. Jednak może być przypadkach, gdy jest nie można zapobiec dodatkowe iteracji uruchamianiu.  
  
 Może to być również przypadku iteracji długotrwałe rozpoczął już wykonywania. W takich przypadkach iteracji może jawnie sprawdziła <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> właściwości i zaprzestanie wykonanie, jeśli właściwość zwraca `true`.  
  
   
  
## Examples  
 Poniższy przykład wykonuje maksymalnie 100 iteracji pętli równolegle. Wstrzymuje każdej iteracji dla losowo wybranym interwałem z zakresu od 1 do 1000 milisekund. Określa losowo generowanej wartości, na które iteracji pętli <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> metoda jest wywoływana. Zapobiega to iteracji, którego indeks jest większy niż <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> wartość właściwości uruchomienie po wywołaniu <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> metody, ale nie wpływa na wszystkie iteracje już rozpoczęto wykonywanie. Aby uniknąć tych ukończenie, wywołuje każdej iteracji <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A> , aby sprawdzić, czy inny iteracji została wywołana <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> metody. Jeśli tak, iteracji sprawdza wartość <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A> właściwości i, jeśli jest większa niż wartość indeksu bieżącej iteracji, zwraca natychmiast.  
  
 [!code-csharp[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/cs/break1.cs#2)]
 [!code-vb[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/vb/break1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration" />
        <altmember cref="M:System.Threading.Tasks.ParallelLoopState.Break" />
        <altmember cref="M:System.Threading.Tasks.ParallelLoopState.Stop" />
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.ParallelLoopState.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop();" />
      <MemberSignature Language="F#" Value="member this.Stop : unit -&gt; unit" Usage="parallelLoopState.Stop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Komunikuje się, że <see cref="T:System.Threading.Tasks.Parallel" /> pętla powinna zakończyć wykonywania wygodne najwcześniejszą systemu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływanie <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> — metoda oznacza, że iteracji pętli, które nie zostały jeszcze uruchomione nie muszą być uruchamiane. Umożliwia anulowanie skutecznie wszelkie dodatkowe iteracji pętli. Jednak nie zatrzymuje wszystkie iteracje już rozpoczęto wykonywanie.  
  
 Wywoływanie <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> metody powoduje, że <xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A> właściwości do zwrócenia `true` dla dowolnego iteracji pętli, które jest nadal wykonywane. Jest to szczególnie przydatne podczas długotrwałych iteracji, które można sprawdzić <xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A> właściwości i Zakończ wcześniej, jeśli jego wartość wynosi `true`.  
  
 <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> Zazwyczaj jest stosowanych w algorytmy na podstawie wyszukiwania, gdzie po wynik znaleziono, żadnych innych iteracji muszą można wykonać.  
  
   
  
## Examples  
 Poniższy przykład wykonuje maksymalnie 10 000 iteracji pętli równolegle. Wstrzymuje każdej iteracji dla losowo wybranym interwałem z zakresu od 1 do 1000 milisekund. Określa losowo generowanej wartości, na które iteracji pętli <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> metoda jest wywoływana. Jak pokazano na dane wyjściowe z przykładu, iteracji nie wykonać po wywołaniu <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> metody.  
  
 [!code-csharp[System.Threading.Tasks.ParallelLoopState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/cs/stop1.cs#1)]
 [!code-vb[System.Threading.Tasks.ParallelLoopState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/vb/stop1.vb#1)]  
  
 Ponieważ iteracji pętli są nadal mogą być wykonywane podczas <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> metoda jest wywoływana, wywołuje każdej iteracji <xref:System.Threading.Tasks.ParallelLoopState.IsStopped%2A> , aby sprawdzić, czy inny iteracji została wywołana <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> metody. Jeśli zmienna zwraca `true`, iteracji zwraca natychmiast.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Threading.Tasks.ParallelLoopState.Break" /> Wcześniej wywołano metodę. <see cref="M:System.Threading.Tasks.ParallelLoopState.Break" /> i <see cref="M:System.Threading.Tasks.ParallelLoopState.Stop" /> nie mogą być używane w połączeniu przez iteracji pętli tej samej.</exception>
        <altmember cref="P:System.Threading.Tasks.ParallelLoopState.IsStopped" />
      </Docs>
    </Member>
  </Members>
</Type>
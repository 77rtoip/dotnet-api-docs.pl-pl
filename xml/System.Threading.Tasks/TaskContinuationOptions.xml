<Type Name="TaskContinuationOptions" FullName="System.Threading.Tasks.TaskContinuationOptions">
  <Metadata><Meta Name="ms.openlocfilehash" Value="8f842eb8c44cd7cefdd338dceb8a1dace9c0cb20" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69099084" /></Metadata><TypeSignature Language="C#" Value="public enum TaskContinuationOptions" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed TaskContinuationOptions extends System.Enum" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.TaskContinuationOptions" />
  <TypeSignature Language="VB.NET" Value="Public Enum TaskContinuationOptions" />
  <TypeSignature Language="C++ CLI" Value="public enum class TaskContinuationOptions" />
  <TypeSignature Language="F#" Value="type TaskContinuationOptions = " />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Enum</BaseTypeName>
  </Base>
  <Attributes>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
      <AttributeName>System.Flags</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Określa zachowanie zadania tworzonego przy użyciu <see cref="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" /> metody lub. <see cref="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0}},System.Threading.Tasks.TaskContinuationOptions)" /></summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="AttachedToParent">
      <MemberSignature Language="C#" Value="AttachedToParent" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Threading.Tasks.TaskContinuationOptions AttachedToParent = int32(4)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.Tasks.TaskContinuationOptions.AttachedToParent" />
      <MemberSignature Language="VB.NET" Value="AttachedToParent" />
      <MemberSignature Language="C++ CLI" Value="AttachedToParent" />
      <MemberSignature Language="F#" Value="AttachedToParent = 4" Usage="System.Threading.Tasks.TaskContinuationOptions.AttachedToParent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskContinuationOptions</ReturnType>
      </ReturnValue>
      <MemberValue>4</MemberValue>
      <Docs>
        <summary>Określa, że kontynuacja, jeśli jest zadaniem podrzędnym, jest dołączona do elementu nadrzędnego w hierarchii zadań. Kontynuacja może być zadaniem podrzędnym tylko wtedy, gdy jego poprzednik jest również zadaniem podrzędnym. Domyślnie zadanie podrzędne (czyli zadanie wewnętrzne utworzone przez zadanie zewnętrzne) jest wykonywane niezależnie od jego elementu nadrzędnego. Można użyć <see cref="F:System.Threading.Tasks.TaskContinuationOptions.AttachedToParent" /> opcji, aby zsynchronizować zadania nadrzędne i podrzędne.  
  
Należy pamiętać, że jeśli zadanie nadrzędne jest skonfigurowane <see cref="F:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach" /> z opcją <see cref="F:System.Threading.Tasks.TaskCreationOptions.AttachedToParent" /> , opcja w zadaniu podrzędnym nie ma żadnego efektu, a zadanie podrzędne zostanie wykonane jako odłączone zadanie podrzędne.  
  
Aby uzyskać więcej informacji, zobacz [dołączone i odłączone zadania podrzędne](~/docs/standard/parallel-programming/attached-and-detached-child-tasks.md).</summary>
      </Docs>
    </Member>
    <Member MemberName="DenyChildAttach">
      <MemberSignature Language="C#" Value="DenyChildAttach" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Threading.Tasks.TaskContinuationOptions DenyChildAttach = int32(8)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.Tasks.TaskContinuationOptions.DenyChildAttach" />
      <MemberSignature Language="VB.NET" Value="DenyChildAttach" />
      <MemberSignature Language="C++ CLI" Value="DenyChildAttach" />
      <MemberSignature Language="F#" Value="DenyChildAttach = 8" Usage="System.Threading.Tasks.TaskContinuationOptions.DenyChildAttach" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskContinuationOptions</ReturnType>
      </ReturnValue>
      <MemberValue>8</MemberValue>
      <Docs>
        <summary>Określa, że każde zadanie podrzędne (czyli każde zagnieżdżone zadanie wewnętrzne utworzone w tej kontynuacji), które jest tworzone za <see cref="F:System.Threading.Tasks.TaskCreationOptions.AttachedToParent" /> pomocą opcji i próby wykonania jako dołączone zadanie podrzędne, nie będzie mogło zostać dołączone do zadania nadrzędnego i zostanie wykonane zamiast Odłączono zadanie podrzędne. Aby uzyskać więcej informacji, zobacz [dołączone i odłączone zadania podrzędne](~/docs/standard/parallel-programming/attached-and-detached-child-tasks.md).</summary>
      </Docs>
    </Member>
    <Member MemberName="ExecuteSynchronously">
      <MemberSignature Language="C#" Value="ExecuteSynchronously" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Threading.Tasks.TaskContinuationOptions ExecuteSynchronously = int32(524288)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />
      <MemberSignature Language="VB.NET" Value="ExecuteSynchronously" />
      <MemberSignature Language="C++ CLI" Value="ExecuteSynchronously" />
      <MemberSignature Language="F#" Value="ExecuteSynchronously = 524288" Usage="System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskContinuationOptions</ReturnType>
      </ReturnValue>
      <MemberValue>524288</MemberValue>
      <Docs>
        <summary>Określa, że zadanie kontynuacji powinno być wykonywane synchronicznie. W przypadku wybrania tej opcji kontynuacja przebiega w tym samym wątku, który powoduje przejście zadania poprzedzającego do stanu końcowego. Jeśli poprzedzający jest już ukończony podczas tworzenia kontynuacji, kontynuacja zostanie uruchomiona w wątku, który tworzy kontynuację. Jeśli poprzedzający <see cref="T:System.Threading.CancellationTokenSource" /> element <see langword="finally" /> zostanie usunięty w bloku (<see langword="Finally" /> w Visual Basic), kontynuacja z tą opcją zostanie uruchomiona w tym <see langword="finally" /> bloku. Tylko bardzo krótkie działania powinny być wykonywane synchronicznie.  
  
Ponieważ zadanie jest wykonywane synchronicznie, nie ma potrzeby wywoływania metody, takiej jak <see cref="M:System.Threading.Tasks.Task.Wait" /> aby upewnić się, że wątek wywołujący czeka na ukończenie zadania.</summary>
      </Docs>
    </Member>
    <Member MemberName="HideScheduler">
      <MemberSignature Language="C#" Value="HideScheduler" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Threading.Tasks.TaskContinuationOptions HideScheduler = int32(16)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.Tasks.TaskContinuationOptions.HideScheduler" />
      <MemberSignature Language="VB.NET" Value="HideScheduler" />
      <MemberSignature Language="C++ CLI" Value="HideScheduler" />
      <MemberSignature Language="F#" Value="HideScheduler = 16" Usage="System.Threading.Tasks.TaskContinuationOptions.HideScheduler" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskContinuationOptions</ReturnType>
      </ReturnValue>
      <MemberValue>16</MemberValue>
      <Docs>
        <summary>Określa, że zadania utworzone przez wywoływanie metod, takie jak <see cref="M:System.Threading.Tasks.Task.Run(System.Action)" /> lub <see cref="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})" /> , zobacz domyślny harmonogram (<see cref="P:System.Threading.Tasks.TaskScheduler.Default" />), a nie harmonogram, w którym ta kontynuacja jest uruchomiona jako bieżący harmonogram.</summary>
      </Docs>
    </Member>
    <Member MemberName="LazyCancellation">
      <MemberSignature Language="C#" Value="LazyCancellation" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Threading.Tasks.TaskContinuationOptions LazyCancellation = int32(32)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.Tasks.TaskContinuationOptions.LazyCancellation" />
      <MemberSignature Language="VB.NET" Value="LazyCancellation" />
      <MemberSignature Language="C++ CLI" Value="LazyCancellation" />
      <MemberSignature Language="F#" Value="LazyCancellation = 32" Usage="System.Threading.Tasks.TaskContinuationOptions.LazyCancellation" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskContinuationOptions</ReturnType>
      </ReturnValue>
      <MemberValue>32</MemberValue>
      <Docs>
        <summary>W przypadku anulowania kontynuacji program zapobiega zakończeniu kontynuacji do momentu ukończenia poprzedzającego.</summary>
      </Docs>
    </Member>
    <Member MemberName="LongRunning">
      <MemberSignature Language="C#" Value="LongRunning" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Threading.Tasks.TaskContinuationOptions LongRunning = int32(2)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.Tasks.TaskContinuationOptions.LongRunning" />
      <MemberSignature Language="VB.NET" Value="LongRunning" />
      <MemberSignature Language="C++ CLI" Value="LongRunning" />
      <MemberSignature Language="F#" Value="LongRunning = 2" Usage="System.Threading.Tasks.TaskContinuationOptions.LongRunning" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskContinuationOptions</ReturnType>
      </ReturnValue>
      <MemberValue>2</MemberValue>
      <Docs>
        <summary>Określa, że kontynuacja będzie długotrwałą operacją. Zapewnia wskazówkę dotyczącą <see cref="T:System.Threading.Tasks.TaskScheduler" /> subskrypcji, która może być uzasadniona.</summary>
      </Docs>
    </Member>
    <Member MemberName="None">
      <MemberSignature Language="C#" Value="None" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Threading.Tasks.TaskContinuationOptions None = int32(0)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.Tasks.TaskContinuationOptions.None" />
      <MemberSignature Language="VB.NET" Value="None" />
      <MemberSignature Language="C++ CLI" Value="None" />
      <MemberSignature Language="F#" Value="None = 0" Usage="System.Threading.Tasks.TaskContinuationOptions.None" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskContinuationOptions</ReturnType>
      </ReturnValue>
      <MemberValue>0</MemberValue>
      <Docs>
        <summary>Gdy nie określono żadnych opcji kontynuacji, program określa, że zachowanie domyślne powinno być używane podczas wykonywania kontynuacji. Kontynuacja jest uruchamiana asynchronicznie, gdy zadanie poprzedzające zostanie zakończone, niezależnie od <see cref="P:System.Threading.Tasks.Task.Status" /> końcowej wartości właściwości poprzedzającej. Kontynuacja jest zadaniem podrzędnym, jest tworzone jako odłączone zadanie zagnieżdżone.</summary>
      </Docs>
    </Member>
    <Member MemberName="NotOnCanceled">
      <MemberSignature Language="C#" Value="NotOnCanceled" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Threading.Tasks.TaskContinuationOptions NotOnCanceled = int32(262144)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.Tasks.TaskContinuationOptions.NotOnCanceled" />
      <MemberSignature Language="VB.NET" Value="NotOnCanceled" />
      <MemberSignature Language="C++ CLI" Value="NotOnCanceled" />
      <MemberSignature Language="F#" Value="NotOnCanceled = 262144" Usage="System.Threading.Tasks.TaskContinuationOptions.NotOnCanceled" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskContinuationOptions</ReturnType>
      </ReturnValue>
      <MemberValue>262144</MemberValue>
      <Docs>
        <summary>Określa, że zadanie kontynuacji nie powinno być zaplanowane, jeśli jego poprzednik został anulowany. Element poprzedzający jest anulowany <see cref="P:System.Threading.Tasks.Task.Status" /> , jeśli jego właściwość <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" />została ukończona. Ta opcja jest nieprawidłowa dla kontynuacji wielozadania.</summary>
      </Docs>
    </Member>
    <Member MemberName="NotOnFaulted">
      <MemberSignature Language="C#" Value="NotOnFaulted" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Threading.Tasks.TaskContinuationOptions NotOnFaulted = int32(131072)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.Tasks.TaskContinuationOptions.NotOnFaulted" />
      <MemberSignature Language="VB.NET" Value="NotOnFaulted" />
      <MemberSignature Language="C++ CLI" Value="NotOnFaulted" />
      <MemberSignature Language="F#" Value="NotOnFaulted = 131072" Usage="System.Threading.Tasks.TaskContinuationOptions.NotOnFaulted" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskContinuationOptions</ReturnType>
      </ReturnValue>
      <MemberValue>131072</MemberValue>
      <Docs>
        <summary>Określa, że zadanie kontynuacji nie powinno być zaplanowane, jeśli jego poprzednik wywołał nieobsłużony wyjątek. Element poprzedzający zgłasza nieobsłużony wyjątek, jeśli <see cref="P:System.Threading.Tasks.Task.Status" /> jego właściwość została <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" />ukończona. Ta opcja jest nieprawidłowa dla kontynuacji wielozadania.</summary>
      </Docs>
    </Member>
    <Member MemberName="NotOnRanToCompletion">
      <MemberSignature Language="C#" Value="NotOnRanToCompletion" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Threading.Tasks.TaskContinuationOptions NotOnRanToCompletion = int32(65536)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.Tasks.TaskContinuationOptions.NotOnRanToCompletion" />
      <MemberSignature Language="VB.NET" Value="NotOnRanToCompletion" />
      <MemberSignature Language="C++ CLI" Value="NotOnRanToCompletion" />
      <MemberSignature Language="F#" Value="NotOnRanToCompletion = 65536" Usage="System.Threading.Tasks.TaskContinuationOptions.NotOnRanToCompletion" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskContinuationOptions</ReturnType>
      </ReturnValue>
      <MemberValue>65536</MemberValue>
      <Docs>
        <summary>Określa, że zadania kontynuacji nie należy planować, jeśli jego poprzednik został zrealizowany. Poprzednik jest uruchamiany, jeśli jego <see cref="P:System.Threading.Tasks.Task.Status" /> właściwość została <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" />ukończona. Ta opcja jest nieprawidłowa dla kontynuacji wielozadania.</summary>
      </Docs>
    </Member>
    <Member MemberName="OnlyOnCanceled">
      <MemberSignature Language="C#" Value="OnlyOnCanceled" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Threading.Tasks.TaskContinuationOptions OnlyOnCanceled = int32(196608)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />
      <MemberSignature Language="VB.NET" Value="OnlyOnCanceled" />
      <MemberSignature Language="C++ CLI" Value="OnlyOnCanceled" />
      <MemberSignature Language="F#" Value="OnlyOnCanceled = 196608" Usage="System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskContinuationOptions</ReturnType>
      </ReturnValue>
      <MemberValue>196608</MemberValue>
      <Docs>
        <summary>Określa, że kontynuacja powinna zostać zaplanowana tylko wtedy, gdy jego poprzednik został anulowany.  Element poprzedzający jest anulowany <see cref="P:System.Threading.Tasks.Task.Status" /> , jeśli jego właściwość <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" />została ukończona. Ta opcja jest nieprawidłowa dla kontynuacji wielozadania.</summary>
      </Docs>
    </Member>
    <Member MemberName="OnlyOnFaulted">
      <MemberSignature Language="C#" Value="OnlyOnFaulted" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Threading.Tasks.TaskContinuationOptions OnlyOnFaulted = int32(327680)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnFaulted" />
      <MemberSignature Language="VB.NET" Value="OnlyOnFaulted" />
      <MemberSignature Language="C++ CLI" Value="OnlyOnFaulted" />
      <MemberSignature Language="F#" Value="OnlyOnFaulted = 327680" Usage="System.Threading.Tasks.TaskContinuationOptions.OnlyOnFaulted" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskContinuationOptions</ReturnType>
      </ReturnValue>
      <MemberValue>327680</MemberValue>
      <Docs>
        <summary>Określa, że zadanie kontynuacji powinno być zaplanowane tylko wtedy, gdy jego poprzednik wywołał nieobsłużony wyjątek. Element poprzedzający zgłasza nieobsłużony wyjątek, jeśli <see cref="P:System.Threading.Tasks.Task.Status" /> jego właściwość została <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" />ukończona.  
  
Opcja gwarantuje, że właściwość we poprzedzającym nie <see langword="null" />jest. <see cref="P:System.Threading.Tasks.Task.Exception" /> <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnFaulted" /> Tej właściwości można użyć do przechwycenia wyjątku i sprawdzenia, który wyjątek spowodował błąd zadania. Jeśli nie masz dostępu <see cref="P:System.Threading.Tasks.Task.Exception" /> do właściwości, wyjątek jest nieobsługiwany. Ponadto, jeśli próbujesz uzyskać dostęp <see cref="P:System.Threading.Tasks.Task`1.Result" /> do właściwości zadania, które zostało anulowane lub ma błąd, zostanie zgłoszony nowy wyjątek.  
  
Ta opcja jest nieprawidłowa dla kontynuacji wielozadania.</summary>
      </Docs>
    </Member>
    <Member MemberName="OnlyOnRanToCompletion">
      <MemberSignature Language="C#" Value="OnlyOnRanToCompletion" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Threading.Tasks.TaskContinuationOptions OnlyOnRanToCompletion = int32(393216)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnRanToCompletion" />
      <MemberSignature Language="VB.NET" Value="OnlyOnRanToCompletion" />
      <MemberSignature Language="C++ CLI" Value="OnlyOnRanToCompletion" />
      <MemberSignature Language="F#" Value="OnlyOnRanToCompletion = 393216" Usage="System.Threading.Tasks.TaskContinuationOptions.OnlyOnRanToCompletion" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskContinuationOptions</ReturnType>
      </ReturnValue>
      <MemberValue>393216</MemberValue>
      <Docs>
        <summary>Określa, że kontynuacja powinna zostać zaplanowana tylko wtedy, gdy jego poprzednik został wykonany do ukończenia. Poprzednik jest uruchamiany, jeśli jego <see cref="P:System.Threading.Tasks.Task.Status" /> właściwość została <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" />ukończona. Ta opcja jest nieprawidłowa dla kontynuacji wielozadania.</summary>
      </Docs>
    </Member>
    <Member MemberName="PreferFairness">
      <MemberSignature Language="C#" Value="PreferFairness" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Threading.Tasks.TaskContinuationOptions PreferFairness = int32(1)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.Tasks.TaskContinuationOptions.PreferFairness" />
      <MemberSignature Language="VB.NET" Value="PreferFairness" />
      <MemberSignature Language="C++ CLI" Value="PreferFairness" />
      <MemberSignature Language="F#" Value="PreferFairness = 1" Usage="System.Threading.Tasks.TaskContinuationOptions.PreferFairness" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskContinuationOptions</ReturnType>
      </ReturnValue>
      <MemberValue>1</MemberValue>
      <Docs>
        <summary>Wskazówka <see cref="T:System.Threading.Tasks.TaskScheduler" /> do harmonogramu zadań w kolejności, w jakiej zostały zaplanowane, aby zadania zaplanowane wcześniej były bardziej podobne do uruchomienia, a zadania zaplanowane później mogą być uruchamiane później.</summary>
      </Docs>
    </Member>
    <Member MemberName="RunContinuationsAsynchronously">
      <MemberSignature Language="C#" Value="RunContinuationsAsynchronously" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Threading.Tasks.TaskContinuationOptions RunContinuationsAsynchronously = int32(64)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.Tasks.TaskContinuationOptions.RunContinuationsAsynchronously" />
      <MemberSignature Language="VB.NET" Value="RunContinuationsAsynchronously" />
      <MemberSignature Language="C++ CLI" Value="RunContinuationsAsynchronously" />
      <MemberSignature Language="F#" Value="RunContinuationsAsynchronously = 64" Usage="System.Threading.Tasks.TaskContinuationOptions.RunContinuationsAsynchronously" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskContinuationOptions</ReturnType>
      </ReturnValue>
      <MemberValue>64</MemberValue>
      <Docs>
        <summary>Określa, że zadanie kontynuacji powinno być uruchamiane asynchronicznie.  Ta opcja ma pierwszeństwo <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />przed.</summary>
      </Docs>
    </Member>
  </Members>
</Type>

<Type Name="TaskScheduler" FullName="System.Threading.Tasks.TaskScheduler">
  <Metadata><Meta Name="ms.openlocfilehash" Value="87f581e4666a42d1ea6037aa75f9d64296c41160" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69229837" /></Metadata><TypeSignature Language="C#" Value="public abstract class TaskScheduler" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit TaskScheduler extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.TaskScheduler" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class TaskScheduler" />
  <TypeSignature Language="C++ CLI" Value="public ref class TaskScheduler abstract" />
  <TypeSignature Language="F#" Value="type TaskScheduler = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Id={Id}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Threading.Tasks.TaskScheduler/SystemThreadingTasks_TaskSchedulerDebugView))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje obiekt obsługujący zadania kolejkowania zadań na niskim poziomie w wątkach.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wystąpienie <xref:System.Threading.Tasks.TaskScheduler> klasy reprezentuje harmonogram zadań. Harmonogram zadań zapewnia, że zadanie zadania zostanie ostatecznie wykonane.  
  
 Domyślny harmonogram zadań jest oparty na puli wątków .NET Framework 4, która zapewnia kradzieży w ramach równoważenia obciążenia, iniekcję wątków/wycofanie w celu zapewnienia maksymalnej przepływności i ogólną wydajność. Powinno to być wystarczające dla większości scenariuszy.  
  
 <xref:System.Threading.Tasks.TaskScheduler> Klasa służy również jako punkt rozszerzenia dla wszystkich dostosowywalnych logiki planowania.  Obejmuje to takie mechanizmy jak planowanie zadania do wykonania oraz sposób ujawniania zaplanowanych zadań w debugerach. Jeśli jest wymagana specjalna funkcja, można utworzyć harmonogram niestandardowy i włączyć go dla określonych zadań lub zapytań.  
  
 W tym temacie:  
[Domyślny harmonogram zadań i Pula wątków](#Default)  
 [Kolejka globalna a kolejki lokalne](#Queues)  
 [Kradzież służbowa](#Stealing)  
 [Zadania długotrwałe](#LongRunning)  
 [Dekreślenie zadań](#Inlining)  
[Określanie kontekstu synchronizacji](#Sync)  
  
<a name="Default"></a>   
## <a name="the-default-task-scheduler-and-the-thread-pool"></a>Domyślny harmonogram zadań i Pula wątków  
 Domyślny harmonogram dla biblioteki zadań równoległych i PLINQ używa puli wątków .NET Framework, która jest reprezentowana przez <xref:System.Threading.ThreadPool> klasę, do kolejki i wykonywania pracy. Pula wątków używa informacji dostarczonych przez <xref:System.Threading.Tasks.Task> typ do wydajnej obsługi równoległości (długotrwałych jednostek pracy), które często przedstawiają zadania równoległe i zapytania.  
  
<a name="Queues"></a>   
### <a name="the-global-queue-vs-local-queues"></a>Kolejka globalna a kolejki lokalne  
 Pula wątków utrzymuje globalną kolejkę roboczą FIFO (pierwszy na zewnątrz) dla wątków w każdej domenie aplikacji. Za każdym razem, gdy <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A?displayProperty=nameWithType> program wywołuje <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A?displayProperty=nameWithType>metodę (lub), praca jest umieszczana w tej kolejce udostępnionej i ostatecznie odwołuje się do następnego wątku, który staną się dostępne. Począwszy od .NET Framework 4, ta kolejka została ulepszona w celu użycia algorytmu bez blokady podobnego <xref:System.Collections.Concurrent.ConcurrentQueue%601> do klasy. Korzystając z tej implementacji bezpłatnej blokady, Pula wątków poświęca mniej czasu na kolejki i usuwa elementy robocze z kolejki. Ta korzyść wydajności jest dostępna dla wszystkich programów, które używają puli wątków.  
  
 Zadania najwyższego poziomu, które są zadaniami, które nie są tworzone w kontekście innego zadania, są umieszczane w kolejce globalnej tak samo jak każdy inny element roboczy. Jednak zadania zagnieżdżone lub podrzędne, które są tworzone w kontekście innego zadania, są obsługiwane bardzo inaczej. Zadanie podrzędne lub zagnieżdżone jest umieszczane w lokalnej kolejce, która jest specyficzna dla wątku, w którym wykonywane jest zadanie nadrzędne. Zadanie nadrzędne może być zadaniem najwyższego poziomu lub może być również elementem podrzędnym innego zadania. Gdy ten wątek jest gotowy do dalszej pracy, najpierw szuka kolejki lokalnej. Jeśli elementy robocze czekają na to, można uzyskać do nich dostęp szybko. Kolejki lokalne są dostępne w pierwszej kolejności (LIFO) w celu zachowania lokalizacji pamięci podręcznej i zmniejszenia rywalizacji. Aby uzyskać więcej informacji o zadaniach podrzędnych i zadaniach zagnieżdżonych, zobacz [dołączone i odłączone zadania podrzędne](~/docs/standard/parallel-programming/attached-and-detached-child-tasks.md).  
  
 Użycie kolejek lokalnych nie tylko zmniejsza nacisk na kolejkę globalną, ale również korzysta z lokalizacji danych. Elementy robocze w lokalnej kolejce często odwołują się do struktur danych, które znajdują się fizycznie blisko siebie w pamięci. W takich przypadkach dane znajdują się już w pamięci podręcznej po wykonaniu pierwszego zadania i można szybko uzyskać do niego dostęp. Zarówno [Parallel LINQ (PLINQ)](~/docs/standard/parallel-programming/parallel-linq-plinq.md) , jak <xref:System.Threading.Tasks.Parallel> i Klasa używają zagnieżdżonych zadań i podrzędnych zadań i osiągają znaczący przyspieszenia przy użyciu lokalnych kolejek roboczych.  
  
<a name="Stealing"></a>   
### <a name="work-stealing"></a>Kradzież służbowa  
 Począwszy od .NET Framework 4, Pula wątków zawiera również algorytm kradzieży pracy, który pomaga upewnić się, że żadne wątki nie są bezczynne, a inne nadal pracują w swoich kolejkach. Gdy wątek puli wątków jest gotowy do większej pracy, najpierw przegląda on szefa kolejki lokalnej, a następnie w kolejce globalnej, a następnie w kolejkach lokalnych innych wątków. Jeśli odnajdzie element roboczy w lokalnej kolejce innego wątku, najpierw zastosuje heurystykę, aby upewnić się, że może uruchamiać pracę wydajnie. Jeśli to możliwe, oddziałuje element roboczy z ogona (w kolejności FIFO). Pozwala to zmniejszyć rywalizację na każdą lokalną kolejkę i zachowuje miejscowość danych. Ta architektura ułatwia Równoważenie obciążenia puli wątków wydajniej niż przeszłe wersje.  
  
<a name="LongRunning"></a>   
### <a name="long-running-tasks"></a>Zadania długotrwałe  
 Można jawnie uniemożliwić umieszczenie zadania w kolejce lokalnej. Na przykład może być wiadomo, że określony element roboczy zostanie uruchomiony przez stosunkowo długi czas i będzie można zablokować wszystkie inne elementy robocze w lokalnej kolejce. W takim przypadku można określić <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType> opcję, która udostępnia wskazówkę do harmonogramu, że dodatkowy wątek może być wymagany dla zadania, aby nie blokował postępów innych wątków ani elementów roboczych w lokalnej kolejce. Korzystając z tej opcji, można uniknąć całkowitego wykorzystania puli wątków, łącznie z kolejkami globalnymi i lokalnymi.  
  
<a name="Inlining"></a>   
### <a name="task-inlining"></a>Dekreślenie zadań  
 W niektórych przypadkach, gdy <xref:System.Threading.Tasks.Task> czeka, może być wykonywane synchronicznie w wątku, który wykonuje operację oczekiwania. Zwiększa to wydajność, uniemożliwiając konieczność dodatkowego wątku i zamiast niego przy użyciu istniejącego wątku, który mógłby zostać zablokowany w inny sposób. Aby zapobiec błędom ze względu na współużytkowania wątkowości, wykreślenie zadań następuje tylko wtedy, gdy obiekt docelowy oczekiwania zostanie znaleziony w lokalnej kolejce wątku.  
  
<a name="Sync"></a>   
## <a name="specifying-a-synchronization-context"></a>Określanie kontekstu synchronizacji  
 Możesz użyć <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType> metody, aby określić, że zadanie powinno zostać zaplanowane do uruchomienia w określonym wątku. Jest to przydatne w strukturach, takich jak Windows Forms i Windows Presentation Foundation, gdzie dostęp do obiektów interfejsu użytkownika jest często ograniczony do kodu, który jest uruchomiony w tym samym wątku, w którym został utworzony obiekt interfejsu użytkownika.  
  
 W poniższym przykładzie użyto <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType> metody w aplikacji Windows Presentation Foundation (WPF) do zaplanowania zadania w tym samym wątku, w którym został utworzony formant interfejsu użytkownika.   Przykład tworzy mozaikę obrazów, które są losowo wybierane z określonego katalogu. Obiekty WPF są używane do ładowania obrazów i ich zmiany. Nieprzetworzone piksele są następnie przenoszone do zadania, które <xref:System.Threading.Tasks.Parallel.For%2A> używa pętli w celu zapisania danych pikseli w dużej jednobajtowej tablicy. Synchronizacja nie jest wymagana, ponieważ dwa kafelki nie zajmują tych samych elementów tablicy. Kafelki można także pisać w dowolnej kolejności, ponieważ ich położenie jest obliczane niezależnie od innego kafelka. Duża tablica jest następnie przenoszona do zadania uruchamianego w wątku interfejsu użytkownika, gdzie dane pikseli są ładowane do kontrolki obrazu.  
  
 Przykład przenosi dane z wątku interfejsu użytkownika, modyfikuje go przy użyciu pętli równoległych <xref:System.Threading.Tasks.Task> i obiektów, a następnie przekazuje je z powrotem do zadania uruchomionego w wątku interfejsu użytkownika. Takie podejście jest przydatne, gdy konieczne jest użycie biblioteki zadań równoległych do wykonywania operacji, które nie są obsługiwane przez interfejs API WPF, lub nie są wystarczająco szybkie. Innym sposobem na utworzenie mozaiki obrazu w WPF jest użycie <xref:System.Windows.Controls.WrapPanel?displayProperty=nameWithType> kontrolki i dodanie do niej obrazów. <xref:System.Windows.Controls.WrapPanel> Obsługuje rozmieszczenie kafelków. Jednak ta operacja może zostać wykonana tylko w wątku interfejsu użytkownika.  
  
 [!code-csharp[TPL_SyncContext#01](~/samples/snippets/csharp/VS_Snippets_Misc/tpl_synccontext/cs/mainwindow.xaml.cs#01)]
 [!code-vb[TPL_SyncContext#01](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl_synccontext/vb/MainWindow.xaml.vb#01)]  
  
 Aby utworzyć przykład, Utwórz projekt aplikacji WPF w programie Visual Studio i nadaj mu nazwę WPF_CS1 (dla projektu C# WPF) lub WPF_VB1 (dla projektu WPF Visual Basic). Następnie wykonaj poniższe czynności:  
  
1. W widoku projektu przeciągnij <xref:System.Windows.Controls.Image> kontrolkę z **przybornika** w lewym górnym rogu powierzchni projektowej. W polu tekstowym **Nazwa** okna **Właściwości** Nadaj formantowi nazwę "Image".    
  
2. Przeciągnij kontrolkę z przybornika do lewej dolnej części okna aplikacji. **** <xref:System.Windows.Controls.Button> W widoku XAML Określ <xref:System.Windows.Controls.ContentControl.Content%2A> właściwość przycisku jako "Utwórz mozaikę" i określ jej <xref:System.Windows.FrameworkElement.Width> właściwość jako "100". Połącz zdarzenie z programem `<Button>` obsługi `Click="button_Click"` zdarzeń zdefiniowanym w kodzie przykład poprzez dodanie do elementu. `button_Click` <xref:System.Windows.Controls.Primitives.ButtonBase.Click> W polu tekstowym **Nazwa** okna **Właściwości** Nazwij kontrolkę "przycisk".  
  
3. Zamień całą zawartość pliku MainWindow.xaml.cs lub MainWindow. XAML. vb na kod z tego przykładu. W przypadku C# projektu WPF upewnij się, że nazwa obszaru roboczego jest zgodna z nazwą projektu. 
  
4. Przykład odczytuje obrazy JPEG z katalogu o nazwie obrazy\\C:\Users\Public\Pictures\Sample. Utwórz katalog i umieść w nim kilka obrazów albo zmień ścieżkę, aby odwoływać się do innego katalogu, który zawiera obrazy. 
  
Ten przykład ma pewne ograniczenia. Na przykład obsługiwane są tylko obrazy 32-bitów-na pikseli. obrazy w innych formatach są uszkodzone przez <xref:System.Windows.Media.Imaging.BitmapImage> obiekt podczas operacji zmiany rozmiarów. Ponadto obrazy źródłowe muszą być większe niż rozmiar kafelka. W tym celu można dodać funkcję do obsługi wielu formatów pikseli i rozmiarów plików.  
  
## Examples  
 Poniższy przykład jest pobierany z [przykładów dotyczących programowania równoległego przy użyciu .NET Framework 4](https://go.microsoft.com/fwlink/?LinkID=165717) w witrynie sieci Web galerii kodu MSDN.  Tworzy niestandardowy harmonogram zadań, który ogranicza liczbę wątków używanych przez aplikację. Następnie uruchamia dwa zestawy zadań i wyświetla informacje o zadaniu i wątku, w którym zadanie jest wykonywane.  
  
 [!code-csharp[TPL_Schedulers#02](~/samples/snippets/csharp/VS_Snippets_Misc/tpl_schedulers/cs/limitex1.cs#02)]
 [!code-vb[TPL_Schedulers#02](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl_schedulers/vb/module2.vb#02)]  
  
 Dodatkowo kilka przykładowych harmonogramów zadań jest dostępnych w galerii kodu: [Przykłady programowania równoległego w .NET Framework 4](https://go.microsoft.com/fwlink/?LinkID=165717).  
  
 ]]></format>
    </remarks>
    <threadsafe>Wszystkie elementy członkowskie typu abstrakcyjnego <see cref="T:System.Threading.Tasks.TaskScheduler" /> są bezpieczne dla wątków i mogą być używane jednocześnie z wielu wątków.</threadsafe>
    <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
    <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteka zadań równoległych (TPL)</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected TaskScheduler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; TaskScheduler();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Threading.Tasks.TaskScheduler" />Inicjuje.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteka zadań równoległych (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskScheduler Current" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Current" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Current As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::TaskScheduler ^ Current { System::Threading::Tasks::TaskScheduler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskScheduler.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Threading.Tasks.TaskScheduler" /> Pobiera skojarzone z aktualnie wykonywanym zadaniem.</summary>
        <value><see cref="T:System.Threading.Tasks.TaskScheduler" /> Zwraca skojarzoną z aktualnie wykonywanym zadaniem.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy nie wywołano z poziomu zadania, <xref:System.Threading.Tasks.TaskScheduler.Current%2A> program <xref:System.Threading.Tasks.TaskScheduler.Default%2A> zwróci harmonogram.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Threading.Tasks.TaskScheduler>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteka zadań równoległych (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskScheduler Default" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::TaskScheduler ^ Default { System::Threading::Tasks::TaskScheduler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Default : System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskScheduler.Default" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera domyślne <see cref="T:System.Threading.Tasks.TaskScheduler" /> wystąpienie dostarczone przez .NET Framework.</summary>
        <value>Zwraca wystąpienie domyślne <see cref="T:System.Threading.Tasks.TaskScheduler" /> .</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji, zobacz <xref:System.Threading.Tasks.TaskScheduler>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteka zadań równoległych (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~TaskScheduler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!TaskScheduler ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="taskScheduler.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszystkie zasoby skojarzone z tym harmonogramem.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FromCurrentSynchronizationContext">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler FromCurrentSynchronizationContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.TaskScheduler FromCurrentSynchronizationContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromCurrentSynchronizationContext () As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::TaskScheduler ^ FromCurrentSynchronizationContext();" />
      <MemberSignature Language="F#" Value="static member FromCurrentSynchronizationContext : unit -&gt; System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy skojarzenie z bieżącym <see cref="T:System.Threading.SynchronizationContext" />. <see cref="T:System.Threading.Tasks.TaskScheduler" /></summary>
        <returns>Skojarzone z bieżącym <see cref="T:System.Threading.SynchronizationContext" />, zgodnie z oczekiwaniami <see cref="P:System.Threading.SynchronizationContext.Current" />. <see cref="T:System.Threading.Tasks.TaskScheduler" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszystkie <xref:System.Threading.Tasks.Task> wystąpienia dodane do zwróconego harmonogramu będą wykonywane przez wywołanie <xref:System.Threading.SynchronizationContext.Post%2A> metody w tym kontekście.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Threading.Tasks.TaskScheduler>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nie można użyć bieżącego SynchronizationContext jako elementu TaskScheduler.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteka zadań równoległych (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="GetScheduledTasks">
      <MemberSignature Language="C#" Value="protected abstract System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt; GetScheduledTasks ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task&gt; GetScheduledTasks() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetScheduledTasks () As IEnumerable(Of Task)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task ^&gt; ^ GetScheduledTasks();" />
      <MemberSignature Language="F#" Value="abstract member GetScheduledTasks : unit -&gt; seq&lt;System.Threading.Tasks.Task&gt;" Usage="taskScheduler.GetScheduledTasks " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>W przypadku obsługi debugera program generuje wyliczalne <see cref="T:System.Threading.Tasks.Task" /> wystąpienia, które są obecnie umieszczane w kolejce do harmonogramu, oczekując na wykonanie.</summary>
        <returns>Wartość wyliczalna, która umożliwia debugerowi przechodzenie zadań aktualnie umieszczonych w kolejce do tego harmonogramu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasa pochodna <xref:System.Threading.Tasks.TaskScheduler> implementowania tej metody w celu obsługi integracji z debugerami. Ta metoda będzie wywoływana tylko przez .NET Framework, gdy debuger zażąda dostępu do danych. Wyliczalne zwrócenia będzie przenoszone przez narzędzia debugowania w celu uzyskania dostępu do zadań znajdujących się obecnie w kolejce do tego harmonogramu, co umożliwia debugerowi udostępnienie informacji w interfejsie użytkownika.  
  
 Należy pamiętać, że w przypadku wywołania tej metody wszystkie pozostałe wątki w procesie zostaną zamrożone. W związku z tym ważne jest, aby uniknąć synchronizacji z innymi wątkami, które mogą prowadzić do blokowania. Jeśli wymagana jest synchronizacja i nie można uzyskać blokady w tej metodzie, należy zgłosić wyjątek, aby debuger nie blokował. Poniższy przykład przedstawia jedną z C#możliwych metod:
  
```csharp
protected override IEnumerable<Task> GetScheduledTasks()  
{  
    bool lockTaken = false;  
    try  
    {  
        Monitor.TryEnter(_syncObj, ref lockTaken);  
        if (lockTaken)  
        {  
            return _tasks.ToArray();  
        }  
        else throw new NotSupportedException();  
    }  
    finally  
    {  
    if (lockTaken) Monitor.Exit(_syncObj);  
    }}  
```  
  
 Ponadto ta metoda i wyliczalne zwracane nie mogą modyfikować żadnego stanu widocznego globalnie.  
  
 Zwrócony wyliczalny nigdy nie powinien mieć wartości null. Jeśli obecnie nie ma żadnych zadań w kolejce, zamiast tego należy zwrócić pustą wartością wyliczalną.  
  
 Deweloperzy implementujący debugery niestandardowe nie powinni wywoływać tej metody bezpośrednio, ale powinny używać metody `GetScheduledTasksForDebugger` otoki wewnętrznej:. `internal Task[] GetScheduledTasksForDebugger()` Ta metoda otoki zwraca tablicę zadań zamiast wartości wyliczalnej. Aby pobrać listę aktywnych harmonogramów, użyj metody `internal static TaskScheduler[] GetTaskSchedulersForDebugger()`wewnętrznej. Ta metoda statyczna zwraca tablicę wszystkich aktywnych <xref:System.Threading.Tasks.TaskScheduler> wystąpień. Następnie można użyć `GetScheduledTasksForDebugger` każdego wystąpienia harmonogramu do pobrania listy zaplanowanych zadań.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Ten harmonogram nie może w tej chwili wygenerować listy zadań znajdujących się w kolejce.</exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteka zadań równoległych (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.Threading.Tasks.TaskScheduler.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera unikatowy identyfikator dla tego <see cref="T:System.Threading.Tasks.TaskScheduler" />elementu.</summary>
        <value>Zwraca unikatowy identyfikator dla tego <see cref="T:System.Threading.Tasks.TaskScheduler" />elementu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji, zobacz <xref:System.Threading.Tasks.TaskScheduler>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteka zadań równoległych (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="MaximumConcurrencyLevel">
      <MemberSignature Language="C#" Value="public virtual int MaximumConcurrencyLevel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaximumConcurrencyLevel" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property MaximumConcurrencyLevel As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int MaximumConcurrencyLevel { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MaximumConcurrencyLevel : int" Usage="System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wskazuje maksymalny poziom <see cref="T:System.Threading.Tasks.TaskScheduler" /> współbieżności, który jest w stanie obsłużyć.</summary>
        <value>Zwraca liczbę całkowitą reprezentującą maksymalny poziom współbieżności. Domyślny harmonogram zwraca wartość <see cref="F:System.Int32.MaxValue" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji, zobacz <xref:System.Threading.Tasks.TaskScheduler>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteka zadań równoległych (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="QueueTask">
      <MemberSignature Language="C#" Value="protected internal abstract void QueueTask (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void QueueTask(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract void QueueTask(System::Threading::Tasks::Task ^ task);" />
      <MemberSignature Language="F#" Value="abstract member QueueTask : System.Threading.Tasks.Task -&gt; unit" Usage="taskScheduler.QueueTask task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task"><see cref="T:System.Threading.Tasks.Task" /> Do umieszczenia w kolejce.</param>
        <summary>Kolejkuje <see cref="T:System.Threading.Tasks.Task" /> do harmonogramu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasa pochodna <xref:System.Threading.Tasks.TaskScheduler> implementowania tej metody w celu akceptowania zadań zaplanowanych w harmonogramie.  
  
 W przypadku typowej implementacji zadanie jest przechowywane w wewnętrznej strukturze danych, które będzie obsługiwany przez wątki, które będą wykonywały te zadania w pewnym czasie w przyszłości.  
  
 Ta metoda jest przeznaczona tylko do wywoływania przez .NET Framework i nie powinna być wywoływana bezpośrednio przez klasę pochodną. Jest to niezbędne do utrzymania spójności systemu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="task" /> Argument ma wartość null.</exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteka zadań równoległych (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="TryDequeue">
      <MemberSignature Language="C#" Value="protected internal virtual bool TryDequeue (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool TryDequeue(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool TryDequeue(System::Threading::Tasks::Task ^ task);" />
      <MemberSignature Language="F#" Value="abstract member TryDequeue : System.Threading.Tasks.Task -&gt; bool&#xA;override this.TryDequeue : System.Threading.Tasks.Task -&gt; bool" Usage="taskScheduler.TryDequeue task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task"><see cref="T:System.Threading.Tasks.Task" /> Ma zostać usunięty z kolejki.</param>
        <summary>Próbuje usunąć z kolejki <see cref="T:System.Threading.Tasks.Task" /> element, który wcześniej został umieszczony w kolejce do tego harmonogramu.</summary>
        <returns>Wartość logiczna określająca, czy <paramref name="task" /> argument został pomyślnie usunięty z kolejki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji, zobacz <xref:System.Threading.Tasks.TaskScheduler>.  
  
 Ta metoda może być wykonywana w bloku finally; w związku z tym powinna zostać zwrócona tak szybko, jak to możliwe <xref:System.Threading.CancellationTokenRegistration> , aby wszystkie zasoby, takie jak obiekty, mogły zostać zlikwidowane w odpowiednim czasie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="task" /> Argument ma wartość null.</exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteka zadań równoległych (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="TryExecuteTask">
      <MemberSignature Language="C#" Value="protected bool TryExecuteTask (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool TryExecuteTask(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool TryExecuteTask(System::Threading::Tasks::Task ^ task);" />
      <MemberSignature Language="F#" Value="member this.TryExecuteTask : System.Threading.Tasks.Task -&gt; bool" Usage="taskScheduler.TryExecuteTask task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task"><see cref="T:System.Threading.Tasks.Task" /> Obiekt, który ma zostać wykonany.</param>
        <summary>Próbuje wykonać podane <see cref="T:System.Threading.Tasks.Task" /> w tym harmonogramie.</summary>
        <returns>Wartość logiczna, która ma wartość <paramref name="task" /> true, jeśli została wykonana pomyślnie, wartość false, jeśli nie została. Typową przyczyną niepowodzenia wykonania jest to, że zadanie zostało wykonane wcześniej lub jest w trakcie wykonywania przez inny wątek.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Implementacje usługi Scheduler są <xref:System.Threading.Tasks.Task> dostarczane z wystąpieniami, które mają <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A> być wykonane za <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline%2A> pomocą metody lub metody. Gdy harmonogram uzna, że jest on właściwy do uruchomienia podanego <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> zadania, należy do tego celu użyć. TryExecuteTask obsługuje wszystkie aspekty wykonywania zadania, w tym wywołania akcji, obsługę wyjątków, zarządzanie stanami i kontrolę cyklu życia.  
  
 <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A>może być używany tylko w przypadku zadań udostępnionych w tym harmonogramie przez infrastrukturę .NET Framework. Nie należy używać go do wykonywania dowolnych zadań uzyskanych za poorednictwem mechanizmów niestandardowych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nie <paramref name="task" /> jest skojarzony z tym harmonogramem.</exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteka zadań równoległych (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="TryExecuteTaskInline">
      <MemberSignature Language="C#" Value="protected abstract bool TryExecuteTaskInline (System.Threading.Tasks.Task task, bool taskWasPreviouslyQueued);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool TryExecuteTaskInline(class System.Threading.Tasks.Task task, bool taskWasPreviouslyQueued) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool TryExecuteTaskInline(System::Threading::Tasks::Task ^ task, bool taskWasPreviouslyQueued);" />
      <MemberSignature Language="F#" Value="abstract member TryExecuteTaskInline : System.Threading.Tasks.Task * bool -&gt; bool" Usage="taskScheduler.TryExecuteTaskInline (task, taskWasPreviouslyQueued)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
        <Parameter Name="taskWasPreviouslyQueued" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="task"><see cref="T:System.Threading.Tasks.Task" /> Do wykonania.</param>
        <param name="taskWasPreviouslyQueued">Wartość logiczna określająca, czy zadanie zostało wcześniej dodane do kolejki. Jeśli ten parametr ma wartość true, zadanie mogło wcześniej znajdować się w kolejce (zaplanowane); Jeśli wartość jest równa false, to zadanie jest znane, aby nie zostało dodane do kolejki i to wywołanie jest wykonywane w celu wykonania zadania wbudowanego bez jego kolejkowania.</param>
        <summary>Określa, czy dostarczone <see cref="T:System.Threading.Tasks.Task" /> może być wykonywane synchronicznie w tym wywołaniu, a jeśli to możliwe, wykonuje je.</summary>
        <returns>Wartość logiczna wskazująca, czy zadanie zostało wykonane wewnętrznie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasa pochodna <xref:System.Threading.Tasks.TaskScheduler> implementowania tej funkcji do obsługi wbudowanego wykonywania zadania w wątku, który inicjuje oczekiwanie na obiekt zadania. Wykonywanie wbudowane jest opcjonalne i żądanie może zostać odrzucone przez zwrócenie wartości false. Jednak im więcej zadań, które można przeskalować, tym lepsze będzie skalowanie harmonogramu. W rzeczywistości harmonogram, który jest zbyt mały, może być podatny na zakleszczenia. Właściwa implementacja powinna mieć pewność, że żądanie wykonywane w ramach zasad gwarantowanych przez harmonogram może być pomyślnie wbudowane. Na przykład jeśli harmonogram używa dedykowanego wątku do wykonywania zadań, wszystkie żądania wykreślania z tego wątku powinny zakończyć się powodzeniem.  
  
 Jeśli harmonogram zdecyduje się wykonać wykonywanie w wierszu, należy to zrobić przez wywołanie <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> metody bazowej TaskScheduler z podanym obiektem zadania i propagowanie wartości zwracanej. Może być również konieczne, aby harmonogram usunął zadanie wbudowane z wewnętrznych struktur danych, jeśli zdecyduje się on przestrzegać żądania wykreślania. Należy jednak zauważyć, że w pewnych okolicznościach harmonogram może być proszony o wbudowanie zadania, które nie zostało wcześniej dostarczone z tą <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A> metodą.  
  
 Harmonogram pochodny jest odpowiedzialny za upewnienie się, że wątek wywołujący jest odpowiedni do wykonywania danego zadania, o ile ma to zastosowanie do własnych zasad planowania i wykonywania.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Threading.Tasks.TaskScheduler>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="task" /> Argument ma wartość null.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="task" /> Zostało już wykonane.</exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteka zadań równoległych (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="UnobservedTaskException">
      <MemberSignature Language="C#" Value="public static event EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; UnobservedTaskException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; UnobservedTaskException" />
      <MemberSignature Language="DocId" Value="E:System.Threading.Tasks.TaskScheduler.UnobservedTaskException" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event UnobservedTaskException As EventHandler(Of UnobservedTaskExceptionEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler&lt;System::Threading::Tasks::UnobservedTaskExceptionEventArgs ^&gt; ^ UnobservedTaskException;" />
      <MemberSignature Language="F#" Value="member this.UnobservedTaskException : EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; " Usage="member this.UnobservedTaskException : System.EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wyjątek niezauważalnego zadania wyzwala zasady eskalacji wyjątku, które domyślnie spowodują przerwanie procesu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie dla całej domeny aplikacji udostępnia mechanizm zapobiegania zasadom eskalacji wyjątków (domyślnie przerywa proces) od wyzwalania.  
  
 Aby ułatwić deweloperom pisanie kodu asynchronicznego na podstawie zadań, [!INCLUDE[net_v45](~/includes/net-v45-md.md)] zmiany domyślne zachowanie wyjątków dla niezauważalnych wyjątków. Chociaż niezauważalne wyjątki nadal zgłaszają <xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException> wyjątek, proces nie zostanie domyślnie zakończony. Zamiast tego wyjątek jest obsługiwany przez środowisko uruchomieniowe po wywołaniu zdarzenia, niezależnie od tego, czy program obsługi zdarzeń obserwuje wyjątek. Takie zachowanie można skonfigurować. Począwszy od [`<ThrowUnobservedTaskExceptions>`,można](~/docs/framework/configure-apps/file-schema/runtime/throwunobservedtaskexceptions-element.md) użyć elementu konfiguracji, aby przywrócić zachowanie [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] i zakończyć proces: [!INCLUDE[net_v45](~/includes/net-v45-md.md)]  
  
```xml  
<configuration>   
   <runtime>   
      <ThrowUnobservedTaskExceptions enabled="true"/>   
   </runtime>   
</configuration>  
  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteka zadań równoległych (TPL)</related>
        <related type="Article" href="~/docs/framework/configure-apps/file-schema/runtime/throwunobservedtaskexceptions-element.md">&lt;ThrowUnobservedTaskExceptions&gt; , element</related>
      </Docs>
    </Member>
  </Members>
</Type>

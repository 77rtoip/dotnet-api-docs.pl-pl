<Type Name="TaskScheduler" FullName="System.Threading.Tasks.TaskScheduler">
  <Metadata><Meta Name="ms.openlocfilehash" Value="f341693f0b4921e6a0676d39d785574747332f84" /><Meta Name="ms.sourcegitcommit" Value="954560a1b131dce1872e29ce5c01cd9f2c927f11" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="01/11/2019" /><Meta Name="ms.locfileid" Value="54234790" /></Metadata><TypeSignature Language="C#" Value="public abstract class TaskScheduler" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit TaskScheduler extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.TaskScheduler" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class TaskScheduler" />
  <TypeSignature Language="C++ CLI" Value="public ref class TaskScheduler abstract" />
  <TypeSignature Language="F#" Value="type TaskScheduler = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Id={Id}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Threading.Tasks.TaskScheduler/SystemThreadingTasks_TaskSchedulerDebugView))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="f31b3-101">Reprezentuje obiekt, który obsługuje niskiego poziomu pracy kolejkowania zadania na wątki.</span><span class="sxs-lookup"><span data-stu-id="f31b3-101">Represents an object that handles the low-level work of queuing tasks onto threads.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f31b3-102">Wystąpienie <xref:System.Threading.Tasks.TaskScheduler> klasa reprezentuje harmonogramu zadań.</span><span class="sxs-lookup"><span data-stu-id="f31b3-102">An instance of the <xref:System.Threading.Tasks.TaskScheduler> class represents a task scheduler.</span></span> <span data-ttu-id="f31b3-103">Harmonogram zadań zapewnia, że pracy zadania jest wykonywana po pewnym czasie.</span><span class="sxs-lookup"><span data-stu-id="f31b3-103">A task scheduler ensures that the work of a task is eventually executed.</span></span>  
  
 <span data-ttu-id="f31b3-104">Domyślnego harmonogramu zadań zależy od puli wątków programu .NET Framework 4 zawiera kradzież pracy dla równoważenia obciążenia, wątek iniekcji/wycofania dla maksymalnej przepustowości i ogólne dobrą wydajność.</span><span class="sxs-lookup"><span data-stu-id="f31b3-104">The default task scheduler is based on the .NET Framework 4 thread pool, which provides work-stealing for load-balancing, thread injection/retirement for maximum throughput, and overall good performance.</span></span> <span data-ttu-id="f31b3-105">Powinny być wystarczające dla większości scenariuszy.</span><span class="sxs-lookup"><span data-stu-id="f31b3-105">It should be sufficient for most scenarios.</span></span>  
  
 <span data-ttu-id="f31b3-106"><xref:System.Threading.Tasks.TaskScheduler> Klasy służy również jako punkt rozszerzenia na całą logikę planowania można dostosowywać.</span><span class="sxs-lookup"><span data-stu-id="f31b3-106">The <xref:System.Threading.Tasks.TaskScheduler> class also serves as the extension point for all customizable scheduling logic.</span></span>  <span data-ttu-id="f31b3-107">Obejmuje to mechanizmy, takich jak debugery mają być widoczne jak zaplanować zadanie do wykonania i jak z zaplanowanych zadań.</span><span class="sxs-lookup"><span data-stu-id="f31b3-107">This includes mechanisms such as how to schedule a task for execution, and how scheduled tasks should be exposed to debuggers.</span></span> <span data-ttu-id="f31b3-108">Jeśli potrzebujesz specjalne funkcje, można utworzyć niestandardowy harmonogram i włącz ją do określonych zadań lub zapytań.</span><span class="sxs-lookup"><span data-stu-id="f31b3-108">If you require special functionality, you can create a custom scheduler and enable it for specific tasks or queries.</span></span>  
  
 <span data-ttu-id="f31b3-109">W tym temacie:</span><span class="sxs-lookup"><span data-stu-id="f31b3-109">In this topic:</span></span>  
[<span data-ttu-id="f31b3-110">Domyślnego harmonogramu zadań i puli wątków</span><span class="sxs-lookup"><span data-stu-id="f31b3-110">The default task scheduler and the thread pool</span></span>](#Default)  
 [<span data-ttu-id="f31b3-111">Globalne kolejki, a lokalne kolejki</span><span class="sxs-lookup"><span data-stu-id="f31b3-111">The global queue vs. local queues</span></span>](#Queues)  
 [<span data-ttu-id="f31b3-112">Praca, kradzież</span><span class="sxs-lookup"><span data-stu-id="f31b3-112">Work stealing</span></span>](#Stealing)  
 [<span data-ttu-id="f31b3-113">Długotrwałych zadań</span><span class="sxs-lookup"><span data-stu-id="f31b3-113">Long-running tasks</span></span>](#LongRunning)  
 [<span data-ttu-id="f31b3-114">Wbudowanie zadania</span><span class="sxs-lookup"><span data-stu-id="f31b3-114">Task inlining</span></span>](#Inlining)  
[<span data-ttu-id="f31b3-115">Określanie kontekstu synchronizacji</span><span class="sxs-lookup"><span data-stu-id="f31b3-115">Specifying a synchronization context</span></span>](#Sync)  
  
<a name="Default"></a>   
## <a name="the-default-task-scheduler-and-the-thread-pool"></a><span data-ttu-id="f31b3-116">Domyślnego harmonogramu zadań i puli wątków</span><span class="sxs-lookup"><span data-stu-id="f31b3-116">The default task scheduler and the thread pool</span></span>  
 <span data-ttu-id="f31b3-117">Domyślny harmonogram bibliotece równoległych zadań i PLINQ korzysta z puli wątków .NET Framework, która jest reprezentowana przez <xref:System.Threading.ThreadPool> klasy do kolejki i wykonywania pracy.</span><span class="sxs-lookup"><span data-stu-id="f31b3-117">The default scheduler for the Task Parallel Library and PLINQ uses the .NET Framework thread pool, which is represented by the <xref:System.Threading.ThreadPool> class, to queue and execute work.</span></span> <span data-ttu-id="f31b3-118">Informacje, które są dostarczane przez korzysta z puli wątków <xref:System.Threading.Tasks.Task> typu, aby efektywnie obsługiwać równoległość drobnoziarnistą (krótkotrwałe jednostki pracy), który równoległe zadania i zapytania często reprezentują.</span><span class="sxs-lookup"><span data-stu-id="f31b3-118">The thread pool uses the information that is provided by the <xref:System.Threading.Tasks.Task> type to efficiently     support the fine-grained parallelism (short-lived units of work) that parallel tasks and queries often represent.</span></span>  
  
<a name="Queues"></a>   
### <a name="the-global-queue-vs-local-queues"></a><span data-ttu-id="f31b3-119">Globalne kolejki, a lokalne kolejki</span><span class="sxs-lookup"><span data-stu-id="f31b3-119">The global queue vs. local queues</span></span>  
 <span data-ttu-id="f31b3-120">Pula wątków utrzymuje globalne FIFO (pierwszy in, first-out) działają kolejki dla wątków w każdej domenie aplikacji.</span><span class="sxs-lookup"><span data-stu-id="f31b3-120">The thread pool maintains a global FIFO (first-in, first-out) work queue for threads in each application domain.</span></span> <span data-ttu-id="f31b3-121">Zawsze, gdy program wywołuje <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A?displayProperty=nameWithType> (lub <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A?displayProperty=nameWithType>) metody pracy jest umieścić w tej kolejce udostępnionych i ostatecznie cofnąć umieszczonych w kolejce na następny wątek, który stanie się dostępny.</span><span class="sxs-lookup"><span data-stu-id="f31b3-121">Whenever a program calls the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A?displayProperty=nameWithType> (or <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A?displayProperty=nameWithType>) method, the work is put on this shared queue and eventually de-queued onto the next thread that becomes available.</span></span> <span data-ttu-id="f31b3-122">Począwszy od programu .NET Framework 4, tej kolejki został ulepszony, aby używać algorytmu wolne od blokady, który przypomina <xref:System.Collections.Concurrent.ConcurrentQueue%601> klasy.</span><span class="sxs-lookup"><span data-stu-id="f31b3-122">Starting with the .NET Framework 4, this queue has been improved to use a lock-free algorithm that resembles the <xref:System.Collections.Concurrent.ConcurrentQueue%601> class.</span></span> <span data-ttu-id="f31b3-123">Przy użyciu tej implementacji wolne od blokady, puli wątków zużywa mniej czasu, gdy kolejki i usuwania kolejki elementów roboczych.</span><span class="sxs-lookup"><span data-stu-id="f31b3-123">By using this lock-free implementation, the thread pool spends less time when it queues and de-queues work items.</span></span> <span data-ttu-id="f31b3-124">Ta korzyść wydajności jest dostępny dla wszystkich programów, które używają puli wątków.</span><span class="sxs-lookup"><span data-stu-id="f31b3-124">This performance benefit is available to all programs that use the thread pool.</span></span>  
  
 <span data-ttu-id="f31b3-125">Zadania najwyższego poziomu, które są zadania, które nie są tworzone w kontekście innego zadania, są umieszczane w kolejce globalnego, podobnie jak dowolnej innej pozycji roboczej.</span><span class="sxs-lookup"><span data-stu-id="f31b3-125">Top-level tasks, which are tasks that are not created in the context of another task, are put on the global queue just like any other work item.</span></span> <span data-ttu-id="f31b3-126">Jednak zagnieżdżone lub zadań podrzędnych, które są tworzone w kontekście innego zadania, są obsługiwane odbywa się zupełnie inaczej.</span><span class="sxs-lookup"><span data-stu-id="f31b3-126">However, nested or child tasks, which are created in the context of another task, are handled quite differently.</span></span> <span data-ttu-id="f31b3-127">Podrzędne lub zadania zagnieżdżonego jest umieszczana w kolejce lokalnej, która zależy od do wątku, na którym jest wykonywane zadanie nadrzędne.</span><span class="sxs-lookup"><span data-stu-id="f31b3-127">A child or nested task is put on a local queue that is specific to the thread on which the parent task is executing.</span></span> <span data-ttu-id="f31b3-128">Zadanie nadrzędne może być zadania najwyższego poziomu, lub też może być elementem podrzędnym innego zadania.</span><span class="sxs-lookup"><span data-stu-id="f31b3-128">The parent task may be a top-level task or it also may be the child of another task.</span></span> <span data-ttu-id="f31b3-129">Kiedy ten wątek jest gotowy do pracy, najpierw szuka w lokalnej kolejce.</span><span class="sxs-lookup"><span data-stu-id="f31b3-129">When this thread is ready for more work, it first looks in the local queue.</span></span> <span data-ttu-id="f31b3-130">Jeśli istnieje oczekujące elementy robocze mogą być dostępne szybko.</span><span class="sxs-lookup"><span data-stu-id="f31b3-130">If work items are waiting there, they can be accessed quickly.</span></span> <span data-ttu-id="f31b3-131">Lokalne kolejki są dostępne w ostatni na wejściu, kolejności FIFO (LIFO), zachować lokalność pamięci podręcznej do zmniejszenia stopnia rywalizacji.</span><span class="sxs-lookup"><span data-stu-id="f31b3-131">The local queues are accessed in last-in, first-out order (LIFO) to preserve cache locality and reduce contention.</span></span> <span data-ttu-id="f31b3-132">Aby uzyskać więcej informacji dotyczących zadania zagnieżdżone i zadania podrzędne, zobacz [dołączone i odłączone zadania podrzędne](~/docs/standard/parallel-programming/attached-and-detached-child-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="f31b3-132">For more information about child tasks and nested tasks, see [Attached and Detached Child Tasks](~/docs/standard/parallel-programming/attached-and-detached-child-tasks.md).</span></span>  
  
 <span data-ttu-id="f31b3-133">Korzystanie z kolejek lokalnych nie tylko zmniejsza wykorzystanie kolejki globalnych, ale również korzysta z zalet lokalizacja danych.</span><span class="sxs-lookup"><span data-stu-id="f31b3-133">The use of local queues not only reduces pressure on the global queue, but also takes advantage of data locality.</span></span> <span data-ttu-id="f31b3-134">Elementy robocze w lokalnej kolejce często odwołanie do struktur danych, które są fizycznie blisko siebie nawzajem w pamięci.</span><span class="sxs-lookup"><span data-stu-id="f31b3-134">Work items in the local queue frequently reference data structures that are physically near one another in memory.</span></span> <span data-ttu-id="f31b3-135">W takich przypadkach dane są już w pamięci podręcznej po pierwsze zadanie zostało uruchomione i mogą być dostępne szybko.</span><span class="sxs-lookup"><span data-stu-id="f31b3-135">In these cases, the data is already in the cache after the first task has run and can be accessed quickly.</span></span> <span data-ttu-id="f31b3-136">Zarówno [Parallel LINQ (PLINQ)](~/docs/standard/parallel-programming/parallel-linq-plinq.md) i <xref:System.Threading.Tasks.Parallel> często klasy zagnieżdżone użycie zadania i zadania podrzędne i osiągnąć znaczne szybsze przy użyciu funkcji kolejek pracy lokalnej.</span><span class="sxs-lookup"><span data-stu-id="f31b3-136">Both [Parallel LINQ (PLINQ)](~/docs/standard/parallel-programming/parallel-linq-plinq.md) and the <xref:System.Threading.Tasks.Parallel> class use nested tasks and child tasks extensively, and achieve significant speedups by using the local work queues.</span></span>  
  
<a name="Stealing"></a>   
### <a name="work-stealing"></a><span data-ttu-id="f31b3-137">Praca, kradzież</span><span class="sxs-lookup"><span data-stu-id="f31b3-137">Work stealing</span></span>  
 <span data-ttu-id="f31b3-138">Począwszy od programu .NET Framework 4, puli wątków obejmuje także algorytmu kradzież pracy, pomaga zapewnić zapewnia żadne wątki bezczynności podczas nadal mieć pracują w kolejkach, ich.</span><span class="sxs-lookup"><span data-stu-id="f31b3-138">Starting with the .NET Framework 4, the thread pool also features a work-stealing algorithm to help make sure that no threads are sitting idle while others still have work in their queues.</span></span> <span data-ttu-id="f31b3-139">Kiedy wątek puli wątków jest gotowy do pracy, najpierw przeszukuje na czele lokalnej kolejki, następnie w kolejce globalne, a następnie w kolejkach lokalnych innych wątków.</span><span class="sxs-lookup"><span data-stu-id="f31b3-139">When a thread-pool thread is ready for more work, it first looks at the head of its local queue, then in the global queue, and then in the local queues of other threads.</span></span> <span data-ttu-id="f31b3-140">Jeśli znajdzie elementu roboczego w lokalnej kolejce inny wątek najpierw stosuje Algorytm heurystyczny, aby upewnić się, że praca może działać wydajnie.</span><span class="sxs-lookup"><span data-stu-id="f31b3-140">If it finds a work item in the local queue of another thread, it first applies heuristics to make sure that it can run the work efficiently.</span></span> <span data-ttu-id="f31b3-141">Jeśli jest to możliwe, usuwanie kolejek elementu roboczego z zakończeniem (w kolejności FIFO).</span><span class="sxs-lookup"><span data-stu-id="f31b3-141">If it can, it de-queues the work item from the tail (in FIFO order).</span></span> <span data-ttu-id="f31b3-142">To ogranicza rywalizację o każdej kolejki lokalne i zachowuje lokalizacja danych.</span><span class="sxs-lookup"><span data-stu-id="f31b3-142">This reduces contention on each local queue and preserves data locality.</span></span> <span data-ttu-id="f31b3-143">Ta architektura pozwala wątek puli równoważenia obciążenia pracować wydajniej niż poprzednich wersji.</span><span class="sxs-lookup"><span data-stu-id="f31b3-143">This architecture helps the thread pool load-balance work more efficiently than past versions did.</span></span>  
  
<a name="LongRunning"></a>   
### <a name="long-running-tasks"></a><span data-ttu-id="f31b3-144">Długotrwałych zadań</span><span class="sxs-lookup"><span data-stu-id="f31b3-144">Long-running tasks</span></span>  
 <span data-ttu-id="f31b3-145">Można jawnie uniemożliwić zadania umieszczeniem w lokalnej kolejce.</span><span class="sxs-lookup"><span data-stu-id="f31b3-145">You may want to explicitly prevent a task from being put on a local queue.</span></span> <span data-ttu-id="f31b3-146">Na przykład wiadomo, że danego elementu pracy będzie wykonywany dla stosunkowo długo i może zablokować wszystkie inne elementy robocze w lokalnej kolejce.</span><span class="sxs-lookup"><span data-stu-id="f31b3-146">For example, you may know that a particular work item will run for a relatively long time and is likely to block all other work items on the local queue.</span></span> <span data-ttu-id="f31b3-147">W takim przypadku można określić <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType> opcja, która dostarcza wskazówkę obiektowi harmonogram, że dodatkowy wątek może być wymagane dla zadania tak, aby nie blokować postęp innych wątków lub elementów roboczych w lokalnej kolejce.</span><span class="sxs-lookup"><span data-stu-id="f31b3-147">In this case, you can specify the <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType> option, which provides a hint to the scheduler that an additional thread might be required for the task so that it does not block the forward progress of other threads or work items on the local queue.</span></span> <span data-ttu-id="f31b3-148">Przy użyciu tej opcji pozwala uniknąć puli wątków całkowicie, łącznie z kolejkami globalne i lokalne.</span><span class="sxs-lookup"><span data-stu-id="f31b3-148">By using this option you avoid the thread pool completely, including the global and local queues.</span></span>  
  
<a name="Inlining"></a>   
### <a name="task-inlining"></a><span data-ttu-id="f31b3-149">Wbudowanie zadania</span><span class="sxs-lookup"><span data-stu-id="f31b3-149">Task inlining</span></span>  
 <span data-ttu-id="f31b3-150">W niektórych przypadkach, gdy <xref:System.Threading.Tasks.Task> to czas potrzebny, on mogą być wykonywane synchronicznie w wątku, który wykonuje operację oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="f31b3-150">In some cases when a <xref:System.Threading.Tasks.Task> is waited on, it may be executed synchronously on the thread that is performing the wait operation.</span></span> <span data-ttu-id="f31b3-151">To zwiększa wydajność poprzez zapobieganie potrzebę dodatkowy wątek i zamiast tego przy użyciu istniejącego wątku, który będzie zablokowany w przeciwnym razie.</span><span class="sxs-lookup"><span data-stu-id="f31b3-151">This enhances performance by preventing the need for an additional thread and instead using the existing thread, which would have blocked otherwise.</span></span> <span data-ttu-id="f31b3-152">Aby zapobiec wystąpieniu błędów z powodu re-entrancy, wbudowanie zadania wykonywane tylko w przypadku docelowej oczekiwania znajduje się w lokalnej kolejce odpowiednie wątku.</span><span class="sxs-lookup"><span data-stu-id="f31b3-152">To prevent errors due to re-entrancy, task inlining only occurs when the wait target is found in the relevant thread's local queue.</span></span>  
  
<a name="Sync"></a>   
## <a name="specifying-a-synchronization-context"></a><span data-ttu-id="f31b3-153">Określanie kontekstu synchronizacji</span><span class="sxs-lookup"><span data-stu-id="f31b3-153">Specifying a synchronization context</span></span>  
 <span data-ttu-id="f31b3-154">Możesz użyć <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType> metodę, aby określić, że zadanie powinno zostać zaplanowane do uruchomienia na określonego wątku.</span><span class="sxs-lookup"><span data-stu-id="f31b3-154">You can use the <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType> method to specify that a task should be scheduled to run on a particular thread.</span></span> <span data-ttu-id="f31b3-155">Jest to przydatne w przypadku środowisk, takich jak formularze Windows i Windows Presentation Foundation, gdzie dostęp do obiektów interfejsu użytkownika często jest ograniczony do kodu, który działa na tym samym wątku, na którym został utworzony obiekt interfejsu użytkownika.</span><span class="sxs-lookup"><span data-stu-id="f31b3-155">This is useful in frameworks such as Windows Forms and Windows Presentation Foundation where access to user interface objects is often restricted to code that is running on the same thread on which the UI object was created.</span></span>  
  
 <span data-ttu-id="f31b3-156">W poniższym przykładzie użyto <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType> metody w aplikacji Windows Presentation Foundation (WPF), aby zaplanować zadanie, w tym samym wątku, utworzonego kontrolki interfejsu użytkownika.</span><span class="sxs-lookup"><span data-stu-id="f31b3-156">The following example uses the <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType> method in a Windows Presentation Foundation (WPF) app to schedule a task on the same thread that the user interface (UI) control was created on.</span></span>   <span data-ttu-id="f31b3-157">Ten przykład tworzy mozaiki obrazów, które są wybierane losowo spośród określonego katalogu.</span><span class="sxs-lookup"><span data-stu-id="f31b3-157">The example creates a mosaic of images that are randomly selected from a specified directory.</span></span> <span data-ttu-id="f31b3-158">Obiekty WPF są używane do ładowania i zmienianie rozmiaru obrazów.</span><span class="sxs-lookup"><span data-stu-id="f31b3-158">The WPF objects are used to load and resize the images.</span></span> <span data-ttu-id="f31b3-159">Nieprzetworzone pikseli są następnie przekazywane do zadania, które używa <xref:System.Threading.Tasks.Parallel.For%2A> pętli do zapisywania danych pikseli na dużą tablicę jednobajtowych.</span><span class="sxs-lookup"><span data-stu-id="f31b3-159">The raw pixels are then passed to a task that uses a <xref:System.Threading.Tasks.Parallel.For%2A> loop to write the pixel data into a large single-byte array.</span></span> <span data-ttu-id="f31b3-160">Synchronizacja nie jest wymagana, ponieważ żadne dwa Kafelki zajmować się te same elementy tablicy.</span><span class="sxs-lookup"><span data-stu-id="f31b3-160">No synchronization is required because no two tiles occupy the same array elements.</span></span> <span data-ttu-id="f31b3-161">Kafelki również będą zapisywane w dowolnej kolejności, ponieważ ich pozycja jest obliczany niezależnie od innych kafelków.</span><span class="sxs-lookup"><span data-stu-id="f31b3-161">The tiles can also be written in any order because their position is calculated independently of any other tile.</span></span> <span data-ttu-id="f31b3-162">Dużą tablicę jest następnie przekazywany do zadania, które jest uruchamiane w wątku interfejsu użytkownika, gdzie dane pikseli są ładowane do kontrolkę typu obraz.</span><span class="sxs-lookup"><span data-stu-id="f31b3-162">The large array is then passed to a task that runs on the UI thread, where the pixel data is loaded into an Image control.</span></span>  
  
 <span data-ttu-id="f31b3-163">Przykład przenoszenia danych poza wątku interfejsu użytkownika, modyfikuje je za pomocą pętli równoległych i <xref:System.Threading.Tasks.Task> obiektów, a następnie przekazuje go do zadań, które jest uruchamiane w wątku interfejsu użytkownika.</span><span class="sxs-lookup"><span data-stu-id="f31b3-163">The example moves data off the UI thread, modifies it by using parallel loops and <xref:System.Threading.Tasks.Task> objects, and then passes it back to a task that runs on the UI thread.</span></span> <span data-ttu-id="f31b3-164">To podejście jest przydatne, gdy trzeba użyć Biblioteka zadań równoległych do wykonywania operacji, które nie są obsługiwane przez interfejs API WPF lub nie są wystarczająco szybko.</span><span class="sxs-lookup"><span data-stu-id="f31b3-164">This approach is useful when you have to use the Task Parallel Library to perform operations that either are not supported by the WPF API, or are not sufficiently fast.</span></span> <span data-ttu-id="f31b3-165">Innym sposobem tworzenia mozaiki obrazu na platformie WPF jest użycie <xref:System.Windows.Controls.WrapPanel?displayProperty=nameWithType> kontroli i dodać do niej obrazy.</span><span class="sxs-lookup"><span data-stu-id="f31b3-165">Another way to create an image mosaic in WPF is to use a <xref:System.Windows.Controls.WrapPanel?displayProperty=nameWithType> control and add images to it.</span></span> <span data-ttu-id="f31b3-166"><xref:System.Windows.Controls.WrapPanel> Obsługuje pracy pozycjonowania Kafelki.</span><span class="sxs-lookup"><span data-stu-id="f31b3-166">The <xref:System.Windows.Controls.WrapPanel> handles the work of positioning the tiles.</span></span> <span data-ttu-id="f31b3-167">Jednak tej pracy można wykonać tylko w wątku interfejsu użytkownika.</span><span class="sxs-lookup"><span data-stu-id="f31b3-167">However, this work can only be performed on the UI thread.</span></span>  
  
 [!code-csharp[TPL_SyncContext#01](~/samples/snippets/csharp/VS_Snippets_Misc/tpl_synccontext/cs/mainwindow.xaml.cs#01)]
 [!code-vb[TPL_SyncContext#01](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl_synccontext/vb/MainWindow.xaml.vb#01)]  
  
 <span data-ttu-id="f31b3-168">Aby utworzyć przykład, Utwórz projekt aplikacji WPF w programie Visual Studio i nadaj jej nazwę na WPF_CS1 (dla C# projekt WPF) lub WPF_VB1 (w projekcie WPF w języku Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="f31b3-168">To create the example, create a WPF application project in Visual Studio and name it WPF_CS1 (for a C# WPF project) or WPF_VB1 (for a Visual Basic WPF project).</span></span> <span data-ttu-id="f31b3-169">Następnie wykonaj poniższe czynności:</span><span class="sxs-lookup"><span data-stu-id="f31b3-169">Then do the following:</span></span>  
  
1. <span data-ttu-id="f31b3-170">W widoku projektu przeciągnij <xref:System.Windows.Controls.Image> z kontrolować **przybornika** na lewym górnym rogu powierzchni projektowej.</span><span class="sxs-lookup"><span data-stu-id="f31b3-170">In design view, drag an <xref:System.Windows.Controls.Image> control from the **Toolbox** onto the upper left corner of the design surface.</span></span> <span data-ttu-id="f31b3-171">W **nazwa** pole tekstowe z **właściwości** oknie Nazwa kontrolki "image".</span><span class="sxs-lookup"><span data-stu-id="f31b3-171">In the **Name** textbox of the **Properties** window, name the control "image".</span></span>    
  
2. <span data-ttu-id="f31b3-172">Przeciągnij <xref:System.Windows.Controls.Button> z kontrolować **przybornika** do lewej dolnej części okna aplikacji.</span><span class="sxs-lookup"><span data-stu-id="f31b3-172">Drag a <xref:System.Windows.Controls.Button> control from the **Toolbox** to the lower left part of the application window.</span></span> <span data-ttu-id="f31b3-173">W widoku XAML, określ <xref:System.Windows.Controls.ContentControl.Content%2A> właściwość przycisku jako "Marka mozaiki", a następnie określ jej <xref:System.Windows.FrameworkElement.Width> właściwości jako "100".</span><span class="sxs-lookup"><span data-stu-id="f31b3-173">In XAML view, specify the <xref:System.Windows.Controls.ContentControl.Content%2A> property of the button as "Make a mosaic", and specify its <xref:System.Windows.FrameworkElement.Width> property as "100".</span></span> <span data-ttu-id="f31b3-174">Połącz <xref:System.Windows.Controls.Primitives.ButtonBase.Click> zdarzenie z `button_Click` programu obsługi zdarzeń zdefiniowanych w przykładowym kodzie, dodając `Click="button_Click"` do `<Button>` elementu.</span><span class="sxs-lookup"><span data-stu-id="f31b3-174">Connect the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event with the `button_Click` event handler defined in the example's code by adding `Click="button_Click"` to the `<Button>` element.</span></span> <span data-ttu-id="f31b3-175">W **nazwa** pole tekstowe z **właściwości** oknie Nazwa kontrolki "button".</span><span class="sxs-lookup"><span data-stu-id="f31b3-175">In the **Name** textbox of the **Properties** window, name the control "button".</span></span>  
  
3. <span data-ttu-id="f31b3-176">Zamień całą zawartość pliku MainWindow.xaml.cs lub MainWindow.xaml.vb kod z tego przykładu.</span><span class="sxs-lookup"><span data-stu-id="f31b3-176">Replace the entire contents of the MainWindow.xaml.cs or MainWindow.xaml.vb file with the code from this example.</span></span> <span data-ttu-id="f31b3-177">Aby uzyskać C# WPF projektu, upewnij się, że nazwa obszaru roboczego odpowiada nazwę projektu.</span><span class="sxs-lookup"><span data-stu-id="f31b3-177">For a C# WPF project, make sure that the name of the workspace matches the project name.</span></span> 
  
4. <span data-ttu-id="f31b3-178">Przykład odczytuje obrazy JPEG z katalogu o nazwie obrazy C:\Users\Public\Pictures\Sample\\.</span><span class="sxs-lookup"><span data-stu-id="f31b3-178">The example reads JPEG images from a directory named C:\Users\Public\Pictures\Sample Pictures\\.</span></span> <span data-ttu-id="f31b3-179">Tworzenie katalogu i umieścić niektóre obrazy w niej lub zmienić ścieżkę do odwoływania się do innego katalogu, który zawiera obrazy.</span><span class="sxs-lookup"><span data-stu-id="f31b3-179">Either create the directory and place some images in it, or change the path to refer to some other directory that contains images.</span></span> 
  
<span data-ttu-id="f31b3-180">W tym przykładzie ma pewne ograniczenia.</span><span class="sxs-lookup"><span data-stu-id="f31b3-180">This example has some limitations.</span></span> <span data-ttu-id="f31b3-181">Na przykład obsługiwane są tylko 32-bity każdego piksela obrazy; obrazy w innych formatach są uszkodzone, przez <xref:System.Windows.Media.Imaging.BitmapImage> obiektu podczas operacji zmiany rozmiaru.</span><span class="sxs-lookup"><span data-stu-id="f31b3-181">For example, only 32-bits-per-pixel images are supported; images in other formats are corrupted by the <xref:System.Windows.Media.Imaging.BitmapImage> object during the resizing operation.</span></span> <span data-ttu-id="f31b3-182">Ponadto obrazy źródłowe wszystkie muszą być większe niż rozmiar kafelka.</span><span class="sxs-lookup"><span data-stu-id="f31b3-182">Also, the source images must all be larger than the tile size.</span></span> <span data-ttu-id="f31b3-183">Jako dodatkowe ćwiczenie można dodawać funkcje do obsługi wielu formatów pikseli i rozmiarów plików.</span><span class="sxs-lookup"><span data-stu-id="f31b3-183">As a further exercise, you can add functionality to handle multiple pixel formats and file sizes.</span></span>  
  
## Examples  
 <span data-ttu-id="f31b3-184">Poniższy przykład pochodzi z [przykłady dotyczące programowania równoległego za pomocą programu .NET Framework 4](https://go.microsoft.com/fwlink/?LinkID=165717) w witrynie sieci Web galerii kodu MSDN.</span><span class="sxs-lookup"><span data-stu-id="f31b3-184">The following example is taken from the [Samples for Parallel Programming with the .NET Framework 4](https://go.microsoft.com/fwlink/?LinkID=165717) on the MSDN Code Gallery Web site.</span></span>  <span data-ttu-id="f31b3-185">Powoduje utworzenie harmonogramu niestandardowego zadania, która ogranicza liczbę wątków używanych przez aplikację.</span><span class="sxs-lookup"><span data-stu-id="f31b3-185">It creates a custom task scheduler that limits the number of threads used by the app.</span></span> <span data-ttu-id="f31b3-186">Następnie uruchamia dwa rodzaje zadań i wyświetla informacje na temat wątku, na którym jest wykonywane zadanie i zadania.</span><span class="sxs-lookup"><span data-stu-id="f31b3-186">It then launches two sets of tasks and displays information about the task and the thread on which the task is executing.</span></span>  
  
 [!code-csharp[TPL_Schedulers#02](~/samples/snippets/csharp/VS_Snippets_Misc/tpl_schedulers/cs/limitex1.cs#02)]
 [!code-vb[TPL_Schedulers#02](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl_schedulers/vb/module2.vb#02)]  
  
 <span data-ttu-id="f31b3-187">Ponadto kilka harmonogramów zadań próbki są dostępne w galerii kodów: [Przykłady dotyczące programowania równoległego za pomocą programu .NET Framework 4](https://go.microsoft.com/fwlink/?LinkID=165717).</span><span class="sxs-lookup"><span data-stu-id="f31b3-187">In addition, several sample task schedulers are available on Code Gallery: [Samples for Parallel Programming with the .NET Framework 4](https://go.microsoft.com/fwlink/?LinkID=165717).</span></span>  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="f31b3-188">Wszyscy członkowie abstrakcyjnej <see cref="T:System.Threading.Tasks.TaskScheduler" /> typu są bezpieczne pod względem wątku i mogą być używane jednocześnie z wielu wątków.</span><span class="sxs-lookup"><span data-stu-id="f31b3-188">All members of the abstract <see cref="T:System.Threading.Tasks.TaskScheduler" /> type are thread-safe and may be used from multiple threads concurrently.</span></span></threadsafe>
    <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
    <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="f31b3-189">Biblioteka zadań równoległych (TPL)</span><span class="sxs-lookup"><span data-stu-id="f31b3-189">Task Parallel Library (TPL)</span></span></related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected TaskScheduler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; TaskScheduler();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f31b3-190">Inicjuje <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span><span class="sxs-lookup"><span data-stu-id="f31b3-190">Initializes the <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span></span></summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="f31b3-191">Biblioteka zadań równoległych (TPL)</span><span class="sxs-lookup"><span data-stu-id="f31b3-191">Task Parallel Library (TPL)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskScheduler Current" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Current" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Current As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::TaskScheduler ^ Current { System::Threading::Tasks::TaskScheduler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskScheduler.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f31b3-192">Pobiera <see cref="T:System.Threading.Tasks.TaskScheduler" /> skojarzone z aktualnie przeprowadzane zadanie.</span><span class="sxs-lookup"><span data-stu-id="f31b3-192">Gets the <see cref="T:System.Threading.Tasks.TaskScheduler" /> associated with the currently executing task.</span></span></summary>
        <value><span data-ttu-id="f31b3-193">Zwraca <see cref="T:System.Threading.Tasks.TaskScheduler" /> skojarzone z aktualnie przeprowadzane zadanie.</span><span class="sxs-lookup"><span data-stu-id="f31b3-193">Returns the <see cref="T:System.Threading.Tasks.TaskScheduler" /> associated with the currently executing task.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f31b3-194">Gdy nie wywołane z wnętrza zadania, <xref:System.Threading.Tasks.TaskScheduler.Current%2A> zwróci <xref:System.Threading.Tasks.TaskScheduler.Default%2A> harmonogramu.</span><span class="sxs-lookup"><span data-stu-id="f31b3-194">When not called from within a task, <xref:System.Threading.Tasks.TaskScheduler.Current%2A> will return the <xref:System.Threading.Tasks.TaskScheduler.Default%2A> scheduler.</span></span>  
  
 <span data-ttu-id="f31b3-195">Aby uzyskać więcej informacji, zobacz <xref:System.Threading.Tasks.TaskScheduler>.</span><span class="sxs-lookup"><span data-stu-id="f31b3-195">For more information, see <xref:System.Threading.Tasks.TaskScheduler>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="f31b3-196">Biblioteka zadań równoległych (TPL)</span><span class="sxs-lookup"><span data-stu-id="f31b3-196">Task Parallel Library (TPL)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskScheduler Default" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::TaskScheduler ^ Default { System::Threading::Tasks::TaskScheduler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Default : System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskScheduler.Default" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f31b3-197">Pobiera domyślny <see cref="T:System.Threading.Tasks.TaskScheduler" /> wystąpienia, który znajduje się w programie .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="f31b3-197">Gets the default <see cref="T:System.Threading.Tasks.TaskScheduler" /> instance that is provided by the .NET Framework.</span></span></summary>
        <value><span data-ttu-id="f31b3-198">Zwraca domyślny <see cref="T:System.Threading.Tasks.TaskScheduler" /> wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="f31b3-198">Returns the default <see cref="T:System.Threading.Tasks.TaskScheduler" /> instance.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f31b3-199">Aby uzyskać więcej informacji, zobacz <xref:System.Threading.Tasks.TaskScheduler>.</span><span class="sxs-lookup"><span data-stu-id="f31b3-199">For more information, see <xref:System.Threading.Tasks.TaskScheduler>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="f31b3-200">Biblioteka zadań równoległych (TPL)</span><span class="sxs-lookup"><span data-stu-id="f31b3-200">Task Parallel Library (TPL)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~TaskScheduler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!TaskScheduler ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="taskScheduler.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f31b3-201">Zwalnia wszystkie zasoby skojarzone z tym harmonogramem.</span><span class="sxs-lookup"><span data-stu-id="f31b3-201">Frees all resources associated with this scheduler.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FromCurrentSynchronizationContext">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler FromCurrentSynchronizationContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.TaskScheduler FromCurrentSynchronizationContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromCurrentSynchronizationContext () As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::TaskScheduler ^ FromCurrentSynchronizationContext();" />
      <MemberSignature Language="F#" Value="static member FromCurrentSynchronizationContext : unit -&gt; System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f31b3-202">Tworzy <see cref="T:System.Threading.Tasks.TaskScheduler" /> skojarzone z bieżącym <see cref="T:System.Threading.SynchronizationContext" />.</span><span class="sxs-lookup"><span data-stu-id="f31b3-202">Creates a <see cref="T:System.Threading.Tasks.TaskScheduler" /> associated with the current <see cref="T:System.Threading.SynchronizationContext" />.</span></span></summary>
        <returns><span data-ttu-id="f31b3-203">A <see cref="T:System.Threading.Tasks.TaskScheduler" /> skojarzone z bieżącym <see cref="T:System.Threading.SynchronizationContext" />, zgodnie z ustaleniami <see cref="P:System.Threading.SynchronizationContext.Current" />.</span><span class="sxs-lookup"><span data-stu-id="f31b3-203">A <see cref="T:System.Threading.Tasks.TaskScheduler" /> associated with the current <see cref="T:System.Threading.SynchronizationContext" />, as determined by <see cref="P:System.Threading.SynchronizationContext.Current" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f31b3-204">Wszystkie <xref:System.Threading.Tasks.Task> w kolejce do zwracanego wystąpienia usługi scheduler zostaną wykonane za pomocą wywołania <xref:System.Threading.SynchronizationContext.Post%2A> metody w tym kontekście.</span><span class="sxs-lookup"><span data-stu-id="f31b3-204">All <xref:System.Threading.Tasks.Task> instances queued to the returned scheduler will be executed through a call to the <xref:System.Threading.SynchronizationContext.Post%2A> method on that context.</span></span>  
  
 <span data-ttu-id="f31b3-205">Aby uzyskać więcej informacji, zobacz <xref:System.Threading.Tasks.TaskScheduler>.</span><span class="sxs-lookup"><span data-stu-id="f31b3-205">For more information, see <xref:System.Threading.Tasks.TaskScheduler>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f31b3-206">Bieżący SynchronizationContext nie może służyć jako harmonogramu zadań systemu.</span><span class="sxs-lookup"><span data-stu-id="f31b3-206">The current SynchronizationContext may not be used as a TaskScheduler.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="f31b3-207">Biblioteka zadań równoległych (TPL)</span><span class="sxs-lookup"><span data-stu-id="f31b3-207">Task Parallel Library (TPL)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetScheduledTasks">
      <MemberSignature Language="C#" Value="protected abstract System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt; GetScheduledTasks ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task&gt; GetScheduledTasks() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetScheduledTasks () As IEnumerable(Of Task)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task ^&gt; ^ GetScheduledTasks();" />
      <MemberSignature Language="F#" Value="abstract member GetScheduledTasks : unit -&gt; seq&lt;System.Threading.Tasks.Task&gt;" Usage="taskScheduler.GetScheduledTasks " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f31b3-208">Debuger pomocy technicznej, generuje element wyliczalny z <see cref="T:System.Threading.Tasks.Task" /> wystąpień aktualnie czekają w kolejce do harmonogramu oczekujących na wykonanie.</span><span class="sxs-lookup"><span data-stu-id="f31b3-208">For debugger support only, generates an enumerable of <see cref="T:System.Threading.Tasks.Task" /> instances currently queued to the scheduler waiting to be executed.</span></span></summary>
        <returns><span data-ttu-id="f31b3-209">Moduł wyliczający, który umożliwia debugera do obecnie przechodzenie przez zadania w kolejce do tego harmonogramu.</span><span class="sxs-lookup"><span data-stu-id="f31b3-209">An enumerable that allows a debugger to traverse the tasks currently queued to this scheduler.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f31b3-210">Klasa pochodząca z <xref:System.Threading.Tasks.TaskScheduler> implementuje tę metodę w celu obsługi integracji z debugery.</span><span class="sxs-lookup"><span data-stu-id="f31b3-210">A class derived from <xref:System.Threading.Tasks.TaskScheduler> implements this method in order to support integration with debuggers.</span></span> <span data-ttu-id="f31b3-211">Ta metoda będzie można wywołać tylko w programie .NET Framework, gdy debuger żąda dostępu do danych.</span><span class="sxs-lookup"><span data-stu-id="f31b3-211">This method will only be invoked by the .NET Framework when the debugger requests access to the data.</span></span> <span data-ttu-id="f31b3-212">Wyliczenia zwrócony zostanie przesunięta dzięki możliwości debugowania narzędzi do dostępu do zadań aktualnie w kolejce do tego harmonogramem, dzięki czemu debugera, aby zapewnić reprezentację tę informację w interfejsie użytkownika.</span><span class="sxs-lookup"><span data-stu-id="f31b3-212">The enumerable returned will be traversed by debugging utilities to access the tasks currently queued to this scheduler, enabling the debugger to provide a representation of this information in the user interface.</span></span>  
  
 <span data-ttu-id="f31b3-213">Należy pamiętać, ta metoda jest wywoływana, będzie można zablokować wszystkie wątki w procesie.</span><span class="sxs-lookup"><span data-stu-id="f31b3-213">It is important to note that, when this method is called, all other threads in the process will be frozen.</span></span> <span data-ttu-id="f31b3-214">W związku z tym jest ważne, aby uniknąć synchronizacji z innych wątków, które mogą prowadzić do zablokowania.</span><span class="sxs-lookup"><span data-stu-id="f31b3-214">Therefore, it's important to avoid synchronization with other threads that may lead to blocking.</span></span> <span data-ttu-id="f31b3-215">Jeśli zachodzi synchronizacji i nie można uzyskać blokady w ramach tej metody, następnie należy zgłoszenie wyjątku, aby debuger nie zawieszeniu.</span><span class="sxs-lookup"><span data-stu-id="f31b3-215">If synchronization is necessary, and you are unable to acquire the lock in this method, then you should throw an exception so that the debugger does not hang.</span></span> <span data-ttu-id="f31b3-216">Poniższy przykład przedstawia jedną z możliwych rozwiązań w języku C#:</span><span class="sxs-lookup"><span data-stu-id="f31b3-216">The following example shows one possible approach in C#:</span></span>  
  
```  
protected override IEnumerable<Task> GetScheduledTasks()  
{  
    bool lockTaken = false;  
    try  
    {  
        Monitor.TryEnter(_syncObj, ref lockTaken);  
        if (lockTaken)  
        {  
            return _tasks.ToArray();  
        }  
        else throw new NotSupportedException();  
    }  
    finally  
    {  
    if (lockTaken) Monitor.Exit(_syncObj);  
    }}  
```  
  
 <span data-ttu-id="f31b3-217">Ponadto ta metoda i wyliczalny zwracane nie wolno modyfikować każdy stan widoczne globalnie.</span><span class="sxs-lookup"><span data-stu-id="f31b3-217">Additionally, this method and the enumerable returned must not modify any globally visible state.</span></span>  
  
 <span data-ttu-id="f31b3-218">Zwrócone wyliczalny, nigdy nie powinien mieć wartość null.</span><span class="sxs-lookup"><span data-stu-id="f31b3-218">The returned enumerable should never be null.</span></span> <span data-ttu-id="f31b3-219">Jeśli nie ma obecnie żadnych zadań umieszczonych w kolejce, pusta wyliczalny należy zamiast tego zostanie zwrócony.</span><span class="sxs-lookup"><span data-stu-id="f31b3-219">If there are currently no queued tasks, an empty enumerable should be returned instead.</span></span>  
  
 <span data-ttu-id="f31b3-220">Deweloperzy, którzy wdrażają debugery niestandardowe nie należy bezpośrednio wywołać tę metodę, ale należy użyć metody otoki wewnętrznego `GetScheduledTasksForDebugger` zamiast: `internal Task[] GetScheduledTasksForDebugger()`.</span><span class="sxs-lookup"><span data-stu-id="f31b3-220">Developers who are implementing custom debuggers shouldn't call this method directly, but should use the internal wrapper method `GetScheduledTasksForDebugger` instead: `internal Task[] GetScheduledTasksForDebugger()`.</span></span> <span data-ttu-id="f31b3-221">Ta metoda otoki zwraca tablicę zadań zamiast wyliczalny.</span><span class="sxs-lookup"><span data-stu-id="f31b3-221">This wrapper method returns an array of tasks instead of an enumerable.</span></span> <span data-ttu-id="f31b3-222">Aby pobrać listę aktywnych harmonogramów, użyj metody wewnętrznej `internal static TaskScheduler[] GetTaskSchedulersForDebugger()`.</span><span class="sxs-lookup"><span data-stu-id="f31b3-222">To retrieve a list of active schedulers, use the internal method `internal static TaskScheduler[] GetTaskSchedulersForDebugger()`.</span></span> <span data-ttu-id="f31b3-223">Ta metoda statyczna zwraca tablicę wszystkich aktywnych <xref:System.Threading.Tasks.TaskScheduler> wystąpień.</span><span class="sxs-lookup"><span data-stu-id="f31b3-223">This static method returns an array of all active <xref:System.Threading.Tasks.TaskScheduler> instances.</span></span> <span data-ttu-id="f31b3-224">Następnie można użyć `GetScheduledTasksForDebugger` na każde wystąpienie harmonogramu można pobrać listy zaplanowanych zadań.</span><span class="sxs-lookup"><span data-stu-id="f31b3-224">You can then use `GetScheduledTasksForDebugger` on each scheduler instance to retrieve its list of scheduled tasks.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f31b3-225">Ten harmonogram nie mógł wygenerować listy zadań podrzędnych w kolejce w tej chwili.</span><span class="sxs-lookup"><span data-stu-id="f31b3-225">This scheduler is unable to generate a list of queued tasks at this time.</span></span></exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="f31b3-226">Biblioteka zadań równoległych (TPL)</span><span class="sxs-lookup"><span data-stu-id="f31b3-226">Task Parallel Library (TPL)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.Threading.Tasks.TaskScheduler.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f31b3-227">Pobiera unikatowy identyfikator dla tego <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span><span class="sxs-lookup"><span data-stu-id="f31b3-227">Gets the unique ID for this <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span></span></summary>
        <value><span data-ttu-id="f31b3-228">Zwraca unikatowy identyfikator dla tej klasy <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span><span class="sxs-lookup"><span data-stu-id="f31b3-228">Returns the unique ID for this <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f31b3-229">Aby uzyskać więcej informacji, zobacz <xref:System.Threading.Tasks.TaskScheduler>.</span><span class="sxs-lookup"><span data-stu-id="f31b3-229">For more information, see <xref:System.Threading.Tasks.TaskScheduler>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="f31b3-230">Biblioteka zadań równoległych (TPL)</span><span class="sxs-lookup"><span data-stu-id="f31b3-230">Task Parallel Library (TPL)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="MaximumConcurrencyLevel">
      <MemberSignature Language="C#" Value="public virtual int MaximumConcurrencyLevel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaximumConcurrencyLevel" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property MaximumConcurrencyLevel As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int MaximumConcurrencyLevel { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MaximumConcurrencyLevel : int" Usage="System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f31b3-231">Wskazuje poziom współbieżności maksymalną, to <see cref="T:System.Threading.Tasks.TaskScheduler" /> umożliwiającą obsługę.</span><span class="sxs-lookup"><span data-stu-id="f31b3-231">Indicates the maximum concurrency level this <see cref="T:System.Threading.Tasks.TaskScheduler" /> is able to support.</span></span></summary>
        <value><span data-ttu-id="f31b3-232">Zwraca liczbę całkowitą, która reprezentuje poziom współbieżności maksymalną.</span><span class="sxs-lookup"><span data-stu-id="f31b3-232">Returns an integer that represents the maximum concurrency level.</span></span> <span data-ttu-id="f31b3-233">Zwraca domyślnego harmonogramu <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="f31b3-233">The default scheduler returns <see cref="F:System.Int32.MaxValue" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f31b3-234">Aby uzyskać więcej informacji, zobacz <xref:System.Threading.Tasks.TaskScheduler>.</span><span class="sxs-lookup"><span data-stu-id="f31b3-234">For more information, see <xref:System.Threading.Tasks.TaskScheduler>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="f31b3-235">Biblioteka zadań równoległych (TPL)</span><span class="sxs-lookup"><span data-stu-id="f31b3-235">Task Parallel Library (TPL)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="QueueTask">
      <MemberSignature Language="C#" Value="protected internal abstract void QueueTask (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void QueueTask(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract void QueueTask(System::Threading::Tasks::Task ^ task);" />
      <MemberSignature Language="F#" Value="abstract member QueueTask : System.Threading.Tasks.Task -&gt; unit" Usage="taskScheduler.QueueTask task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task"><span data-ttu-id="f31b3-236"><see cref="T:System.Threading.Tasks.Task" /> Do umieszczone w kolejce.</span><span class="sxs-lookup"><span data-stu-id="f31b3-236">The <see cref="T:System.Threading.Tasks.Task" /> to be queued.</span></span></param>
        <summary><span data-ttu-id="f31b3-237">Kolejki <see cref="T:System.Threading.Tasks.Task" /> do harmonogramu.</span><span class="sxs-lookup"><span data-stu-id="f31b3-237">Queues a <see cref="T:System.Threading.Tasks.Task" /> to the scheduler.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f31b3-238">Klasa pochodząca z <xref:System.Threading.Tasks.TaskScheduler> implementuje tę metodę, aby zaakceptować zadania zaplanowane w ramach harmonogramu zadań.</span><span class="sxs-lookup"><span data-stu-id="f31b3-238">A class derived from <xref:System.Threading.Tasks.TaskScheduler> implements this method to accept tasks being scheduled on the scheduler.</span></span>  
  
 <span data-ttu-id="f31b3-239">Typowa implementacja będzie przechowywać zadania w strukturze danych wewnętrznych, które będą obsługiwane przez wątki, które spowoduje wykonanie tych zadań w czasie w przyszłości.</span><span class="sxs-lookup"><span data-stu-id="f31b3-239">A typical implementation would store the task in an internal data structure, which would be serviced by threads that would execute those tasks at some time in the future.</span></span>  
  
 <span data-ttu-id="f31b3-240">Ta metoda jest przeznaczone wyłącznie do można wywoływać za pomocą programu .NET Framework i nie powinien być wywoływany bezpośrednio przez klasy pochodnej.</span><span class="sxs-lookup"><span data-stu-id="f31b3-240">This method is only meant to be called by the .NET Framework and should not be called directly by the derived class.</span></span> <span data-ttu-id="f31b3-241">Jest to konieczne utrzymanie spójności systemu.</span><span class="sxs-lookup"><span data-stu-id="f31b3-241">This is necessary for maintaining the consistency of the system.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f31b3-242"><paramref name="task" /> Argument ma wartość null.</span><span class="sxs-lookup"><span data-stu-id="f31b3-242">The <paramref name="task" /> argument is null.</span></span></exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="f31b3-243">Biblioteka zadań równoległych (TPL)</span><span class="sxs-lookup"><span data-stu-id="f31b3-243">Task Parallel Library (TPL)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryDequeue">
      <MemberSignature Language="C#" Value="protected internal virtual bool TryDequeue (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool TryDequeue(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool TryDequeue(System::Threading::Tasks::Task ^ task);" />
      <MemberSignature Language="F#" Value="abstract member TryDequeue : System.Threading.Tasks.Task -&gt; bool&#xA;override this.TryDequeue : System.Threading.Tasks.Task -&gt; bool" Usage="taskScheduler.TryDequeue task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task"><span data-ttu-id="f31b3-244"><see cref="T:System.Threading.Tasks.Task" /> Do być usuwane z kolejki.</span><span class="sxs-lookup"><span data-stu-id="f31b3-244">The <see cref="T:System.Threading.Tasks.Task" /> to be dequeued.</span></span></param>
        <summary><span data-ttu-id="f31b3-245">Podejmuje próbę usuwania z kolejki <see cref="T:System.Threading.Tasks.Task" /> który został wcześniej w kolejce do tego harmonogramu.</span><span class="sxs-lookup"><span data-stu-id="f31b3-245">Attempts to dequeue a <see cref="T:System.Threading.Tasks.Task" /> that was previously queued to this scheduler.</span></span></summary>
        <returns><span data-ttu-id="f31b3-246">Wartość logiczna wskazująca czy <paramref name="task" /> argument był dequeued pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="f31b3-246">A Boolean denoting whether the <paramref name="task" /> argument was successfully dequeued.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f31b3-247">Aby uzyskać więcej informacji, zobacz <xref:System.Threading.Tasks.TaskScheduler>.</span><span class="sxs-lookup"><span data-stu-id="f31b3-247">For more information, see <xref:System.Threading.Tasks.TaskScheduler>.</span></span>  
  
 <span data-ttu-id="f31b3-248">Ta metoda może być wykonywany w bloku finally; w związku z tym powinien zostać zwrócony tak szybko, jak to możliwe tak że dowolne zasoby, takie jak <xref:System.Threading.CancellationTokenRegistration> obiekty mogą być usuwane w sposób terminowy.</span><span class="sxs-lookup"><span data-stu-id="f31b3-248">This method may execute in a finally block; therefore it should return as quickly as possible so that any resources such as <xref:System.Threading.CancellationTokenRegistration> objects can be disposed of in a timely manner.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f31b3-249"><paramref name="task" /> Argument ma wartość null.</span><span class="sxs-lookup"><span data-stu-id="f31b3-249">The <paramref name="task" /> argument is null.</span></span></exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="f31b3-250">Biblioteka zadań równoległych (TPL)</span><span class="sxs-lookup"><span data-stu-id="f31b3-250">Task Parallel Library (TPL)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryExecuteTask">
      <MemberSignature Language="C#" Value="protected bool TryExecuteTask (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool TryExecuteTask(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool TryExecuteTask(System::Threading::Tasks::Task ^ task);" />
      <MemberSignature Language="F#" Value="member this.TryExecuteTask : System.Threading.Tasks.Task -&gt; bool" Usage="taskScheduler.TryExecuteTask task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task"><span data-ttu-id="f31b3-251">Element <see cref="T:System.Threading.Tasks.Task" /> obiektu do wykonania.</span><span class="sxs-lookup"><span data-stu-id="f31b3-251">A <see cref="T:System.Threading.Tasks.Task" /> object to be executed.</span></span></param>
        <summary><span data-ttu-id="f31b3-252">Podejmuje próbę wykonania podanych <see cref="T:System.Threading.Tasks.Task" /> w tym harmonogramie.</span><span class="sxs-lookup"><span data-stu-id="f31b3-252">Attempts to execute the provided <see cref="T:System.Threading.Tasks.Task" /> on this scheduler.</span></span></summary>
        <returns><span data-ttu-id="f31b3-253">Wartość logiczna oznacza to wartość true, jeśli <paramref name="task" /> zostało wykonane pomyślnie, wartość false, jeśli nie było.</span><span class="sxs-lookup"><span data-stu-id="f31b3-253">A Boolean that is true if <paramref name="task" /> was successfully executed, false if it was not.</span></span> <span data-ttu-id="f31b3-254">Typową przyczyną niepowodzenia wykonywania jest, że zadanie wcześniej zostały wykonane lub trwa proces wykonywany przez inny wątek.</span><span class="sxs-lookup"><span data-stu-id="f31b3-254">A common reason for execution failure is that the task had previously been executed or is in the process of being executed by another thread.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f31b3-255">Harmonogram implementacje są dostarczane z <xref:System.Threading.Tasks.Task> wystąpień do wykonania przy użyciu jednej <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A> metody lub <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="f31b3-255">Scheduler implementations are provided with <xref:System.Threading.Tasks.Task> instances to be executed through either the <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A> method or the <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline%2A> method.</span></span> <span data-ttu-id="f31b3-256">Gdy harmonogram uzna to za właściwe uruchomić zadanie podana <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> należy to zrobić.</span><span class="sxs-lookup"><span data-stu-id="f31b3-256">When the scheduler deems it appropriate to run the provided task, <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> should be used to do so.</span></span> <span data-ttu-id="f31b3-257">TryExecuteTask obsługuje wszystkich aspektów wykonywania zadania, w tym wywołanie akcji, obsługa wyjątków, zarządzanie stanem i kontroli cyklu życia.</span><span class="sxs-lookup"><span data-stu-id="f31b3-257">TryExecuteTask handles all aspects of executing a task, including action invocation, exception handling, state management, and lifecycle control.</span></span>  
  
 <span data-ttu-id="f31b3-258"><xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> może być używana tylko dla zadań dostarczane do tego harmonogramu przez infrastrukturę programu .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="f31b3-258"><xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> must only be used for tasks provided to this scheduler by the .NET Framework infrastructure.</span></span> <span data-ttu-id="f31b3-259">Nie można stosować można wykonać dowolne zadania uzyskane za pomocą niestandardowych mechanizmów.</span><span class="sxs-lookup"><span data-stu-id="f31b3-259">It should not be used to execute arbitrary tasks obtained through custom mechanisms.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f31b3-260"><paramref name="task" /> Nie jest skojarzony z tym harmonogramem.</span><span class="sxs-lookup"><span data-stu-id="f31b3-260">The <paramref name="task" /> is not associated with this scheduler.</span></span></exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="f31b3-261">Biblioteka zadań równoległych (TPL)</span><span class="sxs-lookup"><span data-stu-id="f31b3-261">Task Parallel Library (TPL)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryExecuteTaskInline">
      <MemberSignature Language="C#" Value="protected abstract bool TryExecuteTaskInline (System.Threading.Tasks.Task task, bool taskWasPreviouslyQueued);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool TryExecuteTaskInline(class System.Threading.Tasks.Task task, bool taskWasPreviouslyQueued) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool TryExecuteTaskInline(System::Threading::Tasks::Task ^ task, bool taskWasPreviouslyQueued);" />
      <MemberSignature Language="F#" Value="abstract member TryExecuteTaskInline : System.Threading.Tasks.Task * bool -&gt; bool" Usage="taskScheduler.TryExecuteTaskInline (task, taskWasPreviouslyQueued)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
        <Parameter Name="taskWasPreviouslyQueued" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="task"><span data-ttu-id="f31b3-262"><see cref="T:System.Threading.Tasks.Task" /> Do wykonania.</span><span class="sxs-lookup"><span data-stu-id="f31b3-262">The <see cref="T:System.Threading.Tasks.Task" /> to be executed.</span></span></param>
        <param name="taskWasPreviouslyQueued"><span data-ttu-id="f31b3-263">Wartość logiczna wskazująca, czy zadanie zostało wcześniej umieszczone w kolejce.</span><span class="sxs-lookup"><span data-stu-id="f31b3-263">A Boolean denoting whether or not task has previously been queued.</span></span> <span data-ttu-id="f31b3-264">Jeśli ten parametr ma wartość True, następnie zadanie może wcześniej dodane do kolejki (zaplanowane); Jeśli ma wartość FAŁSZ, następnie zadanie jest znane nie zostały umieszczone w kolejce, a to wywołanie jest wykonywane w celu wykonywania zadań w tekście bez usługi kolejkowania go.</span><span class="sxs-lookup"><span data-stu-id="f31b3-264">If this parameter is True, then the task may have been previously queued (scheduled); if False, then the task is known not to have been queued, and this call is being made in order to execute the task inline without queuing it.</span></span></param>
        <summary><span data-ttu-id="f31b3-265">Określa, czy podany <see cref="T:System.Threading.Tasks.Task" /> mogą być wykonywane synchronicznie, w tym wywołaniu i jeśli jest to możliwe, wykonuje on.</span><span class="sxs-lookup"><span data-stu-id="f31b3-265">Determines whether the provided <see cref="T:System.Threading.Tasks.Task" /> can be executed synchronously in this call, and if it can, executes it.</span></span></summary>
        <returns><span data-ttu-id="f31b3-266">Wartość logiczna wskazująca, czy zadanie był wykonywany w tekście.</span><span class="sxs-lookup"><span data-stu-id="f31b3-266">A Boolean value indicating whether the task was executed inline.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f31b3-267">Klasa pochodząca z <xref:System.Threading.Tasks.TaskScheduler> implementuje tej funkcji do obsługi wykonywania śródwierszowego zadania w wątku, który inicjuje oczekiwania dla tego obiektu zadania.</span><span class="sxs-lookup"><span data-stu-id="f31b3-267">A class derived from <xref:System.Threading.Tasks.TaskScheduler> implements this function to support inline execution of a task on a thread that initiates a wait on that task object.</span></span> <span data-ttu-id="f31b3-268">Wykonywanie śródwierszowe jest opcjonalny, a żądania mogą zostać odrzucone przez zwrócenie wartości false.</span><span class="sxs-lookup"><span data-stu-id="f31b3-268">Inline execution is optional, and the request may be rejected by returning false.</span></span> <span data-ttu-id="f31b3-269">Jednak większej liczby zadań, może być śródwierszowa, tym lepsze harmonogram będzie skalowana.</span><span class="sxs-lookup"><span data-stu-id="f31b3-269">However, the more tasks that can be inlined, the better the scheduler will scale.</span></span> <span data-ttu-id="f31b3-270">W rzeczywistości harmonogram tego inlines zbyt nieco mogą być podatne na zakleszczenia.</span><span class="sxs-lookup"><span data-stu-id="f31b3-270">In fact, a scheduler that inlines too little may be prone to deadlocks.</span></span> <span data-ttu-id="f31b3-271">Prawidłowego wdrożenia należy upewnić się, że wykonywania żądania w obszarze zasady gwarantowane przez harmonogram może pomyślnie wbudowanego.</span><span class="sxs-lookup"><span data-stu-id="f31b3-271">A proper implementation should ensure that a request executing under the policies guaranteed by the scheduler can successfully inline.</span></span> <span data-ttu-id="f31b3-272">Na przykład, jeśli harmonogramu używa dedykowany wątek służący do wykonywania zadań, wszelkie wbudowanie żądania z tego wątku ma być pomyślnie wykonane.</span><span class="sxs-lookup"><span data-stu-id="f31b3-272">For example, if a scheduler uses a dedicated thread to execute tasks, any inlining requests from that thread should succeed.</span></span>  
  
 <span data-ttu-id="f31b3-273">Jeśli harmonogramu decyduje o do wykonywania wykonywania śródwierszowego, go należy to zrobić za pośrednictwem wywołania do podstawowej TaskScheduler <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> metody za pomocą obiektu task podana propagowanie wartości zwracanej.</span><span class="sxs-lookup"><span data-stu-id="f31b3-273">If a scheduler decides to perform the inline execution, it should do so by calling to the base TaskScheduler's <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> method with the provided task object, propagating the return value.</span></span> <span data-ttu-id="f31b3-274">Może to być również odpowiednie usługi scheduler do usuwania zadań śródwierszowych jego wewnętrznych struktur danych zdecyduje się do tego żądania wbudowanie.</span><span class="sxs-lookup"><span data-stu-id="f31b3-274">It may also be appropriate for the scheduler to remove an inlined task from its internal data structures if it decides to honor the inlining request.</span></span> <span data-ttu-id="f31b3-275">Należy jednak pamiętać, że w pewnych okolicznościach harmonogramu może być konieczne podanie wbudowane zadanie, które wcześniej nie został podany do niego za pomocą <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="f31b3-275">Note, however, that under some circumstances a scheduler may be asked to inline a task that was not previously provided to it with the <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A> method.</span></span>  
  
 <span data-ttu-id="f31b3-276">Pochodne harmonogramu jest odpowiedzialny za zagwarantowanie, że wątek wywołujący nadaje się do wykonywania danego zadania w miarę własnych harmonogramów i zasad wykonywania są.</span><span class="sxs-lookup"><span data-stu-id="f31b3-276">The derived scheduler is responsible for making sure that the calling thread is suitable for executing the given task as far as its own scheduling and execution policies are concerned.</span></span>  
  
 <span data-ttu-id="f31b3-277">Aby uzyskać więcej informacji, zobacz <xref:System.Threading.Tasks.TaskScheduler>.</span><span class="sxs-lookup"><span data-stu-id="f31b3-277">For more information, see <xref:System.Threading.Tasks.TaskScheduler>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f31b3-278"><paramref name="task" /> Argument ma wartość null.</span><span class="sxs-lookup"><span data-stu-id="f31b3-278">The <paramref name="task" /> argument is null.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="f31b3-279"><paramref name="task" /> Zostało już wykonane.</span><span class="sxs-lookup"><span data-stu-id="f31b3-279">The <paramref name="task" /> was already executed.</span></span></exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="f31b3-280">Biblioteka zadań równoległych (TPL)</span><span class="sxs-lookup"><span data-stu-id="f31b3-280">Task Parallel Library (TPL)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="UnobservedTaskException">
      <MemberSignature Language="C#" Value="public static event EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; UnobservedTaskException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; UnobservedTaskException" />
      <MemberSignature Language="DocId" Value="E:System.Threading.Tasks.TaskScheduler.UnobservedTaskException" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event UnobservedTaskException As EventHandler(Of UnobservedTaskExceptionEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler&lt;System::Threading::Tasks::UnobservedTaskExceptionEventArgs ^&gt; ^ UnobservedTaskException;" />
      <MemberSignature Language="F#" Value="member this.UnobservedTaskException : EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; " Usage="member this.UnobservedTaskException : System.EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f31b3-281">Występuje, gdy wyjątek niewidocznego uszkodzoną zadanie ma zasady eskalacji wyjątek, który domyślnie zakończy się proces wyzwalacza.</span><span class="sxs-lookup"><span data-stu-id="f31b3-281">Occurs when a faulted task's unobserved exception is about to trigger exception escalation policy, which, by default, would terminate the process.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f31b3-282">To zdarzenie na poziomie domeny aplikacji udostępnia mechanizm do uniemożliwić zasady eskalacji wyjątków (która domyślnie kończy proces) z procesu wyzwalania.</span><span class="sxs-lookup"><span data-stu-id="f31b3-282">This application domain-wide event provides a mechanism to prevent exception escalation policy (which, by default, terminates the process) from triggering.</span></span>  
  
 <span data-ttu-id="f31b3-283">Aby ułatwić programistom pisanie kodu asynchronicznego, na podstawie zadań, [!INCLUDE[net_v45](~/includes/net-v45-md.md)] zmienia domyślne zachowanie wyjątek niewidocznego wyjątków.</span><span class="sxs-lookup"><span data-stu-id="f31b3-283">To make it easier for developers to write asynchronous code based on tasks, the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] changes the default exception behavior for unobserved exceptions.</span></span> <span data-ttu-id="f31b3-284">Mimo że nadal niewidocznego wyjątki podnieść <xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException> wyjątku, proces kończy domyślnie.</span><span class="sxs-lookup"><span data-stu-id="f31b3-284">Although unobserved exceptions still raise the <xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException> exception, the process does not terminate by default.</span></span> <span data-ttu-id="f31b3-285">Zamiast tego wyjątku jest obsługiwany przez środowisko uruchomieniowe po zdarzenie jest wywoływane niezależnie od tego, czy program obsługi zdarzeń przestrzega wyjątek.</span><span class="sxs-lookup"><span data-stu-id="f31b3-285">Instead, the exception is handled by the runtime after the event is raised, regardless of whether an event handler observes the exception.</span></span> <span data-ttu-id="f31b3-286">To zachowanie można skonfigurować.</span><span class="sxs-lookup"><span data-stu-id="f31b3-286">This behavior can be configured.</span></span> <span data-ttu-id="f31b3-287">Począwszy od [!INCLUDE[net_v45](~/includes/net-v45-md.md)], możesz użyć [ `<ThrowUnobservedTaskExceptions>` ](~/docs/framework/configure-apps/file-schema/runtime/throwunobservedtaskexceptions-element.md) element konfiguracji, aby przywrócić działanie [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] i przerwać proces:</span><span class="sxs-lookup"><span data-stu-id="f31b3-287">Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], you can use the [`<ThrowUnobservedTaskExceptions>`](~/docs/framework/configure-apps/file-schema/runtime/throwunobservedtaskexceptions-element.md) configuration element to revert to the behavior of the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] and terminate the process:</span></span>  
  
```xml  
<configuration>   
   <runtime>   
      <ThrowUnobservedTaskExceptions enabled="true"/>   
   </runtime>   
</configuration>  
  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="f31b3-288">Biblioteka zadań równoległych (TPL)</span><span class="sxs-lookup"><span data-stu-id="f31b3-288">Task Parallel Library (TPL)</span></span></related>
        <related type="Article" href="~/docs/framework/configure-apps/file-schema/runtime/throwunobservedtaskexceptions-element.md"><span data-ttu-id="f31b3-289">&lt;Throwunobservedtaskexceptions —&gt; — Element</span><span class="sxs-lookup"><span data-stu-id="f31b3-289">&lt;ThrowUnobservedTaskExceptions&gt; Element</span></span></related>
      </Docs>
    </Member>
  </Members>
</Type>
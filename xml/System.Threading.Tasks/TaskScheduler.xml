<Type Name="TaskScheduler" FullName="System.Threading.Tasks.TaskScheduler">
  <Metadata><Meta Name="ms.openlocfilehash" Value="b8c7170ce5ac0632458a657d3d57ad5f78a71889" /><Meta Name="ms.sourcegitcommit" Value="3f21796619d6e69ad383c958cc013ce44c0678de" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="02/11/2019" /><Meta Name="ms.locfileid" Value="56073082" /></Metadata><TypeSignature Language="C#" Value="public abstract class TaskScheduler" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit TaskScheduler extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.TaskScheduler" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class TaskScheduler" />
  <TypeSignature Language="C++ CLI" Value="public ref class TaskScheduler abstract" />
  <TypeSignature Language="F#" Value="type TaskScheduler = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Id={Id}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Threading.Tasks.TaskScheduler/SystemThreadingTasks_TaskSchedulerDebugView))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje obiekt, który obsługuje niskiego poziomu pracy kolejkowania zadania na wątki.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wystąpienie <xref:System.Threading.Tasks.TaskScheduler> klasa reprezentuje harmonogramu zadań. Harmonogram zadań zapewnia, że pracy zadania jest wykonywana po pewnym czasie.  
  
 Domyślnego harmonogramu zadań zależy od puli wątków programu .NET Framework 4 zawiera kradzież pracy dla równoważenia obciążenia, wątek iniekcji/wycofania dla maksymalnej przepustowości i ogólne dobrą wydajność. Powinny być wystarczające dla większości scenariuszy.  
  
 <xref:System.Threading.Tasks.TaskScheduler> Klasy służy również jako punkt rozszerzenia na całą logikę planowania można dostosowywać.  Obejmuje to mechanizmy, takich jak debugery mają być widoczne jak zaplanować zadanie do wykonania i jak z zaplanowanych zadań. Jeśli potrzebujesz specjalne funkcje, można utworzyć niestandardowy harmonogram i włącz ją do określonych zadań lub zapytań.  
  
 W tym temacie:  
[Domyślnego harmonogramu zadań i puli wątków](#Default)  
 [Globalne kolejki, a lokalne kolejki](#Queues)  
 [Praca, kradzież](#Stealing)  
 [Długotrwałych zadań](#LongRunning)  
 [Wbudowanie zadania](#Inlining)  
[Określanie kontekstu synchronizacji](#Sync)  
  
<a name="Default"></a>   
## <a name="the-default-task-scheduler-and-the-thread-pool"></a>Domyślnego harmonogramu zadań i puli wątków  
 Domyślny harmonogram bibliotece równoległych zadań i PLINQ korzysta z puli wątków .NET Framework, która jest reprezentowana przez <xref:System.Threading.ThreadPool> klasy do kolejki i wykonywania pracy. Informacje, które są dostarczane przez korzysta z puli wątków <xref:System.Threading.Tasks.Task> typu, aby efektywnie obsługiwać równoległość drobnoziarnistą (krótkotrwałe jednostki pracy), który równoległe zadania i zapytania często reprezentują.  
  
<a name="Queues"></a>   
### <a name="the-global-queue-vs-local-queues"></a>Globalne kolejki, a lokalne kolejki  
 Pula wątków utrzymuje globalne FIFO (pierwszy in, first-out) działają kolejki dla wątków w każdej domenie aplikacji. Zawsze, gdy program wywołuje <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A?displayProperty=nameWithType> (lub <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A?displayProperty=nameWithType>) metody pracy jest umieścić w tej kolejce udostępnionych i ostatecznie cofnąć umieszczonych w kolejce na następny wątek, który stanie się dostępny. Począwszy od programu .NET Framework 4, tej kolejki został ulepszony, aby używać algorytmu wolne od blokady, który przypomina <xref:System.Collections.Concurrent.ConcurrentQueue%601> klasy. Przy użyciu tej implementacji wolne od blokady, puli wątków zużywa mniej czasu, gdy kolejki i usuwania kolejki elementów roboczych. Ta korzyść wydajności jest dostępny dla wszystkich programów, które używają puli wątków.  
  
 Zadania najwyższego poziomu, które są zadania, które nie są tworzone w kontekście innego zadania, są umieszczane w kolejce globalnego, podobnie jak dowolnej innej pozycji roboczej. Jednak zagnieżdżone lub zadań podrzędnych, które są tworzone w kontekście innego zadania, są obsługiwane odbywa się zupełnie inaczej. Podrzędne lub zadania zagnieżdżonego jest umieszczana w kolejce lokalnej, która zależy od do wątku, na którym jest wykonywane zadanie nadrzędne. Zadanie nadrzędne może być zadania najwyższego poziomu, lub też może być elementem podrzędnym innego zadania. Kiedy ten wątek jest gotowy do pracy, najpierw szuka w lokalnej kolejce. Jeśli istnieje oczekujące elementy robocze mogą być dostępne szybko. Lokalne kolejki są dostępne w ostatni na wejściu, kolejności FIFO (LIFO), zachować lokalność pamięci podręcznej do zmniejszenia stopnia rywalizacji. Aby uzyskać więcej informacji dotyczących zadania zagnieżdżone i zadania podrzędne, zobacz [dołączone i odłączone zadania podrzędne](~/docs/standard/parallel-programming/attached-and-detached-child-tasks.md).  
  
 Korzystanie z kolejek lokalnych nie tylko zmniejsza wykorzystanie kolejki globalnych, ale również korzysta z zalet lokalizacja danych. Elementy robocze w lokalnej kolejce często odwołanie do struktur danych, które są fizycznie blisko siebie nawzajem w pamięci. W takich przypadkach dane są już w pamięci podręcznej po pierwsze zadanie zostało uruchomione i mogą być dostępne szybko. Zarówno [Parallel LINQ (PLINQ)](~/docs/standard/parallel-programming/parallel-linq-plinq.md) i <xref:System.Threading.Tasks.Parallel> często klasy zagnieżdżone użycie zadania i zadania podrzędne i osiągnąć znaczne szybsze przy użyciu funkcji kolejek pracy lokalnej.  
  
<a name="Stealing"></a>   
### <a name="work-stealing"></a>Praca, kradzież  
 Począwszy od programu .NET Framework 4, puli wątków obejmuje także algorytmu kradzież pracy, pomaga zapewnić zapewnia żadne wątki bezczynności podczas nadal mieć pracują w kolejkach, ich. Kiedy wątek puli wątków jest gotowy do pracy, najpierw przeszukuje na czele lokalnej kolejki, następnie w kolejce globalne, a następnie w kolejkach lokalnych innych wątków. Jeśli znajdzie elementu roboczego w lokalnej kolejce inny wątek najpierw stosuje Algorytm heurystyczny, aby upewnić się, że praca może działać wydajnie. Jeśli jest to możliwe, usuwanie kolejek elementu roboczego z zakończeniem (w kolejności FIFO). To ogranicza rywalizację o każdej kolejki lokalne i zachowuje lokalizacja danych. Ta architektura pozwala wątek puli równoważenia obciążenia pracować wydajniej niż poprzednich wersji.  
  
<a name="LongRunning"></a>   
### <a name="long-running-tasks"></a>Długotrwałych zadań  
 Można jawnie uniemożliwić zadania umieszczeniem w lokalnej kolejce. Na przykład wiadomo, że danego elementu pracy będzie wykonywany dla stosunkowo długo i może zablokować wszystkie inne elementy robocze w lokalnej kolejce. W takim przypadku można określić <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType> opcja, która dostarcza wskazówkę obiektowi harmonogram, że dodatkowy wątek może być wymagane dla zadania tak, aby nie blokować postęp innych wątków lub elementów roboczych w lokalnej kolejce. Przy użyciu tej opcji pozwala uniknąć puli wątków całkowicie, łącznie z kolejkami globalne i lokalne.  
  
<a name="Inlining"></a>   
### <a name="task-inlining"></a>Wbudowanie zadania  
 W niektórych przypadkach, gdy <xref:System.Threading.Tasks.Task> to czas potrzebny, on mogą być wykonywane synchronicznie w wątku, który wykonuje operację oczekiwania. To zwiększa wydajność poprzez zapobieganie potrzebę dodatkowy wątek i zamiast tego przy użyciu istniejącego wątku, który będzie zablokowany w przeciwnym razie. Aby zapobiec wystąpieniu błędów z powodu re-entrancy, wbudowanie zadania wykonywane tylko w przypadku docelowej oczekiwania znajduje się w lokalnej kolejce odpowiednie wątku.  
  
<a name="Sync"></a>   
## <a name="specifying-a-synchronization-context"></a>Określanie kontekstu synchronizacji  
 Możesz użyć <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType> metodę, aby określić, że zadanie powinno zostać zaplanowane do uruchomienia na określonego wątku. Jest to przydatne w przypadku środowisk, takich jak formularze Windows i Windows Presentation Foundation, gdzie dostęp do obiektów interfejsu użytkownika często jest ograniczony do kodu, który działa na tym samym wątku, na którym został utworzony obiekt interfejsu użytkownika.  
  
 W poniższym przykładzie użyto <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType> metody w aplikacji Windows Presentation Foundation (WPF), aby zaplanować zadanie, w tym samym wątku, utworzonego kontrolki interfejsu użytkownika.   Ten przykład tworzy mozaiki obrazów, które są wybierane losowo spośród określonego katalogu. Obiekty WPF są używane do ładowania i zmienianie rozmiaru obrazów. Nieprzetworzone pikseli są następnie przekazywane do zadania, które używa <xref:System.Threading.Tasks.Parallel.For%2A> pętli do zapisywania danych pikseli na dużą tablicę jednobajtowych. Synchronizacja nie jest wymagana, ponieważ żadne dwa Kafelki zajmować się te same elementy tablicy. Kafelki również będą zapisywane w dowolnej kolejności, ponieważ ich pozycja jest obliczany niezależnie od innych kafelków. Dużą tablicę jest następnie przekazywany do zadania, które jest uruchamiane w wątku interfejsu użytkownika, gdzie dane pikseli są ładowane do kontrolkę typu obraz.  
  
 Przykład przenoszenia danych poza wątku interfejsu użytkownika, modyfikuje je za pomocą pętli równoległych i <xref:System.Threading.Tasks.Task> obiektów, a następnie przekazuje go do zadań, które jest uruchamiane w wątku interfejsu użytkownika. To podejście jest przydatne, gdy trzeba użyć Biblioteka zadań równoległych do wykonywania operacji, które nie są obsługiwane przez interfejs API WPF lub nie są wystarczająco szybko. Innym sposobem tworzenia mozaiki obrazu na platformie WPF jest użycie <xref:System.Windows.Controls.WrapPanel?displayProperty=nameWithType> kontroli i dodać do niej obrazy. <xref:System.Windows.Controls.WrapPanel> Obsługuje pracy pozycjonowania Kafelki. Jednak tej pracy można wykonać tylko w wątku interfejsu użytkownika.  
  
 [!code-csharp[TPL_SyncContext#01](~/samples/snippets/csharp/VS_Snippets_Misc/tpl_synccontext/cs/mainwindow.xaml.cs#01)]
 [!code-vb[TPL_SyncContext#01](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl_synccontext/vb/MainWindow.xaml.vb#01)]  
  
 Aby utworzyć przykład, Utwórz projekt aplikacji WPF w programie Visual Studio i nadaj jej nazwę na WPF_CS1 (dla C# projekt WPF) lub WPF_VB1 (w projekcie WPF w języku Visual Basic). Następnie wykonaj poniższe czynności:  
  
1. W widoku projektu przeciągnij <xref:System.Windows.Controls.Image> z kontrolować **przybornika** na lewym górnym rogu powierzchni projektowej. W **nazwa** pole tekstowe z **właściwości** oknie Nazwa kontrolki "image".    
  
2. Przeciągnij <xref:System.Windows.Controls.Button> z kontrolować **przybornika** do lewej dolnej części okna aplikacji. W widoku XAML, określ <xref:System.Windows.Controls.ContentControl.Content%2A> właściwość przycisku jako "Marka mozaiki", a następnie określ jej <xref:System.Windows.FrameworkElement.Width> właściwości jako "100". Połącz <xref:System.Windows.Controls.Primitives.ButtonBase.Click> zdarzenie z `button_Click` programu obsługi zdarzeń zdefiniowanych w przykładowym kodzie, dodając `Click="button_Click"` do `<Button>` elementu. W **nazwa** pole tekstowe z **właściwości** oknie Nazwa kontrolki "button".  
  
3. Zamień całą zawartość pliku MainWindow.xaml.cs lub MainWindow.xaml.vb kod z tego przykładu. Aby uzyskać C# WPF projektu, upewnij się, że nazwa obszaru roboczego odpowiada nazwę projektu. 
  
4. Przykład odczytuje obrazy JPEG z katalogu o nazwie obrazy C:\Users\Public\Pictures\Sample\\. Tworzenie katalogu i umieścić niektóre obrazy w niej lub zmienić ścieżkę do odwoływania się do innego katalogu, który zawiera obrazy. 
  
W tym przykładzie ma pewne ograniczenia. Na przykład obsługiwane są tylko 32-bity każdego piksela obrazy; obrazy w innych formatach są uszkodzone, przez <xref:System.Windows.Media.Imaging.BitmapImage> obiektu podczas operacji zmiany rozmiaru. Ponadto obrazy źródłowe wszystkie muszą być większe niż rozmiar kafelka. Jako dodatkowe ćwiczenie można dodawać funkcje do obsługi wielu formatów pikseli i rozmiarów plików.  
  
## Examples  
 Poniższy przykład pochodzi z [przykłady dotyczące programowania równoległego za pomocą programu .NET Framework 4](https://go.microsoft.com/fwlink/?LinkID=165717) w witrynie sieci Web galerii kodu MSDN.  Powoduje utworzenie harmonogramu niestandardowego zadania, która ogranicza liczbę wątków używanych przez aplikację. Następnie uruchamia dwa rodzaje zadań i wyświetla informacje na temat wątku, na którym jest wykonywane zadanie i zadania.  
  
 [!code-csharp[TPL_Schedulers#02](~/samples/snippets/csharp/VS_Snippets_Misc/tpl_schedulers/cs/limitex1.cs#02)]
 [!code-vb[TPL_Schedulers#02](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl_schedulers/vb/module2.vb#02)]  
  
 Ponadto kilka harmonogramów zadań próbki są dostępne w galerii kodów: [Przykłady dotyczące programowania równoległego za pomocą programu .NET Framework 4](https://go.microsoft.com/fwlink/?LinkID=165717).  
  
 ]]></format>
    </remarks>
    <threadsafe>Wszyscy członkowie abstrakcyjnej <see cref="T:System.Threading.Tasks.TaskScheduler" /> typu są bezpieczne pod względem wątku i mogą być używane jednocześnie z wielu wątków.</threadsafe>
    <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
    <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteka zadań równoległych (TPL)</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected TaskScheduler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; TaskScheduler();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje <see cref="T:System.Threading.Tasks.TaskScheduler" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteka zadań równoległych (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskScheduler Current" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Current" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Current As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::TaskScheduler ^ Current { System::Threading::Tasks::TaskScheduler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskScheduler.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Threading.Tasks.TaskScheduler" /> skojarzone z aktualnie przeprowadzane zadanie.</summary>
        <value>Zwraca <see cref="T:System.Threading.Tasks.TaskScheduler" /> skojarzone z aktualnie przeprowadzane zadanie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy nie wywołane z wnętrza zadania, <xref:System.Threading.Tasks.TaskScheduler.Current%2A> zwróci <xref:System.Threading.Tasks.TaskScheduler.Default%2A> harmonogramu.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Threading.Tasks.TaskScheduler>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteka zadań równoległych (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskScheduler Default" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::TaskScheduler ^ Default { System::Threading::Tasks::TaskScheduler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Default : System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskScheduler.Default" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera domyślny <see cref="T:System.Threading.Tasks.TaskScheduler" /> wystąpienia, który znajduje się w programie .NET Framework.</summary>
        <value>Zwraca domyślny <see cref="T:System.Threading.Tasks.TaskScheduler" /> wystąpienia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji, zobacz <xref:System.Threading.Tasks.TaskScheduler>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteka zadań równoległych (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~TaskScheduler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!TaskScheduler ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="taskScheduler.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszystkie zasoby skojarzone z tym harmonogramem.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FromCurrentSynchronizationContext">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler FromCurrentSynchronizationContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.TaskScheduler FromCurrentSynchronizationContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromCurrentSynchronizationContext () As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::TaskScheduler ^ FromCurrentSynchronizationContext();" />
      <MemberSignature Language="F#" Value="static member FromCurrentSynchronizationContext : unit -&gt; System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy <see cref="T:System.Threading.Tasks.TaskScheduler" /> skojarzone z bieżącym <see cref="T:System.Threading.SynchronizationContext" />.</summary>
        <returns>A <see cref="T:System.Threading.Tasks.TaskScheduler" /> skojarzone z bieżącym <see cref="T:System.Threading.SynchronizationContext" />, zgodnie z ustaleniami <see cref="P:System.Threading.SynchronizationContext.Current" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszystkie <xref:System.Threading.Tasks.Task> w kolejce do zwracanego wystąpienia usługi scheduler zostaną wykonane za pomocą wywołania <xref:System.Threading.SynchronizationContext.Post%2A> metody w tym kontekście.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Threading.Tasks.TaskScheduler>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Bieżący SynchronizationContext nie może służyć jako harmonogramu zadań systemu.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteka zadań równoległych (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="GetScheduledTasks">
      <MemberSignature Language="C#" Value="protected abstract System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt; GetScheduledTasks ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task&gt; GetScheduledTasks() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetScheduledTasks () As IEnumerable(Of Task)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task ^&gt; ^ GetScheduledTasks();" />
      <MemberSignature Language="F#" Value="abstract member GetScheduledTasks : unit -&gt; seq&lt;System.Threading.Tasks.Task&gt;" Usage="taskScheduler.GetScheduledTasks " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Debuger pomocy technicznej, generuje element wyliczalny z <see cref="T:System.Threading.Tasks.Task" /> wystąpień aktualnie czekają w kolejce do harmonogramu oczekujących na wykonanie.</summary>
        <returns>Moduł wyliczający, który umożliwia debugera do obecnie przechodzenie przez zadania w kolejce do tego harmonogramu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasa pochodząca z <xref:System.Threading.Tasks.TaskScheduler> implementuje tę metodę w celu obsługi integracji z debugery. Ta metoda będzie można wywołać tylko w programie .NET Framework, gdy debuger żąda dostępu do danych. Wyliczenia zwrócony zostanie przesunięta dzięki możliwości debugowania narzędzi do dostępu do zadań aktualnie w kolejce do tego harmonogramem, dzięki czemu debugera, aby zapewnić reprezentację tę informację w interfejsie użytkownika.  
  
 Należy pamiętać, ta metoda jest wywoływana, będzie można zablokować wszystkie wątki w procesie. W związku z tym jest ważne, aby uniknąć synchronizacji z innych wątków, które mogą prowadzić do zablokowania. Jeśli zachodzi synchronizacji i nie można uzyskać blokady w ramach tej metody, następnie należy zgłoszenie wyjątku, aby debuger nie zawieszeniu. Poniższy przykład przedstawia jedną z możliwych rozwiązań w języku C#:  
  
```  
protected override IEnumerable<Task> GetScheduledTasks()  
{  
    bool lockTaken = false;  
    try  
    {  
        Monitor.TryEnter(_syncObj, ref lockTaken);  
        if (lockTaken)  
        {  
            return _tasks.ToArray();  
        }  
        else throw new NotSupportedException();  
    }  
    finally  
    {  
    if (lockTaken) Monitor.Exit(_syncObj);  
    }}  
```  
  
 Ponadto ta metoda i wyliczalny zwracane nie wolno modyfikować każdy stan widoczne globalnie.  
  
 Zwrócone wyliczalny, nigdy nie powinien mieć wartość null. Jeśli nie ma obecnie żadnych zadań umieszczonych w kolejce, pusta wyliczalny należy zamiast tego zostanie zwrócony.  
  
 Deweloperzy, którzy wdrażają debugery niestandardowe nie należy bezpośrednio wywołać tę metodę, ale należy użyć metody otoki wewnętrznego `GetScheduledTasksForDebugger` zamiast: `internal Task[] GetScheduledTasksForDebugger()`. Ta metoda otoki zwraca tablicę zadań zamiast wyliczalny. Aby pobrać listę aktywnych harmonogramów, użyj metody wewnętrznej `internal static TaskScheduler[] GetTaskSchedulersForDebugger()`. Ta metoda statyczna zwraca tablicę wszystkich aktywnych <xref:System.Threading.Tasks.TaskScheduler> wystąpień. Następnie można użyć `GetScheduledTasksForDebugger` na każde wystąpienie harmonogramu można pobrać listy zaplanowanych zadań.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Ten harmonogram nie mógł wygenerować listy zadań podrzędnych w kolejce w tej chwili.</exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteka zadań równoległych (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.Threading.Tasks.TaskScheduler.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera unikatowy identyfikator dla tego <see cref="T:System.Threading.Tasks.TaskScheduler" />.</summary>
        <value>Zwraca unikatowy identyfikator dla tej klasy <see cref="T:System.Threading.Tasks.TaskScheduler" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji, zobacz <xref:System.Threading.Tasks.TaskScheduler>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteka zadań równoległych (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="MaximumConcurrencyLevel">
      <MemberSignature Language="C#" Value="public virtual int MaximumConcurrencyLevel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaximumConcurrencyLevel" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property MaximumConcurrencyLevel As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int MaximumConcurrencyLevel { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MaximumConcurrencyLevel : int" Usage="System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wskazuje poziom współbieżności maksymalną, to <see cref="T:System.Threading.Tasks.TaskScheduler" /> umożliwiającą obsługę.</summary>
        <value>Zwraca liczbę całkowitą, która reprezentuje poziom współbieżności maksymalną. Zwraca domyślnego harmonogramu <see cref="F:System.Int32.MaxValue" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji, zobacz <xref:System.Threading.Tasks.TaskScheduler>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteka zadań równoległych (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="QueueTask">
      <MemberSignature Language="C#" Value="protected internal abstract void QueueTask (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void QueueTask(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract void QueueTask(System::Threading::Tasks::Task ^ task);" />
      <MemberSignature Language="F#" Value="abstract member QueueTask : System.Threading.Tasks.Task -&gt; unit" Usage="taskScheduler.QueueTask task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task"><see cref="T:System.Threading.Tasks.Task" /> Do umieszczone w kolejce.</param>
        <summary>Kolejki <see cref="T:System.Threading.Tasks.Task" /> do harmonogramu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasa pochodząca z <xref:System.Threading.Tasks.TaskScheduler> implementuje tę metodę, aby zaakceptować zadania zaplanowane w ramach harmonogramu zadań.  
  
 Typowa implementacja będzie przechowywać zadania w strukturze danych wewnętrznych, które będą obsługiwane przez wątki, które spowoduje wykonanie tych zadań w czasie w przyszłości.  
  
 Ta metoda jest przeznaczone wyłącznie do można wywoływać za pomocą programu .NET Framework i nie powinien być wywoływany bezpośrednio przez klasy pochodnej. Jest to konieczne utrzymanie spójności systemu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="task" /> Argument ma wartość null.</exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteka zadań równoległych (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="TryDequeue">
      <MemberSignature Language="C#" Value="protected internal virtual bool TryDequeue (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool TryDequeue(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool TryDequeue(System::Threading::Tasks::Task ^ task);" />
      <MemberSignature Language="F#" Value="abstract member TryDequeue : System.Threading.Tasks.Task -&gt; bool&#xA;override this.TryDequeue : System.Threading.Tasks.Task -&gt; bool" Usage="taskScheduler.TryDequeue task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task"><see cref="T:System.Threading.Tasks.Task" /> Do być usuwane z kolejki.</param>
        <summary>Podejmuje próbę usuwania z kolejki <see cref="T:System.Threading.Tasks.Task" /> który został wcześniej w kolejce do tego harmonogramu.</summary>
        <returns>Wartość logiczna wskazująca czy <paramref name="task" /> argument był dequeued pomyślnie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji, zobacz <xref:System.Threading.Tasks.TaskScheduler>.  
  
 Ta metoda może być wykonywany w bloku finally; w związku z tym powinien zostać zwrócony tak szybko, jak to możliwe tak że dowolne zasoby, takie jak <xref:System.Threading.CancellationTokenRegistration> obiekty mogą być usuwane w sposób terminowy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="task" /> Argument ma wartość null.</exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteka zadań równoległych (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="TryExecuteTask">
      <MemberSignature Language="C#" Value="protected bool TryExecuteTask (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool TryExecuteTask(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool TryExecuteTask(System::Threading::Tasks::Task ^ task);" />
      <MemberSignature Language="F#" Value="member this.TryExecuteTask : System.Threading.Tasks.Task -&gt; bool" Usage="taskScheduler.TryExecuteTask task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task">Element <see cref="T:System.Threading.Tasks.Task" /> obiektu do wykonania.</param>
        <summary>Podejmuje próbę wykonania podanych <see cref="T:System.Threading.Tasks.Task" /> w tym harmonogramie.</summary>
        <returns>Wartość logiczna oznacza to wartość true, jeśli <paramref name="task" /> zostało wykonane pomyślnie, wartość false, jeśli nie było. Typową przyczyną niepowodzenia wykonywania jest, że zadanie wcześniej zostały wykonane lub trwa proces wykonywany przez inny wątek.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Harmonogram implementacje są dostarczane z <xref:System.Threading.Tasks.Task> wystąpień do wykonania przy użyciu jednej <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A> metody lub <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline%2A> metody. Gdy harmonogram uzna to za właściwe uruchomić zadanie podana <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> należy to zrobić. TryExecuteTask obsługuje wszystkich aspektów wykonywania zadania, w tym wywołanie akcji, obsługa wyjątków, zarządzanie stanem i kontroli cyklu życia.  
  
 <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> może być używana tylko dla zadań dostarczane do tego harmonogramu przez infrastrukturę programu .NET Framework. Nie można stosować można wykonać dowolne zadania uzyskane za pomocą niestandardowych mechanizmów.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="task" /> Nie jest skojarzony z tym harmonogramem.</exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteka zadań równoległych (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="TryExecuteTaskInline">
      <MemberSignature Language="C#" Value="protected abstract bool TryExecuteTaskInline (System.Threading.Tasks.Task task, bool taskWasPreviouslyQueued);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool TryExecuteTaskInline(class System.Threading.Tasks.Task task, bool taskWasPreviouslyQueued) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool TryExecuteTaskInline(System::Threading::Tasks::Task ^ task, bool taskWasPreviouslyQueued);" />
      <MemberSignature Language="F#" Value="abstract member TryExecuteTaskInline : System.Threading.Tasks.Task * bool -&gt; bool" Usage="taskScheduler.TryExecuteTaskInline (task, taskWasPreviouslyQueued)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
        <Parameter Name="taskWasPreviouslyQueued" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="task"><see cref="T:System.Threading.Tasks.Task" /> Do wykonania.</param>
        <param name="taskWasPreviouslyQueued">Wartość logiczna wskazująca, czy zadanie zostało wcześniej umieszczone w kolejce. Jeśli ten parametr ma wartość True, następnie zadanie może wcześniej dodane do kolejki (zaplanowane); Jeśli ma wartość FAŁSZ, następnie zadanie jest znane nie zostały umieszczone w kolejce, a to wywołanie jest wykonywane w celu wykonywania zadań w tekście bez usługi kolejkowania go.</param>
        <summary>Określa, czy podany <see cref="T:System.Threading.Tasks.Task" /> mogą być wykonywane synchronicznie, w tym wywołaniu i jeśli jest to możliwe, wykonuje on.</summary>
        <returns>Wartość logiczna wskazująca, czy zadanie był wykonywany w tekście.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasa pochodząca z <xref:System.Threading.Tasks.TaskScheduler> implementuje tej funkcji do obsługi wykonywania śródwierszowego zadania w wątku, który inicjuje oczekiwania dla tego obiektu zadania. Wykonywanie śródwierszowe jest opcjonalny, a żądania mogą zostać odrzucone przez zwrócenie wartości false. Jednak większej liczby zadań, może być śródwierszowa, tym lepsze harmonogram będzie skalowana. W rzeczywistości harmonogram tego inlines zbyt nieco mogą być podatne na zakleszczenia. Prawidłowego wdrożenia należy upewnić się, że wykonywania żądania w obszarze zasady gwarantowane przez harmonogram może pomyślnie wbudowanego. Na przykład, jeśli harmonogramu używa dedykowany wątek służący do wykonywania zadań, wszelkie wbudowanie żądania z tego wątku ma być pomyślnie wykonane.  
  
 Jeśli harmonogramu decyduje o do wykonywania wykonywania śródwierszowego, go należy to zrobić za pośrednictwem wywołania do podstawowej TaskScheduler <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> metody za pomocą obiektu task podana propagowanie wartości zwracanej. Może to być również odpowiednie usługi scheduler do usuwania zadań śródwierszowych jego wewnętrznych struktur danych zdecyduje się do tego żądania wbudowanie. Należy jednak pamiętać, że w pewnych okolicznościach harmonogramu może być konieczne podanie wbudowane zadanie, które wcześniej nie został podany do niego za pomocą <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A> metody.  
  
 Pochodne harmonogramu jest odpowiedzialny za zagwarantowanie, że wątek wywołujący nadaje się do wykonywania danego zadania w miarę własnych harmonogramów i zasad wykonywania są.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Threading.Tasks.TaskScheduler>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="task" /> Argument ma wartość null.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="task" /> Zostało już wykonane.</exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteka zadań równoległych (TPL)</related>
      </Docs>
    </Member>
    <Member MemberName="UnobservedTaskException">
      <MemberSignature Language="C#" Value="public static event EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; UnobservedTaskException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; UnobservedTaskException" />
      <MemberSignature Language="DocId" Value="E:System.Threading.Tasks.TaskScheduler.UnobservedTaskException" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event UnobservedTaskException As EventHandler(Of UnobservedTaskExceptionEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler&lt;System::Threading::Tasks::UnobservedTaskExceptionEventArgs ^&gt; ^ UnobservedTaskException;" />
      <MemberSignature Language="F#" Value="member this.UnobservedTaskException : EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; " Usage="member this.UnobservedTaskException : System.EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wyjątek niewidocznego uszkodzoną zadanie ma zasady eskalacji wyjątek, który domyślnie zakończy się proces wyzwalacza.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie na poziomie domeny aplikacji udostępnia mechanizm do uniemożliwić zasady eskalacji wyjątków (która domyślnie kończy proces) z procesu wyzwalania.  
  
 Aby ułatwić programistom pisanie kodu asynchronicznego, na podstawie zadań, [!INCLUDE[net_v45](~/includes/net-v45-md.md)] zmienia domyślne zachowanie wyjątek niewidocznego wyjątków. Mimo że nadal niewidocznego wyjątki podnieść <xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException> wyjątku, proces kończy domyślnie. Zamiast tego wyjątku jest obsługiwany przez środowisko uruchomieniowe po zdarzenie jest wywoływane niezależnie od tego, czy program obsługi zdarzeń przestrzega wyjątek. To zachowanie można skonfigurować. Począwszy od [!INCLUDE[net_v45](~/includes/net-v45-md.md)], możesz użyć [ `<ThrowUnobservedTaskExceptions>` ](~/docs/framework/configure-apps/file-schema/runtime/throwunobservedtaskexceptions-element.md) element konfiguracji, aby przywrócić działanie [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] i przerwać proces:  
  
```xml  
<configuration>   
   <runtime>   
      <ThrowUnobservedTaskExceptions enabled="true"/>   
   </runtime>   
</configuration>  
  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteka zadań równoległych (TPL)</related>
        <related type="Article" href="~/docs/framework/configure-apps/file-schema/runtime/throwunobservedtaskexceptions-element.md">&lt;Throwunobservedtaskexceptions —&gt; — Element</related>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="TaskScheduler" FullName="System.Threading.Tasks.TaskScheduler">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="4d9adf13c8a7e851e5512c4b8b0e6ada78afa563" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36407623" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class TaskScheduler" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit TaskScheduler extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.TaskScheduler" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class TaskScheduler" />
  <TypeSignature Language="C++ CLI" Value="public ref class TaskScheduler abstract" />
  <TypeSignature Language="F#" Value="type TaskScheduler = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("Id={Id}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Threading.Tasks.TaskScheduler/SystemThreadingTasks_TaskSchedulerDebugView))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje obiekt, który obsługuje niskiego poziomu pracy Kolejkowanie zadań na wątków.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wystąpienie <xref:System.Threading.Tasks.TaskScheduler> klasa reprezentuje harmonogramu zadań. Harmonogram zadań zapewnia ostatecznie wykonaniem pracy zadania.  
  
 Harmonogram zadań domyślna jest oparta na puli wątków .NET Framework 4, co zapewnia kradzież pracy dla usługi równoważenia obciążenia, wątek iniekcji/wycofania dla maksymalnej przepustowości i ogólnej dobrą wydajność. Powinny być wystarczające w większości scenariuszy.  
  
 <xref:System.Threading.Tasks.TaskScheduler> Klasy służy również jako punkt rozszerzenia wszystkie dostosowania logiki planowania.  Zawiera mechanizmy, takie jak sposób tworzenia harmonogramu zadań do wykonania i jak zaplanowanych zadań powinny zostać ujawnione do debugera. Jeśli wymagają specjalnych funkcji, można tworzyć harmonogramu niestandardowego i włącz ją dla określonych zadań lub zapytań.  
  
 W tym temacie:  
[Domyślny harmonogram zadań i puli wątków](#Default)  
 [Globalne kolejki a lokalnych kolejek](#Queues)  
 [Praca kradzież](#Stealing)  
 [Długotrwałych zadań](#LongRunning)  
 [Zadania ze śródwierszowaniem](#Inlining)  
[Określanie kontekstu synchronizacji](#Sync)  
  
<a name="Default"></a>   
## <a name="the-default-task-scheduler-and-the-thread-pool"></a>Domyślny harmonogram zadań i puli wątków  
 Harmonogram domyślnej bibliotece równoległych zadań i PLINQ korzysta z puli wątków .NET Framework, która jest reprezentowana przez <xref:System.Threading.ThreadPool> klasy do kolejki i do pracy. Informacje, które są udostępniane przez korzysta z puli wątków <xref:System.Threading.Tasks.Task> typ do obsługi szczegółowych równoległości (krótkim okresie jednostki pracy) równoległych zadań i zapytania często odpowiadają.  
  
<a name="Queues"></a>   
### <a name="the-global-queue-vs-local-queues"></a>Globalne kolejki a lokalnych kolejek  
 Pula wątków przechowuje globalne FIFO (pierwszy w, FIFO) pracy kolejkę dla wątków w każdej domenie aplikacji. Gdy program wywołuje <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A?displayProperty=nameWithType> (lub <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A?displayProperty=nameWithType>) metody pracy jest należy umieścić w tej kolejce udostępnionego i ostatecznie cofnąć oczekujących na następny wątek, który staje się dostępny. Począwszy od programu .NET Framework 4, ta kolejka została ulepszona próbę użycia algorytmu zwolnić blokady, podobny <xref:System.Collections.Concurrent.ConcurrentQueue%601> klasy. Przy użyciu tej implementacji zwolnić blokady, puli wątków zużywa mniej czasu, gdy kolejki i usuwania kolejki elementów roboczych. Świadczenie wydajności jest dostępne dla wszystkich programów używających puli wątków.  
  
 Zadania najwyższego poziomu, które są zadania, które nie są tworzone w ramach innego zadania, są umieszczane w kolejce globalnych, podobnie jak wszystkie inne elementy robocze. Jednak zagnieżdżone lub zadania podrzędne, które są tworzone w ramach innego zadania, są obsługiwane odbywa się zupełnie inaczej. Obiekt podrzędny lub zadania zagnieżdżonego jest umieszczany w lokalnej kolejce, specyficzne dla wątku, na którym jest wykonywany zadaniem nadrzędnym. Zadaniem nadrzędnym może być zadanie najwyższego poziomu lub też może być elementem podrzędnym innego zadania. Gdy ten wątek jest gotowa do pracy, najpierw wyszukiwana w lokalnej kolejce. Jeśli istnieje oczekujące elementów roboczych, są one szybko dostępne. Kolejek lokalnych są dostępne w ostatniej, w kolejności FIFO (LIFO), aby zachować lokalizację pamięci podręcznej i zmniejszyć rywalizacji. Aby uzyskać więcej informacji na temat zadań podrzędnych i zagnieżdżone, zobacz [dołączonego i odłączone zadania podrzędne](~/docs/standard/parallel-programming/attached-and-detached-child-tasks.md).  
  
 Korzystanie z kolejek lokalnych nie tylko zmniejsza nacisk na globalne kolejki, ale również korzysta z danych lokalizacji. Elementów roboczych w lokalnej kolejce często struktur danych odwołania, które znajdują się fizycznie obok siebie w pamięci. W takich przypadkach dane są już w pamięci podręcznej po pierwsze zadanie zostało uruchomione i szybko dostępne. Zarówno [równoległe LINQ (PLINQ)](~/docs/standard/parallel-programming/parallel-linq-plinq.md) i <xref:System.Threading.Tasks.Parallel> często klasy użyj zagnieżdżone zadań i zadań podrzędnych, a osiągnąć znaczne speedups za pomocą kolejek pracy lokalnej.  
  
<a name="Stealing"></a>   
### <a name="work-stealing"></a>Praca kradzież  
 Począwszy od programu .NET Framework 4, puli wątków również funkcje algorytmu kradzież pracy pomaga zapewnić miejsca nie wątków bezczynności podczas nadal mieć pracują w ich kolejek. Gdy wątku puli wątków jest gotowa do pracy, najpierw analizuje nagłówek kolejki lokalnej, następnie w kolejce globalne, a następnie w kolejkach lokalnych innych wątków. Jeśli znajdzie elementu roboczego w lokalnej kolejce inny wątek najpierw stosuje Algorytm heurystyczny, aby upewnić się, że jego sprawnego działania pracy. Jeśli tak, usuń zaznaczenie pola kolejek elementu roboczego z tail (w kolejności FIFO). To ogranicza rywalizację na każdej kolejki lokalne i zachowuje lokalizację danych. Taka architektura pomaga w wątku puli równoważenia obciążenia pracować wydajniej niż poprzednich wersji.  
  
<a name="LongRunning"></a>   
### <a name="long-running-tasks"></a>Długotrwałych zadań  
 Można jawnie uniemożliwić zadania są umieszczone w lokalnej kolejce. Na przykład wiadomo, że elementu roboczego określonego uruchomi dość długo i może zablokować innych elementów pracy w lokalnej kolejce. W takim przypadku można określić <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType> opcja, która stanowi wskazówkę harmonogramu, że dodatkowe wątku mogą być wymagane dla zadania, aby nie blokować postęp innych wątków lub elementy robocze w lokalnej kolejce. Za pomocą tej opcji można uniknąć puli wątków całkowicie, łącznie z kolejkami globalne i lokalne.  
  
<a name="Inlining"></a>   
### <a name="task-inlining"></a>Zadania ze śródwierszowaniem  
 W niektórych przypadkach, gdy <xref:System.Threading.Tasks.Task> jest czas potrzebny na, jego mogą być wykonywane synchronicznie w wątku, który wykonuje operację oczekiwania. Zwiększa wydajność przez zapobieganie potrzebę dodatkowe wątku i zamiast tego przy użyciu istniejących wątek, które mogłyby w przeciwnym razie zablokowanych. Aby uniknąć błędów spowodowanych re-entrancy, zadania ze śródwierszowaniem wykonywane tylko w przypadku docelowej oczekiwania znajduje się w lokalnej kolejce odpowiednich wątku.  
  
<a name="Sync"></a>   
## <a name="specifying-a-synchronization-context"></a>Określanie kontekstu synchronizacji  
 Można użyć <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType> metodę, aby określić, że zadanie powinny zostać zaplanowane do uruchomienia w szczególności wątku. Jest to przydatne w przypadku platform, takich jak formularzy systemu Windows i Windows Presentation Foundation, gdy dostęp do obiektów interfejsu użytkownika często jest ograniczony do kodu, który działa na tym samym wątku, w którym został utworzony obiekt interfejsu użytkownika.  
  
 W poniższym przykładzie użyto <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType> metody w aplikacji Windows Presentation Foundation (WPF), można zaplanować zadania na tym samym wątku, utworzonego formantu interfejsu użytkownika.   W przykładzie jest tworzony mozaiki obrazów, które są losowo dobierane spośród określonego katalogu. Obiekty WPF są używane do ładowania i zmienianie rozmiaru obrazów. Nieprzetworzone pikseli są następnie przekazywane do zadań, która używa <xref:System.Threading.Tasks.Parallel.For%2A> pętli do zapisania danych pikseli w dużą tablicę jednobajtowe. Synchronizacja nie jest wymagana, ponieważ nie dwa Kafelki zajmują niewiele miejsca w tej samej elementów tablicy. Kafelki również można pisać w dowolnej kolejności, ponieważ ich pozycja jest obliczana niezależnie od innych kafelka. Dużą tablicę są następnie przekazywane do zadania, które jest uruchamiane w wątku interfejsu użytkownika załadunku danych pikseli w formancie obrazu.  
  
 Przykład przenosi dane poza wątku interfejsu użytkownika, modyfikuje go za pomocą pętle równoległe i <xref:System.Threading.Tasks.Task> obiektów, a następnie przekazuje do zadania w wątku interfejsu użytkownika. Takie rozwiązanie jest przydatne, gdy należy użyć w celu wykonania operacji, które nie są obsługiwane przez interfejs API WPF, lub nie są dostatecznie szybkiego Biblioteka zadań równoległych. Innym sposobem tworzenia mozaiki obrazu na platformie WPF jest użycie <xref:System.Windows.Controls.WrapPanel?displayProperty=nameWithType> kontroli i dodać do niej obrazy. <xref:System.Windows.Controls.WrapPanel> Obsługuje pracy pozycjonowania Kafelki. Jednak tej pracy można wykonać tylko w wątku interfejsu użytkownika.  
  
 [!code-csharp[TPL_SyncContext#01](~/samples/snippets/csharp/VS_Snippets_Misc/tpl_synccontext/cs/mainwindow.xaml.cs#01)]
 [!code-vb[TPL_SyncContext#01](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl_synccontext/vb/MainWindow.xaml.vb#01)]  
  
 Aby utworzyć przykład, Utwórz projekt aplikacji WPF w programie Visual Studio i przypisać mu nazwę. Następnie wykonaj następujące czynności:  
  
1.  W widoku Projekt, przeciągnij <xref:System.Windows.Controls.Image> kontrolować z **przybornika** na powierzchnię projektu. W widoku XAML Określ wyrównanie w poziomie jako "Do lewej." Rozmiar nie ma znaczenia, ponieważ formant jest zmieniany dynamicznie w czasie wykonywania. Zaakceptuj nazwę domyślną, "obrazu".  
  
2.  Przeciągnij <xref:System.Windows.Controls.Button> kontrolować z **przybornika** do lewej dolnej części okna aplikacji. Kliknij dwukrotnie przycisk, aby dodać <xref:System.Windows.Controls.Primitives.ButtonBase.Click> obsługi zdarzeń. W widoku XAML, określ <xref:System.Windows.Controls.ContentControl.Content%2A> właściwość przycisku "Przechowuj mozaiki" i określ jej wyrównanie poziome "Od lewej". Zaakceptuj nazwę domyślną, "button".  
  
3.  Zastąp całą zawartość pliku MainWindow.xaml.cs lub MainWindow.xaml.vb kod z tego przykładu. Upewnij się, że nazwa obszaru roboczego odpowiada nazwie projektu.  
  
4.  Przykład odczytuje obrazy JPEG z katalogu o nazwie obrazy C:\Users\Public\Pictures\Sample\\. Utwórz katalog i umieść w nim niektóre obrazy lub zmień ścieżkę, aby odwoływać się do innego katalogu zawiera obrazy.  
  
 W tym przykładzie ma pewne ograniczenia. Na przykład obsługiwane są tylko 32-bity każdego piksela obrazy; obrazy w innych formatach są uszkodzone, przez <xref:System.Windows.Media.Imaging.BitmapImage> obiektu podczas operacji zmiany rozmiaru. Ponadto obrazków wszystkie muszą być większe niż rozmiar kafelka. Jako dodatkowe wykonywania można dodać funkcji obsługi wielu formatów pikseli i rozmiary plików.  
  
   
  
## Examples  
 Poniższy przykład pochodzi z [przykłady dla programowania równoległego przy użyciu programu .NET Framework 4](http://go.microsoft.com/fwlink/?LinkID=165717) w witrynie sieci Web galerii kodu MSDN.  Powoduje to utworzenie harmonogramu niestandardowego zadania, która ogranicza liczbę wątków używanych przez aplikację. Następnie uruchamia dwa zestawy zadań i wyświetla informacje o wątku, na którym jest wykonywane zadanie i zadania.  
  
 [!code-csharp[TPL_Schedulers#02](~/samples/snippets/csharp/VS_Snippets_Misc/tpl_schedulers/cs/limitex1.cs#02)]
 [!code-vb[TPL_Schedulers#02](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl_schedulers/vb/module2.vb#02)]  
  
 Ponadto kilka planiści zadań próbki są dostępne w galerii kodu: [przykłady dla programowania równoległego przy użyciu programu .NET Framework 4](http://go.microsoft.com/fwlink/?LinkID=165717).  
  
 ]]></format>
    </remarks>
    <threadsafe>Wszystkie elementy członkowskie klasy abstrakcyjnej <see cref="T:System.Threading.Tasks.TaskScheduler" /> typu są wątkowo i mogą być używane przez wiele wątków jednocześnie.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected TaskScheduler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; TaskScheduler();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje <see cref="T:System.Threading.Tasks.TaskScheduler" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskScheduler Current" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Current" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Current As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::TaskScheduler ^ Current { System::Threading::Tasks::TaskScheduler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskScheduler.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Threading.Tasks.TaskScheduler" /> skojarzony z aktualnie wykonywanego zadania.</summary>
        <value>Zwraca <see cref="T:System.Threading.Tasks.TaskScheduler" /> skojarzony z aktualnie wykonywanego zadania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy nie wywołane z wnętrza zadania, <xref:System.Threading.Tasks.TaskScheduler.Current%2A> zwróci <xref:System.Threading.Tasks.TaskScheduler.Default%2A> harmonogramu.  
  
 Aby uzyskać więcej informacji, zobacz <xref:System.Threading.Tasks.TaskScheduler>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskScheduler Default" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::TaskScheduler ^ Default { System::Threading::Tasks::TaskScheduler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Default : System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskScheduler.Default" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera domyślny <see cref="T:System.Threading.Tasks.TaskScheduler" /> wystąpienie, które jest dostępne w programie .NET Framework.</summary>
        <value>Zwraca domyślne <see cref="T:System.Threading.Tasks.TaskScheduler" /> wystąpienia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji, zobacz [planiści zadań](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromCurrentSynchronizationContext">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler FromCurrentSynchronizationContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.TaskScheduler FromCurrentSynchronizationContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromCurrentSynchronizationContext () As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::TaskScheduler ^ FromCurrentSynchronizationContext();" />
      <MemberSignature Language="F#" Value="static member FromCurrentSynchronizationContext : unit -&gt; System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy <see cref="T:System.Threading.Tasks.TaskScheduler" /> skojarzone z bieżącym <see cref="T:System.Threading.SynchronizationContext" />.</summary>
        <returns>A <see cref="T:System.Threading.Tasks.TaskScheduler" /> skojarzone z bieżącym <see cref="T:System.Threading.SynchronizationContext" />, zgodnie z ustaleniami <see cref="P:System.Threading.SynchronizationContext.Current" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszystkie <xref:System.Threading.Tasks.Task> wystąpień w kolejce w celu zwróconego harmonogramu będą wykonywane przez wywołanie <xref:System.Threading.SynchronizationContext.Post%2A> metody w tym kontekście.  
  
 Aby uzyskać więcej informacji, zobacz [planiści zadań](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Bieżący obiekt SynchronizationContext nie może być używany jako obiekt TaskScheduler.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetScheduledTasks">
      <MemberSignature Language="C#" Value="protected abstract System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt; GetScheduledTasks ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task&gt; GetScheduledTasks() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetScheduledTasks () As IEnumerable(Of Task)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task ^&gt; ^ GetScheduledTasks();" />
      <MemberSignature Language="F#" Value="abstract member GetScheduledTasks : unit -&gt; seq&lt;System.Threading.Tasks.Task&gt;" Usage="taskScheduler.GetScheduledTasks " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Debuger pomocy technicznej, generuje element wyliczalny z <see cref="T:System.Threading.Tasks.Task" /> wystąpień obecnie w kolejce do harmonogramu oczekujących na wykonanie.</summary>
        <returns>Moduł wyliczający, który umożliwia debugera obecnie przesyłanie zadań w kolejce do tego harmonogramu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasa pochodna od <xref:System.Threading.Tasks.TaskScheduler> implementuje tę metodę w celu zapewnienia obsługi integracji z debugery. Ta metoda będzie można wywołać tylko w programie .NET Framework, gdy debuger żąda dostępu do danych. Wyliczenia zwrócił będzie można przechodzić przez debugowania narzędzi do uzyskania dostępu do zadań obecnie w kolejce do tego harmonogramem, dzięki czemu debuger w celu zapewnienia reprezentację te informacje w interfejsie użytkownika.  
  
 Należy pamiętać, ta metoda jest wywoływana, będzie można zablokowane wątki w procesie. Dlatego jest ważne uniknąć synchronizacji z innych wątków, które mogą prowadzić do zablokowania. Jeśli synchronizacja jest niezbędne, a nie można uzyskać blokady w ramach tej metody, następnie należy powinien zgłosić wyjątek, aby debuger nie zawieszenie. W poniższym przykładzie przedstawiono jeden ze sposobów możliwe w języku C#:  
  
```  
protected override IEnumerable<Task> GetScheduledTasks()  
{  
    bool lockTaken = false;  
    try  
    {  
        Monitor.TryEnter(_syncObj, ref lockTaken);  
        if (lockTaken)  
        {  
            return _tasks.ToArray();  
        }  
        else throw new NotSupportedException();  
    }  
    finally  
    {  
    if (lockTaken) Monitor.Exit(_syncObj);  
    }}  
```  
  
 Ponadto ta metoda i wyliczenia zwrócił nie należy zmodyfikować każdy stan globalny widoczne.  
  
 Zwrócony wyliczalny, nigdy nie może mieć wartości null. Obecnie nie ma żadnych zadań w kolejce, zamiast tego należy zwrócony wyliczalny pusta.  
  
 Deweloperzy, którzy są Implementowanie niestandardowych debugery nie należy bezpośrednio wywołać tę metodę, ale powinien użyć metody wewnętrznej otoki `GetScheduledTasksForDebugger` zamiast: `internal Task[] GetScheduledTasksForDebugger()`. Ta metoda otoki zwraca tablicę zadań zamiast wyliczalny. Aby pobrać listę aktywnych planiści, użyj metody wewnętrznej `internal static TaskScheduler[] GetTaskSchedulersForDebugger()`. Ta metoda statyczna zwraca tablicę wszystkich aktywnych <xref:System.Threading.Tasks.TaskScheduler> wystąpień. Następnie można użyć `GetScheduledTasksForDebugger` na każde wystąpienie harmonogramu można pobrać listy zaplanowanych zadań.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Nie można wygenerować listy zadań w kolejce w tej chwili jest tego harmonogramu.</exception>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.Threading.Tasks.TaskScheduler.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera unikatowy identyfikator dla tego <see cref="T:System.Threading.Tasks.TaskScheduler" />.</summary>
        <value>Zwraca unikatowy identyfikator dla tego <see cref="T:System.Threading.Tasks.TaskScheduler" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji, zobacz [planiści zadań](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximumConcurrencyLevel">
      <MemberSignature Language="C#" Value="public virtual int MaximumConcurrencyLevel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaximumConcurrencyLevel" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property MaximumConcurrencyLevel As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int MaximumConcurrencyLevel { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MaximumConcurrencyLevel : int" Usage="System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wskazuje poziom współbieżności maksymalna to <see cref="T:System.Threading.Tasks.TaskScheduler" /> umożliwiającą obsługę.</summary>
        <value>Zwraca liczbę całkowitą przedstawiającą współbieżności maksymalny poziom. Zwraca domyślny harmonogram <see cref="F:System.Int32.MaxValue" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji, zobacz [planiści zadań](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueueTask">
      <MemberSignature Language="C#" Value="protected internal abstract void QueueTask (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void QueueTask(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract void QueueTask(System::Threading::Tasks::Task ^ task);" />
      <MemberSignature Language="F#" Value="abstract member QueueTask : System.Threading.Tasks.Task -&gt; unit" Usage="taskScheduler.QueueTask task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task">
          <see cref="T:System.Threading.Tasks.Task" /> Do kolejki.</param>
        <summary>Kolejki <see cref="T:System.Threading.Tasks.Task" /> do harmonogramu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasa pochodna od <xref:System.Threading.Tasks.TaskScheduler> implementuje tę metodę, aby zaakceptować planowanego na harmonogram zadań.  
  
 Typowa implementacja będzie przechowywać zadania w strukturze danych wewnętrznych, które będą obsługiwane przez wątki, które może wykonać te zadania w czasie w przyszłości.  
  
 Ta metoda jest przeznaczone tylko do wywołania przez program .NET Framework i nie powinna być wywoływana bezpośrednio w klasie pochodnej. Jest to niezbędne do obsługi spójności systemu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="task" /> Argument ma wartość null.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryDequeue">
      <MemberSignature Language="C#" Value="protected internal virtual bool TryDequeue (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool TryDequeue(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool TryDequeue(System::Threading::Tasks::Task ^ task);" />
      <MemberSignature Language="F#" Value="abstract member TryDequeue : System.Threading.Tasks.Task -&gt; bool&#xA;override this.TryDequeue : System.Threading.Tasks.Task -&gt; bool" Usage="taskScheduler.TryDequeue task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task">
          <see cref="T:System.Threading.Tasks.Task" /> Do być usunięty z kolejki.</param>
        <summary>Podejmuje próbę usuwania z kolejki <see cref="T:System.Threading.Tasks.Task" /> który został uprzednio ustawione w kolejce do tego harmonogramu.</summary>
        <returns>Wartość logiczna wskazująca czy <paramref name="task" /> argument został pomyślnie dequeued.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji, zobacz [planiści zadań](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).  
  
 Ta metoda może być wykonywany w bloku finally; w związku z tym powinien on zwrócić tak szybko jak to możliwe tak że dowolne zasoby, takie jak <xref:System.Threading.CancellationTokenRegistration> obiekty mogą być usuwane w odpowiednim czasie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="task" /> Argument ma wartość null.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryExecuteTask">
      <MemberSignature Language="C#" Value="protected bool TryExecuteTask (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool TryExecuteTask(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool TryExecuteTask(System::Threading::Tasks::Task ^ task);" />
      <MemberSignature Language="F#" Value="member this.TryExecuteTask : System.Threading.Tasks.Task -&gt; bool" Usage="taskScheduler.TryExecuteTask task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task">A <see cref="T:System.Threading.Tasks.Task" /> obiektu do wykonania.</param>
        <summary>Podejmuje próbę wykonania dostarczonych <see cref="T:System.Threading.Tasks.Task" /> na tego harmonogramu.</summary>
        <returns>Wartość logiczna oznacza to PRAWDA, jeśli <paramref name="task" /> zostało wykonane pomyślnie, wartość false, jeśli nie było. Częstą przyczyną niepowodzenia wykonywania nie wcześniej zostały wykonane zadania lub trwa proces wykonywany przez inny wątek.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Implementacje harmonogramu są dostarczane z <xref:System.Threading.Tasks.Task> wystąpienia ma być wykonywana przy użyciu jednej <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A> — metoda lub <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline%2A> metody. Gdy planista uzna należy uruchomić zadanie podana <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> należy to zrobić. TryExecuteTask obsługuje wszystkie aspekty wykonywanie zadania, w tym wywołanie akcji, obsługa wyjątków, zarządzanie stanem i kontroli cyklu życia.  
  
 <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> może być używana tylko dla udostępniony przez infrastrukturę programu .NET Framework tego harmonogramu zadań. Nie można stosować do wykonania dowolnego zadania uzyskanymi za pośrednictwem niestandardowych mechanizmów.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="task" /> Nie jest skojarzony z tym harmonogramem.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryExecuteTaskInline">
      <MemberSignature Language="C#" Value="protected abstract bool TryExecuteTaskInline (System.Threading.Tasks.Task task, bool taskWasPreviouslyQueued);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool TryExecuteTaskInline(class System.Threading.Tasks.Task task, bool taskWasPreviouslyQueued) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool TryExecuteTaskInline(System::Threading::Tasks::Task ^ task, bool taskWasPreviouslyQueued);" />
      <MemberSignature Language="F#" Value="abstract member TryExecuteTaskInline : System.Threading.Tasks.Task * bool -&gt; bool" Usage="taskScheduler.TryExecuteTaskInline (task, taskWasPreviouslyQueued)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
        <Parameter Name="taskWasPreviouslyQueued" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="task">
          <see cref="T:System.Threading.Tasks.Task" /> Do wykonania.</param>
        <param name="taskWasPreviouslyQueued">Wartość logiczna wskazująca, czy zadanie zostało wcześniej umieszczone w kolejce. Jeśli ten parametr ma wartość True, następnie zadania może zostały wcześniej umieszczone w kolejce (zaplanowane); w przypadku wartości FAŁSZ następnie zadanie jest znana nie zostały umieszczone w kolejce i odbywa się to wywołanie w celu wbudowane zadanie zostanie wykonane bez kolejkowania go.</param>
        <summary>Określa, czy podany <see cref="T:System.Threading.Tasks.Task" /> można synchronicznie wykonać w to wywołanie, a jeśli tak, wykonuje on.</summary>
        <returns>Wartość logiczna wskazująca, czy zadanie zostało wykonane wbudowanego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasa pochodna od <xref:System.Threading.Tasks.TaskScheduler> implementuje tej funkcji do obsługi wbudowanego realizacji zadań w wątku, który inicjuje oczekiwania dla tego obiektu zadania. Wykonanie wbudowanego jest opcjonalny i żądania mogą być odrzucane przez zwrócenie wartości false. Jednak kolejne zadania który może zostać umieszczona w tekście, są skalowane, tym lepiej harmonogramu. W rzeczywistości harmonogramu tego inlines zbyt nieco mogą być podatne na zakleszczenie. Prawidłowe wdrożenie powinien upewnić się, że wykonywanie żądania w obszarze zasady gwarantowane przez harmonogram może pomyślnie wbudowanego. Na przykład jeśli harmonogramu używa dedykowanego wątku do wykonania zadania, wszelkie ze śródwierszowaniem żądania z tego wątku ma być pomyślnie wykonane.  
  
 Jeśli harmonogramu decyduje o tym, do wykonania wykonywanie śródwierszowe, go należy to zrobić przez wywołanie do podstawowej TaskScheduler <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> metody za pomocą obiektu task podana propagowanie wartości zwracanej. Może to być również odpowiedniego harmonogramu usunąć wbudowanego zadania z jego struktur danych wewnętrznych zdecyduje uwzględnić ze śródwierszowaniem żądania. Należy jednak pamiętać, że w pewnych okolicznościach harmonogramu może zostać poproszony o wbudowane zadanie, którego nie podano wcześniej do niego z <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A> metody.  
  
 Pochodne harmonogramu jest odpowiedzialny za zapewnienie, że wątek wywołujący jest odpowiednia do wykonywania danego zadania, jak własnych harmonogramów i dotyczą zasad wykonywania.  
  
 Aby uzyskać więcej informacji, zobacz [planiści zadań](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="task" /> Argument ma wartość null.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="task" /> Zostało już wykonane.</exception>
      </Docs>
    </Member>
    <Member MemberName="UnobservedTaskException">
      <MemberSignature Language="C#" Value="public static event EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; UnobservedTaskException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; UnobservedTaskException" />
      <MemberSignature Language="DocId" Value="E:System.Threading.Tasks.TaskScheduler.UnobservedTaskException" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event UnobservedTaskException As EventHandler(Of UnobservedTaskExceptionEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler&lt;System::Threading::Tasks::UnobservedTaskExceptionEventArgs ^&gt; ^ UnobservedTaskException;" />
      <MemberSignature Language="F#" Value="member this.UnobservedTaskException : EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; " Usage="member this.UnobservedTaskException : System.EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy zadanie błędnej niezaobserwowany wyjątek ma wyzwolić zasady eskalacji wyjątek, który domyślnie spowoduje zakończenie procesu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie w całej domenie aplikacji zapewnia mechanizm, aby zapobiec zasady eskalacji wyjątek (który domyślnie kończy proces) z wyzwalania.  
  
 Aby ułatwić deweloperom pisanie kodu asynchroniczny oparty na zadaniach, [!INCLUDE[net_v45](~/includes/net-v45-md.md)] zmienia domyślne zachowanie wyjątek niezaobserwowany wyjątków. Mimo że nadal niezaobserwowany wyjątki podnieść <xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException> wyjątek, proces nie zakończy domyślnie. Zamiast tego wyjątku jest obsługiwany przez środowisko uruchomieniowe po wywołaniu zdarzenia, niezależnie od tego, czy program obsługi zdarzeń przestrzega wyjątek. To zachowanie można skonfigurować. Począwszy od [!INCLUDE[net_v45](~/includes/net-v45-md.md)], można użyć elementu konfiguracji, aby powrócić do zachowania [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] i zakończenie procesu:  
  
```xml  
<configuration>   
   <runtime>   
      <ThrowUnobservedTaskExceptions enabled="true"/>   
   </runtime>   
</configuration>  
  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
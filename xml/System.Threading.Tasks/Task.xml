<Type Name="Task" FullName="System.Threading.Tasks.Task">
  <Metadata><Meta Name="ms.openlocfilehash" Value="c200bb14e9b286622509ade5fbfb3ca3adb9b4db" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69099120" /></Metadata><TypeSignature Language="C#" Value="public class Task : IAsyncResult, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Task extends System.Object implements class System.IAsyncResult, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.Task" />
  <TypeSignature Language="VB.NET" Value="Public Class Task&#xA;Implements IAsyncResult, IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Task : IAsyncResult, IDisposable" />
  <TypeSignature Language="F#" Value="type Task = class&#xA;    interface IAsyncResult&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IAsyncResult</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Id = {Id}, Status = {Status}, Method = {DebuggerDisplayMethodDescription}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Threading.Tasks.SystemThreadingTasks_TaskDebugView))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje operację asynchroniczną.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
   
## Remarks  
 <xref:System.Threading.Tasks.Task> Klasa reprezentuje pojedynczą operację, która nie zwraca wartości i zazwyczaj wykonuje ją asynchronicznie. <xref:System.Threading.Tasks.Task>obiekty są jednym z centralnych składników [wzorca asynchronicznego opartego na zadaniach](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md) , które zostały najpierw wprowadzone w .NET Framework 4. Ponieważ <xref:System.Threading.Tasks.Task> prace wykonywane przez obiekt zwykle są wykonywane asynchronicznie w wątku puli wątków zamiast synchronicznie w wątku aplikacji głównej, można <xref:System.Threading.Tasks.Task.Status%2A> użyć właściwości <xref:System.Threading.Tasks.Task.IsCanceled%2A>, a także, <xref:System.Threading.Tasks.Task.IsCompleted%2A>i <xref:System.Threading.Tasks.Task.IsFaulted%2A> właściwości, aby określić stan zadania. Najczęściej wyrażenie lambda służy do określenia pracy, którą zadanie ma wykonać.  
  
 W przypadku operacji, które zwracają wartości, należy <xref:System.Threading.Tasks.Task%601> użyć klasy.  
  
 W tej sekcji:  
  
 [Przykłady tworzenia wystąpień zadań](#Instant)   
 [Tworzenie i wykonywanie zadania](#Creating)   
 [Rozdzielanie tworzenia i wykonywania zadań](#Separating)   
 [Oczekiwanie na zakończenie jednego lub większej liczby zadań](#WaitingForOne)   
 [Zadania i kultura](#Culture)   
 [Dla deweloperów debugera](#Debugger)  

 <a name="Instant"></a>     
## <a name="task-instantiation"></a>Tworzenie wystąpienia zadania  
 Poniższy przykład tworzy i wykonuje cztery zadania. Trzy zadania wykonują <xref:System.Action%601> delegata `action`o nazwie, który akceptuje argument typu <xref:System.Object>. Czwarte zadanie wykonuje wyrażenie lambda ( <xref:System.Action> delegat) zdefiniowane wewnętrznie w wywołaniu metody tworzenia zadania. Każde zadanie jest tworzone i uruchamiane w inny sposób:  
  
-   Zadanie `t1` jest tworzone przez wywołanie konstruktora klasy zadań, ale jest uruchamiane przez wywołanie jego <xref:System.Threading.Tasks.Task.Start> metody tylko po rozpoczęciu `t2` zadania.  
  
-   Zadanie `t2` jest tworzone i rozpoczęte w pojedynczym wywołaniu metody przez <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%29?displayProperty=nameWithType> wywołanie metody.  
  
-   Zadanie `t3` jest tworzone i rozpoczęte w pojedynczym wywołaniu metody przez <xref:System.Threading.Tasks.Task.Run%28System.Action%29> wywołanie metody.  
  
-   Zadanie `t4` jest wykonywane synchronicznie w głównym wątku przez <xref:System.Threading.Tasks.Task.RunSynchronously> wywołanie metody.  
  
 Ponieważ zadanie `t4` jest wykonywane synchronicznie, jest wykonywane na głównym wątku aplikacji. Pozostałe zadania są wykonywane asynchronicznie zazwyczaj w co najmniej jednym wątku puli wątków.  
  
 [!code-csharp[System.Threading.Tasks.Task#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/startnew.cs#01)]
 [!code-vb[System.Threading.Tasks.Task#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/startnew.vb#01)] 
    
<a name="Creating"></a>   
## <a name="creating-and-executing-a-task"></a>Tworzenie i wykonywanie zadania  
 <xref:System.Threading.Tasks.Task>wystąpienia mogą być tworzone na różne sposoby. Najbardziej typowym podejściem, które jest dostępne od [!INCLUDE[net_v45](~/includes/net-v45-md.md)], jest wywołanie metody statycznej. <xref:System.Threading.Tasks.Task.Run%2A> <xref:System.Threading.Tasks.Task.Run%2A> Metoda zapewnia prosty sposób uruchamiania zadania przy użyciu wartości domyślnych i bez konieczności stosowania dodatkowych parametrów. W poniższym przykładzie zastosowano <xref:System.Threading.Tasks.Task.Run%28System.Action%29> metodę, aby uruchomić zadanie, które tworzy pętlę, a następnie wyświetla liczbę iteracji pętli:  
  
 [!code-csharp[System.Threading.Tasks.Task#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/run1.cs#6)]
 [!code-vb[System.Threading.Tasks.Task#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/run1.vb#6)]  
  
 Alternatywna metoda, a najczęściej, aby uruchomić zadanie w [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], jest metodą statyczną. <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> <xref:System.Threading.Tasks.Task.Factory%2A?displayProperty=nameWithType> Właściwość<xref:System.Threading.Tasks.TaskFactory> zwraca obiekt. <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> Przeciążenia metody pozwalają określić parametry do przekazania do opcji tworzenia zadania i harmonogramu zadań. Poniższy przykład używa <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> metody do uruchomienia zadania. Jest ona funkcjonalnie równoważna z kodem w poprzednim przykładzie.  
  
 [!code-csharp[System.Threading.Tasks.Task#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/startnew1.cs#7)]
 [!code-vb[System.Threading.Tasks.Task#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/startnew1.vb#7)]  
  
 Aby uzyskać więcej kompletnych przykładów, zobacz [oparte na zadaniach programowanie asynchroniczne](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md).  
  
<a name="Separating"></a>   
## <a name="separating-task-creation-and-execution"></a>Rozdzielanie tworzenia i wykonywania zadań  
 <xref:System.Threading.Tasks.Task> Klasa zawiera również konstruktory, które inicjują zadanie, ale nie Zaplanuj jego wykonywania. Ze względu na wydajność <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> , <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> lub metoda jest preferowanym mechanizmem tworzenia i planowania zadań obliczeniowych, ale w przypadku scenariuszy, w których tworzenie i planowanie musi być oddzielone, można użyć konstruktorów, a następnie wywołać <xref:System.Threading.Tasks.Task.Start%2A?displayProperty=nameWithType> Metoda planowania wykonywania zadania w późniejszym czasie.  
  
<a name="WaitingForOne"></a>   
## <a name="waiting-for-one-or-more-tasks-to-complete"></a>Oczekiwanie na zakończenie jednego lub większej liczby zadań  
 Ponieważ zadania są zwykle uruchamiane asynchronicznie w wątku puli wątków, wątek, który tworzy i uruchamia zadanie kontynuuje wykonywanie zaraz po utworzeniu wystąpienia zadania. W niektórych przypadkach, gdy wątek wywołujący jest głównym wątkiem aplikacji, aplikacja może zakończyć się przed rozpoczęciem wykonywania zadania. W innych przypadkach logika aplikacji może wymagać, aby wątek wywołujący kontynuował wykonywanie tylko wtedy, gdy co najmniej jedno zadanie zostało ukończone. Można synchronizować wykonywanie wątku wywołującego i wykonywanych przez niego zadań asynchronicznych, wywołując `Wait` metodę w celu oczekiwania na ukończenie jednego lub większej liczby zadań.  
  
 Aby poczekać na zakończenie jednego zadania, możesz wywołać jego <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> metodę. Wywołanie <xref:System.Threading.Tasks.Task.Wait%2A> metody blokuje wątek wywołujący do momentu zakończenia wykonywania wystąpienia pojedynczej klasy.  
  
 Poniższy przykład wywołuje <xref:System.Threading.Tasks.Task.Wait> metodę bez parametrów, aby odczekać bezwarunkowo do momentu ukończenia zadania. Zadanie symuluje działanie, wywołując <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> metodę w stanie uśpienia przez dwa sekundy.  
  
 [!code-csharp[System.Threading.Tasks.Task#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/Wait1.cs#8)]
 [!code-vb[System.Threading.Tasks.Task#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/Wait1.vb#8)]  
  
 Możesz również poczekać na ukończenie zadania. Metody <xref:System.Threading.Tasks.Task.Wait%28System.Int32%29> i<xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29> blokują wątek wywołujący do momentu zakończenia zadania lub przekroczenia limitu czasu, zależnie od tego, co nastąpi wcześniej. Ponieważ Poniższy przykład uruchamia zadanie, które jest w stanie uśpienia przez dwa sekundy, ale definiuje jedną sekundę wartość limitu czasu, wątek wywołujący jest blokowany do momentu wygaśnięcia limitu czasu i przed ukończeniem wykonywania zadania.  
  
 [!code-csharp[System.Threading.Tasks.Task#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/Wait2.cs#9)]
 [!code-vb[System.Threading.Tasks.Task#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/Wait2.vb#9)]  
  
 Możesz również podać token anulowania, wywołując <xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29> metody i. <xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> Jeśli <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> właściwość tokenu jest `true` lub przyjmuje się `true` , gdy <xref:System.Threading.Tasks.Task.Wait%2A> Metoda jest wykonywana, metoda zgłasza <xref:System.OperationCanceledException>.  
  
 W niektórych przypadkach może być konieczne poczekanie na wykonanie pierwszej serii wykonywanych zadań, ale nie Zadbaj o to, jakie zadanie ma.  W tym celu można wywołać jedno z przeciążeń <xref:System.Threading.Tasks.Task.WaitAny%2A?displayProperty=nameWithType> metody.  Poniższy przykład tworzy trzy zadania, z których każdy uśpienie dla interwału określa generator liczb losowych. <xref:System.Threading.Tasks.Task.WaitAny%28System.Threading.Tasks.Task%5B%5D%29> Metoda czeka na zakończenie pierwszego zadania. W tym przykładzie wyświetlane są informacje o stanie wszystkich trzech zadań.  
  
 [!code-csharp[System.Threading.Tasks.Task#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/WhenAny1.cs#10)]
 [!code-vb[System.Threading.Tasks.Task#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/WaitAny1.vb#10)]  
  
 Możesz również poczekać na ukończenie wszystkich serii zadań, wywołując <xref:System.Threading.Tasks.Task.WaitAll%2A> metodę. Poniższy przykład tworzy dziesięć zadań, czeka na zakończenie wszystkich dziesięciu, a następnie wyświetla ich stan.  
  
 [!code-csharp[System.Threading.Tasks.Task#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/WaitAll1.cs#11)]
 [!code-vb[System.Threading.Tasks.Task#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/WaitAll1.vb#11)]  
  
 Należy pamiętać, że po poczekaniu na zakończenie jednego lub większej liczby zadań wszystkie wyjątki zgłoszone w uruchomionych zadaniach są propagowane w wątku `Wait` , który wywołuje metodę, jak pokazano w poniższym przykładzie. Uruchamia 12 zadań, trzy z nich, które pełnią normalne i trzy z nich zgłasza wyjątek. Z pozostałych sześciu zadań, trzy zostały anulowane przed rozpoczęciem, a trzy zostaną anulowane podczas wykonywania. Wyjątki <xref:System.Threading.Tasks.Task.WaitAll%2A> są zgłaszane w wywołaniu metody i są obsługiwane `try` / `catch` przez blok.  
  
 [!code-csharp[System.Threading.Tasks.Task#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/WaitAll2.cs#12)]
 [!code-vb[System.Threading.Tasks.Task#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/WaitAll2.vb#12)]  
  
 Aby uzyskać więcej informacji na temat obsługi wyjątków w operacjach asynchronicznych opartych na zadaniach, zobacz [Obsługa wyjątków](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
<a name="Culture"></a>   
## <a name="tasks-and-culture"></a>Zadania i kultura  
 Począwszy od aplikacji klasycznych, które [!INCLUDE[net_v46](~/includes/net-v46-md.md)]są przeznaczone dla, kultura wątku, który tworzy i wywołuje zadanie, wchodzi w skład kontekstu wątku. Oznacza to, że niezależnie od bieżącej kultury wątku, w którym wykonywane jest zadanie, bieżąca kultura zadania jest kulturą wątku wywołującego. W przypadku aplikacji, które są przeznaczone dla wersji .NET Framework przed [!INCLUDE[net_v46](~/includes/net-v46-md.md)], kultura zadania jest kulturą wątku, w którym wykonywane jest zadanie. Aby uzyskać więcej informacji, zapoznaj się z sekcją "kultury i operacje asynchroniczne oparte na <xref:System.Globalization.CultureInfo> zadaniach" w temacie.  
  
> [!NOTE]
>  Aplikacje ze sklepu wykonują środowisko wykonawcze systemu Windows w ustawieniu i pobierają kulturę domyślną.  
  
<a name="Debugger"></a>   
## <a name="for-debugger-developers"></a>Dla deweloperów debugera  
 Deweloperzy implementujący niestandardowe debugery mogą używać kilku wewnętrznych i prywatnych elementów członkowskich zadania (mogą one ulec zmianie w wersji Release to Release). Pole służy jako magazyn zapasowy <xref:System.Threading.Tasks.Task.Id%2A> dla właściwości, jednak dostęp do tego pola bezpośrednio z debugera może być bardziej wydajny niż dostęp do tej samej wartości za pomocą metody pobierającej właściwości ( `s_taskIdCounter` licznik jest `m_taskId` służy do pobierania następnego dostępnego identyfikatora zadania). Analogicznie, `m_stateFlags` w polu są przechowywane informacje o bieżącym etapie cyklu życia zadania, a także informacje dostępne <xref:System.Threading.Tasks.Task.Status%2A> przez właściwość. W `m_action` polu jest przechowywane odwołanie do delegata zadania, a w polu `m_stateObject` jest przechowywany stan asynchroniczny przesłany do zadania przez dewelopera. Na koniec w przypadku debugerów, które analizują ramki `InternalWait` stosu, metoda służy do uzyskania potencjalnego znacznika, gdy zadanie przekroczy operację oczekiwania.   
  
 ]]></format>
    </remarks>
    <threadsafe>Wszystkie elementy członkowskie <see cref="T:System.Threading.Tasks.Task" />, z wyjątkiem <see cref="M:System.Threading.Tasks.Task.Dispose" />, są bezpieczne dla wątków i mogą być używane jednocześnie z wielu wątków.</threadsafe>
    <altmember cref="T:System.Threading.Tasks.Task`1" />
    <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteka zadań równoległych (TPL)</related>
    <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">Programowanie asynchroniczne oparte na zadaniach</related>
    <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/Samples-for-Parallel-b4b76364">Przykłady programowania równoległego przy użyciu .NET Framework</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowy <see cref="T:System.Threading.Tasks.Task" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action ^ action);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task action" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
      </Parameters>
      <Docs>
        <param name="action">Delegat reprezentujący kod do wykonania w zadaniu.</param>
        <summary>Inicjuje nową <see cref="T:System.Threading.Tasks.Task" /> z określoną akcją.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor powinien być używany tylko w zaawansowanych scenariuszach, w których jest wymagane, aby utworzenie i rozpoczęcie zadania zostało oddzielone.  
  
 Zamiast wywoływania tego konstruktora, najbardziej typowym sposobem tworzenia <xref:System.Threading.Tasks.Task> wystąpienia obiektu i uruchamiania zadania jest wywołanie statyczne <xref:System.Threading.Tasks.Task.Run%28System.Action%29?displayProperty=nameWithType> lub <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=nameWithType> metody.  
  
 Jeśli zadanie, które nie ma żadnej akcji, jest potrzebne tylko w przypadku odbiorcy interfejsu API mającego coś do oczekiwania <xref:System.Threading.Tasks.TaskCompletionSource%601> , należy użyć.  
  
   
  
## Examples  
 Poniższy przykład używa <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%29> konstruktora do tworzenia zadań, które pobierają nazwy plików w określonych katalogach. Wszystkie zadania zapisują nazwy plików w pojedynczym <xref:System.Collections.Concurrent.ConcurrentBag%601> obiekcie. Przykład następnie wywołuje <xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29> metodę, aby upewnić się, że wszystkie zadania zostały ukończone, a następnie wyświetla liczbę całkowitej liczby nazw plików zapisywana <xref:System.Collections.Concurrent.ConcurrentBag%601> w obiekcie.  
  
 [!code-csharp[System.Threading.Tasks.Task.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/vb/ctor1.vb#1)]  
  
 Poniższy przykład jest identyczny, z tą różnicą, <xref:System.Threading.Tasks.Task.Run%28System.Action%29> że używa metody do tworzenia wystąpienia i uruchamiania zadania w ramach jednej operacji. Metoda zwraca <xref:System.Threading.Tasks.Task> obiekt, który reprezentuje zadanie.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run2.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Run#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Argument ma wartość <see langword="null" />. <paramref name="action" /></exception>
        <altmember cref="M:System.Threading.Tasks.Task.Run(System.Action)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action ^ action, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, cancellationToken)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="action">Delegat reprezentujący kod do wykonania w zadaniu.</param>
        <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken" /> Zostanie obserwuje nowe zadanie.</param>
        <summary>Inicjuje nową <see cref="T:System.Threading.Tasks.Task" /> z określoną akcją i <see cref="T:System.Threading.CancellationToken" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zamiast wywoływania tego konstruktora, najbardziej typowym sposobem tworzenia <xref:System.Threading.Tasks.Task> wystąpienia obiektu i uruchamiania zadania jest wywoływanie metod statycznych <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> i <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> . Jedyną gwarancją oferowaną przez ten konstruktor jest możliwość rozdzielenia wystąpienia obiektu od wywołania zadania.  
  
 Aby uzyskać więcej informacji, zobacz [równoległość zadań (Biblioteka zadań równoległych)](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md) i [Anulowanie w zarządzanych wątkach](~/docs/standard/threading/cancellation-in-managed-threads.md).  
  
   
  
## Examples  
 Poniższy przykład wywołuje <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%2CSystem.Threading.CancellationToken%29> konstruktora, aby utworzyć zadanie, które iteruje pliki w katalogu C:\Windows\System32. Wyrażenie lambda wywołuje metodę, <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> aby dodać informacje o każdym pliku <xref:System.Collections.Generic.List%601> do obiektu. Każde odłączone zadanie zagnieżdżone wywoływane przez <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> pętlę sprawdza stan tokenu anulowania i, jeśli zażądano anulowania, <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> wywołuje metodę. Metoda zgłasza wyjątek, który <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> jest obsługiwany w bloku,gdywywoływanywątekwywołujemetodę.`catch` <xref:System.OperationCanceledException> <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType>  <xref:System.Threading.Tasks.Task.Start%2A> Metoda jest następnie wywoływana w celu uruchomienia zadania.  
  
 [!code-csharp[System.Threading.Tasks.Task.ctor#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/cs/run4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.ctor#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/vb/run4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Podane <see cref="T:System.Threading.CancellationToken" /> zostało już usunięte.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="action" /> Argument ma wartość null.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action ^ action, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, creationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">Delegat reprezentujący kod do wykonania w zadaniu.</param>
        <param name="creationOptions"><see cref="T:System.Threading.Tasks.TaskCreationOptions" /> Służy do dostosowywania zachowania zadania.</param>
        <summary>Inicjuje nową <see cref="T:System.Threading.Tasks.Task" /> z określoną akcją i opcjami tworzenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zamiast wywoływania tego konstruktora, najbardziej typowym sposobem tworzenia <xref:System.Threading.Tasks.Task> wystąpienia obiektu i uruchamiania zadania jest wywołanie metody statycznej. <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType> Jedyną gwarancją oferowaną przez ten konstruktor jest możliwość rozdzielenia wystąpienia obiektu od wywołania zadania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="action" /> Argument ma wartość null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Argument określa nieprawidłową wartość dla <see cref="T:System.Threading.Tasks.TaskCreationOptions" />. <paramref name="creationOptions" /></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (action As Action(Of Object), state As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action&lt;obj&gt; * obj -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, state)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="action">Delegat reprezentujący kod do wykonania w zadaniu.</param>
        <param name="state">Obiekt reprezentujący dane, które mają być używane przez tę akcję.</param>
        <summary>Inicjuje nową <see cref="T:System.Threading.Tasks.Task" /> z określoną akcją i stanem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zamiast wywoływania tego konstruktora, najbardziej typowym sposobem tworzenia <xref:System.Threading.Tasks.Task> wystąpienia obiektu i uruchamiania zadania jest wywołanie metody statycznej. <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%29?displayProperty=nameWithType> Jedyną gwarancją oferowaną przez ten konstruktor jest możliwość rozdzielenia wystąpienia obiektu od wywołania zadania.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano tablicę 6-literowych słów. Każdy wyraz jest następnie przenoszona jako argument do <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%7BSystem.Object%7D%2CSystem.Object%29> konstruktora, którego <xref:System.Action%601> delegat szyfruje znaki w wyrazie, a następnie wyświetla oryginalny wyraz i jego zaszyfrowane wersje.  
  
 [!code-csharp[System.Threading.Tasks.Task.ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/cs/startnew3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.ctor#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/vb/startnew3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="action" /> Argument ma wartość null.</exception>
        <altmember cref="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action ^ action, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action * System.Threading.CancellationToken * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, cancellationToken, creationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">Delegat reprezentujący kod do wykonania w zadaniu.</param>
        <param name="cancellationToken"><see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> Zostanie obserwuje nowe zadanie.</param>
        <param name="creationOptions"><see cref="T:System.Threading.Tasks.TaskCreationOptions" /> Służy do dostosowywania zachowania zadania.</param>
        <summary>Inicjuje nową <see cref="T:System.Threading.Tasks.Task" /> z określoną akcją i opcjami tworzenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zamiast wywoływania tego konstruktora, najbardziej typowym sposobem tworzenia <xref:System.Threading.Tasks.Task> wystąpienia obiektu i uruchamiania zadania jest wywołanie metody statycznej. <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType> Jedyną gwarancją oferowaną przez ten konstruktor jest możliwość rozdzielenia wystąpienia obiektu od wywołania zadania.  
  
 Aby uzyskać więcej informacji, zobacz [równoległość zadań (Biblioteka zadań równoległych)](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md) i [Anulowanie zadania](~/docs/standard/parallel-programming/task-cancellation.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.CancellationTokenSource" /> Utworzony<paramref name="cancellationToken" /> został już usunięty.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="action" /> Argument ma wartość null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Argument określa nieprawidłową wartość dla <see cref="T:System.Threading.Tasks.TaskCreationOptions" />. <paramref name="creationOptions" /></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action&lt;obj&gt; * obj * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, state, cancellationToken)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="action">Delegat reprezentujący kod do wykonania w zadaniu.</param>
        <param name="state">Obiekt reprezentujący dane, które mają być używane przez tę akcję.</param>
        <param name="cancellationToken"><see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> Zostanie obserwuje nowe zadanie.</param>
        <summary>Inicjuje nową <see cref="T:System.Threading.Tasks.Task" /> z określoną akcją, stanem i opcjami.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zamiast wywoływania tego konstruktora, najbardziej typowym sposobem tworzenia <xref:System.Threading.Tasks.Task> wystąpienia obiektu i uruchamiania zadania jest wywołanie metody statycznej. <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> Jedyną gwarancją oferowaną przez ten konstruktor jest możliwość rozdzielenia wystąpienia obiektu od wywołania zadania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.CancellationTokenSource" /> Utworzony<paramref name="cancellationToken" /> został już usunięty.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="action" /> Argument ma wartość null.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (action As Action(Of Object), state As Object, creationOptions As TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action&lt;obj&gt; * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, state, creationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">Delegat reprezentujący kod do wykonania w zadaniu.</param>
        <param name="state">Obiekt reprezentujący dane, które mają być używane przez tę akcję.</param>
        <param name="creationOptions"><see cref="T:System.Threading.Tasks.TaskCreationOptions" /> Służy do dostosowywania zachowania zadania.</param>
        <summary>Inicjuje nową <see cref="T:System.Threading.Tasks.Task" /> z określoną akcją, stanem i opcjami.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zamiast wywoływania tego konstruktora, najbardziej typowym sposobem tworzenia <xref:System.Threading.Tasks.Task> wystąpienia obiektu i uruchamiania zadania jest wywołanie metody statycznej. <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType> Jedyną gwarancją oferowaną przez ten konstruktor jest możliwość rozdzielenia wystąpienia obiektu od wywołania zadania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="action" /> Argument ma wartość null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Argument określa nieprawidłową wartość dla <see cref="T:System.Threading.Tasks.TaskCreationOptions" />. <paramref name="creationOptions" /></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action&lt;obj&gt; * obj * System.Threading.CancellationToken * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, state, cancellationToken, creationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">Delegat reprezentujący kod do wykonania w zadaniu.</param>
        <param name="state">Obiekt reprezentujący dane, które mają być używane przez tę akcję.</param>
        <param name="cancellationToken"><see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> Zostanie obserwuje nowe zadanie.</param>
        <param name="creationOptions"><see cref="T:System.Threading.Tasks.TaskCreationOptions" /> Służy do dostosowywania zachowania zadania.</param>
        <summary>Inicjuje nową <see cref="T:System.Threading.Tasks.Task" /> z określoną akcją, stanem i opcjami.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zamiast wywoływania tego konstruktora, najbardziej typowym sposobem tworzenia <xref:System.Threading.Tasks.Task> wystąpienia obiektu i uruchamiania zadania jest wywołanie metody statycznej. <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType> Jedyną gwarancją oferowaną przez ten konstruktor jest możliwość rozdzielenia wystąpienia obiektu od wywołania zadania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.CancellationTokenSource" /> Utworzony<paramref name="cancellationToken" /> został już usunięty.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="action" /> Argument ma wartość null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Argument określa nieprawidłową wartość dla <see cref="T:System.Threading.Tasks.TaskCreationOptions" />. <paramref name="creationOptions" /></exception>
      </Docs>
    </Member>
    <Member MemberName="AsyncState">
      <MemberSignature Language="C#" Value="public object AsyncState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object AsyncState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.AsyncState" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AsyncState As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ AsyncState { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AsyncState : obj" Usage="System.Threading.Tasks.Task.AsyncState" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.AsyncState</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera obiekt stanu dostarczony, gdy <see cref="T:System.Threading.Tasks.Task" /> został utworzony, lub wartość null, jeśli żaden nie został podany.</summary>
        <value><see cref="T:System.Object" /> Reprezentuje dane stanu, które zostały przesłane do zadania podczas jego tworzenia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rzutowanie obiektu z powrotem do oryginalnego typu w celu pobrania jego danych.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompletedTask">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task CompletedTask { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.Task CompletedTask" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.CompletedTask" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CompletedTask As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::Task ^ CompletedTask { System::Threading::Tasks::Task ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CompletedTask : System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.CompletedTask" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera zadanie, które zostało już wykonane pomyślnie.</summary>
        <value>Zadanie zakończone pomyślnie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zwraca zadanie, którego <xref:System.Threading.Tasks.Task.Status%2A> właściwość jest ustawiona na <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>. Aby utworzyć zadanie, które zwraca wartość i uruchamia do ukończenia, wywołaj <xref:System.Threading.Tasks.Task.FromResult%2A> metodę.  
  
 Powtórzone próby pobrania tej wartości właściwości mogą nie zawsze zwracać tego samego wystąpienia.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Tasks.Task.FromResult``1(``0)" />
      </Docs>
    </Member>
    <Member MemberName="ConfigureAwait">
      <MemberSignature Language="C#" Value="public System.Runtime.CompilerServices.ConfiguredTaskAwaitable ConfigureAwait (bool continueOnCapturedContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Runtime.CompilerServices.ConfiguredTaskAwaitable ConfigureAwait(bool continueOnCapturedContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ConfigureAwait(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConfigureAwait (continueOnCapturedContext As Boolean) As ConfiguredTaskAwaitable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::CompilerServices::ConfiguredTaskAwaitable ConfigureAwait(bool continueOnCapturedContext);" />
      <MemberSignature Language="F#" Value="member this.ConfigureAwait : bool -&gt; System.Runtime.CompilerServices.ConfiguredTaskAwaitable" Usage="task.ConfigureAwait continueOnCapturedContext" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.CompilerServices.ConfiguredTaskAwaitable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continueOnCapturedContext" Type="System.Boolean" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="continueOnCapturedContext"><see langword="true" />, aby spróbować zorganizować kontynuację z powrotem do oryginalnego kontekstu przechwycone; w przeciwnym razie. <see langword="false" /></param>
        <summary>Konfiguruje obiekt oczekujący używany do tego <see cref="T:System.Threading.Tasks.Task" />oczekiwania.</summary>
        <returns>Obiekt używany do oczekiwania na to zadanie.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ContinueWith">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy kontynuację, która jest wykonywana asynchronicznie <see cref="T:System.Threading.Tasks.Task" /> po zakończeniu celu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task)) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task&gt; -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith continuationAction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Akcja do uruchomienia po <see cref="T:System.Threading.Tasks.Task" /> zakończeniu. Po uruchomieniu delegat będzie przekazywać zadanie zakończone jako argument.</param>
        <summary>Tworzy kontynuację, która jest wykonywana asynchronicznie <see cref="T:System.Threading.Tasks.Task" /> po zakończeniu celu.</summary>
        <returns>Nowa kontynuacja <see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócona <xref:System.Threading.Tasks.Task> wartość nie zostanie zaplanowana do wykonania do momentu ukończenia bieżącego zadania, bez względu na to, czy działanie zostało zakończone pomyślnie, z powodu nieobsłużonego wyjątku, czy kończy się wcześniej z powodu anulowania.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano zadanie wypełniające tablicę wartością 100 losowych wartości daty i godziny. Używa <xref:System.Threading.Tasks.Task.ContinueWith%28System.Action%7BSystem.Threading.Tasks.Task%7D%29> metody, aby wybrać najwcześniejszą i najpóźniejszą wartość daty, gdy tablica jest w pełni wypełniana.  
  
 [!code-csharp[System.Threading.Tasks.Task.ContinueWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.continuewith/cs/continuewith1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.ContinueWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.continuewith/vb/continuewith1.vb#1)]  
  
 Ponieważ Aplikacja konsolowa może zakończyć działanie przed wykonaniem zadania kontynuacji <xref:System.Threading.Tasks.Task.Wait> , metoda jest wywoływana w celu upewnienia się, że kontynuacja zakończy działanie przed zakończeniem przykładu.  
  
 Aby uzyskać dodatkowy przykład, zobacz Tworzenie [łańcucha zadań przy użyciu zadań kontynuacji](~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Argument ma wartość <see langword="null" />. <paramref name="continuationAction" /></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task, Object), state As Object) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task, obj&gt; * obj -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Akcja do uruchomienia po zakończeniu zadania. Po uruchomieniu delegat otrzymuje zadanie zakończone i obiekt stanu dostarczony przez obiekt wywołujący jako argumenty.</param>
        <param name="state">Obiekt reprezentujący dane, które mają być używane przez akcję kontynuacji.</param>
        <summary>Tworzy kontynuację, która odbiera informacje o stanie dostarczone przez obiekt wywołujący i <see cref="T:System.Threading.Tasks.Task" /> wykonuje po zakończeniu działania obiektu docelowego.</summary>
        <returns>Nowe zadanie kontynuacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócona <xref:System.Threading.Tasks.Task> wartość nie zostanie zaplanowana do wykonania do momentu ukończenia bieżącego zadania, bez względu na to, czy działanie zostało zakończone pomyślnie, z powodu nieobsłużonego wyjątku, czy zostanie zakończone wcześniej z powodu anulowania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Argument ma wartość <see langword="null" />. <paramref name="continuationAction" /></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Akcja do uruchomienia po <see cref="T:System.Threading.Tasks.Task" /> zakończeniu. Po uruchomieniu delegat będzie przekazywać zadanie zakończone jako argument.</param>
        <param name="cancellationToken"><see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> Zostanie przypisany do nowego zadania kontynuacji.</param>
        <summary>Tworzy kontynuację, która odbiera token anulowania i wykonuje asynchronicznie po zakończeniu <see cref="T:System.Threading.Tasks.Task" /> celu.</summary>
        <returns>Nowa kontynuacja <see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócona <xref:System.Threading.Tasks.Task> wartość nie zostanie zaplanowana do wykonania do momentu ukończenia bieżącego zadania, bez względu na to, czy działanie zostało zakończone pomyślnie, z powodu nieobsłużonego wyjątku, czy kończy się wcześniej z powodu anulowania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.CancellationTokenSource" /> Utworzony token został już usunięty.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="continuationAction" /> Argument ma wartość null.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task), continuationOptions As TaskContinuationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Akcja do uruchomienia zgodnie z określonym <paramref name="continuationOptions" />. Po uruchomieniu delegat będzie przekazywać zadanie zakończone jako argument.</param>
        <param name="continuationOptions">Opcje dla momentu, gdy kontynuacja jest zaplanowana i jak działa. Dotyczy to również kryteriów, takich <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />jak, a także opcji wykonywania, takich jak <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <summary>Tworzy kontynuację, która jest wykonywana po zakończeniu zadania docelowego zgodnie z określonym <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</summary>
        <returns>Nowa kontynuacja <see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócona <xref:System.Threading.Tasks.Task> wartość nie zostanie zaplanowana do wykonania, dopóki nie zakończy się bieżące zadanie. Jeśli kryteria kontynuacji określone za pomocą `continuationOptions` parametru nie są spełnione, zadanie kontynuacji zostanie anulowane, a nie zaplanowane.  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie <xref:System.Threading.Tasks.TaskContinuationOptions> , aby określić, że zadanie kontynuacji powinno być uruchamiane synchronicznie po zakończeniu zadania poprzedzającego. (Jeśli określone zadanie zostało już ukończone przez czas <xref:System.Threading.Tasks.Task.ContinueWith%2A> jest wywoływana, kontynuacja synchroniczna zostanie uruchomiona w wątku wywołującym <xref:System.Threading.Tasks.Task.ContinueWith%2A>).  
  
```csharp  
  
public class TaskCounter  
{  
   private volatile int _count;  
  
   public void Track(Task t)  
   {  
      if (t == null) throw new ArgumentNullException("t");  
      Interlocked.Increment(ref _count);  
      t.ContinueWith(ct => Interlocked.Decrement(ref _count), TaskContinuationOptions.ExecuteSynchronously);  
   }  
  
   public int NumberOfActiveTasks { get { return _count; } }  
}  
  
```  
  
```vb  
  
Public Class TaskCounter  
   Private _count as Integer  
  
   Public Sub Track(ByVal t as Task)  
      If t is Nothing Then Throw New ArgumentNullException("t")  
      Interlocked.Increment(_count)  
      t.ContinueWith(Sub(ct)  
                        Interlocked.Decrement(_count)  
                     End Sub,  
                     TaskContinuationOptions.ExecuteSynchronously)  
   End Sub  
  
   Public ReadOnly Property NumberOfActiveTasks As Integer  
      Get  
         Return _count  
      End Get  
   End Property  
End Class  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="continuationAction" /> Argument ma wartość null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Argument określa nieprawidłową wartość dla <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />. <paramref name="continuationOptions" /></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task), scheduler As TaskScheduler) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task&gt; * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Akcja do uruchomienia po <see cref="T:System.Threading.Tasks.Task" /> zakończeniu. Po uruchomieniu delegat będzie przekazywać zadanie zakończone jako argument.</param>
        <param name="scheduler"><see cref="T:System.Threading.Tasks.TaskScheduler" /> Do skojarzenia z zadaniem kontynuacji i do użycia podczas jego wykonywania.</param>
        <summary>Tworzy kontynuację, która jest wykonywana asynchronicznie <see cref="T:System.Threading.Tasks.Task" /> po zakończeniu celu. Kontynuacja używa określonego harmonogramu.</summary>
        <returns>Nowa kontynuacja <see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócona <xref:System.Threading.Tasks.Task> wartość nie zostanie zaplanowana do wykonania do momentu ukończenia bieżącego zadania, bez względu na to, czy działanie zostało zakończone pomyślnie, z powodu nieobsłużonego wyjątku, czy kończy się wcześniej z powodu anulowania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> Został usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">Argument ma wartość <see langword="null" />. <paramref name="continuationAction" />  
  
—lub— 
<paramref name="scheduler" /> Argument ma wartość null.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task, obj&gt; * obj * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Akcja do uruchomienia po <see cref="T:System.Threading.Tasks.Task" /> zakończeniu. Po uruchomieniu delegat będzie przekazywać zadanie zakończone i obiekt stanu dostarczony przez obiekt wywołujący jako argumenty.</param>
        <param name="state">Obiekt reprezentujący dane, które mają być używane przez akcję kontynuacji.</param>
        <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken" /> Zostanie przypisany do nowego zadania kontynuacji.</param>
        <summary>Tworzy kontynuację, która odbiera informacje o stanie dostarczone przez obiekt wywołujący i token anulowania, które są wykonywane <see cref="T:System.Threading.Tasks.Task" /> asynchronicznie po zakończeniu celu.</summary>
        <returns>Nowa kontynuacja <see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócona <xref:System.Threading.Tasks.Task> wartość nie zostanie zaplanowana do wykonania do momentu ukończenia bieżącego zadania, bez względu na to, czy działanie zostało zakończone pomyślnie, z powodu nieobsłużonego wyjątku, czy kończy się wcześniej z powodu anulowania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Argument ma wartość <see langword="null" />. <paramref name="continuationAction" /></exception>
        <exception cref="T:System.ObjectDisposedException">Podane <see cref="T:System.Threading.CancellationToken" /> zostało już usunięte.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task, Object), state As Object, continuationOptions As TaskContinuationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task, obj&gt; * obj * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Akcja do uruchomienia po <see cref="T:System.Threading.Tasks.Task" /> zakończeniu. Po uruchomieniu delegat będzie przekazywać zadanie zakończone i obiekt stanu dostarczony przez obiekt wywołujący jako argumenty.</param>
        <param name="state">Obiekt reprezentujący dane, które mają być używane przez akcję kontynuacji.</param>
        <param name="continuationOptions">Opcje dla momentu, gdy kontynuacja jest zaplanowana i jak działa. Dotyczy to również kryteriów, takich <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />jak, a także opcji wykonywania, takich jak <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <summary>Tworzy kontynuację, która odbiera informacje o stanie dostarczone przez obiekt wywołujący i <see cref="T:System.Threading.Tasks.Task" /> wykonuje po zakończeniu działania obiektu docelowego. Kontynuacja jest wykonywana na podstawie zestawu określonych warunków.</summary>
        <returns>Nowa kontynuacja <see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócona <xref:System.Threading.Tasks.Task> wartość nie zostanie zaplanowana do wykonania, dopóki nie zakończy się bieżące zadanie. Jeśli kryteria kontynuacji określone za pomocą `continuationOptions` parametru nie są spełnione, zadanie kontynuacji zostanie anulowane, a nie zaplanowane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Argument ma wartość <see langword="null" />. <paramref name="continuationAction" /></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Argument określa nieprawidłową wartość dla <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />. <paramref name="continuationOptions" /></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task, Object), state As Object, scheduler As TaskScheduler) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task, obj&gt; * obj * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Akcja do uruchomienia po <see cref="T:System.Threading.Tasks.Task" /> zakończeniu.  Po uruchomieniu delegat będzie przekazywać zadanie zakończone i obiekt stanu dostarczony przez obiekt wywołujący jako argumenty.</param>
        <param name="state">Obiekt reprezentujący dane, które mają być używane przez akcję kontynuacji.</param>
        <param name="scheduler"><see cref="T:System.Threading.Tasks.TaskScheduler" /> Do skojarzenia z zadaniem kontynuacji i do użycia podczas jego wykonywania.</param>
        <summary>Tworzy kontynuację, która odbiera informacje o stanie dostarczone przez obiekt wywołujący i wykonuje <see cref="T:System.Threading.Tasks.Task" /> asynchronicznie po zakończeniu elementu docelowego. Kontynuacja używa określonego harmonogramu.</summary>
        <returns>Nowa kontynuacja <see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócona <xref:System.Threading.Tasks.Task> wartość nie zostanie zaplanowana do wykonania do momentu ukończenia bieżącego zadania, bez względu na to, czy działanie zostało zakończone pomyślnie, z powodu nieobsłużonego wyjątku, czy kończy się wcześniej z powodu anulowania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Argument ma wartość <see langword="null" />. <paramref name="scheduler" /></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Akcja do uruchomienia zgodnie z określonym <paramref name="continuationOptions" />. Po uruchomieniu delegat będzie przekazywać zadanie zakończone jako argument.</param>
        <param name="cancellationToken"><see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> Zostanie przypisany do nowego zadania kontynuacji.</param>
        <param name="continuationOptions">Opcje dla momentu, gdy kontynuacja jest zaplanowana i jak działa. Dotyczy to również kryteriów, takich <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />jak, a także opcji wykonywania, takich jak <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <param name="scheduler"><see cref="T:System.Threading.Tasks.TaskScheduler" /> Do skojarzenia z zadaniem kontynuacji i do użycia podczas jego wykonywania.</param>
        <summary>Tworzy kontynuację, która jest wykonywana, gdy zadanie docelowe konkuruje zgodnie z określonym <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />. Kontynuacja odbiera token anulowania i używa określonego harmonogramu.</summary>
        <returns>Nowa kontynuacja <see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócona <xref:System.Threading.Tasks.Task> wartość nie zostanie zaplanowana do wykonania, dopóki nie zakończy się bieżące zadanie. Jeśli kryteria określone za pomocą `continuationOptions` parametru nie są spełnione, zadanie kontynuacji zostanie anulowane, a nie zaplanowane.  
  
   
  
## Examples  
 Poniżej przedstawiono przykład użycia ContinueWith do uruchamiania pracy zarówno w tle, jak i w wątkach interfejsu użytkownika.  
  
```csharp  
  
private void Button1_Click(object sender, EventArgs e)  
{  
   var backgroundScheduler = TaskScheduler.Default;  
   var uiScheduler = TaskScheduler.FromCurrentSynchronizationContext();  
   Task.Factory.StartNew(delegate { DoBackgroundComputation(); },  
                         backgroundScheduler).  
   ContinueWith(delegate { UpdateUI(); }, uiScheduler).  
                ContinueWith(delegate { DoAnotherBackgroundComputation(); },  
                             backgroundScheduler).  
                ContinueWith(delegate { UpdateUIAgain(); }, uiScheduler);  
}  
  
```  
  
```vb  
  
Private Sub Button1_Click(ByVal sender As System.Object,   
                          ByVal e As System.EventArgs) Handles Button1.Click  
   Dim backgroundScheduler = TaskScheduler.Default  
   Dim uiScheduler = TaskScheduler.FromCurrentSynchronizationContext()  
  
   Task.Factory.StartNew(Sub()  
                           DoBackgroundComputation()  
                         End Sub, backgroundScheduler).ContinueWith(Sub(t)  
                            UpdateUI()  
                         End Sub, uiScheduler).ContinueWith(Sub(t)  
                            DoAnotherBackgroundComputation()  
                         End Sub, backgroundScheduler).ContinueWith(Sub(t)  
                            UpdateUIAgain()  
                         End Sub, uiScheduler)  
End Sub  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.CancellationTokenSource" /> Utworzony token został już usunięty.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="continuationAction" /> Argument ma wartość null.  
  
—lub— 
<paramref name="scheduler" /> Argument ma wartość null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Argument określa nieprawidłową wartość dla <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />. <paramref name="continuationOptions" /></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task, obj&gt; * obj * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Akcja do uruchomienia po <see cref="T:System.Threading.Tasks.Task" /> zakończeniu. Po uruchomieniu delegat będzie przekazywać zadanie zakończone i obiekt stanu dostarczony przez obiekt wywołujący jako argumenty.</param>
        <param name="state">Obiekt reprezentujący dane, które mają być używane przez akcję kontynuacji.</param>
        <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken" /> Zostanie przypisany do nowego zadania kontynuacji.</param>
        <param name="continuationOptions">Opcje dla momentu, gdy kontynuacja jest zaplanowana i jak działa. Dotyczy to również kryteriów, takich <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />jak, a także opcji wykonywania, takich jak <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <param name="scheduler"><see cref="T:System.Threading.Tasks.TaskScheduler" /> Do skojarzenia z zadaniem kontynuacji i do użycia podczas jego wykonywania.</param>
        <summary>Tworzy kontynuację, która odbiera informacje o stanie dostarczone przez obiekt wywołujący i token anulowania, które są <see cref="T:System.Threading.Tasks.Task" /> wykonywane po zakończeniu celu. Kontynuacja jest wykonywana na podstawie zestawu określonych warunków i używa określonego harmonogramu.</summary>
        <returns>Nowa kontynuacja <see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócona <xref:System.Threading.Tasks.Task> wartość nie zostanie zaplanowana do wykonania, dopóki nie zakończy się bieżące zadanie. Jeśli kryteria określone za pomocą `continuationOptions` parametru nie są spełnione, zadanie kontynuacji zostanie anulowane, a nie zaplanowane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Argument ma wartość <see langword="null" />. <paramref name="scheduler" /></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Argument określa nieprawidłową wartość dla <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />. <paramref name="continuationOptions" /></exception>
        <exception cref="T:System.ObjectDisposedException">Podane <see cref="T:System.Threading.CancellationToken" /> zostało już usunięte.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, TResult)) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, 'Result&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith continuationFunction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ wyniku wygenerowanego przez kontynuację.</typeparam>
        <param name="continuationFunction">Funkcja do uruchomienia po <see cref="T:System.Threading.Tasks.Task`1" /> zakończeniu. Po uruchomieniu delegat będzie przekazywać zadanie zakończone jako argument.</param>
        <summary>Tworzy kontynuację, która jest wykonywana asynchronicznie <see cref="T:System.Threading.Tasks.Task`1" /> po zakończeniu elementu docelowego i zwraca wartość.</summary>
        <returns>Nowe zadanie kontynuacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócona <xref:System.Threading.Tasks.Task%601> wartość nie zostanie zaplanowana do wykonania do momentu ukończenia bieżącego zadania, bez względu na to, czy działanie zostało zakończone pomyślnie, z powodu nieobsłużonego wyjątku, czy kończy się wcześniej z powodu anulowania.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać metody ContinueWith:  
  
 [!code-csharp[System.Threading.Tasks.Task#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/continuationsimple.cs#03)]
 [!code-vb[System.Threading.Tasks.Task#03](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/continuationsimple.vb#03)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> Został usunięty.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="continuationFunction" /> Argument ma wartość null.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, Object, TResult), state As Object) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, obj, 'Result&gt; * obj -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ wyniku wygenerowanego przez kontynuację.</typeparam>
        <param name="continuationFunction">Funkcja do uruchomienia po <see cref="T:System.Threading.Tasks.Task" /> zakończeniu. Po uruchomieniu delegat będzie przekazywać zadanie zakończone i obiekt stanu dostarczony przez obiekt wywołujący jako argumenty.</param>
        <param name="state">Obiekt reprezentujący dane, które mają być używane przez funkcję kontynuacji.</param>
        <summary>Tworzy kontynuację, która odbiera informacje o stanie dostarczone przez obiekt wywołujący i wykonuje <see cref="T:System.Threading.Tasks.Task" /> asynchronicznie po zakończeniu elementu docelowego i zwraca wartość.</summary>
        <returns>Nowa kontynuacja <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócona <xref:System.Threading.Tasks.Task%601> wartość nie zostanie zaplanowana do wykonania do momentu ukończenia bieżącego zadania, bez względu na to, czy działanie zostało zakończone pomyślnie, z powodu nieobsłużonego wyjątku, czy kończy się wcześniej z powodu anulowania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Argument ma wartość <see langword="null" />. <paramref name="continuationFunction" /></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, 'Result&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ wyniku wygenerowanego przez kontynuację.</typeparam>
        <param name="continuationFunction">Funkcja do uruchomienia po <see cref="T:System.Threading.Tasks.Task" /> zakończeniu. Po uruchomieniu delegat będzie przekazywać zadanie zakończone jako argument.</param>
        <param name="cancellationToken"><see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> Zostanie przypisany do nowego zadania kontynuacji.</param>
        <summary>Tworzy kontynuację, która jest wykonywana asynchronicznie <see cref="T:System.Threading.Tasks.Task" /> po zakończeniu elementu docelowego i zwraca wartość. Kontynuacja odbiera token anulowania.</summary>
        <returns>Nowa kontynuacja <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócona <xref:System.Threading.Tasks.Task%601> wartość nie zostanie zaplanowana do wykonania do momentu ukończenia bieżącego zadania, bez względu na to, czy działanie zostało zakończone pomyślnie, z powodu nieobsłużonego wyjątku, czy kończy się wcześniej z powodu anulowania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> Został usunięty.  
  
—lub— 
<see cref="T:System.Threading.CancellationTokenSource" /> Utworzony token został już usunięty.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="continuationFunction" /> Argument ma wartość null.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, TResult), continuationOptions As TaskContinuationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, 'Result&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ wyniku wygenerowanego przez kontynuację.</typeparam>
        <param name="continuationFunction">Funkcja, która będzie uruchamiana zgodnie z warunkiem określonym <paramref name="continuationOptions" />w. Po uruchomieniu delegat będzie przekazywać zadanie zakończone jako argument.</param>
        <param name="continuationOptions">Opcje dla momentu, gdy kontynuacja jest zaplanowana i jak działa. Dotyczy to również kryteriów, takich <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />jak, a także opcji wykonywania, takich jak <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <summary>Tworzy kontynuację, która jest wykonywana zgodnie z określonymi opcjami kontynuacji i zwraca wartość.</summary>
        <returns>Nowa kontynuacja <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócona <xref:System.Threading.Tasks.Task%601> wartość nie zostanie zaplanowana do wykonania, dopóki nie zakończy się bieżące zadanie. Jeśli kryteria kontynuacji określone za pomocą `continuationOptions` parametru nie są spełnione, zadanie kontynuacji zostanie anulowane, a nie zaplanowane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> Został usunięty.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="continuationFunction" /> Argument ma wartość null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Argument określa nieprawidłową wartość dla <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />. <paramref name="continuationOptions" /></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, TResult), scheduler As TaskScheduler) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, 'Result&gt; * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ wyniku wygenerowanego przez kontynuację.</typeparam>
        <param name="continuationFunction">Funkcja do uruchomienia po <see cref="T:System.Threading.Tasks.Task" /> zakończeniu. Po uruchomieniu delegat będzie przekazywać zadanie zakończone jako argument.</param>
        <param name="scheduler"><see cref="T:System.Threading.Tasks.TaskScheduler" /> Do skojarzenia z zadaniem kontynuacji i do użycia podczas jego wykonywania.</param>
        <summary>Tworzy kontynuację, która jest wykonywana asynchronicznie <see cref="T:System.Threading.Tasks.Task" /> po zakończeniu elementu docelowego i zwraca wartość. Kontynuacja używa określonego harmonogramu.</summary>
        <returns>Nowa kontynuacja <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócona <xref:System.Threading.Tasks.Task%601> wartość nie zostanie zaplanowana do wykonania do momentu ukończenia bieżącego zadania, bez względu na to, czy działanie zostało zakończone pomyślnie, z powodu nieobsłużonego wyjątku, czy kończy się wcześniej z powodu anulowania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> Został usunięty.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="continuationFunction" /> Argument ma wartość null.  
  
—lub— 
<paramref name="scheduler" /> Argument ma wartość null.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, obj, 'Result&gt; * obj * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, state, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ wyniku wygenerowanego przez kontynuację.</typeparam>
        <param name="continuationFunction">Funkcja do uruchomienia po <see cref="T:System.Threading.Tasks.Task" /> zakończeniu. Po uruchomieniu delegat będzie przekazywać zadanie zakończone i obiekt stanu dostarczony przez obiekt wywołujący jako argumenty.</param>
        <param name="state">Obiekt reprezentujący dane, które mają być używane przez funkcję kontynuacji.</param>
        <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken" /> Zostanie przypisany do nowego zadania kontynuacji.</param>
        <summary>Tworzy kontynuację, która jest wykonywana asynchronicznie <see cref="T:System.Threading.Tasks.Task" /> po zakończeniu elementu docelowego i zwraca wartość. Kontynuacja odbiera informacje o stanie dostarczone przez obiekt wywołujący oraz token anulowania.</summary>
        <returns>Nowa kontynuacja <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócona <xref:System.Threading.Tasks.Task%601> wartość nie zostanie zaplanowana do wykonania do momentu ukończenia bieżącego zadania, bez względu na to, czy działanie zostało zakończone pomyślnie, z powodu nieobsłużonego wyjątku, czy kończy się wcześniej z powodu anulowania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Argument ma wartość <see langword="null" />. <paramref name="continuationFunction" /></exception>
        <exception cref="T:System.ObjectDisposedException">Podane <see cref="T:System.Threading.CancellationToken" /> zostało już usunięte.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, Object, TResult), state As Object, continuationOptions As TaskContinuationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, obj, 'Result&gt; * obj * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, state, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ wyniku wygenerowanego przez kontynuację.</typeparam>
        <param name="continuationFunction">Funkcja do uruchomienia po <see cref="T:System.Threading.Tasks.Task" /> zakończeniu. Po uruchomieniu delegat będzie przekazywać zadanie zakończone i obiekt stanu dostarczony przez obiekt wywołujący jako argumenty.</param>
        <param name="state">Obiekt reprezentujący dane, które mają być używane przez funkcję kontynuacji.</param>
        <param name="continuationOptions">Opcje dla momentu, gdy kontynuacja jest zaplanowana i jak działa. Dotyczy to również kryteriów, takich <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />jak, a także opcji wykonywania, takich jak <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <summary>Tworzy kontynuację, która jest wykonywana na podstawie określonych opcji kontynuacji zadania po <see cref="T:System.Threading.Tasks.Task" /> zakończeniu elementu docelowego. Kontynuacja odbiera informacje o stanie dostarczone przez proces wywołujący.</summary>
        <returns>Nowa kontynuacja <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócona <xref:System.Threading.Tasks.Task%601> wartość nie zostanie zaplanowana do wykonania, dopóki nie zakończy się bieżące zadanie. Jeśli kryteria kontynuacji określone za pomocą `continuationOptions` parametru nie są spełnione, zadanie kontynuacji zostanie anulowane, a nie zaplanowane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Argument ma wartość <see langword="null" />. <paramref name="continuationFunction" /></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Argument określa nieprawidłową wartość dla <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />. <paramref name="continuationOptions" /></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, Object, TResult), state As Object, scheduler As TaskScheduler) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, obj, 'Result&gt; * obj * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, state, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ wyniku wygenerowanego przez kontynuację.</typeparam>
        <param name="continuationFunction">Funkcja do uruchomienia po <see cref="T:System.Threading.Tasks.Task" /> zakończeniu.  Po uruchomieniu delegat będzie przekazywać zadanie zakończone i obiekt stanu dostarczony przez obiekt wywołujący jako argumenty.</param>
        <param name="state">Obiekt reprezentujący dane, które mają być używane przez funkcję kontynuacji.</param>
        <param name="scheduler"><see cref="T:System.Threading.Tasks.TaskScheduler" /> Do skojarzenia z zadaniem kontynuacji i do użycia podczas jego wykonywania.</param>
        <summary>Tworzy kontynuację, która jest wykonywana asynchronicznie <see cref="T:System.Threading.Tasks.Task" /> po zakończeniu celu. Kontynuacja odbiera informacje o stanie dostarczone przez proces wywołujący i używa określonego harmonogramu.</summary>
        <returns>Nowa kontynuacja <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócona <xref:System.Threading.Tasks.Task%601> wartość nie zostanie zaplanowana do wykonania do momentu ukończenia bieżącego zadania, bez względu na to, czy działanie zostało zakończone pomyślnie, z powodu nieobsłużonego wyjątku, czy kończy się wcześniej z powodu anulowania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Argument ma wartość <see langword="null" />. <paramref name="scheduler" /></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, 'Result&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ wyniku wygenerowanego przez kontynuację.</typeparam>
        <param name="continuationFunction">Funkcja, która będzie uruchamiana zgodnie z określonym <c>continuationOptions.</c> Po uruchomieniu delegat będzie przekazywać zadanie zakończone jako argument.</param>
        <param name="cancellationToken"><see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> Zostanie przypisany do nowego zadania kontynuacji.</param>
        <param name="continuationOptions">Opcje dla momentu, gdy kontynuacja jest zaplanowana i jak działa. Dotyczy to również kryteriów, takich <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />jak, a także opcji wykonywania, takich jak <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <param name="scheduler"><see cref="T:System.Threading.Tasks.TaskScheduler" /> Do skojarzenia z zadaniem kontynuacji i do użycia podczas jego wykonywania.</param>
        <summary>Tworzy kontynuację, która jest wykonywana zgodnie z określonymi opcjami kontynuacji i zwraca wartość. Kontynuacja powoduje przekazanie tokenu anulowania i użycie określonego harmonogramu.</summary>
        <returns>Nowa kontynuacja <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócona <xref:System.Threading.Tasks.Task%601> wartość nie zostanie zaplanowana do wykonania, dopóki nie zakończy się bieżące zadanie. Jeśli kryteria określone za pomocą `continuationOptions` parametru nie są spełnione, zadanie kontynuacji zostanie anulowane, a nie zaplanowane.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać metody ContinueWith z opcjami kontynuacji:  
  
 [!code-csharp[System.Threading.Tasks.Task#04](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/continuationoptions.cs#04)]
 [!code-vb[System.Threading.Tasks.Task#04](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/continuationoptions.vb#04)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> Został usunięty.  
  
—lub— 
<see cref="T:System.Threading.CancellationTokenSource" /> Utworzony token został już usunięty.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="continuationFunction" /> Argument ma wartość null.  
  
—lub— 
<paramref name="scheduler" /> Argument ma wartość null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Argument określa nieprawidłową wartość dla <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />. <paramref name="continuationOptions" /></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, obj, 'Result&gt; * obj * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, state, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ wyniku wygenerowanego przez kontynuację.</typeparam>
        <param name="continuationFunction">Funkcja do uruchomienia po <see cref="T:System.Threading.Tasks.Task" /> zakończeniu. Po uruchomieniu delegat będzie przekazywać zadanie zakończone i obiekt stanu dostarczony przez obiekt wywołujący jako argumenty.</param>
        <param name="state">Obiekt reprezentujący dane, które mają być używane przez funkcję kontynuacji.</param>
        <param name="cancellationToken"><see cref="T:System.Threading.CancellationToken" /> Zostanie przypisany do nowego zadania kontynuacji.</param>
        <param name="continuationOptions">Opcje dla momentu, gdy kontynuacja jest zaplanowana i jak działa. Dotyczy to również kryteriów, takich <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />jak, a także opcji wykonywania, takich jak <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <param name="scheduler"><see cref="T:System.Threading.Tasks.TaskScheduler" /> Do skojarzenia z zadaniem kontynuacji i do użycia podczas jego wykonywania.</param>
        <summary>Tworzy kontynuację, która jest wykonywana na podstawie określonych opcji kontynuacji zadania, <see cref="T:System.Threading.Tasks.Task" /> gdy cel kończy się i zwraca wartość. Kontynuacja odbiera informacje o stanie dostarczone przez obiekt wywołujący oraz token anulowania i używa określonego harmonogramu.</summary>
        <returns>Nowa kontynuacja <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócona <xref:System.Threading.Tasks.Task%601> wartość nie zostanie zaplanowana do wykonania, dopóki nie zakończy się bieżące zadanie. Jeśli kryteria określone za pomocą `continuationOptions` parametru nie są spełnione, zadanie kontynuacji zostanie anulowane, a nie zaplanowane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Argument ma wartość <see langword="null" />. <paramref name="scheduler" /></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Argument określa nieprawidłową wartość dla <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />. <paramref name="continuationOptions" /></exception>
        <exception cref="T:System.ObjectDisposedException">Podane <see cref="T:System.Threading.CancellationToken" /> zostało już usunięte.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreationOptions">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.TaskCreationOptions CreationOptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.Tasks.TaskCreationOptions CreationOptions" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.CreationOptions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CreationOptions As TaskCreationOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::TaskCreationOptions CreationOptions { System::Threading::Tasks::TaskCreationOptions get(); };" />
      <MemberSignature Language="F#" Value="member this.CreationOptions : System.Threading.Tasks.TaskCreationOptions" Usage="System.Threading.Tasks.Task.CreationOptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskCreationOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Threading.Tasks.TaskCreationOptions" /> Pobiera użyty do utworzenia tego zadania.</summary>
        <value><see cref="T:System.Threading.Tasks.TaskCreationOptions" /> Użyte do utworzenia tego zadania.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentId">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; CurrentId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Nullable`1&lt;int32&gt; CurrentId" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.CurrentId" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentId As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Nullable&lt;int&gt; CurrentId { Nullable&lt;int&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentId : Nullable&lt;int&gt;" Usage="System.Threading.Tasks.Task.CurrentId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zwraca identyfikator aktualnie wykonywanego <see cref="T:System.Threading.Tasks.Task" />elementu.</summary>
        <value>Liczba całkowita, która została przypisana przez system do aktualnie wykonywanego zadania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.CurrentId%2A>jest właściwością`Shared`(w Visual Basic), która jest używana do pobierania identyfikatora aktualnie wykonywanego zadania z kodu, który wykonuje zadanie. `static` Różni się od <xref:System.Threading.Tasks.Task.Id%2A> właściwości, która zwraca identyfikator konkretnego <xref:System.Threading.Tasks.Task> wystąpienia. W przypadku próby pobrania <xref:System.Threading.Tasks.Task.CurrentId%2A> wartości spoza kodu, który wykonuje zadanie, właściwość zwraca. `null`  
  
 Należy pamiętać, że chociaż Kolizje są bardzo rzadki, identyfikatory zadań nie są gwarantowane jako unikatowe.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Threading.Tasks.Task.Id" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Delay">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy zadanie, które zakończy się po upływie czasu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (int millisecondsDelay);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(int32 millisecondsDelay) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Delay (millisecondsDelay As Integer) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Delay(int millisecondsDelay);" />
      <MemberSignature Language="F#" Value="static member Delay : int -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Delay millisecondsDelay" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsDelay" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="millisecondsDelay">Liczba milisekund oczekiwania przed ukończeniem zwróconego zadania lub wartość-1 w celu oczekiwania na czas nieokreślony.</param>
        <summary>Tworzy zadanie, które kończy się po określonej liczbie milisekund.</summary>
        <returns>Zadanie, które reprezentuje opóźnienie czasu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Delay%2A> Metoda jest zwykle używana do opóźniania operacji wszystkich lub części zadania przez określony przedział czasu. Najczęściej jest wprowadzana wartość opóźnienia:  
  
-   Na początku zadania, jak pokazano w poniższym przykładzie.  
  
     [!code-csharp[System.Threading.Tasks.Task.Delay#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay5.cs#5)]
     [!code-vb[System.Threading.Tasks.Task.Delay#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay5.vb#5)]  
  
-   W czasie wykonywania zadania. W takim przypadku wywołanie <xref:System.Threading.Tasks.Task.Delay%2A> metody jest wykonywane jako zadanie podrzędne w ramach zadania, jak pokazano w poniższym przykładzie. Należy zauważyć, że ponieważ zadanie wywołujące <xref:System.Threading.Tasks.Task.Delay%2A> metodę jest wykonywane asynchronicznie, zadanie nadrzędne musi oczekiwać na jego zakończenie przy `await` użyciu słowa kluczowego.  
  
     [!code-csharp[System.Threading.Tasks.Task.Delay#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay5.cs#7)]
     [!code-vb[System.Threading.Tasks.Task.Delay#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay5.vb#7)]  
  
 Po upływie określonego czasu zadanie zostanie wykonane w <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> stanie.  
  
 Ta metoda zależy od zegara systemowego. Oznacza to, że opóźnienie będzie w przybliżeniu równe rozdzielczości zegara systemowego, jeśli `millisecondsDelay` argument jest krótszy niż rozdzielczość zegara systemowego, czyli około 15 milisekund w systemach Windows.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano proste użycie <xref:System.Threading.Tasks.Task.Delay%2A> metody.  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Delay#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość <paramref name="millisecondsDelay" /> argumentu jest mniejsza niż-1.</exception>
      </Docs>
    </Member>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (TimeSpan delay);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(valuetype System.TimeSpan delay) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Delay (delay As TimeSpan) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Delay(TimeSpan delay);" />
      <MemberSignature Language="F#" Value="static member Delay : TimeSpan -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Delay delay" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delay" Type="System.TimeSpan" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="delay">Przedział czasu oczekiwania przed ukończeniem zwróconego zadania lub <see langword="TimeSpan.FromMilliseconds(-1)" /> oczekiwania na czas nieokreślony.</param>
        <summary>Tworzy zadanie, które kończy się po określonym interwale czasu.</summary>
        <returns>Zadanie, które reprezentuje opóźnienie czasu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po upływie określonego czasu zadanie zostanie ukończone w <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> stanie.  
  
 Scenariusze użycia i dodatkowe przykłady można znaleźć w dokumentacji <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> przeciążenia.  
  
 Ta metoda zależy od zegara systemowego. Oznacza to, że opóźnienie będzie w przybliżeniu równe rozdzielczości zegara systemowego, jeśli `delay` argument jest krótszy niż rozdzielczość zegara systemowego, czyli około 15 milisekund w systemach Windows.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano proste użycie <xref:System.Threading.Tasks.Task.Delay%2A> metody.  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay2.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.Delay#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="delay" />reprezentuje ujemny przedział czasu inny niż <see langword="TimeSpan.FromMilliseconds(-1)" />.  
  
—lub— 
Właściwość argumentu jest większa niż <see cref="F:System.Int32.MaxValue" />. <paramref name="delay" /> <see cref="P:System.TimeSpan.TotalMilliseconds" /></exception>
      </Docs>
    </Member>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (int millisecondsDelay, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(int32 millisecondsDelay, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Delay(int millisecondsDelay, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Delay : int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Delay (millisecondsDelay, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsDelay" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="millisecondsDelay">Liczba milisekund oczekiwania przed ukończeniem zwróconego zadania lub wartość-1 w celu oczekiwania na czas nieokreślony.</param>
        <param name="cancellationToken">Token anulowania do obserwowania podczas oczekiwania na ukończenie zadania.</param>
        <summary>Tworzy zadanie anulowania, które kończy się po określonej liczbie milisekund.</summary>
        <returns>Zadanie, które reprezentuje opóźnienie czasu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli token anulowania jest zasygnalizowane przed określonym opóźnieniem, <xref:System.Threading.Tasks.TaskCanceledException> wynik wyjątku, a zadanie zostanie ukończone <xref:System.Threading.Tasks.TaskStatus.Canceled> w stanie.  W przeciwnym razie zadanie zostanie ukończone w <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> stanie po upływie określonego czasu.  
  
 Scenariusze użycia i dodatkowe przykłady można znaleźć w dokumentacji <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> przeciążenia.  
  
 Ta metoda zależy od zegara systemowego. Oznacza to, że opóźnienie będzie w przybliżeniu równe rozdzielczości zegara systemowego, jeśli `millisecondsDelay` argument jest krótszy niż rozdzielczość zegara systemowego, czyli około 15 milisekund w systemach Windows.  
  
   
  
## Examples  
 Poniższy przykład uruchamia zadanie, które zawiera wywołanie <xref:System.Threading.Tasks.Task.Delay%28System.Int32%2CSystem.Threading.CancellationToken%29> metody z jednym drugim opóźnieniem. Przed upływem interwału opóźnień token zostanie anulowany. Dane wyjściowe z przykładu pokazują, że w wyniku <xref:System.Threading.Tasks.TaskCanceledException> zgłoszenia jest generowany i <xref:System.Threading.Tasks.Task.Status%2A> Właściwość Tasks jest ustawiona na <xref:System.Threading.Tasks.TaskStatus.Canceled>.  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.Delay#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość <paramref name="millisecondsDelay" /> argumentu jest mniejsza niż-1.</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">Zadanie zostało anulowane.</exception>
        <exception cref="T:System.ObjectDisposedException">Podane <paramref name="cancellationToken" /> zostało już usunięte.</exception>
      </Docs>
    </Member>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (TimeSpan delay, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(valuetype System.TimeSpan delay, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Delay(TimeSpan delay, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Delay : TimeSpan * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Delay (delay, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delay" Type="System.TimeSpan" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="delay">Przedział czasu oczekiwania przed ukończeniem zwróconego zadania lub <see langword="TimeSpan.FromMilliseconds(-1)" /> oczekiwania na czas nieokreślony.</param>
        <param name="cancellationToken">Token anulowania do obserwowania podczas oczekiwania na ukończenie zadania.</param>
        <summary>Tworzy zadanie, które kończy się po upływie określonego interwału czasu.</summary>
        <returns>Zadanie, które reprezentuje opóźnienie czasu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli token anulowania jest zasygnalizowane przed określonym opóźnieniem, <xref:System.Threading.Tasks.TaskCanceledException> wynik wyjątku, a zadanie zostanie ukończone <xref:System.Threading.Tasks.TaskStatus.Canceled> w stanie.  W przeciwnym razie zadanie zostanie ukończone w <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> stanie po upływie określonego czasu.  
  
 Scenariusze użycia i dodatkowe przykłady można znaleźć w dokumentacji <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> przeciążenia.  
  
 Ta metoda zależy od zegara systemowego. Oznacza to, że opóźnienie będzie w przybliżeniu równe rozdzielczości zegara systemowego, jeśli `delay` argument jest krótszy niż rozdzielczość zegara systemowego, czyli około 15 milisekund w systemach Windows.  
  
   
  
## Examples  
 Poniższy przykład uruchamia zadanie, które zawiera wywołanie <xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29> metody z 1,5 drugim opóźnieniem. Przed upływem interwału opóźnień token zostanie anulowany. Dane wyjściowe z przykładu pokazują, że w wyniku <xref:System.Threading.Tasks.TaskCanceledException> zgłoszenia jest generowany i <xref:System.Threading.Tasks.Task.Status%2A> Właściwość Tasks jest ustawiona na <xref:System.Threading.Tasks.TaskStatus.Canceled>.  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.Delay#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay4.vb#4)]  
  
 Należy zauważyć, że ten przykład zawiera potencjalne sytuacje wyścigu: zależy od zadania asynchronicznego wykonywania opóźnień po anulowaniu tokenu. Mimo że opóźnienie w 1,5 sekund od wywołania <xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29> metody sprawia, że założenie to prawdopodobnie, istnieje jednak możliwość zwrócenia wywołania <xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29> metody przed anulowaniem tokenu. W takim przypadku przykład generuje następujące dane wyjściowe:  
  
```  
Task t Status: RanToCompletion, Result: 42  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="delay" />reprezentuje ujemny przedział czasu inny niż <see langword="TimeSpan.FromMilliseconds(-1)" />.  
  
—lub— 
Właściwość argumentu jest większa niż <see cref="F:System.Int32.MaxValue" />. <paramref name="delay" /> <see cref="P:System.TimeSpan.TotalMilliseconds" /></exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">Zadanie zostało anulowane.</exception>
        <exception cref="T:System.ObjectDisposedException">Podane <paramref name="cancellationToken" /> zostało już usunięte.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwalnia wszystkie zasoby używane przez bieżące wystąpienie <see cref="T:System.Threading.Tasks.Task" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="task.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszystkie zasoby używane przez bieżące wystąpienie <see cref="T:System.Threading.Tasks.Task" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasa implementuje interfejs, <xref:System.IDisposable> ponieważ wewnętrznie korzysta z zasobów, które również implementują <xref:System.IDisposable>. <xref:System.Threading.Tasks.Task> Jednak zwłaszcza jeśli aplikacja jest przeznaczona dla programu [!INCLUDE[net_v45](~/includes/net-v45-md.md)] lub nowszego, nie ma potrzeby wywoływania <xref:System.Threading.Tasks.Task.Dispose%2A> , chyba że testowanie wydajności lub skalowalności wskazuje na to, że w oparciu o wzorce użycia można ulepszyć wydajność aplikacji przez oddanie zadań. Aby uzyskać więcej informacji, zobacz temat [Czy muszę usunąć zadania?](https://devblogs.microsoft.com/pfxteam/do-i-need-to-dispose-of-tasks/) w programie równoległe Programowanie przy użyciu platformy .NET.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Zadanie nie znajduje się w jednym ze Stanów końcowych <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" />: <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" />,, <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" />lub.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="task.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="disposing">Wartość logiczna wskazująca, czy ta metoda jest wywoływana z powodu wywołania <see cref="M:System.Threading.Tasks.Task.Dispose" />.</param>
        <summary><see cref="T:System.Threading.Tasks.Task" />Usuwa, zwalniając wszystkie niezarządzane zasoby.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasa implementuje interfejs, <xref:System.IDisposable> ponieważ wewnętrznie korzysta z zasobów, które również implementują <xref:System.IDisposable>. <xref:System.Threading.Tasks.Task> Jednak zwłaszcza jeśli aplikacja jest przeznaczona dla programu [!INCLUDE[net_v45](~/includes/net-v45-md.md)] lub nowszego, nie ma potrzeby wywoływania <xref:System.Threading.Tasks.Task.Dispose%2A> , chyba że testowanie wydajności lub skalowalności wskazuje na to, że w oparciu o wzorce użycia można ulepszyć wydajność aplikacji przez oddanie zadań. Aby uzyskać więcej informacji, zobacz temat [Czy muszę usunąć zadania?](https://devblogs.microsoft.com/pfxteam/do-i-need-to-dispose-of-tasks/) w programie równoległe Programowanie przy użyciu platformy .NET.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Zadanie nie znajduje się w jednym ze Stanów końcowych <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" />: <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" />,, <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" />lub.</exception>
        <threadsafe>W przeciwieństwie do większości elementów członkowskich <see cref="T:System.Threading.Tasks.Task" /> klasy, ta metoda nie jest bezpieczna wątkowo.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="Exception">
      <MemberSignature Language="C#" Value="public AggregateException Exception { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AggregateException Exception" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Exception" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Exception As AggregateException" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AggregateException ^ Exception { AggregateException ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Exception : AggregateException" Usage="System.Threading.Tasks.Task.Exception" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AggregateException</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera, który <see cref="T:System.Threading.Tasks.Task" /> spowodował przedwcześnie zakończenie. <see cref="T:System.AggregateException" /> Jeśli zakończyło się <see cref="T:System.Threading.Tasks.Task" /> pomyślnie lub nie zgłoszono żadnych wyjątków, spowoduje to <see langword="null" />zwrócenie.</summary>
        <value><see cref="T:System.AggregateException" /> To<see cref="T:System.Threading.Tasks.Task" /> spowodowało przedwcześnie zakończenie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zadania, które generują Nieobsłużone wyjątki, przechowują wyjątek wynikający i propagują <xref:System.AggregateException> go w wywołaniach do <xref:System.Threading.Tasks.Task.Wait%2A> lub <xref:System.Threading.Tasks.Task.Exception%2A> w dostępie do właściwości. Wszelkie wyjątki zaobserwowane przez czas, w którym wystąpienie zadania jest zbierane jako elementy bezużyteczne, zostanie propagowane w wątku finalizatora. Aby uzyskać więcej informacji i zapoznać się z przykładem, zobacz temat [Obsługa wyjątków (Biblioteka zadań równoległych)](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Factory">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskFactory Factory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskFactory Factory" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Factory" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Factory As TaskFactory" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::TaskFactory ^ Factory { System::Threading::Tasks::TaskFactory ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Factory : System.Threading.Tasks.TaskFactory" Usage="System.Threading.Tasks.Task.Factory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskFactory</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zapewnia dostęp do metod fabrycznych na potrzeby tworzenia <see cref="T:System.Threading.Tasks.Task" /> i <see cref="T:System.Threading.Tasks.Task`1" /> konfigurowania wystąpień.</summary>
        <value>Obiekt fabryki, który może tworzyć różne <see cref="T:System.Threading.Tasks.Task" /> obiekty i. <see cref="T:System.Threading.Tasks.Task`1" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zwraca domyślne wystąpienie <xref:System.Threading.Tasks.TaskFactory> klasy, która jest identyczna z klasą utworzoną przez wywołanie <xref:System.Threading.Tasks.TaskFactory.%23ctor?displayProperty=nameWithType> konstruktora bez parametrów. Ma następujące wartości właściwości:  
  
|Właściwość|Wartość|  
|--------------|-----------|  
|<xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A?displayProperty=nameWithType>|<xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType>|  
|<xref:System.Threading.Tasks.TaskFactory.ContinuationOptions%2A?displayProperty=nameWithType>|<xref:System.Threading.Tasks.TaskContinuationOptions.None?displayProperty=nameWithType>|  
|<xref:System.Threading.Tasks.TaskFactory.CreationOptions%2A?displayProperty=nameWithType>|<xref:System.Threading.Tasks.TaskCreationOptions.None?displayProperty=nameWithType>|  
|<xref:System.Threading.Tasks.TaskFactory.Scheduler%2A?displayProperty=nameWithType>|`null`lub<xref:System.Threading.Tasks.TaskScheduler.Current%2A?displayProperty=nameWithType>|  
  
 Najbardziej typowym zastosowaniem tej właściwości jest utworzenie i uruchomienie nowego zadania w jednym wywołaniu <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> metody.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v45](~/includes/net-v45-md.md)] <xref:System.Threading.Tasks.Task> , Metoda zapewnia najprostszy sposób tworzenia obiektu z domyślnymi wartościami konfiguracji. <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType>  
  
 Poniższy przykład używa właściwości statycznej <xref:System.Threading.Tasks.Task.Factory%2A> , aby wykonać dwa wywołania <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> metody. Pierwszy wypełnia tablicę nazwami plików w katalogu elementów WebDocuments, podczas gdy druga wypełnia tablicę nazwami podkatalogów katalogu Moje dokumenty użytkownika. Następnie wywołuje <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%28System.Threading.Tasks.Task%5B%5D%2CSystem.Action%7BSystem.Threading.Tasks.Task%5B%5D%7D%29?displayProperty=nameWithType> metodę, która wyświetla informacje o liczbie plików i katalogów w dwóch tablicach po wykonaniu dwóch pierwszych zadań.  
  
 [!code-csharp[System.Threading.Tasks.Task.Factory#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.factory/cs/factory1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Factory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.factory/vb/factory1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskFactory" />
      </Docs>
    </Member>
    <Member MemberName="FromCanceled">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task FromCanceled (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task FromCanceled(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromCanceled(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ FromCanceled(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member FromCanceled : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.FromCanceled cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">Token anulowania, za pomocą którego należy wykonać zadanie.</param>
        <summary>Tworzy element <see cref="T:System.Threading.Tasks.Task" /> , który został ukończony z powodu anulowania z określonym tokenem anulowania.</summary>
        <returns>Anulowane zadanie.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Nie zażądano <paramref name="cancellationToken" />anulowania; jego <see cref="P:System.Threading.CancellationToken.IsCancellationRequested" /> Właściwość to <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromCanceled&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; FromCanceled&lt;TResult&gt; (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromCanceled&lt;TResult&gt;(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromCanceled``1(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ FromCanceled(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member FromCanceled : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.FromCanceled cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ wyniku zwróconego przez zadanie.</typeparam>
        <param name="cancellationToken">Token anulowania, za pomocą którego należy wykonać zadanie.</param>
        <summary>Tworzy element <see cref="T:System.Threading.Tasks.Task`1" /> , który został ukończony z powodu anulowania z określonym tokenem anulowania.</summary>
        <returns>Anulowane zadanie.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Nie zażądano <paramref name="cancellationToken" />anulowania; jego <see cref="P:System.Threading.CancellationToken.IsCancellationRequested" /> Właściwość to <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromException">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task FromException (Exception exception);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task FromException(class System.Exception exception) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromException(System.Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ FromException(Exception ^ exception);" />
      <MemberSignature Language="F#" Value="static member FromException : Exception -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.FromException exception" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exception" Type="System.Exception" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="exception">Wyjątek, z którego należy wykonać zadanie.</param>
        <summary>Tworzy obiekt <see cref="T:System.Threading.Tasks.Task" /> , który został ukończony z określonym wyjątkiem.</summary>
        <returns>Zadanie zostało uszkodzone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task> Ta metoda tworzy obiekt, którego <xref:System.Threading.Tasks.Task.Status%2A> właściwość jest <xref:System.Threading.Tasks.TaskStatus.Faulted> i której <xref:System.Threading.Tasks.Task.Exception%2A> Właściwość zawiera `exception`. Metoda jest często używana, gdy użytkownik natychmiast wie, że wykonanie zadania spowoduje zgłoszenie wyjątku przed wykonaniem dłuższej ścieżki kodu. Aby zapoznać się z przykładem <xref:System.Threading.Tasks.Task.FromException%60%601%28System.Exception%29> , zapoznaj się z przeciążeniem.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromException&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; FromException&lt;TResult&gt; (Exception exception);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromException&lt;TResult&gt;(class System.Exception exception) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromException``1(System.Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ FromException(Exception ^ exception);" />
      <MemberSignature Language="F#" Value="static member FromException : Exception -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.FromException exception" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="exception" Type="System.Exception" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ wyniku zwróconego przez zadanie.</typeparam>
        <param name="exception">Wyjątek, z którego należy wykonać zadanie.</param>
        <summary><see cref="T:System.Threading.Tasks.Task`1" /> Tworzy zakończenie z określonym wyjątkiem.</summary>
        <returns>Zadanie zostało uszkodzone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task%601> Ta metoda tworzy obiekt, którego <xref:System.Threading.Tasks.Task.Status%2A> właściwość jest <xref:System.Threading.Tasks.TaskStatus.Faulted> i której <xref:System.Threading.Tasks.Task.Exception%2A> Właściwość zawiera `exception`. Metoda jest często używana, gdy użytkownik natychmiast wie, że wykonanie zadania spowoduje zgłoszenie wyjątku przed wykonaniem dłuższej ścieżki kodu. Przykład stanowi ilustrację.  
  
   
  
## Examples  
 Poniższy przykład to narzędzie wiersza polecenia, które oblicza liczbę bajtów w plikach w każdym katalogu, którego nazwa jest przenoszona jako argument wiersza polecenia. Zamiast wykonywania większej ścieżki kodu, która tworzy wystąpienie <xref:System.IO.FileInfo> obiektu i pobiera wartość jego <xref:System.IO.FileInfo.Length%2A?displayProperty=nameWithType> właściwości dla każdego pliku w katalogu, przykład po prostu wywołuje <xref:System.Threading.Tasks.Task.FromException%60%601%28System.Exception%29> metodę, aby utworzyć zadanie o nieprawidłowej awarii, jeśli określony podkatalog nie istnieje.  
  
 [!code-csharp[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/cs/fromresult1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/vb/fromresult1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromResult&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; FromResult&lt;TResult&gt; (TResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromResult&lt;TResult&gt;(!!TResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromResult``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromResult(Of TResult) (result As TResult) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ FromResult(TResult result);" />
      <MemberSignature Language="F#" Value="static member FromResult : 'Result -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.FromResult result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="result" Type="TResult" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ wyniku zwróconego przez zadanie.</typeparam>
        <param name="result">Wynik do zapisania w ukończonym zadaniu.</param>
        <summary>Tworzy element <see cref="T:System.Threading.Tasks.Task`1" /> , który został pomyślnie ukończony z określonym wynikiem.</summary>
        <returns>Zadanie zakończone pomyślnie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task%601> Ta metoda tworzy obiekt, którego <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> właściwość jest `result` i której <xref:System.Threading.Tasks.Task.Status%2A> właściwość jest <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>. Metoda jest często używana, gdy wartość zwracana zadania jest natychmiast znana bez wykonywania dłuższej ścieżki kodu. Przykład stanowi ilustrację.  
  
 Aby utworzyć obiekt zadania, który nie zwraca wartości, Pobierz obiekt zadania z <xref:System.Threading.Tasks.Task.CompletedTask%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykład to narzędzie wiersza polecenia, które oblicza liczbę bajtów w plikach w każdym katalogu, którego nazwa jest przenoszona jako argument wiersza polecenia. Zamiast wykonywania większej ścieżki kodu, <xref:System.IO.FileStream> która tworzy wystąpienie obiektu i pobiera wartość jego <xref:System.IO.FileStream.Length%2A?displayProperty=nameWithType> właściwości dla każdego pliku w katalogu, przykład po prostu wywołuje <xref:System.Threading.Tasks.Task.FromResult%2A> metodę, aby utworzyć zadanie, którego <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> Właściwość ma wartość zero (0), jeśli katalog nie ma plików.  
  
 [!code-csharp[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/cs/fromresult1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/vb/fromresult1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Threading.Tasks.Task.CompletedTask" />
      </Docs>
    </Member>
    <Member MemberName="GetAwaiter">
      <MemberSignature Language="C#" Value="public System.Runtime.CompilerServices.TaskAwaiter GetAwaiter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Runtime.CompilerServices.TaskAwaiter GetAwaiter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.GetAwaiter" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAwaiter () As TaskAwaiter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::CompilerServices::TaskAwaiter GetAwaiter();" />
      <MemberSignature Language="F#" Value="member this.GetAwaiter : unit -&gt; System.Runtime.CompilerServices.TaskAwaiter" Usage="task.GetAwaiter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.CompilerServices.TaskAwaiter</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera obiekt oczekujący, który jest używany <see cref="T:System.Threading.Tasks.Task" />do oczekiwania na to.</summary>
        <returns>Wystąpienie await.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest przeznaczona do użytku kompilatora, a nie do użycia w kodzie aplikacji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.Threading.Tasks.Task.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera identyfikator dla tego <see cref="T:System.Threading.Tasks.Task" /> wystąpienia.</summary>
        <value>Identyfikator, który jest przypisany przez system do tego <see cref="T:System.Threading.Tasks.Task" /> wystąpienia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identyfikatory zadań są przypisywane na żądanie i nie muszą reprezentować kolejności, w której tworzone są wystąpienia zadań. Należy pamiętać, że chociaż Kolizje są bardzo rzadki, identyfikatory zadań nie są gwarantowane jako unikatowe.  
  
 Aby uzyskać identyfikator zadania aktualnie wykonywanego zadania z poziomu kodu, który wykonuje zadanie, użyj <xref:System.Threading.Tasks.Task.CurrentId%2A> właściwości.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Threading.Tasks.Task.CurrentId" />
      </Docs>
    </Member>
    <Member MemberName="IsCanceled">
      <MemberSignature Language="C#" Value="public bool IsCanceled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCanceled" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsCanceled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCanceled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCanceled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCanceled : bool" Usage="System.Threading.Tasks.Task.IsCanceled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa, czy <see cref="T:System.Threading.Tasks.Task" /> to wystąpienie zakończyło wykonywanie z powodu anulowania.</summary>
        <value><see langword="true" />Jeśli zadanie zostało ukończone z powodu anulowania; w <see langword="false" />przeciwnym razie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Threading.Tasks.Task> zostanie zakończona <xref:System.Threading.Tasks.TaskStatus.Canceled> w stanie w ramach jednego z następujących warunków:  
  
-   <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> Została oznaczona do anulowania przed rozpoczęciem wykonywania zadania,  
  
-   Zadanie potwierdza, <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> <xref:System.OperationCanceledException> że żądanie anulowania zostało już zasygnalizowane przez wyrzucanie, które ma takie samo <xref:System.Threading.CancellationToken>.  
  
-   Zadanie potwierdza, że żądanie anulowania zostało już sygnalizowane <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> przez <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A> wywołanie metody w <xref:System.Threading.CancellationToken>.  
  
> [!IMPORTANT]
>  Pobieranie wartości <xref:System.Threading.Tasks.Task.IsCanceled%2A> właściwości nie blokuje wątku wywołującego do momentu ukończenia zadania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCompleted">
      <MemberSignature Language="C#" Value="public bool IsCompleted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCompleted" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsCompleted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCompleted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCompleted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCompleted : bool" Usage="System.Threading.Tasks.Task.IsCompleted" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.IsCompleted</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy zadanie zostało ukończone.</summary>
        <value><see langword="true" />Jeśli zadanie zostało ukończone (oznacza to, że zadanie jest w jednym z trzech stanów końcowych: <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" />, <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> <see langword="false" />lub <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" />); w przeciwnym razie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
> Pobieranie wartości <xref:System.Threading.Tasks.Task.IsCompleted%2A?displayProperty=nameWithType> właściwości nie blokuje wątku wywołującego do momentu ukończenia zadania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCompletedSuccessfully">
      <MemberSignature Language="C#" Value="public bool IsCompletedSuccessfully { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCompletedSuccessfully" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsCompletedSuccessfully" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCompletedSuccessfully As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCompletedSuccessfully { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCompletedSuccessfully : bool" Usage="System.Threading.Tasks.Task.IsCompletedSuccessfully" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFaulted">
      <MemberSignature Language="C#" Value="public bool IsFaulted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFaulted" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsFaulted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFaulted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFaulted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFaulted : bool" Usage="System.Threading.Tasks.Task.IsFaulted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera czy <see cref="T:System.Threading.Tasks.Task" /> ukończono z powodu nieobsługiwanego wyjątku.</summary>
        <value><see langword="true" />Jeśli zadanie zgłosiło nieobsługiwany wyjątek; w <see langword="false" />przeciwnym razie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Threading.Tasks.Task.IsFaulted%2A> <xref:System.Threading.Tasks.Task.Status%2A> ma wartość,<xref:System.Threading.Tasks.TaskStatus.Faulted>zadanie jest równe, a jego <xref:System.Threading.Tasks.Task.Exception%2A> właściwość będzie różna od null. `true`  
  
> [!IMPORTANT]
>  Pobieranie wartości <xref:System.Threading.Tasks.Task.IsFaulted%2A?displayProperty=nameWithType> właściwości nie blokuje wątku wywołującego do momentu ukończenia zadania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kolejkuje określoną służbę do uruchomienia w puli wątków i zwraca zadanie lub <see cref="T:System.Threading.Tasks.Task`1" /> dojście dla tej pracy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Run%2A> Metoda zawiera zestaw przeciążeń, które ułatwiają rozpoczęcie zadania przy użyciu wartości domyślnych. Jest to uproszczona alternatywa dla <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> przeciążeń.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Action action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Action action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Action)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Run(Action ^ action);" />
      <MemberSignature Language="F#" Value="static member Run : Action -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Run action" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="action">Pracy do wykonania asynchronicznej</param>
        <summary>Kolejkuje określoną liczbę zadań do uruchomienia w puli wątków i zwraca <see cref="T:System.Threading.Tasks.Task" /> obiekt, który reprezentuje tę działanie.</summary>
        <returns>Zadanie, które reprezentuje element roboczy w kolejce do wykonania w puli wątków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda pozwala utworzyć i wykonać zadanie w jednym wywołaniu metody i jest prostszym rozwiązaniem alternatywnym <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> dla metody. <xref:System.Threading.Tasks.Task.Run%2A> Tworzy zadanie z następującymi wartościami domyślnymi:  
  
-   Tokenem anulowania jest <xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType>.  
  
-   Jego <xref:System.Threading.Tasks.Task.CreationOptions%2A> wartość właściwości to <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>.  
  
-   Używa domyślnego harmonogramu zadań.  
  
 Aby uzyskać informacje dotyczące obsługi wyjątków zgłaszanych przez operacje zadań, zobacz [Obsługa wyjątków](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano `ShowThreadInfo` metodę, która <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType> wyświetla bieżący wątek. Jest on wywoływany bezpośrednio z wątku aplikacji i jest wywoływany z <xref:System.Action> delegata przesłanego <xref:System.Threading.Tasks.Task.Run%28System.Action%29> do metody.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run11.cs#11)]
 [!code-vb[System.Threading.Tasks.Task.Run#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run11.vb#11)]  
  
 Poniższy przykład jest podobny do poprzedniego, z tą różnicą, że używa wyrażenia lambda do definiowania kodu, który zadanie ma wykonać.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run6.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.Run#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run6.vb#3)]  
  
 Przykłady pokazują, że zadanie asynchroniczne jest wykonywane w innym wątku niż główny wątek aplikacji.  
  
 Wywołanie <xref:System.Threading.Tasks.Task.Wait%2A> metody gwarantuje, że zadanie zakończy się i wyświetli dane wyjściowe przed zakończeniem działania aplikacji. W przeciwnym razie jest możliwe, aby `Main` Metoda została ukończona przed zakończeniem zadania.  
  
 Poniższy przykład ilustruje <xref:System.Threading.Tasks.Task.Run%28System.Action%29> metodę. Definiuje on tablicę nazw katalogów i uruchamia oddzielne zadanie w celu pobrania nazw plików w każdym katalogu. Wszystkie zadania zapisują nazwy plików w pojedynczym <xref:System.Collections.Concurrent.ConcurrentBag%601> obiekcie. Przykład następnie wywołuje <xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29> metodę, aby upewnić się, że wszystkie zadania zostały ukończone, a następnie wyświetla liczbę całkowitej liczby nazw plików zapisywana <xref:System.Collections.Concurrent.ConcurrentBag%601> w obiekcie.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run2.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Run#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="action" /> Parametr został<see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">Obsługa wyjątku (Biblioteka zadań równoległych)</related>
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Func&lt;System.Threading.Tasks.Task&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Func`1&lt;class System.Threading.Tasks.Task&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Run (function As Func(Of Task)) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Run(Func&lt;System::Threading::Tasks::Task ^&gt; ^ function);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;System.Threading.Tasks.Task&gt; -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Run function" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="function">Pracy do wykonania asynchronicznej</param>
        <summary>Kolejkuje określoną służbę do uruchomienia w puli wątków i zwraca serwer proxy dla zadania zwróconego przez <paramref name="function" />.</summary>
        <returns>Zadanie, które reprezentuje serwer proxy dla zadania zwróconego przez <paramref name="function" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać informacje dotyczące obsługi wyjątków zgłaszanych przez operacje zadań, zobacz [Obsługa wyjątków](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="function" /> Parametr został<see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">Obsługa wyjątku (Biblioteka zadań równoległych)</related>
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Action action, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Run(Action ^ action, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Run : Action * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Run (action, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="action">Pracy do wykonania asynchronicznej</param>
        <param name="cancellationToken">Token anulowania, który może służyć do anulowania pracy</param>
        <summary>Kolejkuje określoną liczbę zadań do uruchomienia w puli wątków i zwraca <see cref="T:System.Threading.Tasks.Task" /> obiekt, który reprezentuje tę działanie. Token anulowania umożliwia anulowanie pracy.</summary>
        <returns>Zadanie, które reprezentuje element roboczy w kolejce do wykonania w puli wątków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli żądanie anulowania zostanie rozpoczęte przed rozpoczęciem wykonywania zadania, zadanie nie zostanie wykonane. Zamiast tego jest ono ustawione na <xref:System.Threading.Tasks.TaskStatus.Canceled> stan i <xref:System.Threading.Tasks.TaskCanceledException> zgłasza wyjątek.  
  
 Metoda jest prostszym rozwiązaniem alternatywnym <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> dla metody. <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29> Tworzy zadanie z następującymi wartościami domyślnymi:  
  
-   Jego <xref:System.Threading.Tasks.Task.CreationOptions%2A> wartość właściwości to <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>.  
  
-   Używa domyślnego harmonogramu zadań.  
  
 Aby uzyskać informacje dotyczące obsługi wyjątków zgłaszanych przez operacje zadań, zobacz [Obsługa wyjątków](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
   
  
## Examples  
 Poniższy przykład wywołuje <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29> metodę, aby utworzyć zadanie, które iteruje pliki w katalogu C:\Windows\System32. Wyrażenie lambda wywołuje metodę, <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> aby dodać informacje o każdym pliku <xref:System.Collections.Generic.List%601> do obiektu. Każde odłączone zadanie zagnieżdżone wywoływane przez <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> pętlę sprawdza stan tokenu anulowania i, jeśli zażądano anulowania, <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> wywołuje metodę. Metoda zgłasza wyjątek, który <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> jest obsługiwany w bloku,gdywywoływanywątekwywołujemetodę.`catch` <xref:System.OperationCanceledException> <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType>  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.Run#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="action" /> Parametr został<see langword="null" />.</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">Zadanie zostało anulowane.</exception>
        <exception cref="T:System.ObjectDisposedException">Skojarzony z elementem <paramref name="cancellationToken" /> został usunięty. <see cref="T:System.Threading.CancellationTokenSource" /></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">Obsługa wyjątku (Biblioteka zadań równoległych)</related>
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Func&lt;System.Threading.Tasks.Task&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Func`1&lt;class System.Threading.Tasks.Task&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Run(Func&lt;System::Threading::Tasks::Task ^&gt; ^ function, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;System.Threading.Tasks.Task&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Run (function, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="function">Prace do wykonania asynchronicznie.</param>
        <param name="cancellationToken">Token anulowania, który powinien zostać użyty do anulowania pracy.</param>
        <summary>Kolejkuje określoną służbę do uruchomienia w puli wątków i zwraca serwer proxy dla zadania zwróconego przez <paramref name="function" />.</summary>
        <returns>Zadanie, które reprezentuje serwer proxy dla zadania zwróconego przez <paramref name="function" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać informacje dotyczące obsługi wyjątków zgłaszanych przez operacje zadań, zobacz [Obsługa wyjątków](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="function" /> Parametr został<see langword="null" />.</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">Zadanie zostało anulowane.</exception>
        <exception cref="T:System.ObjectDisposedException">Skojarzony z elementem <paramref name="cancellationToken" /> został usunięty. <see cref="T:System.Threading.CancellationTokenSource" /></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Anulowanie zadania</related>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">Obsługa wyjątku (Biblioteka zadań równoległych)</related>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Run(Of TResult) (function As Func(Of Task(Of TResult))) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ Run(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ function);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.Run function" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ wyniku zwróconego przez zadanie proxy.</typeparam>
        <param name="function">Pracy do wykonania asynchronicznej</param>
        <summary>Kolejkuje określoną służbę do uruchomienia w puli wątków i zwraca serwer proxy dla <see langword="Task(TResult)" /> zwracanych przez. <paramref name="function" /></summary>
        <returns>Reprezentuje serwer proxy <see langword="Task(TResult)" /> dla zwracanych przez <paramref name="function" />. <see langword="Task(TResult)" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać informacje dotyczące obsługi wyjątków zgłaszanych przez operacje zadań, zobacz [Obsługa wyjątków](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="function" /> Parametr został<see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">Obsługa wyjątku (Biblioteka zadań równoległych)</related>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;TResult&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Run(Of TResult) (function As Func(Of TResult)) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ Run(Func&lt;TResult&gt; ^ function);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;'Result&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.Run function" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Zwracany typ zadania.</typeparam>
        <param name="function">Prace do wykonania asynchronicznie.</param>
        <summary>Kolejkuje określoną liczbę zadań do uruchomienia w puli wątków i zwraca <see cref="T:System.Threading.Tasks.Task`1" /> obiekt, który reprezentuje tę działanie.</summary>
        <returns>Obiekt zadania, który reprezentuje element roboczy w kolejce do wykonania w puli wątków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda jest prostszym rozwiązaniem alternatywnym <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=nameWithType> dla metody. <xref:System.Threading.Tasks.Task.Run%2A> Tworzy zadanie z następującymi wartościami domyślnymi:  
  
-   Tokenem anulowania jest <xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType>.  
  
-   Jego <xref:System.Threading.Tasks.Task.CreationOptions%2A> wartość właściwości to <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>.  
  
-   Używa domyślnego harmonogramu zadań.  
  
 Aby uzyskać informacje dotyczące obsługi wyjątków zgłaszanych przez operacje zadań, zobacz [Obsługa wyjątków](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
   
  
## Examples  
 Poniższy przykład zlicza przybliżoną liczbę wyrazów w plikach tekstowych, które reprezentują opublikowane książki. Każde zadanie jest odpowiedzialne za otwieranie pliku, odczytywanie całej zawartości asynchronicznie i obliczanie liczby wyrazów za pomocą wyrażenia regularnego. <xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29> Metoda jest wywoływana, aby upewnić się, że wszystkie zadania zostały ukończone przed wyświetleniem wyrazu liczba słów każdej książki w konsoli programu.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run3.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.Run#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run3.vb#2)]  
  
 Wyrażenie `\p{P}*\s+` regularne dopasowuje zero, jeden lub więcej znaków interpunkcyjnych, po których występuje co najmniej jeden znak odstępu. Przyjęto założenie, że łączna liczba dopasowań jest równa przybliżonej liczbie wyrazów.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="function" /></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">Obsługa wyjątku (Biblioteka zadań równoległych)</related>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ Run(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ function, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.Run (function, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ wyniku zwróconego przez zadanie proxy.</typeparam>
        <param name="function">Pracy do wykonania asynchronicznej</param>
        <param name="cancellationToken">Token anulowania, który powinien zostać użyty do anulowania pracy</param>
        <summary>Kolejkuje określoną służbę do uruchomienia w puli wątków i zwraca serwer proxy dla <see langword="Task(TResult)" /> zwracanych przez. <paramref name="function" /></summary>
        <returns>Reprezentuje serwer proxy <see langword="Task(TResult)" /> dla zwracanych przez <paramref name="function" />. <see langword="Task(TResult)" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać informacje dotyczące obsługi wyjątków zgłaszanych przez operacje zadań, zobacz [Obsługa wyjątków](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="function" /> Parametr został<see langword="null" />.</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">Zadanie zostało anulowane.</exception>
        <exception cref="T:System.ObjectDisposedException">Skojarzony z elementem <paramref name="cancellationToken" /> został usunięty. <see cref="T:System.Threading.CancellationTokenSource" /></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Anulowanie zadania</related>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">Obsługa wyjątku (Biblioteka zadań równoległych)</related>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;TResult&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ Run(Func&lt;TResult&gt; ^ function, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;'Result&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.Run (function, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ wyniku zadania.</typeparam>
        <param name="function">Pracy do wykonania asynchronicznej</param>
        <param name="cancellationToken">Token anulowania, który powinien zostać użyty do anulowania pracy</param>
        <summary>Kolejkuje określoną liczbę zadań do uruchomienia w puli wątków i zwraca <see langword="Task(TResult)" /> obiekt, który reprezentuje tę działanie. Token anulowania umożliwia anulowanie pracy.</summary>
        <returns>Reprezentuje <see langword="Task(TResult)" /> element roboczy w kolejce do wykonania w puli wątków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli żądanie anulowania zostanie rozpoczęte przed rozpoczęciem wykonywania zadania, zadanie nie zostanie wykonane. Zamiast tego jest ono ustawione na <xref:System.Threading.Tasks.TaskStatus.Canceled> stan i <xref:System.Threading.Tasks.TaskCanceledException> zgłasza wyjątek.  
  
 Metoda jest prostszym rozwiązaniem alternatywnym <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> dla metody. <xref:System.Threading.Tasks.Task.Run%2A> Tworzy zadanie z następującymi wartościami domyślnymi:  
  
-   Jego <xref:System.Threading.Tasks.Task.CreationOptions%2A> wartość właściwości to <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>.  
  
-   Używa domyślnego harmonogramu zadań.  
  
 Aby uzyskać informacje dotyczące obsługi wyjątków zgłaszanych przez operacje zadań, zobacz [Obsługa wyjątków](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
   
  
## Examples  
 Poniższy przykład tworzy 20 zadań, które będą się powtarzać, dopóki licznik zostanie zwiększony do wartości 2 000 000. Gdy pierwsze 10 zadań osiągnie wartość 2 000 000, token anulowania zostanie anulowany, a wszystkie zadania, których liczniki nie osiągnęły 2 000 000, są anulowane. W przykładzie pokazano możliwe dane wyjściowe.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run7.cs#7)]
 [!code-vb[System.Threading.Tasks.Task.Run#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run7.vb#7)]  
  
 Zamiast używać <xref:System.AggregateException.InnerExceptions%2A> właściwości do sprawdzania wyjątków, przykład wykonuje iterację wszystkich zadań, aby określić, które zakończyły się powodzeniem, i które zostały anulowane. Dla tych, które ukończyły, wyświetla wartość zwracaną przez zadanie.  
  
 Ponieważ anulowanie jest wspólne, każde zadanie może zdecydować, jak odpowiedzieć na anulowanie. Poniższy przykład jest podobny do pierwszego, z tą różnicą, że po anulowaniu tokenu zadania zwracają liczbę zakończonych iteracji zamiast zgłosić wyjątek.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run28.cs#28)]
 [!code-vb[System.Threading.Tasks.Task.Run#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run28.vb#28)]  
  
 Przykład nadal musi obsługiwać <xref:System.AggregateException> wyjątek, ponieważ wszelkie zadania, które nie rozpoczęły się po zażądaniu anulowania, nadal generują wyjątek.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="function" /></exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">Zadanie zostało anulowane.</exception>
        <exception cref="T:System.ObjectDisposedException">Skojarzony z elementem <paramref name="cancellationToken" /> został usunięty. <see cref="T:System.Threading.CancellationTokenSource" /></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Anulowanie zadania</related>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">Obsługa wyjątku (Biblioteka zadań równoległych)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="RunSynchronously">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Uruchamia synchronicznie na bieżącym <see cref="T:System.Threading.Tasks.TaskScheduler" />. <see cref="T:System.Threading.Tasks.Task" /></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RunSynchronously">
      <MemberSignature Language="C#" Value="public void RunSynchronously ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RunSynchronously() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.RunSynchronously" />
      <MemberSignature Language="VB.NET" Value="Public Sub RunSynchronously ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RunSynchronously();" />
      <MemberSignature Language="F#" Value="member this.RunSynchronously : unit -&gt; unit" Usage="task.RunSynchronously " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Uruchamia synchronicznie na bieżącym <see cref="T:System.Threading.Tasks.TaskScheduler" />. <see cref="T:System.Threading.Tasks.Task" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwykle zadania są wykonywane asynchronicznie w wątku puli wątków i nie blokują wątku wywołującego. Zadania wykonywane przez wywołanie <xref:System.Threading.Tasks.Task.RunSynchronously> metody są skojarzone z bieżącą <xref:System.Threading.Tasks.TaskScheduler> i są uruchamiane w wątku wywołującym. Jeśli harmonogram docelowy nie obsługuje uruchamiania tego zadania w wątku wywołującym, zadanie zostanie zaplanowane do wykonania w harmonogramie, a wątek wywołujący zostanie zablokowany do momentu zakończenia wykonywania zadania. Mimo że zadanie jest uruchamiane synchronicznie, wątek wywołujący powinien nadal wywołać <xref:System.Threading.Tasks.Task.Wait%2A> , aby obsłużyć wszelkie wyjątki, które może zgłosić zadanie.  Aby uzyskać więcej informacji na temat obsługi wyjątków, zobacz [Obsługa wyjątków](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 Zadania wykonywane przez wywołanie <xref:System.Threading.Tasks.Task.RunSynchronously%2A> metody są tworzone przez <xref:System.Threading.Tasks.Task> wywołanie konstruktora klasy lub <xref:System.Threading.Tasks.Task%601> . Zadanie, które ma zostać uruchomione synchronicznie, musi znajdować się w <xref:System.Threading.Tasks.TaskStatus.Created> stanie. Zadanie może zostać uruchomione i uruchomione tylko raz. Każda próba zaplanowania zadania po raz drugi spowoduje wyjątek.  
  
   
  
## Examples  
 Poniższy przykład porównuje zadanie wykonane przez wywołanie <xref:System.Threading.Tasks.Task.RunSynchronously%2A> metody z jednym wykonywanym asynchronicznie. W obu przypadkach zadania wykonują identyczne wyrażenia lambda, które wyświetlają identyfikator zadania i identyfikator wątku, w którym uruchomiono zadanie. Zadanie oblicza sumę liczb całkowitych z zakresu od 1 do 1 000 000. Dane wyjściowe z przykładu pokazują, że zadanie wykonywane przez wywołanie <xref:System.Threading.Tasks.Task.RunSynchronously%2A> metody jest uruchamiane w wątku aplikacji, podczas gdy zadanie asynchroniczne nie jest.  
  
 [!code-csharp[System.Threading.Tasks.Task.RunSynchronously#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.runsynchronously/cs/runsynchronously1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.RunSynchronously#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.runsynchronously/vb/runsynchronously1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> Wystąpienie zostało usunięte.</exception>
        <exception cref="T:System.InvalidOperationException">Stan <see cref="T:System.Threading.Tasks.Task" /> jest nieprawidłowy, aby można było go uruchomić. Być może został już uruchomiony, wykonany lub anulowany lub został utworzony w sposób, który nie obsługuje planowania bezpośredniego.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">Obsługa wyjątku (Biblioteka zadań równoległych)</related>
      </Docs>
    </Member>
    <Member MemberName="RunSynchronously">
      <MemberSignature Language="C#" Value="public void RunSynchronously (System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RunSynchronously(class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RunSynchronously (scheduler As TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RunSynchronously(System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.RunSynchronously : System.Threading.Tasks.TaskScheduler -&gt; unit" Usage="task.RunSynchronously scheduler" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="scheduler">Harmonogram, dla którego ma zostać podjęta próba uruchomienia tego zadania wbudowanego.</param>
        <summary>Działa synchronicznie na <see cref="T:System.Threading.Tasks.TaskScheduler" />podanym. <see cref="T:System.Threading.Tasks.Task" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zadania wykonywane przez wywołanie <xref:System.Threading.Tasks.Task.RunSynchronously%2A> metody są tworzone przez <xref:System.Threading.Tasks.Task> wywołanie konstruktora klasy lub <xref:System.Threading.Tasks.Task%601> . Zadanie, które ma zostać uruchomione synchronicznie, musi znajdować się w <xref:System.Threading.Tasks.TaskStatus.Created> stanie. Zadanie może zostać uruchomione i uruchomione tylko raz. Każda próba zaplanowania zadania po raz drugi spowoduje wyjątek.  
  
 Jeśli harmonogram docelowy nie obsługuje uruchamiania tego zadania w bieżącym wątku, zadanie zostanie zaplanowane do wykonania w harmonogramie, a bieżący wątek zostanie zablokowany do momentu zakończenia wykonywania zadania. Z tego powodu wątek wywołujący nie musi wywoływać metody, takiej jak <xref:System.Threading.Tasks.Task.Wait%2A> , aby upewnić się, że zadanie zostało ukończone. Aby uzyskać więcej informacji na temat obsługi wyjątków dla operacji zadań, zobacz [Obsługa wyjątków](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> Wystąpienie zostało usunięte.</exception>
        <exception cref="T:System.ArgumentNullException">Argument ma wartość <see langword="null" />. <paramref name="scheduler" /></exception>
        <exception cref="T:System.InvalidOperationException">Stan <see cref="T:System.Threading.Tasks.Task" /> jest nieprawidłowy, aby można było go uruchomić. Być może został już uruchomiony, wykonany lub anulowany lub został utworzony w sposób, który nie obsługuje planowania bezpośredniego.</exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">Obsługa wyjątku (Biblioteka zadań równoległych)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Threading.Tasks.Task" />Uruchamia.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; unit" Usage="task.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Uruchamia program, planując go do wykonania w bieżącym <see cref="T:System.Threading.Tasks.TaskScheduler" />. <see cref="T:System.Threading.Tasks.Task" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zadanie może zostać uruchomione i uruchomione tylko raz. Każda próba zaplanowania zadania po raz drugi spowoduje wyjątek.  
  
 Służy do wykonywania zadania, które zostało utworzone przez wywołanie jednego <xref:System.Threading.Tasks.Task> z konstruktorów. <xref:System.Threading.Tasks.Task.Start%2A> Zazwyczaj należy to zrobić, gdy zachodzi potrzeba oddzielenia tworzenia zadania od jego wykonania, na przykład podczas warunkowego wykonywania utworzonych przez siebie zadań. W przypadku bardziej typowej sytuacji, w której nie trzeba oddzielić tworzenia wystąpienia zadania od wykonania, zalecamy wywołanie metody przeciążenia <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> lub. <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType>  
  
 Aby uzyskać informacje dotyczące obsługi wyjątków zgłaszanych przez operacje zadań, zobacz [Obsługa wyjątków](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
   
  
## Examples  
 Poniższy przykład wywołuje <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%29> konstruktora w celu utworzenia wystąpienia nowego <xref:System.Threading.Tasks.Task> obiektu, który wyświetla identyfikator zadania i identyfikator wątku zarządzanego, a następnie wykonuje pętlę. Następnie wywołuje <xref:System.Threading.Tasks.Task.Start%2A> metodę, aby wykonać zadanie.  Ponieważ jest to Aplikacja konsolowa, wywołanie <xref:System.Threading.Tasks.Task.Wait%2A> metody jest konieczne, aby uniemożliwić zakończenie działania aplikacji przed ukończeniem wykonywania zadania.  
  
 [!code-csharp[System.Threading.Tasks.Task.Start#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.start/cs/Start1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Start#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.start/vb/Start1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> Wystąpienie zostało usunięte.</exception>
        <exception cref="T:System.InvalidOperationException">Stan <see cref="T:System.Threading.Tasks.Task" /> jest nieprawidłowy, aby można było go uruchomić. Być może został już uruchomiony, wykonany lub anulowany lub został utworzony w sposób, który nie obsługuje planowania bezpośredniego.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">Obsługa wyjątku (Biblioteka zadań równoległych)</related>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start (System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start(class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Start(System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start (scheduler As TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start(System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.Start : System.Threading.Tasks.TaskScheduler -&gt; unit" Usage="task.Start scheduler" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="scheduler">, <see cref="T:System.Threading.Tasks.TaskScheduler" /> Z którym ma zostać skojarzone i wykonane to zadanie.</param>
        <summary>Uruchamia, aby zaplanować wykonanie do określonego <see cref="T:System.Threading.Tasks.TaskScheduler" />. <see cref="T:System.Threading.Tasks.Task" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zadanie można uruchomić tylko raz. Każda próba zaplanowania zadania po raz drugi spowoduje wyjątek.  
  
 Aby uzyskać informacje dotyczące obsługi wyjątków zgłaszanych przez operacje zadań, zobacz [Obsługa wyjątków](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Argument ma wartość <see langword="null" />. <paramref name="scheduler" /></exception>
        <exception cref="T:System.InvalidOperationException">Stan <see cref="T:System.Threading.Tasks.Task" /> jest nieprawidłowy, aby można było go uruchomić. Być może został już uruchomiony, wykonany lub anulowany lub został utworzony w sposób, który nie obsługuje planowania bezpośredniego.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> Wystąpienie zostało usunięte.</exception>
        <exception cref="T:System.Threading.Tasks.TaskSchedulerException">Harmonogram nie mógł umieścić tego zadania w kolejce.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">Obsługa wyjątku (Biblioteka zadań równoległych)</related>
      </Docs>
    </Member>
    <Member MemberName="Status">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.TaskStatus Status { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.Tasks.TaskStatus Status" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Status" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Status As TaskStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::TaskStatus Status { System::Threading::Tasks::TaskStatus get(); };" />
      <MemberSignature Language="F#" Value="member this.Status : System.Threading.Tasks.TaskStatus" Usage="System.Threading.Tasks.Task.Status" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskStatus</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Threading.Tasks.TaskStatus" /> Pobiera to zadanie.</summary>
        <value>Bieżąca <see cref="T:System.Threading.Tasks.TaskStatus" /> wartość tego wystąpienia zadania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pobieranie wartości <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> właściwości nie blokuje wątku wywołującego do momentu ukończenia zadania.  
  
 Aby uzyskać więcej informacji i zapoznać się z przykładem, zobacz Tworzenie [łańcucha zadań przy użyciu zadań kontynuacji](~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md) i [instrukcje: Anuluj zadanie i jego elementy podrzędne](~/docs/standard/parallel-programming/how-to-cancel-a-task-and-its-children.md).  
  
   
  
## Examples  
 Poniższy przykład tworzy 20 zadań, które będą się powtarzać, dopóki licznik zostanie zwiększony do wartości 2 000 000. Gdy pierwsze 10 zadań osiągnie wartość 2 000 000, token anulowania zostanie anulowany, a wszystkie zadania, których liczniki nie osiągnęły 2 000 000, są anulowane. Przykład następnie analizuje <xref:System.Threading.Tasks.Task.Status%2A> właściwość każdego zadania, aby wskazać, czy zakończyło się pomyślnie, czy też zostało anulowane. Dla tych, które ukończyły, wyświetla wartość zwracaną przez zadanie.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run7.cs#7)]
 [!code-vb[System.Threading.Tasks.Task.Run#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run7.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IAsyncResult.AsyncWaitHandle">
      <MemberSignature Language="C#" Value="System.Threading.WaitHandle System.IAsyncResult.AsyncWaitHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.WaitHandle System.IAsyncResult.AsyncWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.System#IAsyncResult#AsyncWaitHandle" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property AsyncWaitHandle As WaitHandle Implements IAsyncResult.AsyncWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="property System::Threading::WaitHandle ^ System::IAsyncResult::AsyncWaitHandle { System::Threading::WaitHandle ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.IAsyncResult.AsyncWaitHandle" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.AsyncWaitHandle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.WaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Threading.WaitHandle" /> Pobiera, który może być używany do oczekiwania na ukończenie zadania.</summary>
        <value><see cref="T:System.Threading.WaitHandle" /> , Który może być używany do oczekiwania na ukończenie zadania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użycie funkcji oczekiwania zapewnianej przez <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> program jest preferowane w <xref:System.IAsyncResult.AsyncWaitHandle%2A> przypadku korzystania z programu w celu uzyskania podobnych funkcji. Aby uzyskać więcej informacji, zobacz sekcję "Oczekiwanie na zadania" w [programowaniu asynchronicznym opartym](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md) na zadaniach i [Używanie TPL z innymi wzorcami asynchronicznymi](~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> Został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IAsyncResult.CompletedSynchronously">
      <MemberSignature Language="C#" Value="bool System.IAsyncResult.CompletedSynchronously { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.IAsyncResult.CompletedSynchronously" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.System#IAsyncResult#CompletedSynchronously" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property CompletedSynchronously As Boolean Implements IAsyncResult.CompletedSynchronously" />
      <MemberSignature Language="C++ CLI" Value="property bool System::IAsyncResult::CompletedSynchronously { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.IAsyncResult.CompletedSynchronously" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.CompletedSynchronously</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera informację o tym, czy operacja została ukończona synchronicznie.</summary>
        <value><see langword="true" />Jeśli operacja została zakończona synchronicznie; w przeciwnym razie. <see langword="false" /></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Wait">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Czeka na <see cref="T:System.Threading.Tasks.Task" /> zakończenie wykonywania.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public void Wait ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Wait() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait" />
      <MemberSignature Language="VB.NET" Value="Public Sub Wait ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Wait();" />
      <MemberSignature Language="F#" Value="member this.Wait : unit -&gt; unit" Usage="task.Wait " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Czeka na <see cref="T:System.Threading.Tasks.Task" /> zakończenie wykonywania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Wait%2A>jest metodą synchronizacji, która powoduje, że wątek wywołujący czeka na zakończenie bieżącego zadania. Jeśli bieżące zadanie nie rozpoczęło wykonywania, Metoda wait podejmie próbę usunięcia zadania z harmonogramu i wykonania go w tym wątku. Jeśli nie można tego zrobić, lub jeśli bieżące zadanie już rozpoczęło wykonywanie, blokuje wątek wywołujący do momentu ukończenia zadania. Aby uzyskać więcej informacji, zobacz zapoznaj się z tematem [zadanie. czekaj i "](https://devblogs.microsoft.com/pfxteam/task-wait-and-inlining/) deznakowanie" na blogu programowanie równoległe przy użyciu platformy .NET.   
  
## Examples  
 Poniższy przykład uruchamia zadanie, które generuje 1 000 000 losowe liczby całkowite z zakresu od 0 do 100 i oblicza ich średnią wartość. W przykładzie zastosowano <xref:System.Threading.Tasks.Task.Wait%2A> metodę, aby upewnić się, że zadanie zostało ukończone przed zakończeniem działania aplikacji. W przeciwnym razie, ponieważ jest to Aplikacja konsolowa, przykład zostanie przerwany, zanim zadanie będzie można obliczyć i wyświetlić średnią.  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/wait1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Wait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/wait1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> Został usunięty.</exception>
        <exception cref="T:System.AggregateException">Zadanie zostało anulowane. <see cref="P:System.AggregateException.InnerExceptions" /> Kolekcja<see cref="T:System.Threading.Tasks.TaskCanceledException" /> zawiera obiekt.  
  
—lub— 
Zgłoszono wyjątek podczas wykonywania zadania. <see cref="P:System.AggregateException.InnerExceptions" /> Kolekcja zawiera informacje o wyjątku lub wyjątkach.</exception>
        <related type="ExternalDocumentation" href="https://devblogs.microsoft.com/pfxteam/task-wait-and-inlining/">Task. wait i "depodkreolenie"</related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Wait (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Wait(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.Wait : int -&gt; bool" Usage="task.Wait millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Liczba milisekund oczekiwania lub <see cref="F:System.Threading.Timeout.Infinite" /> (-1) oczekiwania na czas nieokreślony.</param>
        <summary><see cref="T:System.Threading.Tasks.Task" /> Czeka na zakończenie wykonywania w ciągu określonej liczby milisekund.</summary>
        <returns><see langword="true" />Jeśli zakończone wykonanie w wyznaczonym czasie; w przeciwnym <see langword="false" />razie,. <see cref="T:System.Threading.Tasks.Task" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Wait%28System.Int32%29>jest metodą synchronizacji, która powoduje, że wątek wywołujący czeka na zakończenie bieżącego wystąpienia zadania, dopóki nie wystąpi jedno z następujących wystąpień:  
  
-   Zadanie zostało ukończone pomyślnie.  
  
-   Samo zadanie jest anulowane lub zgłasza wyjątek. W takim przypadku można obsłużyć <xref:System.AggregateException> wyjątek. <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> Właściwość zawiera szczegółowe informacje o wyjątku lub wyjątkach.  
  
-   Interwał definiowany przez `millisecondsTimeout` czas. W takim przypadku bieżący wątek wznawia wykonywanie i zwraca `false`metodę.  
  
   
  
## Examples  
 Poniższy przykład uruchamia zadanie, które generuje 5 000 000 losowe liczby całkowite z zakresu od 0 do 100 i oblicza ich średnią wartość. W przykładzie zastosowano <xref:System.Threading.Tasks.Task.Wait%28System.Int32%29> metodę oczekiwania na zakończenie działania aplikacji w ciągu 150 milisekund. Jeśli aplikacja zostanie ukończona normalnie, zadanie wyświetla sumę i średnią liczb losowych, które zostały wygenerowane. Jeśli upłynął limit czasu, w przykładzie zostanie wyświetlony komunikat przed jego zakończeniem.  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/Wait5.cs#5)]
 [!code-vb[System.Threading.Tasks.Task.Wait#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/Wait5.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> Został usunięty.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" />jest liczbą ujemną inną niż-1, co oznacza nieskończony limit czasu.</exception>
        <exception cref="T:System.AggregateException">Zadanie zostało anulowane. <see cref="P:System.AggregateException.InnerExceptions" /> Kolekcja<see cref="T:System.Threading.Tasks.TaskCanceledException" /> zawiera obiekt.  
  
—lub— 
Zgłoszono wyjątek podczas wykonywania zadania. <see cref="P:System.AggregateException.InnerExceptions" /> Kolekcja zawiera informacje o wyjątku lub wyjątkach.</exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public void Wait (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Wait(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Wait(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.Wait : System.Threading.CancellationToken -&gt; unit" Usage="task.Wait cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">Token anulowania do obserwowania podczas oczekiwania na ukończenie zadania.</param>
        <summary>Czeka na <see cref="T:System.Threading.Tasks.Task" /> zakończenie wykonywania. Oczekiwanie kończy się, jeśli token anulowania zostanie anulowany przed ukończeniem zadania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29> Metoda tworzy oczekiwanie na anulowanie, czyli powoduje, że bieżący wątek oczekuje na jedną z następujących sytuacji:  
  
-   Zadanie zostało ukończone.  
  
-   Token anulowania został anulowany. W takim przypadku wywołanie <xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29> metody <xref:System.OperationCanceledException>zgłasza.  
  
> [!NOTE]
>  Anulowanie tokenu anulowania nie ma wpływu na uruchomione zadanie, chyba że został również przekazano token anulowania i jest przygotowany do obsługi anulowania. `cancellationToken` Przekazanie `cancellationToken` obiektu do tej metody po prostu pozwala na anulowanie oczekiwania.  
  
   
  
## Examples  
 Poniższy przykład ilustruje proste użycie tokenu anulowania, aby anulować oczekiwanie na ukończenie zadania. Zadanie jest uruchamiane, wywołuje <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> metodę, aby anulować wszystkie tokeny anulowania źródła tokenu, a następnie opóźniać się przez pięć sekund. Zwróć uwagę, że samo zadanie nie przekazano tokenu anulowania i nie jest to niemożliwe do anulowania. Wątek aplikacji wywołuje <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> metodę zadania, aby poczekać na zakończenie zadania, ale oczekiwanie na anulowanie tokenu anulowania <xref:System.OperationCanceledException> i zgłoszenia zostanie anulowane. Procedura obsługi wyjątków zgłasza wyjątek, a następnie uśpienia przez sześć sekund. Dane wyjściowe z przykładu pokazują, że opóźnienie umożliwia ukończenie zadania w <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> stanie.  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/wait3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.Wait#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/wait3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken" /> Anulowano.</exception>
        <exception cref="T:System.ObjectDisposedException">Zadanie zostało usunięte.</exception>
        <exception cref="T:System.AggregateException">Zadanie zostało anulowane. <see cref="P:System.AggregateException.InnerExceptions" /> Kolekcja<see cref="T:System.Threading.Tasks.TaskCanceledException" /> zawiera obiekt.  
  
—lub— 
Zgłoszono wyjątek podczas wykonywania zadania. <see cref="P:System.AggregateException.InnerExceptions" /> Kolekcja zawiera informacje o wyjątku lub wyjątkach.</exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Wait (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Wait(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Wait : TimeSpan -&gt; bool" Usage="task.Wait timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Reprezentuje liczbę milisekund, które należy oczekiwać <see cref="T:System.TimeSpan" /> lub który reprezentuje-1 milisekund, aby czekać na czas nieokreślony. <see cref="T:System.TimeSpan" /></param>
        <summary><see cref="T:System.Threading.Tasks.Task" /> Czeka na zakończenie wykonywania w określonym przedziale czasu.</summary>
        <returns><see langword="true" />Jeśli zakończone wykonanie w wyznaczonym czasie; w przeciwnym <see langword="false" />razie,. <see cref="T:System.Threading.Tasks.Task" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29>jest metodą synchronizacji, która powoduje, że wątek wywołujący czeka na zakończenie bieżącego wystąpienia zadania, dopóki nie wystąpi jedno z następujących wystąpień:  
  
-   Zadanie zostało ukończone pomyślnie.  
  
-   Samo zadanie jest anulowane lub zgłasza wyjątek. W takim przypadku można obsłużyć <xref:System.AggregateException> wyjątek. <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> Właściwość zawiera szczegółowe informacje o wyjątku lub wyjątkach.  
  
-   Interwał definiowany przez `timeout` czas. W takim przypadku bieżący wątek wznawia wykonywanie i zwraca `false`metodę.  
  
   
  
## Examples  
 Poniższy przykład uruchamia zadanie, które generuje 5 000 000 losowe liczby całkowite z zakresu od 0 do 100 i oblicza ich średnią wartość. W przykładzie zastosowano <xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29> metodę oczekiwania na zakończenie działania aplikacji w ciągu 150 milisekund. Jeśli aplikacja zostanie ukończona normalnie, zadanie wyświetla sumę i średnią liczb losowych, które zostały wygenerowane. Jeśli upłynął limit czasu, w przykładzie zostanie wyświetlony komunikat przed jego zakończeniem.  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/Wait6.cs#6)]
 [!code-vb[System.Threading.Tasks.Task.Wait#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/Wait6.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> Został usunięty.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" />jest liczbą ujemną inną niż-1 milisekund, która reprezentuje nieskończony limit czasu. 
—lub— 
 <paramref name="timeout" />jest większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.AggregateException">Zadanie zostało anulowane. <see cref="P:System.AggregateException.InnerExceptions" /> Kolekcja<see cref="T:System.Threading.Tasks.TaskCanceledException" /> zawiera obiekt.  
  
—lub— 
Zgłoszono wyjątek podczas wykonywania zadania. <see cref="P:System.AggregateException.InnerExceptions" /> Kolekcja zawiera informacje o wyjątku lub wyjątkach.</exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Wait(int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.Wait : int * System.Threading.CancellationToken -&gt; bool" Usage="task.Wait (millisecondsTimeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Liczba milisekund oczekiwania lub <see cref="F:System.Threading.Timeout.Infinite" /> (-1) oczekiwania na czas nieokreślony.</param>
        <param name="cancellationToken">Token anulowania do obserwowania podczas oczekiwania na ukończenie zadania.</param>
        <summary>Czeka na <see cref="T:System.Threading.Tasks.Task" /> zakończenie wykonywania. Oczekiwanie kończy się, jeśli upłynie interwał limitu czasu lub token anulowania został anulowany przed ukończeniem zadania.</summary>
        <returns><see langword="true" />Jeśli zakończone wykonanie w wyznaczonym czasie; w przeciwnym <see langword="false" />razie,. <see cref="T:System.Threading.Tasks.Task" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29>jest metodą synchronizacji, która powoduje, że wątek wywołujący czeka na zakończenie bieżącego wystąpienia zadania, dopóki nie wystąpi jedno z następujących wystąpień:  
  
-   Zadanie zostało ukończone pomyślnie.  
  
-   Samo zadanie jest anulowane lub zgłasza wyjątek. W takim przypadku można obsłużyć <xref:System.AggregateException> wyjątek. <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> Właściwość zawiera szczegółowe informacje o wyjątku lub wyjątkach.  
  
-   Token `cancellationToken` anulowania został anulowany. W takim przypadku wywołanie <xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> metody <xref:System.OperationCanceledException>zgłasza.  
  
-   Interwał definiowany przez `millisecondsTimeout` czas. W takim przypadku bieżący wątek wznawia wykonywanie i zwraca `false`metodę.  
  
> [!NOTE]
>  Anulowanie tokenu anulowania nie ma wpływu na uruchomione zadanie, chyba że został również przekazano token anulowania i jest przygotowany do obsługi anulowania. `cancellationToken` Przekazanie `cancellationToken` obiektu do tej metody po prostu pozwala na anulowanie oczekiwania na podstawie pewnego warunku.  
  
   
  
## Examples  
 Poniższy przykład wywołuje <xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> metodę w celu zapewnienia zarówno wartości limitu czasu, jak i tokenu anulowania, który może zakończyć oczekiwanie na ukończenie zadania. Nowy wątek jest uruchamiany i wykonuje `CancelToken` metodę, która wstrzymuje, a następnie <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> wywołuje metodę, aby anulować tokeny anulowania. Uruchomione zostanie zadanie i opóźnienia przez 5 sekund. <xref:System.Threading.Tasks.Task.Wait%2A> Metoda jest następnie wywoływana w celu oczekiwania na ukończenie zadania i ma zapewnioną zarówno krótką wartość limitu czasu, jak i token anulowania.  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/wait4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.Wait#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/wait4.vb#4)]  
  
 Należy zauważyć, że dokładne dane wyjściowe z przykładu zależą od tego, czy oczekiwanie zostało anulowane z powodu tokenu anulowania lub interwału limitu czasu, który upłynął.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken" /> Anulowano.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> Został usunięty.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" />jest liczbą ujemną inną niż-1, co oznacza nieskończony limit czasu.</exception>
        <exception cref="T:System.AggregateException">Zadanie zostało anulowane. <see cref="P:System.AggregateException.InnerExceptions" /> Kolekcja<see cref="T:System.Threading.Tasks.TaskCanceledException" /> zawiera obiekt.  
  
—lub— 
Zgłoszono wyjątek podczas wykonywania zadania. <see cref="P:System.AggregateException.InnerExceptions" /> Kolekcja zawiera informacje o wyjątku lub wyjątkach.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAll">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Czeka na wszystkie podane <see cref="T:System.Threading.Tasks.Task" /> obiekty, aby ukończyć wykonywanie.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static void WaitAll (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WaitAll(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WaitAll (ParamArray tasks As Task())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WaitAll(... cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.Tasks.Task[] -&gt; unit" Usage="System.Threading.Tasks.Task.WaitAll tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks">Tablica <see cref="T:System.Threading.Tasks.Task" /> wystąpień, na których należy czekać.</param>
        <summary>Czeka na wszystkie podane <see cref="T:System.Threading.Tasks.Task" /> obiekty, aby ukończyć wykonywanie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład uruchamia 10 zadań, z których każdy jest przekazywać indeks jako obiekt stanu. Zadania z indeksem od dwóch do pięciu zgłaszają wyjątki. Wywołanie <xref:System.Threading.Tasks.Task.WaitAll%2A> metody otacza wszystkie wyjątki <xref:System.AggregateException> w obiekcie i propaguje je do wątku wywołującego.  
  
 [!code-csharp[System.Threading.Tasks.Task#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/waitall.cs#02)]
 [!code-vb[System.Threading.Tasks.Task#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/waitall.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Co najmniej jeden z <see cref="T:System.Threading.Tasks.Task" /> obiektów w programie <paramref name="tasks" /> został usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">Argument ma wartość <see langword="null" />. <paramref name="tasks" /></exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> Argument zawiera element o wartości null.</exception>
        <exception cref="T:System.AggregateException">Co najmniej jedno <see cref="T:System.Threading.Tasks.Task" /> wystąpienie zostało anulowane. Jeśli zadanie zostało anulowane, <see cref="T:System.AggregateException" /> wyjątek <see cref="T:System.OperationCanceledException" /> zawiera wyjątek w swojej <see cref="P:System.AggregateException.InnerExceptions" /> kolekcji.  
  
—lub— 
Zgłoszono wyjątek podczas wykonywania co najmniej jednego <see cref="T:System.Threading.Tasks.Task" /> wystąpienia.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (tasks As Task(), millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.Tasks.Task[] * int -&gt; bool" Usage="System.Threading.Tasks.Task.WaitAll (tasks, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="tasks">Tablica <see cref="T:System.Threading.Tasks.Task" /> wystąpień, na których należy czekać.</param>
        <param name="millisecondsTimeout">Liczba milisekund oczekiwania lub <see cref="F:System.Threading.Timeout.Infinite" /> (-1) oczekiwania na czas nieokreślony.</param>
        <summary>Czeka na wszystkie podane <see cref="T:System.Threading.Tasks.Task" /> obiekty, aby ukończyć wykonywanie w ciągu określonej liczby milisekund.</summary>
        <returns><see langword="true" />Jeśli wszystkie <see cref="T:System.Threading.Tasks.Task" /> wystąpienia zostały ukończone w wyznaczonym czasie; <see langword="false" />w przeciwnym razie.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Co najmniej jeden z <see cref="T:System.Threading.Tasks.Task" /> obiektów w programie <paramref name="tasks" /> został usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">Argument ma wartość <see langword="null" />. <paramref name="tasks" /></exception>
        <exception cref="T:System.AggregateException">Co najmniej jedno <see cref="T:System.Threading.Tasks.Task" /> wystąpienie zostało anulowane. Jeśli zadanie zostało anulowane, <see cref="T:System.AggregateException" /> zawiera element <see cref="T:System.OperationCanceledException" /> w <see cref="P:System.AggregateException.InnerExceptions" /> kolekcji.  
  
—lub— 
Zgłoszono wyjątek podczas wykonywania co najmniej jednego <see cref="T:System.Threading.Tasks.Task" /> wystąpienia.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" />jest liczbą ujemną inną niż-1, co oznacza nieskończony limit czasu.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> Argument zawiera element o wartości null.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static void WaitAll (System.Threading.Tasks.Task[] tasks, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WaitAll(class System.Threading.Tasks.Task[] tasks, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WaitAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.Tasks.Task[] * System.Threading.CancellationToken -&gt; unit" Usage="System.Threading.Tasks.Task.WaitAll (tasks, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">Tablica <see cref="T:System.Threading.Tasks.Task" /> wystąpień, na których należy czekać.</param>
        <param name="cancellationToken">A <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> , aby obserwować czas oczekiwania na ukończenie zadań.</param>
        <summary>Czeka na ukończenie wszystkich podanych <see cref="T:System.Threading.Tasks.Task" /> obiektów, chyba że oczekiwanie zostanie anulowane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `cancellationToken` Argument jest używany do anulowania operacji oczekiwania. Anulowanie zadań jest operacją odrębną i jest sygnalizowane przez <xref:System.AggregateException> wymienione powyżej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken" /> Anulowano.</exception>
        <exception cref="T:System.ArgumentNullException">Argument ma wartość <see langword="null" />. <paramref name="tasks" /></exception>
        <exception cref="T:System.AggregateException">Co najmniej jedno <see cref="T:System.Threading.Tasks.Task" /> wystąpienie zostało anulowane. Jeśli zadanie zostało anulowane, <see cref="T:System.AggregateException" /> zawiera element <see cref="T:System.OperationCanceledException" /> w <see cref="P:System.AggregateException.InnerExceptions" /> kolekcji.  
  
—lub— 
Zgłoszono wyjątek podczas wykonywania co najmniej jednego <see cref="T:System.Threading.Tasks.Task" /> wystąpienia.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> Argument zawiera element o wartości null.</exception>
        <exception cref="T:System.ObjectDisposedException">Co najmniej jeden z <see cref="T:System.Threading.Tasks.Task" /> obiektów w programie <paramref name="tasks" /> został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.Tasks.Task[] tasks, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.Tasks.Task[] tasks, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (tasks As Task(), timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.Tasks.Task[] * TimeSpan -&gt; bool" Usage="System.Threading.Tasks.Task.WaitAll (tasks, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="tasks">Tablica <see cref="T:System.Threading.Tasks.Task" /> wystąpień, na których należy czekać.</param>
        <param name="timeout">Reprezentuje liczbę milisekund, które należy oczekiwać <see cref="T:System.TimeSpan" /> lub który reprezentuje-1 milisekund, aby czekać na czas nieokreślony. <see cref="T:System.TimeSpan" /></param>
        <summary>Czeka na wszystkie poświadczone <see cref="T:System.Threading.Tasks.Task" /> obiekty do wykonania w określonym przedziale czasu.</summary>
        <returns><see langword="true" />Jeśli wszystkie <see cref="T:System.Threading.Tasks.Task" /> wystąpienia zostały ukończone w wyznaczonym czasie; <see langword="false" />w przeciwnym razie.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Co najmniej jeden z <see cref="T:System.Threading.Tasks.Task" /> obiektów w programie <paramref name="tasks" /> został usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">Argument ma wartość <see langword="null" />. <paramref name="tasks" /></exception>
        <exception cref="T:System.AggregateException">Co najmniej jedno <see cref="T:System.Threading.Tasks.Task" /> wystąpienie zostało anulowane. Jeśli zadanie zostało anulowane, <see cref="T:System.AggregateException" /> zawiera element <see cref="T:System.OperationCanceledException" /> w <see cref="P:System.AggregateException.InnerExceptions" /> kolekcji.  
  
—lub— 
Zgłoszono wyjątek podczas wykonywania co najmniej jednego <see cref="T:System.Threading.Tasks.Task" /> wystąpienia.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" />jest liczbą ujemną inną niż-1 milisekund, która reprezentuje nieskończony limit czasu. 
—lub— 
 <paramref name="timeout" />jest większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> Argument zawiera element o wartości null.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.Tasks.Task[] * int * System.Threading.CancellationToken -&gt; bool" Usage="System.Threading.Tasks.Task.WaitAll (tasks, millisecondsTimeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">Tablica <see cref="T:System.Threading.Tasks.Task" /> wystąpień, na których należy czekać.</param>
        <param name="millisecondsTimeout">Liczba milisekund oczekiwania lub <see cref="F:System.Threading.Timeout.Infinite" /> (-1) oczekiwania na czas nieokreślony.</param>
        <param name="cancellationToken">A <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> , aby obserwować czas oczekiwania na ukończenie zadań.</param>
        <summary>Czeka na wszystkie podane <see cref="T:System.Threading.Tasks.Task" /> obiekty, aby ukończyć wykonywanie w ciągu określonej liczby milisekund lub do czasu anulowania oczekiwania.</summary>
        <returns><see langword="true" />Jeśli wszystkie <see cref="T:System.Threading.Tasks.Task" /> wystąpienia zostały ukończone w wyznaczonym czasie; <see langword="false" />w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `cancellationToken` Argument jest używany do anulowania operacji oczekiwania. Anulowanie zadań jest operacją odrębną i jest sygnalizowane <xref:System.AggregateException> zanotowaną powyżej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Co najmniej jeden z <see cref="T:System.Threading.Tasks.Task" /> obiektów w programie <paramref name="tasks" /> został usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">Argument ma wartość <see langword="null" />. <paramref name="tasks" /></exception>
        <exception cref="T:System.AggregateException">Co najmniej jedno <see cref="T:System.Threading.Tasks.Task" /> wystąpienie zostało anulowane. Jeśli zadanie zostało anulowane, <see cref="T:System.AggregateException" /> zawiera element <see cref="T:System.OperationCanceledException" /> w <see cref="P:System.AggregateException.InnerExceptions" /> kolekcji.  
  
—lub— 
Zgłoszono wyjątek podczas wykonywania co najmniej jednego <see cref="T:System.Threading.Tasks.Task" /> wystąpienia.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" />jest liczbą ujemną inną niż-1, co oznacza nieskończony limit czasu.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> Argument zawiera element o wartości null.</exception>
        <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken" /> Anulowano.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAny">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Czeka na dowolne z podanych <see cref="T:System.Threading.Tasks.Task" /> obiektów, aby ukończyć wykonywanie.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (ParamArray tasks As Task()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(... cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.Tasks.Task[] -&gt; int" Usage="System.Threading.Tasks.Task.WaitAny tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks">Tablica <see cref="T:System.Threading.Tasks.Task" /> wystąpień, na których należy czekać.</param>
        <summary>Czeka na dowolne z podanych <see cref="T:System.Threading.Tasks.Task" /> obiektów, aby ukończyć wykonywanie.</summary>
        <returns>Indeks ukończonego <see cref="T:System.Threading.Tasks.Task" /> obiektu <paramref name="tasks" /> w tablicy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie uruchamiane są pięć zadań, z których każde uśpienie jest przez co najmniej 50 milisekund lub maksymalnie 1 050 milisekund. Następnie <xref:System.Threading.Tasks.Task.WaitAny%2A> Metoda czeka na zakończenie każdego z zadań. W przykładzie przedstawiono identyfikator zadania zadania, które zakończyło się oczekiwanie, a także bieżący stan wszystkich zadań.  
  
 [!code-csharp[System.Threading.Tasks.Task.WaitAny#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Tasks.Task.WaitAny/cs/WaitAny1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.WaitAny#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Tasks.Task.WaitAny/vb/WaitAny1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> Został usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">Argument ma wartość <see langword="null" />. <paramref name="tasks" /></exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> Argument zawiera element o wartości null.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (tasks As Task(), millisecondsTimeout As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.Tasks.Task[] * int -&gt; int" Usage="System.Threading.Tasks.Task.WaitAny (tasks, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="tasks">Tablica <see cref="T:System.Threading.Tasks.Task" /> wystąpień, na których należy czekać.</param>
        <param name="millisecondsTimeout">Liczba milisekund oczekiwania lub <see cref="F:System.Threading.Timeout.Infinite" /> (-1) oczekiwania na czas nieokreślony.</param>
        <summary>Czeka na dowolne z podanych <see cref="T:System.Threading.Tasks.Task" /> obiektów, aby ukończyć wykonywanie w ciągu określonej liczby milisekund.</summary>
        <returns>Indeks ukończonego zadania w <paramref name="tasks" /> argumencie Array lub-1, jeśli upłynął limit czasu.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> Został usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">Argument ma wartość <see langword="null" />. <paramref name="tasks" /></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" />jest liczbą ujemną inną niż-1, co oznacza nieskończony limit czasu.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> Argument zawiera element o wartości null.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.Tasks.Task[] * System.Threading.CancellationToken -&gt; int" Usage="System.Threading.Tasks.Task.WaitAny (tasks, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">Tablica <see cref="T:System.Threading.Tasks.Task" /> wystąpień, na których należy czekać.</param>
        <param name="cancellationToken">A <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> , aby obserwować czas oczekiwania na ukończenie zadania.</param>
        <summary>Czeka na dowolne z podanych <see cref="T:System.Threading.Tasks.Task" /> obiektów do zakończenia wykonywania, chyba że oczekiwanie zostanie anulowane.</summary>
        <returns>Indeks ukończonego zadania w <paramref name="tasks" /> argumencie Array.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> Został usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">Argument ma wartość <see langword="null" />. <paramref name="tasks" /></exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> Argument zawiera element o wartości null.</exception>
        <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken" /> Anulowano.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (tasks As Task(), timeout As TimeSpan) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.Tasks.Task[] * TimeSpan -&gt; int" Usage="System.Threading.Tasks.Task.WaitAny (tasks, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="tasks">Tablica <see cref="T:System.Threading.Tasks.Task" /> wystąpień, na których należy czekać.</param>
        <param name="timeout">Reprezentuje liczbę milisekund, które należy oczekiwać <see cref="T:System.TimeSpan" /> lub który reprezentuje-1 milisekund, aby czekać na czas nieokreślony. <see cref="T:System.TimeSpan" /></param>
        <summary>Czeka na dowolne z podanych <see cref="T:System.Threading.Tasks.Task" /> obiektów, aby zakończyć wykonywanie w określonym przedziale czasu.</summary>
        <returns>Indeks ukończonego zadania w <paramref name="tasks" /> argumencie Array lub-1, jeśli upłynął limit czasu.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> Został usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">Argument ma wartość <see langword="null" />. <paramref name="tasks" /></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><see cref="P:System.TimeSpan.TotalMilliseconds" /> Właściwość<paramref name="timeout" /> argumentu jest liczbą ujemną inną niż-1, co oznacza nieskończony limit czasu. 
—lub— 
Właściwość argumentu jest większa niż <see cref="F:System.Int32.MaxValue" />. <see cref="P:System.TimeSpan.TotalMilliseconds" /> <paramref name="timeout" /></exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> Argument zawiera element o wartości null.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.Tasks.Task[] * int * System.Threading.CancellationToken -&gt; int" Usage="System.Threading.Tasks.Task.WaitAny (tasks, millisecondsTimeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">Tablica <see cref="T:System.Threading.Tasks.Task" /> wystąpień, na których należy czekać.</param>
        <param name="millisecondsTimeout">Liczba milisekund oczekiwania lub <see cref="F:System.Threading.Timeout.Infinite" /> (-1) oczekiwania na czas nieokreślony.</param>
        <param name="cancellationToken">A <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> , aby obserwować czas oczekiwania na ukończenie zadania.</param>
        <summary>Czeka na dowolne z podanych <see cref="T:System.Threading.Tasks.Task" /> obiektów, aby zakończyć wykonywanie w ciągu określonej liczby milisekund lub do czasu anulowania tokenu anulowania.</summary>
        <returns>Indeks ukończonego zadania w <paramref name="tasks" /> argumencie Array lub-1, jeśli upłynął limit czasu.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Threading.Tasks.Task" /> Został usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">Argument ma wartość <see langword="null" />. <paramref name="tasks" /></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout" />jest liczbą ujemną inną niż-1, co oznacza nieskończony limit czasu.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> Argument zawiera element o wartości null.</exception>
        <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken" /> Anulowano.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WhenAll">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy zadanie, które zostanie ukończone po zakończeniu wszystkich podanych zadań.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WhenAll">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WhenAll (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WhenAll(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAll (tasks As IEnumerable(Of Task)) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ WhenAll(System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAll : seq&lt;System.Threading.Tasks.Task&gt; -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.WhenAll tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="tasks">Zadania, które należy oczekiwać na zakończenie.</param>
        <summary>Tworzy zadanie, które zostanie ukończone, gdy wszystkie <see cref="T:System.Threading.Tasks.Task" /> obiekty w wyliczalnej kolekcji zostaną zakończone.</summary>
        <returns>Zadanie, które reprezentuje zakończenie wszystkich podanych zadań.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążenia <xref:System.Threading.Tasks.Task.WhenAll%2A> metody, która <xref:System.Threading.Tasks.Task> zwraca obiekt, są zwykle wywoływane, gdy interesuje się stan zestawu zadań lub wyjątków zgłaszanych przez zestaw zadań.  
  
> [!NOTE]
>  Wywołanie <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29> metody nie blokuje wątku wywołującego.  
  
 Jeśli którekolwiek z podanych zadań zakończy się w stanie awarii, zwrócone zadanie również zostanie ukończone w <xref:System.Threading.Tasks.TaskStatus.Faulted> stanie, w którym jego wyjątki będą zawierać agregację zestawu nieopakowanych wyjątków z każdego z podanych zadań.  
  
 Jeśli żaden z podanych zadań nie wystąpił błąd, ale co najmniej jeden z nich został anulowany, zwrócone zadanie zakończy się w <xref:System.Threading.Tasks.TaskStatus.Canceled> stanie.  
  
 Jeśli żadne z zadań nie zakończyło się niepowodzeniem, a żadne z nich nie zostało anulowane, wyniki <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> zadania zakończą się w stanie.  
  
 Jeśli dostarczona tablica/wyliczalna nie zawiera żadnych zadań, zwracane zadanie natychmiast przejdzie <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> do stanu, zanim zostanie zwrócone do obiektu wywołującego.  
  
   
  
## Examples  
 Poniższy przykład tworzy zestaw zadań, które wysyłają polecenie ping do adresów URL w tablicy. Zadania są przechowywane w `List<Task>` kolekcji, która jest przenoszona <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29> do metody. Po wywołaniu <xref:System.Threading.Tasks.Task.Wait%2A> metody zapewnia, że wszystkie wątki zostały ukończone, przykład sprawdza <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> właściwość, aby określić, czy jakieś zadania uległy awarii.  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/WhenAll4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/WhenAll4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" /> Argument był<see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> Kolekcja<see langword="null" /> zawiera zadanie.</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAll">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WhenAll (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WhenAll(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAll (ParamArray tasks As Task()) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ WhenAll(... cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAll : System.Threading.Tasks.Task[] -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.WhenAll tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks">Zadania, które należy oczekiwać na zakończenie.</param>
        <summary>Tworzy zadanie, które zostanie ukończone po zakończeniu wszystkich <see cref="T:System.Threading.Tasks.Task" /> obiektów w tablicy.</summary>
        <returns>Zadanie, które reprezentuje zakończenie wszystkich podanych zadań.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążenia <xref:System.Threading.Tasks.Task.WhenAll%2A> metody, która <xref:System.Threading.Tasks.Task> zwraca obiekt, są zwykle wywoływane, gdy interesuje się stan zestawu zadań lub wyjątków zgłaszanych przez zestaw zadań.  
  
> [!NOTE]
>  Wywołanie <xref:System.Threading.Tasks.Task.WhenAll%28System.Threading.Tasks.Task%5B%5D%29> metody nie blokuje wątku wywołującego.  
  
 Jeśli którekolwiek z podanych zadań zakończy się w stanie awarii, zwrócone zadanie również zostanie ukończone w <xref:System.Threading.Tasks.TaskStatus.Faulted> stanie, w którym jego wyjątki będą zawierać agregację zestawu nieopakowanych wyjątków z każdego z podanych zadań.  
  
 Jeśli żaden z podanych zadań nie wystąpił błąd, ale co najmniej jeden z nich został anulowany, zwrócone zadanie zakończy się w <xref:System.Threading.Tasks.TaskStatus.Canceled> stanie.  
  
 Jeśli żadne z zadań nie zakończyło się niepowodzeniem, a żadne z nich nie zostało anulowane, wyniki <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> zadania zakończą się w stanie.  
  
 Jeśli dostarczona tablica/wyliczalna nie zawiera żadnych zadań, zwracane zadanie natychmiast przejdzie <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> do stanu, zanim zostanie zwrócone do obiektu wywołującego.  
  
   
  
## Examples  
 Poniższy przykład tworzy zestaw zadań, które wysyłają polecenie ping do adresów URL w tablicy. Zadania są przechowywane w `List<Task>` kolekcji, która jest konwertowana na tablicę i przenoszona <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29> do metody. Po wywołaniu <xref:System.Threading.Tasks.Task.Wait%2A> metody zapewnia, że wszystkie wątki zostały ukończone, przykład sprawdza <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> właściwość, aby określić, czy jakieś zadania uległy awarii.  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/WhenAll3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/WhenAll3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" /> Argument był<see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> Tablica<see langword="null" /> zawiera zadanie.</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAll&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult[]&gt; WhenAll&lt;TResult&gt; (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult[]&gt; WhenAll&lt;TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAll(Of TResult) (tasks As IEnumerable(Of Task(Of TResult))) As Task(Of TResult())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;cli::array &lt;TResult&gt; ^&gt; ^ WhenAll(System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAll : seq&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; -&gt; System.Threading.Tasks.Task&lt;'Result[]&gt;" Usage="System.Threading.Tasks.Task.WhenAll tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult[]&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ ukończonego zadania.</typeparam>
        <param name="tasks">Zadania, które należy oczekiwać na zakończenie.</param>
        <summary>Tworzy zadanie, które zostanie ukończone, gdy wszystkie <see cref="T:System.Threading.Tasks.Task`1" /> obiekty w wyliczalnej kolekcji zostaną zakończone.</summary>
        <returns>Zadanie, które reprezentuje zakończenie wszystkich podanych zadań.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie <xref:System.Threading.Tasks.Task.WhenAll%60%601%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7B%60%600%7D%7D%29> metody nie blokuje wątku wywołującego. Jednak wywołanie zwracanej <xref:System.Threading.Tasks.Task%601.Result%2A> właściwości blokuje wywołujący wątek.  
  
 Jeśli którekolwiek z podanych zadań zakończy się w stanie awarii, zwrócone zadanie również zostanie ukończone w <xref:System.Threading.Tasks.TaskStatus.Faulted> stanie, w którym jego wyjątki będą zawierać agregację zestawu nieopakowanych wyjątków z każdego z podanych zadań.  
  
 Jeśli żaden z podanych zadań nie wystąpił błąd, ale co najmniej jeden z nich został anulowany, zwrócone zadanie zakończy się w <xref:System.Threading.Tasks.TaskStatus.Canceled> stanie.  
  
 Jeśli żadne z zadań nie zakończyło się niepowodzeniem, a żadne z nich nie zostało anulowane, wyniki <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> zadania zakończą się w stanie.  Właściwość zwracanego zadania zostanie ustawiona na tablicę zawierającą wszystkie wyniki dostarczonych zadań w tej samej kolejności, w jakiej zostały dostarczone (np. Jeśli tablica zadań wejściowych zawiera T1, T2, T3, <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> właściwość zadania wyjściowego zwróci wartość <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> `TResult[]` gdzie .`arr[0] == t1.Result, arr[1] == t2.Result, and arr[2] == t3.Result)`  
  
 Jeśli argument nie zawiera żadnych zadań, zwracane zadanie natychmiast przejdzie <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> do stanu przed zwróceniem go do obiektu wywołującego. `tasks` Zwracana `TResult[]` wartość będzie tablicą 0 elementów.  
  
   
  
## Examples  
 Poniższy przykład tworzy dziesięć zadań, z których każdy tworzy wystąpienie generatora liczb losowych, co powoduje utworzenie losowych liczb 1 000 z zakresu od 1 do 1 000 i obliczy ich znaczenie. <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> Metoda jest używana do opóźniania tworzenia wystąpień generatorów liczb losowych, dzięki czemu nie są one tworzone z identycznymi wartościami inicjatora. Wywołanie <xref:System.Threading.Tasks.Task.WhenAll%2A> metody<xref:System.Int64> zwraca tablicę zawierającą średnią obliczoną przez każde zadanie. Są one następnie używane do obliczania całkowitego średniego.  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/whenall1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/whenall1.vb#1)]  
  
 W takim przypadku dziesięć poszczególnych zadań są przechowywane w <xref:System.Collections.Generic.List%601> obiekcie. <xref:System.Collections.Generic.List%601><xref:System.Collections.Generic.IEnumerable%601> implementuje interfejs.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" /> Argument był<see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> Kolekcja<see langword="null" /> zawiera zadanie.</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAll&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult[]&gt; WhenAll&lt;TResult&gt; (params System.Threading.Tasks.Task&lt;TResult&gt;[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult[]&gt; WhenAll&lt;TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TResult&gt;[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAll(Of TResult) (ParamArray tasks As Task(Of TResult)()) As Task(Of TResult())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;cli::array &lt;TResult&gt; ^&gt; ^ WhenAll(... cli::array &lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAll : System.Threading.Tasks.Task&lt;'Result&gt;[] -&gt; System.Threading.Tasks.Task&lt;'Result[]&gt;" Usage="System.Threading.Tasks.Task.WhenAll tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult[]&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TResult&gt;[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ ukończonego zadania.</typeparam>
        <param name="tasks">Zadania, które należy oczekiwać na zakończenie.</param>
        <summary>Tworzy zadanie, które zostanie ukończone po zakończeniu wszystkich <see cref="T:System.Threading.Tasks.Task`1" /> obiektów w tablicy.</summary>
        <returns>Zadanie, które reprezentuje zakończenie wszystkich podanych zadań.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie <xref:System.Threading.Tasks.Task.WhenAll%60%601%28System.Threading.Tasks.Task%7B%60%600%7D%5B%5D%29> metody nie blokuje wątku wywołującego. Jednak wywołanie zwracanej <xref:System.Threading.Tasks.Task%601.Result%2A> właściwości blokuje wywołujący wątek.  
  
 Jeśli którekolwiek z podanych zadań zakończy się w stanie awarii, zwrócone zadanie również zostanie ukończone w <xref:System.Threading.Tasks.TaskStatus.Faulted> stanie, w którym jego wyjątki będą zawierać agregację zestawu nieopakowanych wyjątków z każdego z podanych zadań.  
  
 Jeśli żaden z podanych zadań nie wystąpił błąd, ale co najmniej jeden z nich został anulowany, zwrócone zadanie zakończy się w <xref:System.Threading.Tasks.TaskStatus.Canceled> stanie.  
  
 Jeśli żadne z zadań nie zakończyło się niepowodzeniem, a żadne z nich nie zostało anulowane, wyniki <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> zadania zakończą się w stanie.  Dla zwracanego zadania zostanie ustawiona tablica zawierająca wszystkie wyniki dostarczonych zadań w tej samej kolejności, w jakiej zostały dostarczone (np. Jeśli tablica zadań wejściowych zawiera T1, T2, T3, <xref:System.Threading.Tasks.Task%601.Result%2A> zadanie wyjściowe zwróci `TResult[]` <xref:System.Threading.Tasks.Task%601.Result%2A> gdzie `arr[0] == t1.Result, arr[1] == t2.Result, and arr[2] == t3.Result)`.  
  
 Jeśli dostarczona tablica/wyliczalna nie zawiera żadnych zadań, zwracane zadanie natychmiast przejdzie <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> do stanu, zanim zostanie zwrócone do obiektu wywołującego.  Zwracana `TResult[]` wartość będzie tablicą 0 elementów.  
  
   
  
## Examples  
 Poniższy przykład tworzy dziesięć zadań, z których każdy tworzy wystąpienie generatora liczb losowych, co powoduje utworzenie losowych liczb 1 000 z zakresu od 1 do 1 000 i obliczy ich znaczenie. W takim przypadku dziesięć poszczególnych zadań jest przechowywanych w `Task<Int64>` tablicy.  <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> Metoda jest używana do opóźniania tworzenia wystąpień generatorów liczb losowych, dzięki czemu nie są one tworzone z identycznymi wartościami inicjatora. Wywołanie <xref:System.Threading.Tasks.Task.WhenAll%2A> metody<xref:System.Int64> zwraca tablicę zawierającą średnią obliczoną przez każde zadanie. Są one następnie używane do obliczania całkowitego średniego.  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/whenall2.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/whenall2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" /> Argument był<see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> Tablica<see langword="null" /> zawiera zadanie.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WhenAny">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy zadanie, które zostanie ukończone po zakończeniu dowolnego z podanych zadań.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WhenAny">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt; WhenAny (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task&gt; WhenAny(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAny (tasks As IEnumerable(Of Task)) As Task(Of Task)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task&lt;System::Threading::Tasks::Task ^&gt; ^ WhenAny(System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAny : seq&lt;System.Threading.Tasks.Task&gt; -&gt; System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt;" Usage="System.Threading.Tasks.Task.WhenAny tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="tasks">Zadania, które należy oczekiwać na zakończenie.</param>
        <summary>Tworzy zadanie, które zostanie ukończone po zakończeniu dowolnego z podanych zadań.</summary>
        <returns>Zadanie, które reprezentuje zakończenie jednego z podanych zadań.  Wynik zadania powrotu to zadanie, które zostało zakończone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócone zadanie zostanie ukończone po zakończeniu dowolnego z podanych zadań.  Zwrócone zadanie będzie zawsze kończyć `RanToCompletion` się stanem, a jego wynik jest ustawiony na pierwsze zadanie do wykonania.  Ta wartość jest prawdziwa nawet wtedy, gdy pierwsze zadanie zostało zakończone w `Canceled` stanie `Faulted` lub.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" /> Argument był<see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> Tablica zawiera zadanie o wartości null lub jest puste.</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAny">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt; WhenAny (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task&gt; WhenAny(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny(System.Threading.Tasks.Task[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAny (ParamArray tasks As Task()) As Task(Of Task)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task&lt;System::Threading::Tasks::Task ^&gt; ^ WhenAny(... cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAny : System.Threading.Tasks.Task[] -&gt; System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt;" Usage="System.Threading.Tasks.Task.WhenAny tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks">Zadania, które należy oczekiwać na zakończenie.</param>
        <summary>Tworzy zadanie, które zostanie ukończone po zakończeniu dowolnego z podanych zadań.</summary>
        <returns>Zadanie, które reprezentuje zakończenie jednego z podanych zadań.  Wynik zadania powrotu to zadanie, które zostało zakończone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócone zadanie zostanie ukończone po zakończeniu dowolnego z podanych zadań.  Zwrócone zadanie będzie zawsze kończyć `RanToCompletion` się stanem `Result` ustawionym na pierwsze zadanie do wykonania.  Ta wartość jest prawdziwa nawet wtedy, gdy pierwsze zadanie zostało zakończone w `Canceled` stanie `Faulted` lub.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" /> Argument miał wartość null.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> Tablica zawiera zadanie o wartości null lub jest puste.</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAny&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; WhenAny&lt;TResult&gt; (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; WhenAny&lt;TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAny(Of TResult) (tasks As IEnumerable(Of Task(Of TResult))) As Task(Of Task(Of TResult))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ WhenAny(System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAny : seq&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; -&gt; System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt;" Usage="System.Threading.Tasks.Task.WhenAny tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ ukończonego zadania.</typeparam>
        <param name="tasks">Zadania, które należy oczekiwać na zakończenie.</param>
        <summary>Tworzy zadanie, które zostanie ukończone po zakończeniu dowolnego z podanych zadań.</summary>
        <returns>Zadanie, które reprezentuje zakończenie jednego z podanych zadań.  Wynik zadania powrotu to zadanie, które zostało zakończone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócone zadanie zostanie ukończone po zakończeniu dowolnego z podanych zadań.  Zwrócone zadanie będzie zawsze kończyć się stanem RanToCompletion, a jego wynik jest ustawiony na pierwsze zadanie do wykonania. Jest to prawdziwe, nawet jeśli pierwsze zadanie do ukończenia zostało zakończone w stanie anulowane lub błędne.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" /> Argument był<see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> Tablica zawiera zadanie o wartości null lub jest puste.</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAny&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; WhenAny&lt;TResult&gt; (params System.Threading.Tasks.Task&lt;TResult&gt;[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; WhenAny&lt;TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TResult&gt;[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny``1(System.Threading.Tasks.Task{``0}[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAny(Of TResult) (ParamArray tasks As Task(Of TResult)()) As Task(Of Task(Of TResult))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ WhenAny(... cli::array &lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAny : System.Threading.Tasks.Task&lt;'Result&gt;[] -&gt; System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt;" Usage="System.Threading.Tasks.Task.WhenAny tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TResult&gt;[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ ukończonego zadania.</typeparam>
        <param name="tasks">Zadania, które należy oczekiwać na zakończenie.</param>
        <summary>Tworzy zadanie, które zostanie ukończone po zakończeniu dowolnego z podanych zadań.</summary>
        <returns>Zadanie, które reprezentuje zakończenie jednego z podanych zadań.  Wynik zadania powrotu to zadanie, które zostało zakończone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócone zadanie zostanie ukończone po zakończeniu dowolnego z podanych zadań.  Zwrócone zadanie będzie zawsze kończyć się stanem RanToCompletion, a jego wynik jest ustawiony na pierwsze zadanie do wykonania. Jest to prawdziwe, nawet jeśli pierwsze zadanie do ukończenia zostało zakończone w stanie anulowane lub błędne.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="tasks" /> Argument miał wartość null.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="tasks" /> Tablica zawiera zadanie o wartości null lub jest puste.</exception>
      </Docs>
    </Member>
    <Member MemberName="Yield">
      <MemberSignature Language="C#" Value="public static System.Runtime.CompilerServices.YieldAwaitable Yield ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Runtime.CompilerServices.YieldAwaitable Yield() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Yield" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Yield () As YieldAwaitable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::CompilerServices::YieldAwaitable Yield();" />
      <MemberSignature Language="F#" Value="static member Yield : unit -&gt; System.Runtime.CompilerServices.YieldAwaitable" Usage="System.Threading.Tasks.Task.Yield " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.CompilerServices.YieldAwaitable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy zadanie oczekujące, które asynchronicznie zwraca do bieżącego kontekstu, gdy oczekiwano.</summary>
        <returns>Kontekst, który w oczekiwany sposób będzie asynchronicznie przechodzić do bieżącego kontekstu w czasie oczekiwania. Jeśli bieżąca <see cref="T:System.Threading.SynchronizationContext" /> wartość jest inna niż null, jest traktowana jako bieżący kontekst. W przeciwnym razie harmonogram zadań skojarzony z aktualnie wykonywanym zadaniem jest traktowany jako bieżący kontekst.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można użyć `await Task.Yield();` w metodzie asynchronicznej, aby wymusić asynchroniczne wykonywanie metody. Jeśli istnieje bieżący kontekst synchronizacji (<xref:System.Threading.SynchronizationContext> obiekt), spowoduje to opublikowanie pozostałej części wykonania metody z powrotem do tego kontekstu. Jednak kontekst decyduje o sposobach określania priorytetów tej pracy względem innych zadań, które mogą być w stanie oczekiwania. W przypadku kontekstu synchronizacji, który jest obecny w wątku interfejsu użytkownika w większości środowisk interfejsu użytkownika, często priorytety pracy ogłoszonej w kontekście wyższym niż dane wejściowe i renderowania. Z tego powodu nie należy polegać `await Task.Yield();` na utrzymywaniu przez interfejs użytkownika odpowiedzi.  Aby uzyskać więcej informacji, zobacz temat [przydatne streszczenia włączone z ContinueWith](https://devblogs.microsoft.com/pfxteam/useful-abstractions-enabled-with-continuewith/) w blogu programowanie równoległe przy użyciu platformy .NET.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>

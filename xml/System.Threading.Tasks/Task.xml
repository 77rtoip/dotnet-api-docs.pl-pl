<Type Name="Task" FullName="System.Threading.Tasks.Task">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c16340e471c95a0473b0f16f55090f971e888200" />
    <Meta Name="ms.sourcegitcommit" Value="723b8a6d92667ba86fcda96190bad3b4a03283b3" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="11/09/2018" />
    <Meta Name="ms.locfileid" Value="51308314" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Task : IAsyncResult, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Task extends System.Object implements class System.IAsyncResult, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.Task" />
  <TypeSignature Language="VB.NET" Value="Public Class Task&#xA;Implements IAsyncResult, IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Task : IAsyncResult, IDisposable" />
  <TypeSignature Language="F#" Value="type Task = class&#xA;    interface IAsyncResult&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IAsyncResult</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Id = {Id}, Status = {Status}, Method = {DebuggerDisplayMethodDescription}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Threading.Tasks.SystemThreadingTasks_TaskDebugView))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje operację asynchroniczną.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
   
## Remarks  
 <xref:System.Threading.Tasks.Task> Klasy reprezentuje jednej operacji, która nie zwraca wartości i że zwykle działa w sposób asynchroniczny. <xref:System.Threading.Tasks.Task> obiekty są jednymi z centralne składniki [wzorca asynchronicznego opartego na zadaniach](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md) po raz pierwszy wprowadzone w programie .NET Framework 4. Ponieważ praca wykonana przez <xref:System.Threading.Tasks.Task> obiektu zwykle wykonuje asynchronicznie na wątku z puli wątków, a nie synchronicznie w wątku głównego aplikacji, można użyć <xref:System.Threading.Tasks.Task.Status%2A> właściwości, jak również <xref:System.Threading.Tasks.Task.IsCanceled%2A>, <xref:System.Threading.Tasks.Task.IsCompleted%2A>, i <xref:System.Threading.Tasks.Task.IsFaulted%2A> właściwości w celu określenia stanu zadania. Najczęściej Wyrażenie lambda jest używany do określenia pracy, która ma wykonać zadanie.  
  
 Dla operacji, które zwracają wartości, możesz użyć <xref:System.Threading.Tasks.Task%601> klasy.  
  
 W tej sekcji:  
  
 [Przykłady tworzenia wystąpienia zadania](#Instant)   
 [Tworzenie i wykonywanie zadania](#Creating)   
 [Oddzielenie zadań tworzenia i wykonywanie](#Separating)   
 [Oczekiwanie na zakończenie jednego lub więcej zadań](#WaitingForOne)   
 [Zadania i kultury](#Culture)   
 [Dla deweloperów debuggerów](#Debugger)  

 <a name="Instant"></a>     
## <a name="task-instantiation"></a>Podczas tworzenia wystąpienia zadania  
 Poniższy przykład tworzy i uruchamia cztery zadania. Trzy zadania wykonywane <xref:System.Action%601> delegat o nazwie `action`, które przyjmuje argument typu <xref:System.Object>. Czwarte zadanie podrzędne wykonuje wyrażenia lambda ( <xref:System.Action> delegować) oznacza to zdefiniowano w tekście w wywołaniu metody tworzenia zadania. Każde zadanie jest tworzone i uruchamiać w inny sposób:  
  
-   Zadanie `t1` jest tworzone przez wywołanie konstruktora klasy zadania, ale jest uruchomiona przez wywołanie jego <xref:System.Threading.Tasks.Task.Start> metody tylko zadania `t2` została uruchomiona.  
  
-   Zadanie `t2` jest tworzone i pracę w pojedynczym wywołaniu metody, wywołując <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%29?displayProperty=nameWithType> metody.  
  
-   Zadanie `t3` jest tworzone i pracę w pojedynczym wywołaniu metody, wywołując <xref:System.Threading.Tasks.Task.Run%28System.Action%29> metody.  
  
-   Zadanie `t4` jest wykonywana synchronicznie w wątku głównym, wywołując <xref:System.Threading.Tasks.Task.RunSynchronously> metody.  
  
 Ponieważ zadanie `t4` jest wykonywana synchronicznie, wykonuje na wątku głównego aplikacji. Asynchronicznie zwykle wykonać pozostałe zadania na jeden lub więcej wątków z puli wątków.  
  
 [!code-csharp[System.Threading.Tasks.Task#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/startnew.cs#01)]
 [!code-vb[System.Threading.Tasks.Task#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/startnew.vb#01)] 
    
<a name="Creating"></a>   
## <a name="creating-and-executing-a-task"></a>Tworzenie i wykonywanie zadania  
 <xref:System.Threading.Tasks.Task> wystąpienia można tworzyć różne sposoby. Najbardziej typowym podejściem, która jest dostępna, począwszy od [!INCLUDE[net_v45](~/includes/net-v45-md.md)], wywołaj statyczną jest <xref:System.Threading.Tasks.Task.Run%2A> metody. <xref:System.Threading.Tasks.Task.Run%2A> Metoda zapewnia prosty sposób, aby uruchomić zadanie przy użyciu wartości domyślnych i nie wymaga dodatkowych parametrów. W poniższym przykładzie użyto <xref:System.Threading.Tasks.Task.Run%28System.Action%29> metodę, aby uruchomić zadanie, które w pętli, a następnie wyświetla liczbę iteracji pętli:  
  
 [!code-csharp[System.Threading.Tasks.Task#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/run1.cs#6)]
 [!code-vb[System.Threading.Tasks.Task#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/run1.vb#6)]  
  
 Zamiast i najbardziej typowa metoda, aby uruchomić zadanie w ramach [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], jest statyczną <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> metody. <xref:System.Threading.Tasks.Task.Factory%2A?displayProperty=nameWithType> Właściwość zwraca <xref:System.Threading.Tasks.TaskFactory> obiektu. Przeciążenia <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> metody pozwalają określić parametry do przekazania do opcji tworzenia zadań i harmonogramu zadań. W poniższym przykładzie użyto <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> metodę, aby uruchomić zadanie. Jest funkcjonalnym odpowiednikiem kodu w poprzednim przykładzie.  
  
 [!code-csharp[System.Threading.Tasks.Task#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/startnew1.cs#7)]
 [!code-vb[System.Threading.Tasks.Task#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/startnew1.vb#7)]  
  
 Aby uzyskać bardziej kompletne przykłady, zobacz [opartego na zadaniach Asynchronous Programming](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md).  
  
<a name="Separating"></a>   
## <a name="separating-task-creation-and-execution"></a>Oddzielenie zadań tworzenia i wykonywanie  
 <xref:System.Threading.Tasks.Task> Również udostępnia konstruktorów, zainicjować zadanie, ale który nie należy planować go do wykonania. Ze względu na wydajność <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> lub <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> metody jest to preferowany sposób tworzenia i planowania zadań obliczeniowych, ale w przypadku scenariuszy, w której muszą być oddzielone tworzeniem i planowaniem użycie konstruktorów, a następnie wywołać <xref:System.Threading.Tasks.Task.Start%2A?displayProperty=nameWithType> metodę, aby zaplanować zadanie do wykonania w późniejszym czasie.  
  
<a name="WaitingForOne"></a>   
## <a name="waiting-for-one-or-more-tasks-to-complete"></a>Oczekiwanie na zakończenie jednego lub więcej zadań  
 Ponieważ zadania zazwyczaj są uruchamiane asynchronicznie na wątku z puli wątków, wątek, który tworzy i uruchamia zadanie kontynuuje wykonywanie, tak szybko, jak utworzyć wystąpienia zadania. W niektórych przypadkach, gdy wątek wywołujący jest wątku głównego aplikacji aplikacji może rozwiązać niniejszą przed każdą zadanie faktycznie rozpoczyna wykonywanie. W innych Twoja aplikacja logiki może wymagać wątek wywołujący kontynuować wykonywanie, tylko wtedy, gdy co najmniej jedno zadanie zakończy działanie. Można synchronizować wykonanie wątku wywołującego i asynchroniczną zadań jej uruchomień, wywołując `Wait` metodę, aby czekać na zakończenie jednego lub więcej zadań.  
  
 Oczekiwania na zakończenie pojedynczego zadania, można wywołać jej <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> metody. Wywołanie <xref:System.Threading.Tasks.Task.Wait%2A> metoda blokuje wątek wywołujący, dopóki nie zakończy się wystąpieniem jednej klasy wykonywania.  
  
 Poniższy przykład wywołuje bez parametrów <xref:System.Threading.Tasks.Task.Wait> metoda bezwarunkowo czekać, aż do zakończenia zadania. Zadanie symuluje pracy przez wywołanie metody <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> metody w stan uśpienia na 2 sekundy.  
  
 [!code-csharp[System.Threading.Tasks.Task#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/Wait1.cs#8)]
 [!code-vb[System.Threading.Tasks.Task#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/Wait1.vb#8)]  
  
 Możesz również warunkowo poczekać na zakończenie zadania. <xref:System.Threading.Tasks.Task.Wait%28System.Int32%29> i <xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29> metody zablokowanie wątku wywołującego przed zakończeniem zadania lub interwał limitu czasu upłynie, osiągnięta jako pierwsza. Ponieważ w poniższym przykładzie uruchamia zadanie, które zostaje uśpione na dwóch sekund, ale określa wartość limitu czasu jednosekundowych, wywoływania bloki wątku, dopóki nie upłynie limit czasu i przed zadanie zostało ukończone wykonywania.  
  
 [!code-csharp[System.Threading.Tasks.Task#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/Wait2.cs#9)]
 [!code-vb[System.Threading.Tasks.Task#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/Wait2.vb#9)]  
  
 Możesz również dostarczyć token anulowania, wywołując <xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29> i <xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> metody. Jeśli token <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> właściwość `true` lub staje się `true` podczas <xref:System.Threading.Tasks.Task.Wait%2A> metoda jest wykonywaay, metoda zgłasza <xref:System.OperationCanceledException>.  
  
 W niektórych przypadkach możesz chcieć oczekiwania dla pierwszej serii wykonywania zadań do wykonania, ale nie jest opiekę zadań go.  W tym celu można też wywołać jedną z przeciążeń <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> metody.  Poniższy przykład tworzy trzy zadania, z których każdy jest w stanie uśpienia dla interwału określają przez generator liczb losowych. <xref:System.Threading.Tasks.Task.WaitAny%28System.Threading.Tasks.Task%5B%5D%29> Metoda czeka na pierwsze zadanie do wykonania. Przykład następnie wyświetla informacje o stanie wszystkich trzech zadań.  
  
 [!code-csharp[System.Threading.Tasks.Task#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/WhenAny1.cs#10)]
 [!code-vb[System.Threading.Tasks.Task#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/WaitAny1.vb#10)]  
  
 Można również poczekać, aż wszystkie serię zadań do wykonania przez wywołanie metody <xref:System.Threading.Tasks.Task.WaitAll%2A> metody. Poniższy przykład tworzy dziesięć zadania podrzędne, czeka, aż wszystkie dziesięć do ukończenia, a następnie wyświetla ich stan.  
  
 [!code-csharp[System.Threading.Tasks.Task#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/WaitAll1.cs#11)]
 [!code-vb[System.Threading.Tasks.Task#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/WaitAll1.vb#11)]  
  
 Należy pamiętać, że gdy czekasz na zakończenie jednego lub więcej zadań, wyjątki zgłaszane w uruchomione zadania podrzędne są przenoszone w wątku, który wywołuje `Wait` metody, jak w poniższym przykładzie pokazano. Uruchamia on 12 zadań, z których trzy zakończone normalnie i trzy które throw wyjątek, który. Pozostałe sześć zadań są trzy anulowane przed rozpoczęciem, a trzy są anulowane podczas ich wykonywania. Wyjątki zostaną zgłoszone w <xref:System.Threading.Tasks.Task.WaitAll%2A> wywołania metody i są obsługiwane przez `try` / `catch` bloku.  
  
 [!code-csharp[System.Threading.Tasks.Task#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/WaitAll2.cs#12)]
 [!code-vb[System.Threading.Tasks.Task#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/WaitAll2.vb#12)]  
  
 Aby uzyskać więcej informacji na temat obsługi wyjątków w opartego na zadaniach operacji asynchronicznych, zobacz [wyjątków](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
<a name="Culture"></a>   
## <a name="tasks-and-culture"></a>Zadania i kultury  
 Począwszy od aplikacji komputerowych, których platformą docelową [!INCLUDE[net_v46](~/includes/net-v46-md.md)], kultury wątku, który tworzy, a następnie wywołuje zadanie staje się częścią kontekst wątku. Niezależnie od bieżącej kultury wątku, na którym zadanie podrzędne jest wykonywane, bieżącej kultury zadania jest kultura wątku wywołującego. W przypadku aplikacji przeznaczonych dla wersji programu .NET Framework w wersjach wcześniejszych niż [!INCLUDE[net_v46](~/includes/net-v46-md.md)], kultury zadania jest kulturą wątku, na którym zadanie podrzędne jest wykonywane. Aby uzyskać więcej informacji, zobacz sekcję "Kultury i opartego na zadaniach asynchronicznej operacji" w <xref:System.Globalization.CultureInfo> tematu.  
  
> [!NOTE]
>  Store apps wykonaj środowiska wykonawczego Windows w ustawienie i pobierania domyślnej kultury.  
  
<a name="Debugger"></a>   
## <a name="for-debugger-developers"></a>Dla deweloperów debuggerów  
 Dla deweloperów, implementowanie niestandardowych debugery kilka wewnętrzne i prywatne składowe, które zadania mogą być przydatne, (te mogą ulec zmianie wersji). `m_taskId` Pola służy jako magazyn zapasowy <xref:System.Threading.Tasks.Task.Id%2A> właściwość, jednak do uzyskiwania dostępu do tego pola bezpośrednio z debuger może być bardziej efektywne niż dostęp do tej samej wartości za pośrednictwem metoda pobierająca właściwości ( `s_taskIdCounter` licznika używany do pobierania następnego dostępnego Identyfikatora zadania). Podobnie `m_stateFlags` pola przechowuje informacje o bieżącym etapie cyklu życia zadania informacji jest również dostępny za pośrednictwem <xref:System.Threading.Tasks.Task.Status%2A> właściwości. `m_action` Pole przechowuje odwołania do delegata zadania, a `m_stateObject` pole przechowuje stan async przekazany do zadania przez dewelopera. Na koniec dla debugery, które analizy ramek stosu `InternalWait` metody służy potencjalnych znacznika, gdy zadanie jest wprowadzania operacji oczekiwania.   
  
 ]]></format>
    </remarks>
    <threadsafe>Wszystkie elementy członkowskie <see cref="T:System.Threading.Tasks.Task" />, z wyjątkiem <see cref="M:System.Threading.Tasks.Task.Dispose" />, są odporne na wątki i mogą być używane jednocześnie z wielu wątków.</threadsafe>
    <altmember cref="T:System.Threading.Tasks.Task`1" />
    <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">Biblioteka zadań równoległych (TPL)</related>
    <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">Programowanie asynchroniczne oparte na zadanie</related>
    <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/Samples-for-Parallel-b4b76364">Przykłady dotyczące programowania równoległego za pomocą programu .NET Framework</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Threading.Tasks.Task" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action ^ action);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task action" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
      </Parameters>
      <Docs>
        <param name="action">Delegat, który reprezentuje kod do wykonania w zadaniu.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Threading.Tasks.Task" /> przy użyciu określonej akcji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zamiast wywoływania tego konstruktora najbardziej popularny sposób do utworzenia wystąpienia <xref:System.Threading.Tasks.Task> obiektu, a następnie uruchom zadanie to przez wywołanie statycznego <xref:System.Threading.Tasks.Task.Run%28System.Action%29?displayProperty=nameWithType> lub <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=nameWithType> metody. Tylko korzyści oferowane przez ten konstruktor jest możliwość tworzenia wystąpienia obiektu oddzielić od wywołania zadania.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%29> Konstruktor do tworzenia zadań, które służą do pobierania nazwy plików w określonych katalogach. Wszystkie zadania zapisu nazwy plików do pojedynczego <xref:System.Collections.Concurrent.ConcurrentBag%601> obiektu. Przykład następnie wywołuje <xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29> metodę, aby upewnić się, że wszystkie zadania zostały wykonane, a następnie wyświetla liczbę całkowitą liczby nazw plików, zapisywane <xref:System.Collections.Concurrent.ConcurrentBag%601> obiektu.  
  
 [!code-csharp[System.Threading.Tasks.Task.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/vb/ctor1.vb#1)]  
  
 Poniższy przykład jest identyczny, z tą różnicą, że użyta <xref:System.Threading.Tasks.Task.Run%28System.Action%29> metody do tworzenia instancji i uruchomić zadanie w ramach jednej operacji. Metoda ta zwraca <xref:System.Threading.Tasks.Task> obiekt, który reprezentuje zadanie.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run2.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Run#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="action" /> Argument jest <see langword="null" />.</exception>
        <altmember cref="M:System.Threading.Tasks.Task.Run(System.Action)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action ^ action, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, cancellationToken)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="action">Delegat, który reprezentuje kod do wykonania w zadaniu.</param>
        <param name="cancellationToken">
          <see cref="T:System.Threading.CancellationToken" /> , Nowe zadanie będzie przestrzegać.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Threading.Tasks.Task" /> z określoną akcję oraz <see cref="T:System.Threading.CancellationToken" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zamiast wywoływania tego konstruktora najbardziej popularny sposób do utworzenia wystąpienia <xref:System.Threading.Tasks.Task> obiektu, a następnie uruchom zadanie to przez wywołanie statycznego <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> i <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> metody. Tylko korzyści oferowane przez ten konstruktor jest możliwość tworzenia wystąpienia obiektu oddzielić od wywołania zadania.  
  
 Aby uzyskać więcej informacji, zobacz [równoległość zadań (Biblioteka zadań równoległych)](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md) i [anulowanie w zarządzanych wątkach](~/docs/standard/threading/cancellation-in-managed-threads.md).  
  
   
  
## Examples  
 Poniższy przykład wywołuje <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%2CSystem.Threading.CancellationToken%29> konstruktora, aby utworzyć zadanie, który iteruje po plików w katalogu C:\Windows\System32. Wywołań wyrażeń lambda <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> metody w celu dodania informacji o każdym z plików do <xref:System.Collections.Generic.List%601> obiektu. Każdy odłączone zadanie zagnieżdżone, wywoływany przez <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> pętli służy do sprawdzania stanu token anulowania i czy zażądano anulowania wywołuje <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> metody. <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> Metoda zgłasza wyjątek <xref:System.OperationCanceledException> wyjątku, który jest obsługiwany w `catch` zablokować, jeśli wątek wywołujący wywołuje <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> metody.  <xref:System.Threading.Tasks.Task.Start%2A> Następnie wywoływana jest metoda, aby rozpocząć zadanie.  
  
 [!code-csharp[System.Threading.Tasks.Task.ctor#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/cs/run4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.ctor#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/vb/run4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Podany <see cref="T:System.Threading.CancellationToken" /> został już usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="action" /> Argument ma wartość null.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action ^ action, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, creationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">Delegat, który reprezentuje kod do wykonania w zadaniu.</param>
        <param name="creationOptions">
          <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> Służące do dostosowywania zachowania zadania podrzędnego.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Threading.Tasks.Task" /> z określonymi opcjami akcji i tworzenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zamiast wywoływania tego konstruktora najbardziej popularny sposób do utworzenia wystąpienia <xref:System.Threading.Tasks.Task> obiektu, a następnie uruchom zadanie to przez wywołanie statycznego <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType> metody. Tylko korzyści oferowane przez ten konstruktor jest możliwość tworzenia wystąpienia obiektu oddzielić od wywołania zadania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="action" /> Argument ma wartość null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="creationOptions" /> Argument określa nieprawidłową wartość dla <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (action As Action(Of Object), state As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action&lt;obj&gt; * obj -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, state)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="action">Delegat, który reprezentuje kod do wykonania w zadaniu.</param>
        <param name="state">Obiekt reprezentujący dane do użycia przez akcję.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Threading.Tasks.Task" /> z określoną akcję i stanu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zamiast wywoływania tego konstruktora najbardziej popularny sposób do utworzenia wystąpienia <xref:System.Threading.Tasks.Task> obiektu, a następnie uruchom zadanie to przez wywołanie statycznego <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%29?displayProperty=nameWithType> metody. Tylko korzyści oferowane przez ten konstruktor jest możliwość tworzenia wystąpienia obiektu oddzielić od wywołania zadania.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano tablicę wyrazów 6. Poszczególnych wyrazów jest następnie przekazywany jako argument do <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%7BSystem.Object%7D%2CSystem.Object%29> konstruktora, którego <xref:System.Action%601> delegata zaszyfrowanie znaków słowa, a następnie wyświetla oryginalny program word i jego wersja zaszyfrowane.  
  
 [!code-csharp[System.Threading.Tasks.Task.ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/cs/startnew3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.ctor#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/vb/startnew3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="action" /> Argument ma wartość null.</exception>
        <altmember cref="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action ^ action, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action * System.Threading.CancellationToken * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, cancellationToken, creationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">Delegat, który reprezentuje kod do wykonania w zadaniu.</param>
        <param name="cancellationToken">
          <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> , Nowe zadanie będzie przestrzegać.</param>
        <param name="creationOptions">
          <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> Służące do dostosowywania zachowania zadania podrzędnego.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Threading.Tasks.Task" /> z określonymi opcjami akcji i tworzenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zamiast wywoływania tego konstruktora najbardziej popularny sposób do utworzenia wystąpienia <xref:System.Threading.Tasks.Task> obiektu, a następnie uruchom zadanie to przez wywołanie statycznego <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType> metody. Tylko korzyści oferowane przez ten konstruktor jest możliwość tworzenia wystąpienia obiektu oddzielić od wywołania zadania.  
  
 Aby uzyskać więcej informacji, zobacz [równoległość zadań (Biblioteka zadań równoległych)](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md) i [anulowanie zadania](~/docs/standard/parallel-programming/task-cancellation.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.CancellationTokenSource" /> Utworzonego <paramref name="cancellationToken" /> został już usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="action" /> Argument ma wartość null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="creationOptions" /> Argument określa nieprawidłową wartość dla <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action&lt;obj&gt; * obj * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, state, cancellationToken)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="action">Delegat, który reprezentuje kod do wykonania w zadaniu.</param>
        <param name="state">Obiekt reprezentujący dane do użycia przez akcję.</param>
        <param name="cancellationToken">
          <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> , Która będzie przestrzegać nowe zadanie.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Threading.Tasks.Task" /> przy użyciu określonej akcji, stanu i opcje.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zamiast wywoływania tego konstruktora najbardziej popularny sposób do utworzenia wystąpienia <xref:System.Threading.Tasks.Task> obiektu, a następnie uruchom zadanie to przez wywołanie statycznego <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> metody. Tylko korzyści oferowane przez ten konstruktor jest możliwość tworzenia wystąpienia obiektu oddzielić od wywołania zadania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.CancellationTokenSource" /> Utworzonego <paramref name="cancellationToken" /> został już usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="action" /> Argument ma wartość null.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (action As Action(Of Object), state As Object, creationOptions As TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action&lt;obj&gt; * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, state, creationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">Delegat, który reprezentuje kod do wykonania w zadaniu.</param>
        <param name="state">Obiekt reprezentujący dane do użycia przez akcję.</param>
        <param name="creationOptions">
          <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> Służące do dostosowywania zachowania zadania podrzędnego.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Threading.Tasks.Task" /> przy użyciu określonej akcji, stanu i opcje.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zamiast wywoływania tego konstruktora najbardziej popularny sposób do utworzenia wystąpienia <xref:System.Threading.Tasks.Task> obiektu, a następnie uruchom zadanie to przez wywołanie statycznego <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType> metody. Tylko korzyści oferowane przez ten konstruktor jest możliwość tworzenia wystąpienia obiektu oddzielić od wywołania zadania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="action" /> Argument ma wartość null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="creationOptions" /> Argument określa nieprawidłową wartość dla <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action&lt;obj&gt; * obj * System.Threading.CancellationToken * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, state, cancellationToken, creationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">Delegat, który reprezentuje kod do wykonania w zadaniu.</param>
        <param name="state">Obiekt reprezentujący dane do użycia przez akcję.</param>
        <param name="cancellationToken">
          <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> , Która będzie przestrzegać nowe zadanie...</param>
        <param name="creationOptions">
          <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> Służące do dostosowywania zachowania zadania podrzędnego.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Threading.Tasks.Task" /> przy użyciu określonej akcji, stanu i opcje.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zamiast wywoływania tego konstruktora najbardziej popularny sposób do utworzenia wystąpienia <xref:System.Threading.Tasks.Task> obiektu, a następnie uruchom zadanie to przez wywołanie statycznego <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType> metody. Tylko korzyści oferowane przez ten konstruktor jest możliwość tworzenia wystąpienia obiektu oddzielić od wywołania zadania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.CancellationTokenSource" /> Utworzonego <paramref name="cancellationToken" /> został już usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="action" /> Argument ma wartość null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="creationOptions" /> Argument określa nieprawidłową wartość dla <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AsyncState">
      <MemberSignature Language="C#" Value="public object AsyncState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object AsyncState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.AsyncState" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AsyncState As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ AsyncState { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AsyncState : obj" Usage="System.Threading.Tasks.Task.AsyncState" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.AsyncState</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera obiekt stanu dostarczane, gdy <see cref="T:System.Threading.Tasks.Task" /> został utworzony lub wartość null, jeśli nie została podana.</summary>
        <value>
          <see cref="T:System.Object" /> Reprezentujący dane stanu, która została przekazana do zadania podczas jej tworzenia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekt do oryginalnego typu można pobrać danych rzutowania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompletedTask">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task CompletedTask { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.Task CompletedTask" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.CompletedTask" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CompletedTask As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::Task ^ CompletedTask { System::Threading::Tasks::Task ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CompletedTask : System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.CompletedTask" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera klasę task, która już została pomyślnie zakończona.</summary>
        <value>Pomyślnie ukończono zadanie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zwraca klasę task, którego <xref:System.Threading.Tasks.Task.Status%2A> właściwość jest ustawiona na <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>. Aby utworzyć zadanie, które zwraca wartość i zostaje ukończone, wywołaj <xref:System.Threading.Tasks.Task.FromResult%2A> metody.  
  
 Ponawianie prób pobierania tej wartości właściwości mogą nie zwracać zawsze tego samego wystąpienia.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Tasks.Task.FromResult``1(``0)" />
      </Docs>
    </Member>
    <Member MemberName="ConfigureAwait">
      <MemberSignature Language="C#" Value="public System.Runtime.CompilerServices.ConfiguredTaskAwaitable ConfigureAwait (bool continueOnCapturedContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Runtime.CompilerServices.ConfiguredTaskAwaitable ConfigureAwait(bool continueOnCapturedContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ConfigureAwait(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConfigureAwait (continueOnCapturedContext As Boolean) As ConfiguredTaskAwaitable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::CompilerServices::ConfiguredTaskAwaitable ConfigureAwait(bool continueOnCapturedContext);" />
      <MemberSignature Language="F#" Value="member this.ConfigureAwait : bool -&gt; System.Runtime.CompilerServices.ConfiguredTaskAwaitable" Usage="task.ConfigureAwait continueOnCapturedContext" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.CompilerServices.ConfiguredTaskAwaitable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continueOnCapturedContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="continueOnCapturedContext">
          <see langword="true" /> Aby kierować kontynuacja z powrotem do oryginalnego kontekstu, które są przechwytywane; w przeciwnym razie <see langword="false" />.</param>
        <summary>Konfiguruje awaiter umożliwia to await <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <returns>Obiekt, który umożliwia await tego zadania.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ContinueWith">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy kontynuację, która wykonuje asynchronicznie po docelowej <see cref="T:System.Threading.Tasks.Task" /> kończy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task)) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task&gt; -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith continuationAction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Działanie, aby uruchamiać, gdy <see cref="T:System.Threading.Tasks.Task" /> kończy. Po uruchomieniu delegata zostaną przekazane ukończonego zadania jako argument.</param>
        <summary>Tworzy kontynuację, która wykonuje asynchronicznie po docelowej <see cref="T:System.Threading.Tasks.Task" /> kończy.</summary>
        <returns>Nowe kontynuacji <see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócony <xref:System.Threading.Tasks.Task> będzie nie być zaplanowane do wykonania, dopóki nie zakończy się bieżące zadanie, czy zostanie zakończona z powodu uruchomionych ukończone pomyślnie, powodujący błąd z powodu nieobsługiwanego wyjątku lub zamykania się wcześniej z powodu anulowania.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano klasę task, która wypełnia tablicę przy użyciu 100 losowych wartości daty i godziny. Używa ona <xref:System.Threading.Tasks.Task.ContinueWith%28System.Action%7BSystem.Threading.Tasks.Task%7D%29> metodę, aby wybrać wcześniej niż i najnowszej wartości daty, gdy tablica jest całkowicie wypełnione.  
  
 [!code-csharp[System.Threading.Tasks.Task.ContinueWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.continuewith/cs/continuewith1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.ContinueWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.continuewith/vb/continuewith1.vb#1)]  
  
 Ponieważ aplikacja konsoli może zakończyć się przed wykonaniem zadania kontynuacji, <xref:System.Threading.Tasks.Task.Wait> metoda jest wywoływana, aby upewnić się, że kontynuacja kończy wykonywanie przed zakończeniem przykładu.  
  
 Na przykład dodatkowe zobacz [tworzenie łańcuchów zadań przy użyciu zadań kontynuacji](~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationAction" /> Argument jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task, Object), state As Object) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task, obj&gt; * obj -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Akcja do uruchomienia po zakończeniu zadania. Po uruchomieniu delegata jest przekazywane jako argumenty ukończonego zadania i obiektu stanu dostarczonych przez obiekt wywołujący.</param>
        <param name="state">Obiekt reprezentujący dane do użycia przez akcję kontynuacji.</param>
        <summary>Tworzy kontynuację, która otrzymuje informacje o stanie dostarczonych przez obiekt wywołujący i wykonuje, gdy element docelowy <see cref="T:System.Threading.Tasks.Task" /> kończy.</summary>
        <returns>Nowe zadanie kontynuacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócony <xref:System.Threading.Tasks.Task> będzie nie być zaplanowane do wykonania, dopóki nie zakończy się bieżące zadanie, czy zostanie zakończona z powodu uruchomionych ukończone pomyślnie, powodujący błąd z powodu nieobsługiwanego wyjątku lub wcześnie zakończone z powodu anulowania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationAction" /> Argument jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Działanie, aby uruchamiać, gdy <see cref="T:System.Threading.Tasks.Task" /> kończy. Po uruchomieniu delegata zostaną przekazane ukończonego zadania jako argument.</param>
        <param name="cancellationToken">
          <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> , Zostanie przypisany do nowego zadania kontynuacji.</param>
        <summary>Tworzy kontynuację, która odbiera token anulowania i wykonuje asynchronicznie po docelowej <see cref="T:System.Threading.Tasks.Task" /> kończy.</summary>
        <returns>Nowe kontynuacji <see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócony <xref:System.Threading.Tasks.Task> będzie nie być zaplanowane do wykonania, dopóki nie zakończy się bieżące zadanie, czy zostanie zakończona z powodu uruchomionych ukończone pomyślnie, powodujący błąd z powodu nieobsługiwanego wyjątku lub zamykania się wcześniej z powodu anulowania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.CancellationTokenSource" /> Utworzony token został już usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationAction" /> Argument ma wartość null.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task), continuationOptions As TaskContinuationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Akcje zgodnie z określonym <c>continuationOptions</c>. Po uruchomieniu delegata zostaną przekazane ukończonego zadania jako argument.</param>
        <param name="continuationOptions">Opcje kiedy kontynuacja jest zaplanowana i jak działa. Obejmuje to kryteria, takie jak <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, a także opcje wykonywania, takie jak <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <summary>Tworzy kontynuację, który jest wykonywany po zakończeniu zadania docelowego zgodnie z określonym <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</summary>
        <returns>Nowe kontynuacji <see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócony <xref:System.Threading.Tasks.Task> nie zostaną zaplanowane do wykonania, dopóki nie zakończy się bieżącego zadania. Jeśli określone kryteria kontynuacji za pośrednictwem `continuationOptions` parametru nie są spełnione, zostaną anulowane zadanie kontynuacji zamiast zaplanowane.  
  
   
  
## Examples  
 Poniższy przykład demonstruje użycie <xref:System.Threading.Tasks.TaskContinuationOptions> do określenia, czy zadanie kontynuacji powinny być wykonywane synchronicznie po zakończeniu zadania poprzedzającego. (Jeśli określone zadanie zostało już ukończone do czasu <xref:System.Threading.Tasks.Task.ContinueWith%2A> jest wywoływana, synchronicznej kontynuacji będzie uruchamiany na wątku wywołania <xref:System.Threading.Tasks.Task.ContinueWith%2A>.)  
  
```csharp  
  
public class TaskCounter  
{  
   private volatile int _count;  
  
   public void Track(Task t)  
   {  
      if (t == null) throw new ArgumentNullException("t");  
      Interlocked.Increment(ref _count);  
      t.ContinueWith(ct => Interlocked.Decrement(ref _count), TaskContinuationOptions.ExecuteSynchronously);  
   }  
  
   public int NumberOfActiveTasks { get { return _count; } }  
}  
  
```  
  
```vb  
  
Public Class TaskCounter  
   Private _count as Integer  
  
   Public Sub Track(ByVal t as Task)  
      If t is Nothing Then Throw New ArgumentNullException("t")  
      Interlocked.Increment(_count)  
      t.ContinueWith(Sub(ct)  
                        Interlocked.Decrement(_count)  
                     End Sub,  
                     TaskContinuationOptions.ExecuteSynchronously)  
   End Sub  
  
   Public ReadOnly Property NumberOfActiveTasks As Integer  
      Get  
         Return _count  
      End Get  
   End Property  
End Class  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationAction" /> Argument ma wartość null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="continuationOptions" /> Argument określa nieprawidłową wartość dla <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task), scheduler As TaskScheduler) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task&gt; * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Działanie, aby uruchamiać, gdy <see cref="T:System.Threading.Tasks.Task" /> kończy. Po uruchomieniu delegata zostaną przekazane ukończonego zadania jako argument.</param>
        <param name="scheduler">
          <see cref="T:System.Threading.Tasks.TaskScheduler" /> Do skojarzenia z zadaniem kontynuacji i wykorzystać do jego realizacji.</param>
        <summary>Tworzy kontynuację, która wykonuje asynchronicznie po docelowej <see cref="T:System.Threading.Tasks.Task" /> kończy. Kontynuacja używa określonego harmonogramu.</summary>
        <returns>Nowe kontynuacji <see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócony <xref:System.Threading.Tasks.Task> będzie nie być zaplanowane do wykonania, dopóki nie zakończy się bieżące zadanie, czy zostanie zakończona z powodu uruchomionych ukończone pomyślnie, powodujący błąd z powodu nieobsługiwanego wyjątku lub zamykania się wcześniej z powodu anulowania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> Został usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationAction" /> Argument jest <see langword="null" />.  
  
—lub— 
<paramref name="scheduler" /> Argument ma wartość null.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task, obj&gt; * obj * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Działanie, aby uruchamiać, gdy <see cref="T:System.Threading.Tasks.Task" /> kończy. Po uruchomieniu delegata zostaną przekazane ukończonego zadania i obiektu stanu dostarczonych przez obiekt wywołujący, jako argumenty.</param>
        <param name="state">Obiekt reprezentujący dane do użycia przez akcję kontynuacji.</param>
        <param name="cancellationToken">
          <see cref="T:System.Threading.CancellationToken" /> , Zostanie przypisany do nowego zadania kontynuacji.</param>
        <summary>Tworzy kontynuację, która otrzymuje informacje o stanie dostarczonych przez obiekt wywołujący i token anulowania, i który jest wykonywany asynchronicznie po docelowej <see cref="T:System.Threading.Tasks.Task" /> kończy.</summary>
        <returns>Nowe kontynuacji <see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócony <xref:System.Threading.Tasks.Task> będzie nie być zaplanowane do wykonania, dopóki nie zakończy się bieżące zadanie, czy zostanie zakończona z powodu uruchomionych ukończone pomyślnie, powodujący błąd z powodu nieobsługiwanego wyjątku lub zamykania się wcześniej z powodu anulowania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationAction" /> Argument jest <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Podany <see cref="T:System.Threading.CancellationToken" /> został już usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task, Object), state As Object, continuationOptions As TaskContinuationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task, obj&gt; * obj * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Działanie, aby uruchamiać, gdy <see cref="T:System.Threading.Tasks.Task" /> kończy. Po uruchomieniu delegata zostaną przekazane ukończonego zadania i obiektu stanu dostarczonych przez obiekt wywołujący, jako argumenty.</param>
        <param name="state">Obiekt reprezentujący dane do użycia przez akcję kontynuacji.</param>
        <param name="continuationOptions">Opcje kiedy kontynuacja jest zaplanowana i jak działa. Obejmuje to kryteria, takie jak <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, a także opcje wykonywania, takie jak <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <summary>Tworzy kontynuację, która otrzymuje informacje o stanie dostarczonych przez obiekt wywołujący i wykonuje, gdy element docelowy <see cref="T:System.Threading.Tasks.Task" /> kończy. Kontynuacja wykonuje na podstawie zestawu określone warunki.</summary>
        <returns>Nowe kontynuacji <see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócony <xref:System.Threading.Tasks.Task> nie zostaną zaplanowane do wykonania, dopóki nie zakończy się bieżącego zadania. Jeśli określone kryteria kontynuacji za pośrednictwem `continuationOptions` parametru nie są spełnione, zostaną anulowane zadanie kontynuacji zamiast zaplanowane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationAction" /> Argument jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="continuationOptions" /> Argument określa nieprawidłową wartość dla <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task, Object), state As Object, scheduler As TaskScheduler) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task, obj&gt; * obj * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Działanie, aby uruchamiać, gdy <see cref="T:System.Threading.Tasks.Task" /> kończy.  Po uruchomieniu delegata zostaną przekazane ukończonego zadania i obiektu stanu dostarczonych przez obiekt wywołujący, jako argumenty.</param>
        <param name="state">Obiekt reprezentujący dane do użycia przez akcję kontynuacji.</param>
        <param name="scheduler">
          <see cref="T:System.Threading.Tasks.TaskScheduler" /> Do skojarzenia z zadaniem kontynuacji i wykorzystać do jego realizacji.</param>
        <summary>Tworzy kontynuację, która otrzymuje informacje o stanie dostarczonych przez obiekt wywołujący i wykonuje asynchronicznie po docelowej <see cref="T:System.Threading.Tasks.Task" /> kończy. Kontynuacja używa określonego harmonogramu.</summary>
        <returns>Nowe kontynuacji <see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócony <xref:System.Threading.Tasks.Task> będzie nie być zaplanowane do wykonania, dopóki nie zakończy się bieżące zadanie, czy zostanie zakończona z powodu uruchomionych ukończone pomyślnie, powodujący błąd z powodu nieobsługiwanego wyjątku lub zamykania się wcześniej z powodu anulowania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="scheduler" /> Argument jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Akcje zgodnie z określonym <c>continuationOptions</c>. Po uruchomieniu delegata zostaną przekazane ukończonego zadania jako argument.</param>
        <param name="cancellationToken">
          <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> , Zostanie przypisany do nowego zadania kontynuacji.</param>
        <param name="continuationOptions">Opcje kiedy kontynuacja jest zaplanowana i jak działa. Obejmuje to kryteria, takie jak <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, a także opcje wykonywania, takie jak <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <param name="scheduler">
          <see cref="T:System.Threading.Tasks.TaskScheduler" /> Do skojarzenia z zadaniem kontynuacji i wykorzystać do jego realizacji.</param>
        <summary>Tworzy kontynuację, która wykonuje, gdy zadanie docelowe konkuruje zgodnie z określonym <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />. Kontynuacja odbiera token anulowania i używa określonego harmonogramu.</summary>
        <returns>Nowe kontynuacji <see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócony <xref:System.Threading.Tasks.Task> nie zostaną zaplanowane do wykonania, dopóki nie zakończy się bieżącego zadania. Jeśli kryteria określone przez `continuationOptions` parametru nie są spełnione, zostaną anulowane zadanie kontynuacji zamiast zaplanowane.  
  
   
  
## Examples  
 Oto przykład użycia ContinueWith można pracować zarówno w tle, jak i użytkownik wątki interfejsu.  
  
```csharp  
  
private void Button1_Click(object sender, EventArgs e)  
{  
   var backgroundScheduler = TaskScheduler.Default;  
   var uiScheduler = TaskScheduler.FromCurrentSynchronizationContext();  
   Task.Factory.StartNew(delegate { DoBackgroundComputation(); },  
                         backgroundScheduler).  
   ContinueWith(delegate { UpdateUI(); }, uiScheduler).  
                ContinueWith(delegate { DoAnotherBackgroundComputation(); },  
                             backgroundScheduler).  
                ContinueWith(delegate { UpdateUIAgain(); }, uiScheduler);  
}  
  
```  
  
```vb  
  
Private Sub Button1_Click(ByVal sender As System.Object,   
                          ByVal e As System.EventArgs) Handles Button1.Click  
   Dim backgroundScheduler = TaskScheduler.Default  
   Dim uiScheduler = TaskScheduler.FromCurrentSynchronizationContext()  
  
   Task.Factory.StartNew(Sub()  
                           DoBackgroundComputation()  
                         End Sub, backgroundScheduler).ContinueWith(Sub(t)  
                            UpdateUI()  
                         End Sub, uiScheduler).ContinueWith(Sub(t)  
                            DoAnotherBackgroundComputation()  
                         End Sub, backgroundScheduler).ContinueWith(Sub(t)  
                            UpdateUIAgain()  
                         End Sub, uiScheduler)  
End Sub  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.CancellationTokenSource" /> Utworzony token został już usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationAction" /> Argument ma wartość null.  
  
—lub— 
<paramref name="scheduler" /> Argument ma wartość null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="continuationOptions" /> Argument określa nieprawidłową wartość dla <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task, obj&gt; * obj * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Działanie, aby uruchamiać, gdy <see cref="T:System.Threading.Tasks.Task" /> kończy. Po uruchomieniu delegata zostaną przekazane ukończonego zadania i obiektu stanu dostarczonych przez obiekt wywołujący, jako argumenty.</param>
        <param name="state">Obiekt reprezentujący dane do użycia przez akcję kontynuacji.</param>
        <param name="cancellationToken">
          <see cref="T:System.Threading.CancellationToken" /> , Zostanie przypisany do nowego zadania kontynuacji.</param>
        <param name="continuationOptions">Opcje kiedy kontynuacja jest zaplanowana i jak działa. Obejmuje to kryteria, takie jak <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, a także opcje wykonywania, takie jak <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <param name="scheduler">
          <see cref="T:System.Threading.Tasks.TaskScheduler" /> Do skojarzenia z zadaniem kontynuacji i wykorzystać do jego realizacji.</param>
        <summary>Tworzy kontynuację, która otrzymuje informacje o stanie dostarczonych przez obiekt wywołujący i token anulowania, i który wykonuje, gdy element docelowy <see cref="T:System.Threading.Tasks.Task" /> kończy. Kontynuacja wykonuje na podstawie zestawu określone warunki i używa określonego harmonogramu.</summary>
        <returns>Nowe kontynuacji <see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócony <xref:System.Threading.Tasks.Task> nie zostaną zaplanowane do wykonania, dopóki nie zakończy się bieżącego zadania. Jeśli kryteria określone przez `continuationOptions` parametru nie są spełnione, zostaną anulowane zadanie kontynuacji zamiast zaplanowane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="scheduler" /> Argument jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="continuationOptions" /> Argument określa nieprawidłową wartość dla <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Podany <see cref="T:System.Threading.CancellationToken" /> został już usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, TResult)) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, 'Result&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith continuationFunction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ wyniku, generowane przez kontynuacja.</typeparam>
        <param name="continuationFunction">Funkcję, aby uruchamiać, gdy <see cref="T:System.Threading.Tasks.Task`1" /> kończy. Po uruchomieniu delegata zostaną przekazane ukończonego zadania jako argument.</param>
        <summary>Tworzy kontynuację, która wykonuje asynchronicznie po docelowej <see cref="T:System.Threading.Tasks.Task`1" /> kończy i zwraca wartość.</summary>
        <returns>Nowe zadanie kontynuacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócony <xref:System.Threading.Tasks.Task%601> będzie nie być zaplanowane do wykonania, dopóki nie zakończy się bieżące zadanie, czy zostanie zakończona z powodu uruchomionych ukończone pomyślnie, powodujący błąd z powodu nieobsługiwanego wyjątku lub zamykania się wcześniej z powodu anulowania.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak użyć tej metody ContinueWith:  
  
 [!code-csharp[System.Threading.Tasks.Task#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/continuationsimple.cs#03)]
 [!code-vb[System.Threading.Tasks.Task#03](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/continuationsimple.vb#03)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> Został usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationFunction" /> Argument ma wartość null.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, Object, TResult), state As Object) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, obj, 'Result&gt; * obj -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ wyniku, generowane przez kontynuacja.</typeparam>
        <param name="continuationFunction">Funkcję, aby uruchamiać, gdy <see cref="T:System.Threading.Tasks.Task" /> kończy. Po uruchomieniu delegata zostaną przekazane ukończonego zadania i obiektu stanu dostarczonych przez obiekt wywołujący, jako argumenty.</param>
        <param name="state">Obiekt reprezentujący dane do użycia przez funkcję kontynuacji.</param>
        <summary>Tworzy kontynuację, która otrzymuje informacje o stanie dostarczonych przez obiekt wywołujący i wykonuje asynchronicznie po docelowej <see cref="T:System.Threading.Tasks.Task" /> kończy i zwraca wartość.</summary>
        <returns>Nowe kontynuacji <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócony <xref:System.Threading.Tasks.Task%601> będzie nie być zaplanowane do wykonania, dopóki nie zakończy się bieżące zadanie, czy zostanie zakończona z powodu uruchomionych ukończone pomyślnie, powodujący błąd z powodu nieobsługiwanego wyjątku lub zamykania się wcześniej z powodu anulowania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationFunction" /> Argument jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, 'Result&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ wyniku, generowane przez kontynuacja.</typeparam>
        <param name="continuationFunction">Funkcję, aby uruchamiać, gdy <see cref="T:System.Threading.Tasks.Task" /> kończy. Po uruchomieniu delegata zostaną przekazane ukończonego zadania jako argument.</param>
        <param name="cancellationToken">
          <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> , Zostanie przypisany do nowego zadania kontynuacji.</param>
        <summary>Tworzy kontynuację, która wykonuje asynchronicznie po docelowej <see cref="T:System.Threading.Tasks.Task" /> kończy i zwraca wartość. Kontynuacja odbiera token anulowania.</summary>
        <returns>Nowe kontynuacji <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócony <xref:System.Threading.Tasks.Task%601> będzie nie być zaplanowane do wykonania, dopóki nie zakończy się bieżące zadanie, czy zostanie zakończona z powodu uruchomionych ukończone pomyślnie, powodujący błąd z powodu nieobsługiwanego wyjątku lub zamykania się wcześniej z powodu anulowania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> Został usunięty.  
  
—lub— 
<see cref="T:System.Threading.CancellationTokenSource" /> Utworzony token został już usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationFunction" /> Argument ma wartość null.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, TResult), continuationOptions As TaskContinuationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, 'Result&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ wyniku, generowane przez kontynuacja.</typeparam>
        <param name="continuationFunction">Funkcja do uruchomienia zgodnie z warunek określony w <c>continuationOptions</c>. Po uruchomieniu delegata zostaną przekazane ukończonego zadania jako argument.</param>
        <param name="continuationOptions">Opcje kiedy kontynuacja jest zaplanowana i jak działa. Obejmuje to kryteria, takie jak <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, a także opcje wykonywania, takie jak <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <summary>Tworzy kontynuację, która jest wykonywana zgodnie z opcjami kontynuacji określonego i zwraca wartość.</summary>
        <returns>Nowe kontynuacji <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócony <xref:System.Threading.Tasks.Task%601> nie zostaną zaplanowane do wykonania, dopóki nie zakończy się bieżącego zadania. Jeśli określone kryteria kontynuacji za pośrednictwem `continuationOptions` parametru nie są spełnione, zostaną anulowane zadanie kontynuacji zamiast zaplanowane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> Został usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationFunction" /> Argument ma wartość null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="continuationOptions" /> Argument określa nieprawidłową wartość dla <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, TResult), scheduler As TaskScheduler) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, 'Result&gt; * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ wyniku, generowane przez kontynuacja.</typeparam>
        <param name="continuationFunction">Funkcję, aby uruchamiać, gdy <see cref="T:System.Threading.Tasks.Task" /> kończy. Po uruchomieniu delegata zostaną przekazane ukończonego zadania jako argument.</param>
        <param name="scheduler">
          <see cref="T:System.Threading.Tasks.TaskScheduler" /> Do skojarzenia z zadaniem kontynuacji i wykorzystać do jego realizacji.</param>
        <summary>Tworzy kontynuację, która wykonuje asynchronicznie po docelowej <see cref="T:System.Threading.Tasks.Task" /> kończy i zwraca wartość. Kontynuacja używa określonego harmonogramu.</summary>
        <returns>Nowe kontynuacji <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócony <xref:System.Threading.Tasks.Task%601> będzie nie być zaplanowane do wykonania, dopóki nie zakończy się bieżące zadanie, czy zostanie zakończona z powodu uruchomionych ukończone pomyślnie, powodujący błąd z powodu nieobsługiwanego wyjątku lub zamykania się wcześniej z powodu anulowania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> Został usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationFunction" /> Argument ma wartość null.  
  
—lub— 
<paramref name="scheduler" /> Argument ma wartość null.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, obj, 'Result&gt; * obj * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, state, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ wyniku, generowane przez kontynuacja.</typeparam>
        <param name="continuationFunction">Funkcję, aby uruchamiać, gdy <see cref="T:System.Threading.Tasks.Task" /> kończy. Po uruchomieniu delegata zostaną przekazane ukończonego zadania i obiektu stanu dostarczonych przez obiekt wywołujący, jako argumenty.</param>
        <param name="state">Obiekt reprezentujący dane do użycia przez funkcję kontynuacji.</param>
        <param name="cancellationToken">
          <see cref="T:System.Threading.CancellationToken" /> , Zostanie przypisany do nowego zadania kontynuacji.</param>
        <summary>Tworzy kontynuację, która wykonuje asynchronicznie po docelowej <see cref="T:System.Threading.Tasks.Task" /> kończy i zwraca wartość. Kontynuacja otrzymuje informacje o stanie dostarczonych przez obiekt wywołujący i token anulowania.</summary>
        <returns>Nowe kontynuacji <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócony <xref:System.Threading.Tasks.Task%601> będzie nie być zaplanowane do wykonania, dopóki nie zakończy się bieżące zadanie, czy zostanie zakończona z powodu uruchomionych ukończone pomyślnie, powodujący błąd z powodu nieobsługiwanego wyjątku lub zamykania się wcześniej z powodu anulowania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationFunction" /> Argument jest <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Podany <see cref="T:System.Threading.CancellationToken" /> został już usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, Object, TResult), state As Object, continuationOptions As TaskContinuationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, obj, 'Result&gt; * obj * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, state, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ wyniku, generowane przez kontynuacja.</typeparam>
        <param name="continuationFunction">Funkcję, aby uruchamiać, gdy <see cref="T:System.Threading.Tasks.Task" /> kończy. Po uruchomieniu delegata zostaną przekazane ukończonego zadania i obiektu stanu dostarczonych przez obiekt wywołujący, jako argumenty.</param>
        <param name="state">Obiekt reprezentujący dane do użycia przez funkcję kontynuacji.</param>
        <param name="continuationOptions">Opcje kiedy kontynuacja jest zaplanowana i jak działa. Obejmuje to kryteria, takie jak <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, a także opcje wykonywania, takie jak <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <summary>Tworzy kontynuację, która jest wykonywana na podstawie kontynuacji opcji, gdy element docelowy <see cref="T:System.Threading.Tasks.Task" /> kończy. Kontynuacja otrzymuje informacje o stanie dostarczonych przez obiekt wywołujący.</summary>
        <returns>Nowe kontynuacji <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócony <xref:System.Threading.Tasks.Task%601> nie zostaną zaplanowane do wykonania, dopóki nie zakończy się bieżącego zadania. Jeśli określone kryteria kontynuacji za pośrednictwem `continuationOptions` parametru nie są spełnione, zostaną anulowane zadanie kontynuacji zamiast zaplanowane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationFunction" /> Argument jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="continuationOptions" /> Argument określa nieprawidłową wartość dla <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, Object, TResult), state As Object, scheduler As TaskScheduler) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, obj, 'Result&gt; * obj * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, state, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ wyniku, generowane przez kontynuacja.</typeparam>
        <param name="continuationFunction">Funkcję, aby uruchamiać, gdy <see cref="T:System.Threading.Tasks.Task" /> kończy.  Po uruchomieniu delegata zostaną przekazane ukończonego zadania i obiektu stanu dostarczonych przez obiekt wywołujący, jako argumenty.</param>
        <param name="state">Obiekt reprezentujący dane do użycia przez funkcję kontynuacji.</param>
        <param name="scheduler">
          <see cref="T:System.Threading.Tasks.TaskScheduler" /> Do skojarzenia z zadaniem kontynuacji i wykorzystać do jego realizacji.</param>
        <summary>Tworzy kontynuację, która wykonuje asynchronicznie po docelowej <see cref="T:System.Threading.Tasks.Task" /> kończy. Kontynuacja otrzymuje informacje o stanie dostarczonych przez obiekt wywołujący i używa określonego harmonogramu.</summary>
        <returns>Nowe kontynuacji <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócony <xref:System.Threading.Tasks.Task%601> będzie nie być zaplanowane do wykonania, dopóki nie zakończy się bieżące zadanie, czy zostanie zakończona z powodu uruchomionych ukończone pomyślnie, powodujący błąd z powodu nieobsługiwanego wyjątku lub zamykania się wcześniej z powodu anulowania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="scheduler" /> Argument jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, 'Result&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ wyniku, generowane przez kontynuacja.</typeparam>
        <param name="continuationFunction">Funkcja do uruchomienia zgodnie z określonym <c>continuationOptions.</c> Po uruchomieniu delegata zostaną przekazane ukończonego zadania jako argument.</param>
        <param name="cancellationToken">
          <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> , Zostanie przypisany do nowego zadania kontynuacji.</param>
        <param name="continuationOptions">Opcje kiedy kontynuacja jest zaplanowana i jak działa. Obejmuje to kryteria, takie jak <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, a także opcje wykonywania, takie jak <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <param name="scheduler">
          <see cref="T:System.Threading.Tasks.TaskScheduler" /> Do skojarzenia z zadaniem kontynuacji i wykorzystać do jego realizacji.</param>
        <summary>Tworzy kontynuację, która jest wykonywana zgodnie z opcjami kontynuacji określonego i zwraca wartość. Kontynuacja przechodzi przez token anulowania i używa określonego harmonogramu.</summary>
        <returns>Nowe kontynuacji <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócony <xref:System.Threading.Tasks.Task%601> nie zostaną zaplanowane do wykonania, dopóki nie zakończy się bieżącego zadania. Jeśli kryteria określone przez `continuationOptions` parametru nie są spełnione, zostaną anulowane zadanie kontynuacji zamiast zaplanowane.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak przy użyciu metody ContinueWith kontynuacji opcji:  
  
 [!code-csharp[System.Threading.Tasks.Task#04](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/continuationoptions.cs#04)]
 [!code-vb[System.Threading.Tasks.Task#04](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/continuationoptions.vb#04)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> Został usunięty.  
  
—lub— 
<see cref="T:System.Threading.CancellationTokenSource" /> Utworzony token został już usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationFunction" /> Argument ma wartość null.  
  
—lub— 
<paramref name="scheduler" /> Argument ma wartość null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="continuationOptions" /> Argument określa nieprawidłową wartość dla <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, obj, 'Result&gt; * obj * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, state, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ wyniku, generowane przez kontynuacja.</typeparam>
        <param name="continuationFunction">Funkcję, aby uruchamiać, gdy <see cref="T:System.Threading.Tasks.Task" /> kończy. Po uruchomieniu delegata zostaną przekazane ukończonego zadania i obiektu stanu dostarczonych przez obiekt wywołujący, jako argumenty.</param>
        <param name="state">Obiekt reprezentujący dane do użycia przez funkcję kontynuacji.</param>
        <param name="cancellationToken">
          <see cref="T:System.Threading.CancellationToken" /> , Zostanie przypisany do nowego zadania kontynuacji.</param>
        <param name="continuationOptions">Opcje kiedy kontynuacja jest zaplanowana i jak działa. Obejmuje to kryteria, takie jak <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, a także opcje wykonywania, takie jak <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <param name="scheduler">
          <see cref="T:System.Threading.Tasks.TaskScheduler" /> Do skojarzenia z zadaniem kontynuacji i wykorzystać do jego realizacji.</param>
        <summary>Tworzy kontynuację, która jest wykonywana na podstawie kontynuacji opcji, gdy element docelowy <see cref="T:System.Threading.Tasks.Task" /> kończy i zwraca wartość. Kontynuacja otrzymuje informacje o stanie dostarczonych przez obiekt wywołujący i token anulowania i używa określonego harmonogramu.</summary>
        <returns>Nowe kontynuacji <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócony <xref:System.Threading.Tasks.Task%601> nie zostaną zaplanowane do wykonania, dopóki nie zakończy się bieżącego zadania. Jeśli kryteria określone przez `continuationOptions` parametru nie są spełnione, zostaną anulowane zadanie kontynuacji zamiast zaplanowane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="scheduler" /> Argument jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="continuationOptions" /> Argument określa nieprawidłową wartość dla <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Podany <see cref="T:System.Threading.CancellationToken" /> został już usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreationOptions">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.TaskCreationOptions CreationOptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.Tasks.TaskCreationOptions CreationOptions" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.CreationOptions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CreationOptions As TaskCreationOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::TaskCreationOptions CreationOptions { System::Threading::Tasks::TaskCreationOptions get(); };" />
      <MemberSignature Language="F#" Value="member this.CreationOptions : System.Threading.Tasks.TaskCreationOptions" Usage="System.Threading.Tasks.Task.CreationOptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskCreationOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> użyty do utworzenia tego zadania.</summary>
        <value>
          <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> Użyty do utworzenia tego zadania.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentId">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; CurrentId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Nullable`1&lt;int32&gt; CurrentId" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.CurrentId" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentId As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Nullable&lt;int&gt; CurrentId { Nullable&lt;int&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentId : Nullable&lt;int&gt;" Usage="System.Threading.Tasks.Task.CurrentId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zwraca identyfikator aktualnie wykonywanych <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <value>Liczba całkowita, która została przypisana przez system aktualnie wykonywanych zadań.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.CurrentId%2A> jest `static` (`Shared` w języku Visual Basic) właściwość, która jest używana do pobierania identyfikator aktualnie wykonywane zadanie z kodu, który wykonuje zadania. Różni się od <xref:System.Threading.Tasks.Task.Id%2A> właściwość, która zwraca identyfikator określonego <xref:System.Threading.Tasks.Task> wystąpienia. Jeśli użytkownik podejmie próbę pobrania <xref:System.Threading.Tasks.Task.CurrentId%2A> wartości z poza kodem, który wykonuje zadania, właściwość ta zwraca `null`.  
  
 Należy pamiętać, że chociaż konflikty występują bardzo rzadko, identyfikatory zadań są nie musi być unikatowy.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Threading.Tasks.Task.Id" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Delay">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy zadanie, które zostanie ukończone z pewnym opóźnieniem.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (int millisecondsDelay);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(int32 millisecondsDelay) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Delay (millisecondsDelay As Integer) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Delay(int millisecondsDelay);" />
      <MemberSignature Language="F#" Value="static member Delay : int -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Delay millisecondsDelay" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsDelay" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsDelay">Liczba milisekund oczekiwania przed ukończeniem zwracanego zadania lub -1, aby czekać w nieskończoność.</param>
        <summary>Tworzy zadanie, które kończy się po określonej liczbie milisekund.</summary>
        <returns>Zadanie, które reprezentuje czas opóźnienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Delay%2A> Metoda jest zwykle używana do opóźnienia, zanim wszystkie działania lub części zadania określonym przedziale czasu. Najczęściej wprowadza się czas opóźnienia:  
  
-   Co zawiera początek danego zadania, w poniższym przykładzie.  
  
     [!code-csharp[System.Threading.Tasks.Task.Delay#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay5.cs#5)]
     [!code-vb[System.Threading.Tasks.Task.Delay#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay5.vb#5)]  
  
-   Później, gdy zadanie jest wykonywane. W tym przypadku wywołanie <xref:System.Threading.Tasks.Task.Delay%2A> metoda jest wykonywana jako zadania podrzędne w zadaniu, co ilustruje poniższy przykład. Należy pamiętać, że od zadania, wywołuje <xref:System.Threading.Tasks.Task.Delay%2A> metoda jest wykonywana asynchronicznie, zadanie nadrzędne musi czekać na jego zakończenie przy użyciu `await` — słowo kluczowe.  
  
     [!code-csharp[System.Threading.Tasks.Task.Delay#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay5.cs#7)]
     [!code-vb[System.Threading.Tasks.Task.Delay#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay5.vb#7)]  
  
 Po upływie określonego czasu opóźnienia, zadanie zostało ukończone w <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> stanu.  
  
 Ta metoda zależy od zegara systemowego. Oznacza to, że czas opóźnienia około będzie równa rozdzielczości zegara systemowego, jeśli `millisecondsDelay` argument jest mniejszy od rozdzielczości zegara systemowego, czyli około 15 milisekund w systemach Windows.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie prostego <xref:System.Threading.Tasks.Task.Delay%2A> metody.  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Delay#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsDelay" /> Argument jest mniejsza niż -1.</exception>
      </Docs>
    </Member>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (TimeSpan delay);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(valuetype System.TimeSpan delay) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Delay (delay As TimeSpan) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Delay(TimeSpan delay);" />
      <MemberSignature Language="F#" Value="static member Delay : TimeSpan -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Delay delay" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delay" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="delay">Przedział czasu oczekiwania przed ukończeniem zwracanego zadania lub <see langword="TimeSpan.FromMilliseconds(-1)" /> czekanie w nieskończoność.</param>
        <summary>Tworzy zadanie, które kończy się po określonym interwale czasu.</summary>
        <returns>Zadanie, które reprezentuje czas opóźnienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po upływie określonego czasu opóźnienia, zadanie zostało ukończone w <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> stanu.  
  
 Przykłady użycia scenariuszy oraz dodatkowe przykłady, zobacz dokumentację dla <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> przeciążenia.  
  
 Ta metoda zależy od zegara systemowego. Oznacza to, że czas opóźnienia około będzie równa rozdzielczości zegara systemowego, jeśli `delay` argument jest mniejszy od rozdzielczości zegara systemowego, czyli około 15 milisekund w systemach Windows.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie prostego <xref:System.Threading.Tasks.Task.Delay%2A> metody.  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay2.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.Delay#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="delay" /> reprezentuje ujemny przedział czasu, inne niż <see langword="TimeSpan.FromMillseconds(-1)" />.  
  
—lub— 
<paramref name="delay" /> Argumentu <see cref="P:System.TimeSpan.TotalMilliseconds" /> właściwości jest większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (int millisecondsDelay, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(int32 millisecondsDelay, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Delay(int millisecondsDelay, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Delay : int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Delay (millisecondsDelay, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsDelay" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="millisecondsDelay">Liczba milisekund oczekiwania przed ukończeniem zwracanego zadania lub -1, aby czekać w nieskończoność.</param>
        <param name="cancellationToken">Token anulowania do obserwowania podczas oczekiwania na zakończenie zadania.</param>
        <summary>Tworzy zadanie można anulować, które kończy się po określonej liczbie milisekund.</summary>
        <returns>Zadanie, które reprezentuje czas opóźnienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli token anulowania jest sygnalizowane przed określony czas opóźnienia, <xref:System.Threading.Tasks.TaskCanceledException> wynikiem będzie wyjątek, a zadanie jest wykonywane w <xref:System.Threading.Tasks.TaskStatus.Canceled> stanu.  W przeciwnym razie zadanie zostało ukończone w <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> stanu po upłynie określony czas opóźnienia.  
  
 Przykłady użycia scenariuszy oraz dodatkowe przykłady, zobacz dokumentację dla <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> przeciążenia.  
  
 Ta metoda zależy od zegara systemowego. Oznacza to, że czas opóźnienia około będzie równa rozdzielczości zegara systemowego, jeśli `millisecondsDelay` argument jest mniejszy od rozdzielczości zegara systemowego, czyli około 15 milisekund w systemach Windows.  
  
   
  
## Examples  
 Poniższy przykład uruchamia zadanie, które zawiera wywołanie <xref:System.Threading.Tasks.Task.Delay%28System.Int32%2CSystem.Threading.CancellationToken%29> metody za pomocą jednego półsekundowym opóźnieniu. Token została anulowana, zanim czasu opóźnienia. Dane wyjściowe z przykładu wskazują, że w wyniku, <xref:System.Threading.Tasks.TaskCanceledException> jest generowany i zadań <xref:System.Threading.Tasks.Task.Status%2A> właściwość jest ustawiona na <xref:System.Threading.Tasks.TaskStatus.Canceled>.  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.Delay#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsDelay" /> Argument jest mniejsza niż -1.</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">Zadanie zostało anulowane.</exception>
        <exception cref="T:System.ObjectDisposedException">Podany <paramref name="cancellationToken" /> został już usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (TimeSpan delay, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(valuetype System.TimeSpan delay, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Delay(TimeSpan delay, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Delay : TimeSpan * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Delay (delay, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delay" Type="System.TimeSpan" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="delay">Przedział czasu oczekiwania przed ukończeniem zwracanego zadania lub <see langword="TimeSpan.FromMilliseconds(-1)" /> czekanie w nieskończoność.</param>
        <param name="cancellationToken">Token anulowania do obserwowania podczas oczekiwania na zakończenie zadania.</param>
        <summary>Tworzy zadanie można anulować, które kończy się po określonym interwale czasu.</summary>
        <returns>Zadanie, które reprezentuje czas opóźnienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli token anulowania jest sygnalizowane przed określony czas opóźnienia, <xref:System.Threading.Tasks.TaskCanceledException> wynikiem będzie wyjątek, a zadanie jest wykonywane w <xref:System.Threading.Tasks.TaskStatus.Canceled> stanu.  W przeciwnym razie zadanie zostało ukończone w <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> stanu po upłynie określony czas opóźnienia.  
  
 Przykłady użycia scenariuszy oraz dodatkowe przykłady, zobacz dokumentację dla <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> przeciążenia.  
  
 Ta metoda zależy od zegara systemowego. Oznacza to, że czas opóźnienia około będzie równa rozdzielczości zegara systemowego, jeśli `delay` argument jest mniejszy od rozdzielczości zegara systemowego, czyli około 15 milisekund w systemach Windows.  
  
   
  
## Examples  
 Poniższy przykład uruchamia zadanie, które zawiera wywołanie <xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29> metody z 1,5 półsekundowym opóźnieniu. Token została anulowana, zanim czasu opóźnienia. Dane wyjściowe z przykładu wskazują, że w wyniku, <xref:System.Threading.Tasks.TaskCanceledException> jest generowany i zadań <xref:System.Threading.Tasks.Task.Status%2A> właściwość jest ustawiona na <xref:System.Threading.Tasks.TaskStatus.Canceled>.  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.Delay#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay4.vb#4)]  
  
 Należy pamiętać, że w tym przykładzie zawiera potencjalnych sytuacji wyścigu: zależy od zadania asynchroniczne wykonywanie opóźnienie po anulowaniu tokenu. Mimo że 1,5 sekund opóźnienia z wywołania <xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29> metody sprawia, że założono, że jest prawdopodobne, niemniej jednak możliwe jest, wywołanie <xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29> metoda może zwrócić przed tokenem zostało anulowane. W takim przypadku przykład generuje następujące wyniki:  
  
```  
Task t Status: RanToCompletion, Result: 42  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="delay" /> reprezentuje ujemny przedział czasu, inne niż <see langword="TimeSpan.FromMillseconds(-1)" />.  
  
—lub— 
<paramref name="delay" /> Argumentu <see cref="P:System.TimeSpan.TotalMilliseconds" /> właściwości jest większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">Zadanie zostało anulowane.</exception>
        <exception cref="T:System.ObjectDisposedException">Podany <paramref name="cancellationToken" /> został już usunięty.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwalnia wszelkie zasoby używane przez bieżące wystąpienie <see cref="T:System.Threading.Tasks.Task" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="task.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszelkie zasoby używane przez bieżące wystąpienie <see cref="T:System.Threading.Tasks.Task" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task> Klasy implementuje <xref:System.IDisposable> interfejsu, ponieważ wewnętrznie używa zasobów, które implementują także <xref:System.IDisposable>. Jednak zwłaszcza gdy aplikacji jest przeznaczony dla [!INCLUDE[net_v45](~/includes/net-v45-md.md)] lub nowszym, nie trzeba wywoływac <xref:System.Threading.Tasks.Task.Dispose%2A> chyba, że wydajność i skalowalność testowanie wskazuje, że, oparty na Twoich wzorców użycia, wydajność Twojej aplikacji będzie można poprawić, usuwanie zadania. Aby uzyskać więcej informacji, zobacz [należy dysponować zadań?](http://blogs.msdn.com/b/pfxteam/archive/2012/03/25/10287435.aspx) w Programowanie równoległe z bloga platformy .NET.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Zadanie nie jest w jednym z ostatnim stanów: <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" />, <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" />, lub <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="task.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Wartość logiczna, która wskazuje, czy ta metoda jest wywoływana ze względu na wywołanie w celu <see cref="M:System.Threading.Tasks.Task.Dispose" />.</param>
        <summary>Usuwa <see cref="T:System.Threading.Tasks.Task" />, zwalniając wszystkich jej zasobów niezarządzanych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task> Klasy implementuje <xref:System.IDisposable> interfejsu, ponieważ wewnętrznie używa zasobów, które implementują także <xref:System.IDisposable>. Jednak zwłaszcza gdy aplikacji jest przeznaczony dla [!INCLUDE[net_v45](~/includes/net-v45-md.md)] lub nowszym, nie trzeba wywoływac <xref:System.Threading.Tasks.Task.Dispose%2A> chyba, że wydajność i skalowalność testowanie wskazuje, że, oparty na Twoich wzorców użycia, wydajność Twojej aplikacji będzie można poprawić, usuwanie zadania. Aby uzyskać więcej informacji, zobacz [należy dysponować zadań?](http://blogs.msdn.com/b/pfxteam/archive/2012/03/25/10287435.aspx) w Programowanie równoległe z bloga platformy .NET.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Zadanie nie jest w jednym z ostatnim stanów: <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" />, <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" />, lub <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" />.</exception>
        <threadsafe>W przeciwieństwie do większości elementów członkowskich <see cref="T:System.Threading.Tasks.Task" /> klasy, ta metoda nie jest metodą o bezpiecznych wątkach.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="Exception">
      <MemberSignature Language="C#" Value="public AggregateException Exception { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AggregateException Exception" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Exception" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Exception As AggregateException" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AggregateException ^ Exception { AggregateException ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Exception : AggregateException" Usage="System.Threading.Tasks.Task.Exception" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AggregateException</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.AggregateException" /> powodujący <see cref="T:System.Threading.Tasks.Task" /> przedwczesne zakończenie. Jeśli <see cref="T:System.Threading.Tasks.Task" /> zakończone pomyślnie lub nie jeszcze zgłosił wyjątki, spowoduje to zwrócenie <see langword="null" />.</summary>
        <value>
          <see cref="T:System.AggregateException" /> Powodujący <see cref="T:System.Threading.Tasks.Task" /> przedwczesne zakończenie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zadania, które zgłasza nieobsługiwanych wyjątków przechowywania wynikowy wyjątku oraz Propagacja ona otoczona <xref:System.AggregateException> w wywołaniach <xref:System.Threading.Tasks.Task.Wait%2A> lub dostęp do <xref:System.Threading.Tasks.Task.Exception%2A> właściwości. Wszelkie wyjątki, które nie są przestrzegane przez razem, gdy wystąpienia zadania jest bezużyteczne będą propagowane w wątku finalizatora. Aby uzyskać więcej informacji i obejrzeć przykład, zobacz [Exception Handling (Biblioteka zadań równoległych)](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Factory">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskFactory Factory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskFactory Factory" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Factory" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Factory As TaskFactory" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::TaskFactory ^ Factory { System::Threading::Tasks::TaskFactory ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Factory : System.Threading.Tasks.TaskFactory" Usage="System.Threading.Tasks.Task.Factory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskFactory</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zapewnia dostęp do metod fabryki dla tworzenia i konfigurowania <see cref="T:System.Threading.Tasks.Task" /> i <see cref="T:System.Threading.Tasks.Task`1" /> wystąpień.</summary>
        <value>Obiekt fabryki, które można tworzyć różne <see cref="T:System.Threading.Tasks.Task" /> i <see cref="T:System.Threading.Tasks.Task`1" /> obiektów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zwraca domyślne wystąpienie <xref:System.Threading.Tasks.TaskFactory> klasę, która jest taka sama jak utworzonym przez wywołanie metody bez parametrów <xref:System.Threading.Tasks.TaskFactory.%23ctor?displayProperty=nameWithType> konstruktora. Obowiązują następujące wartości właściwości:  
  
|Właściwość|Wartość|  
|--------------|-----------|  
|<xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A?displayProperty=nameWithType>|<xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType>|  
|<xref:System.Threading.Tasks.TaskFactory.ContinuationOptions%2A?displayProperty=nameWithType>|<xref:System.Threading.Tasks.TaskContinuationOptions.None?displayProperty=nameWithType>|  
|<xref:System.Threading.Tasks.TaskFactory.CreationOptions%2A?displayProperty=nameWithType>|<xref:System.Threading.Tasks.TaskCreationOptions.None?displayProperty=nameWithType>|  
|<xref:System.Threading.Tasks.TaskFactory.Scheduler%2A?displayProperty=nameWithType>|`null`, lub <xref:System.Threading.Tasks.TaskScheduler.Current%2A?displayProperty=nameWithType>|  
  
 Najczęściej używane w tej właściwości jest tworzenie i uruchamianie nowego zadania w jednym wywołaniu <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> metody.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v45](~/includes/net-v45-md.md)], <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> metoda zapewnia Najprostszym sposobem utworzenia <xref:System.Threading.Tasks.Task> obiektu z domyślnych wartości konfiguracji.  
  
 W poniższym przykładzie użyto statycznego <xref:System.Threading.Tasks.Task.Factory%2A> właściwość, aby wykonywać wywołania dwóch <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> metody. Pierwszy wypełnia tablicę z nazwami plików w katalogu Moje dokumenty użytkownika, podczas gdy drugi wypełnia tablicę z nazwami podkatalogi katalogu Moje dokumenty użytkownika. Następnie wywołuje <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%28System.Threading.Tasks.Task%5B%5D%2CSystem.Action%7BSystem.Threading.Tasks.Task%5B%5D%7D%29?displayProperty=nameWithType> metody, która wyświetla informacje o liczbie plików i katalogów w dwóch tablicach, po pierwsze dwa zadania zostaną ukończone.  
  
 [!code-csharp[System.Threading.Tasks.Task.Factory#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.factory/cs/factory1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Factory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.factory/vb/factory1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskFactory" />
      </Docs>
    </Member>
    <Member MemberName="FromCanceled">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task FromCanceled (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task FromCanceled(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromCanceled(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ FromCanceled(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member FromCanceled : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.FromCanceled cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">Token anulowania, za pomocą którego do ukończenia zadania.</param>
        <summary>Tworzy <see cref="T:System.Threading.Tasks.Task" /> ten zostanie zakończony z powodu anulowania z tokenem anulowania określony.</summary>
        <returns>Anulowano zadanie.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Nie zażądano anulowania dla <paramref name="cancellationToken" />; jej <see cref="P:System.Threading.CancellationToken.IsCancellationRequested" /> właściwość <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromCanceled&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; FromCanceled&lt;TResult&gt; (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromCanceled&lt;TResult&gt;(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromCanceled``1(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ FromCanceled(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member FromCanceled : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.FromCanceled cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ wyniku zwracanego przez zadanie.</typeparam>
        <param name="cancellationToken">Token anulowania, za pomocą którego do ukończenia zadania.</param>
        <summary>Tworzy <see cref="T:System.Threading.Tasks.Task`1" /> ten zostanie zakończony z powodu anulowania z tokenem anulowania określony.</summary>
        <returns>Anulowano zadanie.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Nie zażądano anulowania dla <paramref name="cancellationToken" />; jej <see cref="P:System.Threading.CancellationToken.IsCancellationRequested" /> właściwość <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromException">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task FromException (Exception exception);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task FromException(class System.Exception exception) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromException(System.Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ FromException(Exception ^ exception);" />
      <MemberSignature Language="F#" Value="static member FromException : Exception -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.FromException exception" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exception" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="exception">Wyjątek za pomocą którego do ukończenia zadania.</param>
        <summary>Tworzy <see cref="T:System.Threading.Tasks.Task" /> ukończenia przy użyciu określonego wyjątku.</summary>
        <returns>Zadanie błędowi.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda tworzy <xref:System.Threading.Tasks.Task> którego <xref:System.Threading.Tasks.Task.Status%2A> właściwość <xref:System.Threading.Tasks.TaskStatus.Faulted> i którego <xref:System.Threading.Tasks.Task.Exception%2A> właściwość zawiera `exception`. Metoda jest często używane, gdy natychmiast wiadomo, że pracy, który wykonuje zadania spowoduje zgłoszenie wyjątku przed wykonaniem dłuższej ścieżki kodu. Aby uzyskać przykład, zobacz <xref:System.Threading.Tasks.Task.FromException%60%601%28System.Exception%29> przeciążenia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromException&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; FromException&lt;TResult&gt; (Exception exception);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromException&lt;TResult&gt;(class System.Exception exception) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromException``1(System.Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ FromException(Exception ^ exception);" />
      <MemberSignature Language="F#" Value="static member FromException : Exception -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.FromException exception" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="exception" Type="System.Exception" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ wyniku zwracanego przez zadanie.</typeparam>
        <param name="exception">Wyjątek za pomocą którego do ukończenia zadania.</param>
        <summary>Tworzy <see cref="T:System.Threading.Tasks.Task`1" /> , zostało zakończone z określonym wyjątkiem.</summary>
        <returns>Zadanie błędowi.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda tworzy <xref:System.Threading.Tasks.Task%601> którego <xref:System.Threading.Tasks.Task.Status%2A> właściwość <xref:System.Threading.Tasks.TaskStatus.Faulted> i którego <xref:System.Threading.Tasks.Task.Exception%2A> właściwość zawiera `exception`. Metoda jest często używane, gdy natychmiast wiadomo, że pracy, który wykonuje zadania spowoduje zgłoszenie wyjątku przed wykonaniem dłuższej ścieżki kodu. Przykład stanowi ilustrację.  
  
   
  
## Examples  
 Poniższy przykład jest narzędziem wiersza polecenia, który oblicza liczbę bajtów w plikach w każdym katalogu, którego nazwa jest przekazywany jako argument wiersza polecenia. Zamiast wykonywania dłuższej ścieżki kodu, która tworzy wystąpienie <xref:System.IO.FileInfo> obiektu i pobiera wartość jego <xref:System.IO.FileInfo.Length%2A?displayProperty=nameWithType> właściwości dla każdego pliku w katalogu, przykład po prostu wywołuje <xref:System.Threading.Tasks.Task.FromException%60%601%28System.Exception%29> metodę, aby utworzyć zadanie uszkodzoną, jeśli określony podkatalog nie istnieje.  
  
 [!code-csharp[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/cs/fromresult1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/vb/fromresult1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromResult&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; FromResult&lt;TResult&gt; (TResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromResult&lt;TResult&gt;(!!TResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromResult``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromResult(Of TResult) (result As TResult) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ FromResult(TResult result);" />
      <MemberSignature Language="F#" Value="static member FromResult : 'Result -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.FromResult result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="result" Type="TResult" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ wyniku zwracanego przez zadanie.</typeparam>
        <param name="result">Wynik zapisywania w ukończonego zadania.</param>
        <summary>Tworzy <see cref="T:System.Threading.Tasks.Task`1" /> pomyślnie ukończono z wynikiem określonej.</summary>
        <returns>Pomyślnie ukończono zadanie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda tworzy <xref:System.Threading.Tasks.Task%601> którego <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> właściwość `result` i którego <xref:System.Threading.Tasks.Task.Status%2A> właściwość <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>. Metoda jest często używane, gdy znana jest natychmiast wartość zwracaną przez zadanie bez wykonywania dłuższej ścieżki kodu. Przykład stanowi ilustrację.  
  
 Aby utworzyć obiekt zadania, która nie zwraca wartości, należy pobrać obiekt zadania z <xref:System.Threading.Tasks.Task.CompletedTask%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykład jest narzędziem wiersza polecenia, który oblicza liczbę bajtów w plikach w każdym katalogu, którego nazwa jest przekazywany jako argument wiersza polecenia. Zamiast wykonywania dłuższej ścieżki kodu, która tworzy wystąpienie <xref:System.IO.FileStream> obiektu i pobiera wartość jego <xref:System.IO.FileStream.Length%2A?displayProperty=nameWithType> właściwości dla każdego pliku w katalogu, przykład po prostu wywołuje <xref:System.Threading.Tasks.Task.FromResult%2A> metody, aby utworzyć zadanie, którego <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> Właściwość jest zero (0), jeśli w katalogu nie ma żadnych plików.  
  
 [!code-csharp[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/cs/fromresult1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/vb/fromresult1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Threading.Tasks.Task.CompletedTask" />
      </Docs>
    </Member>
    <Member MemberName="GetAwaiter">
      <MemberSignature Language="C#" Value="public System.Runtime.CompilerServices.TaskAwaiter GetAwaiter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Runtime.CompilerServices.TaskAwaiter GetAwaiter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.GetAwaiter" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAwaiter () As TaskAwaiter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::CompilerServices::TaskAwaiter GetAwaiter();" />
      <MemberSignature Language="F#" Value="member this.GetAwaiter : unit -&gt; System.Runtime.CompilerServices.TaskAwaiter" Usage="task.GetAwaiter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.CompilerServices.TaskAwaiter</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera awaiter umożliwia to await <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <returns>Wystąpienie awaiter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest przeznaczona do użytku kompilatora, a nie do użytku w kodzie aplikacji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.Threading.Tasks.Task.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera identyfikator dla tego <see cref="T:System.Threading.Tasks.Task" /> wystąpienia.</summary>
        <value>Identyfikator, który jest przypisany przez system do tego <see cref="T:System.Threading.Tasks.Task" /> wystąpienia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identyfikatory zadań podrzędnych są przypisywane na żądanie i nie musi to oznaczać kolejność, w ramach zadania, które są tworzone wystąpienia. Należy pamiętać, że chociaż konflikty występują bardzo rzadko, identyfikatory zadań są nie musi być unikatowy.  
  
 Aby uzyskać identyfikator zadania aktualnie wykonywane zadanie z kodem, który wykonuje to zadanie, należy użyć <xref:System.Threading.Tasks.Task.CurrentId%2A> właściwości.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Threading.Tasks.Task.CurrentId" />
      </Docs>
    </Member>
    <Member MemberName="IsCanceled">
      <MemberSignature Language="C#" Value="public bool IsCanceled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCanceled" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsCanceled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCanceled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCanceled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCanceled : bool" Usage="System.Threading.Tasks.Task.IsCanceled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera czy to <see cref="T:System.Threading.Tasks.Task" /> wystąpienia zakończyła wykonanie z powodu anulowania.</summary>
        <value>
          <see langword="true" /> Jeśli zadanie zostało ukończone z powodu anulowania; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Threading.Tasks.Task> potrwa <xref:System.Threading.Tasks.TaskStatus.Canceled> stanu w żadnej z następujących warunków:  
  
-   Jego <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> został oznaczony do anulowania, przed rozpoczęciem zadania wykonywania  
  
-   Zadanie potwierdzone żądanie anulowania w jego już sygnałowego <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> zgłaszając <xref:System.OperationCanceledException> , ma taki sam <xref:System.Threading.CancellationToken>.  
  
-   Zadanie potwierdzone żądanie anulowania w jego już sygnałowego <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> przez wywołanie metody <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A> metody <xref:System.Threading.CancellationToken>.  
  
> [!IMPORTANT]
>  Pobieranie wartości <xref:System.Threading.Tasks.Task.IsCanceled%2A> właściwości nie blokuje wątek wywołujący, dopóki zadanie zostało ukończone.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCompleted">
      <MemberSignature Language="C#" Value="public bool IsCompleted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCompleted" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsCompleted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCompleted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCompleted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCompleted : bool" Usage="System.Threading.Tasks.Task.IsCompleted" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.IsCompleted</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera czy to <see cref="T:System.Threading.Tasks.Task" /> zostało zakończone.</summary>
        <value>
          <see langword="true" /> Jeśli zadanie zostało ukończone; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.IsCompleted%2A> zwróci `true` gdy zadanie jest w jednym z trzech stanów końcowego: <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>, <xref:System.Threading.Tasks.TaskStatus.Faulted>, lub <xref:System.Threading.Tasks.TaskStatus.Canceled>.  
  
> [!IMPORTANT]
>  Pobieranie wartości <xref:System.Threading.Tasks.Task.IsCompleted%2A?displayProperty=nameWithType> właściwości nie blokuje wątek wywołujący, dopóki zadanie zostało ukończone.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCompletedSuccessfully">
      <MemberSignature Language="C#" Value="public bool IsCompletedSuccessfully { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCompletedSuccessfully" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsCompletedSuccessfully" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCompletedSuccessfully As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCompletedSuccessfully { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCompletedSuccessfully : bool" Usage="System.Threading.Tasks.Task.IsCompletedSuccessfully" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFaulted">
      <MemberSignature Language="C#" Value="public bool IsFaulted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFaulted" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsFaulted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFaulted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFaulted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFaulted : bool" Usage="System.Threading.Tasks.Task.IsFaulted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera czy <see cref="T:System.Threading.Tasks.Task" /> ukończona z powodu nieobsługiwanego wyjątku.</summary>
        <value>
          <see langword="true" /> Jeśli zadanie zgłosił nieobsługiwany wyjątek; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Threading.Tasks.Task.IsFaulted%2A> jest `true`, zadania podrzędnego <xref:System.Threading.Tasks.Task.Status%2A> jest równa <xref:System.Threading.Tasks.TaskStatus.Faulted>, a jego <xref:System.Threading.Tasks.Task.Exception%2A> właściwość będzie miała inną niż null.  
  
> [!IMPORTANT]
>  Pobieranie wartości <xref:System.Threading.Tasks.Task.IsFaulted%2A?displayProperty=nameWithType> właściwości nie blokuje wątek wywołujący, dopóki zadanie zostało ukończone.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Umieszcza w kolejce określona pracy do uruchomienia w puli wątków i zwraca klasę task, lub <see cref="T:System.Threading.Tasks.Task`1" /> dojścia do pracy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Run%2A> Metoda zawiera zbiór przeciążenia, które ułatwiają uruchomić zadanie przy użyciu wartości domyślnych. Jest to uproszczone alternatywa dla <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> przeciążenia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Action action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Action action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Action)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Run(Action ^ action);" />
      <MemberSignature Language="F#" Value="static member Run : Action -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Run action" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
      </Parameters>
      <Docs>
        <param name="action">Pracy są wykonywane asynchronicznie</param>
        <summary>Kolejki określona pracy do uruchomienia w puli wątków i zwraca <see cref="T:System.Threading.Tasks.Task" /> obiekt, który reprezentuje tę pracę.</summary>
        <returns>Zadanie reprezentujące pracę w kolejce do wykonania w puli wątków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Run%2A> Metoda umożliwia tworzenie i wykonywanie zadań w pojedynczym wywołaniu metody i jest prostszej alternatywy <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> metody. Tworzy zadanie z następujących wartości domyślne:  
  
-   Jego token anulowania jest <xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType>.  
  
-   Jego <xref:System.Threading.Tasks.Task.CreationOptions%2A> wartość właściwości jest <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>.  
  
-   Używa domyślnego harmonogramu zadań.  
  
 Aby uzyskać informacje dotyczące obsługi wyjątków zgłaszanych przez operacje zadań, zobacz [wyjątków](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano `ShowThreadInfo` metoda, która wyświetla <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType> bieżącego wątku. Jest wywoływana bezpośrednio z poziomu wątku aplikacji i jest wywoływana z <xref:System.Action> obiekt delegowany przekazany do <xref:System.Threading.Tasks.Task.Run%28System.Action%29> metody.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run11.cs#11)]
 [!code-vb[System.Threading.Tasks.Task.Run#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run11.vb#11)]  
  
 Poniższy przykład jest podobny do poprzedniego, z tą różnicą, że używa wyrażenia lambda do definiowania kod, który ma wykonać zadanie.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run6.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.Run#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run6.vb#3)]  
  
 W przykładach pokazano, że asynchroniczne zadanie podrzędne jest wykonywane w innym wątku niż wątku głównego aplikacji.  
  
 Wywołanie <xref:System.Threading.Tasks.Task.Wait%2A> metoda zapewnia, że zadanie kończy i wyświetla dane wyjściowe przed zakończeniem aplikacji. W przeciwnym razie jest to możliwe, `Main` metoda zostanie ukończone przed zakończeniem zadania.  
  
 W poniższym przykładzie pokazano <xref:System.Threading.Tasks.Task.Run%28System.Action%29> metody. On zdefiniowano tablicę nazwy katalogów i uruchamia oddzielne zadanie w celu pobrania nazwy plików w każdym katalogu. Wszystkie zadania zapisu nazwy plików do pojedynczego <xref:System.Collections.Concurrent.ConcurrentBag%601> obiektu. Przykład następnie wywołuje <xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29> metodę, aby upewnić się, że wszystkie zadania zostały wykonane, a następnie wyświetla liczbę całkowitą liczby nazw plików, zapisywane <xref:System.Collections.Concurrent.ConcurrentBag%601> obiektu.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run2.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Run#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="action" /> Został parametr <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">Obsługa wyjątku (Biblioteka zadań równoległych)</related>
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Func&lt;System.Threading.Tasks.Task&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Func`1&lt;class System.Threading.Tasks.Task&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Run (function As Func(Of Task)) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Run(Func&lt;System::Threading::Tasks::Task ^&gt; ^ function);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;System.Threading.Tasks.Task&gt; -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Run function" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="function">Pracy są wykonywane asynchronicznie</param>
        <summary>Kolejki określona pracy do uruchomienia w puli wątków i zwraca serwer proxy dla zadania zwracany przez <paramref name="function" />.</summary>
        <returns>Zadanie reprezentujące serwera proxy dla zadania zwracany przez <paramref name="function" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać informacje dotyczące obsługi wyjątków zgłaszanych przez operacje zadań, zobacz [wyjątków](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="function" /> Został parametr <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">Obsługa wyjątku (Biblioteka zadań równoległych)</related>
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Action action, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Run(Action ^ action, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Run : Action * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Run (action, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="action">Pracy są wykonywane asynchronicznie</param>
        <param name="cancellationToken">Token anulowania, który może służyć do anulowania pracy</param>
        <summary>Kolejki określona pracy do uruchomienia w puli wątków i zwraca <see cref="T:System.Threading.Tasks.Task" /> obiekt, który reprezentuje tę pracę. Token anulowania umożliwia pracy można anulować.</summary>
        <returns>Zadanie reprezentujące pracę w kolejce do wykonania w puli wątków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Czy zażądano anulowania zanim zadanie rozpocznie się wykonywanie zadania nie jest wykonywane. Zamiast tego jest równa <xref:System.Threading.Tasks.TaskStatus.Canceled> stan i zgłasza <xref:System.Threading.Tasks.TaskCanceledException> wyjątku.  
  
 <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29> Metodą jest prostszej alternatywy <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> metody. Tworzy zadanie z następujących wartości domyślne:  
  
-   Jego <xref:System.Threading.Tasks.Task.CreationOptions%2A> wartość właściwości jest <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>.  
  
-   Używa domyślnego harmonogramu zadań.  
  
 Aby uzyskać informacje dotyczące obsługi wyjątków zgłaszanych przez operacje zadań, zobacz [wyjątków](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
   
  
## Examples  
 Poniższy przykład wywołuje <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29> metodę, aby utworzyć zadanie, który iteruje po plików w katalogu C:\Windows\System32. Wywołań wyrażeń lambda <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> metody w celu dodania informacji o każdym z plików do <xref:System.Collections.Generic.List%601> obiektu. Każdy odłączone zadanie zagnieżdżone, wywoływany przez <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> pętli służy do sprawdzania stanu token anulowania i czy zażądano anulowania wywołuje <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> metody. <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> Metoda zgłasza wyjątek <xref:System.OperationCanceledException> wyjątku, który jest obsługiwany w `catch` zablokować, jeśli wątek wywołujący wywołuje <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> metody.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.Run#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="action" /> Został parametr <see langword="null" />.</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">Zadanie zostało anulowane.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.CancellationTokenSource" /> Skojarzony <paramref name="cancellationToken" /> został usunięty.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">Obsługa wyjątku (Biblioteka zadań równoległych)</related>
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Func&lt;System.Threading.Tasks.Task&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Func`1&lt;class System.Threading.Tasks.Task&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Run(Func&lt;System::Threading::Tasks::Task ^&gt; ^ function, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;System.Threading.Tasks.Task&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Run (function, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="function">Pracy są wykonywane asynchronicznie.</param>
        <param name="cancellationToken">Token anulowania, które mają być używane do anulowania pracy.</param>
        <summary>Kolejki określona pracy do uruchomienia w puli wątków i zwraca serwer proxy dla zadania zwracany przez <paramref name="function" />.</summary>
        <returns>Zadanie reprezentujące serwera proxy dla zadania zwracany przez <paramref name="function" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać informacje dotyczące obsługi wyjątków zgłaszanych przez operacje zadań, zobacz [wyjątków](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="function" /> Został parametr <see langword="null" />.</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">Zadanie zostało anulowane.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.CancellationTokenSource" /> Skojarzony <paramref name="cancellationToken" /> został usunięty.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Anulowanie zadania</related>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">Obsługa wyjątku (Biblioteka zadań równoległych)</related>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Run(Of TResult) (function As Func(Of Task(Of TResult))) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ Run(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ function);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.Run function" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ wynik zwracany przez zadanie serwera proxy.</typeparam>
        <param name="function">Pracy są wykonywane asynchronicznie</param>
        <summary>Kolejki określona pracy do uruchomienia w puli wątków i zwraca serwer proxy dla <see langword="Task(TResult)" /> zwrócone przez <paramref name="function" />.</summary>
        <returns>A <see langword="Task(TResult)" /> reprezentujący serwera proxy dla <see langword="Task(TResult)" /> zwrócone przez <paramref name="function" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać informacje dotyczące obsługi wyjątków zgłaszanych przez operacje zadań, zobacz [wyjątków](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="function" /> Został parametr <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">Obsługa wyjątku (Biblioteka zadań równoległych)</related>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;TResult&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Run(Of TResult) (function As Func(Of TResult)) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ Run(Func&lt;TResult&gt; ^ function);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;'Result&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.Run function" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ zwracanego zadania.</typeparam>
        <param name="function">Pracy są wykonywane asynchronicznie.</param>
        <summary>Kolejki określona pracy do uruchomienia w puli wątków i zwraca <see cref="T:System.Threading.Tasks.Task`1" /> obiekt, który reprezentuje tę pracę.</summary>
        <returns>Obiekt zadania reprezentujący pracy w kolejce do wykonania w puli wątków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Run%2A> Metodą jest prostszej alternatywy <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=nameWithType> metody. Tworzy zadanie z następujących wartości domyślne:  
  
-   Jego token anulowania jest <xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType>.  
  
-   Jego <xref:System.Threading.Tasks.Task.CreationOptions%2A> wartość właściwości jest <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>.  
  
-   Używa domyślnego harmonogramu zadań.  
  
 Aby uzyskać informacje dotyczące obsługi wyjątków zgłaszanych przez operacje zadań, zobacz [wyjątków](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
   
  
## Examples  
 Poniższy przykład oblicza przybliżoną liczbę słów w pliki tekstowe, które reprezentuje opublikowane książki. Każde zadanie jest odpowiedzialna za otwarcie pliku, asynchronicznego odczytywania jego całą zawartość i oblicza liczbę wyrazów za pomocą wyrażenia regularnego. <xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29> Metoda jest wywoływana, aby upewnić się, że wszystkie zadania zostały ukończone przed wyświetleniem wyrazów każdej książki do konsoli.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run3.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.Run#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run3.vb#2)]  
  
 Wyrażenie regularne `\p{P}*\s+` dopasowuje zero, jeden lub więcej znaków interpunkcyjnych, w którym następuje co najmniej jeden znak odstępu. Przyjęto założenie, że łączna liczba dopasowań jest równe przybliżony wyrazów.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="function" /> Parametr <see langword="null" />.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">Obsługa wyjątku (Biblioteka zadań równoległych)</related>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ Run(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ function, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.Run (function, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ wynik zwracany przez zadanie serwera proxy.</typeparam>
        <param name="function">Pracy są wykonywane asynchronicznie</param>
        <param name="cancellationToken">Token anulowania, który powinien być używany do anulowania pracy</param>
        <summary>Kolejki określona pracy do uruchomienia w puli wątków i zwraca serwer proxy dla <see langword="Task(TResult)" /> zwrócone przez <paramref name="function" />.</summary>
        <returns>A <see langword="Task(TResult)" /> reprezentujący serwera proxy dla <see langword="Task(TResult)" /> zwrócone przez <paramref name="function" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać informacje dotyczące obsługi wyjątków zgłaszanych przez operacje zadań, zobacz [wyjątków](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="function" /> Został parametr <see langword="null" />.</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">Zadanie zostało anulowane.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.CancellationTokenSource" /> Skojarzony <paramref name="cancellationToken" /> został usunięty.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Anulowanie zadania</related>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">Obsługa wyjątku (Biblioteka zadań równoległych)</related>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;TResult&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ Run(Func&lt;TResult&gt; ^ function, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;'Result&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.Run (function, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ wyniku zadania.</typeparam>
        <param name="function">Pracy są wykonywane asynchronicznie</param>
        <param name="cancellationToken">Token anulowania, który powinien być używany do anulowania pracy</param>
        <summary>Kolejki określona pracy do uruchomienia w puli wątków i zwraca <see langword="Task(TResult)" /> obiekt, który reprezentuje tę pracę. Token anulowania umożliwia pracy można anulować.</summary>
        <returns>A <see langword="Task(TResult)" /> który reprezentuje pracę w kolejce do wykonania w puli wątków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Czy zażądano anulowania zanim zadanie rozpocznie się wykonywanie zadania nie jest wykonywane. Zamiast tego jest równa <xref:System.Threading.Tasks.TaskStatus.Canceled> stan i zgłasza <xref:System.Threading.Tasks.TaskCanceledException> wyjątku.  
  
 <xref:System.Threading.Tasks.Task.Run%2A> Metodą jest prostszej alternatywy <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> metody. Tworzy zadanie z następujących wartości domyślne:  
  
-   Jego <xref:System.Threading.Tasks.Task.CreationOptions%2A> wartość właściwości jest <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>.  
  
-   Używa domyślnego harmonogramu zadań.  
  
 Aby uzyskać informacje dotyczące obsługi wyjątków zgłaszanych przez operacje zadań, zobacz [wyjątków](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
   
  
## Examples  
 Poniższy przykład tworzy 20 zadania, które będą pętli do licznik jest zwiększany na wartość 2 miliony. 10 pierwszych zadań dotrzeć do milionów 2, odwołano token anulowania i wszelkie zadania, którego liczniki nie osiągnęły 2 miliony zostały anulowane. W przykładzie danych wyjściowych.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run7.cs#7)]
 [!code-vb[System.Threading.Tasks.Task.Run#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run7.vb#7)]  
  
 Zamiast używania <xref:System.AggregateException.InnerExceptions%2A> właściwość do sprawdzenia wyjątki, przykład wykonuje iterację wszystkich zadań w celu ustalenia, które zostały ukończone pomyślnie i zostały anulowane. Dla osób, które zostały wykonane wyświetlana jest wartość zwracana przez zadanie.  
  
 Ponieważ kooperatywne anulowanie, każde zadanie podrzędne można zdecydować, jak reagować na operację anulowania. Poniższy przykład jest podobna do pierwszej, z tą różnicą, że po anulowaniu tokenu zadania zwraca liczbę iteracji one została ukończona, a nie zgłasza wyjątku.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run28.cs#28)]
 [!code-vb[System.Threading.Tasks.Task.Run#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run28.vb#28)]  
  
 Przykład musi obsługiwać <xref:System.AggregateException> wyjątku, ponieważ wszystkie zadania, które nie zostały uruchomione, gdy zażądano anulowania nadal zgłoszenie wyjątku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="function" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">Zadanie zostało anulowane.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.CancellationTokenSource" /> Skojarzony <paramref name="cancellationToken" /> został usunięty.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md">Anulowanie zadania</related>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">Obsługa wyjątku (Biblioteka zadań równoległych)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="RunSynchronously">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Przebiegi <see cref="T:System.Threading.Tasks.Task" /> synchronicznie na bieżącym <see cref="T:System.Threading.Tasks.TaskScheduler" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RunSynchronously">
      <MemberSignature Language="C#" Value="public void RunSynchronously ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RunSynchronously() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.RunSynchronously" />
      <MemberSignature Language="VB.NET" Value="Public Sub RunSynchronously ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RunSynchronously();" />
      <MemberSignature Language="F#" Value="member this.RunSynchronously : unit -&gt; unit" Usage="task.RunSynchronously " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Przebiegi <see cref="T:System.Threading.Tasks.Task" /> synchronicznie na bieżącym <see cref="T:System.Threading.Tasks.TaskScheduler" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwykle zadania są wykonywane asynchronicznie w wątku z puli wątków i nie blokują wątek wywołujący. Zadania wykonywane przez wywołanie metody <xref:System.Threading.Tasks.Task.RunSynchronously> metody są skojarzone z bieżącym <xref:System.Threading.Tasks.TaskScheduler> i są uruchamiane w wątku wywołującego. Jeśli harmonogram docelowy nie obsługuje tego zadania na wątku wywołującym, zadanie zostanie zaplanowane do wykonania w ramach harmonogramu zadań i spowoduje zablokowanie wątku wywołującego, dopóki nie zakończy się zadanie wykonania. Mimo że zadanie jest uruchamiane synchronicznie, wątek wywołujący, nadal powinny wywoływać <xref:System.Threading.Tasks.Task.Wait%2A> obsługującą ewentualne wyjątki, które mogą zgłosić zadania.  Aby uzyskać więcej informacji na temat obsługi wyjątków, zobacz [wyjątków](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 Zadania wykonywane przez wywołanie metody <xref:System.Threading.Tasks.Task.RunSynchronously%2A> metody są tworzone przez wywołanie metody <xref:System.Threading.Tasks.Task> lub <xref:System.Threading.Tasks.Task%601> konstruktora klasy. Zadania są uruchamiane synchronicznie musi znajdować się w <xref:System.Threading.Tasks.TaskStatus.Created> stanu. Zadanie może być uruchomione i są wykonywane tylko raz. Próbuje zaplanować zadanie, czas drugiego powoduje wyjątek.  
  
   
  
## Examples  
 W poniższym przykładzie porównano zadania wykonywane przez wywołanie metody <xref:System.Threading.Tasks.Task.RunSynchronously%2A> metody przy użyciu jednego wykonywany asynchronicznie. W obu przypadkach zadania wykonywane wyrażeń lambda identyczne, które wyświetlają identyfikator zadania i identyfikator wątku, na którym jest uruchomione zadanie. Zadanie oblicza sumę liczb całkowitych od 1 do 1 000 000. Dane wyjściowe z przykładu pokazują, zadanie jest wykonywana przez wywołanie <xref:System.Threading.Tasks.Task.RunSynchronously%2A> metoda uruchamia się w wątku aplikacji, natomiast zadanie asynchroniczne nie.  
  
 [!code-csharp[System.Threading.Tasks.Task.RunSynchronously#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.runsynchronously/cs/runsynchronously1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.RunSynchronously#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.runsynchronously/vb/runsynchronously1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> Wystąpienie zostało usunięte.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Threading.Tasks.Task" /> Nie jest w nieprawidłowym stanie, który ma zostać uruchomiony. Go może zostały już uruchomione, wykonywane lub zostało anulowane lub został utworzony w taki sposób, który nie obsługuje bezpośredniego planowania.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">Obsługa wyjątku (Biblioteka zadań równoległych)</related>
      </Docs>
    </Member>
    <Member MemberName="RunSynchronously">
      <MemberSignature Language="C#" Value="public void RunSynchronously (System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RunSynchronously(class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RunSynchronously (scheduler As TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RunSynchronously(System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.RunSynchronously : System.Threading.Tasks.TaskScheduler -&gt; unit" Usage="task.RunSynchronously scheduler" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="scheduler">Harmonogram, na którym ma zostać próba uruchomienia zadań w tym tekście.</param>
        <summary>Przebiegi <see cref="T:System.Threading.Tasks.Task" /> synchronicznie na <see cref="T:System.Threading.Tasks.TaskScheduler" /> podane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zadania wykonywane przez wywołanie metody <xref:System.Threading.Tasks.Task.RunSynchronously%2A> metody są tworzone przez wywołanie metody <xref:System.Threading.Tasks.Task> lub <xref:System.Threading.Tasks.Task%601> konstruktora klasy. Zadania są uruchamiane synchronicznie musi znajdować się w <xref:System.Threading.Tasks.TaskStatus.Created> stanu. Zadanie może być uruchomione i są wykonywane tylko raz. Próbuje zaplanować zadanie, czas drugiego powoduje wyjątek.  
  
 Jeśli harmonogram docelowy nie obsługuje uruchamianie go w bieżącym wątku, zadanie zostanie zaplanowane do wykonania w ramach harmonogramu zadań i blokuje bieżącego wątku, dopóki nie zakończy się zadanie wykonania. W związku z tym wątek wywołujący nie jest konieczne wywołanie metody, takie jak <xref:System.Threading.Tasks.Task.Wait%2A> aby upewnić się, że zadanie zostało ukończone wykonywania. Aby uzyskać więcej informacji na temat obsługi wyjątków dla operacji zadań, zobacz [wyjątków](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> Wystąpienie zostało usunięte.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="scheduler" /> Argument jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Threading.Tasks.Task" /> Nie jest w nieprawidłowym stanie, który ma zostać uruchomiony. Go może zostały już uruchomione, wykonywane lub zostało anulowane lub został utworzony w taki sposób, który nie obsługuje bezpośredniego planowania.</exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">Obsługa wyjątku (Biblioteka zadań równoległych)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Uruchamia <see cref="T:System.Threading.Tasks.Task" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; unit" Usage="task.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Uruchamia <see cref="T:System.Threading.Tasks.Task" />, planowanie jego wykonywanie do bieżącego <see cref="T:System.Threading.Tasks.TaskScheduler" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zadanie może być uruchomione i są wykonywane tylko raz. Próbuje zaplanować zadanie, po raz drugi, wynikiem będzie wyjątek.  
  
 <xref:System.Threading.Tasks.Task.Start%2A> Służy do wykonywania zadań, który został utworzony, wywołując jedną z <xref:System.Threading.Tasks.Task> konstruktorów. Zwykle w tym przypadku należy oddzielić Tworzenie zadania podrzędnego z jego wykonania, takie jak podczas warunkowo wykonywania zadań, które zostały utworzone. W przypadku bardziej powszechne, w której nie trzeba rozdzielić wystąpienia zadania wykonania, firma Microsoft zaleca, wywołania przeciążenia <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> lub <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> metody.  
  
 Aby uzyskać informacje dotyczące obsługi wyjątków zgłaszanych przez operacje zadań, zobacz [wyjątków](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
   
  
## Examples  
 Poniższy przykład wywołuje <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%29> Konstruktor do tworzenia wystąpienia nowego <xref:System.Threading.Tasks.Task> obiekt, który wyświetla jej zadania, Identyfikatory oraz wątków zarządzanych, a następnie wykonuje pętlę. Następnie wywołuje <xref:System.Threading.Tasks.Task.Start%2A> metodę, aby wykonać zadania.  Ponieważ jest to aplikacja konsoli, wywołanie <xref:System.Threading.Tasks.Task.Wait%2A> metoda jest niezbędna uniemożliwić zakończenie przed zakończeniem zadania wykonywania aplikacji.  
  
 [!code-csharp[System.Threading.Tasks.Task.Start#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.start/cs/Start1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Start#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.start/vb/Start1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> Wystąpienie zostało usunięte.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Threading.Tasks.Task" /> Nie jest w nieprawidłowym stanie, który ma zostać uruchomiony. Go może zostały już uruchomione, wykonywane lub zostało anulowane lub został utworzony w taki sposób, który nie obsługuje bezpośredniego planowania.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">Obsługa wyjątku (Biblioteka zadań równoległych)</related>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start (System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start(class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Start(System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start (scheduler As TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start(System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.Start : System.Threading.Tasks.TaskScheduler -&gt; unit" Usage="task.Start scheduler" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="scheduler">
          <see cref="T:System.Threading.Tasks.TaskScheduler" /> Za pomocą którego do kojarzenia i wykonanie tego zadania.</param>
        <summary>Uruchamia <see cref="T:System.Threading.Tasks.Task" />, planowanie wykonywania określonej <see cref="T:System.Threading.Tasks.TaskScheduler" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zadanie może być tylko pracy i są wykonywane tylko raz. Próbuje zaplanować zadanie, po raz drugi, wynikiem będzie wyjątek.  
  
 Aby uzyskać informacje dotyczące obsługi wyjątków zgłaszanych przez operacje zadań, zobacz [wyjątków](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="scheduler" /> Argument jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Threading.Tasks.Task" /> Nie jest w nieprawidłowym stanie, który ma zostać uruchomiony. Go może zostały już uruchomione, wykonywane lub zostało anulowane lub został utworzony w taki sposób, który nie obsługuje bezpośredniego planowania.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> Wystąpienie zostało usunięte.</exception>
        <exception cref="T:System.Threading.Tasks.TaskSchedulerException">Harmonogram nie może tego zadania w kolejce.</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md">Obsługa wyjątku (Biblioteka zadań równoległych)</related>
      </Docs>
    </Member>
    <Member MemberName="Status">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.TaskStatus Status { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.Tasks.TaskStatus Status" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Status" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Status As TaskStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::TaskStatus Status { System::Threading::Tasks::TaskStatus get(); };" />
      <MemberSignature Language="F#" Value="member this.Status : System.Threading.Tasks.TaskStatus" Usage="System.Threading.Tasks.Task.Status" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskStatus</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Threading.Tasks.TaskStatus" /> tego zadania.</summary>
        <value>Bieżący <see cref="T:System.Threading.Tasks.TaskStatus" /> tego wystąpienia zadania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pobieranie wartości <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> właściwości nie blokuje wątek wywołujący, dopóki zadanie zostało ukończone.  
  
 Aby uzyskać więcej informacji i obejrzeć przykład, zobacz [tworzenie łańcuchów zadań przy użyciu zadań kontynuacji](~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md) i [porady: anulowanie zadania i jego elementy podrzędne](~/docs/standard/parallel-programming/how-to-cancel-a-task-and-its-children.md).  
  
   
  
## Examples  
 Poniższy przykład tworzy 20 zadania, które będą pętli do licznik jest zwiększany na wartość 2 miliony. 10 pierwszych zadań dotrzeć do milionów 2, odwołano token anulowania i wszelkie zadania, którego liczniki nie osiągnęły 2 miliony zostały anulowane. Przykład następnie sprawdza, czy <xref:System.Threading.Tasks.Task.Status%2A> właściwości każdego zadania, aby wskazać, czy została ukończona pomyślnie, lub została anulowana. Dla osób, które ukończone wyświetlana jest wartość zwracana przez zadanie.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run7.cs#7)]
 [!code-vb[System.Threading.Tasks.Task.Run#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run7.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IAsyncResult.AsyncWaitHandle">
      <MemberSignature Language="C#" Value="System.Threading.WaitHandle System.IAsyncResult.AsyncWaitHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.WaitHandle System.IAsyncResult.AsyncWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.System#IAsyncResult#AsyncWaitHandle" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property AsyncWaitHandle As WaitHandle Implements IAsyncResult.AsyncWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="property System::Threading::WaitHandle ^ System::IAsyncResult::AsyncWaitHandle { System::Threading::WaitHandle ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.IAsyncResult.AsyncWaitHandle" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.AsyncWaitHandle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.WaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Threading.WaitHandle" /> można poczekać na zakończenie zadania.</summary>
        <value>Element <see cref="T:System.Threading.WaitHandle" /> można poczekać na zakończenie zadania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Korzystając z funkcji oczekiwania, dostarczone przez <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> zalecane jest stosowanie <xref:System.IAsyncResult.AsyncWaitHandle%2A> dla podobne funkcje. Aby uzyskać więcej informacji, zobacz sekcję "Oczekiwanie na zadania" w [opartego na zadaniach Asynchronous Programming](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md) i [za pomocą TPL z innych wzorami asynchronicznymi](~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> Został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IAsyncResult.CompletedSynchronously">
      <MemberSignature Language="C#" Value="bool System.IAsyncResult.CompletedSynchronously { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.IAsyncResult.CompletedSynchronously" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.System#IAsyncResult#CompletedSynchronously" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property CompletedSynchronously As Boolean Implements IAsyncResult.CompletedSynchronously" />
      <MemberSignature Language="C++ CLI" Value="property bool System::IAsyncResult::CompletedSynchronously { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.IAsyncResult.CompletedSynchronously" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.CompletedSynchronously</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wskazanie, czy operacja została ukończona synchronicznie.</summary>
        <value>
          <see langword="true" /> Jeśli operacja została ukończona synchronicznie; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Wait">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Czeka, aż <see cref="T:System.Threading.Tasks.Task" /> można ukończyć wykonywania.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public void Wait ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Wait() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait" />
      <MemberSignature Language="VB.NET" Value="Public Sub Wait ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Wait();" />
      <MemberSignature Language="F#" Value="member this.Wait : unit -&gt; unit" Usage="task.Wait " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Czeka, aż <see cref="T:System.Threading.Tasks.Task" /> można ukończyć wykonywania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Wait%2A> jest to metoda synchronizacji, który powoduje, że wątek wywołujący, poczekaj na zakończenie bieżącego zadania. Jeśli bieżące zadanie nie zostało rozpoczęte wykonywania, metody Wait próbuje usunąć zadanie z harmonogramu i wykonaj go wbudowanego w bieżącym wątku. Jeśli nie jest w stanie to zrobić, lub jeśli bieżące zadanie wykonywania już się rozpoczął, blokuje wątek wywołujący, aż do zakończenia zadania. Aby uzyskać więcej informacji, zobacz [Task.Wait i "Inlining"](http://blogs.msdn.com/b/pfxteam/archive/2009/10/15/9907713.aspx) w Programowanie równoległe z bloga platformy .NET.   
  
## Examples  
 Poniższy przykład uruchamia zadanie, które generuje miliona losowych liczb całkowitych od 0 do 100, a następnie oblicza ich wartości średniej. W przykładzie użyto <xref:System.Threading.Tasks.Task.Wait%2A> metodę, aby upewnić się, że zadanie kończy przed zakończenia aplikacji. W przeciwnym razie ponieważ jest to aplikacja konsoli, przykład zakończy się przed zadania można obliczyć i wyświetlić średniej.  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/wait1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Wait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/wait1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> Został usunięty.</exception>
        <exception cref="T:System.AggregateException">Zadanie zostało anulowane. <see cref="P:System.AggregateException.InnerExceptions" /> Kolekcja zawiera <see cref="T:System.Threading.Tasks.TaskCanceledException" /> obiektu.  
  
—lub— 
Wystąpił wyjątek podczas wykonywania zadania. <see cref="P:System.AggregateException.InnerExceptions" /> Kolekcja zawiera informacje o wyjątku lub wyjątki.</exception>
        <related type="ExternalDocumentation" href="http://blogs.msdn.com/b/pfxteam/archive/2009/10/15/9907713.aspx">Task.Wait i "Inlining"</related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Wait (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Wait(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.Wait : int -&gt; bool" Usage="task.Wait millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Liczba milisekund, lub <see cref="F:System.Threading.Timeout.Infinite" /> (-1), aby czekać w nieskończoność.</param>
        <summary>Czeka, aż <see cref="T:System.Threading.Tasks.Task" /> można ukończyć wykonywania w obrębie określoną liczbę milisekund.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="T:System.Threading.Tasks.Task" /> ukończone w wyznaczonym limicie czasu; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Wait%28System.Int32%29> jest to metoda synchronizacji, która powoduje, że wątek wywołujący oczekiwania dla bieżącego wystąpienia zadań do wykonania, dopóki nie wystąpi jedno z następujących czynności:  
  
-   Zadanie zakończy się pomyślnie.  
  
-   Samo zadanie jest anulowane lub zgłasza wyjątek. W takim przypadku można obsłużyć <xref:System.AggregateException> wyjątku. <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> Właściwość zawiera szczegóły dotyczące wyjątków lub wyjątku.  
  
-   Odstępach czasu zdefiniowanych przez `millisecondsTimeout` upływa. W tym przypadku bieżącego wątku wznawia działanie, a metoda zwraca `false`.  
  
   
  
## Examples  
 Poniższy przykład uruchamia zadanie, które generuje pięć milionów losowe liczby całkowite z przedziału od 0 do 100, a następnie oblicza ich wartości średniej. W przykładzie użyto <xref:System.Threading.Tasks.Task.Wait%28System.Int32%29> metodę, aby czekać aż aplikacja ukończenia w MS 150. Jeśli aplikacja zakończy się normalnie, zadanie wyświetla Suma i średnia liczb losowych, która go wygenerowała. Jeśli upłynął limit czasu, w przykładzie wyświetlono komunikatu przed zakończeniem.  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/Wait5.cs#5)]
 [!code-vb[System.Threading.Tasks.Task.Wait#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/Wait5.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> Został usunięty.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> jest liczbą ujemną od-1, który reprezentuje nieskończony limit czasu.</exception>
        <exception cref="T:System.AggregateException">Zadanie zostało anulowane. <see cref="P:System.AggregateException.InnerExceptions" /> Kolekcja zawiera <see cref="T:System.Threading.Tasks.TaskCanceledException" /> obiektu.  
  
—lub— 
Wystąpił wyjątek podczas wykonywania zadania. <see cref="P:System.AggregateException.InnerExceptions" /> Kolekcja zawiera informacje o wyjątku lub wyjątki.</exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public void Wait (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Wait(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Wait(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.Wait : System.Threading.CancellationToken -&gt; unit" Usage="task.Wait cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">Token anulowania do obserwowania podczas oczekiwania na zakończenie zadania.</param>
        <summary>Czeka, aż <see cref="T:System.Threading.Tasks.Task" /> można ukończyć wykonywania. Czas oczekiwania skończy się, jeśli token anulowania, zostanie anulowane przed zakończeniem zadania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29> Metoda tworzy cancelable oczekiwania, czyli powoduje bieżącego wątku oczekiwania, dopóki nie wystąpi jedno z następujących czynności:  
  
-   Zadanie zostanie ukończone.  
  
-   Token anulowania, zostanie anulowane. W tym przypadku wywołanie <xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29> metoda zgłasza wyjątek <xref:System.OperationCanceledException>.  
  
> [!NOTE]
>  Trwa anulowanie `cancellationToken` token anulowania nie ma wpływu na bieżące zadanie chyba że również został przekazany token anulowania i jest przygotowany do obsługi anulowania. Przekazywanie `cancellationToken` obiektu ta metoda po prostu umożliwia oczekiwania zostaną anulowane.  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie prostego token anulowania do anulowania podczas oczekiwania na zakończenie zadania podrzędnego. Zadanie jest uruchamiane, wywołuje <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> metody Anuluj wszelkie źródłem tokena tokenów anulowania, a następnie opóźnienia na pięć sekund. Należy pamiętać, że samo zadanie nie został przekazany token anulowania i nie będzie można anulować. Wątek aplikacji wywołuje zadanie <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> metodę, aby czekać na zakończenie zadania, ale czas oczekiwania zostanie anulowane po token anulowania, zostanie anulowane i <xref:System.OperationCanceledException> zgłaszany. Program obsługi wyjątków zgłasza wyjątek, a następnie zostaje uśpione na sześć sekund. Dane wyjściowe z przykładu pokazują, że opóźnienie umożliwia zadań do wykonania w <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> stanu.  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/wait3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.Wait#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/wait3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="cancellationToken" /> Zostało anulowane.</exception>
        <exception cref="T:System.ObjectDisposedException">Zadanie zostało usunięte.</exception>
        <exception cref="T:System.AggregateException">Zadanie zostało anulowane. <see cref="P:System.AggregateException.InnerExceptions" /> Kolekcja zawiera <see cref="T:System.Threading.Tasks.TaskCanceledException" /> obiektu.  
  
—lub— 
Wystąpił wyjątek podczas wykonywania zadania. <see cref="P:System.AggregateException.InnerExceptions" /> Kolekcja zawiera informacje o wyjątku lub wyjątki.</exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Wait (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Wait(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Wait : TimeSpan -&gt; bool" Usage="task.Wait timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> reprezentujący liczbę milisekund oczekiwania, lub <see cref="T:System.TimeSpan" /> reprezentujący milisekund czekać w nieskończoność,-1.</param>
        <summary>Czeka, aż <see cref="T:System.Threading.Tasks.Task" /> można ukończyć wykonywania w określonym przedziale czasu.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="T:System.Threading.Tasks.Task" /> ukończone w wyznaczonym limicie czasu; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29> jest to metoda synchronizacji, która powoduje, że wątek wywołujący oczekiwania dla bieżącego wystąpienia zadań do wykonania, dopóki nie wystąpi jedno z następujących czynności:  
  
-   Zadanie zakończy się pomyślnie.  
  
-   Samo zadanie jest anulowane lub zgłasza wyjątek. W takim przypadku można obsłużyć <xref:System.AggregateException> wyjątku. <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> Właściwość zawiera szczegóły dotyczące wyjątków lub wyjątku.  
  
-   Odstępach czasu zdefiniowanych przez `timeout` upływa. W tym przypadku bieżącego wątku wznawia działanie, a metoda zwraca `false`.  
  
   
  
## Examples  
 Poniższy przykład uruchamia zadanie, które generuje pięć milionów losowe liczby całkowite z przedziału od 0 do 100, a następnie oblicza ich wartości średniej. W przykładzie użyto <xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29> metodę, aby czekać aż aplikacja ukończenia w MS 150. Jeśli aplikacja zakończy się normalnie, zadanie wyświetla Suma i średnia liczb losowych, która go wygenerowała. Jeśli upłynął limit czasu, w przykładzie wyświetlono komunikatu przed zakończeniem.  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/Wait6.cs#6)]
 [!code-vb[System.Threading.Tasks.Task.Wait#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/Wait6.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> Został usunięty.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> jest to liczba ujemna innych niż milisekund wartości-1, który reprezentuje nieskończony limit czasu. 
—lub— 
 <paramref name="timeout" /> jest większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.AggregateException">Zadanie zostało anulowane. <see cref="P:System.AggregateException.InnerExceptions" /> Kolekcja zawiera <see cref="T:System.Threading.Tasks.TaskCanceledException" /> obiektu.  
  
—lub— 
Wystąpił wyjątek podczas wykonywania zadania. <see cref="P:System.AggregateException.InnerExceptions" /> Kolekcja zawiera informacje o wyjątku lub wyjątki.</exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Wait(int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.Wait : int * System.Threading.CancellationToken -&gt; bool" Usage="task.Wait (millisecondsTimeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Liczba milisekund, lub <see cref="F:System.Threading.Timeout.Infinite" /> (-1), aby czekać w nieskończoność.</param>
        <param name="cancellationToken">Token anulowania do obserwowania podczas oczekiwania na zakończenie zadania.</param>
        <summary>Czeka, aż <see cref="T:System.Threading.Tasks.Task" /> można ukończyć wykonywania. Czas oczekiwania skończy się, jeśli upłynie limit czasu lub token anulowania, zostanie anulowane przed zakończeniem zadania.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="T:System.Threading.Tasks.Task" /> ukończone w wyznaczonym limicie czasu; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> jest to metoda synchronizacji, która powoduje, że wątek wywołujący oczekiwania dla bieżącego wystąpienia zadań do wykonania, dopóki nie wystąpi jedno z następujących czynności:  
  
-   Zadanie zakończy się pomyślnie.  
  
-   Samo zadanie jest anulowane lub zgłasza wyjątek. W takim przypadku można obsłużyć <xref:System.AggregateException> wyjątku. <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> Właściwość zawiera szczegóły dotyczące wyjątków lub wyjątku.  
  
-   `cancellationToken` Token anulowania, zostanie anulowane. W tym przypadku wywołanie <xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> metoda zgłasza wyjątek <xref:System.OperationCanceledException>.  
  
-   Odstępach czasu zdefiniowanych przez `millisecondsTimeout` upływa. W tym przypadku bieżącego wątku wznawia działanie, a metoda zwraca `false`.  
  
> [!NOTE]
>  Trwa anulowanie `cancellationToken` token anulowania nie ma wpływu na bieżące zadanie chyba że również został przekazany token anulowania i jest przygotowany do obsługi anulowania. Przekazywanie `cancellationToken` obiektu ta metoda po prostu umożliwia oczekiwania zostaną anulowane na podstawie na jakiś warunek.  
  
   
  
## Examples  
 Poniższy przykład wywołuje <xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> metody w celu zapewnienia wartość limitu czasu i anulowania tokenu, który można zakończyć oczekiwanie na ukończenie zadania. Nowy wątek jest uruchomiony i wykonuje `CancelToken` metody, która wstrzymuje, a następnie wywołuje <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> metodę, aby anulować tokenów anulowania. Zadanie to uruchomiona i opóźnia 5 sekund. <xref:System.Threading.Tasks.Task.Wait%2A> Metody są udostępniane zarówno wartość limitu czasu krótkie, jak i token anulowania i następnie jest wywoływana, aby czekać na ukończenie zadania podrzędnego.  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/wait4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.Wait#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/wait4.vb#4)]  
  
 Należy pamiętać, że dokładne dane wyjściowe z przykładu jest zależna od czy czas oczekiwania zostało anulowane z powodu anulowania lub ponieważ upłynął limit czasu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="cancellationToken" /> Zostało anulowane.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> Został usunięty.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> jest liczbą ujemną od-1, który reprezentuje nieskończony limit czasu.</exception>
        <exception cref="T:System.AggregateException">Zadanie zostało anulowane. <see cref="P:System.AggregateException.InnerExceptions" /> Kolekcja zawiera <see cref="T:System.Threading.Tasks.TaskCanceledException" /> obiektu.  
  
—lub— 
Wystąpił wyjątek podczas wykonywania zadania. <see cref="P:System.AggregateException.InnerExceptions" /> Kolekcja zawiera informacje o wyjątku lub wyjątki.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAll">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Czeka, aż wszystkie podane <see cref="T:System.Threading.Tasks.Task" /> obiektów, aby zakończyć wykonywania.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static void WaitAll (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WaitAll(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WaitAll (ParamArray tasks As Task())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WaitAll(... cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.Tasks.Task[] -&gt; unit" Usage="System.Threading.Tasks.Task.WaitAll tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks">Tablica <see cref="T:System.Threading.Tasks.Task" /> wystąpienia, na którym oczekiwania.</param>
        <summary>Czeka, aż wszystkie podane <see cref="T:System.Threading.Tasks.Task" /> obiektów, aby zakończyć wykonywania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład rozpoczyna się 10 zadań, z których każdy jest przekazywany indeks jako obiekt stanu. Zadania związane z indeksu od dwóch do pięciu zgłaszać wyjątki. Wywołanie <xref:System.Threading.Tasks.Task.WaitAll%2A> metoda opakowuje wszystkie wyjątki w <xref:System.AggregateException> obiektu i propaguje je do wątku wywołującego.  
  
 [!code-csharp[System.Threading.Tasks.Task#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/waitall.cs#02)]
 [!code-vb[System.Threading.Tasks.Task#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/waitall.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Co najmniej jeden <see cref="T:System.Threading.Tasks.Task" /> obiekty w <paramref name="tasks" /> został usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> Argument jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> Argument zawiera element o wartości null.  
  
—lub— 
<paramref name="tasks" /> Argument jest pusta tablica.</exception>
        <exception cref="T:System.AggregateException">Co najmniej jeden z <see cref="T:System.Threading.Tasks.Task" /> wystąpień zostało anulowane. Jeśli zadanie zostało anulowane, <see cref="T:System.AggregateException" /> wyjątek zawiera <see cref="T:System.OperationCanceledException" /> wyjątek w jego <see cref="P:System.AggregateException.InnerExceptions" /> kolekcji.  
  
—lub— 
Wystąpił wyjątek podczas wykonywania co najmniej jeden z <see cref="T:System.Threading.Tasks.Task" /> wystąpień.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (tasks As Task(), millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.Tasks.Task[] * int -&gt; bool" Usage="System.Threading.Tasks.Task.WaitAll (tasks, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="tasks">Tablica <see cref="T:System.Threading.Tasks.Task" /> wystąpienia, na którym oczekiwania.</param>
        <param name="millisecondsTimeout">Liczba milisekund, lub <see cref="F:System.Threading.Timeout.Infinite" /> (-1), aby czekać w nieskończoność.</param>
        <summary>Czeka, aż wszystkie podane <see cref="T:System.Threading.Tasks.Task" /> obiektów, aby ukończyć wykonywania w obrębie określoną liczbę milisekund.</summary>
        <returns>
          <see langword="true" /> Jeśli wszystkie z <see cref="T:System.Threading.Tasks.Task" /> wykonywania wystąpienia zakończona w wyznaczonym limicie czasu; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Co najmniej jeden <see cref="T:System.Threading.Tasks.Task" /> obiekty w <paramref name="tasks" /> został usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> Argument jest <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Co najmniej jeden z <see cref="T:System.Threading.Tasks.Task" /> wystąpień zostało anulowane. Jeśli zadanie zostało anulowane, <see cref="T:System.AggregateException" /> zawiera <see cref="T:System.OperationCanceledException" /> w jego <see cref="P:System.AggregateException.InnerExceptions" /> kolekcji.  
  
—lub— 
Wystąpił wyjątek podczas wykonywania co najmniej jeden z <see cref="T:System.Threading.Tasks.Task" /> wystąpień.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> jest liczbą ujemną od-1, który reprezentuje nieskończony limit czasu.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> Argument zawiera element o wartości null.  
  
—lub— 
<paramref name="tasks" /> Argument jest pusta tablica.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static void WaitAll (System.Threading.Tasks.Task[] tasks, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WaitAll(class System.Threading.Tasks.Task[] tasks, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WaitAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.Tasks.Task[] * System.Threading.CancellationToken -&gt; unit" Usage="System.Threading.Tasks.Task.WaitAll (tasks, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">Tablica <see cref="T:System.Threading.Tasks.Task" /> wystąpienia, na którym oczekiwania.</param>
        <param name="cancellationToken">A <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> do obserwowania podczas oczekiwania na ukończenie zadań.</param>
        <summary>Czeka, aż wszystkie podane <see cref="T:System.Threading.Tasks.Task" /> obiektów, aby zakończyć wykonywania, o ile nie zostało anulowane podczas oczekiwania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `cancellationToken` Argument jest używany do anulowania operacji oczekiwania. Anulowanie zadania jest operacji distinct i zasygnalizowania przez <xref:System.AggregateException> wymienionych powyżej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="cancellationToken" /> Zostało anulowane.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> Argument jest <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Co najmniej jeden z <see cref="T:System.Threading.Tasks.Task" /> wystąpień zostało anulowane. Jeśli zadanie zostało anulowane, <see cref="T:System.AggregateException" /> zawiera <see cref="T:System.OperationCanceledException" /> w jego <see cref="P:System.AggregateException.InnerExceptions" /> kolekcji.  
  
—lub— 
Wystąpił wyjątek podczas wykonywania co najmniej jeden z <see cref="T:System.Threading.Tasks.Task" /> wystąpień.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> Argument zawiera element o wartości null.  
  
—lub— 
<paramref name="tasks" /> Argument jest pusta tablica.</exception>
        <exception cref="T:System.ObjectDisposedException">Co najmniej jeden <see cref="T:System.Threading.Tasks.Task" /> obiekty w <paramref name="tasks" /> został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.Tasks.Task[] tasks, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.Tasks.Task[] tasks, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (tasks As Task(), timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.Tasks.Task[] * TimeSpan -&gt; bool" Usage="System.Threading.Tasks.Task.WaitAll (tasks, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="tasks">Tablica <see cref="T:System.Threading.Tasks.Task" /> wystąpienia, na którym oczekiwania.</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> reprezentujący liczbę milisekund oczekiwania, lub <see cref="T:System.TimeSpan" /> reprezentujący milisekund czekać w nieskończoność,-1.</param>
        <summary>W tym czasie czeka dla wszystkich udostępnionych można anulować <see cref="T:System.Threading.Tasks.Task" /> obiektów, aby zakończyć wykonywanie w określonym przedziale czasu.</summary>
        <returns>
          <see langword="true" /> Jeśli wszystkie z <see cref="T:System.Threading.Tasks.Task" /> wykonywania wystąpienia zakończona w wyznaczonym limicie czasu; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Co najmniej jeden <see cref="T:System.Threading.Tasks.Task" /> obiekty w <paramref name="tasks" /> został usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> Argument jest <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Co najmniej jeden z <see cref="T:System.Threading.Tasks.Task" /> wystąpień zostało anulowane. Jeśli zadanie zostało anulowane, <see cref="T:System.AggregateException" /> zawiera <see cref="T:System.OperationCanceledException" /> w jego <see cref="P:System.AggregateException.InnerExceptions" /> kolekcji.  
  
—lub— 
Wystąpił wyjątek podczas wykonywania co najmniej jeden z <see cref="T:System.Threading.Tasks.Task" /> wystąpień.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> jest to liczba ujemna innych niż milisekund wartości-1, który reprezentuje nieskończony limit czasu. 
—lub— 
 <paramref name="timeout" /> jest większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> Argument zawiera element o wartości null.  
  
—lub— 
<paramref name="tasks" /> Argument jest pusta tablica.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.Tasks.Task[] * int * System.Threading.CancellationToken -&gt; bool" Usage="System.Threading.Tasks.Task.WaitAll (tasks, millisecondsTimeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">Tablica <see cref="T:System.Threading.Tasks.Task" /> wystąpienia, na którym oczekiwania.</param>
        <param name="millisecondsTimeout">Liczba milisekund, lub <see cref="F:System.Threading.Timeout.Infinite" /> (-1), aby czekać w nieskończoność.</param>
        <param name="cancellationToken">A <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> do obserwowania podczas oczekiwania na ukończenie zadań.</param>
        <summary>Czeka, aż wszystkie podane <see cref="T:System.Threading.Tasks.Task" /> obiektów, aby ukończyć wykonywania w obrębie określoną liczbę milisekund, lub do momentu zostało anulowane podczas oczekiwania.</summary>
        <returns>
          <see langword="true" /> Jeśli wszystkie z <see cref="T:System.Threading.Tasks.Task" /> wykonywania wystąpienia zakończona w wyznaczonym limicie czasu; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `cancellationToken` Argument jest używany do anulowania operacji oczekiwania. Anulowanie zadania jest operacji distinct i zasygnalizowania przez <xref:System.AggregateException> przedstawionych powyżej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Co najmniej jeden <see cref="T:System.Threading.Tasks.Task" /> obiekty w <paramref name="tasks" /> został usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> Argument jest <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Co najmniej jeden z <see cref="T:System.Threading.Tasks.Task" /> wystąpień zostało anulowane. Jeśli zadanie zostało anulowane, <see cref="T:System.AggregateException" /> zawiera <see cref="T:System.OperationCanceledException" /> w jego <see cref="P:System.AggregateException.InnerExceptions" /> kolekcji.  
  
—lub— 
Wystąpił wyjątek podczas wykonywania co najmniej jeden z <see cref="T:System.Threading.Tasks.Task" /> wystąpień.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> jest liczbą ujemną od-1, który reprezentuje nieskończony limit czasu.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> Argument zawiera element o wartości null.  
  
—lub— 
<paramref name="tasks" /> Argument jest pusta tablica.</exception>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="cancellationToken" /> Zostało anulowane.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAny">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Czeka na dowolny z dostarczonych <see cref="T:System.Threading.Tasks.Task" /> obiektów, aby zakończyć wykonywania.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (ParamArray tasks As Task()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(... cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.Tasks.Task[] -&gt; int" Usage="System.Threading.Tasks.Task.WaitAny tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks">Tablica <see cref="T:System.Threading.Tasks.Task" /> wystąpienia, na którym oczekiwania.</param>
        <summary>Czeka na dowolny z dostarczonych <see cref="T:System.Threading.Tasks.Task" /> obiektów, aby zakończyć wykonywania.</summary>
        <returns>Indeks ukończoną <see cref="T:System.Threading.Tasks.Task" /> obiektu <paramref name="tasks" /> tablicy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład powoduje uruchomienie pięć zadań, z których każdy jest w stanie uśpienia dla co najmniej 50 MS lub maksymalnie 1,050 milisekund. <xref:System.Threading.Tasks.Task.WaitAny%2A> Metoda następnie oczekuje dla każdego zadania do wykonania. W przykładzie są wyświetlane zadania o identyfikatorze zadania, który upłynął czas oczekiwania, a także bieżący stan wszystkich zadań.  
  
 [!code-csharp[System.Threading.Tasks.Task.WaitAny#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Tasks.Task.WaitAny/cs/WaitAny1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.WaitAny#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Tasks.Task.WaitAny/vb/WaitAny1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> Został usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> Argument jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> Argument zawiera element o wartości null.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (tasks As Task(), millisecondsTimeout As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.Tasks.Task[] * int -&gt; int" Usage="System.Threading.Tasks.Task.WaitAny (tasks, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="tasks">Tablica <see cref="T:System.Threading.Tasks.Task" /> wystąpienia, na którym oczekiwania.</param>
        <param name="millisecondsTimeout">Liczba milisekund, lub <see cref="F:System.Threading.Timeout.Infinite" /> (-1), aby czekać w nieskończoność.</param>
        <summary>Czeka na dowolny z dostarczonych <see cref="T:System.Threading.Tasks.Task" /> obiektów, aby ukończyć wykonywania w obrębie określoną liczbę milisekund.</summary>
        <returns>Indeks ukończonego zadania we <paramref name="tasks" /> tablicy argument lub wartość -1, jeśli nastąpiło przekroczenie limitu czasu.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> Został usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> Argument jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> jest liczbą ujemną od-1, który reprezentuje nieskończony limit czasu.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> Argument zawiera element o wartości null.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.Tasks.Task[] * System.Threading.CancellationToken -&gt; int" Usage="System.Threading.Tasks.Task.WaitAny (tasks, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">Tablica <see cref="T:System.Threading.Tasks.Task" /> wystąpienia, na którym oczekiwania.</param>
        <param name="cancellationToken">A <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> do obserwowania podczas oczekiwania na zakończenie zadania.</param>
        <summary>Czeka na dowolny z dostarczonych <see cref="T:System.Threading.Tasks.Task" /> obiektów, aby zakończyć wykonywania, o ile nie zostało anulowane podczas oczekiwania.</summary>
        <returns>Indeks ukończonego zadania we <paramref name="tasks" /> tablica argumentów.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> Został usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> Argument jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> Argument zawiera element o wartości null.</exception>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="cancellationToken" /> Zostało anulowane.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (tasks As Task(), timeout As TimeSpan) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.Tasks.Task[] * TimeSpan -&gt; int" Usage="System.Threading.Tasks.Task.WaitAny (tasks, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="tasks">Tablica <see cref="T:System.Threading.Tasks.Task" /> wystąpienia, na którym oczekiwania.</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> reprezentujący liczbę milisekund oczekiwania, lub <see cref="T:System.TimeSpan" /> reprezentujący milisekund czekać w nieskończoność,-1.</param>
        <summary>Czeka na dowolny z dostarczonych <see cref="T:System.Threading.Tasks.Task" /> obiektów, aby zakończyć wykonywanie w określonym przedziale czasu.</summary>
        <returns>Indeks ukończonego zadania we <paramref name="tasks" /> tablicy argument lub wartość -1, jeśli nastąpiło przekroczenie limitu czasu.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> Został usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> Argument jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> jest to liczba ujemna innych niż milisekund wartości-1, który reprezentuje nieskończony limit czasu. 
—lub— 
 <paramref name="timeout" /> jest większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> Argument zawiera element o wartości null.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.Tasks.Task[] * int * System.Threading.CancellationToken -&gt; int" Usage="System.Threading.Tasks.Task.WaitAny (tasks, millisecondsTimeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">Tablica <see cref="T:System.Threading.Tasks.Task" /> wystąpienia, na którym oczekiwania.</param>
        <param name="millisecondsTimeout">Liczba milisekund, lub <see cref="F:System.Threading.Timeout.Infinite" /> (-1), aby czekać w nieskończoność.</param>
        <param name="cancellationToken">A <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> do obserwowania podczas oczekiwania na zakończenie zadania.</param>
        <summary>Czeka na dowolny z dostarczonych <see cref="T:System.Threading.Tasks.Task" /> obiektów, aby ukończyć wykonywania w obrębie określoną liczbę milisekund, lub do momentu odwołano token anulowania.</summary>
        <returns>Indeks ukończonego zadania we <paramref name="tasks" /> tablicy argument lub wartość -1, jeśli nastąpiło przekroczenie limitu czasu.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> Został usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> Argument jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> jest liczbą ujemną od-1, który reprezentuje nieskończony limit czasu.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> Argument zawiera element o wartości null.</exception>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="cancellationToken" /> Zostało anulowane.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WhenAll">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy zadanie, które zostanie ukończone, gdy wszystkie podane zadania zostały ukończone.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WhenAll">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WhenAll (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WhenAll(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAll (tasks As IEnumerable(Of Task)) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ WhenAll(System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAll : seq&lt;System.Threading.Tasks.Task&gt; -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.WhenAll tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="tasks">Zadania, które ma oczekiwać na zakończenie.</param>
        <summary>Tworzy zadanie, które zostanie ukończone, gdy wszystkie <see cref="T:System.Threading.Tasks.Task" /> obiektów wyliczalny kolekcji zostały ukończone.</summary>
        <returns>Zadanie, które reprezentuje ukończenie wszystkich zadań podane.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążenia <xref:System.Threading.Tasks.Task.WhenAll%2A> metody, która zwraca <xref:System.Threading.Tasks.Task> obiektu zwykle są wywoływane, gdy interesuje Cię w stan zestawu zadań lub wyjątki generowane przez zestaw zadań.  
  
> [!NOTE]
>  Wywołanie <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29> metody nie blokuje wątek wywołujący.  
  
 Jeśli podane zadań zakończy się w nieprawidłowym stanie, zwrócone zadanie zakończy się również w <xref:System.Threading.Tasks.TaskStatus.Faulted> stanu, w którym jej wyjątki będzie zawierać agregacji zbiór nieopakowane wyjątki od poszczególnych zadań podane.  
  
 Jeśli żadne podane zadanie zwracające błędy, ale co najmniej jeden z nich zostało anulowane, zwrócone zadanie zakończy się w <xref:System.Threading.Tasks.TaskStatus.Canceled> stanu.  
  
 Jeśli żadne zadanie zwracające błędy żadnych zadań zostały anulowane, wynikowe zadanie zakończy się w <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> stanu.  
  
 Jeśli podana tablica/wyliczenia nie zawiera zadań, zwrócone zadanie natychmiast zostanie zastąpiona usługą <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> stanu przed zwróceniem do obiektu wywołującego.  
  
   
  
## Examples  
 Poniższy przykład tworzy zestaw zadań, które polecenie ping adresy URL w tablicy. Zadania są przechowywane w `List<Task>` kolekcji, który jest przekazywany do <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29> metody. Po wywołaniu <xref:System.Threading.Tasks.Task.Wait%2A> metoda zapewnia, że zostały wykonane wszystkie wątki, przykład sprawdza, czy <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> właściwości w celu określenia, wszystkie zadania, mają wystąpił błąd.  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/WhenAll4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/WhenAll4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> Argument był <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> Zbioru zawarte <see langword="null" /> zadania.</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAll">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WhenAll (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WhenAll(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAll (ParamArray tasks As Task()) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ WhenAll(... cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAll : System.Threading.Tasks.Task[] -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.WhenAll tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks">Zadania, które ma oczekiwać na zakończenie.</param>
        <summary>Tworzy zadanie, które zostanie ukończone, gdy wszystkie <see cref="T:System.Threading.Tasks.Task" /> zakończył obiektów w tablicy.</summary>
        <returns>Zadanie, które reprezentuje ukończenie wszystkich zadań podane.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążenia <xref:System.Threading.Tasks.Task.WhenAll%2A> metody, która zwraca <xref:System.Threading.Tasks.Task> obiektu zwykle są wywoływane, gdy interesuje Cię w stan zestawu zadań lub wyjątki generowane przez zestaw zadań.  
  
> [!NOTE]
>  Wywołanie <xref:System.Threading.Tasks.Task.WhenAll%28System.Threading.Tasks.Task%5B%5D%29> metody nie blokuje wątek wywołujący.  
  
 Jeśli podane zadań zakończy się w nieprawidłowym stanie, zwrócone zadanie zakończy się również w <xref:System.Threading.Tasks.TaskStatus.Faulted> stanu, w którym jej wyjątki będzie zawierać agregacji zbiór nieopakowane wyjątki od poszczególnych zadań podane.  
  
 Jeśli żadne podane zadanie zwracające błędy, ale co najmniej jeden z nich zostało anulowane, zwrócone zadanie zakończy się w <xref:System.Threading.Tasks.TaskStatus.Canceled> stanu.  
  
 Jeśli żadne zadanie zwracające błędy żadnych zadań zostały anulowane, wynikowe zadanie zakończy się w <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> stanu.  
  
 Jeśli podana tablica/wyliczenia nie zawiera zadań, zwrócone zadanie natychmiast zostanie zastąpiona usługą <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> stanu przed zwróceniem do obiektu wywołującego.  
  
   
  
## Examples  
 Poniższy przykład tworzy zestaw zadań, które polecenie ping adresy URL w tablicy. Zadania są przechowywane w `List<Task>` kolekcji, która jest konwertowana na tablicę i przekazywane do <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29> metody. Po wywołaniu <xref:System.Threading.Tasks.Task.Wait%2A> metoda zapewnia, że zostały wykonane wszystkie wątki, przykład sprawdza, czy <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> właściwości w celu określenia, wszystkie zadania, mają wystąpił błąd.  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/WhenAll3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/WhenAll3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> Argument był <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> Tablica <see langword="null" /> zadania.</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAll&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult[]&gt; WhenAll&lt;TResult&gt; (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult[]&gt; WhenAll&lt;TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAll(Of TResult) (tasks As IEnumerable(Of Task(Of TResult))) As Task(Of TResult())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;cli::array &lt;TResult&gt; ^&gt; ^ WhenAll(System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAll : seq&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; -&gt; System.Threading.Tasks.Task&lt;'Result[]&gt;" Usage="System.Threading.Tasks.Task.WhenAll tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult[]&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ ukończonego zadania.</typeparam>
        <param name="tasks">Zadania, które ma oczekiwać na zakończenie.</param>
        <summary>Tworzy zadanie, które zostanie ukończone, gdy wszystkie <see cref="T:System.Threading.Tasks.Task`1" /> obiektów wyliczalny kolekcji zostały ukończone.</summary>
        <returns>Zadanie, które reprezentuje ukończenie wszystkich zadań podane.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie <xref:System.Threading.Tasks.Task.WhenAll%60%601%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7B%60%600%7D%7D%29> metody nie blokuje wątek wywołujący. Jednak wywołania do zwracanego <xref:System.Threading.Tasks.Task%601.Result%2A> właściwość zablokowanie wątku wywołującego.  
  
 Jeśli podane zadań zakończy się w nieprawidłowym stanie, zwrócone zadanie zakończy się również w <xref:System.Threading.Tasks.TaskStatus.Faulted> stanu, w którym jej wyjątki będzie zawierać agregacji zbiór nieopakowane wyjątki od poszczególnych zadań podane.  
  
 Jeśli żadne podane zadanie zwracające błędy, ale co najmniej jeden z nich zostało anulowane, zwrócone zadanie zakończy się w <xref:System.Threading.Tasks.TaskStatus.Canceled> stanu.  
  
 Jeśli żadne zadanie zwracające błędy żadnych zadań zostały anulowane, wynikowe zadanie zakończy się w <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> stanu.  <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> Właściwość zwracanego zadania zostanie ustawiona na tablicę zawierającą wszystkie wyniki zadania podane w tej samej kolejności, ponieważ zostały one dostarczone (np. Jeśli dane wejściowe zadania tablica t1, t2, t3, zadaniem wyjściowym <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> zwróci właściwości `TResult[]` gdzie `arr[0] == t1.Result, arr[1] == t2.Result, and arr[2] == t3.Result)`.  
  
 Jeśli `tasks` argumentu nie zawiera zadań, zwrócone zadanie natychmiast zostanie zastąpiona usługą <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> stanu przed zwróceniem do obiektu wywołującego. Zwrócony `TResult[]` będzie tablica elementów 0.  
  
   
  
## Examples  
 Poniższy przykład tworzy dziesięć zadań, z których każdy uruchamia generator liczb losowych, który tworzy 1000 losowych liczb od 1 do 1000, a następnie oblicza ich wartości średniej. <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> Metoda jest używana do opóźnienie wystąpienia generatorów liczb losowych, tak aby nie są tworzone z wartościami inicjującymi identyczne. Wywołanie <xref:System.Threading.Tasks.Task.WhenAll%2A> następnie metoda zwraca <xref:System.Int64> tablicę, która zawiera wartość średnia obliczona przez każde zadanie podrzędne. Następnie są one używane do obliczania średniej ogólnej.  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/whenall1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/whenall1.vb#1)]  
  
 W tym przypadku dziesięć poszczególne zadania są przechowywane w <xref:System.Collections.Generic.List%601> obiektu. <xref:System.Collections.Generic.List%601> implementuje <xref:System.Collections.Generic.IEnumerable%601> interfejsu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> Argument był <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> Zbioru zawarte <see langword="null" /> zadania.</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAll&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult[]&gt; WhenAll&lt;TResult&gt; (params System.Threading.Tasks.Task&lt;TResult&gt;[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult[]&gt; WhenAll&lt;TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TResult&gt;[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAll(Of TResult) (ParamArray tasks As Task(Of TResult)()) As Task(Of TResult())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;cli::array &lt;TResult&gt; ^&gt; ^ WhenAll(... cli::array &lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAll : System.Threading.Tasks.Task&lt;'Result&gt;[] -&gt; System.Threading.Tasks.Task&lt;'Result[]&gt;" Usage="System.Threading.Tasks.Task.WhenAll tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult[]&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TResult&gt;[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ ukończonego zadania.</typeparam>
        <param name="tasks">Zadania, które ma oczekiwać na zakończenie.</param>
        <summary>Tworzy zadanie, które zostanie ukończone, gdy wszystkie <see cref="T:System.Threading.Tasks.Task`1" /> zakończył obiektów w tablicy.</summary>
        <returns>Zadanie, które reprezentuje ukończenie wszystkich zadań podane.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie <xref:System.Threading.Tasks.Task.WhenAll%60%601%28System.Threading.Tasks.Task%7B%60%600%7D%5B%5D%29> metody nie blokuje wątek wywołujący. Jednak wywołania do zwracanego <xref:System.Threading.Tasks.Task%601.Result%2A> właściwość zablokowanie wątku wywołującego.  
  
 Jeśli podane zadań zakończy się w nieprawidłowym stanie, zwrócone zadanie zakończy się również w <xref:System.Threading.Tasks.TaskStatus.Faulted> stanu, w którym jej wyjątki będzie zawierać agregacji zbiór nieopakowane wyjątki od poszczególnych zadań podane.  
  
 Jeśli żadne podane zadanie zwracające błędy, ale co najmniej jeden z nich zostało anulowane, zwrócone zadanie zakończy się w <xref:System.Threading.Tasks.TaskStatus.Canceled> stanu.  
  
 Jeśli żadne zadanie zwracające błędy żadnych zadań zostały anulowane, wynikowe zadanie zakończy się w <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> stanu.  <xref:System.Threading.Tasks.Task%601.Result%2A> Zwracanego zadania zostanie ustawiony na tablicę zawierającą wszystkie wyniki zadania podane w tej samej kolejności, ponieważ zostały one dostarczone (np. Jeśli dane wejściowe zadania tablica t1, t2, t3, zadaniem wyjściowym <xref:System.Threading.Tasks.Task%601.Result%2A> zwróci `TResult[]` gdzie `arr[0] == t1.Result, arr[1] == t2.Result, and arr[2] == t3.Result)`.  
  
 Jeśli podana tablica/wyliczenia nie zawiera zadań, zwrócone zadanie natychmiast zostanie zastąpiona usługą <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> stanu przed zwróceniem do obiektu wywołującego.  Zwrócony `TResult[]` będzie tablica elementów 0.  
  
   
  
## Examples  
 Poniższy przykład tworzy dziesięć zadań, z których każdy uruchamia generator liczb losowych, który tworzy 1000 losowych liczb od 1 do 1000, a następnie oblicza ich wartości średniej. W tym przypadku dziesięć poszczególne zadania są przechowywane w `Task<Int64>` tablicy.  <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> Metoda jest używana do opóźnienie wystąpienia generatorów liczb losowych, tak aby nie są tworzone z wartościami inicjującymi identyczne. Wywołanie <xref:System.Threading.Tasks.Task.WhenAll%2A> następnie metoda zwraca <xref:System.Int64> tablicę, która zawiera wartość średnia obliczona przez każde zadanie podrzędne. Następnie są one używane do obliczania średniej ogólnej.  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/whenall2.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/whenall2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> Argument był <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> Tablica <see langword="null" /> zadania.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WhenAny">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy zadanie, które zostanie ukończone, gdy dowolne zadania podane zostały wykonane.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WhenAny">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt; WhenAny (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task&gt; WhenAny(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAny (tasks As IEnumerable(Of Task)) As Task(Of Task)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task&lt;System::Threading::Tasks::Task ^&gt; ^ WhenAny(System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAny : seq&lt;System.Threading.Tasks.Task&gt; -&gt; System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt;" Usage="System.Threading.Tasks.Task.WhenAny tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="tasks">Zadania, które ma oczekiwać na zakończenie.</param>
        <summary>Tworzy zadanie, które zostanie ukończone, gdy dowolne zadania podane zostały wykonane.</summary>
        <returns>Zadanie, które reprezentuje ukończenie zadania podane.  Zwracana wartość wynik zadania jest zadanie, które zakończona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócone zadanie zostanie ukończone, gdy dostarczony zadań zostało zakończone.  Zwrócone zadanie zakończy się zawsze w `RanToCompletion` stanu z jej zestaw wyników, aby pierwsze zadanie do wykonania.  Ta zasada obowiązuje nawet wtedy, gdy pierwsze zadanie do wykonania zostało zakończone w `Canceled` lub `Faulted` stanu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> Argument był <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> Tablica zawiera zadania o wartości null lub był pusty.</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAny">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt; WhenAny (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task&gt; WhenAny(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny(System.Threading.Tasks.Task[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAny (ParamArray tasks As Task()) As Task(Of Task)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task&lt;System::Threading::Tasks::Task ^&gt; ^ WhenAny(... cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAny : System.Threading.Tasks.Task[] -&gt; System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt;" Usage="System.Threading.Tasks.Task.WhenAny tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks">Zadania, które ma oczekiwać na zakończenie.</param>
        <summary>Tworzy zadanie, które zostanie ukończone, gdy dowolne zadania podane zostały wykonane.</summary>
        <returns>Zadanie, które reprezentuje ukończenie zadania podane.  Zwracana wartość wynik zadania jest zadanie, które zakończona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócone zadanie zostanie ukończone, gdy dostarczony zadań zostało zakończone.  Zwrócone zadanie zakończy się zawsze w `RanToCompletion` stanu z jego `Result` równa pierwsze zadanie do wykonania.  Ta zasada obowiązuje nawet wtedy, gdy pierwsze zadanie do wykonania zostało zakończone w `Canceled` lub `Faulted` stanu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> Argument miał wartość null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> Tablica zawiera zadania o wartości null lub był pusty.</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAny&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; WhenAny&lt;TResult&gt; (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; WhenAny&lt;TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAny(Of TResult) (tasks As IEnumerable(Of Task(Of TResult))) As Task(Of Task(Of TResult))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ WhenAny(System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAny : seq&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; -&gt; System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt;" Usage="System.Threading.Tasks.Task.WhenAny tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ ukończonego zadania.</typeparam>
        <param name="tasks">Zadania, które ma oczekiwać na zakończenie.</param>
        <summary>Tworzy zadanie, które zostanie ukończone, gdy dowolne zadania podane zostały wykonane.</summary>
        <returns>Zadanie, które reprezentuje ukończenie zadania podane.  Zwracana wartość wynik zadania jest zadanie, które zakończona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócone zadanie zostanie ukończone, gdy dostarczony zadań zostało zakończone.  Zwrócone zadanie zakończy się zawsze w stanie RanToCompletion z jej zestaw wyników, aby pierwsze zadanie do wykonania. Ta zasada obowiązuje, nawet wtedy, gdy pierwsze zadanie do wykonania zostało zakończone w stanie anulowane lub Faulted.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> Argument był <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> Tablica zawiera zadania o wartości null lub był pusty.</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAny&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; WhenAny&lt;TResult&gt; (params System.Threading.Tasks.Task&lt;TResult&gt;[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; WhenAny&lt;TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TResult&gt;[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny``1(System.Threading.Tasks.Task{``0}[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAny(Of TResult) (ParamArray tasks As Task(Of TResult)()) As Task(Of Task(Of TResult))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ WhenAny(... cli::array &lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAny : System.Threading.Tasks.Task&lt;'Result&gt;[] -&gt; System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt;" Usage="System.Threading.Tasks.Task.WhenAny tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TResult&gt;[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ ukończonego zadania.</typeparam>
        <param name="tasks">Zadania, które ma oczekiwać na zakończenie.</param>
        <summary>Tworzy zadanie, które zostanie ukończone, gdy dowolne zadania podane zostały wykonane.</summary>
        <returns>Zadanie, które reprezentuje ukończenie zadania podane.  Zwracana wartość wynik zadania jest zadanie, które zakończona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócone zadanie zostanie ukończone, gdy dostarczony zadań zostało zakończone.  Zwrócone zadanie zakończy się zawsze w stanie RanToCompletion z jej zestaw wyników, aby pierwsze zadanie do wykonania. Ta zasada obowiązuje, nawet wtedy, gdy pierwsze zadanie do wykonania zostało zakończone w stanie anulowane lub Faulted.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> Argument miał wartość null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> Tablica zawiera zadania o wartości null lub był pusty.</exception>
      </Docs>
    </Member>
    <Member MemberName="Yield">
      <MemberSignature Language="C#" Value="public static System.Runtime.CompilerServices.YieldAwaitable Yield ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Runtime.CompilerServices.YieldAwaitable Yield() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Yield" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Yield () As YieldAwaitable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::CompilerServices::YieldAwaitable Yield();" />
      <MemberSignature Language="F#" Value="static member Yield : unit -&gt; System.Runtime.CompilerServices.YieldAwaitable" Usage="System.Threading.Tasks.Task.Yield " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.CompilerServices.YieldAwaitable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy zadanie oczekujący, który asynchronicznie daje do bieżącego kontekstu, gdy jest oczekiwane.</summary>
        <returns>Kontekst, gdy jest oczekiwane, asynchronicznie spowoduje przejście do bieżącego kontekstu, w czasie oczekiwania. Jeśli bieżący <see cref="T:System.Threading.SynchronizationContext" /> jest różna od null, jest ona traktowana jako bieżący kontekst. W przeciwnym razie Harmonogram zadań, który jest skojarzony z aktualnie wykonywane zadanie jest traktowany jako bieżący kontekst.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz użyć `await Task.Yield();` w metodzie asynchronicznej, aby wymusić metoda zakończone asynchronicznie. Jeśli bieżący kontekst synchronizacji (<xref:System.Threading.SynchronizationContext> obiektu), to opublikuje pozostałą część metody wykonywania do danego kontekstu. Jednak kontekst zdecyduje, jak ustalić priorytet tej pracy względem innych zadań, które mogą być oczekujące. Kontekst synchronizacji, który znajduje się w wątku interfejsu użytkownika w większości środowisk interfejsu użytkownika często priorytetów pracy opublikowany na wyższe niż dane wejściowe i renderowanie pracy kontekstu. Z tego powodu nie należy polegać na `await Task.Yield();` zapewnienie dynamicznego interfejsu użytkownika.  Aby uzyskać więcej informacji, zobacz wpis [przydatne abstrakcje z włączoną ContinueWith](http://blogs.msdn.com/b/pfxteam/archive/2008/07/23/8768673.aspx) w Programowanie równoległe z bloga platformy .NET.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
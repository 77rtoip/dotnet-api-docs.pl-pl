<Type Name="Task" FullName="System.Threading.Tasks.Task">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="d920b17ab80db20fab0e3101b745858eade81dd1" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30580045" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Task : IAsyncResult, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Task extends System.Object implements class System.IAsyncResult, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.Task" />
  <TypeSignature Language="VB.NET" Value="Public Class Task&#xA;Implements IAsyncResult, IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Task : IAsyncResult, IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IAsyncResult</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("Id = {Id}, Status = {Status}, Method = {DebuggerDisplayMethodDescription}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Threading.Tasks.SystemThreadingTasks_TaskDebugView))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje operację asynchroniczną.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
   
## Remarks  
 <xref:System.Threading.Tasks.Task> Klasy reprezentuje jednej operacji, która nie zwraca wartość i która zazwyczaj wykonuje asynchronicznie. <xref:System.Threading.Tasks.Task> obiekty są jednym z centralnej składników [wzorca asynchronicznego opartego na zadaniach](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md) najpierw wprowadzone w programie .NET Framework 4. Ponieważ praca jest wykonywana przez <xref:System.Threading.Tasks.Task> obiektu zazwyczaj wykonuje asynchronicznie w wątku puli wątków zamiast synchronicznie na wątku głównego aplikacji, można użyć <xref:System.Threading.Tasks.Task.Status%2A> właściwości, oraz z <xref:System.Threading.Tasks.Task.IsCanceled%2A>, <xref:System.Threading.Tasks.Task.IsCompleted%2A>, i <xref:System.Threading.Tasks.Task.IsFaulted%2A> właściwości, aby określić stan zadania. Najczęściej wyrażenia lambda jest używany do określenia pracę zadania do wykonania.  
  
 Dla operacji, które zwracają wartości, możesz użyć <xref:System.Threading.Tasks.Task%601> klasy.  
  
 W tej sekcji:  
  
 [Przykłady wystąpienia zadania](#Instant)   
 [Tworzenie i wykonywanie zadania](#Creating)   
 [Oddzielanie zadań tworzenia i wykonywania](#Separating)   
 [Oczekiwanie na ukończenie zadań jednego lub więcej](#WaitingForOne)   
 [Zadania i kultury.](#Culture)   
 [Dla deweloperów debugera](#Debugger)  

 <a name="Instant"></a>     
## <a name="task-instantiation"></a>Podczas tworzenia wystąpienia zadania  
 Poniższy przykład tworzy i wykonuje cztery zadania. Wykonanie zadania trzy <xref:System.Action%601> delegata o nazwie `action`, która akceptuje argument typu <xref:System.Object>. Czwarty zadania wykonuje wyrażenia lambda ( <xref:System.Action> delegować) czyli zdefiniowano w tekście w wywołaniu metody tworzenia zadania. Każde zadanie jest tworzone i uruchom w inny sposób:  
  
-   Zadanie `t1` zostanie uruchomiony przez wywołanie konstruktora klasy zadania, ale jest uruchamiana przez wywołanie jego <xref:System.Threading.Tasks.Task.Start> metody tylko po zadań `t2` została uruchomiona.  
  
-   Zadanie `t2` to wystąpienie zostało utworzone i uruchomione w wywołaniu metody pojedynczego przez wywołanie metody <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%29?displayProperty=nameWithType> metody.  
  
-   Zadanie `t3` to wystąpienie zostało utworzone i uruchomione w wywołaniu metody pojedynczego przez wywołanie metody <xref:System.Threading.Tasks.Task.Run%28System.Action%29> metody.  
  
-   Zadanie `t4` jest wykonywana synchronicznie w głównym wątku przez wywołanie <xref:System.Threading.Tasks.Task.RunSynchronously> metody.  
  
 Ponieważ zadania `t4` synchronicznie, wykonuje on wykonuje na wątku głównego aplikacji. Asynchronicznie zwykle wykonać kolejnych zadań na jeden lub więcej wątków z puli wątków.  
  
 [!code-csharp[System.Threading.Tasks.Task#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/startnew.cs#01)]
 [!code-vb[System.Threading.Tasks.Task#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/startnew.vb#01)] 
    
<a name="Creating"></a>   
## <a name="creating-and-executing-a-task"></a>Tworzenie i wykonywanie zadania  
 <xref:System.Threading.Tasks.Task> można tworzyć wystąpień różne sposoby. Najbardziej typowe podejście, które jest dostępne począwszy od [!INCLUDE[net_v45](~/includes/net-v45-md.md)], jest wywołanie statycznych <xref:System.Threading.Tasks.Task.Run%2A> metody. <xref:System.Threading.Tasks.Task.Run%2A> Metoda zapewnia prosty sposób, aby uruchomić zadanie przy użyciu wartości domyślnych i bez konieczności dodatkowe parametry. W poniższym przykładzie użyto <xref:System.Threading.Tasks.Task.Run%28System.Action%29> metodę, aby uruchomić zadanie, które wykonuje pętlę, a następnie wyświetla liczby iteracji pętli:  
  
 [!code-csharp[System.Threading.Tasks.Task#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/run1.cs#6)]
 [!code-vb[System.Threading.Tasks.Task#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/run1.vb#6)]  
  
 Zamiast i najbardziej typowa metoda, aby uruchomić zadanie [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], jest statycznych <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> metody. <xref:System.Threading.Tasks.Task.Factory%2A?displayProperty=nameWithType> Zwraca właściwość <xref:System.Threading.Tasks.TaskFactory> obiektu. Overloads z <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> metody pozwalają określić parametry do przekazania do opcje tworzenia zadania i harmonogramu zadań. W poniższym przykładzie użyto <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> metody, aby uruchomić zadanie. Jest funkcjonalnym odpowiednikiem kodu w poprzednim przykładzie.  
  
 [!code-csharp[System.Threading.Tasks.Task#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/startnew1.cs#7)]
 [!code-vb[System.Threading.Tasks.Task#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/startnew1.vb#7)]  
  
 Aby uzyskać bardziej szczegółowy przykłady, zobacz [opartego na zadaniach asynchronicznej programowania](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md).  
  
<a name="Separating"></a>   
## <a name="separating-task-creation-and-execution"></a>Oddzielanie zadań tworzenia i wykonywania  
 <xref:System.Threading.Tasks.Task> Klasa udostępnia także konstruktorów, który zainicjować zadanie, ale który nie należy planować go do wykonania. Ze względu na wydajność <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> lub <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> metoda jest to preferowany sposób tworzenia i planowania zadań obliczeniową, ale w scenariuszach, w których muszą być oddzielone tworzenie i planowanie, można użyć konstruktorów, a następnie wywołać <xref:System.Threading.Tasks.Task.Start%2A?displayProperty=nameWithType> metodę, aby zaplanować zadanie do wykonania w późniejszym czasie.  
  
<a name="WaitingForOne"></a>   
## <a name="waiting-for-one-or-more-tasks-to-complete"></a>Oczekiwanie na ukończenie zadań jednego lub więcej  
 Ponieważ zadania są zazwyczaj uruchamiane asynchronicznie w wątku puli wątków, wątku, który tworzy i uruchamia zadanie kontynuuje wykonywanie, jak utworzyć wystąpienia zadania. W niektórych przypadkach, gdy wątek wywołujący jest wątku głównego aplikacji, aplikacja może zakończyć przed każdą zadania faktycznie rozpoczyna się wykonanie. W innych logiki aplikacji może wymagać wątek wywołujący kontynuować wykonywania, tylko wtedy, gdy co najmniej jedno zadanie zakończy działanie. Możesz zsynchronizować wykonanie wątku i asynchroniczną zadań on uruchomiony przez wywołanie metody `Wait` metody oczekiwania na ukończenie zadań co najmniej jeden.  
  
 Oczekiwania dla pojedynczego zadania do wykonania, można wywołać jej <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> metody. Wywołanie <xref:System.Threading.Tasks.Task.Wait%2A> metody blokuje wątek wywołujący, aż do zakończenia wykonywania jedno wystąpienie klasy.  
  
 Poniższy przykład wywołuje bez parametrów <xref:System.Threading.Tasks.Task.Wait> metody bezwarunkowo czekać do momentu ukończenia zadania. Zadanie symuluje pracy przez wywołanie metody <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> metody w stan uśpienia przez dwie sekundy.  
  
 [!code-csharp[System.Threading.Tasks.Task#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/Wait1.cs#8)]
 [!code-vb[System.Threading.Tasks.Task#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/Wait1.vb#8)]  
  
 Można również warunkowo poczekać na ukończenie zadania. <xref:System.Threading.Tasks.Task.Wait%28System.Int32%29> i <xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29> metody zablokować wątek wywołujący zakończenie zadania lub upłynie limit czasu, zależnie od zostanie osiągnięty jako pierwszy. Ponieważ w poniższym przykładzie uruchamia zadanie, które zostanie uśpiony na dwóch sekund, ale definiuje wartość limitu czasu sekundę, wywołujący bloki wątku do chwili osiągnięcia limitu czasu i przed ukończyć wykonywania zadania.  
  
 [!code-csharp[System.Threading.Tasks.Task#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/Wait2.cs#9)]
 [!code-vb[System.Threading.Tasks.Task#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/Wait2.vb#9)]  
  
 Token anulowania może też podawać, wywołując <xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29> i <xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> metody. Jeśli token <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> właściwość jest `true`, czas oczekiwania zostało anulowane; jeśli prawda podczas staje się <xref:System.Threading.Tasks.Task.Wait%2A> metoda kończy.  
  
 W niektórych przypadkach można oczekiwać w pierwszym serii wykonywanych zadań do wykonania, ale nie jest szczególną uwagę, który go zadań.  W tym celu należy wywołać jednego z przeciążeń <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> metody.  Poniższy przykład tworzy trzech zadań, z których każdy jest w stanie uśpienia Określ interwał przez generator liczb losowych. <xref:System.Threading.Tasks.Task.WaitAny%28System.Threading.Tasks.Task%5B%5D%29> — Metoda oczekuje na zakończenie pierwszej zadania. W przykładzie następnie przedstawiono informacje o stanie wszystkich trzech zadań.  
  
 [!code-csharp[System.Threading.Tasks.Task#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/WhenAny1.cs#10)]
 [!code-vb[System.Threading.Tasks.Task#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/WaitAny1.vb#10)]  
  
 Można również poczekać, aż wszystkie serię zadań do wykonania przez wywołanie metody <xref:System.Threading.Tasks.Task.WaitAll%2A> metody. Poniższy przykład tworzy dziesięciu zadań, czeka na dziesięć wszystkie zakończyć, a następnie wyświetla jego stan.  
  
 [!code-csharp[System.Threading.Tasks.Task#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/WaitAll1.cs#11)]
 [!code-vb[System.Threading.Tasks.Task#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/WaitAll1.vb#11)]  
  
 Należy pamiętać, że podczas oczekiwania na ukończenie zadań co najmniej jeden wszelkie wyjątki zgłaszane w uruchomione zadania są przenoszone w wątku, który wywołuje `Wait` metody, jak przedstawiono na poniższym przykładzie. Uruchamia go 12 zadań, z których trzy zakończone normalnie i trzy które Zgłoś wyjątek, który występuje. Pozostałe sześć zadań trzy są anulowane przed rozpoczęciem i trzy są anulowane podczas ich wykonywania. Wyjątki zostaną zgłoszone w <xref:System.Threading.Tasks.Task.WaitAll%2A> wywołanie metody i są obsługiwane przez `try` / `catch` bloku.  
  
 [!code-csharp[System.Threading.Tasks.Task#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/WaitAll2.cs#12)]
 [!code-vb[System.Threading.Tasks.Task#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/WaitAll2.vb#12)]  
  
 Aby uzyskać więcej informacji dotyczących obsługi wyjątków w operacji asynchronicznych opartego na zadaniach, zobacz [obsługi wyjątków](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
<a name="Culture"></a>   
## <a name="tasks-and-culture"></a>Zadania i kultury.  
 Począwszy od aplikacji klasycznych kierowanych [!INCLUDE[net_v46](~/includes/net-v46-md.md)], kultury wątku, które tworzy i wywołuje zadania staje się częścią kontekst wątku. Niezależnie od bieżącej kultury wątku, w której wykonuje zadanie, bieżącej kultury zadania jest kultury wątku. Dla aplikacji, które odnoszą się do wersji programu .NET Framework, przed [!INCLUDE[net_v46](~/includes/net-v46-md.md)], kultura zadania jest kultura wątku, w której wykonuje zadanie. Aby uzyskać więcej informacji, zobacz sekcję "Kultury i oparty na zadaniach asynchronicznej operacji" w <xref:System.Globalization.CultureInfo> tematu.  
  
> [!NOTE]
>  Aplikacje ze sklepu wykonaj środowiska uruchomieniowego systemu Windows, ustawienia i uzyskiwanie domyślną kulturę.  
  
<a name="Debugger"></a>   
## <a name="for-debugger-developers"></a>Dla deweloperów debugera  
 Dla deweloperów Implementowanie niestandardowych debugery kilka elementów członkowskich wewnętrzne i prywatne zadania mogą być użyteczne, (one ulec zmianie wersji release). `m_taskId` Pola służy jako magazynu zapasowego dla <xref:System.Threading.Tasks.Task.Id%2A> właściwości, jednak podczas uzyskiwania dostępu do tego pola bezpośrednio z debuger może być skuteczniejsza niż dostęp do tej samej wartości za pośrednictwem metody pobierającej właściwości ( `s_taskIdCounter` licznik używane do pobierania następnego dostępnego Identyfikatora zadania). Podobnie `m_stateFlags` pola są przechowywane informacje o bieżący etap cyklu życia zadania, również dostępne za pośrednictwem informacji <xref:System.Threading.Tasks.Task.Status%2A> właściwości. `m_action` Pole zawiera odwołanie do delegata zadania i `m_stateObject` pola przechowuje stan async przekazany do zadania przez dewelopera. Ponadto dla debugery, które analizy ramek stosu `InternalWait` metody służy potencjalnych znacznika, gdy zadanie jest wprowadzania operacji oczekiwania.   
  
 ]]></format>
    </remarks>
    <threadsafe>Wszystkie elementy członkowskie <see cref="T:System.Threading.Tasks.Task" />, z wyjątkiem <see cref="M:System.Threading.Tasks.Task.Dispose" />, są wątkowo i mogą być używane przez wiele wątków jednocześnie.</threadsafe>
    <altmember cref="T:System.Threading.Tasks.Task`1" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowy <see cref="T:System.Threading.Tasks.Task" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action ^ action);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
      </Parameters>
      <Docs>
        <param name="action">Delegat, który reprezentuje kod do wykonania w zadaniu.</param>
        <summary>Inicjuje nowy <see cref="T:System.Threading.Tasks.Task" /> z określonej akcji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zamiast wywoływania najczęściej ten konstruktor do tworzenia wystąpienia <xref:System.Threading.Tasks.Task> obiektu, a następnie uruchom zadanie jest wywołując statycznych <xref:System.Threading.Tasks.Task.Run%28System.Action%29?displayProperty=nameWithType> lub <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=nameWithType> metody. Zaletą tylko oferowane przez ten konstruktor jest możliwość tworzenia wystąpienia obiektu od wywołanie zadania.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%29> Konstruktor do tworzenia zadań, które służą do pobierania nazwy plików w określonych katalogach. Wszystkie zadania zapisu nazwy plików do pojedynczego <xref:System.Collections.Concurrent.ConcurrentBag%601> obiektu. Przykład wywołuje <xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29> metody, aby upewnić się, że wszystkie zadania zostały wykonane, a następnie wyświetla liczba całkowita liczba zapisywane w nazwach plików <xref:System.Collections.Concurrent.ConcurrentBag%601> obiektu.  
  
 [!code-csharp[System.Threading.Tasks.Task.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/vb/ctor1.vb#1)]  
  
 Poniższy przykład jest taki sam, z wyjątkiem tego, aby używać <xref:System.Threading.Tasks.Task.Run%28System.Action%29> metody w celu utworzenia wystąpienia i uruchom zadanie w ramach jednej operacji. Metoda zwraca <xref:System.Threading.Tasks.Task> obiekt, który reprezentuje zadania.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run2.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Run#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="action" /> Argument jest <see langword="null" />.</exception>
        <altmember cref="M:System.Threading.Tasks.Task.Run(System.Action)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action ^ action, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="action">Delegat, który reprezentuje kod do wykonania w zadaniu.</param>
        <param name="cancellationToken">
          <see cref="T:System.Threading.CancellationToken" /> Który odbywa się nowe zadania.</param>
        <summary>Inicjuje nowy <see cref="T:System.Threading.Tasks.Task" /> z określoną akcję i <see cref="T:System.Threading.CancellationToken" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zamiast wywoływania najczęściej ten konstruktor do tworzenia wystąpienia <xref:System.Threading.Tasks.Task> obiektu, a następnie uruchom zadanie jest wywołując statycznych <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> i <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> metody. Zaletą tylko oferowane przez ten konstruktor jest możliwość tworzenia wystąpienia obiektu od wywołanie zadania.  
  
 Aby uzyskać więcej informacji, zobacz [równoległość zadań (Biblioteka zadań równoległych)](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md) i [anulowanie w zarządzanych wątkach](~/docs/standard/threading/cancellation-in-managed-threads.md).  
  
   
  
## Examples  
 Następujące przykładowe wywołania <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%2CSystem.Threading.CancellationToken%29> konstruktora, aby utworzyć zadanie, który iteruje po plików w katalogu C:\Windows\System32. Wywołania wyrażenia lambda <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> metody w celu dodania informacji o poszczególnych plików do <xref:System.Collections.Generic.List%601> obiektu. Odłączyć każdego zadania zagnieżdżonego wywoływane przez <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> pętli sprawdza stan token anulowania i, jeśli żądanie anulowania wywołuje <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> metody. <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> Metoda zgłasza <xref:System.OperationCanceledException> wyjątek, który jest obsługiwany w `catch` zablokować, jeśli wątek wywołujący wywołuje <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> metody.  <xref:System.Threading.Tasks.Task.Start%2A> Wywoływana jest metoda następnie uruchomić zadanie.  
  
 [!code-csharp[System.Threading.Tasks.Task.ctor#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/cs/run4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.ctor#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/vb/run4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Podana <see cref="T:System.Threading.CancellationToken" /> został już usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="action" /> Argument ma wartość null.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action ^ action, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">Delegat, który reprezentuje kod do wykonania w zadaniu.</param>
        <param name="creationOptions">
          <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> Pozwala dostosować zachowanie zadania.</param>
        <summary>Inicjuje nowy <see cref="T:System.Threading.Tasks.Task" /> z podanych opcji działania i tworzenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zamiast wywoływania najczęściej ten konstruktor do tworzenia wystąpienia <xref:System.Threading.Tasks.Task> obiektu, a następnie uruchom zadanie jest wywołując statycznych <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType> metody. Zaletą tylko oferowane przez ten konstruktor jest możliwość tworzenia wystąpienia obiektu od wywołanie zadania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="action" /> Argument ma wartość null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="creationOptions" /> Argument określa nieprawidłową wartość <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (action As Action(Of Object), state As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="action">Delegat, który reprezentuje kod do wykonania w zadaniu.</param>
        <param name="state">Obiekt reprezentujący dane mają być używane przez akcję.</param>
        <summary>Inicjuje nowy <see cref="T:System.Threading.Tasks.Task" /> z określonej wartości atrybutu akcji i stanu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zamiast wywoływania najczęściej ten konstruktor do tworzenia wystąpienia <xref:System.Threading.Tasks.Task> obiektu, a następnie uruchom zadanie jest wywołując statycznych <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%29?displayProperty=nameWithType> metody. Zaletą tylko oferowane przez ten konstruktor jest możliwość tworzenia wystąpienia obiektu od wywołanie zadania.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano tablicę wyrazów 6. Każdego wyrazu są następnie przekazywane jako argument <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%7BSystem.Object%7D%2CSystem.Object%29> konstruktora, których <xref:System.Action%601> delegata zaszyfrowanie znaki w wyrazie, a następnie wyświetla oryginalnego programu word i jego wersja zaszyfrowany.  
  
 [!code-csharp[System.Threading.Tasks.Task.ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/cs/startnew3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.ctor#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/vb/startnew3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="action" /> Argument ma wartość null.</exception>
        <altmember cref="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action ^ action, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">Delegat, który reprezentuje kod do wykonania w zadaniu.</param>
        <param name="cancellationToken">
          <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> Który odbywa się nowe zadania.</param>
        <param name="creationOptions">
          <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> Pozwala dostosować zachowanie zadania.</param>
        <summary>Inicjuje nowy <see cref="T:System.Threading.Tasks.Task" /> z podanych opcji działania i tworzenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zamiast wywoływania najczęściej ten konstruktor do tworzenia wystąpienia <xref:System.Threading.Tasks.Task> obiektu, a następnie uruchom zadanie jest wywołując statycznych <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType> metody. Zaletą tylko oferowane przez ten konstruktor jest możliwość tworzenia wystąpienia obiektu od wywołanie zadania.  
  
 Aby uzyskać więcej informacji, zobacz [równoległość zadań (Biblioteka zadań równoległych)](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md) i [anulowanie zadania](~/docs/standard/parallel-programming/task-cancellation.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.CancellationTokenSource" /> Utworzony <paramref name="cancellationToken" /> został już usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="action" /> Argument ma wartość null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="creationOptions" /> Argument określa nieprawidłową wartość <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="action">Delegat, który reprezentuje kod do wykonania w zadaniu.</param>
        <param name="state">Obiekt reprezentujący dane mają być używane przez akcję.</param>
        <param name="cancellationToken">
          <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> Czy odbywa się nowe zadania.</param>
        <summary>Inicjuje nowy <see cref="T:System.Threading.Tasks.Task" /> z określonej akcji, stanu i opcje.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zamiast wywoływania najczęściej ten konstruktor do tworzenia wystąpienia <xref:System.Threading.Tasks.Task> obiektu, a następnie uruchom zadanie jest wywołując statycznych <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> metody. Zaletą tylko oferowane przez ten konstruktor jest możliwość tworzenia wystąpienia obiektu od wywołanie zadania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.CancellationTokenSource" /> Utworzony <paramref name="cancellationToken" /> został już usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="action" /> Argument ma wartość null.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (action As Action(Of Object), state As Object, creationOptions As TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">Delegat, który reprezentuje kod do wykonania w zadaniu.</param>
        <param name="state">Obiekt reprezentujący dane mają być używane przez akcję.</param>
        <param name="creationOptions">
          <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> Pozwala dostosować zachowanie zadania.</param>
        <summary>Inicjuje nowy <see cref="T:System.Threading.Tasks.Task" /> z określonej akcji, stanu i opcje.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zamiast wywoływania najczęściej ten konstruktor do tworzenia wystąpienia <xref:System.Threading.Tasks.Task> obiektu, a następnie uruchom zadanie jest wywołując statycznych <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType> metody. Zaletą tylko oferowane przez ten konstruktor jest możliwość tworzenia wystąpienia obiektu od wywołanie zadania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="action" /> Argument ma wartość null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="creationOptions" /> Argument określa nieprawidłową wartość <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">Delegat, który reprezentuje kod do wykonania w zadaniu.</param>
        <param name="state">Obiekt reprezentujący dane mają być używane przez akcję.</param>
        <param name="cancellationToken">
          <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> Czy odbywa się nowe zadania.</param>
        <param name="creationOptions">
          <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> Pozwala dostosować zachowanie zadania.</param>
        <summary>Inicjuje nowy <see cref="T:System.Threading.Tasks.Task" /> z określonej akcji, stanu i opcje.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zamiast wywoływania najczęściej ten konstruktor do tworzenia wystąpienia <xref:System.Threading.Tasks.Task> obiektu, a następnie uruchom zadanie jest wywołując statycznych <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType> metody. Zaletą tylko oferowane przez ten konstruktor jest możliwość tworzenia wystąpienia obiektu od wywołanie zadania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.CancellationTokenSource" /> Utworzony <paramref name="cancellationToken" /> został już usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="action" /> Argument ma wartość null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="creationOptions" /> Argument określa nieprawidłową wartość <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AsyncState">
      <MemberSignature Language="C#" Value="public object AsyncState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object AsyncState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.AsyncState" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AsyncState As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ AsyncState { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.AsyncState</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera obiekt stanu podane podczas <see cref="T:System.Threading.Tasks.Task" /> został utworzony, lub wartość null, jeśli nie została podana.</summary>
        <value>
          <see cref="T:System.Object" /> Reprezentujący dane o stanie został przekazany do zadania podczas jej tworzenia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rzutowanie tego obiektu do oryginalnego typu można pobrać danych.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompletedTask">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task CompletedTask { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.Task CompletedTask" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.CompletedTask" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CompletedTask As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::Task ^ CompletedTask { System::Threading::Tasks::Task ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera zadanie, które zostało już zakończone pomyślnie.</summary>
        <value>Pomyślnie zakończono zadanie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zwraca klasę task, których <xref:System.Threading.Tasks.Task.Status%2A> właściwość jest ustawiona na <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>. Aby utworzyć zadanie, które zwraca wartość i jest uruchamiane w celu ukończenia, należy wywołać <xref:System.Threading.Tasks.Task.FromResult%2A> metody.  
  
 Zawsze powtarzane próbuje pobrać wartość tej właściwości nie może zwracać tego samego wystąpienia.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Tasks.Task.FromResult``1(``0)" />
      </Docs>
    </Member>
    <Member MemberName="ConfigureAwait">
      <MemberSignature Language="C#" Value="public System.Runtime.CompilerServices.ConfiguredTaskAwaitable ConfigureAwait (bool continueOnCapturedContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Runtime.CompilerServices.ConfiguredTaskAwaitable ConfigureAwait(bool continueOnCapturedContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ConfigureAwait(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConfigureAwait (continueOnCapturedContext As Boolean) As ConfiguredTaskAwaitable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::CompilerServices::ConfiguredTaskAwaitable ConfigureAwait(bool continueOnCapturedContext);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.CompilerServices.ConfiguredTaskAwaitable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continueOnCapturedContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="continueOnCapturedContext">
          <see langword="true" /> próba zorganizowania kontynuacji z powrotem do oryginalnego kontekście przechwycone; w przeciwnym razie <see langword="false" />.</param>
        <summary>Konfiguruje awaiter umożliwia to await <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <returns>Obiekt używany do await to zadanie.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ContinueWith">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy kontynuacji, która wykonuje asynchronicznie podczas docelowy <see cref="T:System.Threading.Tasks.Task" /> zakończeniu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task)) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Akcje, kiedy <see cref="T:System.Threading.Tasks.Task" /> zakończeniu. Podczas uruchamiania, delegat zostaną przekazane ukończonego zadania jako argument.</param>
        <summary>Tworzy kontynuacji, która wykonuje asynchronicznie podczas docelowy <see cref="T:System.Threading.Tasks.Task" /> zakończeniu.</summary>
        <returns>Nowe kontynuacji <see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócona <xref:System.Threading.Tasks.Task> nie są planowane do wykonania dopiero po ukończeniu bieżącego zadania, czy jego zakończenie z powodu pomyślnie wykonywane ukończenia, powodujący błąd z powodu nieobsługiwanego wyjątku lub zamykanie się wcześniej z powodu anulowania.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano klasę task, która wypełnia tablicy o 100 losowych wartości daty i godziny. Używa <xref:System.Threading.Tasks.Task.ContinueWith%28System.Action%7BSystem.Threading.Tasks.Task%7D%29> metodę, aby wybrać wcześniej niż i najnowszej wartości daty, gdy tablica jest całkowicie wypełnione.  
  
 [!code-csharp[System.Threading.Tasks.Task.ContinueWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.continuewith/cs/continuewith1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.ContinueWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.continuewith/vb/continuewith1.vb#1)]  
  
 Ponieważ aplikacji konsoli może zakończyć się przed wykonaniem zadania kontynuacji, <xref:System.Threading.Tasks.Task.Wait> metoda jest wywoływana, aby upewnić się, że kontynuowanie kończy wykonywanie przed zakończeniem przykład.  
  
 Na przykład dodatkowe zobacz [tworzenie łańcuchów zadań przy użyciu zadań kontynuacji](~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationAction" /> Argument jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task, Object), state As Object) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Akcja do uruchomienia po zakończeniu zadania. Podczas uruchamiania, delegat jest przekazywany jako argumenty ukończonego zadania i obiektu stanu dostarczony przez obiekt wywołujący.</param>
        <param name="state">Obiekt reprezentujący dane mają być używane przez akcję kontynuacji.</param>
        <summary>Tworzy utrzymania otrzymuje informacje o stanie dostarczony przez obiekt wywołujący, który wykonuje, gdy element docelowy <see cref="T:System.Threading.Tasks.Task" /> zakończeniu.</summary>
        <returns>Utworzenie nowego zadania kontynuacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócona <xref:System.Threading.Tasks.Task> nie są planowane do wykonania dopiero po ukończeniu bieżącego zadania, czy jego zakończenie z powodu pomyślnie wykonywane ukończenia, powodujący błąd z powodu nieobsługiwanego wyjątku lub wcześniej został zakończony z powodu anulowania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationAction" /> Argument jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Akcje, kiedy <see cref="T:System.Threading.Tasks.Task" /> zakończeniu. Podczas uruchamiania, delegat zostaną przekazane ukończonego zadania jako argument.</param>
        <param name="cancellationToken">
          <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> Który zostanie przypisany do nowego zadania kontynuacji.</param>
        <summary>Tworzy kontynuacji, który odbiera token anulowania i wykonuje asynchronicznie podczas docelowy <see cref="T:System.Threading.Tasks.Task" /> zakończeniu.</summary>
        <returns>Nowe kontynuacji <see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócona <xref:System.Threading.Tasks.Task> nie są planowane do wykonania dopiero po ukończeniu bieżącego zadania, czy jego zakończenie z powodu pomyślnie wykonywane ukończenia, powodujący błąd z powodu nieobsługiwanego wyjątku lub zamykanie się wcześniej z powodu anulowania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.CancellationTokenSource" /> Utworzony token został już usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationAction" /> Argument ma wartość null.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task), continuationOptions As TaskContinuationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Akcję w celu uruchomienia zgodnie z określonym <c>continuationOptions</c>. Podczas uruchamiania, delegat zostaną przekazane ukończonego zadania jako argument.</param>
        <param name="continuationOptions">Opcje kiedy zaplanowano kontynuacji i jak działa. Obejmuje to kryteria, takich jak <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, a także opcje wykonywania, takie jak <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <summary>Tworzy utrzymania wykonywany po zakończeniu zadania docelowej zgodnie z określonym <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</summary>
        <returns>Nowe kontynuacji <see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócona <xref:System.Threading.Tasks.Task> nie zostanie zaplanowane do uruchomienia, dopiero po ukończeniu bieżącego zadania. Jeśli określone kryteria kontynuacji za pośrednictwem `continuationOptions` parametru nie są spełnione, zostanie anulowane zadania kontynuacji zamiast zaplanowane.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, za pomocą <xref:System.Threading.Tasks.TaskContinuationOptions> do określenia, czy zadania kontynuacji powinny być wykonywane synchronicznie po zakończeniu poprzedzających zadania. (Jeśli określonego zadania została już zakończona w czasie <xref:System.Threading.Tasks.Task.ContinueWith%2A> po wywołaniu synchroniczne kontynuacji będzie uruchamiany na wywołania wątku <xref:System.Threading.Tasks.Task.ContinueWith%2A>.)  
  
```csharp  
  
public class TaskCounter  
{  
   private volatile int _count;  
  
   public void Track(Task t)  
   {  
      if (t == null) throw new ArgumentNullException("t");  
      Interlocked.Increment(ref _count);  
      t.ContinueWith(ct => Interlocked.Decrement(ref _count), TaskContinuationOptions.ExecuteSynchronously);  
   }  
  
   public int NumberOfActiveTasks { get { return _count; } }  
}  
  
```  
  
```vb  
  
Public Class TaskCounter  
   Private _count as Integer  
  
   Public Sub Track(ByVal t as Task)  
      If t is Nothing Then Throw New ArgumentNullException("t")  
      Interlocked.Increment(_count)  
      t.ContinueWith(Sub(ct)  
                        Interlocked.Decrement(_count)  
                     End Sub,  
                     TaskContinuationOptions.ExecuteSynchronously)  
   End Sub  
  
   Public ReadOnly Property NumberOfActiveTasks As Integer  
      Get  
         Return _count  
      End Get  
   End Property  
End Class  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationAction" /> Argument ma wartość null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="continuationOptions" /> Argument określa nieprawidłową wartość <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task), scheduler As TaskScheduler) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Akcje, kiedy <see cref="T:System.Threading.Tasks.Task" /> zakończeniu. Podczas uruchamiania, delegat zostaną przekazane ukończonego zadania jako argument.</param>
        <param name="scheduler">
          <see cref="T:System.Threading.Tasks.TaskScheduler" /> Do skojarzenia z zadania kontynuacji i do użycia podczas jego wykonywania.</param>
        <summary>Tworzy kontynuacji, która wykonuje asynchronicznie podczas docelowy <see cref="T:System.Threading.Tasks.Task" /> zakończeniu. Kontynuacja używa określonego harmonogramu.</summary>
        <returns>Nowe kontynuacji <see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócona <xref:System.Threading.Tasks.Task> nie są planowane do wykonania dopiero po ukończeniu bieżącego zadania, czy jego zakończenie z powodu pomyślnie wykonywane ukończenia, powodujący błąd z powodu nieobsługiwanego wyjątku lub zamykanie się wcześniej z powodu anulowania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> Został usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationAction" /> Argument jest <see langword="null" />.  
  
 —lub—  
  
 <paramref name="scheduler" /> Argument ma wartość null.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Akcje, kiedy <see cref="T:System.Threading.Tasks.Task" /> zakończeniu. Podczas uruchamiania, delegat zostaną przekazane ukończonego zadania i obiektu stanu dostarczony przez obiekt wywołujący, jako argumenty.</param>
        <param name="state">Obiekt reprezentujący dane mają być używane przez akcję kontynuacji.</param>
        <param name="cancellationToken">
          <see cref="T:System.Threading.CancellationToken" /> Który zostanie przypisany do nowego zadania kontynuacji.</param>
        <summary>Tworzy kontynuacji, który odbiera informacje o stanie dostarczony przez obiekt wywołujący i token anulowania i który wykonuje asynchronicznie podczas docelowy <see cref="T:System.Threading.Tasks.Task" /> zakończeniu.</summary>
        <returns>Nowe kontynuacji <see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócona <xref:System.Threading.Tasks.Task> nie są planowane do wykonania dopiero po ukończeniu bieżącego zadania, czy jego zakończenie z powodu pomyślnie wykonywane ukończenia, powodujący błąd z powodu nieobsługiwanego wyjątku lub zamykanie się wcześniej z powodu anulowania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationAction" /> Argument jest <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Podana <see cref="T:System.Threading.CancellationToken" /> został już usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task, Object), state As Object, continuationOptions As TaskContinuationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Akcje, kiedy <see cref="T:System.Threading.Tasks.Task" /> zakończeniu. Podczas uruchamiania, delegat zostaną przekazane ukończonego zadania i obiektu stanu dostarczony przez obiekt wywołujący, jako argumenty.</param>
        <param name="state">Obiekt reprezentujący dane mają być używane przez akcję kontynuacji.</param>
        <param name="continuationOptions">Opcje kiedy zaplanowano kontynuacji i jak działa. Obejmuje to kryteria, takich jak <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, a także opcje wykonywania, takie jak <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <summary>Tworzy utrzymania otrzymuje informacje o stanie dostarczony przez obiekt wywołujący, który wykonuje, gdy element docelowy <see cref="T:System.Threading.Tasks.Task" /> zakończeniu. Wykonuje kontynuacji na podstawie zestawu określonego warunku.</summary>
        <returns>Nowe kontynuacji <see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócona <xref:System.Threading.Tasks.Task> nie zostanie zaplanowane do uruchomienia, dopiero po ukończeniu bieżącego zadania. Jeśli określone kryteria kontynuacji za pośrednictwem `continuationOptions` parametru nie są spełnione, zostanie anulowane zadania kontynuacji zamiast zaplanowane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationAction" /> Argument jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="continuationOptions" /> Argument określa nieprawidłową wartość <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task, Object), state As Object, scheduler As TaskScheduler) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Akcje, kiedy <see cref="T:System.Threading.Tasks.Task" /> zakończeniu.  Podczas uruchamiania, delegat zostaną przekazane ukończonego zadania i obiektu stanu dostarczony przez obiekt wywołujący, jako argumenty.</param>
        <param name="state">Obiekt reprezentujący dane mają być używane przez akcję kontynuacji.</param>
        <param name="scheduler">
          <see cref="T:System.Threading.Tasks.TaskScheduler" /> Do skojarzenia z zadania kontynuacji i do użycia podczas jego wykonywania.</param>
        <summary>Tworzy utrzymania otrzymuje informacje o stanie dostarczony przez obiekt wywołujący, który wykonuje asynchronicznie podczas docelowy <see cref="T:System.Threading.Tasks.Task" /> zakończeniu. Kontynuacja używa określonego harmonogramu.</summary>
        <returns>Nowe kontynuacji <see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócona <xref:System.Threading.Tasks.Task> nie są planowane do wykonania dopiero po ukończeniu bieżącego zadania, czy jego zakończenie z powodu pomyślnie wykonywane ukończenia, powodujący błąd z powodu nieobsługiwanego wyjątku lub zamykanie się wcześniej z powodu anulowania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="scheduler" /> Argument jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Akcję w celu uruchomienia zgodnie z określonym <c>continuationOptions</c>. Podczas uruchamiania, delegat zostaną przekazane ukończonego zadania jako argument.</param>
        <param name="cancellationToken">
          <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> Który zostanie przypisany do nowego zadania kontynuacji.</param>
        <param name="continuationOptions">Opcje kiedy zaplanowano kontynuacji i jak działa. Obejmuje to kryteria, takich jak <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, a także opcje wykonywania, takie jak <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <param name="scheduler">
          <see cref="T:System.Threading.Tasks.TaskScheduler" /> Do skojarzenia z zadania kontynuacji i do użycia podczas jego wykonywania.</param>
        <summary>Tworzy kontynuacji, który wykonuje się, gdy zadanie docelowe konkuruje zgodnie z określonym <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />. Utrzymanie odbiera token anulowania i używa określonego harmonogramu.</summary>
        <returns>Nowe kontynuacji <see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócona <xref:System.Threading.Tasks.Task> nie zostanie zaplanowane do uruchomienia, dopiero po ukończeniu bieżącego zadania. Jeśli kryteria określone przez `continuationOptions` parametru nie są spełnione, zostanie anulowane zadania kontynuacji zamiast zaplanowane.  
  
   
  
## Examples  
 Oto przykład za pomocą polecenia ContinueWith uruchomienia pracy zarówno w tle, jak i użytkownik wątków interfejsu.  
  
```csharp  
  
private void Button1_Click(object sender, EventArgs e)  
{  
   var backgroundScheduler = TaskScheduler.Default;  
   var uiScheduler = TaskScheduler.FromCurrentSynchronizationContext();  
   Task.Factory.StartNew(delegate { DoBackgroundComputation(); },  
                         backgroundScheduler).  
   ContinueWith(delegate { UpdateUI(); }, uiScheduler).  
                ContinueWith(delegate { DoAnotherBackgroundComputation(); },  
                             backgroundScheduler).  
                ContinueWith(delegate { UpdateUIAgain(); }, uiScheduler);  
}  
  
```  
  
```vb  
  
Private Sub Button1_Click(ByVal sender As System.Object,   
                          ByVal e As System.EventArgs) Handles Button1.Click  
   Dim backgroundScheduler = TaskScheduler.Default  
   Dim uiScheduler = TaskScheduler.FromCurrentSynchronizationContext()  
  
   Task.Factory.StartNew(Sub()  
                           DoBackgroundComputation()  
                         End Sub, backgroundScheduler).ContinueWith(Sub(t)  
                            UpdateUI()  
                         End Sub, uiScheduler).ContinueWith(Sub(t)  
                            DoAnotherBackgroundComputation()  
                         End Sub, backgroundScheduler).ContinueWith(Sub(t)  
                            UpdateUIAgain()  
                         End Sub, uiScheduler)  
End Sub  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.CancellationTokenSource" /> Utworzony token został już usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationAction" /> Argument ma wartość null.  
  
 —lub—  
  
 <paramref name="scheduler" /> Argument ma wartość null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="continuationOptions" /> Argument określa nieprawidłową wartość <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Akcje, kiedy <see cref="T:System.Threading.Tasks.Task" /> zakończeniu. Podczas uruchamiania, delegat zostaną przekazane ukończonego zadania i obiektu stanu dostarczony przez obiekt wywołujący, jako argumenty.</param>
        <param name="state">Obiekt reprezentujący dane mają być używane przez akcję kontynuacji.</param>
        <param name="cancellationToken">
          <see cref="T:System.Threading.CancellationToken" /> Który zostanie przypisany do nowego zadania kontynuacji.</param>
        <param name="continuationOptions">Opcje kiedy zaplanowano kontynuacji i jak działa. Obejmuje to kryteria, takich jak <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, a także opcje wykonywania, takie jak <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <param name="scheduler">
          <see cref="T:System.Threading.Tasks.TaskScheduler" /> Do skojarzenia z zadania kontynuacji i do użycia podczas jego wykonywania.</param>
        <summary>Tworzy kontynuacji, który odbiera informacje o stanie dostarczony przez obiekt wywołujący i token anulowania i, który jest wykonywany kiedy element docelowy <see cref="T:System.Threading.Tasks.Task" /> zakończeniu. Wykonuje kontynuacji na podstawie zestawu określone warunki i używa określonego harmonogramu.</summary>
        <returns>Nowe kontynuacji <see cref="T:System.Threading.Tasks.Task" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócona <xref:System.Threading.Tasks.Task> nie zostanie zaplanowane do uruchomienia, dopiero po ukończeniu bieżącego zadania. Jeśli kryteria określone przez `continuationOptions` parametru nie są spełnione, zostanie anulowane zadania kontynuacji zamiast zaplanowane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="scheduler" /> Argument jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="continuationOptions" /> Argument określa nieprawidłową wartość <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Podana <see cref="T:System.Threading.CancellationToken" /> został już usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, TResult)) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ wyniku utworzonego przez kontynuacji.</typeparam>
        <param name="continuationFunction">Funkcja uruchomiony, jeśli <see cref="T:System.Threading.Tasks.Task`1" /> zakończeniu. Podczas uruchamiania, delegat zostaną przekazane ukończonego zadania jako argument.</param>
        <summary>Tworzy kontynuacji, która wykonuje asynchronicznie podczas docelowy <see cref="T:System.Threading.Tasks.Task`1" /> kończy i zwraca wartość.</summary>
        <returns>Utworzenie nowego zadania kontynuacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócona <xref:System.Threading.Tasks.Task%601> nie są planowane do wykonania dopiero po ukończeniu bieżącego zadania, czy jego zakończenie z powodu pomyślnie wykonywane ukończenia, powodujący błąd z powodu nieobsługiwanego wyjątku lub zamykanie się wcześniej z powodu anulowania.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie metody ContinueWith:  
  
 [!code-csharp[System.Threading.Tasks.Task#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/continuationsimple.cs#03)]
 [!code-vb[System.Threading.Tasks.Task#03](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/continuationsimple.vb#03)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> Został usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationFunction" /> Argument ma wartość null.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, Object, TResult), state As Object) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ wyniku utworzonego przez kontynuacji.</typeparam>
        <param name="continuationFunction">Funkcja uruchomiony, jeśli <see cref="T:System.Threading.Tasks.Task" /> zakończeniu. Podczas uruchamiania, delegat zostaną przekazane ukończonego zadania i obiektu stanu dostarczony przez obiekt wywołujący, jako argumenty.</param>
        <param name="state">Obiekt reprezentujący dane mają być używane przez funkcję kontynuacji.</param>
        <summary>Kontynuacja otrzymuje informacje o stanie dostarczony przez obiekt wywołujący, który wykonuje asynchronicznie tworzy gdy element docelowy <see cref="T:System.Threading.Tasks.Task" /> kończy i zwraca wartość.</summary>
        <returns>Nowe kontynuacji <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócona <xref:System.Threading.Tasks.Task%601> nie są planowane do wykonania dopiero po ukończeniu bieżącego zadania, czy jego zakończenie z powodu pomyślnie wykonywane ukończenia, powodujący błąd z powodu nieobsługiwanego wyjątku lub zamykanie się wcześniej z powodu anulowania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationFunction" /> Argument jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ wyniku utworzonego przez kontynuacji.</typeparam>
        <param name="continuationFunction">Funkcja uruchomiony, jeśli <see cref="T:System.Threading.Tasks.Task" /> zakończeniu. Podczas uruchamiania, delegat zostaną przekazane ukończonego zadania jako argument.</param>
        <param name="cancellationToken">
          <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> Który zostanie przypisany do nowego zadania kontynuacji.</param>
        <summary>Tworzy kontynuacji, która wykonuje asynchronicznie podczas docelowy <see cref="T:System.Threading.Tasks.Task" /> kończy i zwraca wartość. Kontynuacja odbiera token anulowania.</summary>
        <returns>Nowe kontynuacji <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócona <xref:System.Threading.Tasks.Task%601> nie są planowane do wykonania dopiero po ukończeniu bieżącego zadania, czy jego zakończenie z powodu pomyślnie wykonywane ukończenia, powodujący błąd z powodu nieobsługiwanego wyjątku lub zamykanie się wcześniej z powodu anulowania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> Został usunięty.  
  
 —lub—  
  
 <see cref="T:System.Threading.CancellationTokenSource" /> Utworzony token został już usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationFunction" /> Argument ma wartość null.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, TResult), continuationOptions As TaskContinuationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ wyniku utworzonego przez kontynuacji.</typeparam>
        <param name="continuationFunction">Funkcja Uruchamianie zgodnie z warunek określony w <c>continuationOptions</c>. Podczas uruchamiania, delegat zostaną przekazane ukończonego zadania jako argument.</param>
        <param name="continuationOptions">Opcje kiedy zaplanowano kontynuacji i jak działa. Obejmuje to kryteria, takich jak <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, a także opcje wykonywania, takie jak <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <summary>Tworzy kontynuacji, który wykonuje zgodnie z opcjami określonego kontynuacji i zwraca wartość.</summary>
        <returns>Nowe kontynuacji <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócona <xref:System.Threading.Tasks.Task%601> nie zostanie zaplanowane do uruchomienia, dopiero po ukończeniu bieżącego zadania. Jeśli określone kryteria kontynuacji za pośrednictwem `continuationOptions` parametru nie są spełnione, zostanie anulowane zadania kontynuacji zamiast zaplanowane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> Został usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationFunction" /> Argument ma wartość null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="continuationOptions" /> Argument określa nieprawidłową wartość <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, TResult), scheduler As TaskScheduler) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ wyniku utworzonego przez kontynuacji.</typeparam>
        <param name="continuationFunction">Funkcja uruchomiony, jeśli <see cref="T:System.Threading.Tasks.Task" /> zakończeniu. Podczas uruchamiania, delegat zostaną przekazane ukończonego zadania jako argument.</param>
        <param name="scheduler">
          <see cref="T:System.Threading.Tasks.TaskScheduler" /> Do skojarzenia z zadania kontynuacji i do użycia podczas jego wykonywania.</param>
        <summary>Tworzy kontynuacji, która wykonuje asynchronicznie podczas docelowy <see cref="T:System.Threading.Tasks.Task" /> kończy i zwraca wartość. Kontynuacja używa określonego harmonogramu.</summary>
        <returns>Nowe kontynuacji <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócona <xref:System.Threading.Tasks.Task%601> nie są planowane do wykonania dopiero po ukończeniu bieżącego zadania, czy jego zakończenie z powodu pomyślnie wykonywane ukończenia, powodujący błąd z powodu nieobsługiwanego wyjątku lub zamykanie się wcześniej z powodu anulowania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> Został usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationFunction" /> Argument ma wartość null.  
  
 —lub—  
  
 <paramref name="scheduler" /> Argument ma wartość null.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ wyniku utworzonego przez kontynuacji.</typeparam>
        <param name="continuationFunction">Funkcja uruchomiony, jeśli <see cref="T:System.Threading.Tasks.Task" /> zakończeniu. Podczas uruchamiania, delegat zostaną przekazane ukończonego zadania i obiektu stanu dostarczony przez obiekt wywołujący, jako argumenty.</param>
        <param name="state">Obiekt reprezentujący dane mają być używane przez funkcję kontynuacji.</param>
        <param name="cancellationToken">
          <see cref="T:System.Threading.CancellationToken" /> Który zostanie przypisany do nowego zadania kontynuacji.</param>
        <summary>Tworzy kontynuacji, która wykonuje asynchronicznie podczas docelowy <see cref="T:System.Threading.Tasks.Task" /> kończy i zwraca wartość. Kontynuacja otrzymuje informacje o stanie dostarczony przez obiekt wywołujący i token anulowania.</summary>
        <returns>Nowe kontynuacji <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócona <xref:System.Threading.Tasks.Task%601> nie są planowane do wykonania dopiero po ukończeniu bieżącego zadania, czy jego zakończenie z powodu pomyślnie wykonywane ukończenia, powodujący błąd z powodu nieobsługiwanego wyjątku lub zamykanie się wcześniej z powodu anulowania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationFunction" /> Argument jest <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Podana <see cref="T:System.Threading.CancellationToken" /> został już usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, Object, TResult), state As Object, continuationOptions As TaskContinuationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ wyniku utworzonego przez kontynuacji.</typeparam>
        <param name="continuationFunction">Funkcja uruchomiony, jeśli <see cref="T:System.Threading.Tasks.Task" /> zakończeniu. Podczas uruchamiania, delegat zostaną przekazane ukończonego zadania i obiektu stanu dostarczony przez obiekt wywołujący, jako argumenty.</param>
        <param name="state">Obiekt reprezentujący dane mają być używane przez funkcję kontynuacji.</param>
        <param name="continuationOptions">Opcje kiedy zaplanowano kontynuacji i jak działa. Obejmuje to kryteria, takich jak <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, a także opcje wykonywania, takie jak <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <summary>Tworzy kontynuacji wykonuje w oparciu o określonym zadań kontynuacji opcji, gdy element docelowy <see cref="T:System.Threading.Tasks.Task" /> zakończeniu. Kontynuacja otrzymuje informacje o stanie dostarczony przez obiekt wywołujący.</summary>
        <returns>Nowe kontynuacji <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócona <xref:System.Threading.Tasks.Task%601> nie zostanie zaplanowane do uruchomienia, dopiero po ukończeniu bieżącego zadania. Jeśli określone kryteria kontynuacji za pośrednictwem `continuationOptions` parametru nie są spełnione, zostanie anulowane zadania kontynuacji zamiast zaplanowane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationFunction" /> Argument jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="continuationOptions" /> Argument określa nieprawidłową wartość <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, Object, TResult), state As Object, scheduler As TaskScheduler) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ wyniku utworzonego przez kontynuacji.</typeparam>
        <param name="continuationFunction">Funkcja uruchomiony, jeśli <see cref="T:System.Threading.Tasks.Task" /> zakończeniu.  Podczas uruchamiania, delegat zostaną przekazane ukończonego zadania i obiektu stanu dostarczony przez obiekt wywołujący, jako argumenty.</param>
        <param name="state">Obiekt reprezentujący dane mają być używane przez funkcję kontynuacji.</param>
        <param name="scheduler">
          <see cref="T:System.Threading.Tasks.TaskScheduler" /> Do skojarzenia z zadania kontynuacji i do użycia podczas jego wykonywania.</param>
        <summary>Tworzy kontynuacji, która wykonuje asynchronicznie podczas docelowy <see cref="T:System.Threading.Tasks.Task" /> zakończeniu. Kontynuacja odbiera informacje o stanie dostarczony przez obiekt wywołujący i używa określonego harmonogramu.</summary>
        <returns>Nowe kontynuacji <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócona <xref:System.Threading.Tasks.Task%601> nie są planowane do wykonania dopiero po ukończeniu bieżącego zadania, czy jego zakończenie z powodu pomyślnie wykonywane ukończenia, powodujący błąd z powodu nieobsługiwanego wyjątku lub zamykanie się wcześniej z powodu anulowania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="scheduler" /> Argument jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ wyniku utworzonego przez kontynuacji.</typeparam>
        <param name="continuationFunction">Funkcja Uruchamianie zgodnie z określonym <c>continuationOptions.</c> Podczas uruchamiania, delegat zostaną przekazane ukończonego zadania jako argument.</param>
        <param name="cancellationToken">
          <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> Który zostanie przypisany do nowego zadania kontynuacji.</param>
        <param name="continuationOptions">Opcje kiedy zaplanowano kontynuacji i jak działa. Obejmuje to kryteria, takich jak <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, a także opcje wykonywania, takie jak <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <param name="scheduler">
          <see cref="T:System.Threading.Tasks.TaskScheduler" /> Do skojarzenia z zadania kontynuacji i do użycia podczas jego wykonywania.</param>
        <summary>Tworzy kontynuacji, który wykonuje zgodnie z opcjami określonego kontynuacji i zwraca wartość. Kontynuacja jest przekazany token anulowania i używa określonego harmonogramu.</summary>
        <returns>Nowe kontynuacji <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócona <xref:System.Threading.Tasks.Task%601> nie zostanie zaplanowane do uruchomienia, dopiero po ukończeniu bieżącego zadania. Jeśli kryteria określone przez `continuationOptions` parametru nie są spełnione, zostanie anulowane zadania kontynuacji zamiast zaplanowane.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie metody ContinueWith z opcjami kontynuacji:  
  
 [!code-csharp[System.Threading.Tasks.Task#04](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/continuationoptions.cs#04)]
 [!code-vb[System.Threading.Tasks.Task#04](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/continuationoptions.vb#04)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> Został usunięty.  
  
 —lub—  
  
 <see cref="T:System.Threading.CancellationTokenSource" /> Utworzony token został już usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationFunction" /> Argument ma wartość null.  
  
 —lub—  
  
 <paramref name="scheduler" /> Argument ma wartość null.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="continuationOptions" /> Argument określa nieprawidłową wartość <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ wyniku utworzonego przez kontynuacji.</typeparam>
        <param name="continuationFunction">Funkcja uruchomiony, jeśli <see cref="T:System.Threading.Tasks.Task" /> zakończeniu. Podczas uruchamiania, delegat zostaną przekazane ukończonego zadania i obiektu stanu dostarczony przez obiekt wywołujący, jako argumenty.</param>
        <param name="state">Obiekt reprezentujący dane mają być używane przez funkcję kontynuacji.</param>
        <param name="cancellationToken">
          <see cref="T:System.Threading.CancellationToken" /> Który zostanie przypisany do nowego zadania kontynuacji.</param>
        <param name="continuationOptions">Opcje kiedy zaplanowano kontynuacji i jak działa. Obejmuje to kryteria, takich jak <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, a także opcje wykonywania, takie jak <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <param name="scheduler">
          <see cref="T:System.Threading.Tasks.TaskScheduler" /> Do skojarzenia z zadania kontynuacji i do użycia podczas jego wykonywania.</param>
        <summary>Tworzy kontynuacji wykonuje w oparciu o określonym zadań kontynuacji opcji, gdy element docelowy <see cref="T:System.Threading.Tasks.Task" /> kończy i zwraca wartość. Kontynuacja odbiera informacje o stanie dostarczony przez obiekt wywołujący i token anulowania i używa określonego harmonogramu.</summary>
        <returns>Nowe kontynuacji <see cref="T:System.Threading.Tasks.Task`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwrócona <xref:System.Threading.Tasks.Task%601> nie zostanie zaplanowane do uruchomienia, dopiero po ukończeniu bieżącego zadania. Jeśli kryteria określone przez `continuationOptions` parametru nie są spełnione, zostanie anulowane zadania kontynuacji zamiast zaplanowane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="scheduler" /> Argument jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="continuationOptions" /> Argument określa nieprawidłową wartość <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Podana <see cref="T:System.Threading.CancellationToken" /> został już usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreationOptions">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.TaskCreationOptions CreationOptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.Tasks.TaskCreationOptions CreationOptions" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.CreationOptions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CreationOptions As TaskCreationOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::TaskCreationOptions CreationOptions { System::Threading::Tasks::TaskCreationOptions get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskCreationOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> umożliwia utworzenie tego zadania.</summary>
        <value>
          <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> Umożliwia utworzenie tego zadania.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentId">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; CurrentId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Nullable`1&lt;int32&gt; CurrentId" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.CurrentId" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentId As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Nullable&lt;int&gt; CurrentId { Nullable&lt;int&gt; get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zwraca identyfikator aktualnie wykonywanych <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <value>Liczba całkowita, która została przypisana przez system do aktualnie wykonywanych zadań.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.CurrentId%2A> jest `static` (`Shared` w języku Visual Basic) właściwość, która jest używany do pobierania identyfikator aktualnie wykonywanego zadania z kodu, który wykonuje zadanie. Różni się od <xref:System.Threading.Tasks.Task.Id%2A> właściwość, która zwraca identyfikator określonego <xref:System.Threading.Tasks.Task> wystąpienia. Jeśli próba pobrania <xref:System.Threading.Tasks.Task.CurrentId%2A> wartości z poza kod, który wykonuje zadanie, właściwość ta zwraca `null`.  
  
 Należy pamiętać, że chociaż kolizji są bardzo rzadko, identyfikatory zadań są nie musi być unikatowy.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Threading.Tasks.Task.Id" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Delay">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy zadanie, które zostanie zakończony z pewnym opóźnieniem.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (int millisecondsDelay);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(int32 millisecondsDelay) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Delay (millisecondsDelay As Integer) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Delay(int millisecondsDelay);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsDelay" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsDelay">Liczba milisekund oczekiwania przed wykonaniem zadań zwróconych, lub wartość -1 będzie czekać w nieskończoność.</param>
        <summary>Tworzy zadanie kończące się pewnym opóźnieniem.</summary>
        <returns>Zadanie reprezentujące opóźnienie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Delay%2A> Metoda jest zwykle używana opóźnienia operacji wszystkich lub części zadania dla określonych odstępach czasu. Najczęściej wprowadza się czas opóźnienia:  
  
-   Na początku zadania, jak w poniższym przykładzie przedstawiono.  
  
     [!code-csharp[System.Threading.Tasks.Task.Delay#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay5.cs#5)]
     [!code-vb[System.Threading.Tasks.Task.Delay#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay5.vb#5)]  
  
-   Pewnym czasie, gdy zadanie jest wykonywane. W tym przypadku wywołanie <xref:System.Threading.Tasks.Task.Delay%2A> — metoda wykonuje jako zadania podrzędne zadania, jak przedstawiono na poniższym przykładzie. Należy pamiętać, że od czasu zadania, który odwołuje się <xref:System.Threading.Tasks.Task.Delay%2A> metoda wykonuje asynchronicznie, zadaniem nadrzędnym należy poczekać na jego ukończenie przy użyciu `await` — słowo kluczowe.  
  
     [!code-csharp[System.Threading.Tasks.Task.Delay#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay5.cs#7)]
     [!code-vb[System.Threading.Tasks.Task.Delay#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay5.vb#7)]  
  
 Po upływie określonego czasu opóźnienia, zadanie zostanie ukończone w <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> stanu.  
  
 Ta metoda jest zależna od zegara systemowego. Oznacza to, że czas opóźnienia około będzie równa rozpoznanie zegar systemowy, jeśli `millisecondsDelay` argument jest mniejsza niż rozdzielczość zegar systemowy, czyli około 15 milisekund w systemie Windows.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono użycie prostego <xref:System.Threading.Tasks.Task.Delay%2A> metody.  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Delay#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsDelay" /> Argument jest mniejsza niż -1.</exception>
      </Docs>
    </Member>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (TimeSpan delay);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(valuetype System.TimeSpan delay) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Delay (delay As TimeSpan) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Delay(TimeSpan delay);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delay" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="delay">Przedział czasu oczekiwania przed ukończeniem zadania zwrócone, lub <see langword="TimeSpan.FromMilliseconds(-1)" /> będzie czekać w nieskończoność.</param>
        <summary>Tworzy zadanie kończące się po upływie czasu określonego czasu.</summary>
        <returns>Zadanie reprezentujące opóźnienie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po upływie określonego czasu opóźnienia, zadanie zostanie ukończone w <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> stanu.  
  
 Scenariusze użycia i dodatkowe przykłady, zobacz dokumentację <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> przeciążenia.  
  
 Ta metoda jest zależna od zegara systemowego. Oznacza to, że czas opóźnienia około będzie równa rozpoznanie zegar systemowy, jeśli `delay` argument jest mniejsza niż rozdzielczość zegar systemowy, czyli około 15 milisekund w systemie Windows.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono użycie prostego <xref:System.Threading.Tasks.Task.Delay%2A> metody.  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay2.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.Delay#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="delay" /> reprezentuje innych niż przedział czasu ujemna <see langword="TimeSpan.FromMillseconds(-1)" />.  
  
 —lub—  
  
 <paramref name="delay" /> Argumentu <see cref="P:System.TimeSpan.TotalMilliseconds" /> właściwości jest większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (int millisecondsDelay, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(int32 millisecondsDelay, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Delay(int millisecondsDelay, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsDelay" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="millisecondsDelay">Liczba milisekund oczekiwania przed wykonaniem zadań zwróconych, lub wartość -1 będzie czekać w nieskończoność.</param>
        <param name="cancellationToken">Token anulowania, który będzie sprawdzany przed ukończeniem zwrócone zadania.</param>
        <summary>Tworzy anulowanie zadań, kończące się pewnym opóźnieniem.</summary>
        <returns>Zadanie reprezentujące opóźnienie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli token anulowania jest sygnalizowane przed określony czas opóźnienia, <xref:System.Threading.Tasks.TaskCanceledException> wyjątek wyniki, a zadanie jest wykonywane za <xref:System.Threading.Tasks.TaskStatus.Canceled> stanu.  W przeciwnym razie zadanie zostało ukończone w <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> stanu po upływie określonego czasu opóźnienia.  
  
 Scenariusze użycia i dodatkowe przykłady, zobacz dokumentację <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> przeciążenia.  
  
 Ta metoda jest zależna od zegara systemowego. Oznacza to, że czas opóźnienia około będzie równa rozpoznanie zegar systemowy, jeśli `millisecondsDelay` argument jest mniejsza niż rozdzielczość zegar systemowy, czyli około 15 milisekund w systemie Windows.  
  
   
  
## Examples  
 Poniższy przykład uruchamia zadanie, które zawiera wywołanie <xref:System.Threading.Tasks.Task.Delay%28System.Int32%2CSystem.Threading.CancellationToken%29> metody z opóźnieniem jednej drugiego. Token zostało anulowane, zanim czasu opóźnienia. Dane wyjściowe w przykładzie pokazano, że, w związku z tym, <xref:System.Threading.Tasks.TaskCanceledException> jest zgłaszany i zadań <xref:System.Threading.Tasks.Task.Status%2A> właściwość jest ustawiona na <xref:System.Threading.Tasks.TaskStatus.Canceled>.  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.Delay#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsDelay" /> Argument jest mniejsza niż -1.</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">Zadanie zostało anulowane.</exception>
        <exception cref="T:System.ObjectDisposedException">Podana <paramref name="cancellationToken" /> został już usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (TimeSpan delay, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(valuetype System.TimeSpan delay, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Delay(TimeSpan delay, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delay" Type="System.TimeSpan" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="delay">Przedział czasu oczekiwania przed ukończeniem zadania zwrócone, lub <see langword="TimeSpan.FromMilliseconds(-1)" /> będzie czekać w nieskończoność.</param>
        <param name="cancellationToken">Token anulowania, który będzie sprawdzany przed ukończeniem zwrócone zadania.</param>
        <summary>Tworzy anulowanie zadania kończonego po określonym przedziale czasu.</summary>
        <returns>Zadanie reprezentujące opóźnienie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli token anulowania jest sygnalizowane przed określony czas opóźnienia, <xref:System.Threading.Tasks.TaskCanceledException> wyjątek wyniki, a zadanie jest wykonywane za <xref:System.Threading.Tasks.TaskStatus.Canceled> stanu.  W przeciwnym razie zadanie zostało ukończone w <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> stanu po upływie określonego czasu opóźnienia.  
  
 Scenariusze użycia i dodatkowe przykłady, zobacz dokumentację <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> przeciążenia.  
  
 Ta metoda jest zależna od zegara systemowego. Oznacza to, że czas opóźnienia około będzie równa rozpoznanie zegar systemowy, jeśli `delay` argument jest mniejsza niż rozdzielczość zegar systemowy, czyli około 15 milisekund w systemie Windows.  
  
   
  
## Examples  
 Poniższy przykład uruchamia zadanie, które zawiera wywołanie <xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29> metody z opóźnieniem jednej i pół drugiego. Token zostało anulowane, zanim czasu opóźnienia. Dane wyjściowe w przykładzie pokazano, że, w związku z tym, <xref:System.Threading.Tasks.TaskCanceledException> jest zgłaszany i zadań <xref:System.Threading.Tasks.Task.Status%2A> właściwość jest ustawiona na <xref:System.Threading.Tasks.TaskStatus.Canceled>.  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.Delay#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay4.vb#4)]  
  
 Należy pamiętać, że w tym przykładzie zawiera potencjalnych sytuacji wyścigu: zależy od zadania wykonywania opóźnienie asynchronicznie, gdy token jest anulowane. Mimo że 1,5 sekund opóźnienia z wywołania <xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29> metody założeń tego prawdopodobnie, niemniej jednak możliwe jest który wywołanie <xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29> metody może zwrócić przed token zostało anulowane. W takim przypadku przykładzie tworzy następujące dane wyjściowe:  
  
```  
Task t Status: RanToCompletion, Result: 42  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="delay" /> reprezentuje innych niż przedział czasu ujemna <see langword="TimeSpan.FromMillseconds(-1)" />.  
  
 —lub—  
  
 <paramref name="delay" /> Argumentu <see cref="P:System.TimeSpan.TotalMilliseconds" /> właściwości jest większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">Zadanie zostało anulowane.</exception>
        <exception cref="T:System.ObjectDisposedException">Podana <paramref name="cancellationToken" /> został już usunięty.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwalnia wszelkie zasoby używane przez bieżące wystąpienie klasy <see cref="T:System.Threading.Tasks.Task" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszelkie zasoby używane przez bieżące wystąpienie klasy <see cref="T:System.Threading.Tasks.Task" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task> Klasa implementuje <xref:System.IDisposable> interfejsu, ponieważ wewnętrznie używa zasobów, które również implementują <xref:System.IDisposable>. Jednak zwłaszcza w wypadku celów aplikacji [!INCLUDE[net_v45](~/includes/net-v45-md.md)] lub później, nie jest konieczne do wywołania <xref:System.Threading.Tasks.Task.Dispose%2A> , chyba że wydajności i skalowalności testowania wskazuje, że, oparte na Twoich wzorców użycia, aplikacji może poprawić wydajność przez usuwanie zadań. Aby uzyskać więcej informacji, zobacz [należy dysponować zadań?](http://blogs.msdn.com/b/pfxteam/archive/2012/03/25/10287435.aspx) w programowania równoległego z blogu .NET.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Zadanie nie jest w jednym ze stanów końcowego: <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" />, <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" />, lub <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Wartość logiczna, która wskazuje, czy ta metoda jest wywoływana z powodu wywołania <see cref="M:System.Threading.Tasks.Task.Dispose" />.</param>
        <summary>Usuwa <see cref="T:System.Threading.Tasks.Task" />, zwolnienie wszystkich jej zasobów niezarządzanych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task> Klasa implementuje <xref:System.IDisposable> interfejsu, ponieważ wewnętrznie używa zasobów, które również implementują <xref:System.IDisposable>. Jednak zwłaszcza w wypadku celów aplikacji [!INCLUDE[net_v45](~/includes/net-v45-md.md)] lub później, nie jest konieczne do wywołania <xref:System.Threading.Tasks.Task.Dispose%2A> , chyba że wydajności i skalowalności testowania wskazuje, że, oparte na Twoich wzorców użycia, aplikacji może poprawić wydajność przez usuwanie zadań. Aby uzyskać więcej informacji, zobacz [należy dysponować zadań?](http://blogs.msdn.com/b/pfxteam/archive/2012/03/25/10287435.aspx) w programowania równoległego z blogu .NET.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Zadanie nie jest w jednym ze stanów końcowego: <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" />, <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" />, lub <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" />.</exception>
        <threadsafe>W przeciwieństwie do większości członków <see cref="T:System.Threading.Tasks.Task" /> klasy, ta metoda nie jest bezpieczne wątkowo.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="Exception">
      <MemberSignature Language="C#" Value="public AggregateException Exception { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AggregateException Exception" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Exception" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Exception As AggregateException" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AggregateException ^ Exception { AggregateException ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AggregateException</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.AggregateException" /> powodujący <see cref="T:System.Threading.Tasks.Task" /> przedwczesne zakończenie. Jeśli <see cref="T:System.Threading.Tasks.Task" /> zakończyła się pomyślnie lub nie jeszcze zgłosił wyjątki, to zwróci <see langword="null" />.</summary>
        <value>
          <see cref="T:System.AggregateException" /> Powodujący <see cref="T:System.Threading.Tasks.Task" /> przedwczesne zakończenie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zadania, które zgłasza nieobsługiwanych wyjątków przechowywania wynikowy wyjątku i Propaguj go w <xref:System.AggregateException> w wywołaniach <xref:System.Threading.Tasks.Task.Wait%2A> lub w dostępie do <xref:System.Threading.Tasks.Task.Exception%2A> właściwości. Wszelkie wyjątki nie przestrzega razem, gdy wystąpienie zadania jest bezużytecznych będzie propagowane na wątku finalizatora. Aby uzyskać więcej informacji i przykład zobacz [obsługi wyjątków (Biblioteka zadań równoległych)](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Factory">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskFactory Factory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskFactory Factory" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Factory" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Factory As TaskFactory" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::TaskFactory ^ Factory { System::Threading::Tasks::TaskFactory ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskFactory</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zapewnia dostęp do metody fabrykę do tworzenia i konfigurowania <see cref="T:System.Threading.Tasks.Task" /> i <see cref="T:System.Threading.Tasks.Task`1" /> wystąpień.</summary>
        <value>Obiekt fabryki, który może tworzyć różnych <see cref="T:System.Threading.Tasks.Task" /> i <see cref="T:System.Threading.Tasks.Task`1" /> obiektów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zwraca domyślnego wystąpienia programu <xref:System.Threading.Tasks.TaskFactory> klasy, która jest taka sama jak utworzony przez wywołanie metody bez parametrów <xref:System.Threading.Tasks.TaskFactory.%23ctor?displayProperty=nameWithType> konstruktora. Ma ona wartości następujących właściwości:  
  
|Właściwość|Wartość|  
|--------------|-----------|  
|<xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A?displayProperty=nameWithType>|<xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType>|  
|<xref:System.Threading.Tasks.TaskFactory.ContinuationOptions%2A?displayProperty=nameWithType>|<xref:System.Threading.Tasks.TaskContinuationOptions.None?displayProperty=nameWithType>|  
|<xref:System.Threading.Tasks.TaskFactory.CreationOptions%2A?displayProperty=nameWithType>|<xref:System.Threading.Tasks.TaskCreationOptions.None?displayProperty=nameWithType>|  
|<xref:System.Threading.Tasks.TaskFactory.Scheduler%2A?displayProperty=nameWithType>|`null`, lub <xref:System.Threading.Tasks.TaskScheduler.Current%2A?displayProperty=nameWithType>|  
  
 Najbardziej typowe użycie tej właściwości jest utworzenie i uruchomić nowe zadanie w jednym wywołaniu <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> metody.  
  
> [!NOTE]
>  Począwszy od [!INCLUDE[net_v45](~/includes/net-v45-md.md)], <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> metoda zapewnia Najprostszym sposobem tworzenia <xref:System.Threading.Tasks.Task> obiekt o wartości konfiguracji domyślnej.  
  
 W poniższym przykładzie użyto statycznych <xref:System.Threading.Tasks.Task.Factory%2A> właściwości do łączenia dwóch się <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> metody. Pierwszy wypełnia tablicy z nazwami plików w katalogu Moje dokumenty użytkownika, podczas gdy druga wypełnia tablicę nazw podkatalogi katalogu Moje dokumenty użytkownika. Następnie wywołuje <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%28System.Threading.Tasks.Task%5B%5D%2CSystem.Action%7BSystem.Threading.Tasks.Task%5B%5D%7D%29?displayProperty=nameWithType> metodę, która wyświetla informacje o liczbę plików i katalogów w dwóch tablic, po wykonaniu pierwsze dwa zadania.  
  
 [!code-csharp[System.Threading.Tasks.Task.Factory#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.factory/cs/factory1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Factory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.factory/vb/factory1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskFactory" />
      </Docs>
    </Member>
    <Member MemberName="FromCanceled">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task FromCanceled (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task FromCanceled(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromCanceled(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ FromCanceled(System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">Token anulowania, z którym do ukończenia tego zadania.</param>
        <summary>Tworzy <see cref="T:System.Threading.Tasks.Task" /> ten zostanie zakończony z powodu anulowania z tokenem anulowania określony.</summary>
        <returns>Zadanie anulowane.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Nie zażądano anulowania dla <paramref name="cancellationToken" />; <see cref="P:System.Threading.CancellationToken.IsCancellationRequested" /> jest właściwość <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromCanceled&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; FromCanceled&lt;TResult&gt; (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromCanceled&lt;TResult&gt;(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromCanceled``1(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ FromCanceled(System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ wyniku zwracanego przez zadania.</typeparam>
        <param name="cancellationToken">Token anulowania, z którym do ukończenia tego zadania.</param>
        <summary>Tworzy <see cref="T:System.Threading.Tasks.Task`1" /> ten zostanie zakończony z powodu anulowania z tokenem anulowania określony.</summary>
        <returns>Zadanie anulowane.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Nie zażądano anulowania dla <paramref name="cancellationToken" />; <see cref="P:System.Threading.CancellationToken.IsCancellationRequested" /> jest właściwość <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromException">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task FromException (Exception exception);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task FromException(class System.Exception exception) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromException(System.Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ FromException(Exception ^ exception);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exception" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="exception">Wyjątek, z którym do ukończenia tego zadania.</param>
        <summary>Tworzy <see cref="T:System.Threading.Tasks.Task" /> który zostało ukończone z określonym wyjątkiem.</summary>
        <returns>Błędnej zadanie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda tworzy <xref:System.Threading.Tasks.Task> którego <xref:System.Threading.Tasks.Task.Status%2A> właściwość jest <xref:System.Threading.Tasks.TaskStatus.Faulted> i których <xref:System.Threading.Tasks.Task.Exception%2A> zawiera właściwość `exception`. Metoda to powszechnie używane, gdy natychmiast wiesz, że pracy, który wykonuje zadania spowoduje zgłoszenie wyjątku przed wykonaniem dłuższe ścieżki kodu. Na przykład zobacz <xref:System.Threading.Tasks.Task.FromException%60%601%28System.Exception%29> przeciążenia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromException&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; FromException&lt;TResult&gt; (Exception exception);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromException&lt;TResult&gt;(class System.Exception exception) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromException``1(System.Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ FromException(Exception ^ exception);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="exception" Type="System.Exception" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ wyniku zwracanego przez zadania.</typeparam>
        <param name="exception">Wyjątek, z którym do ukończenia tego zadania.</param>
        <summary>Tworzy <see cref="T:System.Threading.Tasks.Task`1" /> który zostało zakończone z określonym wyjątkiem.</summary>
        <returns>Błędnej zadanie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda tworzy <xref:System.Threading.Tasks.Task%601> którego <xref:System.Threading.Tasks.Task.Status%2A> właściwość jest <xref:System.Threading.Tasks.TaskStatus.Faulted> i których <xref:System.Threading.Tasks.Task.Exception%2A> zawiera właściwość `exception`. Metoda to powszechnie używane, gdy natychmiast wiesz, że pracy, który wykonuje zadania spowoduje zgłoszenie wyjątku przed wykonaniem dłuższe ścieżki kodu. Przykład stanowi ilustrację.  
  
   
  
## Examples  
 Poniższy przykład jest narzędziem wiersza polecenia, który oblicza liczbę bajtów w plikach w każdym katalogu, którego nazwa jest przekazywany jako argument wiersza polecenia. Zamiast wykonywania dłużej ścieżka kodu, który tworzy <xref:System.IO.FileInfo> obiektu i pobiera wartość jego <xref:System.IO.FileInfo.Length%2A?displayProperty=nameWithType> właściwości dla każdego pliku w katalogu, przykładzie po prostu wywołuje <xref:System.Threading.Tasks.Task.FromException%60%601%28System.Exception%29> metodę w celu utworzenia błędnej zadania, jeśli określonego podkatalog nie istnieje.  
  
 [!code-csharp[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/cs/fromresult1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/vb/fromresult1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromResult&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; FromResult&lt;TResult&gt; (TResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromResult&lt;TResult&gt;(!!TResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromResult``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromResult(Of TResult) (result As TResult) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ FromResult(TResult result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="result" Type="TResult" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ wyniku zwracanego przez zadania.</typeparam>
        <param name="result">Wynik do przechowywania do ukończonego zadania.</param>
        <summary>Tworzy <see cref="T:System.Threading.Tasks.Task`1" /> pomyślnie ukończono z wynikiem określonej.</summary>
        <returns>Pomyślnie zakończono zadanie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda tworzy <xref:System.Threading.Tasks.Task%601> którego <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> właściwość jest `result` i których <xref:System.Threading.Tasks.Task.Status%2A> jest właściwość <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>. Metoda to powszechnie używane, gdy natychmiast znany jest zwracana wartość zadania bez wykonywania dłuższe ścieżki kodu. Przykład stanowi ilustrację.  
  
 Aby utworzyć obiekt zadania, która nie zwraca wartości, Pobierz obiekt zadania z <xref:System.Threading.Tasks.Task.CompletedTask%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykład jest narzędziem wiersza polecenia, który oblicza liczbę bajtów w plikach w każdym katalogu, którego nazwa jest przekazywany jako argument wiersza polecenia. Zamiast wykonywania dłużej ścieżka kodu, który tworzy <xref:System.IO.FileStream> obiektu i pobiera wartość jego <xref:System.IO.FileStream.Length%2A?displayProperty=nameWithType> właściwości dla każdego pliku w katalogu, przykładzie po prostu wywołuje <xref:System.Threading.Tasks.Task.FromResult%2A> metody, aby utworzyć zadanie, którego <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> Właściwość jest zero (0), jeśli w katalogu nie ma plików.  
  
 [!code-csharp[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/cs/fromresult1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/vb/fromresult1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Threading.Tasks.Task.CompletedTask" />
      </Docs>
    </Member>
    <Member MemberName="GetAwaiter">
      <MemberSignature Language="C#" Value="public System.Runtime.CompilerServices.TaskAwaiter GetAwaiter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Runtime.CompilerServices.TaskAwaiter GetAwaiter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.GetAwaiter" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAwaiter () As TaskAwaiter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::CompilerServices::TaskAwaiter GetAwaiter();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.CompilerServices.TaskAwaiter</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera awaiter umożliwia to await <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <returns>Wystąpienie awaiter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest przeznaczona do użytku w kompilatorze, a nie do użytku w kodzie aplikacji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera identyfikator dla tego <see cref="T:System.Threading.Tasks.Task" /> wystąpienia.</summary>
        <value>Identyfikator, który jest przypisywany przez system do tego <see cref="T:System.Threading.Tasks.Task" /> wystąpienia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identyfikatory zadań są przypisane na żądanie i niekoniecznie nie reprezentują kolejności zadań tworzenia wystąpień. Należy pamiętać, że chociaż kolizji są bardzo rzadko, identyfikatory zadań są nie musi być unikatowy.  
  
 Aby uzyskać identyfikator zadania aktualnie wykonywanego zadania z kodem, które wykonuje to zadanie, należy użyć <xref:System.Threading.Tasks.Task.CurrentId%2A> właściwości.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Threading.Tasks.Task.CurrentId" />
      </Docs>
    </Member>
    <Member MemberName="IsCanceled">
      <MemberSignature Language="C#" Value="public bool IsCanceled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCanceled" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsCanceled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCanceled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCanceled { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera czy to <see cref="T:System.Threading.Tasks.Task" /> wystąpienia zakończyła wykonywanie z powodu anulowania.</summary>
        <value>
          <see langword="true" /> Jeśli zadanie zostało ukończone z powodu anulowania; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Threading.Tasks.Task> potrwa <xref:System.Threading.Tasks.TaskStatus.Canceled> stanu we wszystkich następujących warunków:  
  
-   Jego <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> została oznaczona do anulowania, przed uruchomieniem zadania wykonywania  
  
-   Zadanie potwierdzone żądanie anulowania na jego już sygnałowego <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> przez zgłaszanie <xref:System.OperationCanceledException> który posiada taki sam <xref:System.Threading.CancellationToken>.  
  
-   Zadanie potwierdzone żądanie anulowania na jego już sygnałowego <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> przez wywołanie metody <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A> metoda <xref:System.Threading.CancellationToken>.  
  
> [!IMPORTANT]
>  Pobieranie wartości <xref:System.Threading.Tasks.Task.IsCanceled%2A> właściwości nie są blokowane w wątku wywołującym dopiero po ukończeniu zadania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCompleted">
      <MemberSignature Language="C#" Value="public bool IsCompleted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCompleted" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsCompleted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCompleted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCompleted { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.IsCompleted</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera czy to <see cref="T:System.Threading.Tasks.Task" /> zostało ukończone.</summary>
        <value>
          <see langword="true" /> Jeśli zadanie zostało ukończone; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.IsCompleted%2A> Zwraca `true` gdy zadanie jest jeden z trzech stanów końcowe: <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>, <xref:System.Threading.Tasks.TaskStatus.Faulted>, lub <xref:System.Threading.Tasks.TaskStatus.Canceled>.  
  
> [!IMPORTANT]
>  Pobieranie wartości <xref:System.Threading.Tasks.Task.IsCompleted%2A?displayProperty=nameWithType> właściwości nie są blokowane w wątku wywołującym dopiero po ukończeniu zadania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCompletedSuccessfully">
      <MemberSignature Language="C#" Value="public bool IsCompletedSuccessfully { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCompletedSuccessfully" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsCompletedSuccessfully" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCompletedSuccessfully As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCompletedSuccessfully { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFaulted">
      <MemberSignature Language="C#" Value="public bool IsFaulted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFaulted" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsFaulted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFaulted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFaulted { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera czy <see cref="T:System.Threading.Tasks.Task" /> zakończona z powodu nieobsługiwanego wyjątku.</summary>
        <value>
          <see langword="true" /> Jeśli zadanie ma zgłoszono nieobsługiwany wyjątek; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Threading.Tasks.Task.IsFaulted%2A> jest `true`, zadania <xref:System.Threading.Tasks.Task.Status%2A> jest równa <xref:System.Threading.Tasks.TaskStatus.Faulted>, a jego <xref:System.Threading.Tasks.Task.Exception%2A> właściwość będzie mieć wartości null.  
  
> [!IMPORTANT]
>  Pobieranie wartości <xref:System.Threading.Tasks.Task.IsFaulted%2A?displayProperty=nameWithType> właściwości nie są blokowane w wątku wywołującym dopiero po ukończeniu zadania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kolejkuje określona pracy do uruchomienia na obiekcie ThreadPool, a następnie zwraca klasę task, lub <see cref="T:System.Threading.Tasks.Task`1" /> dojścia do pracy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Run%2A> Metoda zapewnia zbiór przeciążeń, które ułatwiają uruchamiania zadania przy użyciu wartości domyślnych. Jest lekki zamiast <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> przeciążenia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Action action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Action action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Action)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Run(Action ^ action);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
      </Parameters>
      <Docs>
        <param name="action">Pracy można wykonać w sposób asynchroniczny</param>
        <summary>Kolejkuje określona pracy do uruchomienia w puli wątków i zwraca <see cref="T:System.Threading.Tasks.Task" /> obiekt, który reprezentuje tę pracę.</summary>
        <returns>Zadanie reprezentujące pracy w kolejce do wykonania w puli wątków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Run%2A> Metoda pozwala na tworzenie i wykonywanie zadania w wywołaniu pojedynczej metody i jest prostsze alternatywą do <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> metody. Tworzy zadanie z następujących wartości domyślne:  
  
-   Jest jego token anulowania <xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType>.  
  
-   Jego <xref:System.Threading.Tasks.Task.CreationOptions%2A> wartość właściwości jest <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>.  
  
-   Użyto domyślnego harmonogramu zadań.  
  
 Informacje dotyczące obsługi wyjątków zgłaszanych przez operacje zadań znajdują się w temacie [obsługi wyjątków](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano `ShowThreadInfo` metodę, która wyświetla <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType> bieżącego wątku. Jest wywoływana bezpośrednio z wątku aplikacji i jest wywoływana z <xref:System.Action> delegata przekazany do <xref:System.Threading.Tasks.Task.Run%28System.Action%29> metody.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run11.cs#11)]
 [!code-vb[System.Threading.Tasks.Task.Run#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run11.vb#11)]  
  
 Poniższy przykład jest podobny do poprzedniego, z wyjątkiem tego, że używa wyrażenia lambda w celu zdefiniowania kod do wykonania zadania.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run6.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.Run#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run6.vb#3)]  
  
 W przykładach pokazano, że zadanie asynchroniczne wykonuje się w innym wątku niż wątku głównego aplikacji.  
  
 Wywołanie <xref:System.Threading.Tasks.Task.Wait%2A> metoda gwarantuje, że zadanie zakończeniu i wyświetla dane wyjściowe przed zakończeniem aplikacji. W przeciwnym razie jest możliwe że `Main` metody zostanie zakończony przed zakończeniem zadania.  
  
 Poniższy przykład przedstawia <xref:System.Threading.Tasks.Task.Run%28System.Action%29> metody. Określa tablicę nazw katalogów, a uruchamia osobne zadanie, można pobrać nazwy pliku w każdym katalogu. Wszystkie zadania zapisu nazwy plików do pojedynczego <xref:System.Collections.Concurrent.ConcurrentBag%601> obiektu. Przykład wywołuje <xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29> metody, aby upewnić się, że wszystkie zadania zostały wykonane, a następnie wyświetla liczba całkowita liczba zapisywane w nazwach plików <xref:System.Collections.Concurrent.ConcurrentBag%601> obiektu.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run2.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Run#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="action" /> Parametru <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Func&lt;System.Threading.Tasks.Task&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Func`1&lt;class System.Threading.Tasks.Task&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Run (function As Func(Of Task)) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Run(Func&lt;System::Threading::Tasks::Task ^&gt; ^ function);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="function">Pracy można wykonać w sposób asynchroniczny</param>
        <summary>Kolejkuje określona pracy do uruchomienia w puli wątków i zwraca serwera proxy dla zadanie zwrócone przez <paramref name="function" />.</summary>
        <returns>Zadanie reprezentujące serwera proxy dla zadanie zwrócone przez <paramref name="function" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Informacje dotyczące obsługi wyjątków zgłaszanych przez operacje zadań znajdują się w temacie [obsługi wyjątków](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="function" /> Parametru <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Action action, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Run(Action ^ action, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="action">Pracy można wykonać w sposób asynchroniczny</param>
        <param name="cancellationToken">Token anulowania, który może służyć do anulowania pracy</param>
        <summary>Kolejkuje określona pracy do uruchomienia w puli wątków i zwraca <see cref="T:System.Threading.Tasks.Task" /> obiekt, który reprezentuje tę pracę. Token anulowania umożliwia pracy anulowanie.</summary>
        <returns>Zadanie reprezentujące pracy w kolejce do wykonania w puli wątków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli żądanie anulowania przed rozpoczęciem wykonywania zadania, nie wykonuje zadanie. Zamiast tego jest równa <xref:System.Threading.Tasks.TaskStatus.Canceled> stanu i zgłasza <xref:System.Threading.Tasks.TaskCanceledException> wyjątku.  
  
 <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29> Metoda jest prostsza zamiast <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> metody. Tworzy zadanie z następujących wartości domyślne:  
  
-   Jego <xref:System.Threading.Tasks.Task.CreationOptions%2A> wartość właściwości jest <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>.  
  
-   Użyto domyślnego harmonogramu zadań.  
  
 Informacje dotyczące obsługi wyjątków zgłaszanych przez operacje zadań znajdują się w temacie [obsługi wyjątków](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
   
  
## Examples  
 Następujące przykładowe wywołania <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29> metodę, aby utworzyć zadanie, który iteruje po plików w katalogu C:\Windows\System32. Wywołania wyrażenia lambda <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> metody w celu dodania informacji o poszczególnych plików do <xref:System.Collections.Generic.List%601> obiektu. Odłączyć każdego zadania zagnieżdżonego wywoływane przez <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> pętli sprawdza stan token anulowania i, jeśli żądanie anulowania wywołuje <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> metody. <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> Metoda zgłasza <xref:System.OperationCanceledException> wyjątek, który jest obsługiwany w `catch` zablokować, jeśli wątek wywołujący wywołuje <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> metody.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.Run#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="action" /> Parametru <see langword="null" />.</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">Zadanie zostało anulowane.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.CancellationTokenSource" /> Skojarzone z <paramref name="cancellationToken" /> został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Func&lt;System.Threading.Tasks.Task&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Func`1&lt;class System.Threading.Tasks.Task&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Run(Func&lt;System::Threading::Tasks::Task ^&gt; ^ function, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="function">Praca do wykonywania asynchronicznie.</param>
        <param name="cancellationToken">Token anulowania, które mają być używane do anulowania pracy.</param>
        <summary>Kolejkuje określona pracy do uruchomienia w puli wątków i zwraca serwera proxy dla zadanie zwrócone przez <paramref name="function" />.</summary>
        <returns>Zadanie reprezentujące serwera proxy dla zadanie zwrócone przez <paramref name="function" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Informacje dotyczące obsługi wyjątków zgłaszanych przez operacje zadań znajdują się w temacie [obsługi wyjątków](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="function" /> Parametru <see langword="null" />.</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">Zadanie zostało anulowane.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.CancellationTokenSource" /> Skojarzone z <paramref name="cancellationToken" /> został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Run(Of TResult) (function As Func(Of Task(Of TResult))) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ Run(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ function);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ wynik zwracany przez zadanie serwera proxy.</typeparam>
        <param name="function">Pracy można wykonać w sposób asynchroniczny</param>
        <summary>Kolejkuje określona pracy do uruchomienia w puli wątków i zwraca serwera proxy dla <see langword="Task(TResult)" /> zwrócony przez <paramref name="function" />.</summary>
        <returns>A <see langword="Task(TResult)" /> reprezentujący serwera proxy dla <see langword="Task(TResult)" /> zwrócony przez <paramref name="function" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Informacje dotyczące obsługi wyjątków zgłaszanych przez operacje zadań znajdują się w temacie [obsługi wyjątków](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="function" /> Parametru <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;TResult&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Run(Of TResult) (function As Func(Of TResult)) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ Run(Func&lt;TResult&gt; ^ function);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ zwracany tego zadania.</typeparam>
        <param name="function">Praca do wykonywania asynchronicznie.</param>
        <summary>Kolejkuje określona pracy do uruchomienia w puli wątków i zwraca <see cref="T:System.Threading.Tasks.Task`1" /> obiekt, który reprezentuje tę pracę.</summary>
        <returns>Obiekt zadania reprezentujący pracy w kolejce do wykonania w puli wątków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Run%2A> Metoda jest prostsza zamiast <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=nameWithType> metody. Tworzy zadanie z następujących wartości domyślne:  
  
-   Jest jego token anulowania <xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType>.  
  
-   Jego <xref:System.Threading.Tasks.Task.CreationOptions%2A> wartość właściwości jest <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>.  
  
-   Użyto domyślnego harmonogramu zadań.  
  
 Informacje dotyczące obsługi wyjątków zgłaszanych przez operacje zadań znajdują się w temacie [obsługi wyjątków](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
   
  
## Examples  
 Poniższy przykład oblicza przybliżoną liczbę słów w pliki tekstowe, które reprezentują książek opublikowanych. Każde zadanie jest odpowiedzialny za otwarcie pliku asynchronicznego odczytywania jego całą zawartość i obliczanie słów przy użyciu wyrażenia regularnego. <xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29> Metoda jest wywoływana, aby upewnić się, że wszystkie zadania zostały ukończone przed wyświetleniem wyrazów każdego książki do konsoli.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run3.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.Run#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run3.vb#2)]  
  
 Wyrażenie regularne `\p{P}*\s+` dopasowuje zero, jeden lub więcej znaków interpunkcyjnych następuje co najmniej jeden znak odstępu. Zakłada się, czy łączna liczba dopasowań jest równe przybliżonej słów.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="function" /> Parametr jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ Run(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ function, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ wynik zwracany przez zadanie serwera proxy.</typeparam>
        <param name="function">Pracy można wykonać w sposób asynchroniczny</param>
        <param name="cancellationToken">Token anulowania, które mają być używane do anulowania pracy</param>
        <summary>Kolejkuje określona pracy do uruchomienia w puli wątków i zwraca serwera proxy dla <see langword="Task(TResult)" /> zwrócony przez <paramref name="function" />.</summary>
        <returns>A <see langword="Task(TResult)" /> reprezentujący serwera proxy dla <see langword="Task(TResult)" /> zwrócony przez <paramref name="function" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Informacje dotyczące obsługi wyjątków zgłaszanych przez operacje zadań znajdują się w temacie [obsługi wyjątków](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="function" /> Parametru <see langword="null" />.</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">Zadanie zostało anulowane.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.CancellationTokenSource" /> Skojarzone z <paramref name="cancellationToken" /> został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;TResult&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ Run(Func&lt;TResult&gt; ^ function, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ wyniku zadania.</typeparam>
        <param name="function">Pracy można wykonać w sposób asynchroniczny</param>
        <param name="cancellationToken">Token anulowania, które mają być używane do anulowania pracy</param>
        <summary>Kolejkuje określona pracy do uruchomienia w puli wątków i zwraca <see langword="Task(TResult)" /> obiekt, który reprezentuje tę pracę. Token anulowania umożliwia pracy anulowanie.</summary>
        <returns>A <see langword="Task(TResult)" /> reprezentująca pracy w kolejce do wykonania w puli wątków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli żądanie anulowania przed rozpoczęciem wykonywania zadania, nie wykonuje zadanie. Zamiast tego jest równa <xref:System.Threading.Tasks.TaskStatus.Canceled> stanu i zgłasza <xref:System.Threading.Tasks.TaskCanceledException> wyjątku.  
  
 <xref:System.Threading.Tasks.Task.Run%2A> Metoda jest prostsza zamiast <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> metody. Tworzy zadanie z następujących wartości domyślne:  
  
-   Jego <xref:System.Threading.Tasks.Task.CreationOptions%2A> wartość właściwości jest <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>.  
  
-   Użyto domyślnego harmonogramu zadań.  
  
 Informacje dotyczące obsługi wyjątków zgłaszanych przez operacje zadań znajdują się w temacie [obsługi wyjątków](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
   
  
## Examples  
 Poniższy przykład tworzy 20 zadań, które będą pętli do licznik jest zwiększany wartość 2 milionów. Gdy zadania pierwszych 10 milionów 2, zostało anulowane, token anulowania, a są anulowane wszystkie zadania, których liczników nie osiągnęły milionów 2. W przykładzie danych wyjściowych.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run7.cs#7)]
 [!code-vb[System.Threading.Tasks.Task.Run#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run7.vb#7)]  
  
 Zamiast <xref:System.AggregateException.InnerExceptions%2A> właściwość do sprawdzenia wyjątki, przykładzie iteruje po wszystkich zadań w celu określenia, które zostały ukończone pomyślnie i zostały anulowane. Dla tych, które zostały wykonane wyświetlana jest wartość zwrócona przez zadania.  
  
 Ponieważ anulowania współpracy, każde zadanie można zdecydować, jak reagować na anulowanie. Poniższy przykład przypomina pierwsza strona, z wyjątkiem tego, po token zostało anulowane, zadania powrócić liczby iteracji one Zakończono zamiast zgłoszenie wyjątku przez.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run28.cs#28)]
 [!code-vb[System.Threading.Tasks.Task.Run#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run28.vb#28)]  
  
 Przykład musi obsługiwać <xref:System.AggregateException> wyjątku, ponieważ wszystkie zadania, które nie rozpoczęły zleconą anulowania nadal zgłosić wyjątek.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="function" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">Zadanie zostało anulowane.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.CancellationTokenSource" /> Skojarzone z <paramref name="cancellationToken" /> został usunięty.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RunSynchronously">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Uruchamia <see cref="T:System.Threading.Tasks.Task" /> synchronicznie na bieżącej <see cref="T:System.Threading.Tasks.TaskScheduler" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RunSynchronously">
      <MemberSignature Language="C#" Value="public void RunSynchronously ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RunSynchronously() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.RunSynchronously" />
      <MemberSignature Language="VB.NET" Value="Public Sub RunSynchronously ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RunSynchronously();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Uruchamia <see cref="T:System.Threading.Tasks.Task" /> synchronicznie na bieżącej <see cref="T:System.Threading.Tasks.TaskScheduler" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwykle zadania są wykonywane asynchronicznie w wątku puli wątków i nie blokują wątek wywołujący. Zadania wykonywane przez wywołanie metody <xref:System.Threading.Tasks.Task.RunSynchronously> metody są skojarzone z bieżącym <xref:System.Threading.Tasks.TaskScheduler> i są uruchamiane w wątku wywołującym. Jeśli harmonogram docelowy nie obsługuje wykonywania tego zadania w wątku wywołującym, zadanie zostanie zaplanowane do wykonania w ramach harmonogramu zadań i Wątek wywołujący zablokuje aż do zakończenia wykonywania zadania. Mimo że to zadanie jest uruchamiane synchronicznie, nadal powinny wywoływać wątek wywołujący <xref:System.Threading.Tasks.Task.Wait%2A> do obsługi wszelkie wyjątki, które może zgłosić zadania.  Aby uzyskać więcej informacji dotyczących obsługi wyjątków, zobacz [obsługi wyjątków](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 Zadania wykonywane przez wywołanie metody <xref:System.Threading.Tasks.Task.RunSynchronously%2A> wystąpienia są tworzone przez wywołanie metody <xref:System.Threading.Tasks.Task> lub <xref:System.Threading.Tasks.Task%601> konstruktora klasy. Zadania są uruchamiane synchronicznie musi być w <xref:System.Threading.Tasks.TaskStatus.Created> stanu. Zadania mogą być uruchomione i uruchomić tylko raz. Próbuje zaplanować zadanie drugi wyniki czasu wyjątku.  
  
   
  
## Examples  
 Poniższy przykład porównuje zadania wykonywane przez wywołanie metody <xref:System.Threading.Tasks.Task.RunSynchronously%2A> metody z jednym wykonywane asynchronicznie. W obu przypadkach zadania wykonywania wyrażenia lambda identyczne, zawierające identyfikator zadania i identyfikator wątku, w którym zadanie jest uruchomione. Zadanie oblicza sumę liczb całkowitych od 1 do 1 000 000. Jak pokazano na dane wyjściowe z przykładu, wywołując wykonać zadania <xref:System.Threading.Tasks.Task.RunSynchronously%2A> — metoda będzie działać w wątku aplikacji nie obsługuje zadanie asynchroniczne.  
  
 [!code-csharp[System.Threading.Tasks.Task.RunSynchronously#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.runsynchronously/cs/runsynchronously1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.RunSynchronously#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.runsynchronously/vb/runsynchronously1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> Wystąpienia został usunięty.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Threading.Tasks.Task" /> Nie jest w prawidłowym stanie do uruchomienia. Mógł już została uruchomiona, wykonywane lub anulowane lub został utworzony w taki sposób, który nie obsługuje bezpośredniego planowania.</exception>
      </Docs>
    </Member>
    <Member MemberName="RunSynchronously">
      <MemberSignature Language="C#" Value="public void RunSynchronously (System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RunSynchronously(class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RunSynchronously (scheduler As TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RunSynchronously(System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="scheduler">Harmonogram, na którym ma być próba uruchomienia tego zadania wbudowanego.</param>
        <summary>Uruchamia <see cref="T:System.Threading.Tasks.Task" /> synchronicznie na <see cref="T:System.Threading.Tasks.TaskScheduler" /> podane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zadania wykonywane przez wywołanie metody <xref:System.Threading.Tasks.Task.RunSynchronously%2A> wystąpienia są tworzone przez wywołanie metody <xref:System.Threading.Tasks.Task> lub <xref:System.Threading.Tasks.Task%601> konstruktora klasy. Zadania są uruchamiane synchronicznie musi być w <xref:System.Threading.Tasks.TaskStatus.Created> stanu. Zadania mogą być uruchomione i uruchomić tylko raz. Próbuje zaplanować zadanie drugi wyniki czasu wyjątku.  
  
 Jeśli harmonogram docelowy nie obsługuje wykonywania tego zadania w bieżącym wątku, zadanie zostanie zaplanowane do wykonania w ramach harmonogramu zadań i blokuje bieżącego wątku, dopóki nie zakończy się zadanie wykonania. W związku z tym wątek wywołujący nie jest konieczne wywołania metody, takie jak <xref:System.Threading.Tasks.Task.Wait%2A> aby upewnić się, że zadanie zostało ukończone wykonywania. Aby uzyskać więcej informacji dotyczących obsługi wyjątków dla operacji zadań, zobacz [obsługi wyjątków](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> Wystąpienia został usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="scheduler" /> Argument jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Threading.Tasks.Task" /> Nie jest w prawidłowym stanie do uruchomienia. Mógł już została uruchomiona, wykonywane lub anulowane lub został utworzony w taki sposób, który nie obsługuje bezpośredniego planowania.</exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Uruchamia <see cref="T:System.Threading.Tasks.Task" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Uruchamia <see cref="T:System.Threading.Tasks.Task" />, planowanie go na bieżącą wykonywania <see cref="T:System.Threading.Tasks.TaskScheduler" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zadania mogą być uruchomione i uruchomić tylko raz. Wystąpił wyjątek spowoduje próbuje zaplanować zadanie po raz drugi.  
  
 <xref:System.Threading.Tasks.Task.Start%2A> Służy do wykonywania zadań, który został utworzony przez wywoływanie jednej z <xref:System.Threading.Tasks.Task> konstruktorów. Zwykle w tym przypadku trzeba rozdzielić Tworzenie zadania z działania, takie jak podczas warunkowo wykonywania zadań, które zostały utworzone. W przypadku częściej, w którym nie trzeba rozdzielić wystąpienia zadania pochodzący z wykonania, firma Microsoft zaleca, aby wywoływać przeciążenia <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> lub <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> metody.  
  
 Informacje dotyczące obsługi wyjątków zgłaszanych przez operacje zadań znajdują się w temacie [obsługi wyjątków](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
   
  
## Examples  
 Następujące przykładowe wywołania <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%29> konstruktora, aby utworzyć obiekt klasy <xref:System.Threading.Tasks.Task> obiekt, który przedstawia zadania, jego identyfikator, identyfikator wątku zarządzanego, a następnie wykonuje pętlę. Następnie wywołuje <xref:System.Threading.Tasks.Task.Start%2A> metodę można wykonać zadania.  Ponieważ to jest aplikacja konsoli, wywołanie <xref:System.Threading.Tasks.Task.Wait%2A> — metoda jest konieczne zapobiec przerywanie przed zakończeniem zadania wykonywania aplikacji.  
  
 [!code-csharp[System.Threading.Tasks.Task.Start#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.start/cs/Start1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Start#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.start/vb/Start1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> Wystąpienia został usunięty.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Threading.Tasks.Task" /> Nie jest w prawidłowym stanie do uruchomienia. Mógł już została uruchomiona, wykonywane lub anulowane lub został utworzony w taki sposób, który nie obsługuje bezpośredniego planowania.</exception>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start (System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start(class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Start(System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start (scheduler As TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start(System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="scheduler">
          <see cref="T:System.Threading.Tasks.TaskScheduler" /> Umożliwiające skojarzyć i wykonać to zadanie.</param>
        <summary>Uruchamia <see cref="T:System.Threading.Tasks.Task" />, planowanie go na określony wykonywania <see cref="T:System.Threading.Tasks.TaskScheduler" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zadania mogą być tylko uruchomione i uruchomić tylko raz. Wystąpił wyjątek spowoduje próbuje zaplanować zadanie po raz drugi.  
  
 Informacje dotyczące obsługi wyjątków zgłaszanych przez operacje zadań znajdują się w temacie [obsługi wyjątków](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="scheduler" /> Argument jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Threading.Tasks.Task" /> Nie jest w prawidłowym stanie do uruchomienia. Mógł już została uruchomiona, wykonywane lub anulowane lub został utworzony w taki sposób, który nie obsługuje bezpośredniego planowania.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> Wystąpienia został usunięty.</exception>
        <exception cref="T:System.Threading.Tasks.TaskSchedulerException">Planista nie można umieścić w kolejce to zadanie.</exception>
      </Docs>
    </Member>
    <Member MemberName="Status">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.TaskStatus Status { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.Tasks.TaskStatus Status" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Status" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Status As TaskStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::TaskStatus Status { System::Threading::Tasks::TaskStatus get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskStatus</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Threading.Tasks.TaskStatus" /> tego zadania.</summary>
        <value>Bieżący <see cref="T:System.Threading.Tasks.TaskStatus" /> tego wystąpienia zadania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pobieranie wartości <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> właściwości nie są blokowane w wątku wywołującym dopiero po ukończeniu zadania.  
  
 Na przykład i więcej informacji, zobacz [tworzenie łańcuchów zadań przy użyciu zadań kontynuacji](~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md) i [porady: anulowanie zadania i jego elementy podrzędne](~/docs/standard/parallel-programming/how-to-cancel-a-task-and-its-children.md).  
  
   
  
## Examples  
 Poniższy przykład tworzy 20 zadań, które będą pętli do licznik jest zwiększany wartość 2 milionów. Gdy zadania pierwszych 10 milionów 2, zostało anulowane, token anulowania, a są anulowane wszystkie zadania, których liczników nie osiągnęły milionów 2. Przykład następnie sprawdza <xref:System.Threading.Tasks.Task.Status%2A> właściwości każdego zadania, aby wskazać, czy zakończyła się pomyślnie, lub została anulowana. Dla tych, które zakończone wyświetlana jest wartość zwrócona przez zadania.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run7.cs#7)]
 [!code-vb[System.Threading.Tasks.Task.Run#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run7.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IAsyncResult.AsyncWaitHandle">
      <MemberSignature Language="C#" Value="System.Threading.WaitHandle System.IAsyncResult.AsyncWaitHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.WaitHandle System.IAsyncResult.AsyncWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.System#IAsyncResult#AsyncWaitHandle" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property AsyncWaitHandle As WaitHandle Implements IAsyncResult.AsyncWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="property System::Threading::WaitHandle ^ System.IAsyncResult.AsyncWaitHandle { System::Threading::WaitHandle ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.AsyncWaitHandle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.WaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Threading.WaitHandle" /> można czekać na ukończenie zadania.</summary>
        <value>A <see cref="T:System.Threading.WaitHandle" /> można czekać na ukończenie zadania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przy użyciu funkcji oczekiwania udostępnianych przez usługę <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> zalecane jest stosowanie <xref:System.IAsyncResult.AsyncWaitHandle%2A> dla podobnych możliwościach. Aby uzyskać więcej informacji, zobacz sekcję "Oczekiwanie na zadania" w [opartego na zadaniach asynchronicznej programowania](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md) i [przy użyciu TPL z innych wzorami asynchronicznymi](~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> Został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IAsyncResult.CompletedSynchronously">
      <MemberSignature Language="C#" Value="bool System.IAsyncResult.CompletedSynchronously { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.IAsyncResult.CompletedSynchronously" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.System#IAsyncResult#CompletedSynchronously" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property CompletedSynchronously As Boolean Implements IAsyncResult.CompletedSynchronously" />
      <MemberSignature Language="C++ CLI" Value="property bool System.IAsyncResult.CompletedSynchronously { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.CompletedSynchronously</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wskazanie czy zakończyć operacji synchronicznie.</summary>
        <value>
          <see langword="true" /> Jeśli operacja wykonana synchronicznie; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Wait">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Czeka na <see cref="T:System.Threading.Tasks.Task" /> do ukończenia wykonywania.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public void Wait ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Wait() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait" />
      <MemberSignature Language="VB.NET" Value="Public Sub Wait ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Wait();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Czeka na <see cref="T:System.Threading.Tasks.Task" /> do ukończenia wykonywania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Wait%2A> to metoda synchronizacji, która powoduje, że wątek wywołujący oczekiwania dopiero po ukończeniu bieżącego zadania. Jeśli bieżące zadanie nie zostało rozpoczęte wykonywania, metoda oczekiwania próbuje usunąć zadanie z harmonogramu i wykonaj go wbudowany w bieżącym wątku. Jeśli nie jest w stanie, w tym, czy bieżące zadanie już się rozpoczął wykonywanie, blokuje wątek wywołujący do momentu ukończenia zadania. Aby uzyskać więcej informacji, zobacz [Task.Wait i "Inlining"](http://blogs.msdn.com/b/pfxteam/archive/2009/10/15/9907713.aspx) w programowania równoległego z blogu .NET.  
  
 Na przykład i więcej informacji, zobacz [porady: Oczekiwanie na jeden lub więcej zadań do wykonania](http://msdn.microsoft.com/library/79cb522b-9c93-46ed-b23a-c06908f3a374).  
  
   
  
## Examples  
 Poniższy przykład uruchamia zadanie, które generuje milion losowych liczb całkowitych od 0 do 100 i oblicza średnią ich. W przykładzie użyto <xref:System.Threading.Tasks.Task.Wait%2A> metody, aby upewnić się, że zadanie zostało ukończone przed kończy aplikacji. W przeciwnym razie jest aplikacji konsoli, dlatego przykładzie spowoduje przerwanie przed zadania można obliczania i wyświetlania średniej.  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/wait1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Wait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/wait1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> Został usunięty.</exception>
        <exception cref="T:System.AggregateException">Zadanie zostało anulowane. <see cref="P:System.AggregateException.InnerExceptions" /> Kolekcja zawiera <see cref="T:System.Threading.Tasks.TaskCanceledException" /> obiektu.  
  
 —lub—  
  
 Wystąpił wyjątek podczas wykonywania zadania. <see cref="P:System.AggregateException.InnerExceptions" /> Kolekcja zawiera informacje o wyjątków i wyjątków.</exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Wait (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Wait(int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Wyrażony w milisekundach czas oczekiwania, lub <see cref="F:System.Threading.Timeout.Infinite" /> (-1) będzie czekać w nieskończoność.</param>
        <summary>Czeka na <see cref="T:System.Threading.Tasks.Task" /> do ukończenia wykonywania w ciągu określonej liczby milisekund.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="T:System.Threading.Tasks.Task" /> ukończył wykonywanie w wyznaczonym limicie czasu; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Wait%28System.Int32%29> jest to metoda synchronizacji, która powoduje, że wątek wywołujący oczekiwania dla bieżącego wystąpienia zadania do wykonania, dopóki nie wystąpi jedno z następujących czynności:  
  
-   Zadanie zostało ukończone pomyślnie.  
  
-   Samo zadanie zostało anulowane lub zgłasza wyjątek. W takim przypadku obsługi <xref:System.AggregateException> wyjątku. <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> Właściwość zawiera szczegóły dotyczące wyjątków i wyjątków.  
  
-   Odstępach czasu zdefiniowanych przez `millisecondsTimeout` upływa. W takim przypadku bieżący wątek wznawia wykonywania i metoda zwraca `false`.  
  
   
  
## Examples  
 Poniższy przykład uruchamia zadanie, które generuje pięć milionów losowych liczb całkowitych od 0 do 100 i oblicza średnią ich. W przykładzie użyto <xref:System.Threading.Tasks.Task.Wait%28System.Int32%29> metody oczekiwania aplikację, aby ukończyć w milisekundach 150. Jeśli normalnie kończy działanie aplikacji, zadanie wyświetla sum i średniej liczby losowe, która go wygenerowała. Jeśli upłynie limit czasu, w przykładzie przedstawiono komunikat przed zostaje zakończone.  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/Wait5.cs#5)]
 [!code-vb[System.Threading.Tasks.Task.Wait#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/Wait5.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> Został usunięty.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> jest to liczba ujemna niż -1, która reprezentuje nieskończony limit czasu.</exception>
        <exception cref="T:System.AggregateException">Zadanie zostało anulowane. <see cref="P:System.AggregateException.InnerExceptions" /> Kolekcja zawiera <see cref="T:System.Threading.Tasks.TaskCanceledException" /> obiektu.  
  
 —lub—  
  
 Wystąpił wyjątek podczas wykonywania zadania. <see cref="P:System.AggregateException.InnerExceptions" /> Kolekcja zawiera informacje o wyjątków i wyjątków.</exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public void Wait (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Wait(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Wait(System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">Token anulowania, aby przyjrzeć się podczas oczekiwania na zakończenie zadania.</param>
        <summary>Czeka na <see cref="T:System.Threading.Tasks.Task" /> do ukończenia wykonywania. Czas oczekiwania kończy się, jeśli token anulowania została anulowana przed ukończeniem zadania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29> Metoda tworzy można anulować oczekiwania, oznacza to, powoduje bieżącego wątku oczekiwania, dopóki nie wystąpi jedno z następujących czynności:  
  
-   Kończy zadanie.  
  
-   Token anulowania zostało anulowane. W tym przypadku wywołanie <xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29> metoda zgłasza <xref:System.OperationCanceledException>.  
  
> [!NOTE]
>  Anulowanie `cancellationToken` token anulowania nie ma wpływu na uruchomione zadanie chyba że również został przekazany token anulowania i jest gotowe do obsługi anulowania. Przekazywanie `cancellationToken` obiekt do tej metody umożliwia po prostu czas oczekiwania do anulowania.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie prostego token anulowania do anulowania oczekiwanie na ukończenie zadania. Zadanie jest uruchamiane, wywołuje <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> metodę, aby anulować żadnego tokenu źródłowego anulowanie tokenów, a następnie opóźnienia przez pięć sekund. Należy pamiętać, że samo zadanie nie został przekazany token anulowania, a nie można anulować. Wątek aplikacji wywołuje zadania <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> metody oczekiwania na zakończenie zadania, ale czas oczekiwania została anulowana po token anulowania zostało anulowane i <xref:System.OperationCanceledException> jest generowany. Obsługa wyjątków zgłasza wyjątek, a następnie zostanie uśpiony na sześć sekund. Jak dane wyjściowe w przykładzie pokazano, że opóźnienie pozwala zadań do wykonania w <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> stanu.  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/wait3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.Wait#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/wait3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="cancellationToken" /> Zostało anulowane.</exception>
        <exception cref="T:System.ObjectDisposedException">Zadanie zostało usunięte.</exception>
        <exception cref="T:System.AggregateException">Zadanie zostało anulowane. <see cref="P:System.AggregateException.InnerExceptions" /> Kolekcja zawiera <see cref="T:System.Threading.Tasks.TaskCanceledException" /> obiektu.  
  
 —lub—  
  
 Wystąpił wyjątek podczas wykonywania zadania. <see cref="P:System.AggregateException.InnerExceptions" /> Kolekcja zawiera informacje o wyjątków i wyjątków.</exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Wait (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Wait(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> reprezentujący wyrażony w milisekundach czas oczekiwania, lub <see cref="T:System.TimeSpan" /> reprezentujący wartość-1 milisekund oczekiwania przez czas nieokreślony.</param>
        <summary>Czeka na <see cref="T:System.Threading.Tasks.Task" /> aby zakończyć działanie w określonym przedziale czasu.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="T:System.Threading.Tasks.Task" /> ukończył wykonywanie w wyznaczonym limicie czasu; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29> jest to metoda synchronizacji, która powoduje, że wątek wywołujący oczekiwania dla bieżącego wystąpienia zadania do wykonania, dopóki nie wystąpi jedno z następujących czynności:  
  
-   Zadanie zostało ukończone pomyślnie.  
  
-   Samo zadanie zostało anulowane lub zgłasza wyjątek. W takim przypadku obsługi <xref:System.AggregateException> wyjątku. <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> Właściwość zawiera szczegóły dotyczące wyjątków i wyjątków.  
  
-   Odstępach czasu zdefiniowanych przez `timeout` upływa. W takim przypadku bieżący wątek wznawia wykonywania i metoda zwraca `false`.  
  
   
  
## Examples  
 Poniższy przykład uruchamia zadanie, które generuje pięć milionów losowych liczb całkowitych od 0 do 100 i oblicza średnią ich. W przykładzie użyto <xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29> metody oczekiwania aplikację, aby ukończyć w milisekundach 150. Jeśli normalnie kończy działanie aplikacji, zadanie wyświetla sum i średniej liczby losowe, która go wygenerowała. Jeśli upłynie limit czasu, w przykładzie przedstawiono komunikat przed zostaje zakończone.  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/Wait6.cs#6)]
 [!code-vb[System.Threading.Tasks.Task.Wait#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/Wait6.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> Został usunięty.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> jest liczbą ujemną niż-1 milisekund, która reprezentuje nieskończony limit czasu.  
  
 —lub—  
  
 <paramref name="timeout" /> jest większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.AggregateException">Zadanie zostało anulowane. <see cref="P:System.AggregateException.InnerExceptions" /> Kolekcja zawiera <see cref="T:System.Threading.Tasks.TaskCanceledException" /> obiektu.  
  
 —lub—  
  
 Wystąpił wyjątek podczas wykonywania zadania. <see cref="P:System.AggregateException.InnerExceptions" /> Kolekcja zawiera informacje o wyjątków i wyjątków.</exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Wait(int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Wyrażony w milisekundach czas oczekiwania, lub <see cref="F:System.Threading.Timeout.Infinite" /> (-1) będzie czekać w nieskończoność.</param>
        <param name="cancellationToken">Token anulowania, aby przyjrzeć się podczas oczekiwania na zakończenie zadania.</param>
        <summary>Czeka na <see cref="T:System.Threading.Tasks.Task" /> do ukończenia wykonywania. Czas oczekiwania kończy się, jeśli upłynie limit czasu lub token anulowania jest anulowany przed ukończeniem zadania.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="T:System.Threading.Tasks.Task" /> ukończył wykonywanie w wyznaczonym limicie czasu; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> jest to metoda synchronizacji, która powoduje, że wątek wywołujący oczekiwania dla bieżącego wystąpienia zadania do wykonania, dopóki nie wystąpi jedno z następujących czynności:  
  
-   Zadanie zostało ukończone pomyślnie.  
  
-   Samo zadanie zostało anulowane lub zgłasza wyjątek. W takim przypadku obsługi <xref:System.AggregateException> wyjątku. <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> Właściwość zawiera szczegóły dotyczące wyjątków i wyjątków.  
  
-   `cancellationToken` Token anulowania zostało anulowane. W tym przypadku wywołanie <xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> metoda zgłasza <xref:System.OperationCanceledException>.  
  
-   Odstępach czasu zdefiniowanych przez `millisecondsTimeout` upływa. W takim przypadku bieżący wątek wznawia wykonywania i metoda zwraca `false`.  
  
> [!NOTE]
>  Anulowanie `cancellationToken` token anulowania nie ma wpływu na uruchomione zadanie chyba że również został przekazany token anulowania i jest gotowe do obsługi anulowania. Przekazywanie `cancellationToken` obiektu do tej metody po prostu umożliwia czas oczekiwania do anulowania oparte na spełnienia określonego warunku.  
  
   
  
## Examples  
 Następujące przykładowe wywołania <xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> metodę w celu zapewnienia zarówno wartość limitu czasu i anulowania token, który może zakończyć oczekiwanie na ukończenie zadania. Nowego wątku jest uruchomiona i wykonuje `CancelToken` metodę, która wstrzymuje działanie, a następnie wywołuje <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> metodę, aby anulować anulowanie tokenów. Zadanie to uruchomienia i wybrano opcję opóźnienia 5 sekund. <xref:System.Threading.Tasks.Task.Wait%2A> Metoda jest następnie wywoływana czekać na zakończenie zadania i podano zarówno wartość limitu czasu krótkie, jak i token anulowania.  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/wait4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.Wait#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/wait4.vb#4)]  
  
 Należy pamiętać, że dokładne dane wyjściowe z przykładu zależy, czy czas oczekiwania zostało anulowane z powodu token anulowania lub ponieważ upłynął limit czasu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="cancellationToken" /> Zostało anulowane.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> Został usunięty.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> jest to liczba ujemna niż -1, która reprezentuje nieskończony limit czasu.</exception>
        <exception cref="T:System.AggregateException">Zadanie zostało anulowane. <see cref="P:System.AggregateException.InnerExceptions" /> Kolekcja zawiera <see cref="T:System.Threading.Tasks.TaskCanceledException" /> obiektu.  
  
 —lub—  
  
 Wystąpił wyjątek podczas wykonywania zadania. <see cref="P:System.AggregateException.InnerExceptions" /> Kolekcja zawiera informacje o wyjątków i wyjątków.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAll">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Czeka na wszystkich udostępnionych <see cref="T:System.Threading.Tasks.Task" /> obiekty do ukończenia wykonywania.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static void WaitAll (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WaitAll(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WaitAll (ParamArray tasks As Task())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WaitAll(... cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks">Tablica <see cref="T:System.Threading.Tasks.Task" /> wystąpienia, na którym oczekiwania.</param>
        <summary>Czeka na wszystkich udostępnionych <see cref="T:System.Threading.Tasks.Task" /> obiekty do ukończenia wykonywania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład rozpoczyna się 10 zadań, z których każdy jest przekazywany indeks jako obiekt stanu. Zadania z indeksem od dwóch do pięciu zgłaszają wyjątki. Wywołanie <xref:System.Threading.Tasks.Task.WaitAll%2A> metoda opakowuje wszystkie wyjątki w <xref:System.AggregateException> obiektu i propaguje go do wywołania wątku.  
  
 [!code-csharp[System.Threading.Tasks.Task#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/waitall.cs#02)]
 [!code-vb[System.Threading.Tasks.Task#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/waitall.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Co najmniej jednego <see cref="T:System.Threading.Tasks.Task" /> obiekty w <paramref name="tasks" /> został usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> Argument jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> Argument zawiera element o wartości null.  
  
 —lub—  
  
 <paramref name="tasks" /> Argument ma być pustą tablicą.</exception>
        <exception cref="T:System.AggregateException">Co najmniej jeden z <see cref="T:System.Threading.Tasks.Task" /> wystąpień zostało anulowane. Jeśli zadanie zostało anulowane, <see cref="T:System.AggregateException" /> wyjątek zawiera <see cref="T:System.OperationCanceledException" /> wyjątek w jego <see cref="P:System.AggregateException.InnerExceptions" /> kolekcji.  
  
 —lub—  
  
 Wystąpił wyjątek podczas wykonywania co najmniej jeden z <see cref="T:System.Threading.Tasks.Task" /> wystąpień.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (tasks As Task(), millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="tasks">Tablica <see cref="T:System.Threading.Tasks.Task" /> wystąpienia, na którym oczekiwania.</param>
        <param name="millisecondsTimeout">Wyrażony w milisekundach czas oczekiwania, lub <see cref="F:System.Threading.Timeout.Infinite" /> (-1) będzie czekać w nieskończoność.</param>
        <summary>Czeka na wszystkich udostępnionych <see cref="T:System.Threading.Tasks.Task" /> obiektów do wykonany w ciągu określonej liczby milisekund.</summary>
        <returns>
          <see langword="true" /> Jeśli wszystkie z <see cref="T:System.Threading.Tasks.Task" /> wykonywania wystąpień zakończona w przydzielonym limicie czasu; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Co najmniej jednego <see cref="T:System.Threading.Tasks.Task" /> obiekty w <paramref name="tasks" /> został usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> Argument jest <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Co najmniej jeden z <see cref="T:System.Threading.Tasks.Task" /> wystąpień zostało anulowane. Jeśli zadanie zostało anulowane, <see cref="T:System.AggregateException" /> zawiera <see cref="T:System.OperationCanceledException" /> w jego <see cref="P:System.AggregateException.InnerExceptions" /> kolekcji.  
  
 —lub—  
  
 Wystąpił wyjątek podczas wykonywania co najmniej jeden z <see cref="T:System.Threading.Tasks.Task" /> wystąpień.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> jest to liczba ujemna niż -1, która reprezentuje nieskończony limit czasu.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> Argument zawiera element o wartości null.  
  
 —lub—  
  
 <paramref name="tasks" /> Argument ma być pustą tablicą.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static void WaitAll (System.Threading.Tasks.Task[] tasks, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WaitAll(class System.Threading.Tasks.Task[] tasks, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WaitAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">Tablica <see cref="T:System.Threading.Tasks.Task" /> wystąpienia, na którym oczekiwania.</param>
        <param name="cancellationToken">A <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> aby przyjrzeć się podczas oczekiwania na ukończenie zadań.</param>
        <summary>Czeka na wszystkich udostępnionych <see cref="T:System.Threading.Tasks.Task" /> obiekty do ukończenia wykonywania, o ile nie zostało anulowane, czas oczekiwania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `cancellationToken` Argument jest używany do anulowania operacji oczekiwania. Anulowanie zadań jest operacją distinct i zostanie zasygnalizowane przez <xref:System.AggregateException> wspomnianego powyżej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="cancellationToken" /> Zostało anulowane.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> Argument jest <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Co najmniej jeden z <see cref="T:System.Threading.Tasks.Task" /> wystąpień zostało anulowane. Jeśli zadanie zostało anulowane, <see cref="T:System.AggregateException" /> zawiera <see cref="T:System.OperationCanceledException" /> w jego <see cref="P:System.AggregateException.InnerExceptions" /> kolekcji.  
  
 —lub—  
  
 Wystąpił wyjątek podczas wykonywania co najmniej jeden z <see cref="T:System.Threading.Tasks.Task" /> wystąpień.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> Argument zawiera element o wartości null.  
  
 —lub—  
  
 <paramref name="tasks" /> Argument ma być pustą tablicą.</exception>
        <exception cref="T:System.ObjectDisposedException">Co najmniej jednego <see cref="T:System.Threading.Tasks.Task" /> obiekty w <paramref name="tasks" /> został usunięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.Tasks.Task[] tasks, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.Tasks.Task[] tasks, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (tasks As Task(), timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="tasks">Tablica <see cref="T:System.Threading.Tasks.Task" /> wystąpienia, na którym oczekiwania.</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> reprezentujący wyrażony w milisekundach czas oczekiwania, lub <see cref="T:System.TimeSpan" /> reprezentujący wartość-1 milisekund oczekiwania przez czas nieokreślony.</param>
        <summary>Czeka na wszystkich udostępnionych możliwe <see cref="T:System.Threading.Tasks.Task" /> obiektów, aby zakończyć działanie w określonym przedziale czasu.</summary>
        <returns>
          <see langword="true" /> Jeśli wszystkie z <see cref="T:System.Threading.Tasks.Task" /> wykonywania wystąpień zakończona w przydzielonym limicie czasu; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Co najmniej jednego <see cref="T:System.Threading.Tasks.Task" /> obiekty w <paramref name="tasks" /> został usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> Argument jest <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Co najmniej jeden z <see cref="T:System.Threading.Tasks.Task" /> wystąpień zostało anulowane. Jeśli zadanie zostało anulowane, <see cref="T:System.AggregateException" /> zawiera <see cref="T:System.OperationCanceledException" /> w jego <see cref="P:System.AggregateException.InnerExceptions" /> kolekcji.  
  
 —lub—  
  
 Wystąpił wyjątek podczas wykonywania co najmniej jeden z <see cref="T:System.Threading.Tasks.Task" /> wystąpień.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> jest liczbą ujemną niż-1 milisekund, która reprezentuje nieskończony limit czasu.  
  
 —lub—  
  
 <paramref name="timeout" /> jest większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> Argument zawiera element o wartości null.  
  
 —lub—  
  
 <paramref name="tasks" /> Argument ma być pustą tablicą.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">Tablica <see cref="T:System.Threading.Tasks.Task" /> wystąpienia, na którym oczekiwania.</param>
        <param name="millisecondsTimeout">Wyrażony w milisekundach czas oczekiwania, lub <see cref="F:System.Threading.Timeout.Infinite" /> (-1) będzie czekać w nieskończoność.</param>
        <param name="cancellationToken">A <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> aby przyjrzeć się podczas oczekiwania na ukończenie zadań.</param>
        <summary>Czeka na wszystkich udostępnionych <see cref="T:System.Threading.Tasks.Task" /> obiektów do wykonany w ciągu określonej liczby milisekund lub zostało anulowane, czas oczekiwania.</summary>
        <returns>
          <see langword="true" /> Jeśli wszystkie z <see cref="T:System.Threading.Tasks.Task" /> wykonywania wystąpień zakończona w przydzielonym limicie czasu; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `cancellationToken` Argument jest używany do anulowania operacji oczekiwania. Anulowanie zadań jest operacją distinct i zostanie zasygnalizowane przez <xref:System.AggregateException> wymienionych powyżej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Co najmniej jednego <see cref="T:System.Threading.Tasks.Task" /> obiekty w <paramref name="tasks" /> został usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> Argument jest <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Co najmniej jeden z <see cref="T:System.Threading.Tasks.Task" /> wystąpień zostało anulowane. Jeśli zadanie zostało anulowane, <see cref="T:System.AggregateException" /> zawiera <see cref="T:System.OperationCanceledException" /> w jego <see cref="P:System.AggregateException.InnerExceptions" /> kolekcji.  
  
 —lub—  
  
 Wystąpił wyjątek podczas wykonywania co najmniej jeden z <see cref="T:System.Threading.Tasks.Task" /> wystąpień.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> jest to liczba ujemna niż -1, która reprezentuje nieskończony limit czasu.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> Argument zawiera element o wartości null.  
  
 —lub—  
  
 <paramref name="tasks" /> Argument ma być pustą tablicą.</exception>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="cancellationToken" /> Zostało anulowane.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAny">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Czeka na dowolne z dostarczonych <see cref="T:System.Threading.Tasks.Task" /> obiekty do ukończenia wykonywania.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (ParamArray tasks As Task()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(... cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks">Tablica <see cref="T:System.Threading.Tasks.Task" /> wystąpienia, na którym oczekiwania.</param>
        <summary>Czeka na dowolne z dostarczonych <see cref="T:System.Threading.Tasks.Task" /> obiekty do ukończenia wykonywania.</summary>
        <returns>Indeks ukończonej <see cref="T:System.Threading.Tasks.Task" /> obiektu w <paramref name="tasks" /> tablicy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład powoduje uruchomienie pięć zadań, z których każdy zostanie uśpiony na co najmniej 50 milisekund lub maksymalnie 1,050 milisekund. <xref:System.Threading.Tasks.Task.WaitAny%2A> Metody następnie czeka na zadań do wykonania. W przykładzie przedstawiono zadania, który upłynął czas oczekiwania identyfikator zadania, jak bieżący stan wszystkich zadań.  
  
 [!code-csharp[System.Threading.Tasks.Task.WaitAny#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Tasks.Task.WaitAny/cs/WaitAny1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.WaitAny#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Tasks.Task.WaitAny/vb/WaitAny1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> Został usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> Argument jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> Argument zawiera element o wartości null.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (tasks As Task(), millisecondsTimeout As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="tasks">Tablica <see cref="T:System.Threading.Tasks.Task" /> wystąpienia, na którym oczekiwania.</param>
        <param name="millisecondsTimeout">Wyrażony w milisekundach czas oczekiwania, lub <see cref="F:System.Threading.Timeout.Infinite" /> (-1) będzie czekać w nieskończoność.</param>
        <summary>Czeka na dowolne z dostarczonych <see cref="T:System.Threading.Tasks.Task" /> obiektów do wykonany w ciągu określonej liczby milisekund.</summary>
        <returns>Indeks ukończonego zadania w <paramref name="tasks" /> tablicy argument lub wartość -1, jeśli upłynął limit czasu.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> Został usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> Argument jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> jest to liczba ujemna niż -1, która reprezentuje nieskończony limit czasu.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> Argument zawiera element o wartości null.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">Tablica <see cref="T:System.Threading.Tasks.Task" /> wystąpienia, na którym oczekiwania.</param>
        <param name="cancellationToken">A <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> aby przyjrzeć się podczas oczekiwania na ukończenie zadania.</param>
        <summary>Czeka na dowolne z dostarczonych <see cref="T:System.Threading.Tasks.Task" /> obiekty do ukończenia wykonywania, o ile nie zostało anulowane, czas oczekiwania.</summary>
        <returns>Indeks ukończonego zadania w <paramref name="tasks" /> tablicy argumentu.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> Został usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> Argument jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> Argument zawiera element o wartości null.</exception>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="cancellationToken" /> Zostało anulowane.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (tasks As Task(), timeout As TimeSpan) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="tasks">Tablica <see cref="T:System.Threading.Tasks.Task" /> wystąpienia, na którym oczekiwania.</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> reprezentujący wyrażony w milisekundach czas oczekiwania, lub <see cref="T:System.TimeSpan" /> reprezentujący wartość-1 milisekund oczekiwania przez czas nieokreślony.</param>
        <summary>Czeka na dowolne z dostarczonych <see cref="T:System.Threading.Tasks.Task" /> obiektów, aby zakończyć działanie w określonym przedziale czasu.</summary>
        <returns>Indeks ukończonego zadania w <paramref name="tasks" /> tablicy argument lub wartość -1, jeśli upłynął limit czasu.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> Został usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> Argument jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> jest liczbą ujemną niż-1 milisekund, która reprezentuje nieskończony limit czasu.  
  
 —lub—  
  
 <paramref name="timeout" /> jest większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> Argument zawiera element o wartości null.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">Tablica <see cref="T:System.Threading.Tasks.Task" /> wystąpienia, na którym oczekiwania.</param>
        <param name="millisecondsTimeout">Wyrażony w milisekundach czas oczekiwania, lub <see cref="F:System.Threading.Timeout.Infinite" /> (-1) będzie czekać w nieskończoność.</param>
        <param name="cancellationToken">A <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> aby przyjrzeć się podczas oczekiwania na ukończenie zadania.</param>
        <summary>Czeka na dowolne z dostarczonych <see cref="T:System.Threading.Tasks.Task" /> obiektów do wykonany w ciągu określonej liczby milisekund lub do chwili token anulowania zostało anulowane.</summary>
        <returns>Indeks ukończonego zadania w <paramref name="tasks" /> tablicy argument lub wartość -1, jeśli upłynął limit czasu.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task" /> Został usunięty.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> Argument jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> jest to liczba ujemna niż -1, która reprezentuje nieskończony limit czasu.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> Argument zawiera element o wartości null.</exception>
        <exception cref="T:System.OperationCanceledException">
          <paramref name="cancellationToken" /> Zostało anulowane.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WhenAll">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy zadanie, które zostanie zakończony, po zakończeniu wszystkich zadań dostarczony.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WhenAll">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WhenAll (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WhenAll(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAll (tasks As IEnumerable(Of Task)) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ WhenAll(System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="tasks">Zaczekać ukończenie zadania.</param>
        <summary>Tworzy zadanie, które zostanie zakończony, kiedy wszystkie <see cref="T:System.Threading.Tasks.Task" /> obiektów z kolekcji wyliczalny została ukończona.</summary>
        <returns>Zadanie reprezentujące zakończenie wszystkich zadań dostarczony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążeń <xref:System.Threading.Tasks.Task.WhenAll%2A> metody, która zwraca <xref:System.Threading.Tasks.Task> obiektu są zwykle nazywane Jeśli interesuje Cię w stan zestawu zadań lub wyjątki wyrzucane przez zestaw zadań.  
  
> [!NOTE]
>  Wywołanie <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29> — metoda nie blokuje wątek wywołujący.  
  
 Podany zadań wykona stan, zwrócony zadań zakończy się również w <xref:System.Threading.Tasks.TaskStatus.Faulted> stanu, gdy jego wyjątki będzie zawierać agregacji zestawu bez otoki wyjątki od poszczególnych zadań podany.  
  
 Jeśli żadne zadanie dostarczony komunikacji niezawodnej, ale co najmniej jeden z nich została anulowana, zadanie zwrócone skończy się za <xref:System.Threading.Tasks.TaskStatus.Canceled> stanu.  
  
 Jeśli żadne zadanie komunikacji niezawodnej żadnych zadań zostały anulowane, zadaniu wynikowym skończy się za <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> stanu.  
  
 Jeśli podany tablicy/wyliczenia nie zawiera żadnych zadań, zwracane zadań będzie natychmiast przejście do <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> stanu przed zwróceniem do obiektu wywołującego.  
  
   
  
## Examples  
 Poniższy przykład tworzy zbiór zadań, które polecenie ping adresy URL w tablicy. Zadania są przechowywane w `List<Task>` kolekcji, który jest przekazywany do <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29> metody. Po wywołaniu <xref:System.Threading.Tasks.Task.Wait%2A> metoda gwarantuje, że zostały wykonane wszystkie wątki, sprawdza przykładzie <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> właściwości w celu określenia, czy ma błędny żadnych zadań.  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/WhenAll4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/WhenAll4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> Argument był <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> Kolekcji znajdującej się <see langword="null" /> zadań.</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAll">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WhenAll (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WhenAll(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAll (ParamArray tasks As Task()) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ WhenAll(... cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks">Zaczekać ukończenie zadania.</param>
        <summary>Tworzy zadanie, które zostanie zakończony, kiedy wszystkie <see cref="T:System.Threading.Tasks.Task" /> obiektów w tablicy została ukończona.</summary>
        <returns>Zadanie reprezentujące zakończenie wszystkich zadań dostarczony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążeń <xref:System.Threading.Tasks.Task.WhenAll%2A> metody, która zwraca <xref:System.Threading.Tasks.Task> obiektu są zwykle nazywane Jeśli interesuje Cię w stan zestawu zadań lub wyjątki wyrzucane przez zestaw zadań.  
  
> [!NOTE]
>  Wywołanie <xref:System.Threading.Tasks.Task.WhenAll%28System.Threading.Tasks.Task%5B%5D%29> — metoda nie blokuje wątek wywołujący.  
  
 Podany zadań wykona stan, zwrócony zadań zakończy się również w <xref:System.Threading.Tasks.TaskStatus.Faulted> stanu, gdy jego wyjątki będzie zawierać agregacji zestawu bez otoki wyjątki od poszczególnych zadań podany.  
  
 Jeśli żadne zadanie dostarczony komunikacji niezawodnej, ale co najmniej jeden z nich została anulowana, zadanie zwrócone skończy się za <xref:System.Threading.Tasks.TaskStatus.Canceled> stanu.  
  
 Jeśli żadne zadanie komunikacji niezawodnej żadnych zadań zostały anulowane, zadaniu wynikowym skończy się za <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> stanu.  
  
 Jeśli podany tablicy/wyliczenia nie zawiera żadnych zadań, zwracane zadań będzie natychmiast przejście do <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> stanu przed zwróceniem do obiektu wywołującego.  
  
   
  
## Examples  
 Poniższy przykład tworzy zbiór zadań, które polecenie ping adresy URL w tablicy. Zadania są przechowywane w `List<Task>` kolekcji, która jest konwertowana na tablicę i przekazywane do <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29> metody. Po wywołaniu <xref:System.Threading.Tasks.Task.Wait%2A> metoda gwarantuje, że zostały wykonane wszystkie wątki, sprawdza przykładzie <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> właściwości w celu określenia, czy ma błędny żadnych zadań.  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/WhenAll3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/WhenAll3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> Argument był <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> Tablica <see langword="null" /> zadań.</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAll&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult[]&gt; WhenAll&lt;TResult&gt; (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult[]&gt; WhenAll&lt;TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAll(Of TResult) (tasks As IEnumerable(Of Task(Of TResult))) As Task(Of TResult())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;cli::array &lt;TResult&gt; ^&gt; ^ WhenAll(System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ tasks);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult[]&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ ukończonego zadania.</typeparam>
        <param name="tasks">Zaczekać ukończenie zadania.</param>
        <summary>Tworzy zadanie, które zostanie zakończony, kiedy wszystkie <see cref="T:System.Threading.Tasks.Task`1" /> obiektów z kolekcji wyliczalny została ukończona.</summary>
        <returns>Zadanie reprezentujące zakończenie wszystkich zadań dostarczony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie <xref:System.Threading.Tasks.Task.WhenAll%60%601%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7B%60%600%7D%7D%29> — metoda nie blokuje wątek wywołujący. Jednak wywołaniu zwracana <xref:System.Threading.Tasks.Task%601.Result%2A> właściwości zablokować wywołania wątku.  
  
 Podany zadań wykona stan, zwrócony zadań zakończy się również w <xref:System.Threading.Tasks.TaskStatus.Faulted> stanu, gdy jego wyjątki będzie zawierać agregacji zestawu bez otoki wyjątki od poszczególnych zadań podany.  
  
 Jeśli żadne zadanie dostarczony komunikacji niezawodnej, ale co najmniej jeden z nich została anulowana, zadanie zwrócone skończy się za <xref:System.Threading.Tasks.TaskStatus.Canceled> stanu.  
  
 Jeśli żadne zadanie komunikacji niezawodnej żadnych zadań zostały anulowane, zadaniu wynikowym skończy się za <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> stanu.  <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> Właściwość zwrócone zadania zostanie ustawiona na tablicę zawierającą wszystkie wyniki zadań podane w tej samej kolejności, ponieważ zostały one udostępniane (np. Jeśli dane wejściowe zadania tablica t1, t2, t3, dane wyjściowe zadania <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> zwróci właściwości `TResult[]` gdzie `arr[0] == t1.Result, arr[1] == t2.Result, and arr[2] == t3.Result)`.  
  
 Jeśli `tasks` argument nie zawiera żadnych zadań, zadanie zwrócone natychmiast spowoduje przejście do <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> stanu przed zwróceniem do obiektu wywołującego. Zwrócona `TResult[]` będzie tablicę elementów 0.  
  
   
  
## Examples  
 Poniższy przykład tworzy dziesięciu zadań, z których każdy tworzy generator liczb losowych, które tworzy 1000 losowych liczb od 1 do 1000 i oblicza średnią ich. <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> Metoda jest używana do opóźnienia wystąpienia losowych liczb generatory tak, aby nie są tworzone z wartościami identyczne inicjatora. Wywołanie <xref:System.Threading.Tasks.Task.WhenAll%2A> następnie metoda zwraca <xref:System.Int64> tablica zawierająca wartości średniej obliczone przez każdego zadania. Następnie są one używane do obliczania średniej ogólnej.  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/whenall1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/whenall1.vb#1)]  
  
 W takim przypadku dziesięć poszczególne zadania są przechowywane w <xref:System.Collections.Generic.List%601> obiektu. <xref:System.Collections.Generic.List%601> implementuje <xref:System.Collections.Generic.IEnumerable%601> interfejsu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> Argument był <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> Kolekcji znajdującej się <see langword="null" /> zadań.</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAll&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult[]&gt; WhenAll&lt;TResult&gt; (params System.Threading.Tasks.Task&lt;TResult&gt;[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult[]&gt; WhenAll&lt;TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TResult&gt;[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAll(Of TResult) (ParamArray tasks As Task(Of TResult)()) As Task(Of TResult())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;cli::array &lt;TResult&gt; ^&gt; ^ WhenAll(... cli::array &lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ tasks);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult[]&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TResult&gt;[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ ukończonego zadania.</typeparam>
        <param name="tasks">Zaczekać ukończenie zadania.</param>
        <summary>Tworzy zadanie, które zostanie zakończony, kiedy wszystkie <see cref="T:System.Threading.Tasks.Task`1" /> obiektów w tablicy została ukończona.</summary>
        <returns>Zadanie reprezentujące zakończenie wszystkich zadań dostarczony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie <xref:System.Threading.Tasks.Task.WhenAll%60%601%28System.Threading.Tasks.Task%7B%60%600%7D%5B%5D%29> — metoda nie blokuje wątek wywołujący. Jednak wywołaniu zwracana <xref:System.Threading.Tasks.Task%601.Result%2A> właściwości zablokować wywołania wątku.  
  
 Podany zadań wykona stan, zwrócony zadań zakończy się również w <xref:System.Threading.Tasks.TaskStatus.Faulted> stanu, gdy jego wyjątki będzie zawierać agregacji zestawu bez otoki wyjątki od poszczególnych zadań podany.  
  
 Jeśli żadne zadanie dostarczony komunikacji niezawodnej, ale co najmniej jeden z nich została anulowana, zadanie zwrócone skończy się za <xref:System.Threading.Tasks.TaskStatus.Canceled> stanu.  
  
 Jeśli żadne zadanie komunikacji niezawodnej żadnych zadań zostały anulowane, zadaniu wynikowym skończy się za <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> stanu.  <xref:System.Threading.Tasks.Task%601.Result%2A> Zwrócone zadania zostaną ustawione na tablicę zawierającą wszystkie wyniki zadań podane w tej samej kolejności, ponieważ zostały one udostępniane (np. Jeśli dane wejściowe zadania tablica t1, t2, t3, dane wyjściowe zadania <xref:System.Threading.Tasks.Task%601.Result%2A> zwróci `TResult[]` gdzie `arr[0] == t1.Result, arr[1] == t2.Result, and arr[2] == t3.Result)`.  
  
 Jeśli podany tablicy/wyliczenia nie zawiera żadnych zadań, zwracane zadań będzie natychmiast przejście do <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> stanu przed zwróceniem do obiektu wywołującego.  Zwrócona `TResult[]` będzie tablicę elementów 0.  
  
   
  
## Examples  
 Poniższy przykład tworzy dziesięciu zadań, z których każdy tworzy generator liczb losowych, które tworzy 1000 losowych liczb od 1 do 1000 i oblicza średnią ich. W takim przypadku dziesięć poszczególne zadania są przechowywane w `Task<Int64>` tablicy.  <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> Metoda jest używana do opóźnienia wystąpienia losowych liczb generatory tak, aby nie są tworzone z wartościami identyczne inicjatora. Wywołanie <xref:System.Threading.Tasks.Task.WhenAll%2A> następnie metoda zwraca <xref:System.Int64> tablica zawierająca wartości średniej obliczone przez każdego zadania. Następnie są one używane do obliczania średniej ogólnej.  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/whenall2.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/whenall2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> Argument był <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> Tablica <see langword="null" /> zadań.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WhenAny">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy zadanie, które ukończy po zakończeniu dostarczony zadań.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WhenAny">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt; WhenAny (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task&gt; WhenAny(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAny (tasks As IEnumerable(Of Task)) As Task(Of Task)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task&lt;System::Threading::Tasks::Task ^&gt; ^ WhenAny(System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="tasks">Zaczekać ukończenie zadania.</param>
        <summary>Tworzy zadanie, które ukończy po zakończeniu dostarczony zadań.</summary>
        <returns>Zadanie reprezentujące zakończenia jeden z dostarczonego zadania.  Zwracany wynik zadania jest zadania, które wykonane.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zadanie zwrócone ukończy, kiedy dostarczony zadań została ukończona.  Zawsze kończy zadanie zwracane w `RanToCompletion` stanu z jej zestaw wyników do pierwszego zadania do wykonania.  Dotyczy to nawet wtedy, gdy pierwszy na zakończenie zadania zakończone w `Canceled` lub `Faulted` stanu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> Argument był <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> Tablicy zawierał zadanie wartości null lub jest pusta.</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAny">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt; WhenAny (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task&gt; WhenAny(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny(System.Threading.Tasks.Task[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAny (ParamArray tasks As Task()) As Task(Of Task)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task&lt;System::Threading::Tasks::Task ^&gt; ^ WhenAny(... cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks">Zaczekać ukończenie zadania.</param>
        <summary>Tworzy zadanie, które ukończy po zakończeniu dostarczony zadań.</summary>
        <returns>Zadanie reprezentujące zakończenia jeden z dostarczonego zadania.  Zwracany wynik zadania jest zadania, które wykonane.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zadanie zwrócone ukończy, kiedy dostarczony zadań została ukończona.  Zawsze kończy zadanie zwracane w `RanToCompletion` stanu z jego `Result` ustawioną pierwszego zadania do wykonania.  Dotyczy to nawet wtedy, gdy pierwszy na zakończenie zadania zakończone w `Canceled` lub `Faulted` stanu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> Argument miał wartość null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> Tablicy zawierał zadanie wartości null lub jest pusta.</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAny&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; WhenAny&lt;TResult&gt; (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; WhenAny&lt;TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAny(Of TResult) (tasks As IEnumerable(Of Task(Of TResult))) As Task(Of Task(Of TResult))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ WhenAny(System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ tasks);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ ukończonego zadania.</typeparam>
        <param name="tasks">Zaczekać ukończenie zadania.</param>
        <summary>Tworzy zadanie, które ukończy po zakończeniu dostarczony zadań.</summary>
        <returns>Zadanie reprezentujące zakończenia jeden z dostarczonego zadania.  Zwracany wynik zadania jest zadania, które wykonane.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zadanie zwrócone ukończy, kiedy dostarczony zadań została ukończona.  Zadanie zwrócone zawsze kończy w stanie RanToCompletion z jej zestaw wyników do pierwszego zadania do wykonania. Dotyczy to nawet wtedy, gdy pierwszy na zakończenie zadania zakończone w stanie anulowane lub Faulted.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> Argument był <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> Tablicy zawierał zadanie wartości null lub jest pusta.</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAny&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; WhenAny&lt;TResult&gt; (params System.Threading.Tasks.Task&lt;TResult&gt;[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; WhenAny&lt;TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TResult&gt;[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny``1(System.Threading.Tasks.Task{``0}[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAny(Of TResult) (ParamArray tasks As Task(Of TResult)()) As Task(Of Task(Of TResult))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ WhenAny(... cli::array &lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ tasks);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TResult&gt;[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TResult">Typ ukończonego zadania.</typeparam>
        <param name="tasks">Zaczekać ukończenie zadania.</param>
        <summary>Tworzy zadanie, które ukończy po zakończeniu dostarczony zadań.</summary>
        <returns>Zadanie reprezentujące zakończenia jeden z dostarczonego zadania.  Zwracany wynik zadania jest zadania, które wykonane.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zadanie zwrócone ukończy, kiedy dostarczony zadań została ukończona.  Zadanie zwrócone zawsze kończy w stanie RanToCompletion z jej zestaw wyników do pierwszego zadania do wykonania. Dotyczy to nawet wtedy, gdy pierwszy na zakończenie zadania zakończone w stanie anulowane lub Faulted.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="tasks" /> Argument miał wartość null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="tasks" /> Tablicy zawierał zadanie wartości null lub jest pusta.</exception>
      </Docs>
    </Member>
    <Member MemberName="Yield">
      <MemberSignature Language="C#" Value="public static System.Runtime.CompilerServices.YieldAwaitable Yield ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Runtime.CompilerServices.YieldAwaitable Yield() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Yield" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Yield () As YieldAwaitable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::CompilerServices::YieldAwaitable Yield();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.CompilerServices.YieldAwaitable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy zadanie oczekujący, które asynchronicznie daje do bieżącego kontekstu, gdy oczekiwane.</summary>
        <returns>Kontekst, gdy oczekiwane, asynchronicznie spowoduje przejście do bieżącego kontekstu w czasie await. Jeśli bieżący <see cref="T:System.Threading.SynchronizationContext" /> jest różna od null, jest ona traktowana jako bieżący kontekst. W przeciwnym razie Harmonogram zadań, który jest skojarzony z aktualnie wykonywanego zadania są traktowane jako bieżący kontekst.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można użyć `await Task.Yield();` w metodę asynchroniczną, aby wymusić metodę, aby ukończyć asynchronicznie. Jeśli bieżący kontekst synchronizacji (<xref:System.Threading.SynchronizationContext> obiektu), to zostanie wysłany w pozostałej części wykonanie metody do tego kontekstu. Jednak kontekście podejmie decyzję, jak priorytety tę pracę względem innych prac, które mogą być oczekujące. Kontekst synchronizacji, który znajduje się w wątku interfejsu użytkownika w większości środowisk interfejsu użytkownika często priorytetów pracy publikowane w kontekście wyższym niż dane wejściowe i renderowania pracy. Z tego powodu nie należy polegać na `await Task.Yield();` do zachowania reakcji interfejsu użytkownika.  Aby uzyskać więcej informacji, zobacz wpis [przydatne abstrakcje z włączoną ContinueWith](http://blogs.msdn.com/b/pfxteam/archive/2008/07/23/8768673.aspx) w programowania równoległego z blogu .NET.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
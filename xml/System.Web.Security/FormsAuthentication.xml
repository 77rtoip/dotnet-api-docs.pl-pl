<Type Name="FormsAuthentication" FullName="System.Web.Security.FormsAuthentication">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b0ed0a6e65813100f358397ce81f86db5d981f0e" />
    <Meta Name="ms.sourcegitcommit" Value="e7865e39826e7aaf54da4c7042975153813a31c7" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/16/2018" />
    <Meta Name="ms.locfileid" Value="31043504" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class FormsAuthentication" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit FormsAuthentication extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.Security.FormsAuthentication" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class FormsAuthentication" />
  <TypeSignature Language="C++ CLI" Value="public ref class FormsAuthentication sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Zarządza usługi uwierzytelniania formularzy dla aplikacji sieci Web. Klasa ta nie może być dziedziczona.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uwierzytelnianie formularzy umożliwia użytkownika i sprawdzanie poprawności hasła dla aplikacji sieci Web, które nie wymagają uwierzytelniania systemu Windows. Za pomocą uwierzytelniania formularzy, informacje użytkownika są przechowywane w zewnętrznym źródłem danych, takich jak <xref:System.Web.Security.Membership> bazy danych, lub w pliku konfiguracyjnym aplikacji. Po uwierzytelnieniu użytkownika, uwierzytelnianie formularzy przechowuje biletu uwierzytelniania w pliku cookie lub adres URL, dzięki czemu uwierzytelniony użytkownik nie musi podać poświadczenia z każdym żądaniem.  
  
 Uwierzytelnianie formularzy jest włączone ustawienie `mode` atrybutu elementu konfiguracji, aby `Forms`. Można wymagać, że wszystkie żądania kierowane do aplikacji zawierają biletu uwierzytelniania prawidłowego użytkownika przy użyciu elementu konfiguracji odrzucanie żądania dowolny użytkownik nieznany, jak pokazano w poniższym przykładzie.  
  
```  
<system.web>  
  <authentication mode="Forms">  
    <forms loginUrl="login.aspx" />  
  </authentication>  
  <authorization>  
    <deny users="?" />  
  </authorization>  
</system.web>  
```  
  
 W poprzednim przykładzie wszystkie żądania dla strony platformy ASP.NET, która jest częścią aplikacji wymaga prawidłowej nazwy użytkownika, która jest dostarczana przez uwierzytelnianie oparte na formularzach. Jeśli nie ma żadnej nazwy użytkownika, wówczas żądanie jest przekierowywane do skonfigurowanego <xref:System.Web.Security.FormsAuthentication.LoginUrl%2A>.  
  
 <xref:System.Web.Security.FormsAuthentication> Klasy zapewnia dostęp do metody i właściwości, których można używać w aplikacji, która służy do uwierzytelniania użytkowników. <xref:System.Web.Security.FormsAuthentication.RedirectToLoginPage%2A> Metody przekierowania przeglądarki do skonfigurowanego <xref:System.Web.Security.FormsAuthentication.LoginUrl%2A> dla użytkowników zalogować się do aplikacji. <xref:System.Web.Security.FormsAuthentication.RedirectFromLoginPage%2A> Metody przekierowuje użytkownika uwierzytelnionego wstecz do oryginalnego chronionych adresu URL, którego zażądano lub <xref:System.Web.Security.FormsAuthentication.DefaultUrl%2A>. Brak metody, które umożliwiają zarządzanie biletów uwierzytelniania formularzy, jeśli to konieczne.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia plik Web.config dla aplikacji ASP.NET, która używa dostawcy członkostwa ASP.NET dla uwierzytelniania formularzy i wymaga od wszystkich użytkowników mają być uwierzytelniani.  
  
```  
<configuration>  
  <connectionStrings>  
    <add name="SqlServices" connectionString="Data Source=MySqlServer;Integrated Security=SSPI;Initial Catalog=aspnetdb;" />  
  </connectionStrings>  
  <system.web>  
    <membership defaultProvider="SqlProvider" userIsOnlineTimeWindow="20">  
      <providers>  
        <add name="SqlProvider"  
          type="System.Web.Security.SqlMembershipProvider"  
          connectionStringName="SqlServices"  
          enablePasswordRetrieval="false"  
          enablePasswordReset="true"  
          requiresQuestionAndAnswer="true"  
          passwordFormat="Hashed"  
          applicationName="/" />  
      </providers>  
    </membership>  
  </system.web>  
</configuration>  
```  
  
 Poniższy przykład kodu pokazuje stronę logowania dla aplikacji ASP.NET, która korzysta z uwierzytelniania formularzy i członkostwa ASP.NET.  
  
> [!IMPORTANT]
>  Ten przykład zawiera pole tekstowe, który akceptuje dane wejściowe użytkownika, który jest potencjalnym zagrożeniem dla bezpieczeństwa. Domyślnie strony sieci Web ASP.NET zweryfikować, czy dane wejściowe użytkownika nie obejmuje skrypt lub elementów HTML. Aby uzyskać więcej informacji, zobacz [Przegląd wykorzystuje skryptu](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[System.Web.Security.SqlMembershipProvider#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.SqlMembershipProvider/CS/logincs.aspx#1)]
 [!code-aspx-vb[System.Web.Security.SqlMembershipProvider#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.SqlMembershipProvider/VB/loginvb.aspx#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Web.AspNetHostingPermission">Aby użyć <see cref="T:System.Web.Security.FormsAuthentication" /> klasy w środowisku hostowanej. Żądanie wartość: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Wartość uprawnienia: <see cref="F:System.Web.AspNetHostingPermissionLevel.Minimal" />.</permission>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FormsAuthentication ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.FormsAuthentication.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FormsAuthentication();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Web.Security.FormsAuthentication" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor nie jest przeznaczony do użycia w kodzie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Authenticate">
      <MemberSignature Language="C#" Value="public static bool Authenticate (string name, string password);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Authenticate(string name, string password) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.FormsAuthentication.Authenticate(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Authenticate (name As String, password As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Authenticate(System::String ^ name, System::String ^ password);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is to use the Membership APIs, such as Membership.ValidateUser. For more information, see http://go.microsoft.com/fwlink/?LinkId=252463.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="password" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa użytkownika.</param>
        <param name="password">Hasło dla użytkownika.</param>
        <summary>Weryfikuje nazwy użytkownika i hasło dla poświadczeń przechowywanych w pliku konfiguracyjnym aplikacji.</summary>
        <returns>
          <see langword="true" /> Jeśli nazwa użytkownika i hasło są prawidłowe; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda uwierzytelniania weryfikuje poświadczenia użytkownika, które są przechowywane w sekcji pliku konfiguracji aplikacji. Alternatywnie można użyć członkostwa ASP.NET do przechowywania poświadczeń użytkownika i wywołanie <xref:System.Web.Security.MembershipProvider.ValidateUser%2A> do zweryfikowania poświadczeń. Aby uzyskać więcej informacji, zobacz [Zarządzanie użytkownikami przy użyciu członkostwa](http://msdn.microsoft.com/library/824c3a24-f0af-427c-a652-0d2d1e9397cd).  
  
 Ze względów bezpieczeństwa hasła przechowywane w pliku konfiguracyjnym aplikacji przy użyciu można zaszyfrować <xref:System.Web.Security.FormsAuthentication.HashPasswordForStoringInConfigFile%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje poświadczenia użytkownika przechowywane w pliku Web.config aplikacji. Wartości hasła zostały mieszany przy użyciu <xref:System.Web.Security.FormsAuthentication.HashPasswordForStoringInConfigFile%2A> metody.  
  
 `<authentication mode="Forms">`  
  
 `<forms loginUrl="login.aspx">`  
  
 `<credentials passwordFormat="SHA1">`  
  
 `<user name="user1"   password="27CE4CA7FBF00685AF2F617E3F5BBCAFF7B7403C" />`  
  
 `<user name="user2"   password="D108F80936F78DFDD333141EBC985B0233A30C7A" />`  
  
 `<user name="user3" password="7BDB09781A3F23885CD43177C0508B375CB1B7E9"/>`  
  
 `</credentials>`  
  
 `</forms>`  
  
 `</authentication>`  
  
 Poniższy przykład kodu pokazuje stronę logowania, która używa <xref:System.Web.Security.FormsAuthentication.Authenticate%2A> metody w celu sprawdzenia poświadczeń użytkownika.  
  
> [!IMPORTANT]
>  Ten przykład zawiera pole tekstowe, który akceptuje dane wejściowe użytkownika, który jest potencjalnym zagrożeniem dla bezpieczeństwa. Domyślnie strony sieci Web ASP.NET zweryfikować, czy dane wejściowe użytkownika nie obejmuje skrypt lub elementów HTML. Aby uzyskać więcej informacji, zobacz [Przegląd wykorzystuje skryptu](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[System.Web.Security.FormsAuthentication#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.FormsAuthentication/CS/logincs.aspx#1)]
 [!code-aspx-vb[System.Web.Security.FormsAuthentication#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.FormsAuthentication/VB/loginvb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CookieDomain">
      <MemberSignature Language="C#" Value="public static string CookieDomain { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CookieDomain" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.FormsAuthentication.CookieDomain" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CookieDomain As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CookieDomain { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość domeny pliku cookie uwierzytelniania formularzy.</summary>
        <value>
          <see cref="P:System.Web.HttpCookie.Domain" /> Pliku cookie uwierzytelniania formularzy. Wartością domyślną jest ciąg pusty ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.FormsAuthentication.CookieDomain%2A> Wartość właściwości jest ustawiana w pliku konfiguracji dla aplikacji ASP.NET przy użyciu `domain` atrybut elementu konfiguracji. <xref:System.Web.Security.FormsAuthentication.CookieDomain%2A> Określa wartość właściwości <xref:System.Web.HttpCookie.Domain%2A> który plik cookie będzie używany dla.  
  
   
  
## Examples  
 Poniższy kod przykładzie `domain` atrybutu w pliku Web.config.  
  
```  
<authentication mode="Forms">  
  <forms loginUrl="member_login.aspx"  
    cookieless="UseCookies"  
    domain="contoso.com" />  
</authentication>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CookieMode">
      <MemberSignature Language="C#" Value="public static System.Web.HttpCookieMode CookieMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Web.HttpCookieMode CookieMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.FormsAuthentication.CookieMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CookieMode As HttpCookieMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Web::HttpCookieMode CookieMode { System::Web::HttpCookieMode get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpCookieMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy aplikacja jest skonfigurowana na potrzeby uwierzytelniania formularzy bez plików cookie.</summary>
        <value>Jeden z <see cref="T:System.Web.HttpCookieMode" /> wartości, które wskazuje, czy aplikacja jest skonfigurowana na potrzeby uwierzytelniania formularzy bez plików cookie. Wartość domyślna to <see cref="F:System.Web.HttpCookieMode.UseDeviceProfile" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.FormsAuthentication.CookieMode%2A> Właściwość odzwierciedla wartość `cookieless` atrybut elementu konfiguracji. <xref:System.Web.Security.FormsAuthentication.CookieMode%2A> Właściwość określa, czy <xref:System.Web.Security.FormsAuthenticationTicket> wartości będą przechowywane w pliku cookie sesji w przeglądarce lub przechowywane w <xref:System.Web.HttpRequest.QueryString%2A> właściwości.  
  
> [!NOTE]
>  Gdy <xref:System.Web.Security.FormsAuthenticationTicket> wartość jest przechowywana w identyfikatorze URI, długość wygenerowanego identyfikatora URI może być dłuższa niż maksymalna dozwolona długość. Jest to najbardziej prawdopodobne podczas <xref:System.Web.Security.FormsAuthentication.FormsCookiePath%2A> właściwość jest ustawiona na nazwę aplikacji i jest długa nazwa aplikacji (co najmniej 40 znaków), gdy nazwy użytkownika w aplikacji jest długa lub gdy długie <xref:System.Web.Security.FormsAuthenticationTicket.UserData%2A> ciągi są przechowywane w <xref:System.Web.Security.FormsAuthenticationTicket> wartość. Jeśli wygenerowanego identyfikatora URI jest zbyt długi, serwer sieci Web zwróci `400 - Bad Request` błędu.  
  
   
  
## Examples  
 Poniższy kod przykładzie `cookieless` atrybutu `AutoDetect` w pliku Web.config.  
  
```  
<authentication mode="Forms">  
  <forms loginUrl="member_login.aspx"  
    cookieless="AutoDetect" />  
</authentication>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CookieSameSite">
      <MemberSignature Language="C#" Value="public static System.Web.SameSiteMode CookieSameSite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Web.SameSiteMode CookieSameSite" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.FormsAuthentication.CookieSameSite" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CookieSameSite As SameSiteMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Web::SameSiteMode CookieSameSite { System::Web::SameSiteMode get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.SameSiteMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość atrybutu SameSite pliku cookie.</summary>
        <value>Jedna z wartości wyliczenia, które reprezentuje trybu wymuszania z pliku cookie. Wartość domyślna to <see cref="F:System.Web.SameSiteMode.Lax" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CookiesSupported">
      <MemberSignature Language="C#" Value="public static bool CookiesSupported { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool CookiesSupported" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.FormsAuthentication.CookiesSupported" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CookiesSupported As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool CookiesSupported { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy aplikacja jest skonfigurowana do obsługi uwierzytelniania formularzy bez plików cookie.</summary>
        <value>
          <see langword="false" /> Jeśli aplikacja jest skonfigurowana do obsługi uwierzytelniania formularzy cookieless; w przeciwnym razie <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.FormsAuthentication.CookiesSupported%2A> Właściwość zwraca wartość na podstawie <xref:System.Web.Security.FormsAuthentication.CookieMode%2A> wartość i możliwości przeglądarki.  
  
-   Jeśli <xref:System.Web.Security.FormsAuthentication.CookieMode%2A> właściwość jest ustawiona na <xref:System.Web.HttpCookieMode.UseCookies>, <xref:System.Web.Security.FormsAuthentication.CookiesSupported%2A> właściwość, którą będzie zwracać `true`.  
  
-   Jeśli <xref:System.Web.Security.FormsAuthentication.CookieMode%2A> właściwość jest ustawiona na <xref:System.Web.HttpCookieMode.UseUri>, <xref:System.Web.Security.FormsAuthentication.CookiesSupported%2A> właściwość, którą będzie zwracać `false`.  
  
-   Jeśli <xref:System.Web.Security.FormsAuthentication.CookieMode%2A> właściwość jest ustawiona na <xref:System.Web.HttpCookieMode.AutoDetect>, <xref:System.Web.Security.FormsAuthentication.CookiesSupported%2A> właściwość, którą będzie zwracać `true` Jeśli przeglądarka obsługuje pliki cookie i pliki cookie są włączone; w przeciwnym razie <xref:System.Web.Security.FormsAuthentication.CookiesSupported%2A> właściwość, którą będzie zwracać `false`.  
  
-   Jeśli <xref:System.Web.Security.FormsAuthentication.CookieMode%2A> właściwość jest ustawiona na <xref:System.Web.HttpCookieMode.UseDeviceProfile>, <xref:System.Web.Security.FormsAuthentication.CookiesSupported%2A> właściwość, którą będzie zwracać `true` Jeśli <xref:System.Web.HttpRequest.Browser%2A> dla bieżącego <xref:System.Web.HttpContext.Request%2A> obsługuje pliki cookie i przekierowanie plików cookie; w przeciwnym razie <xref:System.Web.Security.FormsAuthentication.CookiesSupported%2A> Właściwość, którą będzie zwracać `false`.  
  
   
  
## Examples  
 Poniższy kod przykładzie `cookieless` atrybutu <xref:System.Web.HttpCookieMode.UseUri> w pliku Web.config. Ta konfiguracja może skutkować <xref:System.Web.Security.FormsAuthentication.CookiesSupported%2A> właściwość `false`.  
  
```  
<authentication mode="Forms">  
  <forms loginUrl="member_login.aspx"  
    cookieless="UseUri" />  
</authentication>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Decrypt">
      <MemberSignature Language="C#" Value="public static System.Web.Security.FormsAuthenticationTicket Decrypt (string encryptedTicket);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Web.Security.FormsAuthenticationTicket Decrypt(string encryptedTicket) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.FormsAuthentication.Decrypt(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Decrypt (encryptedTicket As String) As FormsAuthenticationTicket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Web::Security::FormsAuthenticationTicket ^ Decrypt(System::String ^ encryptedTicket);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Security.FormsAuthenticationTicket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="encryptedTicket" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="encryptedTicket">Bilet uwierzytelniania szyfrowanego.</param>
        <summary>Tworzy <see cref="T:System.Web.Security.FormsAuthenticationTicket" /> obiektu oparte na biletu uwierzytelniania formularzy zaszyfrowanych przekazywany do metody.</summary>
        <returns>A <see cref="T:System.Web.Security.FormsAuthenticationTicket" /> obiektu. Jeśli <paramref name="encryptedTicket" /> parametr nie jest prawidłowy bilet <see langword="null" /> jest zwracany.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="encryptedTicket" /> jest <see langword="null" />.  
  
 \- lub -  
  
 <paramref name="encryptedTicket" /> to ciąg pusty ("").  
  
 \- lub -  
  
 Długość <paramref name="encryptedTicket" /> jest większa niż 4096 znaków.  
  
 \- lub -  
  
 <paramref name="encryptedTicket" /> ma nieprawidłowy format.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultUrl">
      <MemberSignature Language="C#" Value="public static string DefaultUrl { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string DefaultUrl" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.FormsAuthentication.DefaultUrl" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DefaultUrl As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ DefaultUrl { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera adres URL, który <see cref="T:System.Web.Security.FormsAuthentication" /> klasy przekieruje, jeśli nie przekierowania określony adres URL.</summary>
        <value>Adres URL który <see cref="T:System.Web.Security.FormsAuthentication" /> klasy przekieruje, jeśli nie przekierowania określony adres URL. Wartość domyślna to "default.aspx".</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.FormsAuthentication.DefaultUrl%2A> Wartość właściwości jest ustawiana w pliku konfiguracji dla aplikacji ASP.NET przy użyciu `defaultUrl` atrybut elementu konfiguracji. <xref:System.Web.Security.FormsAuthentication.DefaultUrl%2A> Jest używana przez <xref:System.Web.Security.FormsAuthentication.RedirectFromLoginPage%2A> metodę, jeśli nie zwrotny adres URL jest zawarte w żądaniu. Podobnie <xref:System.Web.Security.FormsAuthentication.GetRedirectUrl%2A> metoda zwróci <xref:System.Web.Security.FormsAuthentication.DefaultUrl%2A> Jeśli nie zwrotny adres URL jest uwzględniony w żądaniu.  
  
   
  
## Examples  
 Poniższy kod przykładzie `defaultUrl` atrybutu w pliku Web.config.  
  
```  
<authentication mode="Forms">  
  <forms loginUrl="member_login.aspx"  
    defaultUrl="index.aspx" />  
</authentication>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableCrossAppRedirects">
      <MemberSignature Language="C#" Value="public static bool EnableCrossAppRedirects { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool EnableCrossAppRedirects" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.FormsAuthentication.EnableCrossAppRedirects" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property EnableCrossAppRedirects As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool EnableCrossAppRedirects { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy uwierzytelnieni użytkownicy mogą zostać przekierowane do adresów URL w innych aplikacjach sieci Web.</summary>
        <value>
          <see langword="true" /> Jeśli uwierzytelnieni użytkownicy mogą zostać przekierowane do adresów URL w innych aplikacji sieci Web. w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.FormsAuthentication.EnableCrossAppRedirects%2A> Wartość właściwości jest ustawiana za pomocą `enableCrossAppRedirects` atrybut elementu konfiguracji.  
  
 <xref:System.Web.Security.FormsAuthentication.EnableCrossAppRedirects%2A> Właściwość jest zaznaczona w <xref:System.Web.Security.FormsAuthentication.RedirectFromLoginPage%2A> metodą podczas przekierowania adresu URL nie wskazuje stronę w bieżącej aplikacji. Jeśli <xref:System.Web.Security.FormsAuthentication.EnableCrossAppRedirects%2A> jest `true`, a następnie przekierowania jest wykonywane; Jeśli <xref:System.Web.Security.FormsAuthentication.EnableCrossAppRedirects%2A> jest `false`, przeglądarki zostanie przekierowany do strony, zdefiniowanych w <xref:System.Web.Security.FormsAuthentication.DefaultUrl%2A> właściwości.  
  
> [!NOTE]
>  Podczas przekierowywania stron w aplikacjach, to należy się upewnić, że określonych atrybutów w elemencie konfiguracji są duplikowane w aplikacjach uwierzytelniony. Aby uzyskać więcej informacji i przykład zobacz [uwierzytelniania formularzy w aplikacjach](http://msdn.microsoft.com/library/99e2f9e8-5b97-4a4d-a4ed-5f93276053b7).  
  
> [!IMPORTANT]
>  Podczas przekierowania międzyaplikacyjnej są dozwolone, witryny jest narażony na zabezpieczeniach kieruje użytkowników do niebezpiecznej witryny sieci Web, która używa strony logowania w witrynie. Zawsze Sprawdź, czy adres URL przekierowania, który jest zwracany przez <xref:System.Web.Security.FormsAuthentication.GetRedirectUrl%2A> metoda jest adres URL, którego oczekujesz, dzięki czemu można upewnić się, że zezwalają przekierowania tylko zatwierdzone witryny sieci Web. Należy także sprawdzić, czy adres URL przekierowania używa odpowiedni protokół (HTTP lub HTTPS). Aby wykonać te weryfikacji, można dodać obsługi zdarzenia odświeżania strony do strony logowania, lub można dodać obsługi dla <xref:System.Web.UI.WebControls.Login.LoggedIn> zdarzenie <xref:System.Web.UI.WebControls.Login> formantu.  
  
   
  
## Examples  
 Poniższy kod przykładzie `enableCrossAppRedirects` atrybutu `true` w pliku Web.config dla aplikacji ASP.NET.  
  
```  
<authentication mode="Forms">  
  <forms loginUrl="member_login.aspx"  
    cookieless="UseUri"  
    requireSSL="true"   
    enableCrossAppRedirects="true" />  
</authentication>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableFormsAuthentication">
      <MemberSignature Language="C#" Value="public static void EnableFormsAuthentication (System.Collections.Specialized.NameValueCollection configurationData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnableFormsAuthentication(class System.Collections.Specialized.NameValueCollection configurationData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.FormsAuthentication.EnableFormsAuthentication(System.Collections.Specialized.NameValueCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnableFormsAuthentication (configurationData As NameValueCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnableFormsAuthentication(System::Collections::Specialized::NameValueCollection ^ configurationData);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="configurationData" Type="System.Collections.Specialized.NameValueCollection" />
      </Parameters>
      <Docs>
        <param name="configurationData">Kolekcja nazwa wartość, która zawiera wartości "defaultUrl" lub "loginUrl". Parametr może być wartość null, jeśli nie znajdują się wartości dla domyślnego adresu URL lub adres URL logowania.</param>
        <summary>Umożliwia uwierzytelnianie formularzy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Web.Security.FormsAuthentication.DefaultUrl%2A> właściwość jest `null`, że właściwość jest ustawiona wartość domyślna adresu URL z `configurationData` parametru. Jeśli <xref:System.Web.Security.FormsAuthentication.LoginUrl%2A> właściwość jest `null`, że właściwość jest ustawiona na wartość adresu URL logowania z `configurationData` parametru.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Aplikacja nie jest w fazie inicjowania przed uruchomieniem.</exception>
      </Docs>
    </Member>
    <Member MemberName="Encrypt">
      <MemberSignature Language="C#" Value="public static string Encrypt (System.Web.Security.FormsAuthenticationTicket ticket);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Encrypt(class System.Web.Security.FormsAuthenticationTicket ticket) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.FormsAuthentication.Encrypt(System.Web.Security.FormsAuthenticationTicket)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Encrypt (ticket As FormsAuthenticationTicket) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Encrypt(System::Web::Security::FormsAuthenticationTicket ^ ticket);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ticket" Type="System.Web.Security.FormsAuthenticationTicket" />
      </Parameters>
      <Docs>
        <param name="ticket">
          <see cref="T:System.Web.Security.FormsAuthenticationTicket" /> Obiektu, z którym ma zostać utworzony biletu uwierzytelniania formularzy zaszyfrowane.</param>
        <summary>Tworzy ciąg zawierający bilet uwierzytelniania szyfrowanego formularze odpowiedniego do użycia w pliku cookie HTTP.</summary>
        <returns>Ciąg zawierający biletu uwierzytelniania formularzy zaszyfrowane.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu przechowuje wynik <xref:System.Web.Security.FormsAuthentication.Encrypt%2A> w pliku cookie przy użyciu metody <xref:System.Web.Security.FormsAuthentication.FormsCookieName%2A> właściwości, a następnie przekierowuje użytkownika do adresu URL zwrócone przez <xref:System.Web.Security.FormsAuthentication.GetRedirectUrl%2A> — metoda.  
  
> [!IMPORTANT]
>  Ten przykład zawiera pole tekstowe, który akceptuje dane wejściowe użytkownika, który jest potencjalnym zagrożeniem dla bezpieczeństwa. Domyślnie strony sieci Web ASP.NET zweryfikować, czy dane wejściowe użytkownika nie obejmuje skrypt lub elementów HTML. Aby uzyskać więcej informacji, zobacz [Przegląd wykorzystuje skryptu](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[FormsAuthenticationTicketClass#1](~/samples/snippets/csharp/VS_Snippets_WebNet/FormsAuthenticationTicketClass/CS/formsauthenticationticketclasscs.aspx#1)]
 [!code-aspx-vb[FormsAuthenticationTicketClass#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/FormsAuthenticationTicketClass/VB/formsauthenticationticketclassvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="ticket" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FormsCookieName">
      <MemberSignature Language="C#" Value="public static string FormsCookieName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string FormsCookieName" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.FormsAuthentication.FormsCookieName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property FormsCookieName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ FormsCookieName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę pliku cookie używanego do przechowywania biletu uwierzytelniania formularzy.</summary>
        <value>Nazwa pliku cookie używanego do przechowywania biletu uwierzytelniania formularzy. Wartość domyślna to ". ASPXAUTH".</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.FormsAuthentication.FormsCookieName%2A> Wartość właściwości jest ustawiana w pliku konfiguracji dla aplikacji ASP.NET przy użyciu `name` atrybut elementu konfiguracji. <xref:System.Web.Security.FormsAuthentication.FormsCookieName%2A> Jest używana do utworzenia odwołania plik cookie przechowujący <xref:System.Web.Security.FormsAuthenticationTicket> informacji.  
  
   
  
## Examples  
 Poniższy kod przykładzie <xref:System.Web.Security.FormsAuthentication.FormsCookieName%2A> wartości właściwości przy użyciu `name` atrybutu w pliku Web.config.  
  
```  
<authentication mode="Forms">  
  <forms loginUrl="member_login.aspx"  
    cookieless="UseCookies"  
    name=".ASPXFORMSAUTH" />  
</authentication>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FormsCookiePath">
      <MemberSignature Language="C#" Value="public static string FormsCookiePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string FormsCookiePath" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.FormsAuthentication.FormsCookiePath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property FormsCookiePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ FormsCookiePath { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ścieżkę pliku cookie uwierzytelniania formularzy.</summary>
        <value>Ścieżka pliku cookie, w którym przechowywane są informacje biletu uwierzytelniania formularzy. Wartość domyślna to "/".</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.FormsAuthentication.FormsCookiePath%2A> Wartość właściwości jest ustawiana w pliku konfiguracji dla aplikacji ASP.NET przy użyciu `path` atrybut elementu konfiguracji. <xref:System.Web.Security.FormsAuthentication.FormsCookiePath%2A> Określa <xref:System.Web.HttpCookie.Path%2A> dla pliku cookie, która przechowuje <xref:System.Web.Security.FormsAuthenticationTicket> informacji.  
  
   
  
## Examples  
 Poniższy kod przykładzie <xref:System.Web.Security.FormsAuthentication.FormsCookiePath%2A> wartości właściwości przy użyciu `path` atrybutu w pliku Web.config.  
  
```  
<authentication mode="Forms">  
  <forms loginUrl="member_login.aspx"  
    cookieless="UseCookies"  
    path="/MyApplication" />  
</authentication>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetAuthCookie">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy plik cookie uwierzytelniania dla danej nazwy użytkownika.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAuthCookie">
      <MemberSignature Language="C#" Value="public static System.Web.HttpCookie GetAuthCookie (string userName, bool createPersistentCookie);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Web.HttpCookie GetAuthCookie(string userName, bool createPersistentCookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.FormsAuthentication.GetAuthCookie(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAuthCookie (userName As String, createPersistentCookie As Boolean) As HttpCookie" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Web::HttpCookie ^ GetAuthCookie(System::String ^ userName, bool createPersistentCookie);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpCookie</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="createPersistentCookie" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="userName">Nazwa uwierzytelnionego użytkownika.</param>
        <param name="createPersistentCookie">
          <see langword="true" /> Aby utworzyć trwały plik cookie (taki, który jest zapisywany w wielu sesjach przeglądarki); w przeciwnym razie <see langword="false" />.</param>
        <summary>Tworzy plik cookie uwierzytelniania dla danej nazwy użytkownika. To nie ustawia plik cookie jako część odpowiedzi wychodzącej, dzięki czemu aplikacja może mieć większą kontrolę nad jak plik cookie jest wystawiony.</summary>
        <returns>
          <see cref="T:System.Web.HttpCookie" /> Zawierający informacje o bilecie zaszyfrowanych uwierzytelniania formularzy. Wartość domyślna dla <see cref="P:System.Web.Security.FormsAuthentication.FormsCookiePath" /> właściwość jest używana.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ścieżka pliku cookie jest określany przez <xref:System.Web.Security.FormsAuthentication.FormsCookiePath%2A> właściwości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAuthCookie">
      <MemberSignature Language="C#" Value="public static System.Web.HttpCookie GetAuthCookie (string userName, bool createPersistentCookie, string strCookiePath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Web.HttpCookie GetAuthCookie(string userName, bool createPersistentCookie, string strCookiePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.FormsAuthentication.GetAuthCookie(System.String,System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAuthCookie (userName As String, createPersistentCookie As Boolean, strCookiePath As String) As HttpCookie" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Web::HttpCookie ^ GetAuthCookie(System::String ^ userName, bool createPersistentCookie, System::String ^ strCookiePath);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpCookie</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="createPersistentCookie" Type="System.Boolean" />
        <Parameter Name="strCookiePath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="userName">Nazwa uwierzytelnionego użytkownika.</param>
        <param name="createPersistentCookie">
          <see langword="true" /> Aby utworzyć trwały plik cookie (taki, który jest zapisywany w wielu sesjach przeglądarki); w przeciwnym razie <see langword="false" />.</param>
        <param name="strCookiePath">
          <see cref="P:System.Web.HttpCookie.Path" /> Pliku cookie uwierzytelniania.</param>
        <summary>Tworzy plik cookie uwierzytelniania dla danej nazwy użytkownika. To nie ustawia plik cookie jako część odpowiedzi wychodzącej.</summary>
        <returns>
          <see cref="T:System.Web.HttpCookie" /> Zawierający informacje o bilecie zaszyfrowanych uwierzytelniania formularzy.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRedirectUrl">
      <MemberSignature Language="C#" Value="public static string GetRedirectUrl (string userName, bool createPersistentCookie);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetRedirectUrl(string userName, bool createPersistentCookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.FormsAuthentication.GetRedirectUrl(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRedirectUrl (userName As String, createPersistentCookie As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetRedirectUrl(System::String ^ userName, bool createPersistentCookie);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="createPersistentCookie" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="userName">Nazwa uwierzytelnionego użytkownika.</param>
        <param name="createPersistentCookie">Ten parametr jest ignorowany.</param>
        <summary>Zwraca adres URL przekierowania oryginalnego żądania, który spowodował przekierowanie do strony logowania.</summary>
        <returns>Ciąg znaków zawierający adres URL przekierowania, lub wartość null, jeśli <paramref name="userName" /> ma wartość null.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można użyć tej metody, jeśli chcesz wykonać przekierowania w kodzie aplikacji zamiast <xref:System.Web.Security.FormsAuthentication.RedirectFromLoginPage%2A> metody.  
  
 <xref:System.Web.Security.FormsAuthentication.GetRedirectUrl%2A> Metoda zwraca adres URL podany w ciągu zapytania przy użyciu `ReturnURL` nazwy zmiennej. Na przykład w adresie URL `http://www.contoso.com/login.aspx?ReturnUrl=caller.aspx`, <xref:System.Web.Security.FormsAuthentication.GetRedirectUrl%2A> metoda zwraca zwrotny adres URL `caller.aspx`. Jeśli `ReturnURL` zmienna nie istnieje, <xref:System.Web.Security.FormsAuthentication.GetRedirectUrl%2A> metoda zwraca adres URL w <xref:System.Web.Security.FormsAuthentication.DefaultUrl%2A> właściwości.  
  
 ASP.NET automatycznie dodaje zwrotny adres URL, gdy przeglądarka jest przekierowywany na stronę logowania.  
  
 Domyślnie `ReturnUrl` zmiennej musi odwoływać się do strony w bieżącej aplikacji. Jeśli `ReturnUrl` odwołuje się do strony w innej aplikacji lub na innym serwerze, <xref:System.Web.Security.FormsAuthentication.GetRedirectUrl%2A> metody zwraca adres URL w <xref:System.Web.Security.FormsAuthentication.DefaultUrl%2A> właściwości. Jeśli chcesz zezwolić zwrotny adres URL do odwoływania się do strony poza bieżącą aplikacją, musisz ustawić <xref:System.Web.Security.FormsAuthentication.EnableCrossAppRedirects%2A> właściwości `true` przy użyciu `enableCrossAppRedirects` atrybut elementu konfiguracji.  

Ta metoda nie powoduje utworzenia pliku cookie.
  
> [!IMPORTANT]
>  Ustawienie <xref:System.Web.Security.FormsAuthentication.EnableCrossAppRedirects%2A> właściwości `true` umożliwia międzyaplikacyjnej przekierowania jest potencjalnym zagrożeniem dla bezpieczeństwa. Aby uzyskać więcej informacji, zobacz <xref:System.Web.Security.FormsAuthentication.EnableCrossAppRedirects%2A> właściwości.  
  
   
  
## Examples  
 Poniższy kod przekierowania przykład uwierzytelnionych użytkowników do adresu URL zwrócone z <xref:System.Web.Security.FormsAuthentication.GetRedirectUrl%2A> metody.  
  
> [!IMPORTANT]
>  Ten przykład zawiera pole tekstowe, który akceptuje dane wejściowe użytkownika, który jest potencjalnym zagrożeniem dla bezpieczeństwa. Domyślnie strony sieci Web ASP.NET zweryfikować, czy dane wejściowe użytkownika nie obejmuje skrypt lub elementów HTML. Aby uzyskać więcej informacji, zobacz [Przegląd wykorzystuje skryptu](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[FormsAuthenticationTicketClass#1](~/samples/snippets/csharp/VS_Snippets_WebNet/FormsAuthenticationTicketClass/CS/formsauthenticationticketclasscs.aspx#1)]
 [!code-aspx-vb[FormsAuthenticationTicketClass#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/FormsAuthenticationTicketClass/VB/formsauthenticationticketclassvb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HashPasswordForStoringInConfigFile">
      <MemberSignature Language="C#" Value="public static string HashPasswordForStoringInConfigFile (string password, string passwordFormat);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string HashPasswordForStoringInConfigFile(string password, string passwordFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.FormsAuthentication.HashPasswordForStoringInConfigFile(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HashPasswordForStoringInConfigFile (password As String, passwordFormat As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ HashPasswordForStoringInConfigFile(System::String ^ password, System::String ^ passwordFormat);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is to use the Membership APIs, such as Membership.CreateUser. For more information, see http://go.microsoft.com/fwlink/?LinkId=252463.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="password" Type="System.String" />
        <Parameter Name="passwordFormat" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="password">Hasło do wyznaczania wartości skrótu.</param>
        <param name="passwordFormat">Algorytm wyznaczania wartości skrótu do użycia. <c>passwordFormat</c> jest <see langword="String" /> stanowi jeden z <see cref="T:System.Web.Configuration.FormsAuthPasswordFormat" /> wartości wyliczenia.</param>
        <summary>Tworzy skrót hasła odpowiedniego do przechowywania w pliku konfiguracji na podstawie określonego hasła i algorytm wyznaczania wartości skrótu.</summary>
        <returns>Hasło w formie skrótu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.FormsAuthentication.HashPasswordForStoringInConfigFile%2A> Metoda tworzy wartość skrótu hasła można użyć w przypadku uwierzytelniania formularzy do przechowywania poświadczeń w pliku konfiguracyjnym aplikacji.  
  
 Poświadczenia uwierzytelniania przechowywane w pliku konfiguracyjnym aplikacji są używane przez <xref:System.Web.Security.FormsAuthentication.Authenticate%2A> metody do weryfikowania haseł dla użytkowników aplikacji. Alternatywnie można użyć członkostwa ASP.NET do przechowywania poświadczeń użytkownika. Aby uzyskać więcej informacji, zobacz [Zarządzanie użytkownikami przy użyciu członkostwa](http://msdn.microsoft.com/library/824c3a24-f0af-427c-a652-0d2d1e9397cd).  
  
   
  
## Examples  
 Poniższy przykład kodu przyjmuje nazwę użytkownika, hasło i typ wyznaczania wartości skrótu i wyświetla sekcji konfiguracji, który obejmuje definicji użytkownika i hasło w formie skrótu.  
  
> [!IMPORTANT]
>  Ten przykład zawiera pole tekstowe, który akceptuje dane wejściowe użytkownika, który jest potencjalnym zagrożeniem dla bezpieczeństwa. Domyślnie strony sieci Web ASP.NET zweryfikować, czy dane wejściowe użytkownika nie obejmuje skrypt lub elementów HTML. Aby uzyskać więcej informacji, zobacz [Przegląd wykorzystuje skryptu](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[FormsAuthenticationHashPassword#1](~/samples/snippets/csharp/VS_Snippets_WebNet/FormsAuthenticationHashPassword/CS/formsauthenticationhashpasswordcs.aspx#1)]
 [!code-aspx-vb[FormsAuthenticationHashPassword#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/FormsAuthenticationHashPassword/VB/formsauthenticationhashpasswordvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="password" /> jest <see langword="null" />  
  
 —lub—  
  
 <paramref name="passwordFormat" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="passwordFormat" /> nie jest prawidłową <see cref="T:System.Web.Configuration.FormsAuthPasswordFormat" /> wartość.</exception>
      </Docs>
    </Member>
    <Member MemberName="Initialize">
      <MemberSignature Language="C#" Value="public static void Initialize ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Initialize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.FormsAuthentication.Initialize" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Initialize ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Initialize();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inicjuje <see cref="T:System.Web.Security.FormsAuthentication" /> obiekt na podstawie konfiguracji ustawień dla aplikacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.FormsAuthentication.Initialize%2A> Metoda jest wywoływana, gdy <xref:System.Web.Security.FormsAuthenticationModule> tworzy wystąpienie <xref:System.Web.Security.FormsAuthentication> klasy. Ta metoda nie jest przeznaczona do wywoływania z kodu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabled">
      <MemberSignature Language="C#" Value="public static bool IsEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.FormsAuthentication.IsEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IsEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool IsEnabled { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy jest włączone uwierzytelnianie formularzy.</summary>
        <value>
          <see langword="true" /> Jeśli włączone jest uwierzytelnianie formularzy; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LoginUrl">
      <MemberSignature Language="C#" Value="public static string LoginUrl { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string LoginUrl" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.FormsAuthentication.LoginUrl" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property LoginUrl As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ LoginUrl { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera adres URL do strony logowania, która <see cref="T:System.Web.Security.FormsAuthentication" /> nastąpi przekierowanie klasy.</summary>
        <value>Adres URL logowania stronie <see cref="T:System.Web.Security.FormsAuthentication" /> nastąpi przekierowanie klasy. Wartość domyślna to "login.aspx."</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.FormsAuthentication.LoginUrl%2A> Wartość właściwości jest ustawiana w pliku konfiguracji dla aplikacji ASP.NET przy użyciu `loginUrl` atrybut elementu konfiguracji. <xref:System.Web.Security.FormsAuthentication.LoginUrl%2A> Jest używany przez <xref:System.Web.Security.FormsAuthentication.RedirectToLoginPage%2A> metody.  
  
   
  
## Examples  
 Poniższy kod przykładzie `loginUrl` atrybutu w pliku Web.config.  
  
```  
<authentication mode="Forms">  
  <forms loginUrl="member_login.aspx"  
    defaultUrl="index.aspx" />  
</authentication>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RedirectFromLoginPage">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Przekierowuje uwierzytelnionego użytkownika do pierwotnie żądanego adresu URL lub domyślnego adresu URL.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RedirectFromLoginPage">
      <MemberSignature Language="C#" Value="public static void RedirectFromLoginPage (string userName, bool createPersistentCookie);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RedirectFromLoginPage(string userName, bool createPersistentCookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.FormsAuthentication.RedirectFromLoginPage(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RedirectFromLoginPage (userName As String, createPersistentCookie As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RedirectFromLoginPage(System::String ^ userName, bool createPersistentCookie);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="createPersistentCookie" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="userName">Nazwa uwierzytelnionego użytkownika.</param>
        <param name="createPersistentCookie">
          <see langword="true" /> Aby utworzyć trwały plik cookie (taki, który jest zapisywany w wielu sesjach przeglądarki); w przeciwnym razie <see langword="false" />.</param>
        <summary>Przekierowuje uwierzytelnionego użytkownika do pierwotnie żądanego adresu URL lub domyślnego adresu URL.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.FormsAuthentication.RedirectFromLoginPage%2A> Metody przekierowuje do adresu URL określonego w ciągu zapytania przy użyciu `ReturnURL` nazwy zmiennej. Na przykład w adresie URL `http://www.contoso.com/login.aspx?ReturnUrl=caller.aspx`, <xref:System.Web.Security.FormsAuthentication.RedirectFromLoginPage%2A> — metoda przekierowuje pod zwrotny adres URL `caller.aspx`. Jeśli `ReturnURL` zmienna nie istnieje, <xref:System.Web.Security.FormsAuthentication.RedirectFromLoginPage%2A> metody przekierowuje do adresu URL <xref:System.Web.Security.FormsAuthentication.DefaultUrl%2A> właściwości.  
  
 ASP.NET automatycznie dodaje zwrotny adres URL, gdy przeglądarka jest przekierowywany na stronę logowania.  
  
 Domyślnie `ReturnUrl` zmiennej musi odwoływać się do strony w bieżącej aplikacji. Jeśli `ReturnUrl` odwołuje się do strony w innej aplikacji lub na innym serwerze, <xref:System.Web.Security.FormsAuthentication.RedirectFromLoginPage%2A> metody przekierowuje do adresu URL <xref:System.Web.Security.FormsAuthentication.DefaultUrl%2A> właściwości. Jeśli chcesz zezwolić przekierowuje do strony poza bieżącą aplikacją, musisz ustawić <xref:System.Web.Security.FormsAuthentication.EnableCrossAppRedirects%2A> właściwości `true` przy użyciu `enableCrossAppRedirects` atrybut elementu konfiguracji.  
  
> [!IMPORTANT]
>  Ustawienie <xref:System.Web.Security.FormsAuthentication.EnableCrossAppRedirects%2A> właściwości `true` umożliwia międzyaplikacyjnej przekierowania jest potencjalnym zagrożeniem dla bezpieczeństwa. Aby uzyskać więcej informacji, zobacz <xref:System.Web.Security.FormsAuthentication.EnableCrossAppRedirects%2A> właściwości.  
  
 Jeśli <xref:System.Web.Security.FormsAuthentication.CookiesSupported%2A> właściwość jest `true`oraz `ReturnUrl` zmiennej znajduje się w bieżącej aplikacji lub <xref:System.Web.Security.FormsAuthentication.EnableCrossAppRedirects%2A> właściwość jest `true`, a następnie <xref:System.Web.Security.FormsAuthentication.RedirectFromLoginPage%2A> metody wystawia bilet uwierzytelnienia i umieszcza je w domyślny plik cookie przy użyciu <xref:System.Web.Security.FormsAuthentication.SetAuthCookie%2A> metody.  
  
 Jeśli <xref:System.Web.Security.FormsAuthentication.CookiesSupported%2A> jest `false` i ścieżce przekierowania do adresu URL w bieżącej aplikacji, biletu jest wydane jako część adresu URL przekierowania. Jeśli <xref:System.Web.Security.FormsAuthentication.CookiesSupported%2A> jest `false`, <xref:System.Web.Security.FormsAuthentication.EnableCrossAppRedirects%2A> jest `true`i adres URL nie odwołuje się do strony w bieżącej aplikacji Przekieruj <xref:System.Web.Security.FormsAuthentication.RedirectFromLoginPage%2A> metody wystawia bilet uwierzytelnienia i umieszcza je w <xref:System.Web.HttpRequest.QueryString%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykład kodu przekierowuje zatwierdzonych użytkowników albo pierwotnie żądanego adresu URL lub <xref:System.Web.Security.FormsAuthentication.DefaultUrl%2A>. Przykład kodu wykorzystuje członkostwa ASP.NET do weryfikowania użytkowników. Aby uzyskać więcej informacji o członkostwie w ASP.NET, zobacz [Zarządzanie użytkownikami przy użyciu członkostwa](http://msdn.microsoft.com/library/824c3a24-f0af-427c-a652-0d2d1e9397cd).  
  
> [!IMPORTANT]
>  Ten przykład zawiera pole tekstowe, który akceptuje dane wejściowe użytkownika, który jest potencjalnym zagrożeniem dla bezpieczeństwa. Domyślnie strony sieci Web ASP.NET zweryfikować, czy dane wejściowe użytkownika nie obejmuje skrypt lub elementów HTML. Aby uzyskać więcej informacji, zobacz [Przegląd wykorzystuje skryptu](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[System.Web.Security.SqlMembershipProvider#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.SqlMembershipProvider/CS/logincs.aspx#1)]
 [!code-aspx-vb[System.Web.Security.SqlMembershipProvider#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.SqlMembershipProvider/VB/loginvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Zwrotny adres URL określony w ciąg zapytania zawiera protokołu innego niż HTTP: lub HTTPS:.</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectFromLoginPage">
      <MemberSignature Language="C#" Value="public static void RedirectFromLoginPage (string userName, bool createPersistentCookie, string strCookiePath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RedirectFromLoginPage(string userName, bool createPersistentCookie, string strCookiePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.FormsAuthentication.RedirectFromLoginPage(System.String,System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RedirectFromLoginPage (userName As String, createPersistentCookie As Boolean, strCookiePath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RedirectFromLoginPage(System::String ^ userName, bool createPersistentCookie, System::String ^ strCookiePath);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="createPersistentCookie" Type="System.Boolean" />
        <Parameter Name="strCookiePath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="userName">Nazwa uwierzytelnionego użytkownika.</param>
        <param name="createPersistentCookie">
          <see langword="true" /> Aby utworzyć trwały plik cookie (taki, który jest zapisywany w wielu sesjach przeglądarki); w przeciwnym razie <see langword="false" />.</param>
        <param name="strCookiePath">Ścieżka pliku cookie dla biletu uwierzytelniania formularzy.</param>
        <summary>Przekierowuje uwierzytelnionego użytkownika do pierwotnie żądanego adresu URL lub domyślny adres URL dla pliku cookie uwierzytelniania formularzy przy użyciu ścieżki określony plik cookie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.FormsAuthentication.RedirectFromLoginPage%2A> Metody przekierowuje do zwrotny adres URL określony w ciągu zapytania przy użyciu `ReturnURL` nazwy zmiennej. Na przykład w adresie URL `http://www.contoso.com/login.aspx?ReturnUrl=caller.aspx`, <xref:System.Web.Security.FormsAuthentication.RedirectFromLoginPage%2A> — metoda przekierowuje pod zwrotny adres URL `caller.aspx`. Jeśli `ReturnURL` zmienna nie istnieje, <xref:System.Web.Security.FormsAuthentication.RedirectFromLoginPage%2A> metody przekierowuje do adresu URL <xref:System.Web.Security.FormsAuthentication.DefaultUrl%2A> właściwości.  
  
 ASP.NET automatycznie dodaje zwrotny adres URL, gdy przeglądarka jest przekierowywany na stronę logowania.  
  
 Domyślnie `ReturnUrl` zmiennej musi odwoływać się do strony w bieżącej aplikacji. Jeśli `ReturnUrl` odwołuje się do strony w innej aplikacji lub na innym serwerze, <xref:System.Web.Security.FormsAuthentication.RedirectFromLoginPage%2A> metody przekierowuje do adresu URL <xref:System.Web.Security.FormsAuthentication.DefaultUrl%2A> właściwości. Jeśli chcesz zezwolić przekierowuje do strony poza bieżącą aplikacją, musisz ustawić <xref:System.Web.Security.FormsAuthentication.EnableCrossAppRedirects%2A> właściwości `true` przy użyciu `enableCrossAppRedirects` atrybut elementu konfiguracji.  
  
> [!IMPORTANT]
>  Ustawienie <xref:System.Web.Security.FormsAuthentication.EnableCrossAppRedirects%2A> właściwości `true` umożliwia międzyaplikacyjnej przekierowania jest potencjalnym zagrożeniem dla bezpieczeństwa. Aby uzyskać więcej informacji, zobacz <xref:System.Web.Security.FormsAuthentication.EnableCrossAppRedirects%2A> właściwości.  
  
 Jeśli <xref:System.Web.Security.FormsAuthentication.CookiesSupported%2A> właściwość jest `true`oraz `ReturnUrl` zmiennej znajduje się w bieżącej aplikacji lub <xref:System.Web.Security.FormsAuthentication.EnableCrossAppRedirects%2A> właściwość jest `true`, a następnie <xref:System.Web.Security.FormsAuthentication.RedirectFromLoginPage%2A> metody wystawia bilet uwierzytelnienia i umieszcza je w określona przez plik cookie `strCookiePath` przy użyciu parametru <xref:System.Web.Security.FormsAuthentication.SetAuthCookie%2A> metody.  
  
 Jeśli <xref:System.Web.Security.FormsAuthentication.CookiesSupported%2A> jest `false` i ścieżce przekierowania do adresu URL w bieżącej aplikacji, biletu jest wydane jako część adresu URL przekierowania. Jeśli <xref:System.Web.Security.FormsAuthentication.CookiesSupported%2A> jest `false`, <xref:System.Web.Security.FormsAuthentication.EnableCrossAppRedirects%2A> jest `true`i adres URL nie odwołuje się do strony w bieżącej aplikacji Przekieruj <xref:System.Web.Security.FormsAuthentication.RedirectFromLoginPage%2A> metody wystawia bilet uwierzytelnienia i umieszcza je w <xref:System.Web.HttpRequest.QueryString%2A> właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Zwrotny adres URL określony w ciąg zapytania zawiera protokołu innego niż HTTP: lub HTTPS:.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RedirectToLoginPage">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Przekierowuje przeglądarki do adresu URL logowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.FormsAuthentication.RedirectToLoginPage%2A> Metody przekierowuje przeglądarkę, aby <xref:System.Web.Security.FormsAuthentication.LoginUrl%2A>.  
  
 <xref:System.Web.Security.FormsAuthentication.RedirectToLoginPage%2A> — Metoda nie czyści pliku cookie uwierzytelniania formularzy. Można użyć <xref:System.Web.Security.FormsAuthentication.RedirectToLoginPage%2A> w połączeniu z metody <xref:System.Web.Security.FormsAuthentication.SignOut%2A> metodę, aby wylogować jednego użytkownika i zezwolić innego użytkownika do logowania.  
  
 W odróżnieniu od <xref:System.Web.HttpResponse.Redirect%2A?displayProperty=nameWithType> przez wywołanie metody, ta metoda nie kończy żądanie <xref:System.Web.HttpResponse.End%2A?displayProperty=nameWithType>. Oznacza to, że kodu, która <xref:System.Web.Security.FormsAuthentication.RedirectToLoginPage%2A> wywołania metody, które zostaną uruchomione.  
  
   
  
## Examples  
 Poniższy przykład kodu usuwa przy użyciu pliku cookie uwierzytelniania formularzy <xref:System.Web.Security.FormsAuthentication.SignOut%2A> metody, a następnie przekierowuje strona użytkownikowi logowanie za pomocą <xref:System.Web.Security.FormsAuthentication.RedirectToLoginPage%2A> metody.  
  
 [!code-aspx-csharp[System.Web.Security.FormsAuthentication#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.FormsAuthentication/CS/signoutcs.aspx#2)]
 [!code-aspx-vb[System.Web.Security.FormsAuthentication#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.FormsAuthentication/VB/signoutvb.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="RedirectToLoginPage">
      <MemberSignature Language="C#" Value="public static void RedirectToLoginPage ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RedirectToLoginPage() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.FormsAuthentication.RedirectToLoginPage" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RedirectToLoginPage ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RedirectToLoginPage();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Przekierowuje przeglądarki do adresu URL logowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.FormsAuthentication.RedirectToLoginPage%2A> Metody przekierowuje przeglądarkę, aby <xref:System.Web.Security.FormsAuthentication.LoginUrl%2A>.  
  
 <xref:System.Web.Security.FormsAuthentication.RedirectToLoginPage%2A> — Metoda nie czyści pliku cookie uwierzytelniania formularzy. Można użyć <xref:System.Web.Security.FormsAuthentication.RedirectToLoginPage%2A> w połączeniu z metody <xref:System.Web.Security.FormsAuthentication.SignOut%2A> metodę, aby wylogować jednego użytkownika i zezwolić innego użytkownika do logowania.  
  
   
  
## Examples  
 Poniższy przykład kodu usuwa przy użyciu pliku cookie uwierzytelniania formularzy <xref:System.Web.Security.FormsAuthentication.SignOut%2A> metody, a następnie przekierowuje strona użytkownikowi logowanie za pomocą <xref:System.Web.Security.FormsAuthentication.RedirectToLoginPage%2A> metody.  
  
 [!code-aspx-csharp[System.Web.Security.FormsAuthentication#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.FormsAuthentication/CS/signoutcs.aspx#2)]
 [!code-aspx-vb[System.Web.Security.FormsAuthentication#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.FormsAuthentication/VB/signoutvb.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RedirectToLoginPage">
      <MemberSignature Language="C#" Value="public static void RedirectToLoginPage (string extraQueryString);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RedirectToLoginPage(string extraQueryString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.FormsAuthentication.RedirectToLoginPage(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RedirectToLoginPage (extraQueryString As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RedirectToLoginPage(System::String ^ extraQueryString);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="extraQueryString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="extraQueryString">Ciąg zapytania do dołączenia do adresu URL przekierowania.</param>
        <summary>Przekierowuje do adresu URL logowania określony ciąg zapytania przeglądarki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.FormsAuthentication.RedirectToLoginPage%2A> Metody przekierowuje przeglądarkę, aby <xref:System.Web.Security.FormsAuthentication.LoginUrl%2A> i zawiera `extraQueryString` wartość jako <xref:System.Management.ManagementQuery.QueryString%2A> dla adresu URL.  
  
 <xref:System.Web.Security.FormsAuthentication.RedirectToLoginPage%2A> — Metoda nie czyści pliku cookie uwierzytelniania formularzy. Można użyć <xref:System.Web.Security.FormsAuthentication.RedirectToLoginPage%2A> w połączeniu z metody <xref:System.Web.Security.FormsAuthentication.SignOut%2A> metodę, aby wylogować jednego użytkownika i zezwolić innego użytkownika do logowania.  
  
   
  
## Examples  
 Poniższy przykład kodu usuwa przy użyciu pliku cookie uwierzytelniania formularzy <xref:System.Web.Security.FormsAuthentication.SignOut%2A> metody, a następnie przekierowuje strona użytkownikowi logowanie za pomocą <xref:System.Web.Security.FormsAuthentication.RedirectToLoginPage%2A> metody.  
  
 [!code-aspx-csharp[System.Web.Security.FormsAuthentication#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.FormsAuthentication/CS/signout2cs.aspx#3)]
 [!code-aspx-vb[System.Web.Security.FormsAuthentication#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.FormsAuthentication/VB/signout2vb.aspx#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RenewTicketIfOld">
      <MemberSignature Language="C#" Value="public static System.Web.Security.FormsAuthenticationTicket RenewTicketIfOld (System.Web.Security.FormsAuthenticationTicket tOld);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Web.Security.FormsAuthenticationTicket RenewTicketIfOld(class System.Web.Security.FormsAuthenticationTicket tOld) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.FormsAuthentication.RenewTicketIfOld(System.Web.Security.FormsAuthenticationTicket)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RenewTicketIfOld (tOld As FormsAuthenticationTicket) As FormsAuthenticationTicket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Web::Security::FormsAuthenticationTicket ^ RenewTicketIfOld(System::Web::Security::FormsAuthenticationTicket ^ tOld);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Security.FormsAuthenticationTicket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tOld" Type="System.Web.Security.FormsAuthenticationTicket" />
      </Parameters>
      <Docs>
        <param name="tOld">Bilet uwierzytelniania formularzy do zaktualizowania.</param>
        <summary>Warunkowo aktualizacji problem daty i godziny i daty ważności oraz czas <see cref="T:System.Web.Security.FormsAuthenticationTicket" />.</summary>
        <returns>Zaktualizowany interfejs <see cref="T:System.Web.Security.FormsAuthenticationTicket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.FormsAuthentication.RenewTicketIfOld%2A> Metody aktualizacji, datę wygaśnięcia i godzina podana <xref:System.Web.Security.FormsAuthenticationTicket> Jeśli bieżąca data i godzina minus <xref:System.Web.Security.FormsAuthenticationTicket.IssueDate%2A> wartość jest większa niż <xref:System.Web.Security.FormsAuthenticationTicket.Expiration%2A> wartość minus bieżącą datę i godzinę.  
  
 Bilet został zaktualizowany o <xref:System.Web.Security.FormsAuthenticationTicket.IssueDate%2A> bieżącą datę i godzinę ustawioną właściwość i <xref:System.Web.Security.FormsAuthenticationTicket.Expiration%2A> właściwość do bieżącej daty i czasu oraz oryginalnej <xref:System.Web.Security.FormsAuthenticationTicket.Expiration%2A> wartość minus oryginalnej <xref:System.Web.Security.FormsAuthenticationTicket.IssueDate%2A> wartość.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RequireSSL">
      <MemberSignature Language="C#" Value="public static bool RequireSSL { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool RequireSSL" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.FormsAuthentication.RequireSSL" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property RequireSSL As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool RequireSSL { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy plik cookie uwierzytelniania formularzy wymaga protokołu SSL w celu zwrócenia na serwer.</summary>
        <value>
          <see langword="true" /> Jeśli protokół SSL jest wymagany, aby przywrócić plik cookie uwierzytelniania formularzy z serwerem; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.FormsAuthentication.RequireSSL%2A> Wartość właściwości jest ustawiana w pliku konfiguracji dla aplikacji ASP.NET przy użyciu `requireSSL` atrybut elementu konfiguracji. Można określić w pliku Web.config dla aplikacji ASP.NET czy SSL (Secure Sockets Layer) jest wymagany do zwrócenia pliku cookie uwierzytelniania formularzy do serwera przez ustawienie `requireSSL` atrybutu. Aby uzyskać więcej informacji, zobacz <xref:System.Web.HttpCookie.Secure%2A>.  
  
 Zalecane jest konfigurując `requireSSL` jako `false`, można także skonfigurować `slidingExpiration` jako `false`, aby zmniejszyć ilość czasu, dla którego biletu jest nieprawidłowy.  
  
   
  
## Examples  
 Poniższy kod przykładzie `requireSSL` atrybutu w pliku Web.config.  
  
```  
<authentication mode="Forms">  
  <forms loginUrl="member_login.aspx"  
    cookieless="UseCookies"  
    requireSSL="true"  
    path="/MyApplication" />  
</authentication>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetAuthCookie">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy bilet uwierzytelnienia z podaną nazwą użytkownika i dodaje go do kolekcji plików cookie odpowiedzi lub adres URL, jeśli używasz bez plików cookie uwierzytelniania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.FormsAuthentication.SetAuthCookie%2A> Metody dodaje biletu uwierzytelniania formularzy do zbierania plików cookie lub adres URL, jeśli <xref:System.Web.Security.FormsAuthentication.CookiesSupported%2A> jest `false`. Biletu uwierzytelniania formularzy zapewnia uwierzytelnianie formularzy informacje dla następnego żądania przez przeglądarkę. W przypadku uwierzytelniania formularzy, można używać <xref:System.Web.Security.FormsAuthentication.SetAuthCookie%2A> metody, aby uwierzytelnić użytkownika, ale nadal zachowanie kontroli nad nawigacja z użyciem przekierowania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetAuthCookie">
      <MemberSignature Language="C#" Value="public static void SetAuthCookie (string userName, bool createPersistentCookie);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAuthCookie(string userName, bool createPersistentCookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.FormsAuthentication.SetAuthCookie(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetAuthCookie (userName As String, createPersistentCookie As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetAuthCookie(System::String ^ userName, bool createPersistentCookie);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="createPersistentCookie" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="userName">Nazwa uwierzytelnionego użytkownika. Nie ma do mapowania na konto systemu Windows.</param>
        <param name="createPersistentCookie">
          <see langword="true" /> Aby utworzyć trwały plik cookie (taki, który jest zapisywany w wielu sesjach przeglądarki); w przeciwnym razie <see langword="false" />.</param>
        <summary>Tworzy bilet uwierzytelnienia z podaną nazwą użytkownika i dodaje go do kolekcji plików cookie odpowiedzi lub adres URL, jeśli używasz bez plików cookie uwierzytelniania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.FormsAuthentication.SetAuthCookie%2A> Metoda dodaje biletu uwierzytelniania formularzy do kolekcji plików cookie lub do adresu URL Jeśli <xref:System.Web.Security.FormsAuthentication.CookiesSupported%2A> jest `false`. Biletu uwierzytelniania formularzy zapewnia uwierzytelnianie formularzy informacje dla następnego żądania przez przeglądarkę. W przypadku uwierzytelniania formularzy, można używać <xref:System.Web.Security.FormsAuthentication.SetAuthCookie%2A> metody, aby uwierzytelnić użytkownika, ale nadal zachowanie kontroli nad nawigacja z użyciem przekierowania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">
          <see cref="P:System.Web.Security.FormsAuthentication.RequireSSL" /> jest <see langword="true" /> i <see cref="P:System.Web.HttpRequest.IsSecureConnection" /> jest <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAuthCookie">
      <MemberSignature Language="C#" Value="public static void SetAuthCookie (string userName, bool createPersistentCookie, string strCookiePath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAuthCookie(string userName, bool createPersistentCookie, string strCookiePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.FormsAuthentication.SetAuthCookie(System.String,System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetAuthCookie (userName As String, createPersistentCookie As Boolean, strCookiePath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetAuthCookie(System::String ^ userName, bool createPersistentCookie, System::String ^ strCookiePath);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="createPersistentCookie" Type="System.Boolean" />
        <Parameter Name="strCookiePath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="userName">Nazwa uwierzytelnionego użytkownika.</param>
        <param name="createPersistentCookie">
          <see langword="true" /> Aby utworzyć trwały plik cookie (taki, który jest zapisywany w wielu sesjach przeglądarki); w przeciwnym razie <see langword="false" />.</param>
        <param name="strCookiePath">Ścieżka pliku cookie dla biletu uwierzytelniania formularzy.</param>
        <summary>Tworzy bilet uwierzytelnienia nazwy użytkownika i dodaje go do kolekcji plików cookie odpowiedzi, za pomocą ścieżki dostarczonego pliku cookie lub adres URL, jeśli używasz bez plików cookie uwierzytelniania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.FormsAuthentication.SetAuthCookie%2A> Metody dodaje biletu uwierzytelniania formularzy do zbierania plików cookie lub adres URL, jeśli <xref:System.Web.Security.FormsAuthentication.CookiesSupported%2A> jest `false`. Biletu uwierzytelniania formularzy zapewnia uwierzytelnianie formularzy informacje dla następnego żądania przez przeglądarkę. W przypadku uwierzytelniania formularzy, można używać <xref:System.Web.Security.FormsAuthentication.SetAuthCookie%2A> metody, aby uwierzytelnić użytkownika, ale nadal zachowanie kontroli nad nawigacja z użyciem przekierowania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">
          <see cref="P:System.Web.Security.FormsAuthentication.RequireSSL" /> jest <see langword="true" /> i <see cref="P:System.Web.HttpRequest.IsSecureConnection" /> jest <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SignOut">
      <MemberSignature Language="C#" Value="public static void SignOut ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SignOut() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.FormsAuthentication.SignOut" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SignOut ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SignOut();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa biletu uwierzytelniania formularzy z przeglądarki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.FormsAuthentication.SignOut%2A> Metoda usuwa dane biletu uwierzytelniania formularzy z pliku cookie lub adres URL, jeśli <xref:System.Web.Security.FormsAuthentication.CookiesSupported%2A> jest `false`. Można użyć <xref:System.Web.Security.FormsAuthentication.SignOut%2A> w połączeniu z metody <xref:System.Web.Security.FormsAuthentication.RedirectToLoginPage%2A> metodę, aby wylogować jednego użytkownika i zezwolić innego użytkownika do logowania.  
  
 Uruchom wyłącznie w trybie bez plików cookie, lub jeśli obsługuje zarówno uwierzytelnionych i anonimowych użytkowników, należy jawnie kontrolować przekierowanie do strony logowania, jeśli wymagana logiki biznesowej specjalne można wykonać w wyniku usunięcia anonimowy identyfikator.  
  
 Gdy <xref:System.Web.Security.FormsAuthentication.SignOut%2A> metoda jest wywoływana, przekierowanie do strony logowania aplikacji zostało utworzone przez wywołanie <xref:System.Web.HttpResponse.Redirect%2A> metody z `endResponse` ustawiono parametr `false`. Przekierowanie odbywa się, dopóki bieżąca strona zakończono wykonywanie, co dodatkowy kod może być uruchamiane. Jeśli kod zawiera jawne przekierowania do innej strony, użytkownik jest przekierowywany na stronę logowania w pliku konfiguracji aplikacji.  
  
 Wywoływanie <xref:System.Web.Security.FormsAuthentication.SignOut%2A> metody umożliwia tylko usunięcie pliku cookie uwierzytelniania formularzy. Serwer sieci Web nie przechowuje biletów uwierzytelniania prawidłowe i wygasłe do późniejszego porównania. Dzięki temu lokacji narażony na atak powtarzania złośliwy użytkownik uzyska pliku cookie uwierzytelniania formularzy prawidłowe. Aby zwiększyć bezpieczeństwo, korzystając z pliku cookie uwierzytelniania formularzy, należy wykonać następujące:  
  
-   Użyj wygaśnięcia bezwzględne plików cookie uwierzytelniania formularzy, ustawiając <xref:System.Web.Security.FormsAuthentication.SlidingExpiration%2A> właściwości `false`. Ogranicza to okno odtworzone hijacked pliku cookie.  
  
-   Tylko wystawiania i akceptowania plików cookie uwierzytelniania za pośrednictwem Secure Sockets Layer (SSL), ustawiając <xref:System.Web.Security.FormsAuthentication.RequireSSL%2A> właściwości `true` i uruchamiając całej witryny sieci Web w ramach protokołu SSL. Ustawienie <xref:System.Web.Security.FormsAuthentication.RequireSSL%2A> właściwości `true` gwarantuje, że ASP.NET nigdy nie przesyła pliku cookie uwierzytelniania w przeglądarce za pośrednictwem połączenia bez użycia protokołu SSL; jednak klient nie może być przestrzegać zabezpieczone ustawienie w pliku cookie. Oznacza to, że klient może wysyłać pliku cookie uwierzytelniania formularzy przy użyciu połączenia bez użycia protokołu SSL, w związku z tym pozostawienie podatne na przejęcie kontroli. Aby zapobiec klient wysyła pliku cookie uwierzytelniania formularzy w wyczyść uruchamiając całej witryny sieci Web w ramach protokołu SSL.  
  
-   Użyj magazynu trwałego na serwerze, aby zapisać podczas logowania się użytkownika z witryny sieci Web, a następnie użyj zdarzeń aplikacji takich jak <xref:System.Web.HttpApplication.PostAuthenticateRequest> zdarzenia w celu określenia, czy bieżący użytkownik został uwierzytelniony za pomocą uwierzytelniania formularzy. Jeśli użytkownik został uwierzytelniony za pomocą uwierzytelniania formularzy i informacji w magazynie trwały wskazuje wylogowaniem użytkownika, niezwłocznie wyczyść pliku cookie uwierzytelniania i przekierowania przeglądarki z powrotem do strony logowania. Po pomyślnym zalogowaniu aktualizacji magazynu, aby uwzględnić, czy użytkownik jest zalogowany. Możesz użyć tej metody, aplikacja musi śledzić stan zalogowanego użytkownika i należy wymusić bezczynnych użytkowników do logowania.  
  
   
  
## Examples  
 Poniższy przykład kodu usuwa przy użyciu pliku cookie uwierzytelniania formularzy <xref:System.Web.Security.FormsAuthentication.SignOut%2A> metody, a następnie przekierowuje strona użytkownikowi logowanie za pomocą <xref:System.Web.Security.FormsAuthentication.RedirectToLoginPage%2A> metody.  
  
 [!code-aspx-csharp[System.Web.Security.FormsAuthentication#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.FormsAuthentication/CS/signoutcs.aspx#2)]
 [!code-aspx-vb[System.Web.Security.FormsAuthentication#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.FormsAuthentication/VB/signoutvb.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SlidingExpiration">
      <MemberSignature Language="C#" Value="public static bool SlidingExpiration { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SlidingExpiration" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.FormsAuthentication.SlidingExpiration" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SlidingExpiration As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool SlidingExpiration { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy przedłużanie ważności jest włączone.</summary>
        <value>
          <see langword="true" /> Jeśli przedłużanie ważności jest włączone; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.FormsAuthentication.SlidingExpiration%2A> Wartość właściwości jest ustawiana za pomocą `slidingExpiration` atrybut elementu konfiguracji.  
  
 Przedłużanie ważności resetuje czas wygaśnięcia prawidłowy plik cookie Jeśli żądań i ponad połowa limit czasu upłynął. Jeśli plik cookie wygasa, użytkownik musi zostać ponownie uwierzytelnione. Ustawienie <xref:System.Web.Security.FormsAuthentication.SlidingExpiration%2A> właściwości `false` zwiększyć bezpieczeństwo aplikacji poprzez ograniczenie czasu, dla którego plik cookie uwierzytelniania jest prawidłowy, oparte na skonfigurowanego `timeout` wartość.  
  
 Zalecamy, aby po skonfigurowaniu `requireSSL` jako `false`, można także skonfigurować `slidingExpiration` jako `false`, aby zmniejszyć ilość czasu, dla którego biletu jest nieprawidłowy.  
  
   
  
## Examples  
 Poniższy kod przykładzie `slidingExpiration` atrybutu `false` w pliku Web.config dla aplikacji ASP.NET.  
  
```  
<authentication mode="Forms">  
  <forms loginUrl="member_login.aspx"  
    name=".ASPXFORMSAUTH"  
    cookieless="UseCookies"  
    requireSSL="true"   
    slidingExpiration="false" />  
</authentication>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TicketCompatibilityMode">
      <MemberSignature Language="C#" Value="public static System.Web.Configuration.TicketCompatibilityMode TicketCompatibilityMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Web.Configuration.TicketCompatibilityMode TicketCompatibilityMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.FormsAuthentication.TicketCompatibilityMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property TicketCompatibilityMode As TicketCompatibilityMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Web::Configuration::TicketCompatibilityMode TicketCompatibilityMode { System::Web::Configuration::TicketCompatibilityMode get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Configuration.TicketCompatibilityMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy ma być używany uniwersalny czas koordynowany (UTC) lub czas lokalny dla daty wygaśnięcia biletu.</summary>
        <value>Wartość, która wskazuje, czy ma być używany uniwersalny czas koordynowany (UTC) lub czas lokalny dla daty wygaśnięcia biletu.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Timeout">
      <MemberSignature Language="C#" Value="public static TimeSpan Timeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.TimeSpan Timeout" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.FormsAuthentication.Timeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Timeout As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property TimeSpan Timeout { TimeSpan get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera czas wygaśnięcia biletu uwierzytelniania.</summary>
        <value>Wygasa czas przed bilet uwierzytelnienia.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
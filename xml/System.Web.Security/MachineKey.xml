<Type Name="MachineKey" FullName="System.Web.Security.MachineKey">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="79408eb1da4e4e1007df647cc3d7b097561d220e" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30584434" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class MachineKey" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit MachineKey extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.Security.MachineKey" />
  <TypeSignature Language="VB.NET" Value="Public Class MachineKey" />
  <TypeSignature Language="C++ CLI" Value="public ref class MachineKey abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Zapewnia możliwość szyfrowania lub skrót danych (lub obie) przy użyciu tych samych algorytmów i wartości kluczy, które są używane do uwierzytelniania formularzy ASP.NET i stan widoku.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.MachineKey> Klasa dostarcza metody, które udostępniają logiki mieszania i szyfrowania, które program ASP.NET udostępnia. Informacje o które szyfrowania i algorytmów wyznaczania wartości skrótu program ASP.NET używa i wartości kluczy używanych z nimi, zobacz [machineKey Element (schemat ustawień programu ASP.NET)](http://msdn.microsoft.com/library/4b5699a9-bc21-4c4a-85f1-8b3b8ebd2d46).  
  
> [!WARNING]
>  <xref:System.Web.Security.MachineKey> Interfejsów API należy używać tylko w aplikacji ASP.NET. Zachowanie interfejsów API MachineKey poza kontekstem aplikacji ASP.NET jest niezdefiniowana  
  
 ]]></format>
    </remarks>
    <exception cref="T:System.ArgumentNullException">Dane do szyfrowania, mieszania, odszyfrowywania lub sprawdzania poprawności nie istnieje</exception>
  </Docs>
  <Members>
    <Member MemberName="Decode">
      <MemberSignature Language="C#" Value="public static byte[] Decode (string encodedData, System.Web.Security.MachineKeyProtection protectionOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] Decode(string encodedData, valuetype System.Web.Security.MachineKeyProtection protectionOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.MachineKey.Decode(System.String,System.Web.Security.MachineKeyProtection)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Decode (encodedData As String, protectionOption As MachineKeyProtection) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ Decode(System::String ^ encodedData, System::Web::Security::MachineKeyProtection protectionOption);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("This method is obsolete and is only provided for compatibility with existing code. It is recommended that new code use the Protect and Unprotect methods instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="encodedData" Type="System.String" />
        <Parameter Name="protectionOption" Type="System.Web.Security.MachineKeyProtection" />
      </Parameters>
      <Docs>
        <param name="encodedData">Zaszyfrowane dane do odszyfrowania i/lub zweryfikować.</param>
        <param name="protectionOption">Wskazuje, czy <c>encodedData</c> parametr powinien być szyfrowane i/lub mieszany.</param>
        <summary>Dekoduje i/lub weryfikuje dane zaszyfrowane lub udostępniane przy użyciu kodu uwierzytelniania wiadomości oparty na skrótu (HMAC).</summary>
        <returns>A <see cref="T:System.Byte" /> tablica, która reprezentuje odszyfrowane dane.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać informacje o które szyfrowania i algorytmów wyznaczania wartości skrótu program ASP.NET używa do odszyfrowania i sprawdzanie poprawności danych, który jest przekazywany w, zobacz [machineKey Element (schemat ustawień programu ASP.NET)](http://msdn.microsoft.com/library/4b5699a9-bc21-4c4a-85f1-8b3b8ebd2d46).  
  
   
  
## Examples  
 Na przykład kod, zobacz <xref:System.Web.Security.MachineKey> Przegląd klasy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Encode">
      <MemberSignature Language="C#" Value="public static string Encode (byte[] data, System.Web.Security.MachineKeyProtection protectionOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Encode(unsigned int8[] data, valuetype System.Web.Security.MachineKeyProtection protectionOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.MachineKey.Encode(System.Byte[],System.Web.Security.MachineKeyProtection)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Encode (data As Byte(), protectionOption As MachineKeyProtection) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Encode(cli::array &lt;System::Byte&gt; ^ data, System::Web::Security::MachineKeyProtection protectionOption);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("This method is obsolete and is only provided for compatibility with existing code. It is recommended that new code use the Protect and Unprotect methods instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="protectionOption" Type="System.Web.Security.MachineKeyProtection" />
      </Parameters>
      <Docs>
        <param name="data">Dane do zaszyfrowania.</param>
        <param name="protectionOption">Wskazuje, czy <c>danych</c> parametr powinien być szyfrowane i/lub mieszany.</param>
        <summary>Dane są szyfrowane i/lub dołącza kod uwierzytelniania wiadomości na podstawie skrótu (HMAC).</summary>
        <returns>Zaszyfrowaną wartość, wartości wejściowej o HMAC dołączany lub wynik szyfrowania z HMAC dołączany wartości wejściowej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać informacje o które szyfrowania i algorytmów wyznaczania wartości skrótu program ASP.NET używa do odszyfrowania i sprawdzanie poprawności danych, który jest przekazywany w, zobacz [machineKey Element (schemat ustawień programu ASP.NET)](http://msdn.microsoft.com/library/4b5699a9-bc21-4c4a-85f1-8b3b8ebd2d46).  
  
   
  
## Examples  
 Na przykład kod, zobacz <xref:System.Web.Security.MachineKey> Przegląd klasy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Protect">
      <MemberSignature Language="C#" Value="public static byte[] Protect (byte[] userData, params string[] purposes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] Protect(unsigned int8[] userData, string[] purposes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.MachineKey.Protect(System.Byte[],System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Protect (userData As Byte(), ParamArray purposes As String()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ Protect(cli::array &lt;System::Byte&gt; ^ userData, ... cli::array &lt;System::String ^&gt; ^ purposes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="userData" Type="System.Byte[]" />
        <Parameter Name="purposes" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="userData">Dane są chronione. Te dane są przekazywane jako zwykły tekst.</param>
        <param name="purposes">Lista celów do danych. Jeśli ta wartość jest określona, tę samą listę muszą być przekazywane do <see cref="M:System.Web.Security.MachineKey.Unprotect(System.Byte[],System.String[])" /> metody, aby można było odszyfrować zwrócony tekstu szyfrowanego.</param>
        <summary>Chroni określone dane, szyfrowania i podpisywania go.</summary>
        <returns>Dane tekstu szyfrowanego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zastępuje <xref:System.Web.Security.MachineKey.Encode%2A> metodę, która wymaga obiekt wywołujący, aby określić, czy dane w postaci zwykłego tekstu ma być szyfrowana, podpisany, lub obie. <xref:System.Web.Security.MachineKey.Protect%2A> Metoda wykonuje operację odpowiednie i bezpiecznie chroni dane. Dane tekstu szyfrowanego utworzone przez tę metodę mogą być tylko odszyfrowywane przez <xref:System.Web.Security.MachineKey.Unprotect%2A> metody.  
  
 `purposes` Parametr jest opcjonalny listę przyczyn, które mogą zablokować tekstu szyfrowanego do określonego celu. Ten parametr umożliwia izolowanie operacje kryptograficzne wykonywane przez różne podsystemy w aplikacji. Złośliwego klienta nie będą już mogli uzyskać wynik jednego podsystemu <xref:System.Web.Security.MachineKey.Protect%2A> — metoda i źródła danych jako dane wejściowe innego podsystemu <xref:System.Web.Security.MachineKey.Unprotect%2A> metodę, która może naruszyć bezpieczeństwo aplikacji. `purposes` Parametru zapewnia, że chronionych danych tylko mogą być używane przez składnik, który pierwotnie go wygenerowała. Upewnij się, że każdy podsystem używa unikatowego aplikacji `purposes` listy.  
  
 Na przykład aby Włączanie lub wyłączanie ochrony tokenu uwierzytelniania, należy wywołać metodę, przy użyciu kodu, jak w następującym przykładzie:  
  
```csharp  
MachineKey.Protect(..., "Authentication token");  
MachineKey.Unprotect(..., "Authentication token");  
```  
  
```vb  
MachineKey.Protect(..., "Authentication token")  
MachineKey.Unprotect(..., "Authentication token")  
```  
  
 Aplikacje można dynamicznie generować `purposes` parametru. W takim przypadku prefiksu dostarczone przez użytkownika wartości z wartością stałą (takich jak "`Username:` " + *username*) aby ograniczyć ryzyko złośliwego klienta obsługuje tworzenie wejścia odpowiadającego tokenu, który jest używany przez inne części systemu. Wszelkie ciągi generowane dynamicznie powinna występować po stałej ciągów. Na przykład aby Włączanie lub wyłączanie ochrony prywatnych komunikat, który jest powiązany z określonego użytkownika, należy użyć kodu, jak w następującym przykładzie:  
  
```csharp  
MachineKey.Protect(..., "Private message", "Recipient: " + username);  
MachineKey.Unprotect(..., "Private message", "Recipient: " + username);  
```  
  
```vb  
MachineKey.Protect(..., "Private message", "Recipient: " + username)  
MachineKey.Unprotect(..., "Private message", "Recipient: " + username)  
```  
  
 Gdy <xref:System.Web.Security.MachineKey.Unprotect%2A> metoda jest wywoływana, wartość, która jest dostępne w celu `purposes` parametr musi mieć taką samą wartość, który został dostarczony do <xref:System.Web.Security.MachineKey.Protect%2A> metody. W przeciwnym razie operacja zakończy się niepowodzeniem z <xref:System.Security.Cryptography.CryptographicException> wyjątku.  
  
 Ustawienia konfiguracji, które są wymagane dla <xref:System.Web.Configuration.MachineKeyCompatibilityMode.Framework45?displayProperty=nameWithType> opcji są wymagane dla tej metody, nawet jeśli <xref:System.Web.Configuration.MachineKeySection.CompatibilityMode%2A?displayProperty=nameWithType> nie ustawiono właściwości <xref:System.Web.Configuration.MachineKeyCompatibilityMode.Framework45> opcji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="userData" /> Parametr ma wartość null.</exception>
        <exception cref="T:System.ArgumentException">Tablica celów zawiera jeden lub więcej wpisów tylko odstępów.</exception>
      </Docs>
    </Member>
    <Member MemberName="Unprotect">
      <MemberSignature Language="C#" Value="public static byte[] Unprotect (byte[] protectedData, params string[] purposes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] Unprotect(unsigned int8[] protectedData, string[] purposes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.MachineKey.Unprotect(System.Byte[],System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Unprotect (protectedData As Byte(), ParamArray purposes As String()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ Unprotect(cli::array &lt;System::Byte&gt; ^ protectedData, ... cli::array &lt;System::String ^&gt; ^ purposes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="protectedData" Type="System.Byte[]" />
        <Parameter Name="purposes" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="protectedData">Dane tekstu szyfrowanego do usunięcia ochrony.</param>
        <param name="purposes">Lista celów, które opisują, jakie dane są przeznaczone. Musi to być taką samą wartość, która została przekazana do <see cref="M:System.Web.Security.MachineKey.Protect(System.Byte[],System.String[])" /> metodą podczas danych był chroniony.</param>
        <summary>Wyłącza ochronę określonych danych, która była chroniona przez <see cref="M:System.Web.Security.MachineKey.Protect(System.Byte[],System.String[])" /> metody.</summary>
        <returns>Dane w postaci zwykłego tekstu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Informacje dotyczące tej metody, zobacz <xref:System.Web.Security.MachineKey.Protect%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="protectedData" /> Parametr ma wartość null.</exception>
        <exception cref="T:System.ArgumentException">Tablica celów zawiera jeden lub więcej wpisów tylko odstępów.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Możliwe przyczyny są następujące:  
  
-   Chronionych danych został zmieniony.  
  
-   Wartość <paramref name="purposes" /> parametru nie jest taka sama, jak wartość, która została określona, gdy ochronę danych.  
  
-   Aplikacja jest wdrażana na więcej niż jednym serwerze i jest przy użyciu kluczy szyfrowania generowanych automatycznie.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
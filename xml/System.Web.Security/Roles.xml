<Type Name="Roles" FullName="System.Web.Security.Roles">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e6c80025dc8d7f24d9a7ba0a27c009717e02ad7d" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36596766" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Roles" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Roles extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.Security.Roles" />
  <TypeSignature Language="VB.NET" Value="Public Class Roles" />
  <TypeSignature Language="C++ CLI" Value="public ref class Roles abstract sealed" />
  <TypeSignature Language="F#" Value="type Roles = class" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Zarządza członkostwa użytkownika w rolach autoryzacji sprawdzanie w aplikacji ASP.NET. Klasa ta nie może być dziedziczona.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zarządzanie rolami ASP.NET umożliwia zarządzanie autoryzacji dla aplikacji opartych na grupach użytkowników, określany jako ról. Przypisując użytkowników do ról, można kontrolować dostęp do różnych części lub funkcje aplikacji sieci Web na podstawie roli zamiast lub oprócz określania autoryzacji na podstawie nazwy użytkownika. Na przykład aplikacja pracownik może mieć ról, takich jak menedżerów, pracownicy dyrektorów i tak dalej, określoną różne uprawnienia dla każdej roli.  
  
 Użytkownicy mogą należeć do więcej niż jednej roli. Na przykład jeśli witryna jest forum dyskusyjne, w przypadku niektórych użytkowników może być w roli moderatorów i elementów członkowskich. Można zdefiniować każdej roli uprawnień innej witrynie, a użytkownik, który znajduje się w obu ról będzie zmuszony oba zestawy uprawnień.  
  
 Aby włączyć zarządzanie rolami dla aplikacji ASP.NET, należy użyć elementu z `system.web` sekcji w pliku Web.config aplikacji, jak pokazano w poniższym przykładzie.  
  
```  
<configuration>  
  <connectionStrings>  
    <add name="SqlServices" connectionString="Data Source=localhost;Initial Catalog=aspnetdb;Integrated Security=SSPI;" />  
  </connectionStrings>  
  
  <system.web>  
    <authentication mode="Forms" >  
      <forms loginUrl="login.aspx"  
      name=".ASPXFORMSAUTH" />  
    </authentication>  
  
  <roleManager defaultProvider="SqlProvider"   
    enabled="true"  
    cacheRolesInCookie="true"  
    cookieName=".ASPROLES"  
    cookieTimeout="30"  
    cookiePath="/"  
    cookieRequireSSL="false"  
    cookieSlidingExpiration="true"  
    cookieProtection="All" >  
    <providers>  
      <add  
        name="SqlProvider"  
        type="System.Web.Security.SqlRoleProvider"  
        connectionStringName="SqlServices"  
        applicationName="SampleApplication" />  
      </providers>  
    </roleManager>  
  </system.web>  
</configuration>  
```  
  
 Można określić reguły autoryzacji w pliku konfiguracyjnym aplikacji sieci Web lub programowo w kodzie. Na przykład poniższa sekcja z pliku Web.config wymaga od użytkowników zalogowania się (za odmawianie użytkowników anonimowych), a następnie umożliwia tylko użytkownicy w roli administratorów dostępu.  
  
```  
<authorization>  
  <deny users="?" />  
  <allow roles="Administrators" />  
  <deny users="*" />  
</authorization>  
```  
  
 Jeśli używasz `authorization` sekcji w pliku Web.config aplikacji, aby określić autoryzacji na podstawie ról, użytkownicy aplikacji musisz podać tożsamość uwierzytelnionego użytkownika. Użytkownicy mogą uwierzytelniać przy użyciu uwierzytelniania systemu Windows lub formularzy. Użytkownicy anonimowi nie można przypisać do roli. Role można niezależnie od lub w połączeniu z platformy ASP.NET <xref:System.Web.Security.Membership> klasy.  
  
 Aby zweryfikować członkostwo roli programowo, można użyć <xref:System.Web.Security.Roles> klasy lub <xref:System.Web.UI.Page.User%2A?displayProperty=nameWithType> właściwość o <xref:System.Web.Security.Roles.IsUserInRole%2A> można użyć metody, lub <xref:System.Web.UI.Page.User%2A?displayProperty=nameWithType> właściwość o <xref:System.Security.Principal.IPrincipal.IsInRole%2A?displayProperty=nameWithType> metody. Przykładowy kod programowo sprawdza członkostwo roli zobacz sekcję przykład, w tym temacie.  
  
 <xref:System.Web.Security.Roles> Klasa umożliwia także do tworzenia i usuwania ról i dodawać lub usuwać użytkowników z ról.  
  
> [!NOTE]
>  Jeśli zostały skonfigurowane do używania aplikacji <xref:System.Web.Security.WindowsTokenRoleProvider> klasa, nie można zmodyfikować role lub członkostwa w roli. <xref:System.Web.Security.WindowsTokenRoleProvider> Członkostwa classverifies zabezpieczeń systemu Windows tylko grupy. W takim przypadku możesz korzystać Zarządzanie kontami użytkowników systemu Windows, a nie ról ASP.NET tworzenie i usuwanie grup i zarządzanie nimi członkostwa w grupie.  
  
 Informacje o rolach można przechowywać w kilka źródeł danych.  
  
-   Można użyć <xref:System.Web.Security.WindowsTokenRoleProvider> klasę, aby pobrać informacje o rolach oparte na członkostwie w grupach systemu Windows.  
  
-   Informacje o rolach można przechowywać w bazie danych programu SQL Server przy użyciu <xref:System.Web.Security.SqlRoleProvider> klasy.  
  
-   Jeśli masz istniejące informacje o rolach, lub chcesz przechowywać informacje o rolach w i pobierane informacje ze źródła danych, innym niż Windows, magazyn autoryzacji lub SQL Server, tworząc klasę, która dziedziczy możnazaimplementowaćdostawcęniestandardowejrolizabezpieczeń<xref:System.Web.Security.RoleProvider> klasy abstrakcyjnej. Aby uzyskać więcej informacji, zobacz [implementowanie dostawcy roli](http://msdn.microsoft.com/library/851671ce-bf9b-43f2-aba4-bc9d28b11c7d).  
  
 Jeśli przeglądarka użytkownika akceptuje pliki cookie, można przechowywać informacje o rolach dla tego użytkownika w pliku cookie na komputerze użytkownika. Na każdym żądaniu strony ASP.NET odczytuje informacje o rolach dla tego użytkownika z pliku cookie. Może to poprawić wydajność aplikacji przez skrócenie czasu komunikacji wymagane ze źródłem danych, można pobrać informacji o roli. Jeśli informacje o rolach użytkownika jest za długa, aby zapisać w pliku cookie, ASP.NET przechowuje tylko ostatnio używane informacje roli w pliku cookie, a następnie wyszukuje dodatkowe informacje w źródle danych, zgodnie z wymaganiami. Jeśli przeglądarka obsługuje pliki cookie lub pliki cookie są wyłączone, informacje o rolach nie jest buforowana w pliku cookie.  
  
 Można zwiększyć niezawodność nazw ról, określając w pamięci podręcznej w pliku cookie <xref:System.Web.Security.Roles.CookieProtectionValue%2A> właściwości po skonfigurowaniu ról ASP.NET. Wartość domyślna <xref:System.Web.Security.Roles.CookieProtectionValue%2A> jest `All`, który szyfruje nazwy elementu role w pliku cookie i weryfikuje, czy zawartość pliku cookie nie została zmieniona.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono plik Web.config dla aplikacji, który został skonfigurowany do użycia zarówno członkostwa ASP.NET, jak i role programu ASP.NET i <xref:System.Web.Security.SqlRoleProvider> do przechowywania informacji o członkostwa i ról w bazie danych programu SQL Server. Uwierzytelnianie użytkowników za pomocą uwierzytelniania formularzy oraz tylko użytkownicy należący do roli Administratorzy mają dostęp do aplikacji.  
  
```  
<configuration>  
  <connectionStrings>  
    <add name="SqlServices" connectionString="Data Source=localhost;Initial Catalog=aspnetdb;Integrated Security=SSPI;" />  
  </connectionStrings>  
  
  <system.web>  
    <authentication mode="Forms" >  
      <forms loginUrl="login.aspx"  
      name=".ASPXFORMSAUTH" />  
    </authentication>  
  
    <authorization>  
      <deny users="?" />  
      <allow roles="Administrators" />  
      <deny users="*" />  
    </authorization>  
  
    <membership defaultProvider="AspNetSqlProvider" userIsOnlineTimeWindow="15">  
    </membership>  
  
    <roleManager defaultProvider="SqlProvider"   
      enabled="true"  
      cacheRolesInCookie="true"  
      cookieName=".ASPROLES"  
      cookieTimeout="30"  
      cookiePath="/"  
      cookieRequireSSL="true"  
      cookieSlidingExpiration="true"  
      cookieProtection="All" >  
  
      <providers>  
        <clear />  
        <add  
          name="SqlProvider"  
          type="System.Web.Security.SqlRoleProvider"  
          connectionStringName="SqlServices"  
          applicationName="SampleApplication" />  
        </providers>  
  
    </roleManager>  
  </system.web>  
</configuration>  
```  
  
 Poniższy przykładowy kod programowo sprawdza, czy zalogowany użytkownik jest w roli administratora przed zezwoleniem użytkownikowi przeglądanie innych użytkowników, ról.  
  
  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AddUsersToRole">
      <MemberSignature Language="C#" Value="public static void AddUsersToRole (string[] usernames, string roleName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddUsersToRole(string[] usernames, string roleName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.AddUsersToRole(System.String[],System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddUsersToRole (usernames As String(), roleName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddUsersToRole(cli::array &lt;System::String ^&gt; ^ usernames, System::String ^ roleName);" />
      <MemberSignature Language="F#" Value="static member AddUsersToRole : string[] * string -&gt; unit" Usage="System.Web.Security.Roles.AddUsersToRole (usernames, roleName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="usernames" Type="System.String[]" />
        <Parameter Name="roleName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="usernames">Tablica ciągów nazw użytkowników, aby dodać do określonej roli.</param>
        <param name="roleName">Rola do określone nazwy użytkownika do dodania.</param>
        <summary>Dodaje określonych użytkowników do określonej roli.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.Roles.AddUsersToRole%2A> Metoda wywołuje domyślnego dostawcy roli można skojarzyć określonych użytkowników z określonej roli w źródle danych.  
  
 Jeśli aplikacja używa <xref:System.Web.Security.SqlRoleProvider> klasy aktualizacje bazy danych, które są wykonywane podczas wywołania <xref:System.Web.Security.SqlRoleProvider.AddUsersToRoles%2A> metody zostały wprowadzone w obrębie transakcji. Jeśli wystąpi błąd, takie jak nazwa użytkownika, który jest już w określonej roli, transakcja zostanie wycofana i są wykonywane żadne aktualizacje.  
  
> [!NOTE]
>  Nazwy użytkowników i nazwy roli nie może zawierać przecinków.  
  
   
  
## Examples  
 Poniższy przykładowy kod dodaje co najmniej jednego użytkownika do roli lub usuwa użytkownika z roli, w oparciu o dane wejściowe użytkownika. Na przykład plik Web.config, który umożliwia zarządzanie rolami zobacz <xref:System.Web.Security.Roles>.  
  
 [!code-aspx-csharp[System.Web.Security.SqlRoleProvider#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/CS/adduserstorolecs.aspx#3)]
 [!code-aspx-vb[System.Web.Security.SqlRoleProvider#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/VB/adduserstorolevb.aspx#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="roleName" /> jest <see langword="null" />.  - lub - jeden z elementów w <paramref name="usernames" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="roleName" /> to ciąg pusty lub zawiera przecinka (,).  - lub - jeden z elementów w <paramref name="usernames" /> to ciąg pusty lub zawiera przecinka (,).  - lub - <paramref name="usernames" /> zawiera zduplikowany element.</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">Nie włączono zarządzania rolami.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddUsersToRoles">
      <MemberSignature Language="C#" Value="public static void AddUsersToRoles (string[] usernames, string[] roleNames);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddUsersToRoles(string[] usernames, string[] roleNames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.AddUsersToRoles(System.String[],System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddUsersToRoles (usernames As String(), roleNames As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddUsersToRoles(cli::array &lt;System::String ^&gt; ^ usernames, cli::array &lt;System::String ^&gt; ^ roleNames);" />
      <MemberSignature Language="F#" Value="static member AddUsersToRoles : string[] * string[] -&gt; unit" Usage="System.Web.Security.Roles.AddUsersToRoles (usernames, roleNames)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="usernames" Type="System.String[]" />
        <Parameter Name="roleNames" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="usernames">Tablica ciągów nazw użytkowników, aby dodać do określonych ról.</param>
        <param name="roleNames">Tablica ciągów nazw ról do określone nazwy użytkownika do dodania.</param>
        <summary>Dodaje określonych użytkowników do określonych ról.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.Roles.AddUsersToRoles%2A> Metoda wywołuje domyślnego dostawcy roli można skojarzyć określonych użytkowników z określonych ról w źródle danych.  
  
 Jeśli aplikacja używa <xref:System.Web.Security.SqlRoleProvider> klasy aktualizacje bazy danych, które są wykonywane podczas wywołania <xref:System.Web.Security.SqlRoleProvider.AddUsersToRoles%2A> metody zostały wprowadzone w obrębie transakcji. Jeśli wystąpi błąd, takie jak nazwa użytkownika, który jest już w określonej roli, transakcja zostanie wycofana i są wykonywane żadne aktualizacje.  
  
> [!NOTE]
>  Nazwy użytkowników i nazwy roli nie może zawierać przecinków.  
  
   
  
## Examples  
 Poniższy przykładowy kod dodaje co najmniej jednego użytkownika do co najmniej jedną rolę. Na przykład plik Web.config, który umożliwia zarządzanie rolami zobacz <xref:System.Web.Security.Roles>.  
  
 [!code-aspx-csharp[System.Web.Security.Roles#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.Roles/CS/adduserstorolescs.aspx#1)]
 [!code-aspx-vb[System.Web.Security.Roles#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.Roles/VB/adduserstorolesvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Jedną z ról w <paramref name="roleNames" /> jest <see langword="null" />.  - lub - jeden z użytkowników w <paramref name="usernames" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Jedną z ról w <paramref name="roleNames" /> to ciąg pusty lub zawiera przecinka (,).  - lub - jeden z użytkowników w <paramref name="usernames" /> to ciąg pusty lub zawiera przecinka (,).  - lub - <paramref name="roleNames" /> zawiera zduplikowany element.  - lub - <paramref name="usernames" /> zawiera zduplikowany element.</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">Nie włączono zarządzania rolami.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddUserToRole">
      <MemberSignature Language="C#" Value="public static void AddUserToRole (string username, string roleName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddUserToRole(string username, string roleName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.AddUserToRole(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddUserToRole (username As String, roleName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddUserToRole(System::String ^ username, System::String ^ roleName);" />
      <MemberSignature Language="F#" Value="static member AddUserToRole : string * string -&gt; unit" Usage="System.Web.Security.Roles.AddUserToRole (username, roleName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="username" Type="System.String" />
        <Parameter Name="roleName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="username">Nazwa użytkownika do dodania do określonej roli.</param>
        <param name="roleName">Rola do określonej nazwy użytkownika do dodania.</param>
        <summary>Dodaje określonego użytkownika do określonej roli.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.Roles.AddUserToRole%2A> Metoda wywołuje domyślnego dostawcy roli skojarzenie określonego użytkownika z określoną rolę w źródle danych.  
  
> [!NOTE]
>  Nazwy użytkowników i nazwy roli nie może zawierać przecinków.  
  
   
  
## Examples  
 Poniższy przykładowy kod dodaje użytkownika do roli. Na przykład plik Web.config, który umożliwia zarządzanie rolami zobacz <xref:System.Web.Security.Roles>.  
  
 [!code-aspx-csharp[System.Web.Security.Roles#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.Roles/CS/addusertorolecs.aspx#2)]
 [!code-aspx-vb[System.Web.Security.Roles#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.Roles/VB/addusertorolevb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="roleName" /> jest <see langword="null" />.  - lub - <paramref name="username" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="roleName" /> to ciąg pusty lub zawiera przecinka (,).  - lub - <paramref name="username" /> to ciąg pusty lub zawiera przecinka (,).</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">Nie włączono zarządzania rolami.  - lub - użytkownik jest już przypisany do określonej roli.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddUserToRoles">
      <MemberSignature Language="C#" Value="public static void AddUserToRoles (string username, string[] roleNames);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddUserToRoles(string username, string[] roleNames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.AddUserToRoles(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddUserToRoles (username As String, roleNames As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddUserToRoles(System::String ^ username, cli::array &lt;System::String ^&gt; ^ roleNames);" />
      <MemberSignature Language="F#" Value="static member AddUserToRoles : string * string[] -&gt; unit" Usage="System.Web.Security.Roles.AddUserToRoles (username, roleNames)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="username" Type="System.String" />
        <Parameter Name="roleNames" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="username">Nazwa użytkownika do dodania do określonych ról.</param>
        <param name="roleNames">Tablica ciągów ról do określonej nazwy użytkownika do dodania.</param>
        <summary>Dodaje określonego użytkownika do określonych ról.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.Roles.AddUserToRoles%2A> Metoda wywołuje domyślnego dostawcy roli skojarzenie określonego użytkownika z określonych ról w źródle danych.  
  
 Jeśli aplikacja używa <xref:System.Web.Security.SqlRoleProvider> klasy aktualizacje bazy danych, które są wykonywane podczas wywołania <xref:System.Web.Security.Roles.AddUserToRoles%2A> metody zostały wprowadzone w obrębie transakcji. Jeśli wystąpi błąd, takie jak nazwa użytkownika, który jest już w określonej roli, transakcja zostanie wycofana i są wykonywane żadne aktualizacje.  
  
> [!NOTE]
>  Nazwy użytkowników i nazwy roli nie może zawierać przecinków.  
  
   
  
## Examples  
 Poniższy przykładowy kod dodaje użytkownika do co najmniej jedną rolę. Na przykład plik Web.config, który umożliwia zarządzanie rolami zobacz <xref:System.Web.Security.Roles>.  
  
 [!code-aspx-csharp[System.Web.Security.Roles#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.Roles/CS/addusertorolescs.aspx#3)]
 [!code-aspx-vb[System.Web.Security.Roles#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.Roles/VB/addusertorolesvb.aspx#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Jedną z ról w <paramref name="roleNames" /> jest <see langword="null" />.  - lub - <paramref name="username" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Jedną z ról w <paramref name="roleNames" /> to ciąg pusty lub zawiera przecinka (,).  - lub - <paramref name="username" /> to ciąg pusty lub zawiera przecinka (,).  - lub - <paramref name="roleNames" /> zawiera zduplikowany element.</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">Nie włączono zarządzania rolami.</exception>
      </Docs>
    </Member>
    <Member MemberName="ApplicationName">
      <MemberSignature Language="C#" Value="public static string ApplicationName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property string ApplicationName" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.Roles.ApplicationName" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ApplicationName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ApplicationName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationName : string with get, set" Usage="System.Web.Security.Roles.ApplicationName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę aplikacji do przechowywania i pobierane informacje.</summary>
        <value>Nazwa aplikacji do przechowywania i pobierane informacje.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.Roles.ApplicationName%2A> Jest używana przez <xref:System.Web.Security.Roles> klasę, aby skojarzyć użytkowników i ról z różnych aplikacji. Dzięki temu wiele aplikacji może używać tego samego źródła danych do przechowywania bez powodowania konfliktów między zduplikowanych nazw użytkownika lub roli zduplikowanych nazw użytkownika i informacje o rolach. Wiele aplikacji programu ASP.NET można użyć tego samego źródła danych, podając tę samą wartość w <xref:System.Web.Security.Roles.ApplicationName%2A> właściwości. Można ustawić <xref:System.Web.Security.Roles.ApplicationName%2A> właściwości programowo, lub możesz ustawić deklaratywnie w pliku konfiguracji dla aplikacji sieci Web przy użyciu `applicationName` atrybutu.  
  
 Jeśli aplikacja sieci Web używa <xref:System.Web.Security.SqlRoleProvider> klasy i wartość nie jest określony dla `applicationName` atrybutu w pliku konfiguracyjnym <xref:System.Web.HttpRequest.ApplicationPath%2A?displayProperty=nameWithType> wartości właściwości dla bieżącej <xref:System.Web.HttpContext.Request%2A?displayProperty=nameWithType> właściwość jest używana.  
  
> [!CAUTION]
>  Ponieważ domyślnego pojedynczego wystąpienia dostawcy roli jest używana dla wszystkich żądań obsłużonych przez <xref:System.Web.HttpApplication> obiekt może mieć wiele żądań wykonywanych równocześnie i próby ustawienia <xref:System.Web.Security.Roles.ApplicationName%2A> wartości właściwości. <xref:System.Web.Security.Roles.ApplicationName%2A> Właściwość nie jest wątku bezpieczne dla wielu operacji zapisu, a zmiana <xref:System.Web.Security.Roles.ApplicationName%2A> wartość właściwości może spowodować nieoczekiwane zachowanie dla wielu użytkowników aplikacji. Należy unikać pisania kodu, aby umożliwić użytkownikom ustawić <xref:System.Web.Security.Roles.ApplicationName%2A> właściwości, o ile nie jest wymagane. Przykładem aplikacji w przypadku, gdy ustawienie <xref:System.Web.Security.Roles.ApplicationName%2A> właściwości mogą być wymagane jest administracyjne aplikacji, która zarządza danymi roli dla wielu zastosowań. Takiej aplikacji powinna być aplikacją pojedynczego użytkownika, a nie aplikacji sieci Web.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano element `system.web` sekcji w pliku Web.config dla aplikacji ASP.NET. Określa, że aplikacja używa <xref:System.Web.Security.SqlRoleProvider> wystąpienie i konfiguruje `applicationName` atrybutu `MyApplication`.  
  
```  
<roleManager defaultProvider="SqlProvider"   
  enabled="true"  
  cacheRolesInCookie="true"  
  cookieName=".ASPROLES"  
  cookieTimeout="30"  
  cookiePath="/"  
  cookieRequireSSL="false"  
  cookieSlidingExpiration="true"  
  cookieProtection="All" >  
  <providers>  
    <add  
      name="SqlProvider"  
      type="System.Web.Security.SqlRoleProvider"  
      connectionStringName="SqlServices"  
      applicationName="MyApplication" />  
  </providers>  
</roleManager>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CacheRolesInCookie">
      <MemberSignature Language="C#" Value="public static bool CacheRolesInCookie { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool CacheRolesInCookie" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.Roles.CacheRolesInCookie" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CacheRolesInCookie As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool CacheRolesInCookie { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CacheRolesInCookie : bool" Usage="System.Web.Security.Roles.CacheRolesInCookie" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżący użytkownik role są buforowane w pliku cookie.</summary>
        <value>
          <see langword="true" /> Jeśli ról bieżącego użytkownika są buforowane w pliku cookie; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Web.Security.Roles.CacheRolesInCookie%2A> ma ustawioną wartość właściwości `true` w pliku Web.config, informacje o rolach dla każdego użytkownika jest przechowywany w pliku cookie. Podczas zarządzania rolami sprawdza, czy użytkownik jest w określonej roli, role plik cookie jest sprawdzana przed dostawcy roli jest wywoływana, aby sprawdzić listę ról w źródle danych. Plik cookie jest aktualizowana dynamicznie do pamięci podręcznej najbardziej ostatnio zweryfikowanych nazwy roli.  
  
 Można zwiększyć niezawodność nazw ról, określając w pamięci podręcznej w pliku cookie <xref:System.Web.Security.Roles.CookieProtectionValue%2A> właściwości po skonfigurowaniu ról ASP.NET. Wartość domyślna <xref:System.Web.Security.Roles.CookieProtectionValue%2A> jest `All`, który szyfruje nazwy elementu role w pliku cookie i weryfikuje, czy zawartość pliku cookie nie została zmieniona.  
  
> [!NOTE]
>  Ponieważ nazwy roli mogą być buforowane oprócz źródła danych, jest to możliwe, że zmiany do zarządzania rolami w źródle danych nie będzie można odzwierciedlone w buforowane wartości. W takim przypadku użytkownik musi zamknąć i ponownie otwórz w przeglądarce, aby wyczyścić wartości pliku cookie w pamięci podręcznej.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano element `system.web` sekcji w pliku Web.config dla aplikacji ASP.NET. Określa, że aplikacja używa <xref:System.Web.Security.SqlRoleProvider> wystąpienie i konfiguruje `cacheRolesInCookie` atrybutu `true`.  
  
```  
<roleManager defaultProvider="SqlProvider"   
  enabled="true"  
  cacheRolesInCookie="true"  
  cookieName=".ASPROLES"  
  cookieTimeout="30"  
  cookiePath="/"  
  cookieRequireSSL="false"  
  cookieSlidingExpiration="true"  
  cookieProtection="All" >  
  <providers>  
    <add  
      name="SqlProvider"  
      type="System.Web.Security.SqlRoleProvider"  
      connectionStringName="SqlServices"  
      applicationName="MyApplication" />  
   </providers>  
</roleManager>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CookieName">
      <MemberSignature Language="C#" Value="public static string CookieName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CookieName" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.Roles.CookieName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CookieName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CookieName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CookieName : string" Usage="System.Web.Security.Roles.CookieName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę pliku cookie, których nazwy elementu role są buforowane.</summary>
        <value>Nazwa pliku cookie, których nazwy elementu role są buforowane. Wartość domyślna to. ASPXROLES.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy określić nazwę pliku cookie, których role są buforowane dla aplikacji, ustawiając `cookieName` atrybutu w pliku Web.config dla aplikacji ASP.NET. Jest to przydatne, gdy chcesz jednoznacznie zidentyfikować plik cookie dla aplikacji lub plik cookie jest współużytkowany przez wiele aplikacji, takich jak domeny pliku cookie.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano element `system.web` sekcji w pliku Web.config dla aplikacji ASP.NET. Określa, że aplikacja używa <xref:System.Web.Security.SqlRoleProvider> wystąpienie i konfiguruje `cookieName` atrybutu. ASPROLES.  
  
```  
<roleManager defaultProvider="SqlProvider"   
  enabled="true"  
  cacheRolesInCookie="true"  
  cookieName=".ASPROLES"  
  cookieTimeout="30"  
  cookiePath="/"  
  cookieRequireSSL="false"  
  cookieSlidingExpiration="true"  
  cookieProtection="All" >  
  <providers>  
    <add  
      name="SqlProvider"  
      type="System.Web.Security.SqlRoleProvider"  
      connectionStringName="SqlServices"  
      applicationName="MyApplication" />  
  </providers>  
</roleManager>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CookiePath">
      <MemberSignature Language="C#" Value="public static string CookiePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CookiePath" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.Roles.CookiePath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CookiePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CookiePath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CookiePath : string" Usage="System.Web.Security.Roles.CookiePath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ścieżkę pliku cookie z nazwy roli pamięci podręcznej.</summary>
        <value>Ścieżka pliku cookie, których nazwy elementu role są buforowane. Wartość domyślna to /.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można określić ścieżkę pliku cookie, których role są buforowane dla aplikacji przez ustawienie `cookiePath` atrybutu w pliku Web.config dla aplikacji ASP.NET. Aby uzyskać więcej informacji na temat ścieżek plików cookie, zobacz <xref:System.Web.HttpCookie.Path%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano element `system.web` sekcji w pliku Web.config dla aplikacji ASP.NET. Określa, że aplikacja używa <xref:System.Web.Security.SqlRoleProvider> wystąpienie i konfiguruje `cookiePath` atrybutu /MyApplication.  
  
```  
<roleManager defaultProvider="SqlProvider"   
  enabled="true"  
  cacheRolesInCookie="true"  
  cookieName=".ASPROLES"  
  cookieTimeout="30"  
  cookiePath="/MyApplication"  
  cookieRequireSSL="false"  
  cookieSlidingExpiration="true"  
  cookieProtection="All" >  
  <providers>  
    <add  
      name="SqlProvider"  
      type="System.Web.Security.SqlRoleProvider"  
      connectionStringName="SqlServices"  
      applicationName="MyApplication" />  
  </providers>  
</roleManager>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CookieProtectionValue">
      <MemberSignature Language="C#" Value="public static System.Web.Security.CookieProtection CookieProtectionValue { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Web.Security.CookieProtection CookieProtectionValue" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.Roles.CookieProtectionValue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CookieProtectionValue As CookieProtection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Web::Security::CookieProtection CookieProtectionValue { System::Web::Security::CookieProtection get(); };" />
      <MemberSignature Language="F#" Value="member this.CookieProtectionValue : System.Web.Security.CookieProtection" Usage="System.Web.Security.Roles.CookieProtectionValue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Security.CookieProtection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą sposób nazwy roli w pliku cookie w pamięci podręcznej są chronione.</summary>
        <value>Jeden z <see cref="T:System.Web.Security.CookieProtection" /> wartości wyliczenia wskazująca, jak chronione są nazwy ról, które są buforowane w pliku cookie. Wartość domyślna to <see langword="All" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dla aplikacji można określić ochrony plików cookie, których role są buforowane, ustawiając `cookieProtection` atrybutu w pliku Web.config dla aplikacji ASP.NET. `cookieProtection` Atrybutu ma <xref:System.Web.Security.CookieProtection> wartość wyliczenia wskazująca, czy nazwy roli są szyfrowane, zweryfikowany, dlatego obie lub nie.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano element `system.web` sekcji w pliku Web.config dla aplikacji ASP.NET. Określa, że aplikacja używa <xref:System.Web.Security.SqlRoleProvider> wystąpienie i konfiguruje `cookieProtection` atrybutu `Encrypted`.  
  
```  
<roleManager defaultProvider="SqlProvider"   
  enabled="true"  
  cacheRolesInCookie="true"  
  cookieName=".ASPROLES"  
  cookieTimeout="30"  
  cookiePath="/MyApplication"  
  cookieRequireSSL="false"  
  cookieSlidingExpiration="true"  
  cookieProtection="Encrypted" >  
  <providers>  
    <add  
      name="SqlProvider"  
      type="System.Web.Security.SqlRoleProvider"  
      connectionStringName="SqlServices"  
      applicationName="MyApplication" />  
  </providers>  
</roleManager>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CookieRequireSSL">
      <MemberSignature Language="C#" Value="public static bool CookieRequireSSL { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool CookieRequireSSL" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.Roles.CookieRequireSSL" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CookieRequireSSL As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool CookieRequireSSL { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CookieRequireSSL : bool" Usage="System.Web.Security.Roles.CookieRequireSSL" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy plik cookie nazwy roli wymaga protokołu SSL w celu zwrócenia na serwer.</summary>
        <value>
          <see langword="true" /> Jeśli protokół SSL jest wymagany, aby przywrócić plik cookie nazwy roli serwera; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można określić, czy SSL (Secure Sockets Layer) jest wymagany, aby przywrócić plik cookie nazwy roli serwera w aplikacji przez ustawienie `cookieRequireSSL` atrybutu w pliku Web.config dla aplikacji ASP.NET. Aby uzyskać więcej informacji, zobacz <xref:System.Web.HttpCookie.Secure%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano element `system.web` sekcji w pliku Web.config dla aplikacji ASP.NET. Określa, że aplikacja używa <xref:System.Web.Security.SqlRoleProvider> wystąpienie i konfiguruje `cookieRequireSSL` do `true`.  
  
```  
<roleManager defaultProvider="SqlProvider"   
  enabled="true"  
  cacheRolesInCookie="true"  
  cookieName=".ASPROLES"  
  cookieTimeout="30"  
  cookiePath="/MyApplication"  
  cookieRequireSSL="true"  
  cookieSlidingExpiration="true"  
  cookieProtection="Encrypted" >  
  <providers>  
    <add  
      name="SqlProvider"  
      type="System.Web.Security.SqlRoleProvider"  
      connectionStringName="SqlServices"  
      applicationName="MyApplication" />  
  </providers>  
</roleManager>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CookieSlidingExpiration">
      <MemberSignature Language="C#" Value="public static bool CookieSlidingExpiration { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool CookieSlidingExpiration" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.Roles.CookieSlidingExpiration" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CookieSlidingExpiration As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool CookieSlidingExpiration { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CookieSlidingExpiration : bool" Usage="System.Web.Security.Roles.CookieSlidingExpiration" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wskazuje, czy rola nazwy pliku cookie datę i godzinę wygaśnięcia zostaną zresetowane okresowo.</summary>
        <value>
          <see langword="true" /> Jeśli rola nazwy pliku cookie datę i godzinę wygaśnięcia będzie można zresetować okresowo. w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można określić, czy roli nazwy datę ważności pliku cookie i czas zostanie zresetowana z każdym odpowiedzi przy użyciu `cookieSlidingExpiration` atrybutu w pliku Web.config dla aplikacji ASP.NET. Jeśli `true`, datę ważności pliku cookie zostanie początkowo ustawiona na bieżącą datę i godzinę oraz <xref:System.Web.Security.Roles.CookieTimeout%2A> w minutach. Gdy użytkownik nadal aktywnie korzystanie z aplikacji ASP.NET, datę i godzinę wygaśnięcia pliku cookie są automatycznie odświeżane w przypadku mniej niż połowy <xref:System.Web.Security.Roles.CookieTimeout%2A> pozostałych. Aby uzyskać więcej informacji, zobacz <xref:System.Web.HttpCookie.Expires%2A> właściwości.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano element `system.web` sekcji w pliku Web.config dla aplikacji ASP.NET. Określa, że aplikacja używa <xref:System.Web.Security.SqlRoleProvider> wystąpienie i konfiguruje <xref:System.Web.Security.Roles.CookieSlidingExpiration%2A> właściwości `false`.  
  
```  
<roleManager defaultProvider="SqlProvider"   
  enabled="true"  
  cacheRolesInCookie="true"  
  cookieName=".ASPROLES"  
  cookieTimeout="30"  
  cookiePath="/MyApplication"  
  cookieRequireSSL="true"  
  cookieSlidingExpiration="false"  
  cookieProtection="Encrypted" >  
  <providers>  
    <add  
      name="SqlProvider"  
      type="System.Web.Security.SqlRoleProvider"  
      connectionStringName="SqlServices"  
      applicationName="MyApplication" />  
  </providers>  
</roleManager>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CookieTimeout">
      <MemberSignature Language="C#" Value="public static int CookieTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CookieTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.Roles.CookieTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CookieTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int CookieTimeout { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CookieTimeout : int" Usage="System.Web.Security.Roles.CookieTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę minut, po którym wygasa plik cookie ról.</summary>
        <value>Liczba całkowita określająca liczbę minut przed ról plik cookie wygasa. Wartość domyślna to 30 minut.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.Roles.CookieTimeout%2A> Właściwość jest używana podczas <xref:System.Web.Security.Roles.CookieSlidingExpiration%2A> właściwość jest `true` i określa czas wygaśnięcia w minutach, pliku cookie ról. Aby ustawić <xref:System.Web.Security.Roles.CookieTimeout%2A> wartości, należy dodać `cookieTimeout` atrybutu do elementu w pliku Web.config dla aplikacji ASP.NET i określ liczbę całkowitą.  
  
 Jeśli <xref:System.Web.Security.Roles.CookieSlidingExpiration%2A> jest `false`, ta właściwość jest ignorowana.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano element `system.web` sekcji w pliku Web.config dla aplikacji ASP.NET. Określa, że aplikacja używa <xref:System.Web.Security.SqlRoleProvider> wystąpienie i konfiguruje <xref:System.Web.Security.Roles.CookieTimeout%2A> właściwości do 30 minut.  
  
```  
<roleManager defaultProvider="SqlProvider"   
  enabled="true"  
  cacheRolesInCookie="true"  
  cookieName=".ASPROLES"  
  cookieTimeout="30"  
  cookiePath="/MyApplication"  
  cookieRequireSSL="true"  
  cookieSlidingExpiration="true"  
  cookieProtection="Encrypted" >  
  <providers>  
  <add  
    name="SqlProvider"  
    type="System.Web.Security.SqlRoleProvider"  
    connectionStringName="SqlServices"  
    applicationName="MyApplication" />  
  </providers>  
</roleManager>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreatePersistentCookie">
      <MemberSignature Language="C#" Value="public static bool CreatePersistentCookie { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool CreatePersistentCookie" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.Roles.CreatePersistentCookie" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CreatePersistentCookie As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool CreatePersistentCookie { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CreatePersistentCookie : bool" Usage="System.Web.Security.Roles.CreatePersistentCookie" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy plik cookie nazw ról jest oparte na sesji i trwałe.</summary>
        <value>
          <see langword="true" /> Jeśli plik cookie nazw ról jest trwały plik cookie; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.Roles.CreatePersistentCookie%2A> Wartość właściwości jest ustawiana w konfiguracji dla aplikacji ASP.NET przy użyciu `createPersistentCookie` atrybut elementu konfiguracji.  
  
 Gdy `false`, plik cookie nazw ról jest plik cookie sesji, plik cookie jest utracone po zamknięciu przeglądarki. Gdy `true`, plik cookie nazw ról jest trwały plik cookie jest dostępny w wielu sesjach przeglądarki. Data wygaśnięcia trwały plik cookie i godzina są ustawione na bieżącą datę i godzinę oraz <xref:System.Web.Security.Roles.CookieTimeout%2A> wartość w minutach.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateRole">
      <MemberSignature Language="C#" Value="public static void CreateRole (string roleName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateRole(string roleName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.CreateRole(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateRole (roleName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateRole(System::String ^ roleName);" />
      <MemberSignature Language="F#" Value="static member CreateRole : string -&gt; unit" Usage="System.Web.Security.Roles.CreateRole roleName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="roleName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="roleName">Nazwa roli do utworzenia.</param>
        <summary>Dodaje nową rolę do źródła danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.Roles.CreateRole%2A> Metoda dodaje nazwę roli w źródle danych. <xref:System.Web.Security.Roles.CreateRole%2A> wywołania <xref:System.Web.Security.RoleProvider.CreateRole%2A> metody domyślnego dostawcy roli, aby dodać określoną rolę do źródła danych.  
  
> [!NOTE]
>  Nazwy roli nie może zawierać przecinków.  
  
   
  
## Examples  
 Poniższy przykładowy kod tworzy nową rolę w źródle danych. Na przykład plik Web.config, który umożliwia zarządzanie rolami zobacz <xref:System.Web.Security.Roles>.  
  
> [!IMPORTANT]
>  Ten przykład zawiera pole tekstowe, który akceptuje dane wejściowe użytkownika, który jest potencjalnym zagrożeniem dla bezpieczeństwa. Domyślnie strony sieci Web ASP.NET zweryfikować, czy dane wejściowe użytkownika nie obejmuje skrypt lub elementów HTML. Aby uzyskać więcej informacji, zobacz [Przegląd wykorzystuje skryptu](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[System.Web.Security.SqlRoleProvider#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/CS/createrolecs.aspx#1)]
 [!code-aspx-vb[System.Web.Security.SqlRoleProvider#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/VB/createrolevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="roleName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="roleName" /> jest pustym ciągiem.  - lub - <paramref name="roleName" /> zawiera przecinek.</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">Nie włączono zarządzania rolami.</exception>
      </Docs>
    </Member>
    <Member MemberName="DeleteCookie">
      <MemberSignature Language="C#" Value="public static void DeleteCookie ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DeleteCookie() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.DeleteCookie" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteCookie ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteCookie();" />
      <MemberSignature Language="F#" Value="static member DeleteCookie : unit -&gt; unit" Usage="System.Web.Security.Roles.DeleteCookie " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa plik cookie, w którym są buforowane nazwy roli.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.Roles.DeleteCookie%2A> Metody Czyści zawartość pliku cookie, który służy do pamięci podręcznej nazw ról. Aby uzyskać więcej informacji na buforowanie nazw ról, zobacz <xref:System.Web.Security.Roles.CacheRolesInCookie%2A>.  
  
   
  
## Examples  
 Poniższy kod przykładowy wywołania <xref:System.Web.Security.Roles.DeleteCookie%2A> wyczyść wszystkie metody w pamięci podręcznej nazw ról po zalogowaniu użytkownika. Na przykład plik Web.config, który umożliwia zarządzanie rolami zobacz <xref:System.Web.Security.Roles>.  
  
> [!IMPORTANT]
>  Ten przykład zawiera pole tekstowe, który akceptuje dane wejściowe użytkownika, który jest potencjalnym zagrożeniem dla bezpieczeństwa. Domyślnie strony sieci Web ASP.NET zweryfikować, czy dane wejściowe użytkownika nie obejmuje skrypt lub elementów HTML. Aby uzyskać więcej informacji, zobacz [Przegląd wykorzystuje skryptu](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[System.Web.Security.Roles#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.Roles/CS/logincs.aspx#5)]
 [!code-aspx-vb[System.Web.Security.Roles#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.Roles/VB/loginvb.aspx#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.Provider.ProviderException">Nie włączono zarządzania rolami.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteRole">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Usuwa rolę ze źródła danych.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteRole">
      <MemberSignature Language="C#" Value="public static bool DeleteRole (string roleName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool DeleteRole(string roleName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.DeleteRole(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DeleteRole (roleName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool DeleteRole(System::String ^ roleName);" />
      <MemberSignature Language="F#" Value="static member DeleteRole : string -&gt; bool" Usage="System.Web.Security.Roles.DeleteRole roleName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="roleName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="roleName">Nazwa roli do usunięcia.</param>
        <summary>Usuwa rolę ze źródła danych.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="roleName" /> został usunięty ze źródła danych; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.Roles.DeleteRole%2A> Metoda usuwa nazwę roli ze źródła danych. <xref:System.Web.Security.Roles.DeleteRole%2A> wywołania <xref:System.Web.Security.RoleProvider.DeleteRole%2A> metody domyślnego dostawcy roli do usunięcia określonej roli ze źródła danych.  
  
 Jeśli rola zidentyfikowana na podstawie `roleName` parametr ma co najmniej jednego członka, a następnie zostanie wygenerowany wyjątek i roli nie zostaną usunięte.  
  
   
  
## Examples  
 Poniższy przykład kodu usuwa rolę ze źródła danych. Na przykład plik Web.config, który umożliwia zarządzanie rolami zobacz <xref:System.Web.Security.Roles>.  
  
 [!code-aspx-csharp[System.Web.Security.SqlRoleProvider#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/CS/deleterolecs.aspx#2)]
 [!code-aspx-vb[System.Web.Security.SqlRoleProvider#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/VB/deleterolevb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="roleName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="roleName" /> to ciąg pusty lub zawiera przecinka (,).</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">
          <paramref name="roleName" /> zawiera co najmniej jednego członka.  - lub - nie włączono zarządzania rolami.</exception>
      </Docs>
    </Member>
    <Member MemberName="DeleteRole">
      <MemberSignature Language="C#" Value="public static bool DeleteRole (string roleName, bool throwOnPopulatedRole);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool DeleteRole(string roleName, bool throwOnPopulatedRole) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.DeleteRole(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DeleteRole (roleName As String, throwOnPopulatedRole As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool DeleteRole(System::String ^ roleName, bool throwOnPopulatedRole);" />
      <MemberSignature Language="F#" Value="static member DeleteRole : string * bool -&gt; bool" Usage="System.Web.Security.Roles.DeleteRole (roleName, throwOnPopulatedRole)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="roleName" Type="System.String" />
        <Parameter Name="throwOnPopulatedRole" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="roleName">Nazwa roli do usunięcia.</param>
        <param name="throwOnPopulatedRole">Jeśli <see langword="true" />, zgłasza wyjątek, jeśli <c>roleName</c> ma co najmniej jednego członka.</param>
        <summary>Usuwa rolę ze źródła danych.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="roleName" /> został usunięty ze źródła danych; w przeciwnym razie; <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.Roles.DeleteRole%2A> Metoda usuwa nazwę roli ze źródła danych. <xref:System.Web.Security.Roles.DeleteRole%2A> wywołania <xref:System.Web.Security.RoleProvider.DeleteRole%2A> metody domyślnego dostawcy roli do usunięcia określonej roli ze źródła danych.  
  
 Jeśli `throwOnPopulatedRole` jest `true`, następnie zostanie wygenerowany wyjątek i roli nie zostaną usunięte, jeśli rola zidentyfikowana na podstawie `roleName` parametr ma co najmniej jednego członka. Jeśli `throwOnPopulatedRole` jest `false`, roli zostanie usunięty, czy nie jest on pusty.  
  
   
  
## Examples  
 Poniższy przykład kodu usuwa rolę ze źródła danych. Na przykład plik Web.config, który umożliwia zarządzanie rolami zobacz <xref:System.Web.Security.Roles>.  
  
 [!code-aspx-csharp[System.Web.Security.SqlRoleProvider#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/CS/deleterolecs.aspx#2)]
 [!code-aspx-vb[System.Web.Security.SqlRoleProvider#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/VB/deleterolevb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="roleName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="roleName" /> jest pustym ciągiem.</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">
          <paramref name="roleName" /> zawiera co najmniej jednego członka i <paramref name="throwOnPopulatedRole" /> jest <see langword="true" />.  - lub - nie włączono zarządzania rolami.</exception>
      </Docs>
    </Member>
    <Member MemberName="Domain">
      <MemberSignature Language="C#" Value="public static string Domain { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string Domain" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.Roles.Domain" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Domain As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ Domain { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Domain : string" Usage="System.Web.Security.Roles.Domain" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość domeny pliku cookie nazw ról.</summary>
        <value>
          <see cref="P:System.Web.HttpCookie.Domain" /> Pliku cookie z nazwy roli.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.Roles.Domain%2A> Wartość właściwości jest ustawiana w konfiguracji dla aplikacji ASP.NET przy użyciu `domain` atrybut elementu konfiguracji.  
  
 Jeśli nie określono wartości w konfiguracji dla atrybutu domeny <xref:System.Web.Security.Roles.Domain%2A> zwraca `null` i domyślnie domeny pliku cookie nazw ról do zachowania <xref:System.Web.HttpCookie> <xref:System.Web.HttpCookie.Domain%2A> właściwości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Enabled">
      <MemberSignature Language="C#" Value="public static bool Enabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool Enabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.Roles.Enabled" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property Enabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool Enabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Enabled : bool with get, set" Usage="System.Web.Security.Roles.Enabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy rola zarządzanie jest włączone dla bieżącej aplikacji sieci Web.</summary>
        <value>
          <see langword="true" /> Jeśli włączono zarządzanie rolami; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie pokazano element `system.web` sekcji w pliku Web.config dla aplikacji ASP.NET. Określa, że aplikacja używa <xref:System.Web.Security.SqlRoleProvider> wystąpienie i konfiguruje `enabled` atrybutu `true`.  
  
```  
<roleManager defaultProvider="SqlProvider"   
  enabled="true"  
  cacheRolesInCookie="true"  
  cookieName=".ASPROLES"  
  cookieTimeout="30"  
  cookiePath="/"  
  cookieRequireSSL="false"  
  cookieSlidingExpiration="true"  
  cookieProtection="All" >  
  <providers>  
    <add  
      name="SqlProvider"  
      type="System.Web.Security.SqlRoleProvider"  
      connectionStringName="SqlServices"  
      applicationName="MyApplication" />  
  </providers>  
</roleManager>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindUsersInRole">
      <MemberSignature Language="C#" Value="public static string[] FindUsersInRole (string roleName, string usernameToMatch);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] FindUsersInRole(string roleName, string usernameToMatch) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.FindUsersInRole(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindUsersInRole (roleName As String, usernameToMatch As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ FindUsersInRole(System::String ^ roleName, System::String ^ usernameToMatch);" />
      <MemberSignature Language="F#" Value="static member FindUsersInRole : string * string -&gt; string[]" Usage="System.Web.Security.Roles.FindUsersInRole (roleName, usernameToMatch)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="roleName" Type="System.String" />
        <Parameter Name="usernameToMatch" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="roleName">Rola do przeszukania.</param>
        <param name="usernameToMatch">Nazwa użytkownika do wyszukania.</param>
        <summary>Pobiera listę użytkowników w określonej roli, której nazwa użytkownika zawiera nazwę określonego użytkownika do dopasowania.</summary>
        <returns>Tablica ciągów zawierająca nazwy wszystkich użytkowników, których nazwa użytkownika jest zgodna <paramref name="usernameToMatch" /> i którzy są członkami określonej roli.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.Roles.FindUsersInRole%2A> Zwraca listę użytkowników w roli, gdy nazwa użytkownika zawiera dopasowanie podane `usernameToMatch` dla skonfigurowanego `applicationName`. Na przykład jeśli `usernameToMatch` parametr ma wartość "użytkownik", a następnie użytkownicy "uzytkownik1", "uzytkownik2", "UŻYTKOWNIK3", i tak dalej są zwracane. Użytkownicy są zwracane w porządku alfabetycznym według nazwy użytkownika.  
  
 <xref:System.Web.Security.SqlRoleProvider> Wykonuje wyszukiwanie przy użyciu klauzuli LIKE przed `usernameToMatch` parametru. Żadnych symboli wieloznacznych, które są obsługiwane przez program SQL Server w jak klauzule mogą być używane w `usernameToMatch` wartość parametru.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Web.Security.Roles.FindUsersInRole%2A> metodę w celu wyświetlenia członkostwo roli oparte na danych wejściowych użytkownika. Na przykład plik Web.config, który umożliwia zarządzanie rolami zobacz <xref:System.Web.Security.Roles>.  
  
> [!IMPORTANT]
>  Ten przykład zawiera pole tekstowe, który akceptuje dane wejściowe użytkownika, który jest potencjalnym zagrożeniem dla bezpieczeństwa. Domyślnie strony sieci Web ASP.NET zweryfikować, czy dane wejściowe użytkownika nie obejmuje skrypt lub elementów HTML. Aby uzyskać więcej informacji, zobacz [Przegląd wykorzystuje skryptu](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[System.Web.Security.Roles#11](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.Roles/CS/FindUsersInRolecs.aspx#11)]
 [!code-aspx-vb[System.Web.Security.Roles#11](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.Roles/VB/FindUsersInRolevb.aspx#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="roleName" /> jest <see langword="null" /> (<see langword="Nothing" /> w języku Visual Basic).  - lub - <paramref name="usernameToMatch" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="roleName" /> to ciąg pusty lub zawiera przecinka (,).  - lub - <paramref name="usernameToMatch" /> jest pustym ciągiem.</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">Nie włączono zarządzania rolami.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAllRoles">
      <MemberSignature Language="C#" Value="public static string[] GetAllRoles ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetAllRoles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.GetAllRoles" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAllRoles () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetAllRoles();" />
      <MemberSignature Language="F#" Value="static member GetAllRoles : unit -&gt; string[]" Usage="System.Web.Security.Roles.GetAllRoles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera listę wszystkich ról dla aplikacji.</summary>
        <returns>Tablica ciągów zawierająca nazwy wszystkich ról, które są przechowywane w źródle danych dla aplikacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.Roles.GetAllRoles%2A> Wywołania metody <xref:System.Web.Security.RoleProvider.GetAllRoles%2A?displayProperty=nameWithType> metody domyślnego dostawcy roli spowoduje wyświetlenie listy wszystkich ról ze źródła danych dla aplikacji. Tylko role dla aplikacji, która została określona w <xref:System.Web.Security.Roles.ApplicationName%2A> właściwości są pobierane.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Web.Security.Roles.GetAllRoles%2A> metodę, aby uzyskać listę ról dla aplikacji i ich powiązania wyniki w <xref:System.Web.UI.WebControls.GridView?displayProperty=nameWithType> formantu. Na przykład plik Web.config, który umożliwia zarządzanie rolami zobacz <xref:System.Web.Security.Roles>.  
  
> [!IMPORTANT]
>  Ten przykład zawiera pole tekstowe, który akceptuje dane wejściowe użytkownika, który jest potencjalnym zagrożeniem dla bezpieczeństwa. Domyślnie strony sieci Web ASP.NET zweryfikować, czy dane wejściowe użytkownika nie obejmuje skrypt lub elementów HTML. Aby uzyskać więcej informacji, zobacz [Przegląd wykorzystuje skryptu](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[System.Web.Security.SqlRoleProvider#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/CS/createrolecs.aspx#1)]
 [!code-aspx-vb[System.Web.Security.SqlRoleProvider#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/VB/createrolevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.Provider.ProviderException">Nie włączono zarządzania rolami.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetRolesForUser">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera listę ról, które użytkownik.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetRolesForUser">
      <MemberSignature Language="C#" Value="public static string[] GetRolesForUser ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetRolesForUser() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.GetRolesForUser" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRolesForUser () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetRolesForUser();" />
      <MemberSignature Language="F#" Value="static member GetRolesForUser : unit -&gt; string[]" Usage="System.Web.Security.Roles.GetRolesForUser " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera listę ról, które jest aktualnie zalogowanego użytkownika.</summary>
        <returns>Tablica ciągów zawierającą nazwy wszystkich ról, które jest aktualnie zalogowanego użytkownika.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.Roles.GetRolesForUser%2A> Wywołania metody <xref:System.Web.Security.RoleProvider.GetRolesForUser%2A?displayProperty=nameWithType> metody domyślnego dostawcy roli można pobrać danych z źródła ról, które jest aktualnie zalogowanego użytkownika. Obecnie zalogowanego użytkownika jest identyfikowane przez <xref:System.Web.HttpContext.User%2A?displayProperty=nameWithType> właściwości bieżącego <xref:System.Web.HttpContext?displayProperty=nameWithType>, lub <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> środowiskach hostingu dla innych niż HTTP. Jeśli żaden użytkownik nie jest zalogowany, zostanie zgłoszony wyjątek. Tylko role dla aplikacji, która została określona w <xref:System.Web.Security.Roles.ApplicationName%2A> właściwości są pobierane.  
  
 Jeśli <xref:System.Web.Security.Roles.CacheRolesInCookie%2A> jest `true`, następnie wyniki <xref:System.Web.Security.Roles.GetRolesForUser%2A> metody mogą być zwrócone z pamięci podręcznej roli zamiast określonego dostawcy ról.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Web.Security.Roles.GetRolesForUser%2A> metodę, aby pobrać listę ról określonego użytkownika i zwrócony role, które chcesz powiązać <xref:System.Web.UI.WebControls.GridView?displayProperty=nameWithType> formantu. Na przykład plik Web.config, który umożliwia zarządzanie rolami zobacz <xref:System.Web.Security.Roles>.  
  
 [!code-aspx-csharp[System.Web.Security.Roles#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.Roles/CS/ViewRolescs.aspx#4)]
 [!code-aspx-vb[System.Web.Security.Roles#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.Roles/VB/ViewRolesvb.aspx#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Nie ma żadnego bieżącej listy zalogowanego użytkownika.</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">Nie włączono zarządzania rolami.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetRolesForUser">
      <MemberSignature Language="C#" Value="public static string[] GetRolesForUser (string username);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetRolesForUser(string username) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.GetRolesForUser(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRolesForUser (username As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetRolesForUser(System::String ^ username);" />
      <MemberSignature Language="F#" Value="static member GetRolesForUser : string -&gt; string[]" Usage="System.Web.Security.Roles.GetRolesForUser username" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="username" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="username">Użytkownik, aby powrócić do listy ról.</param>
        <summary>Pobiera listę ról, które użytkownik.</summary>
        <returns>Tablica ciągów zawierająca nazwy wszystkich ról określonego użytkownika.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.Roles.GetRolesForUser%2A> Wywołania metody <xref:System.Web.Security.RoleProvider.GetRolesForUser%2A?displayProperty=nameWithType> metody domyślnego dostawcy roli można pobrać danych z źródła role, do których należy użytkownik. Tylko role dla aplikacji, która została określona w <xref:System.Web.Security.Roles.ApplicationName%2A> właściwości są pobierane.  
  
 Jeśli `username` jest taki sam, jak bieżący użytkownik zalogowany i <xref:System.Web.Security.Roles.CacheRolesInCookie%2A> jest `true`, wyniki <xref:System.Web.Security.Roles.GetRolesForUser%2A> metody mogą być zwrócone z pamięci podręcznej roli zamiast określonego <xref:System.Web.Security.Roles.Provider%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Web.Security.Roles.GetRolesForUser%2A> metodę, aby pobrać listę ról określonego użytkownika i zwrócony role, które chcesz powiązać <xref:System.Web.UI.WebControls.GridView?displayProperty=nameWithType> formantu. Na przykład plik Web.config, który umożliwia zarządzanie rolami zobacz <xref:System.Web.Security.Roles>.  
  
 [!code-aspx-csharp[System.Web.Security.Roles#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.Roles/CS/ViewRolescs.aspx#4)]
 [!code-aspx-vb[System.Web.Security.Roles#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.Roles/VB/ViewRolesvb.aspx#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="username" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="username" /> zawiera przecinka (,).</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">Nie włączono zarządzania rolami.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetUsersInRole">
      <MemberSignature Language="C#" Value="public static string[] GetUsersInRole (string roleName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetUsersInRole(string roleName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.GetUsersInRole(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetUsersInRole (roleName As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetUsersInRole(System::String ^ roleName);" />
      <MemberSignature Language="F#" Value="static member GetUsersInRole : string -&gt; string[]" Usage="System.Web.Security.Roles.GetUsersInRole roleName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="roleName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="roleName">Rolę można uzyskać listy użytkowników.</param>
        <summary>Pobiera listę użytkowników w określonej roli.</summary>
        <returns>Tablica ciągów zawierająca nazwy wszystkich użytkowników, którzy są członkami określonej roli.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.Roles.GetUsersInRole%2A> Wywołania metody <xref:System.Web.Security.RoleProvider.GetUsersInRole%2A> metody domyślnego dostawcy roli można pobrać nazwy użytkownika, skojarzone z rolą ze źródła danych. Tylko role dla aplikacji, która została określona w <xref:System.Web.Security.Roles.ApplicationName%2A> właściwości są pobierane.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Web.Security.Roles.GetUsersInRole%2A> metody w celu uzyskania listy użytkowników w określonej roli i wiąże wyniki w <xref:System.Web.UI.WebControls.GridView> formantu. Na przykład plik Web.config, który umożliwia zarządzanie rolami zobacz <xref:System.Web.Security.Roles>.  
  
 [!code-aspx-csharp[System.Web.Security.SqlRoleProvider#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/CS/adduserstorolecs.aspx#3)]
 [!code-aspx-vb[System.Web.Security.SqlRoleProvider#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/VB/adduserstorolevb.aspx#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="roleName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="roleName" /> to ciąg pusty lub zawiera przecinka (,).</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">Nie włączono zarządzania rolami.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsUserInRole">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy użytkownik jest w określonej roli.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsUserInRole">
      <MemberSignature Language="C#" Value="public static bool IsUserInRole (string roleName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsUserInRole(string roleName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.IsUserInRole(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsUserInRole (roleName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsUserInRole(System::String ^ roleName);" />
      <MemberSignature Language="F#" Value="static member IsUserInRole : string -&gt; bool" Usage="System.Web.Security.Roles.IsUserInRole roleName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="roleName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="roleName">Nazwa roli do przeszukania.</param>
        <summary>Pobiera wartość wskazującą, czy aktualnie zalogowany użytkownik jest w określonej roli. Interfejs API jest przeznaczona tylko do zostać wywołany w kontekście wątku żądania programu ASP.NET i w takim przypadku zatwierdzonej używany jest bezpieczne wątkowo.</summary>
        <returns>
          <see langword="true" /> Jeśli aktualnie zalogowany użytkownik jest w określonej roli; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.Roles.IsUserInRole%2A> Wywołania metody <xref:System.Web.Security.RoleProvider.IsUserInRole%2A?displayProperty=nameWithType> metody domyślnego dostawcy roli do ustalenia, czy aktualnie zalogowanego użytkownika jest skojarzony z rolą ze źródła danych dla aplikacji określonego w <xref:System.Web.Security.Roles.ApplicationName%2A> właściwości. Obecnie zalogowanego użytkownika jest identyfikowane przez <xref:System.Web.HttpContext.User%2A?displayProperty=nameWithType> właściwości bieżącego <xref:System.Web.HttpContext?displayProperty=nameWithType>, lub <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> środowiskach hostingu dla innych niż HTTP. Jeśli żaden użytkownik nie jest zalogowany, zostanie zgłoszony wyjątek. Tylko role dla aplikacji, która została określona w <xref:System.Web.Security.Roles.ApplicationName%2A> właściwości są pobierane.  
  
 Jeśli <xref:System.Web.Security.Roles.CacheRolesInCookie%2A> jest `true`, następnie `roleName` może być sprawdzany względem pamięci podręcznej ról, a nie określonego dostawcy ról.  
  
   
  
## Examples  
 Poniższy przykład kodu programowo sprawdza, czy aktualnie zalogowany użytkownik jest w roli administratora, przed zezwoleniem na użytkownika wyświetlić ustawienia ról dla aplikacji. Na przykład plik Web.config, który umożliwia zarządzanie rolami zobacz <xref:System.Web.Security.Roles>.  
  
 [!code-aspx-csharp[System.Web.Security.SqlRoleProvider#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/CS/ViewRolescs.aspx#4)]
 [!code-aspx-vb[System.Web.Security.SqlRoleProvider#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/VB/ViewRolesvb.aspx#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="roleName" /> jest <see langword="null" />.  - lub - nie ma żadnego bieżącej listy zalogowanego użytkownika.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="roleName" /> to ciąg pusty lub zawiera przecinka (,).</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">Nie włączono zarządzania rolami.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsUserInRole">
      <MemberSignature Language="C#" Value="public static bool IsUserInRole (string username, string roleName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsUserInRole(string username, string roleName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.IsUserInRole(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsUserInRole (username As String, roleName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsUserInRole(System::String ^ username, System::String ^ roleName);" />
      <MemberSignature Language="F#" Value="static member IsUserInRole : string * string -&gt; bool" Usage="System.Web.Security.Roles.IsUserInRole (username, roleName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="username" Type="System.String" />
        <Parameter Name="roleName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="username">Nazwa użytkownika do wyszukania.</param>
        <param name="roleName">Nazwa roli do przeszukania.</param>
        <summary>Pobiera wartość wskazującą, czy określony użytkownik ma określoną rolę. Interfejs API jest przeznaczona tylko do zostać wywołany w kontekście wątku żądania programu ASP.NET i w takim przypadku zatwierdzonej używany jest bezpieczne wątkowo.</summary>
        <returns>
          <see langword="true" /> Jeśli określony użytkownik jest w określonej roli; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.Roles.IsUserInRole%2A> Wywołania metody <xref:System.Web.Security.RoleProvider.IsUserInRole%2A> metody domyślnego dostawcy roli do ustalenia, czy nazwa użytkownika jest skojarzony z rolą ze źródła danych dla aplikacji określonego w <xref:System.Web.Security.Roles.ApplicationName%2A> właściwości.  
  
 Jeśli `username` jest taki sam, jak bieżący użytkownik zalogowany i <xref:System.Web.Security.Roles.CacheRolesInCookie%2A> wartość właściwości jest `true`, `roleName` może być sprawdzany względem roli pamięci podręcznej, zamiast określonego <xref:System.Web.Security.Roles.Provider%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu programowo sprawdza, czy użytkownik jest w roli administratora przed zezwoleniem na użytkownika wyświetlić ustawienia ról dla aplikacji. Na przykład plik Web.config, który umożliwia zarządzanie rolami zobacz <xref:System.Web.Security.Roles>.  
  
 [!code-aspx-csharp[System.Web.Security.SqlRoleProvider#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/CS/ViewRolescs.aspx#4)]
 [!code-aspx-vb[System.Web.Security.SqlRoleProvider#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/VB/ViewRolesvb.aspx#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="roleName" /> jest <see langword="null" />.  - lub - <paramref name="username" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="roleName" /> to ciąg pusty lub zawiera przecinka (,).  - lub - <paramref name="username" /> zawiera przecinka (,).</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">Nie włączono zarządzania rolami.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxCachedResults">
      <MemberSignature Language="C#" Value="public static int MaxCachedResults { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 MaxCachedResults" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.Roles.MaxCachedResults" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MaxCachedResults As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int MaxCachedResults { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MaxCachedResults : int" Usage="System.Web.Security.Roles.MaxCachedResults" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera maksymalną liczbę nazw ról do buforowania dla użytkownika.</summary>
        <value>Maksymalna liczba nazw ról do buforowania dla użytkownika. Wartość domyślna to 25.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.Roles.MaxCachedResults%2A> Właściwość jest ustawiona przy użyciu `maxCachedResults` atrybutu konfiguracji. Wartość `maxCachedResults` atrybutu konfiguracji musi mieć ustawioną wartość całkowitą większą niż zero.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano element `system.web` sekcji w pliku Web.config dla aplikacji ASP.NET. Określa, że aplikacja używa <xref:System.Web.Security.SqlRoleProvider> wystąpienie i konfiguruje `maxCachedResults` atrybutu do 10.  
  
```  
<roleManager  
  enabled="true"  
  cacheRolesInCookie="true"  
  cookieName=".ASPROLES"  
  cookieTimeout="30"  
  cookiePath="/"  
  cookieRequireSSL="false"  
  cookieSlidingExpiration="true"  
  cookieProtection="All"   
  maxCachedResults="10" />  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Provider">
      <MemberSignature Language="C#" Value="public static System.Web.Security.RoleProvider Provider { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Web.Security.RoleProvider Provider" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.Roles.Provider" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Provider As RoleProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Web::Security::RoleProvider ^ Provider { System::Web::Security::RoleProvider ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Provider : System.Web.Security.RoleProvider" Usage="System.Web.Security.Roles.Provider" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Security.RoleProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera domyślny dostawca ról dla aplikacji.</summary>
        <value>Domyślny dostawca ról dla aplikacji, która jest ujawniona jako klasa, która dziedziczy <see cref="T:System.Web.Security.RoleProvider" /> klasy abstrakcyjnej.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.Roles.Provider%2A> Właściwość umożliwia bezpośrednim odwołaniem domyślnego dostawcy roli aplikacji. To jest najczęściej używany do dostęp do niestandardowych elementów członkowskich dostawcy ról, które nie są częścią <xref:System.Web.Security.RoleProvider> klasy abstrakcyjnej.  
  
 Na przykład <xref:System.Web.Security.WindowsTokenRoleProvider> klasa zawiera przeciążenia <xref:System.Web.Security.WindowsTokenRoleProvider.IsUserInRole%2A> metodę, która umożliwia określenie, czy użytkownik jest w typowych ról systemu Windows za pomocą <xref:System.Security.Principal.WindowsBuiltInRole> wartości wyliczenia. Odwołanie do <xref:System.Web.Security.WindowsTokenRoleProvider> klasy dla aplikacji można uzyskać za pomocą <xref:System.Web.Security.Roles.Provider%2A> właściwości i mogą być rzutowane jako <xref:System.Web.Security.WindowsTokenRoleProvider> na <xref:System.Web.Security.WindowsTokenRoleProvider.IsUserInRole%2A> przeciążenia.  
  
 Jeśli wielu dostawców roli są skonfigurowane dla aplikacji, możesz uzyskać dostęp przy użyciu dostawców innej roli <xref:System.Web.Security.Roles.Providers%2A> kolekcji.  
  
   
  
## Examples  
 Poniższy przykład kodu rzutuje domyślnego dostawcy roli jako <xref:System.Web.Security.WindowsTokenRoleProvider> i sprawdza, czy aktualnie zalogowany użytkownik jest w roli administratora przed zezwoleniem na użytkownika wyświetlić ustawienia ról dla aplikacji. Na przykład plik Web.config, który umożliwia zarządzanie rolami zobacz <xref:System.Web.Security.WindowsTokenRoleProvider>.  
  
 [!code-aspx-csharp[System.Web.Security.WindowsTokenRoleProvider#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.WindowsTokenRoleProvider/CS/ViewRoles2cs.aspx#2)]
 [!code-aspx-vb[System.Web.Security.WindowsTokenRoleProvider#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.WindowsTokenRoleProvider/VB/ViewRoles2vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.Provider.ProviderException">Nie włączono zarządzania rolami.</exception>
      </Docs>
    </Member>
    <Member MemberName="Providers">
      <MemberSignature Language="C#" Value="public static System.Web.Security.RoleProviderCollection Providers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Web.Security.RoleProviderCollection Providers" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.Roles.Providers" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Providers As RoleProviderCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Web::Security::RoleProviderCollection ^ Providers { System::Web::Security::RoleProviderCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Providers : System.Web.Security.RoleProviderCollection" Usage="System.Web.Security.Roles.Providers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Security.RoleProviderCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję dostawców ról dla aplikacji ASP.NET.</summary>
        <value>A <see cref="T:System.Web.Security.RoleProviderCollection" /> zawierający dostawcy roli skonfigurowane dla aplikacji ASP.NET.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.Roles.Providers%2A> Właściwość odwołuje się do wszystkich dostawców ról włączony dla aplikacji, w tym wszystkich dostawców dodane w pliku Web.config. Można kontrolować roli dostawcy są dostępne dla aplikacji za pomocą `providers` elementu sekcji w pliku Web.config aplikacji.  
  
 W poniższym przykładzie pokazano sekcję, która usuwa wszystkie istniejące dostawców (na przykład określone w pliku Machine.config) i dodaje <xref:System.Web.Security.SqlRoleProvider> wystąpienia jako dostawcy ról dla aplikacji.  
  
```  
<configuration>  
  <connectionStrings>  
    <add name="SqlServices" connectionString="Data Source=MySqlServer;Integrated Security=SSPI;Initial Catalog=aspnetdb;" />  
  </connectionStrings>  
  
  <system.web>  
    <roleManager defaultProvider="SqlProvider"   
      enabled="true"  
      cacheRolesInCookie="true"  
      cookieName=".ASPROLES"  
      cookieTimeout="30"  
      cookiePath="/"  
      cookieRequireSSL="false"  
      cookieSlidingExpiration="true"  
      cookieProtection="Encrypted">  
  
      <providers>  
        <clear/>  
        <add  
          name="SqlProvider"  
          type="System.Web.Security.SqlRoleProvider"  
          connectionStringName="SqlServices"  
          applicationName="MyApplication" />  
         </providers>  
  
    </roleManager>  
  </system.web>  
</configuration>  
```  
  
 Możesz uzyskać jednoznacznie odwołanie do dostawcy z <xref:System.Web.Security.Roles.Providers%2A> kolekcji indeksowania według nazwy dostawcy ról i rzutowania go jako żądanego typu.  
  
 Możesz uzyskać odwołania do domyślnego dostawcę dla aplikacji przy użyciu <xref:System.Web.Security.Roles.Provider%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla listę włączonych dla aplikacji i ich odpowiednich typów dostawców.  
  
 [!code-aspx-csharp[System.Web.Security.Roles#7](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.Roles/CS/Providerscs.aspx#7)]
 [!code-aspx-vb[System.Web.Security.Roles#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.Roles/VB/Providersvb.aspx#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.Provider.ProviderException">Nie włączono zarządzania rolami.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveUserFromRole">
      <MemberSignature Language="C#" Value="public static void RemoveUserFromRole (string username, string roleName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveUserFromRole(string username, string roleName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.RemoveUserFromRole(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveUserFromRole (username As String, roleName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveUserFromRole(System::String ^ username, System::String ^ roleName);" />
      <MemberSignature Language="F#" Value="static member RemoveUserFromRole : string * string -&gt; unit" Usage="System.Web.Security.Roles.RemoveUserFromRole (username, roleName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="username" Type="System.String" />
        <Parameter Name="roleName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="username">Użytkownik do usunięcia z określoną rolę.</param>
        <param name="roleName">Rola do usunięcia z określonego użytkownika.</param>
        <summary>Usuwa określonego użytkownika z określoną rolę.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.Roles.RemoveUserFromRole%2A> Metoda wywołuje domyślnego dostawcy roli można usunąć określonego użytkownika z określoną rolę w źródle danych.  
  
   
  
## Examples  
 Poniższy przykład kodu usuwa użytkownika z roli. Na przykład plik Web.config, który umożliwia zarządzanie rolami zobacz <xref:System.Web.Security.Roles>.  
  
 [!code-aspx-csharp[System.Web.Security.SqlRoleProvider#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/CS/adduserstorolecs.aspx#3)]
 [!code-aspx-vb[System.Web.Security.SqlRoleProvider#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/VB/adduserstorolevb.aspx#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="roleName" /> jest <see langword="null" />.  - lub - <paramref name="username" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="roleName" /> to ciąg pusty lub zawiera przecinka (,) <paramref name="username" /> to ciąg pusty lub zawiera przecinka (,).</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">Nie włączono zarządzania rolami.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveUserFromRoles">
      <MemberSignature Language="C#" Value="public static void RemoveUserFromRoles (string username, string[] roleNames);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveUserFromRoles(string username, string[] roleNames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.RemoveUserFromRoles(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveUserFromRoles (username As String, roleNames As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveUserFromRoles(System::String ^ username, cli::array &lt;System::String ^&gt; ^ roleNames);" />
      <MemberSignature Language="F#" Value="static member RemoveUserFromRoles : string * string[] -&gt; unit" Usage="System.Web.Security.Roles.RemoveUserFromRoles (username, roleNames)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="username" Type="System.String" />
        <Parameter Name="roleNames" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="username">Użytkownik do usunięcia z określonych ról.</param>
        <param name="roleNames">Tablica ciągów nazw ról do usunięcia z określonego użytkownika.</param>
        <summary>Usuwa określonego użytkownika z określonych ról.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.Roles.RemoveUserFromRoles%2A> Metoda wywołuje domyślnego dostawcy roli do usunięcia określonego użytkownika z określonych ról w źródle danych.  
  
 Jeśli aplikacja jest skonfigurowana do używania <xref:System.Web.Security.SqlRoleProvider> klasy aktualizacje bazy danych, które są wykonywane podczas wywołania <xref:System.Web.Security.Roles.RemoveUserFromRoles%2A> metody zostały wprowadzone w obrębie transakcji. Jeśli wystąpi błąd, takie jak nazwa użytkownika, który nie znajduje się w określonej roli, transakcja zostanie wycofana i są wykonywane żadne aktualizacje.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Web.Security.Roles.RemoveUserFromRoles%2A> metodę, aby usunąć użytkownika z co najmniej jedną rolę. Na przykład plik Web.config, który umożliwia zarządzanie rolami zobacz <xref:System.Web.Security.Roles>.  
  
 [!code-aspx-csharp[System.Web.Security.Roles#10](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.Roles/CS/RemoveUserFromRolescs.aspx#10)]
 [!code-aspx-vb[System.Web.Security.Roles#10](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.Roles/VB/RemoveUserFromRolesvb.aspx#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Jedną z ról w <paramref name="roleNames" /> jest <see langword="null" />.  - lub - <paramref name="username" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Jedną z ról w <paramref name="roleNames" /> to ciąg pusty lub zawiera przecinka (,).  - lub - <paramref name="username" /> to ciąg pusty lub zawiera przecinka (,).  - lub - <paramref name="roleNames" /> zawiera zduplikowany element.</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">Nie włączono zarządzania rolami.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveUsersFromRole">
      <MemberSignature Language="C#" Value="public static void RemoveUsersFromRole (string[] usernames, string roleName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveUsersFromRole(string[] usernames, string roleName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.RemoveUsersFromRole(System.String[],System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveUsersFromRole (usernames As String(), roleName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveUsersFromRole(cli::array &lt;System::String ^&gt; ^ usernames, System::String ^ roleName);" />
      <MemberSignature Language="F#" Value="static member RemoveUsersFromRole : string[] * string -&gt; unit" Usage="System.Web.Security.Roles.RemoveUsersFromRole (usernames, roleName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="usernames" Type="System.String[]" />
        <Parameter Name="roleName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="usernames">Tablica ciągów nazw użytkowników do usunięcia z określonych ról.</param>
        <param name="roleName">Nazwa roli do usunięcia z określonych użytkowników.</param>
        <summary>Usuwa określonych użytkowników z określonej roli.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.Roles.RemoveUsersFromRole%2A> Metoda wywołuje domyślnego dostawcy roli, aby usunąć określonych użytkowników z określonej roli w źródle danych.  
  
 Jeśli aplikacja używa <xref:System.Web.Security.SqlRoleProvider> klasy aktualizacje bazy danych, które są wykonywane podczas wywołania <xref:System.Web.Security.SqlRoleProvider.RemoveUsersFromRoles%2A> metody zostały wprowadzone w obrębie transakcji. Jeśli wystąpi błąd, takie jak nazwa użytkownika, który nie znajduje się w określonej roli, transakcja zostanie wycofana i są wykonywane żadne aktualizacje.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Web.Security.Roles.RemoveUsersFromRole%2A> metodę, aby usunąć jednego lub więcej użytkowników z roli. Na przykład plik Web.config, który umożliwia zarządzanie rolami zobacz <xref:System.Web.Security.Roles>.  
  
 [!code-aspx-csharp[System.Web.Security.Roles#9](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.Roles/CS/RemoveUsersFromRolecs.aspx#9)]
 [!code-aspx-vb[System.Web.Security.Roles#9](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.Roles/VB/RemoveUsersFromRolevb.aspx#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="roleName" /> jest <see langword="null" />.  - lub - jednego użytkownika, nazwy w <paramref name="usernames" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="roleName" /> to ciąg pusty lub zawiera przecinka (,).  - lub - jednego użytkownika, nazwy w <paramref name="usernames" /> to ciąg pusty lub zawiera przecinka (,).  - lub - <paramref name="usernames" /> zawiera zduplikowany element.</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">Nie włączono zarządzania rolami.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveUsersFromRoles">
      <MemberSignature Language="C#" Value="public static void RemoveUsersFromRoles (string[] usernames, string[] roleNames);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveUsersFromRoles(string[] usernames, string[] roleNames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.RemoveUsersFromRoles(System.String[],System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveUsersFromRoles (usernames As String(), roleNames As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveUsersFromRoles(cli::array &lt;System::String ^&gt; ^ usernames, cli::array &lt;System::String ^&gt; ^ roleNames);" />
      <MemberSignature Language="F#" Value="static member RemoveUsersFromRoles : string[] * string[] -&gt; unit" Usage="System.Web.Security.Roles.RemoveUsersFromRoles (usernames, roleNames)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="usernames" Type="System.String[]" />
        <Parameter Name="roleNames" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="usernames">Tablica ciągów nazw użytkowników do usunięcia z określonych ról.</param>
        <param name="roleNames">Tablica ciągów nazw ról do usunięcia z określonych użytkowników.</param>
        <summary>Usuwa określone nazwy użytkownika z określonych ról.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.Roles.RemoveUsersFromRoles%2A> Metoda wywołuje domyślnego dostawcy roli, aby usunąć określonych użytkowników z określonych ról w źródle danych.  
  
 Jeśli aplikacja używa <xref:System.Web.Security.SqlRoleProvider> klasy aktualizacje bazy danych, które są wykonywane podczas wywołania <xref:System.Web.Security.SqlRoleProvider.RemoveUsersFromRoles%2A> metody zostały wprowadzone w obrębie transakcji. Jeśli wystąpi błąd, takie jak nazwa użytkownika, który nie znajduje się w określonej roli, transakcja zostanie wycofana i są wykonywane żadne aktualizacje.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Web.Security.Roles.RemoveUsersFromRoles%2A> metodę, aby usunąć jednego lub więcej użytkowników z jednego lub większej liczby ról oparte na danych wejściowych użytkownika. Na przykład plik Web.config, który umożliwia zarządzanie rolami zobacz <xref:System.Web.Security.Roles>.  
  
 [!code-aspx-csharp[System.Web.Security.Roles#8](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.Roles/CS/RemoveUsersFromRolescs.aspx#8)]
 [!code-aspx-vb[System.Web.Security.Roles#8](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.Roles/VB/RemoveUsersFromRolesvb.aspx#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Jedną z ról, określona w <paramref name="roleNames" /> jest <see langword="null" />.  - lub - jeden z użytkowników określonych w <paramref name="usernames" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Jedną z ról, określona w <paramref name="roleNames" /> jest ciągiem pustym lub zawiera przecinka (,).  - lub - jeden z użytkowników określonych w <paramref name="usernames" /> to ciąg pusty lub zawiera przecinka (,).  - lub - <paramref name="roleNames" /> zawiera zduplikowany element.  - lub - <paramref name="usernames" /> zawiera zduplikowany element.</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">Nie włączono zarządzania rolami.</exception>
      </Docs>
    </Member>
    <Member MemberName="RoleExists">
      <MemberSignature Language="C#" Value="public static bool RoleExists (string roleName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool RoleExists(string roleName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.RoleExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RoleExists (roleName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool RoleExists(System::String ^ roleName);" />
      <MemberSignature Language="F#" Value="static member RoleExists : string -&gt; bool" Usage="System.Web.Security.Roles.RoleExists roleName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="roleName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="roleName">Nazwa roli do wyszukania w źródle danych.</param>
        <summary>Pobiera wartość wskazującą, czy nazwa określona rola już istnieje w źródle danych roli.</summary>
        <returns>
          <see langword="true" /> Jeśli nazwa roli już istnieje w źródle danych. w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.Roles.RoleExists%2A> Wywołania metody `RoleExists` metody domyślnego dostawcy roli, aby określić, czy nazwa roli istnieje w źródle danych aplikacji określonego w <xref:System.Web.Security.Roles.ApplicationName%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Web.Security.Roles.RoleExists%2A> metodę, aby określić, czy nazwa roli już istnieje, przed utworzeniem roli. Na przykład plik Web.config, który umożliwia zarządzanie rolami zobacz <xref:System.Web.Security.Roles>.  
  
> [!IMPORTANT]
>  Ten przykład zawiera pole tekstowe, który akceptuje dane wejściowe użytkownika, który jest potencjalnym zagrożeniem dla bezpieczeństwa. Domyślnie strony sieci Web ASP.NET zweryfikować, czy dane wejściowe użytkownika nie obejmuje skrypt lub elementów HTML. Aby uzyskać więcej informacji, zobacz [Przegląd wykorzystuje skryptu](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[System.Web.Security.SqlRoleProvider#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/CS/createrolecs.aspx#1)]
 [!code-aspx-vb[System.Web.Security.SqlRoleProvider#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/VB/createrolevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="roleName" /> jest <see langword="null" /> (<see langword="Nothing" /> w języku Visual Basic).</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="roleName" /> to ciąg pusty lub zawiera przecinka (,).</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">Nie włączono zarządzania rolami.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="ApplicationTrustEnumerator" FullName="System.Security.Policy.ApplicationTrustEnumerator">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="59ab8cb6df681b340ec518887a2d4220c23c34b8" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30570397" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class ApplicationTrustEnumerator : System.Collections.IEnumerator" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ApplicationTrustEnumerator extends System.Object implements class System.Collections.IEnumerator" />
  <TypeSignature Language="DocId" Value="T:System.Security.Policy.ApplicationTrustEnumerator" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ApplicationTrustEnumerator&#xA;Implements IEnumerator" />
  <TypeSignature Language="C++ CLI" Value="public ref class ApplicationTrustEnumerator sealed : System::Collections::IEnumerator" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Security.Permissions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerator</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje moduł wyliczający dla <see cref="T:System.Security.Policy.ApplicationTrust" /> obiekty w <see cref="T:System.Security.Policy.ApplicationTrustCollection" /> kolekcji.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Moduły wyliczające Zezwalaj tylko na odczytywanie danych w kolekcji. Wyliczenia nie można zmodyfikować kolekcji źródłowej.  
  
 Początkowo moduł wyliczający jest umieszczony przed pierwszym elementem w kolekcji. <xref:System.Security.Policy.ApplicationTrustEnumerator.Reset%2A> — Metoda powoduje również moduł wyliczający do tej pozycji. At to pozycja, wywoływania <xref:System.Security.Policy.ApplicationTrustEnumerator.Current%2A> właściwości zgłasza wyjątek. W związku z tym należy wywołać <xref:System.Security.Policy.ApplicationTrustEnumerator.MoveNext%2A> metodę modułu wyliczającego pierwszy element do kolekcji przed odczytywania wartości <xref:System.Security.Policy.ApplicationTrustEnumerator.Current%2A> właściwości.  
  
 <xref:System.Security.Policy.ApplicationTrustEnumerator.Current%2A> zwraca ten sam obiekt do momentu <xref:System.Security.Policy.ApplicationTrustEnumerator.MoveNext%2A> lub <xref:System.Security.Policy.ApplicationTrustEnumerator.Reset%2A> jest wywoływana. <xref:System.Security.Policy.ApplicationTrustEnumerator.MoveNext%2A> Ustawia <xref:System.Security.Policy.ApplicationTrustEnumerator.Current%2A> do następnego elementu.  
  
 Po zakończeniu kolekcji jest moduł wyliczający jest rozmieszczanych za ostatnim elementem w kolekcji i wywoływania <xref:System.Security.Policy.ApplicationTrustEnumerator.MoveNext%2A> zwraca `false`. Jeśli przez ostatnie wywołanie <xref:System.Security.Policy.ApplicationTrustEnumerator.MoveNext%2A> zwrócił `false`, wywoływania <xref:System.Security.Policy.ApplicationTrustEnumerator.Current%2A> zgłasza wyjątek. Aby zresetować <xref:System.Security.Policy.ApplicationTrustEnumerator.Current%2A> do pierwszego elementu kolekcji, należy wywołać <xref:System.Security.Policy.ApplicationTrustEnumerator.Reset%2A> następuje wywołanie <xref:System.Security.Policy.ApplicationTrustEnumerator.MoveNext%2A>.  
  
 Moduł wyliczający zachowuje ważność tak długo, jak długo kolekcja pozostaje niezmieniona. Jeśli zmiany zostały wprowadzone do kolekcji, takie jak dodawanie, modyfikowanie lub usuwanie elementów, moduł wyliczający jest bezpowrotnie unieważniona, a następne wywołanie <xref:System.Security.Policy.ApplicationTrustEnumerator.MoveNext%2A> lub <xref:System.Security.Policy.ApplicationTrustEnumerator.Reset%2A> zgłasza <xref:System.InvalidOperationException> wyjątku. Jeśli kolekcja jest zmodyfikowany między wywoływaniem <xref:System.Security.Policy.ApplicationTrustEnumerator.MoveNext%2A> i <xref:System.Security.Policy.ApplicationTrustEnumerator.Current%2A>, <xref:System.Security.Policy.ApplicationTrustEnumerator.Current%2A> zwraca element, do którego jest obecnie ustawiona, nawet wtedy, gdy moduł wyliczający jest już unieważnione.  
  
 Moduł wyliczający nie ma wyłącznego dostępu do kolekcji, w związku z tym wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość. Nawet gdy kolekcja jest synchronizowana, inne wątki nadal mogą ją modyfikować. Powoduje to zgłaszanie wyjątku przez moduł wyliczający. Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania albo rejestrować wyjątki wynikłe ze zmian wprowadzanych przez inne wątków.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public System.Security.Policy.ApplicationTrust Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.ApplicationTrust Current" />
      <MemberSignature Language="DocId" Value="P:System.Security.Policy.ApplicationTrustEnumerator.Current" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Current As ApplicationTrust" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Policy::ApplicationTrust ^ Current { System::Security::Policy::ApplicationTrust ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.ApplicationTrust</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera bieżący <see cref="T:System.Security.Policy.ApplicationTrust" /> obiektu w <see cref="T:System.Security.Policy.ApplicationTrustCollection" /> kolekcji.</summary>
        <value>Bieżący <see cref="T:System.Security.Policy.ApplicationTrust" /> w <see cref="T:System.Security.Policy.ApplicationTrustCollection" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po utworzeniu modułu wyliczającego nie wskazuje on do obiektu, więc <xref:System.Security.Policy.ApplicationTrustEnumerator.Current%2A> właściwość nie jest prawidłowy i zgłosi wyjątek, jeśli jest on dostępny. Najpierw musisz wywołać <xref:System.Security.Policy.ApplicationTrustEnumerator.MoveNext%2A> metodę, aby umieść kursor na pierwszy obiekt w kolekcji.  
  
 Wiele wywołań <xref:System.Security.Policy.ApplicationTrustEnumerator.Current%2A> nie pośredniczące wywołania <xref:System.Security.Policy.ApplicationTrustEnumerator.MoveNext%2A> , którą będzie zwracać taki sam <xref:System.Security.Policy.ApplicationTrust> obiektu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveNext">
      <MemberSignature Language="C#" Value="public bool MoveNext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveNext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Policy.ApplicationTrustEnumerator.MoveNext" />
      <MemberSignature Language="VB.NET" Value="Public Function MoveNext () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MoveNext();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerator.MoveNext</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Przechodzi do następnego elementu w <see cref="T:System.Security.Policy.ApplicationTrustCollection" /> kolekcji.</summary>
        <returns>
          <see langword="true" /> Jeśli moduł wyliczający został pomyślnie poprawionym do następnego elementu; <see langword="false" /> po zakończeniu zbierania moduł wyliczający.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.Policy.ApplicationTrustEnumerator.MoveNext%2A> Metoda natychmiast zwraca `false` Jeśli nie ma żadnych obiektów w kolekcji.  
  
 <xref:System.Security.Policy.ApplicationTrustEnumerator.MoveNext%2A> Zwraca `true` dopóki osiągnie koniec kolekcji. Następnie zwróci `false` dla każdego kolejne wywołania. Jednak po <xref:System.Security.Policy.ApplicationTrustEnumerator.MoveNext%2A> zwrócił `false`, podczas uzyskiwania dostępu do <xref:System.Security.Policy.ApplicationTrustEnumerator.Current%2A> właściwość spowoduje zgłoszenie wyjątku.  
  
 Po utworzeniu, moduł wyliczający jest umieszczony przed pierwszą <xref:System.Security.Policy.ApplicationTrust> obiektu w kolekcji i w pierwszym wywołaniu <xref:System.Security.Policy.ApplicationTrustEnumerator.MoveNext%2A> umieszcza modułu wyliczającego na pierwszy obiekt w kolekcji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Policy.ApplicationTrustEnumerator.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerator.Reset</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Resetuje modułu wyliczającego na początku <see cref="T:System.Security.Policy.ApplicationTrustCollection" /> kolekcji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Moduł wyliczający przenosi kierunku tylko do przodu. Ta metoda służy do powrotu do kolekcji modułu wyliczającego <xref:System.Security.Policy.ApplicationTrust> obiektów.  
  
 <xref:System.Security.Policy.ApplicationTrustEnumerator.Reset%2A> Metody umieszcza kursor na pierwszy obiekt w kolekcji. Po wywołaniu <xref:System.Security.Policy.ApplicationTrustEnumerator.Reset%2A>, nie należy wywołać <xref:System.Security.Policy.ApplicationTrustEnumerator.MoveNext%2A> metody, aby przesunąć kursor do przodu do pierwszego obiektu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerator.Current">
      <MemberSignature Language="C#" Value="object System.Collections.IEnumerator.Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IEnumerator.Current" />
      <MemberSignature Language="DocId" Value="P:System.Security.Policy.ApplicationTrustEnumerator.System#Collections#IEnumerator#Current" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Current As Object Implements IEnumerator.Current" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.IEnumerator.Current { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IEnumerator.Current</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera bieżący <see cref="T:System.Object" /> w <see cref="T:System.Security.Policy.ApplicationTrustCollection" /> kolekcji.</summary>
        <value>Bieżący <see cref="T:System.Object" /> w <see cref="T:System.Security.Policy.ApplicationTrustCollection" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie wywołuj tej metody; Użyj <xref:System.Security.Policy.ApplicationTrustEnumerator.Current%2A> właściwości zamiast tego.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
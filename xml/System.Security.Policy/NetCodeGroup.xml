<Type Name="NetCodeGroup" FullName="System.Security.Policy.NetCodeGroup">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f65082b2a1fd707f85fa4dad68b87b15bdde5783" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36424689" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class NetCodeGroup : System.Security.Policy.CodeGroup" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit NetCodeGroup extends System.Security.Policy.CodeGroup" />
  <TypeSignature Language="DocId" Value="T:System.Security.Policy.NetCodeGroup" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class NetCodeGroup&#xA;Inherits CodeGroup" />
  <TypeSignature Language="C++ CLI" Value="public ref class NetCodeGroup sealed : System::Security::Policy::CodeGroup" />
  <TypeSignature Language="F#" Value="type NetCodeGroup = class&#xA;    inherit CodeGroup" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Security.Permissions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.Policy.CodeGroup</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Przyznaje uprawnienia do lokacji, z którego został pobrany zestawu w sieci Web. Klasa ta nie może być dziedziczona.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Grupy kodów są blokami konstrukcyjnymi zasad zabezpieczeń dostępu kodu. Każdy poziom zasad składa się z głównej grupy kodów, który może mieć co najmniej jedną grupę kod podrzędny. Każda grupa kodów podrzędnych może mieć własną podrzędnych grup kodu; Rozszerza to zachowanie na dowolną liczbę poziomów tworzące drzewa. Każda grupa kodów zawiera warunek członkostwa, który określa, czy danego zestawu nie należy do grupy, na podstawie dowodów dla tego zestawu. Tylko grupy kodu, których warunki członkostwa odpowiadają danego zestawu, wraz z ich grup kod podrzędny zastosować zasady zabezpieczeń dostępu kodu.  
  
 <xref:System.Security.Policy.NetCodeGroup> ma tej samej semantyki scalania, co <xref:System.Security.Policy.UnionCodeGroup>; wchodzi w skład złożenie <xref:System.Security.Policy.PolicyStatement> obiektów podrzędnych wszystkie pasujące grup kodów i <xref:System.Security.Policy.PolicyStatement> generuje wejściowego <xref:System.Security.Policy.Url> dowód. Jednak <xref:System.Security.Policy.NetCodeGroup> zwraca uprawnienie zawierający dynamicznie obliczeniowego <xref:System.Net.WebPermission> czy przyznaje nawiązać połączenie dostępu do lokacji, z którego jest on uruchamiany; <xref:System.Security.Policy.UnionCodeGroup> po prostu zwraca zestaw uprawnień statycznych.  
  
 Gdy <xref:System.Security.Policy.NetCodeGroup> jest tworzony, zawiera domyślne reguły dostępu połączenia pokazano w poniższej tabeli.  
  
|Schemat identyfikatora URI|Reguła|  
|----------------|----------|  
|— plik|Nie dostępu do połączenia z serwerem źródłowym jest dozwolone.|  
|http|HTTP i HTTPS dostęp jest dozwolony, przy użyciu portu pochodzenia.|  
|Protokół HTTPS|Dostęp HTTPS jest dozwolone przy użyciu portu pochodzenia.|  
  
 Można kontrolować schemat i port, którego kod dozwolone jest używanie podczas łączenia z powrotem do witryny pochodzenia przez przekazanie <xref:System.Security.Policy.CodeConnectAccess> obiektu z odpowiednią <xref:System.Security.Policy.CodeConnectAccess.Scheme%2A> i <xref:System.Security.Policy.CodeConnectAccess.Port%2A> wartości właściwości do <xref:System.Security.Policy.NetCodeGroup.AddConnectAccess%2A> metody. Można utworzyć reguły dostępu połączenia, która ma zastosowanie, gdy schemat źródła nie jest obecny w dowody lub nie jest rozpoznawany przez określenie <xref:System.Security.Policy.NetCodeGroup.AbsentOriginScheme> ("") jako schemat. Można również utworzyć połączenie regułę dostępu, która ma zastosowanie, gdy istnieje żadna reguła dostępu połączenia ze schematem zgodne, określając <xref:System.Security.Policy.NetCodeGroup.AnyOtherOriginScheme> ("*") jako schemat.  
  
> [!NOTE]
>  Jeśli kod nie przedstawi schemat identyfikatora URI jako dowód, jest dozwolony dostęp przy użyciu dowolnego schematu do witryny pochodzenia.  
  
   
  
## Examples  
 W poniższym przykładzie kodu pokazano tworzenie <xref:System.Security.Policy.NetCodeGroup> i dodawanie <xref:System.Security.Policy.CodeConnectAccess> obiekty kod pobrany przy użyciu protokołu HTTP.  
  
 [!code-cpp[NclCodeGroup#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclCodeGroup/cpp/sample.cpp#3)]
 [!code-csharp[NclCodeGroup#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclCodeGroup/CS/sample.cs#3)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NetCodeGroup (System.Security.Policy.IMembershipCondition membershipCondition);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Security.Policy.IMembershipCondition membershipCondition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Policy.NetCodeGroup.#ctor(System.Security.Policy.IMembershipCondition)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (membershipCondition As IMembershipCondition)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NetCodeGroup(System::Security::Policy::IMembershipCondition ^ membershipCondition);" />
      <MemberSignature Language="F#" Value="new System.Security.Policy.NetCodeGroup : System.Security.Policy.IMembershipCondition -&gt; System.Security.Policy.NetCodeGroup" Usage="new System.Security.Policy.NetCodeGroup membershipCondition" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="membershipCondition" Type="System.Security.Policy.IMembershipCondition" />
      </Parameters>
      <Docs>
        <param name="membershipCondition">Warunek członkostwa, który testuje dowody, aby określić, czy ta grupa kod ma zastosowanie zasad zabezpieczenia dostępu kodu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Security.Policy.NetCodeGroup" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Security.Policy.NetCodeGroup> jest tworzony, zawiera domyślne reguły dostępu połączenia pokazano w poniższej tabeli.  
  
|Schemat|Reguła|  
|------------|----------|  
|— plik|Nie dostępu do połączenia z serwerem źródłowym jest dozwolone.|  
|http|HTTP i HTTPS dostęp jest dozwolony, przy użyciu portu pochodzenia.|  
|Protokół HTTPS|Dostęp HTTPS jest dozwolone przy użyciu portu pochodzenia.|  
  
   
  
## Examples  
 W poniższym przykładzie kodu pokazano tworzenie <xref:System.Security.Policy.NetCodeGroup> i dodawanie <xref:System.Security.Policy.CodeConnectAccess> obiekty kod pobrany przy użyciu protokołu HTTP.  
  
 [!code-cpp[NclCodeGroup#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclCodeGroup/cpp/sample.cpp#3)]
 [!code-csharp[NclCodeGroup#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclCodeGroup/CS/sample.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="membershipCondition" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Typ <paramref name="membershipCondition" /> parametr jest nieprawidłowy.</exception>
      </Docs>
    </Member>
    <Member MemberName="AbsentOriginScheme">
      <MemberSignature Language="C#" Value="public static readonly string AbsentOriginScheme;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string AbsentOriginScheme" />
      <MemberSignature Language="DocId" Value="F:System.Security.Policy.NetCodeGroup.AbsentOriginScheme" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AbsentOriginScheme As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ AbsentOriginScheme;" />
      <MemberSignature Language="F#" Value=" staticval mutable AbsentOriginScheme : string" Usage="System.Security.Policy.NetCodeGroup.AbsentOriginScheme" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zawiera wartość używana do określania połączenia dostępu do kodu za pomocą schematu źródła nieznany lub nie została rozpoznana.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas wywoływania metody <xref:System.Security.Policy.NetCodeGroup.AddConnectAccess%2A> metody, określ schemat i skojarzone <xref:System.Security.Policy.CodeConnectAccess> obiektu. Wszelkie <xref:System.Security.Policy.CodeConnectAccess> obiektów, które dodajesz do <xref:System.Security.Policy.NetCodeGroup> przy użyciu <xref:System.Security.Policy.NetCodeGroup.AbsentOriginScheme> jako punkt początkowy schematu są stosowane, gdy schemat pochodzenia kodu nie znajduje się w jego dowód lub schemat nie został rozpoznany przez <xref:System.Security.Policy.NetCodeGroup> obiektu.  
  
 Aby określić <xref:System.Security.Policy.CodeConnectAccess> obiektów do użycia podczas nie pasuje do żadnego schematy zawartych w zestawie schematów pochodzenia dodany do bieżącego schematu źródła kodu <xref:System.Security.Policy.NetCodeGroup> obiektów, użyj <xref:System.Security.Policy.NetCodeGroup.AnyOtherOriginScheme> wartość.  
  
 Wartość <xref:System.Security.Policy.NetCodeGroup.AbsentOriginScheme> pole to ciąg pusty ("").  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddConnectAccess">
      <MemberSignature Language="C#" Value="public void AddConnectAccess (string originScheme, System.Security.Policy.CodeConnectAccess connectAccess);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddConnectAccess(string originScheme, class System.Security.Policy.CodeConnectAccess connectAccess) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Policy.NetCodeGroup.AddConnectAccess(System.String,System.Security.Policy.CodeConnectAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddConnectAccess (originScheme As String, connectAccess As CodeConnectAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddConnectAccess(System::String ^ originScheme, System::Security::Policy::CodeConnectAccess ^ connectAccess);" />
      <MemberSignature Language="F#" Value="member this.AddConnectAccess : string * System.Security.Policy.CodeConnectAccess -&gt; unit" Usage="netCodeGroup.AddConnectAccess (originScheme, connectAccess)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="originScheme" Type="System.String" />
        <Parameter Name="connectAccess" Type="System.Security.Policy.CodeConnectAccess" />
      </Parameters>
      <Docs>
        <param name="originScheme">A <see cref="T:System.String" /> zawierający schemat do dopasowywania schemat kodu.</param>
        <param name="connectAccess">A <see cref="T:System.Security.Policy.CodeConnectAccess" /> , który określa kod schemat i port służy do nawiązywania ponownego połączenia jej z serwera źródłowego.</param>
        <summary>Dodaje określonego połączenia dostępu do bieżącej grupy kodu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można dodawać wiele <xref:System.Security.Policy.CodeConnectAccess> obiektów dla tego samego `origin scheme`. Jeśli `origin scheme` już ma jeden lub kilka skojarzonych <xref:System.Security.Policy.CodeConnectAccess> obiektów, określając `null` dla `connectAccess` nie ma wpływu. Jeśli schemat pochodzenia nie skojarzono <xref:System.Security.Policy.CodeConnectAccess> obiektów, określając `null` dla `connectAccess` uniemożliwia kodu za pomocą schematu źródła odpowiadający `originScheme` dostęp do swojego serwera pochodzenia.  
  
   
  
## Examples  
 W poniższym przykładzie kodu pokazano tworzenie i dodawanie <xref:System.Security.Policy.CodeConnectAccess> obiekty do <xref:System.Security.Policy.NetCodeGroup>.  
  
 [!code-cpp[NclCodeGroup#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclCodeGroup/cpp/sample.cpp#3)]
 [!code-csharp[NclCodeGroup#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclCodeGroup/CS/sample.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="originScheme" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="originScheme" /> zawiera znaki, które nie są dozwolone w systemach.  - lub - <paramref name="originScheme" />  =  <see cref="F:System.Security.Policy.NetCodeGroup.AbsentOriginScheme" /> i <paramref name="connectAccess" /> Określa <see cref="F:System.Security.Policy.CodeConnectAccess.OriginScheme" /> jego schemat.</exception>
      </Docs>
    </Member>
    <Member MemberName="AnyOtherOriginScheme">
      <MemberSignature Language="C#" Value="public static readonly string AnyOtherOriginScheme;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string AnyOtherOriginScheme" />
      <MemberSignature Language="DocId" Value="F:System.Security.Policy.NetCodeGroup.AnyOtherOriginScheme" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AnyOtherOriginScheme As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ AnyOtherOriginScheme;" />
      <MemberSignature Language="F#" Value=" staticval mutable AnyOtherOriginScheme : string" Usage="System.Security.Policy.NetCodeGroup.AnyOtherOriginScheme" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zawiera wartość można określić inny schemat nieokreślony pochodzenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas wywoływania metody <xref:System.Security.Policy.NetCodeGroup.AddConnectAccess%2A> metody, określ schemat i skojarzone <xref:System.Security.Policy.CodeConnectAccess> obiektu. Można użyć wartości <xref:System.Security.Policy.NetCodeGroup.AnyOtherOriginScheme> Aby określić <xref:System.Security.Policy.CodeConnectAccess> obiektów, które mają być używane dla dowolnego schematu, który nie jest jawnie zawarty w zestawie schematów pochodzenia dodany do bieżącego <xref:System.Security.Policy.NetCodeGroup> obiektu.  
  
 <xref:System.Security.Policy.CodeConnectAccess> Obiekty określone za pomocą <xref:System.Security.Policy.NetCodeGroup.AnyOtherOriginScheme> pole są używane, jeśli nie pasuje do żadnego schematy zawartych w zestawie schematów pochodzenia dodany do bieżącego schematu źródła kodu <xref:System.Security.Policy.NetCodeGroup> obiektu.  
  
 Aby określić <xref:System.Security.Policy.CodeConnectAccess> obiekty do zastosowania, gdy schemat pochodzenia kodu nie jest dostępna w jego dowód lub nie został rozpoznany, używają <xref:System.Security.Policy.NetCodeGroup.AbsentOriginScheme> wartość.  
  
 Wartość <xref:System.Security.Policy.NetCodeGroup.AnyOtherOriginScheme> pole jest "*".  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AttributeString">
      <MemberSignature Language="C#" Value="public override string AttributeString { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AttributeString" />
      <MemberSignature Language="DocId" Value="P:System.Security.Policy.NetCodeGroup.AttributeString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AttributeString As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ AttributeString { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AttributeString : string" Usage="System.Security.Policy.NetCodeGroup.AttributeString" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera atrybuty deklaracji zasad grupy kodu reprezentację ciągu.</summary>
        <value>Zawsze <see langword="null" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public override System.Security.Policy.CodeGroup Copy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.Policy.CodeGroup Copy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Policy.NetCodeGroup.Copy" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Copy () As CodeGroup" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::Policy::CodeGroup ^ Copy();" />
      <MemberSignature Language="F#" Value="override this.Copy : unit -&gt; System.Security.Policy.CodeGroup" Usage="netCodeGroup.Copy " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.CodeGroup</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy kopię głębokie bieżącą grupę kodu.</summary>
        <returns>Odpowiednik kopia bieżącej grupy kodu, w tym warunki członkostwa i grup kodów podrzędnych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda tworzy kopię głębokie grupy kodu, co oznacza kopie wszystkich obiektów, które zawiera grupy kodu są również.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateXml">
      <MemberSignature Language="C#" Value="protected override void CreateXml (System.Security.SecurityElement element, System.Security.Policy.PolicyLevel level);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void CreateXml(class System.Security.SecurityElement element, class System.Security.Policy.PolicyLevel level) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Policy.NetCodeGroup.CreateXml(System.Security.SecurityElement,System.Security.Policy.PolicyLevel)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub CreateXml (element As SecurityElement, level As PolicyLevel)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void CreateXml(System::Security::SecurityElement ^ element, System::Security::Policy::PolicyLevel ^ level);" />
      <MemberSignature Language="F#" Value="override this.CreateXml : System.Security.SecurityElement * System.Security.Policy.PolicyLevel -&gt; unit" Usage="netCodeGroup.CreateXml (element, level)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Security.SecurityElement" />
        <Parameter Name="level" Type="System.Security.Policy.PolicyLevel" />
      </Parameters>
      <Docs>
        <param name="element">To be added.</param>
        <param name="level">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Policy.NetCodeGroup.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="netCodeGroup.Equals o" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">
          <see cref="T:System.Security.Policy.NetCodeGroup" /> Obiekt do porównania z bieżącą grupę kodu.</param>
        <summary>Określa, czy określony kod grupy jest odpowiednikiem bieżącą grupę kodu.</summary>
        <returns>
          <see langword="true" /> Jeśli grupa określony kod jest odpowiednikiem bieżącej grupy kodu; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Następujące dane są używane do określania równości dwóch <xref:System.Security.Policy.NetCodeGroup> obiektów:  
  
-   <xref:System.Security.Policy.CodeGroup.Name%2A> i <xref:System.Security.Policy.CodeGroup.Description%2A> właściwości.  
  
-   <xref:System.Security.Policy.CodeGroup.MembershipCondition%2A> Właściwości.  
  
-   Zestaw schematów pochodzenia oraz skojarzonych z nimi <xref:System.Security.Policy.CodeConnectAccess> obiektów.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConnectAccessRules">
      <MemberSignature Language="C#" Value="public System.Collections.DictionaryEntry[] GetConnectAccessRules ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Collections.DictionaryEntry[] GetConnectAccessRules() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Policy.NetCodeGroup.GetConnectAccessRules" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConnectAccessRules () As DictionaryEntry()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Collections::DictionaryEntry&gt; ^ GetConnectAccessRules();" />
      <MemberSignature Language="F#" Value="member this.GetConnectAccessRules : unit -&gt; System.Collections.DictionaryEntry[]" Usage="netCodeGroup.GetConnectAccessRules " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.DictionaryEntry[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera informacje o połączeniu dostępu dla bieżącej grupy kodu.</summary>
        <returns>A <see cref="T:System.Collections.DictionaryEntry" /> tablica zawierająca informacje o połączeniu dostępu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku każdego wpisu słownika <xref:System.Collections.DictionaryEntry.Key%2A> wartość właściwości jest schemat źródła i <xref:System.Collections.DictionaryEntry.Value%2A> wartość właściwości jest tablica skojarzone <xref:System.Security.Policy.CodeConnectAccess> obiektów. Jeśli istnieją nie skojarzone <xref:System.Security.Policy.CodeConnectAccess> obiektów, <xref:System.Collections.DictionaryEntry.Value%2A?displayProperty=nameWithType> zwraca pustą tablicę.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, wyświetlanie połączenia reguł dostępu dla <xref:System.Security.Policy.NetCodeGroup> obiektu.  
  
 [!code-cpp[NclCodeGroup#8](~/samples/snippets/cpp/VS_Snippets_Remoting/NclCodeGroup/cpp/sample.cpp#8)]
 [!code-csharp[NclCodeGroup#8](~/samples/snippets/csharp/VS_Snippets_Remoting/NclCodeGroup/CS/sample.cs#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Policy.NetCodeGroup.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="netCodeGroup.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera wartość skrótu bieżącego grupy kodów.</summary>
        <returns>Wartość skrótu bieżącego grupy kodów.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Security.Policy.CodeGroup.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="MergeLogic">
      <MemberSignature Language="C#" Value="public override string MergeLogic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MergeLogic" />
      <MemberSignature Language="DocId" Value="P:System.Security.Policy.NetCodeGroup.MergeLogic" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MergeLogic As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ MergeLogic { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MergeLogic : string" Usage="System.Security.Policy.NetCodeGroup.MergeLogic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera logikę do użycia na potrzeby scalania grup.</summary>
        <value>Ciąg "Union".</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ParseXml">
      <MemberSignature Language="C#" Value="protected override void ParseXml (System.Security.SecurityElement e, System.Security.Policy.PolicyLevel level);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void ParseXml(class System.Security.SecurityElement e, class System.Security.Policy.PolicyLevel level) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Policy.NetCodeGroup.ParseXml(System.Security.SecurityElement,System.Security.Policy.PolicyLevel)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub ParseXml (e As SecurityElement, level As PolicyLevel)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void ParseXml(System::Security::SecurityElement ^ e, System::Security::Policy::PolicyLevel ^ level);" />
      <MemberSignature Language="F#" Value="override this.ParseXml : System.Security.SecurityElement * System.Security.Policy.PolicyLevel -&gt; unit" Usage="netCodeGroup.ParseXml (e, level)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Security.SecurityElement" />
        <Parameter Name="level" Type="System.Security.Policy.PolicyLevel" />
      </Parameters>
      <Docs>
        <param name="e">To be added.</param>
        <param name="level">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PermissionSetName">
      <MemberSignature Language="C#" Value="public override string PermissionSetName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PermissionSetName" />
      <MemberSignature Language="DocId" Value="P:System.Security.Policy.NetCodeGroup.PermissionSetName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property PermissionSetName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ PermissionSetName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PermissionSetName : string" Usage="System.Security.Policy.NetCodeGroup.PermissionSetName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę <see cref="T:System.Security.NamedPermissionSet" /> dla grupy kodu.</summary>
        <value>Zawsze ciąg "Tej samej witryny sieci Web".</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetConnectAccess">
      <MemberSignature Language="C#" Value="public void ResetConnectAccess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetConnectAccess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Policy.NetCodeGroup.ResetConnectAccess" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetConnectAccess ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetConnectAccess();" />
      <MemberSignature Language="F#" Value="member this.ResetConnectAccess : unit -&gt; unit" Usage="netCodeGroup.ResetConnectAccess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa wszystkie informacje o połączeniu dostępu dla bieżącej grupy kodu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, aby usunąć dostarczane przez system domyślnych reguł dostępu do połączenia.  
  
 W poniższej tabeli przedstawiono reguły domyślne.  
  
|Schemat|Reguła|  
|------------|----------|  
|— plik|Nie dostępu do połączenia z serwerem źródłowym jest dozwolone.|  
|http|HTTP i HTTPS dostęp jest dozwolony, przy użyciu portu pochodzenia.|  
|Protokół HTTPS|Dostęp HTTPS jest dozwolone przy użyciu portu pochodzenia.|  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje wywołanie tej metody można usunąć reguły połączeń domyślny kod dostępu.  
  
 [!code-cpp[NclCodeGroup#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclCodeGroup/cpp/sample.cpp#3)]
 [!code-csharp[NclCodeGroup#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclCodeGroup/CS/sample.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Resolve">
      <MemberSignature Language="C#" Value="public override System.Security.Policy.PolicyStatement Resolve (System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.Policy.PolicyStatement Resolve(class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Policy.NetCodeGroup.Resolve(System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::Policy::PolicyStatement ^ Resolve(System::Security::Policy::Evidence ^ evidence);" />
      <MemberSignature Language="F#" Value="override this.Resolve : System.Security.Policy.Evidence -&gt; System.Security.Policy.PolicyStatement" Usage="netCodeGroup.Resolve evidence" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.PolicyStatement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="evidence">
          <see cref="T:System.Security.Policy.Evidence" /> Dla zestawu.</param>
        <summary>Usuwa zasady dla grupy kodu i jego elementy podrzędne dla zestawem świadectwo.</summary>
        <returns>A <see cref="T:System.Security.Policy.PolicyStatement" /> składający się z uprawnienia przyznane przez Grupa kodów z opcjonalne atrybuty lub <see langword="null" /> Jeśli grupa kodów nie dotyczy (warunek członkostwa jest niezgodny dowód określony).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podana dowody dla zestawu do załadowania, ta metoda ocenia grupa kodów sprawdzając pierwszy warunek członkostwa przed dowód określony. Jeśli istnieje dopasowanie, ta metoda zwraca instrukcję zasady dla grupy kodu, w tym ocenę grup kodów podrzędnych.  
  
 Operacja ta metoda jest następujący:  
  
 Jeśli warunek członkostwa jest niezgodny z określonym dowód, zwróć `null`; w przeciwnym razie zestaw uprawnień wartość zwracaną (P) równa deklaracji zasad grupy kodu i kontynuować. Dla każdej grupy kod podrzędny rozwiązać Grupa kodów z tej samej dowód; Jeśli wynik nie jest `null`, return — instrukcja tej zasady. Jeśli żadna grupa kod podrzędny dopasowane, zwróć P (element nadrzędny deklaracji zasad).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="evidence" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.Security.Policy.PolicyException">Więcej niż jednej grupy kodu (w tym kod grupy nadrzędnej oraz wszystkich podrzędnych grup kodu) jest oznaczony jako <see cref="F:System.Security.Policy.PolicyStatementAttribute.Exclusive" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveMatchingCodeGroups">
      <MemberSignature Language="C#" Value="public override System.Security.Policy.CodeGroup ResolveMatchingCodeGroups (System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.Policy.CodeGroup ResolveMatchingCodeGroups(class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Policy.NetCodeGroup.ResolveMatchingCodeGroups(System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::Policy::CodeGroup ^ ResolveMatchingCodeGroups(System::Security::Policy::Evidence ^ evidence);" />
      <MemberSignature Language="F#" Value="override this.ResolveMatchingCodeGroups : System.Security.Policy.Evidence -&gt; System.Security.Policy.CodeGroup" Usage="netCodeGroup.ResolveMatchingCodeGroups evidence" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.CodeGroup</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="evidence">Dowody dla zestawu.</param>
        <summary>Dopasowanie grup kodu jest rozpoznawana.</summary>
        <returns>Pełny zestaw grup kodów, zgodnych dowody.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podana dowody dla zestawu do załadowania, ta metoda ocenia grupa kodów sprawdzając pierwszy warunek członkostwa przed dowód określony. Jeśli istnieje dopasowanie, ta metoda zwraca głównej grupy kodów. Grupa kodów, która jest zwracana może zawierać podrzędnych grup kodów, które z kolei może być również podrzędnych grup kodów, dlatego zwracana wartość odzwierciedla pełny zestaw grup kodów, zgodnych przez podany.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="evidence" /> Parametr jest <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="X509Certificate2Collection" FullName="System.Security.Cryptography.X509Certificates.X509Certificate2Collection">
  <Metadata><Meta Name="ms.openlocfilehash" Value="b3cb0b230f8cb47fe945ecd7f1b380ba6bb8c440" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69084776" /></Metadata><TypeSignature Language="C#" Value="public class X509Certificate2Collection : System.Security.Cryptography.X509Certificates.X509CertificateCollection" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit X509Certificate2Collection extends System.Security.Cryptography.X509Certificates.X509CertificateCollection" />
  <TypeSignature Language="DocId" Value="T:System.Security.Cryptography.X509Certificates.X509Certificate2Collection" />
  <TypeSignature Language="VB.NET" Value="Public Class X509Certificate2Collection&#xA;Inherits X509CertificateCollection" />
  <TypeSignature Language="C++ CLI" Value="public ref class X509Certificate2Collection : System::Security::Cryptography::X509Certificates::X509CertificateCollection" />
  <TypeSignature Language="F#" Value="type X509Certificate2Collection = class&#xA;    inherit X509CertificateCollection" />
  <AssemblyInfo>
    <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.Cryptography.X509Certificates.X509CertificateCollection</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Reprezentuje kolekcję <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> obiektów. Klasa ta nie może być dziedziczona.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.Cryptography.X509Certificates.X509Certificate2Collection> Po otwarciu <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> magazynu wynik jest reprezentowany przez obiekt. Jeśli znasz niezarządzane konstrukcje interfejsu API kryptografii, możesz zastanowić się <xref:System.Security.Cryptography.X509Certificates.X509Certificate2Collection> , że jest to magazyn <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> pamięci z obiektami.  
  
   
  
## Examples  
 Poniższy przykład kodu otwiera osobisty magazyn certyfikatów bieżącego użytkownika, wybiera tylko prawidłowe certyfikaty, umożliwia użytkownikowi wybranie certyfikatu, a następnie zapisuje informacje o certyfikatach i łańcuchu certyfikatów w konsoli programu. Dane wyjściowe są zależne od certyfikatu wybieranego przez użytkownika.  
  
 [!code-cpp[certselect#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertSelect/CPP/certselect.cpp#1)]
 [!code-csharp[certselect#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertSelect/CS/certselect.cs#1)]
 [!code-vb[certselect#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertSelect/VB/certselect.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2Collection" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public X509Certificate2Collection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2Collection.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; X509Certificate2Collection();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2Collection" /> klasy bez żadnych <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> informacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor tworzy pusty <xref:System.Security.Cryptography.X509Certificates.X509Certificate2Collection> obiekt, który jest w przeciwieństwie do innych konstruktorów korzystających z informacji o certyfikacie lub kolekcji w celu utworzenia obiektu.  
  
   
  
## Examples  
 Poniższy przykład kodu otwiera osobisty magazyn certyfikatów bieżącego użytkownika, wybiera tylko prawidłowe certyfikaty, umożliwia użytkownikowi wybranie certyfikatu, a następnie zapisuje informacje o certyfikatach i łańcuchu certyfikatów w konsoli programu. Dane wyjściowe są zależne od certyfikatu wybieranego przez użytkownika.  
  
 [!code-cpp[certselect#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertSelect/CPP/certselect.cpp#1)]
 [!code-csharp[certselect#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertSelect/CS/certselect.cs#1)]
 [!code-vb[certselect#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertSelect/VB/certselect.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public X509Certificate2Collection (System.Security.Cryptography.X509Certificates.X509Certificate2 certificate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Security.Cryptography.X509Certificates.X509Certificate2 certificate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2Collection.#ctor(System.Security.Cryptography.X509Certificates.X509Certificate2)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (certificate As X509Certificate2)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; X509Certificate2Collection(System::Security::Cryptography::X509Certificates::X509Certificate2 ^ certificate);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.X509Certificates.X509Certificate2Collection : System.Security.Cryptography.X509Certificates.X509Certificate2 -&gt; System.Security.Cryptography.X509Certificates.X509Certificate2Collection" Usage="new System.Security.Cryptography.X509Certificates.X509Certificate2Collection certificate" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="certificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate2" />
      </Parameters>
      <Docs>
        <param name="certificate"><see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> Obiekt, z którego ma zostać rozpoczęta kolekcja.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2Collection" /> klasy <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> przy użyciu obiektu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public X509Certificate2Collection (System.Security.Cryptography.X509Certificates.X509Certificate2[] certificates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Security.Cryptography.X509Certificates.X509Certificate2[] certificates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2Collection.#ctor(System.Security.Cryptography.X509Certificates.X509Certificate2[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (certificates As X509Certificate2())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; X509Certificate2Collection(cli::array &lt;System::Security::Cryptography::X509Certificates::X509Certificate2 ^&gt; ^ certificates);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.X509Certificates.X509Certificate2Collection : System.Security.Cryptography.X509Certificates.X509Certificate2[] -&gt; System.Security.Cryptography.X509Certificates.X509Certificate2Collection" Usage="new System.Security.Cryptography.X509Certificates.X509Certificate2Collection certificates" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="certificates" Type="System.Security.Cryptography.X509Certificates.X509Certificate2[]" />
      </Parameters>
      <Docs>
        <param name="certificates">Tablica <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> obiektów.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2Collection" /> klasy przy użyciu <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> tablicy obiektów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu otwiera osobisty magazyn certyfikatów bieżącego użytkownika, wybiera tylko prawidłowe certyfikaty, umożliwia użytkownikowi wybranie certyfikatu, a następnie zapisuje informacje o certyfikatach i łańcuchu certyfikatów w konsoli programu. Dane wyjściowe są zależne od wybranego certyfikatu.  
  
 [!code-cpp[certselect#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertSelect/CPP/certselect.cpp#1)]
 [!code-csharp[certselect#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertSelect/CS/certselect.cs#1)]
 [!code-vb[certselect#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertSelect/VB/certselect.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public X509Certificate2Collection (System.Security.Cryptography.X509Certificates.X509Certificate2Collection certificates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Security.Cryptography.X509Certificates.X509Certificate2Collection certificates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2Collection.#ctor(System.Security.Cryptography.X509Certificates.X509Certificate2Collection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (certificates As X509Certificate2Collection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; X509Certificate2Collection(System::Security::Cryptography::X509Certificates::X509Certificate2Collection ^ certificates);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.X509Certificates.X509Certificate2Collection : System.Security.Cryptography.X509Certificates.X509Certificate2Collection -&gt; System.Security.Cryptography.X509Certificates.X509Certificate2Collection" Usage="new System.Security.Cryptography.X509Certificates.X509Certificate2Collection certificates" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="certificates" Type="System.Security.Cryptography.X509Certificates.X509Certificate2Collection" />
      </Parameters>
      <Docs>
        <param name="certificates"><see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2Collection" /> Obiekt.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2Collection" /> klasy przy użyciu określonej kolekcji certyfikatów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu otwiera osobisty magazyn certyfikatów bieżącego użytkownika, wybiera tylko prawidłowe certyfikaty, umożliwia użytkownikowi wybranie certyfikatu, a następnie zapisuje informacje o certyfikatach i łańcuchu certyfikatów w konsoli programu. Dane wyjściowe są zależne od certyfikatu wybieranego przez użytkownika.  
  
 [!code-cpp[certselect#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertSelect/CPP/certselect.cpp#1)]
 [!code-csharp[certselect#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertSelect/CS/certselect.cs#1)]
 [!code-vb[certselect#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertSelect/VB/certselect.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public int Add (System.Security.Cryptography.X509Certificates.X509Certificate2 certificate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Add(class System.Security.Cryptography.X509Certificates.X509Certificate2 certificate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2Collection.Add(System.Security.Cryptography.X509Certificates.X509Certificate2)" />
      <MemberSignature Language="VB.NET" Value="Public Function Add (certificate As X509Certificate2) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Add(System::Security::Cryptography::X509Certificates::X509Certificate2 ^ certificate);" />
      <MemberSignature Language="F#" Value="override this.Add : System.Security.Cryptography.X509Certificates.X509Certificate2 -&gt; int" Usage="x509Certificate2Collection.Add certificate" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="certificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate2" />
      </Parameters>
      <Docs>
        <param name="certificate">Certyfikat X. 509 reprezentowany jako <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> obiekt.</param>
        <summary>Dodaje obiekt na końcu <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2Collection" />.</summary>
        <returns>Indeks, w <paramref name="certificate" /> którym został dodany. <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2Collection" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda dodaje <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> obiekt do kolekcji i zwraca lokalizację indeksu certyfikatu.  
  
   
  
## Examples  
 Poniższy przykład kodu otwiera magazyn certyfikatów X. 509, dodaje i usuwa certyfikaty, a następnie zamyka magazyn. Przyjęto założenie, że masz trzy certyfikaty do dodania do i usunięcia z magazynu lokalnego.  
  
 [!code-cpp[x509store2#1](~/samples/snippets/cpp/VS_Snippets_CLR/x509store2/CPP/x509store2.cpp#1)]
 [!code-csharp[x509store2#1](~/samples/snippets/csharp/VS_Snippets_CLR/x509store2/CS/x509store2.cs#1)]
 [!code-vb[x509store2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/x509store2/vb/x509store2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="certificate" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddRange">
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dodaje wiele <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> obiektów <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2Collection" /> do obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (System.Security.Cryptography.X509Certificates.X509Certificate2[] certificates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(class System.Security.Cryptography.X509Certificates.X509Certificate2[] certificates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2Collection.AddRange(System.Security.Cryptography.X509Certificates.X509Certificate2[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (certificates As X509Certificate2())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(cli::array &lt;System::Security::Cryptography::X509Certificates::X509Certificate2 ^&gt; ^ certificates);" />
      <MemberSignature Language="F#" Value="override this.AddRange : System.Security.Cryptography.X509Certificates.X509Certificate2[] -&gt; unit" Usage="x509Certificate2Collection.AddRange certificates" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Method isn't transactional (like documented)")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="certificates" Type="System.Security.Cryptography.X509Certificates.X509Certificate2[]" />
      </Parameters>
      <Docs>
        <param name="certificates">Tablica <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> obiektów.</param>
        <summary>Dodaje wiele <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> obiektów w tablicy <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2Collection" /> do obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, jeśli masz tablicę <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> obiektów do dodania <xref:System.Security.Cryptography.X509Certificates.X509Certificate2Collection> do obiektu. Metody <xref:System.Security.Cryptography.X509Certificates.X509Certificate2Collection.AddRange%2A> i<xref:System.Security.Cryptography.X509Certificates.X509Certificate2Collection.RemoveRange%2A> przetwarzają żądania transakcyjnie, więc jeśli pojedyncze dodanie lub usunięcie zakończy się niepowodzeniem, cała operacja zostanie przerwana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="certificates" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (System.Security.Cryptography.X509Certificates.X509Certificate2Collection certificates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(class System.Security.Cryptography.X509Certificates.X509Certificate2Collection certificates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2Collection.AddRange(System.Security.Cryptography.X509Certificates.X509Certificate2Collection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (certificates As X509Certificate2Collection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::Security::Cryptography::X509Certificates::X509Certificate2Collection ^ certificates);" />
      <MemberSignature Language="F#" Value="override this.AddRange : System.Security.Cryptography.X509Certificates.X509Certificate2Collection -&gt; unit" Usage="x509Certificate2Collection.AddRange certificates" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Method isn't transactional (like documented)")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="certificates" Type="System.Security.Cryptography.X509Certificates.X509Certificate2Collection" />
      </Parameters>
      <Docs>
        <param name="certificates"><see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2Collection" /> Obiekt.</param>
        <summary>Dodaje wiele <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> obiektów <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2Collection" /> w obiekcie do innego <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2Collection" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, jeśli masz certyfikaty w <xref:System.Security.Cryptography.X509Certificates.X509Certificate2Collection> obiekcie, który chcesz dodać do innego <xref:System.Security.Cryptography.X509Certificates.X509Certificate2Collection> obiektu. Metody <xref:System.Security.Cryptography.X509Certificates.X509Certificate2Collection.AddRange%2A> i<xref:System.Security.Cryptography.X509Certificates.X509Certificate2Collection.RemoveRange%2A> przetwarzają żądania transakcyjnie, więc jeśli pojedyncze dodanie lub usunięcie zakończy się niepowodzeniem, cała operacja zostanie przerwana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="certificates" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (System.Security.Cryptography.X509Certificates.X509Certificate2 certificate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(class System.Security.Cryptography.X509Certificates.X509Certificate2 certificate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2Collection.Contains(System.Security.Cryptography.X509Certificates.X509Certificate2)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (certificate As X509Certificate2) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::Security::Cryptography::X509Certificates::X509Certificate2 ^ certificate);" />
      <MemberSignature Language="F#" Value="override this.Contains : System.Security.Cryptography.X509Certificates.X509Certificate2 -&gt; bool" Usage="x509Certificate2Collection.Contains certificate" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="certificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate2" />
      </Parameters>
      <Docs>
        <param name="certificate">Obiekt <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> , który ma zostać zlokalizowany w kolekcji.</param>
        <summary>Określa, <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2Collection" /> czy obiekt zawiera określony certyfikat.</summary>
        <returns><see langword="true" />Jeśli zawiera określony <paramref name="certificate" />; w przeciwnym razie, <see langword="false" />. <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2Collection" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przeprowadza wyszukiwanie liniowe; w związku z tym średni czas wykonywania jest proporcjonalny <xref:System.Collections.CollectionBase.Count%2A> do właściwości. Oznacza to, że ta metoda jest operacją`n`o (), `n` gdzie <xref:System.Collections.CollectionBase.Count%2A>is.  
  
 Ta metoda określa równość przez wywołanie <xref:System.Object.Equals%2A?displayProperty=nameWithType> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="certificate" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Export">
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Eksportuje informacje o certyfikacie X. 509 na podstawie typu zawartości do tablicy bajtów.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Export">
      <MemberSignature Language="C#" Value="public byte[] Export (System.Security.Cryptography.X509Certificates.X509ContentType contentType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] Export(valuetype System.Security.Cryptography.X509Certificates.X509ContentType contentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2Collection.Export(System.Security.Cryptography.X509Certificates.X509ContentType)" />
      <MemberSignature Language="VB.NET" Value="Public Function Export (contentType As X509ContentType) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ Export(System::Security::Cryptography::X509Certificates::X509ContentType contentType);" />
      <MemberSignature Language="F#" Value="member this.Export : System.Security.Cryptography.X509Certificates.X509ContentType -&gt; byte[]" Usage="x509Certificate2Collection.Export contentType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("only support X509ContentType.Cert")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="contentType" Type="System.Security.Cryptography.X509Certificates.X509ContentType" />
      </Parameters>
      <Docs>
        <param name="contentType">Obsługiwany <see cref="T:System.Security.Cryptography.X509Certificates.X509ContentType" /> obiekt.</param>
        <summary>Eksportuje informacje o certyfikacie X. 509 do tablicy bajtów.</summary>
        <returns>Informacje o certyfikacie X. 509 w tablicy bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda obsługuje typy zawartości, które nie wymagają hasła.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Export">
      <MemberSignature Language="C#" Value="public byte[] Export (System.Security.Cryptography.X509Certificates.X509ContentType contentType, string password);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] Export(valuetype System.Security.Cryptography.X509Certificates.X509ContentType contentType, string password) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2Collection.Export(System.Security.Cryptography.X509Certificates.X509ContentType,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Export (contentType As X509ContentType, password As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ Export(System::Security::Cryptography::X509Certificates::X509ContentType contentType, System::String ^ password);" />
      <MemberSignature Language="F#" Value="member this.Export : System.Security.Cryptography.X509Certificates.X509ContentType * string -&gt; byte[]" Usage="x509Certificate2Collection.Export (contentType, password)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("only support X509ContentType.Cert")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="contentType" Type="System.Security.Cryptography.X509Certificates.X509ContentType" />
        <Parameter Name="password" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="contentType">Obsługiwany <see cref="T:System.Security.Cryptography.X509Certificates.X509ContentType" /> obiekt.</param>
        <param name="password">Ciąg używany do ochrony tablicy bajtów.</param>
        <summary>Eksportuje informacje o certyfikacie X. 509 do tablicy typu Byte przy użyciu hasła.</summary>
        <returns>Informacje o certyfikacie X. 509 w tablicy bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda obsługuje następujące <xref:System.Security.Cryptography.X509Certificates.X509ContentType> typy:  
  
-   <xref:System.Security.Cryptography.X509Certificates.X509ContentType.Cert>  
  
-   <xref:System.Security.Cryptography.X509Certificates.X509ContentType.SerializedCert>  
  
-   <xref:System.Security.Cryptography.X509Certificates.X509ContentType.Pfx>  
  
-   <xref:System.Security.Cryptography.X509Certificates.X509ContentType.SerializedStore>  
  
-   <xref:System.Security.Cryptography.X509Certificates.X509ContentType.Pkcs7>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Certyfikat jest nieczytelny, zawartość jest nieprawidłowa lub w przypadku certyfikatu wymagającego hasła nie można wyeksportować klucza prywatnego, ponieważ podane hasło jest nieprawidłowe.</exception>
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.X509Certificates.X509Certificate2Collection Find (System.Security.Cryptography.X509Certificates.X509FindType findType, object findValue, bool validOnly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.Cryptography.X509Certificates.X509Certificate2Collection Find(valuetype System.Security.Cryptography.X509Certificates.X509FindType findType, object findValue, bool validOnly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2Collection.Find(System.Security.Cryptography.X509Certificates.X509FindType,System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (findType As X509FindType, findValue As Object, validOnly As Boolean) As X509Certificate2Collection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::Cryptography::X509Certificates::X509Certificate2Collection ^ Find(System::Security::Cryptography::X509Certificates::X509FindType findType, System::Object ^ findValue, bool validOnly);" />
      <MemberSignature Language="F#" Value="member this.Find : System.Security.Cryptography.X509Certificates.X509FindType * obj * bool -&gt; System.Security.Cryptography.X509Certificates.X509Certificate2Collection" Usage="x509Certificate2Collection.Find (findType, findValue, validOnly)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Does not support X509FindType.FindByTemplateName, FindByApplicationPolicy and FindByCertificatePolicy")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509Certificate2Collection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="findType" Type="System.Security.Cryptography.X509Certificates.X509FindType" />
        <Parameter Name="findValue" Type="System.Object" />
        <Parameter Name="validOnly" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="findType">Jedna z <see cref="T:System.Security.Cryptography.X509Certificates.X509FindType" /> wartości.</param>
        <param name="findValue">Kryteria wyszukiwania jako obiekt.</param>
        <param name="validOnly"><see langword="true" />Aby zezwolić na zwracanie tylko prawidłowych certyfikatów z wyszukiwania; w przeciwnym razie. <see langword="false" /></param>
        <summary>Wyszukuje <see cref="T:System.Security.Cryptography.X509Certificates.X509FindType" /> <paramref name="findValue" /> Obiekt przy użyciu kryteriów wyszukiwania określonych przez Wyliczenie i obiekt. <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2Collection" /></summary>
        <returns><see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2Collection" /> Obiekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, aby <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> znaleźć obiekty w przypadku braku interakcji z użytkownikiem. Użyj metody <xref:System.Security.Cryptography.X509Certificates.X509Certificate2Collection.Find%2A> , aby zezwolić użytkownikowi na zaznaczanie <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> obiektów.  
  
 Należy zauważyć, że ta metoda może być używana w stylu kaskadowym lub zagnieżdżonym, zawężając kryteria wyszukiwania za pomocą każdego wywołania metody.  
  
   
  
## Examples  
 Poniższy przykład kodu otwiera osobisty magazyn certyfikatów bieżącego użytkownika, znajduje tylko prawidłowe certyfikaty, umożliwia użytkownikowi wybranie certyfikatu, a następnie zapisuje informacje o certyfikatach i łańcuchu certyfikatów w konsoli programu. Dane wyjściowe są zależne od certyfikatu wybieranego przez użytkownika.  
  
 [!code-cpp[certselect#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertSelect/CPP/certselect.cpp#1)]
 [!code-csharp[certselect#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertSelect/CS/certselect.cs#1)]
 [!code-vb[certselect#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertSelect/VB/certselect.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><paramref name="findType" /> jest nieprawidłowy.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.X509Certificates.X509Certificate2Enumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.Cryptography.X509Certificates.X509Certificate2Enumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2Collection.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As X509Certificate2Enumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::Cryptography::X509Certificates::X509Certificate2Enumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="override this.GetEnumerator : unit -&gt; System.Security.Cryptography.X509Certificates.X509Certificate2Enumerator" Usage="x509Certificate2Collection.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509Certificate2Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca moduł wyliczający, który może wykonywać <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2Collection" /> iterację obiektu.</summary>
        <returns>Obiekt, który może wykonywać iterację <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2Collection" /> obiektu. <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2Enumerator" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Moduły wyliczające umożliwiają dostęp tylko do odczytu do danych w kolekcji. Nie można użyć modułów wyliczających do modyfikacji źródłowej kolekcji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Import">
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Importuje certyfikat do <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2Collection" /> obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Import">
      <MemberSignature Language="C#" Value="public void Import (byte[] rawData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Import(unsigned int8[] rawData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2Collection.Import(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Import (rawData As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Import(cli::array &lt;System::Byte&gt; ^ rawData);" />
      <MemberSignature Language="F#" Value="member this.Import : byte[] -&gt; unit" Usage="x509Certificate2Collection.Import rawData" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("same limitations as X509Certificate2.Import")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawData" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawData">Tablica bajtowa zawierająca dane z certyfikatu X. 509.</param>
        <summary>Importuje certyfikat w postaci tablicy bajtów do <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2Collection" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda importuje certyfikat w postaci tablicy bajtów do <xref:System.Security.Cryptography.X509Certificates.X509Certificate2Collection> obiektu. Ta metoda obsługuje następujące <xref:System.Security.Cryptography.X509Certificates.X509ContentType> typy:  
  
-   <xref:System.Security.Cryptography.X509Certificates.X509ContentType.Cert>  
  
-   <xref:System.Security.Cryptography.X509Certificates.X509ContentType.SerializedCert>  
  
-   <xref:System.Security.Cryptography.X509Certificates.X509ContentType.Pfx>  
  
-   <xref:System.Security.Cryptography.X509Certificates.X509ContentType.SerializedStore>  
  
-   <xref:System.Security.Cryptography.X509Certificates.X509ContentType.Pkcs7>  
  
-   <xref:System.Security.Cryptography.X509Certificates.X509ContentType.Authenticode>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Import">
      <MemberSignature Language="C#" Value="public void Import (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Import(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2Collection.Import(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Import (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Import(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.Import : string -&gt; unit" Usage="x509Certificate2Collection.Import fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("same limitations as X509Certificate2.Import")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nazwa pliku zawierającego informacje o certyfikacie.</param>
        <summary>Importuje plik certyfikatu do <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2Collection" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda obsługuje następujące <xref:System.Security.Cryptography.X509Certificates.X509ContentType> typy:  
  
-   <xref:System.Security.Cryptography.X509Certificates.X509ContentType.Cert>  
  
-   <xref:System.Security.Cryptography.X509Certificates.X509ContentType.SerializedCert>  
  
-   <xref:System.Security.Cryptography.X509Certificates.X509ContentType.Pfx>  
  
-   <xref:System.Security.Cryptography.X509Certificates.X509ContentType.SerializedStore>  
  
-   <xref:System.Security.Cryptography.X509Certificates.X509ContentType.Pkcs7>  
  
-   <xref:System.Security.Cryptography.X509Certificates.X509ContentType.Authenticode>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Import">
      <MemberSignature Language="C#" Value="public void Import (byte[] rawData, string password, System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Import(unsigned int8[] rawData, string password, valuetype System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2Collection.Import(System.Byte[],System.String,System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Import (rawData As Byte(), password As String, keyStorageFlags As X509KeyStorageFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Import(cli::array &lt;System::Byte&gt; ^ rawData, System::String ^ password, System::Security::Cryptography::X509Certificates::X509KeyStorageFlags keyStorageFlags);" />
      <MemberSignature Language="F#" Value="member this.Import : byte[] * string * System.Security.Cryptography.X509Certificates.X509KeyStorageFlags -&gt; unit" Usage="x509Certificate2Collection.Import (rawData, password, keyStorageFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("same limitations as X509Certificate2.Import")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawData" Type="System.Byte[]" />
        <Parameter Name="password" Type="System.String" />
        <Parameter Name="keyStorageFlags" Type="System.Security.Cryptography.X509Certificates.X509KeyStorageFlags" />
      </Parameters>
      <Docs>
        <param name="rawData">Tablica bajtowa zawierająca dane z <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> obiektu.</param>
        <param name="password">Hasło wymagane do uzyskania dostępu do informacji o certyfikacie.</param>
        <param name="keyStorageFlags">Bitowa kombinacja wartości wyliczenia, które kontrolują sposób i miejsce importowania certyfikatu.</param>
        <summary>Importuje certyfikat w postaci tablicy bajtów, która wymaga hasła dostępu do certyfikatu <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2Collection" /> do obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może być używana z obiektem binarnym PFX/PKCS12, chronionym za pomocą hasła. Kontenery kluczy skojarzone z certyfikatami w obiekcie blob PFX/PKCS12 można utworzyć, <xref:System.Security.Cryptography.X509Certificates.X509KeyStorageFlags> a wartości można użyć do kontrolowania tego procesu. Należy pamiętać, że jeśli nie utworzysz kontenera kluczy, klucz prywatny nie zostanie utrwalony.  
  
 Ta metoda importuje tablicę bajtową certyfikatu do kolekcji certyfikatów. Ta metoda obsługuje następujące <xref:System.Security.Cryptography.X509Certificates.X509ContentType> typy:  
  
-   <xref:System.Security.Cryptography.X509Certificates.X509ContentType.Cert>  
  
-   <xref:System.Security.Cryptography.X509Certificates.X509ContentType.SerializedCert>  
  
-   <xref:System.Security.Cryptography.X509Certificates.X509ContentType.Pfx>  
  
-   <xref:System.Security.Cryptography.X509Certificates.X509ContentType.SerializedStore>  
  
-   <xref:System.Security.Cryptography.X509Certificates.X509ContentType.Pkcs7>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Import">
      <MemberSignature Language="C#" Value="public void Import (string fileName, string password, System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Import(string fileName, string password, valuetype System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2Collection.Import(System.String,System.String,System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Import (fileName As String, password As String, keyStorageFlags As X509KeyStorageFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Import(System::String ^ fileName, System::String ^ password, System::Security::Cryptography::X509Certificates::X509KeyStorageFlags keyStorageFlags);" />
      <MemberSignature Language="F#" Value="member this.Import : string * string * System.Security.Cryptography.X509Certificates.X509KeyStorageFlags -&gt; unit" Usage="x509Certificate2Collection.Import (fileName, password, keyStorageFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("same limitations as X509Certificate2.Import")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="password" Type="System.String" />
        <Parameter Name="keyStorageFlags" Type="System.Security.Cryptography.X509Certificates.X509KeyStorageFlags" />
      </Parameters>
      <Docs>
        <param name="fileName">Nazwa pliku zawierającego informacje o certyfikacie.</param>
        <param name="password">Hasło wymagane do uzyskania dostępu do informacji o certyfikacie.</param>
        <param name="keyStorageFlags">Bitowa kombinacja wartości wyliczenia, które kontrolują sposób i miejsce importowania certyfikatu.</param>
        <summary>Importuje plik certyfikatu, który wymaga hasła do <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2Collection" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może być używana z plikiem PFX/PKCS12 lub innymi plikami certyfikatu, które wymagają hasła. Kontenery kluczy skojarzone z certyfikatami w pliku PFX/PKCS12 można utworzyć, <xref:System.Security.Cryptography.X509Certificates.X509KeyStorageFlags> a wartości można użyć do kontrolowania tego procesu. Należy pamiętać, że jeśli nie utworzysz kontenera kluczy, klucz prywatny nie zostanie utrwalony.  
  
 Należy pamiętać, że plik PFX/PKCS12 może zawierać więcej niż jeden certyfikat. Ta metoda importuje pierwszy certyfikat skojarzony z kluczem prywatnym lub, jeśli nie zostanie znaleziony żaden klucz prywatny, zostanie znaleziony pierwszy certyfikat.  
  
 Ta metoda obsługuje następujące <xref:System.Security.Cryptography.X509Certificates.X509ContentType> typy:  
  
-   <xref:System.Security.Cryptography.X509Certificates.X509ContentType.Cert>  
  
-   <xref:System.Security.Cryptography.X509Certificates.X509ContentType.SerializedCert>  
  
-   <xref:System.Security.Cryptography.X509Certificates.X509ContentType.Pfx>  
  
-   <xref:System.Security.Cryptography.X509Certificates.X509ContentType.SerializedStore>  
  
-   <xref:System.Security.Cryptography.X509Certificates.X509ContentType.Pkcs7>  
  
-   <xref:System.Security.Cryptography.X509Certificates.X509ContentType.Authenticode>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public void Insert (int index, System.Security.Cryptography.X509Certificates.X509Certificate2 certificate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Insert(int32 index, class System.Security.Cryptography.X509Certificates.X509Certificate2 certificate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2Collection.Insert(System.Int32,System.Security.Cryptography.X509Certificates.X509Certificate2)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Insert (index As Integer, certificate As X509Certificate2)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Insert(int index, System::Security::Cryptography::X509Certificates::X509Certificate2 ^ certificate);" />
      <MemberSignature Language="F#" Value="override this.Insert : int * System.Security.Cryptography.X509Certificates.X509Certificate2 -&gt; unit" Usage="x509Certificate2Collection.Insert (index, certificate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="certificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate2" />
      </Parameters>
      <Docs>
        <param name="index">Indeks (liczony od zera), który ma <paramref name="certificate" />zostać wstawiony.</param>
        <param name="certificate"><see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> Obiekt do wstawienia.</param>
        <summary>Wstawia obiekt do <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2Collection" /> obiektu pod określonym indeksem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.CollectionBase.Count%2A> Jeśli właściwość jest już równa pojemności listy, pojemność jest podwojona przez automatyczne ponowne przydzielanie tablicy wewnętrznej przed wstawieniem nowego elementu.  
  
 Jeśli `index` wartość jest <xref:System.Collections.CollectionBase.Count%2A>równa `certificate` , zostanie dodana na końcu kolekcji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />jest mniejsza od zera.  
  
—lub— 
 <paramref name="index" />jest większa niż <see cref="P:System.Collections.CollectionBase.Count" /> właściwość.</exception>
        <exception cref="T:System.NotSupportedException">Kolekcja jest tylko do odczytu.  
  
 —lub—  
  
 Kolekcja ma stały rozmiar.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="certificate" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.X509Certificates.X509Certificate2 this[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.X509Certificates.X509Certificate2 Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.X509Certificates.X509Certificate2Collection.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Item(index As Integer) As X509Certificate2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::X509Certificates::X509Certificate2 ^ default[int] { System::Security::Cryptography::X509Certificates::X509Certificate2 ^ get(int index); void set(int index, System::Security::Cryptography::X509Certificates::X509Certificate2 ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Item(int) : System.Security.Cryptography.X509Certificates.X509Certificate2 with get, set" Usage="System.Security.Cryptography.X509Certificates.X509Certificate2Collection.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509Certificate2</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Liczony od zera indeks elementu, który ma zostać pobrany lub skonfigurowany.</param>
        <summary>Pobieranie lub konfigurowanie elementów pod określonym indeksem.</summary>
        <value>Element pod określonym indeksem.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zapewnia możliwość dostępu do określonego elementu w kolekcji przy użyciu następującej składni: `myCollection[index]`.  
  
   
  
## Examples  
 Poniższy przykład kodu otwiera osobisty magazyn certyfikatów bieżącego użytkownika, wybiera tylko prawidłowe certyfikaty, umożliwia użytkownikowi wybranie certyfikatu, a następnie zapisuje informacje o certyfikatach i łańcuchu certyfikatów w konsoli programu. Dane wyjściowe są zależne od certyfikatu wybieranego przez użytkownika.  
  
 [!code-cpp[certselect#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertSelect/CPP/certselect.cpp#1)]
 [!code-csharp[certselect#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertSelect/CS/certselect.cs#1)]
 [!code-vb[certselect#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertSelect/VB/certselect.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />jest mniejsza od zera.  
  
—lub— 
 <paramref name="index" />jest równa lub większa od <see cref="P:System.Collections.CollectionBase.Count" /> właściwości.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="index" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public void Remove (System.Security.Cryptography.X509Certificates.X509Certificate2 certificate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Remove(class System.Security.Cryptography.X509Certificates.X509Certificate2 certificate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2Collection.Remove(System.Security.Cryptography.X509Certificates.X509Certificate2)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Remove (certificate As X509Certificate2)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Remove(System::Security::Cryptography::X509Certificates::X509Certificate2 ^ certificate);" />
      <MemberSignature Language="F#" Value="override this.Remove : System.Security.Cryptography.X509Certificates.X509Certificate2 -&gt; unit" Usage="x509Certificate2Collection.Remove certificate" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="certificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate2" />
      </Parameters>
      <Docs>
        <param name="certificate">Obiekt, który ma zostać usunięty <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2Collection" /> z obiektu. <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /></param>
        <summary>Usuwa pierwsze wystąpienie certyfikatu z <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2Collection" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda usuwa pierwsze wystąpienie certyfikatu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="certificate" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RemoveRange">
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Usuwa wiele <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> obiektów <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2Collection" /> z obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RemoveRange">
      <MemberSignature Language="C#" Value="public void RemoveRange (System.Security.Cryptography.X509Certificates.X509Certificate2[] certificates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveRange(class System.Security.Cryptography.X509Certificates.X509Certificate2[] certificates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2Collection.RemoveRange(System.Security.Cryptography.X509Certificates.X509Certificate2[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveRange (certificates As X509Certificate2())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveRange(cli::array &lt;System::Security::Cryptography::X509Certificates::X509Certificate2 ^&gt; ^ certificates);" />
      <MemberSignature Language="F#" Value="member this.RemoveRange : System.Security.Cryptography.X509Certificates.X509Certificate2[] -&gt; unit" Usage="x509Certificate2Collection.RemoveRange certificates" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Method isn't transactional (like documented)")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="certificates" Type="System.Security.Cryptography.X509Certificates.X509Certificate2[]" />
      </Parameters>
      <Docs>
        <param name="certificates">Tablica <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> obiektów.</param>
        <summary>Usuwa wiele <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> obiektów w tablicy <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2Collection" /> z obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, jeśli masz tablicę <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> obiektów do usunięcia <xref:System.Security.Cryptography.X509Certificates.X509Certificate2Collection> z obiektu. Metody <xref:System.Security.Cryptography.X509Certificates.X509Certificate2Collection.AddRange%2A> i<xref:System.Security.Cryptography.X509Certificates.X509Certificate2Collection.RemoveRange%2A> przetwarzają żądania transakcyjnie, więc jeśli pojedyncze dodanie lub usunięcie zakończy się niepowodzeniem, cała operacja zostanie przerwana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="certificates" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveRange">
      <MemberSignature Language="C#" Value="public void RemoveRange (System.Security.Cryptography.X509Certificates.X509Certificate2Collection certificates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveRange(class System.Security.Cryptography.X509Certificates.X509Certificate2Collection certificates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2Collection.RemoveRange(System.Security.Cryptography.X509Certificates.X509Certificate2Collection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveRange (certificates As X509Certificate2Collection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveRange(System::Security::Cryptography::X509Certificates::X509Certificate2Collection ^ certificates);" />
      <MemberSignature Language="F#" Value="member this.RemoveRange : System.Security.Cryptography.X509Certificates.X509Certificate2Collection -&gt; unit" Usage="x509Certificate2Collection.RemoveRange certificates" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Method isn't transactional (like documented)")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="certificates" Type="System.Security.Cryptography.X509Certificates.X509Certificate2Collection" />
      </Parameters>
      <Docs>
        <param name="certificates"><see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2Collection" /> Obiekt.</param>
        <summary>Usuwa wiele <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> obiektów <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2Collection" /> w obiekcie z innego <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2Collection" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, jeśli masz certyfikaty w <xref:System.Security.Cryptography.X509Certificates.X509Certificate2Collection> obiekcie, który chcesz usunąć z innego <xref:System.Security.Cryptography.X509Certificates.X509Certificate2Collection> obiektu. Metody <xref:System.Security.Cryptography.X509Certificates.X509Certificate2Collection.AddRange%2A> i<xref:System.Security.Cryptography.X509Certificates.X509Certificate2Collection.RemoveRange%2A> przetwarzają żądania transakcyjnie, więc jeśli pojedyncze dodanie lub usunięcie zakończy się niepowodzeniem, cała operacja zostanie przerwana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="certificates" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>

<Type Name="X509Certificate2" FullName="System.Security.Cryptography.X509Certificates.X509Certificate2">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a1828dea3b043398b7aab391aa3b060a247bd237" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36532052" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class X509Certificate2 : System.Security.Cryptography.X509Certificates.X509Certificate" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit X509Certificate2 extends System.Security.Cryptography.X509Certificates.X509Certificate" />
  <TypeSignature Language="DocId" Value="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />
  <TypeSignature Language="VB.NET" Value="Public Class X509Certificate2&#xA;Inherits X509Certificate" />
  <TypeSignature Language="C++ CLI" Value="public ref class X509Certificate2 : System::Security::Cryptography::X509Certificates::X509Certificate" />
  <TypeSignature Language="F#" Value="type X509Certificate2 = class&#xA;    inherit X509Certificate" />
  <AssemblyInfo>
    <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.Cryptography.X509Certificates.X509Certificate</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Reprezentuje certyfikat X.509.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Struktura X.509 pochodzi Międzynarodowej Organizacji Normalizacyjnej (ISO) grup roboczych. Ta struktura może być używana do reprezentowania różnych typów informacji, łącznie z atrybutami tożsamości, uprawnienia i posiadacz (uprawnienia, wiek, płeć, lokalizacji, przynależności i tak dalej). Chociaż zawierający najwięcej informacji na temat struktury, specyfikacje ISO <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> klasy jest przeznaczony do modelowania scenariusze użycia zdefiniowane w specyfikacji wystawiony przez Internet Engineering Task Force (IETF) infrastruktura kluczy publicznych, X.509 (PKIX ) grupy roboczej. Najbardziej szczegółowy specyfikacji RFC 3280, jest "[certyfikat i profil listy odwołania certyfikatów](http://go.microsoft.com/fwlink/?LinkId=45286)."  
  
> [!IMPORTANT]
>  Począwszy od [!INCLUDE[net_v46](~/includes/net-v46-md.md)], ten typ implementuje <xref:System.IDisposable> interfejsu. Po zakończeniu przy użyciu typu bezpośrednio lub pośrednio należy usunąć z niego. Do usuwania tego typu, należy wywołać jej <xref:System.IDisposable.Dispose%2A> metody w `try` / `catch` bloku. Do usunięcia ich pośrednio, użyj konstrukcji języka takiego jak `using` (w języku C#) lub `Using` (w języku Visual Basic). Aby uzyskać więcej informacji, zobacz sekcję "Przy użyciu obiektu który implementuje interfejs IDisposable" w <xref:System.IDisposable> interfejsu tematu.  
>   
>  Dla aplikacji, które odnoszą się do [!INCLUDE[net_v452](~/includes/net-v452-md.md)] i wcześniejsze wersje <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> klasa nie implementuje <xref:System.IDisposable> interfejsu i dlatego nie ma `Dispose` metody.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób użycia <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> obiektu do szyfrowania i odszyfrowywania pliku.  
  
 [!code-csharp[X509Certificate2#1](~/samples/snippets/csharp/VS_Snippets_CLR/x509certificate2/cs/program.cs#1)]
 [!code-vb[X509Certificate2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/x509certificate2/vb/program.vb#1)]  
  
 Poniższy przykład tworzy pliku wykonywalnego wiersza polecenia, która przyjmuje pliku certyfikatu jako argument i wyświetla różne właściwości certyfikatu do konsoli.  
  
 [!code-cpp[CertInfo#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertInfo/CPP/certinfo.cpp#1)]
 [!code-csharp[CertInfo#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertInfo/CS/certinfo.cs#1)]
 [!code-vb[CertInfo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertInfo/VB/certinfo.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public X509Certificate2 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; X509Certificate2();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor tworzy pustą <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> obiektu, w przeciwieństwie do innych konstruktorów dla tej klasy, które używają informacji o certyfikacie z tablicy bajtów, wskaźnika lub pliku certyfikatu.  
  
   
  
## Examples  
 Poniższy przykład kodu otwiera magazynie certyfikatów bieżącego użytkownika, wybiera tylko aktywne certyfikaty, a następnie umożliwia użytkownikowi wybranie co najmniej jednego certyfikatu. Przykład następnie zapisuje informacje o certyfikacie w konsoli.  
  
 [!code-cpp[CertSelect#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertSelect/CPP/certselect.cpp#1)]
 [!code-csharp[CertSelect#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertSelect/CS/certselect.cs#1)]
 [!code-vb[CertSelect#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertSelect/VB/certselect.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public X509Certificate2 (byte[] rawData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] rawData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.#ctor(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (rawData As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; X509Certificate2(cli::array &lt;System::Byte&gt; ^ rawData);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.X509Certificates.X509Certificate2 : byte[] -&gt; System.Security.Cryptography.X509Certificates.X509Certificate2" Usage="new System.Security.Cryptography.X509Certificates.X509Certificate2 rawData" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="rawData" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawData">Tablica bajtów zawierająca dane z certyfikatu X.509.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> przy użyciu informacji z tablicy bajtów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor tworzy nową <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> obiektu przy użyciu informacji o certyfikacie z tablicy bajtów. Tablica bajtów może być zakodowane pliku binarnego (DER) lub danych X.509 z kodowaniem Base64. Tablica bajtów można też PKCS7 (Authenticode) podpisanego pliku. certyfikat podpisujący jest używany do utworzenia obiektu.  
  
 W przypadku utworzenia <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> certyfikatu za pośrednictwem sklepu podpisany plik PKCS7 dla `rawData`, <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> jest tworzony dla certyfikatu, który podpisał magazynu, a nie dla każdego certyfikaty w magazynie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Występuje błąd z certyfikatem. Na przykład:-plik certyfikatu, który nie istnieje.  -Certyfikat jest nieprawidłowy.  — Hasło do certyfikatu jest nieprawidłowy.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public X509Certificate2 (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.#ctor(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; X509Certificate2(IntPtr handle);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.X509Certificates.X509Certificate2 : nativeint -&gt; System.Security.Cryptography.X509Certificates.X509Certificate2" Usage="new System.Security.Cryptography.X509Certificates.X509Certificate2 handle" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">Wskaźnik do kontekstu certyfikatu za pomocą kodu niezarządzanego. Struktura C nosi nazwę <see langword="PCCERT_CONTEXT" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> przy użyciu dojścia niezarządzanego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor tworzy nowy <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> kontekstu kryptograficznego interfejsu API Microsoft certyfikatu, przy użyciu dojścia `PCCERT_CONTEXT`. Należy pamiętać, że bezpośredniego obiektu wywołującego tego konstruktora musi mieć uprawnienie do kodu niezarządzanego.  
  
> [!IMPORTANT]
>  Konstruktor tworzy kopię kontekstu certyfikatu. Zakłada się, że struktura kontekstu, przekazanych do konstruktora jest nieprawidłowy; może zostać zwolniony. Można uzyskać kopię bieżącego `PCCERT_CONTEXT` struktury z <xref:System.Security.Cryptography.X509Certificates.X509Certificate.Handle%2A> właściwości, ale jest prawidłowa tylko w czasie trwania <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> obiektu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Występuje błąd z certyfikatem. Na przykład:-plik certyfikatu, który nie istnieje.  -Certyfikat jest nieprawidłowy.  — Hasło do certyfikatu jest nieprawidłowy.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać dostęp do kodu niezarządzanego. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public X509Certificate2 (System.Security.Cryptography.X509Certificates.X509Certificate certificate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Security.Cryptography.X509Certificates.X509Certificate certificate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.#ctor(System.Security.Cryptography.X509Certificates.X509Certificate)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (certificate As X509Certificate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; X509Certificate2(System::Security::Cryptography::X509Certificates::X509Certificate ^ certificate);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.X509Certificates.X509Certificate2 : System.Security.Cryptography.X509Certificates.X509Certificate -&gt; System.Security.Cryptography.X509Certificates.X509Certificate2" Usage="new System.Security.Cryptography.X509Certificates.X509Certificate2 certificate" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="certificate" Type="System.Security.Cryptography.X509Certificates.X509Certificate" />
      </Parameters>
      <Docs>
        <param name="certificate">
          <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate" /> Obiektu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> przy użyciu <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda tworzy nowe wystąpienie klasy <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> przy użyciu <xref:System.Security.Cryptography.X509Certificates.X509Certificate> obiektu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Występuje błąd z certyfikatem. Na przykład:-plik certyfikatu, który nie istnieje.  -Certyfikat jest nieprawidłowy.  — Hasło do certyfikatu jest nieprawidłowy.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać dostęp do kodu niezarządzanego. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public X509Certificate2 (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; X509Certificate2(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.X509Certificates.X509Certificate2 : string -&gt; System.Security.Cryptography.X509Certificates.X509Certificate2" Usage="new System.Security.Cryptography.X509Certificates.X509Certificate2 fileName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nazwa pliku certyfikatu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> przy użyciu nazwy pliku certyfikatu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor tworzy nową <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> przy użyciu nazwy pliku certyfikatu. Obsługuje ona kodowanie binarne (DER) lub kodowania Base64.  
  
 W przypadku utworzenia <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> certyfikatu za pośrednictwem sklepu podpisany plik PKCS7 dla `fileName`, <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> jest tworzony dla certyfikatu, który podpisał magazynu, a nie dla każdego certyfikaty w magazynie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Występuje błąd z certyfikatem. Na przykład:-plik certyfikatu, który nie istnieje.  -Certyfikat jest nieprawidłowy.  — Hasło do certyfikatu jest nieprawidłowy.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public X509Certificate2 (byte[] rawData, System.Security.SecureString password);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] rawData, class System.Security.SecureString password) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.#ctor(System.Byte[],System.Security.SecureString)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (rawData As Byte(), password As SecureString)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; X509Certificate2(cli::array &lt;System::Byte&gt; ^ rawData, System::Security::SecureString ^ password);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.X509Certificates.X509Certificate2 : byte[] * System.Security.SecureString -&gt; System.Security.Cryptography.X509Certificates.X509Certificate2" Usage="new System.Security.Cryptography.X509Certificates.X509Certificate2 (rawData, password)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="rawData" Type="System.Byte[]" />
        <Parameter Name="password" Type="System.Security.SecureString" />
      </Parameters>
      <Docs>
        <param name="rawData">Tablica bajtów, który zawiera dane z certyfikatu X.509.</param>
        <param name="password">Hasło wymagane do uzyskania dostępu do danych certyfikatu X.509.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> przy użyciu tablicy bajtów i hasła.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor jest używany z plikami PKCS12 (PFX), które zawierają klucz prywatny certyfikatu. Ten konstruktor podania prawidłowego hasła podczas wywoływania odszyfrowuje klucz prywatny i zapisze go do kontenera kluczy.  
  
> [!IMPORTANT]
>  Kodu nigdy nie silne hasło w kodzie źródłowym.  Ustalony hasła mogą być pobierane z zestawu za pomocą [Ildasm.exe (dezasembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), Edytor szesnastkowych, lub po prostu otwarcie zestawu w edytorze tekstu, takich jak Notepad.exe.  
  
 W przypadku utworzenia <xref:System.Security.Cryptography.X509Certificates.X509Certificate> certyfikatu za pośrednictwem sklepu podpisany plik PKCS7 dla `rawData`, <xref:System.Security.Cryptography.X509Certificates.X509Certificate> jest tworzony dla certyfikatu, który podpisał magazynu, a nie dla każdego certyfikaty w magazynie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Występuje błąd z certyfikatem. Na przykład:-plik certyfikatu, który nie istnieje.  -Certyfikat jest nieprawidłowy.  — Hasło do certyfikatu jest nieprawidłowy.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać dostęp do kodu niezarządzanego. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public X509Certificate2 (byte[] rawData, string password);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] rawData, string password) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.#ctor(System.Byte[],System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (rawData As Byte(), password As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; X509Certificate2(cli::array &lt;System::Byte&gt; ^ rawData, System::String ^ password);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.X509Certificates.X509Certificate2 : byte[] * string -&gt; System.Security.Cryptography.X509Certificates.X509Certificate2" Usage="new System.Security.Cryptography.X509Certificates.X509Certificate2 (rawData, password)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="rawData" Type="System.Byte[]" />
        <Parameter Name="password" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="rawData">Tablica bajtów zawierająca dane z certyfikatu X.509.</param>
        <param name="password">Hasło wymagane do uzyskania dostępu do danych certyfikatu X.509.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> przy użyciu tablicy bajtów i hasła.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor tworzy nową <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> przy użyciu tablicy bajtów i hasło, które jest wymagane do uzyskania dostępu do danych certyfikatu. Pliki PKCS12 (PFX), które zawierają klucz prywatny certyfikatu jest używany. Ten konstruktor podania prawidłowego hasła podczas wywoływania odszyfrowuje klucz prywatny i zapisze go do kontenera kluczy.  
  
> [!IMPORTANT]
>  Kodu nigdy nie silne hasło w kodzie źródłowym.  Ustalony hasła mogą być pobierane z zestawu za pomocą [Ildasm.exe (dezasembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), Edytor szesnastkowych, lub po prostu otwarcie zestawu w edytorze tekstu, takich jak Notepad.exe.  
  
 W przypadku utworzenia <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> certyfikatu za pośrednictwem sklepu podpisany plik PKCS7 dla `rawData`, <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> jest tworzony dla certyfikatu, który podpisał magazynu, a nie dla każdego certyfikaty w magazynie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Występuje błąd z certyfikatem. Na przykład:-plik certyfikatu, który nie istnieje.  -Certyfikat jest nieprawidłowy.  — Hasło do certyfikatu jest nieprawidłowy.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać dostęp do kodu niezarządzanego. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected X509Certificate2 (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; X509Certificate2(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.X509Certificates.X509Certificate2 : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Security.Cryptography.X509Certificates.X509Certificate2" Usage="new System.Security.Cryptography.X509Certificates.X509Certificate2 (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Informacje o serializacji wymaganego do deserializacji nowe <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />.</param>
        <param name="context">Informacje kontekstowe dotyczące źródła strumienia do zdeserializowania.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> przy użyciu określonego informacje o kontekście serializacji i strumienia.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać dostęp do kodu niezarządzanego. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public X509Certificate2 (string fileName, System.Security.SecureString password);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileName, class System.Security.SecureString password) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.#ctor(System.String,System.Security.SecureString)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileName As String, password As SecureString)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; X509Certificate2(System::String ^ fileName, System::Security::SecureString ^ password);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.X509Certificates.X509Certificate2 : string * System.Security.SecureString -&gt; System.Security.Cryptography.X509Certificates.X509Certificate2" Usage="new System.Security.Cryptography.X509Certificates.X509Certificate2 (fileName, password)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="password" Type="System.Security.SecureString" />
      </Parameters>
      <Docs>
        <param name="fileName">Nazwa pliku certyfikatu.</param>
        <param name="password">Hasło wymagane do uzyskania dostępu do danych certyfikatu X.509.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> przy użyciu nazwy pliku certyfikatu i hasła.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor jest używany z plikami PKCS12 (PFX), które zawierają klucz prywatny certyfikatu. Ten konstruktor podania prawidłowego hasła podczas wywoływania odszyfrowuje klucz prywatny i zapisze go do kontenera kluczy.  
  
> [!IMPORTANT]
>  Kodu nigdy nie silne hasło w kodzie źródłowym.  Ustalony hasła mogą być pobierane z zestawu za pomocą [Ildasm.exe (dezasembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), Edytor szesnastkowych, lub po prostu otwarcie zestawu w edytorze tekstu, takich jak Notepad.exe.  
  
 W przypadku utworzenia <xref:System.Security.Cryptography.X509Certificates.X509Certificate> certyfikatu za pośrednictwem sklepu podpisany plik PKCS7 dla `fileName`, <xref:System.Security.Cryptography.X509Certificates.X509Certificate> jest tworzony dla certyfikatu, który podpisał magazynu, a nie dla każdego certyfikaty w magazynie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Występuje błąd z certyfikatem. Na przykład:-plik certyfikatu, który nie istnieje.  -Certyfikat jest nieprawidłowy.  — Hasło do certyfikatu jest nieprawidłowy.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać dostęp do kodu niezarządzanego. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public X509Certificate2 (string fileName, string password);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileName, string password) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileName As String, password As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; X509Certificate2(System::String ^ fileName, System::String ^ password);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.X509Certificates.X509Certificate2 : string * string -&gt; System.Security.Cryptography.X509Certificates.X509Certificate2" Usage="new System.Security.Cryptography.X509Certificates.X509Certificate2 (fileName, password)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="password" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nazwa pliku certyfikatu.</param>
        <param name="password">Hasło wymagane do uzyskania dostępu do danych certyfikatu X.509.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> przy użyciu nazwy pliku certyfikatu i hasło używane do dostępu do certyfikatu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor tworzy nową <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> przy użyciu nazwy pliku certyfikatu i hasła wymagane do dostępu do certyfikatu. Pliki PKCS12 (PFX), które zawierają klucz prywatny certyfikatu jest używany. Ten konstruktor podania prawidłowego hasła podczas wywoływania odszyfrowuje klucz prywatny i zapisze go do kontenera kluczy.  
  
> [!IMPORTANT]
>  Kodu nigdy nie silne hasło w kodzie źródłowym.  Ustalony hasła mogą być pobierane z zestawu za pomocą [Ildasm.exe (dezasembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), Edytor szesnastkowych, lub po prostu otwarcie zestawu w edytorze tekstu, takich jak Notepad.exe.  
  
 W przypadku utworzenia <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> certyfikatu za pośrednictwem sklepu podpisany plik PKCS7 dla `fileName`, <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> jest tworzony dla certyfikatu, który podpisał magazynu, a nie dla każdego certyfikaty w magazynie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Występuje błąd z certyfikatem. Na przykład:-plik certyfikatu, który nie istnieje.  -Certyfikat jest nieprawidłowy.  — Hasło do certyfikatu jest nieprawidłowy.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać dostęp do kodu niezarządzanego. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public X509Certificate2 (byte[] rawData, System.Security.SecureString password, System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] rawData, class System.Security.SecureString password, valuetype System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.#ctor(System.Byte[],System.Security.SecureString,System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (rawData As Byte(), password As SecureString, keyStorageFlags As X509KeyStorageFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; X509Certificate2(cli::array &lt;System::Byte&gt; ^ rawData, System::Security::SecureString ^ password, System::Security::Cryptography::X509Certificates::X509KeyStorageFlags keyStorageFlags);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.X509Certificates.X509Certificate2 : byte[] * System.Security.SecureString * System.Security.Cryptography.X509Certificates.X509KeyStorageFlags -&gt; System.Security.Cryptography.X509Certificates.X509Certificate2" Usage="new System.Security.Cryptography.X509Certificates.X509Certificate2 (rawData, password, keyStorageFlags)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="rawData" Type="System.Byte[]" />
        <Parameter Name="password" Type="System.Security.SecureString" />
        <Parameter Name="keyStorageFlags" Type="System.Security.Cryptography.X509Certificates.X509KeyStorageFlags" />
      </Parameters>
      <Docs>
        <param name="rawData">Tablica bajtów, który zawiera dane z certyfikatu X.509.</param>
        <param name="password">Hasło wymagane do uzyskania dostępu do danych certyfikatu X.509.</param>
        <param name="keyStorageFlags">Bitowe połączenie wyliczenia wartości tego formantu, jak i gdzie można zaimportować certyfikatu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> przy użyciu tablicy bajtów, hasło i flagę magazynu kluczy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor jest używany z plikami PKCS12 (PFX), które zawierają klucz prywatny certyfikatu. Ten konstruktor podania prawidłowego hasła podczas wywoływania odszyfrowuje klucz prywatny i zapisuje je do firmy Microsoft kryptograficznego interfejsu API usługi dostawcy Kryptograficznych.  
  
> [!IMPORTANT]
>  Kodu nigdy nie silne hasło w kodzie źródłowym.  Ustalony hasła mogą być pobierane z zestawu za pomocą [Ildasm.exe (dezasembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), Edytor szesnastkowych, lub po prostu otwarcie zestawu w edytorze tekstu, takich jak Notepad.exe.  
  
 W przypadku utworzenia <xref:System.Security.Cryptography.X509Certificates.X509Certificate> certyfikatu za pośrednictwem sklepu podpisany plik PKCS7 dla `rawData`, <xref:System.Security.Cryptography.X509Certificates.X509Certificate> jest tworzony dla certyfikatu, który podpisał magazynu, a nie dla każdego certyfikaty w magazynie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Występuje błąd z certyfikatem. Na przykład:-plik certyfikatu, który nie istnieje.  -Certyfikat jest nieprawidłowy.  — Hasło do certyfikatu jest nieprawidłowy.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać dostęp do kodu niezarządzanego. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public X509Certificate2 (byte[] rawData, string password, System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] rawData, string password, valuetype System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.#ctor(System.Byte[],System.String,System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (rawData As Byte(), password As String, keyStorageFlags As X509KeyStorageFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; X509Certificate2(cli::array &lt;System::Byte&gt; ^ rawData, System::String ^ password, System::Security::Cryptography::X509Certificates::X509KeyStorageFlags keyStorageFlags);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.X509Certificates.X509Certificate2 : byte[] * string * System.Security.Cryptography.X509Certificates.X509KeyStorageFlags -&gt; System.Security.Cryptography.X509Certificates.X509Certificate2" Usage="new System.Security.Cryptography.X509Certificates.X509Certificate2 (rawData, password, keyStorageFlags)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="rawData" Type="System.Byte[]" />
        <Parameter Name="password" Type="System.String" />
        <Parameter Name="keyStorageFlags" Type="System.Security.Cryptography.X509Certificates.X509KeyStorageFlags" />
      </Parameters>
      <Docs>
        <param name="rawData">Tablica bajtów zawierająca dane z certyfikatu X.509.</param>
        <param name="password">Hasło wymagane do uzyskania dostępu do danych certyfikatu X.509.</param>
        <param name="keyStorageFlags">Bitowe połączenie wyliczenia wartości tego formantu, jak i gdzie można zaimportować certyfikatu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> przy użyciu tablicy bajtów, hasło i flagę magazynu kluczy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor tworzy nową <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> tablicy obiektu przy użyciu typu byte, hasło, które jest potrzebne do dostępu do danych certyfikatu i flagę magazynu kluczy. Pliki PKCS12 (PFX), które zawierają klucz prywatny certyfikatu jest używany. Ten konstruktor podania prawidłowego hasła podczas wywoływania odszyfrowuje klucz prywatny i zapisuje je do firmy Microsoft kryptograficznego interfejsu API usługi dostawcy Kryptograficznych.  
  
> [!IMPORTANT]
>  Kodu nigdy nie silne hasło w kodzie źródłowym.  Ustalony hasła mogą być pobierane z zestawu za pomocą [Ildasm.exe (dezasembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), Edytor szesnastkowych, lub po prostu otwarcie zestawu w edytorze tekstu, takich jak Notepad.exe.  
  
 W przypadku utworzenia <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> certyfikatu za pośrednictwem sklepu podpisany plik PKCS7 dla `rawData`, <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> jest tworzony dla certyfikatu, który podpisał magazynu, a nie dla każdego certyfikaty w magazynie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Występuje błąd z certyfikatem. Na przykład:-plik certyfikatu, który nie istnieje.  -Certyfikat jest nieprawidłowy.  — Hasło do certyfikatu jest nieprawidłowy.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać dostęp do kodu niezarządzanego. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public X509Certificate2 (string fileName, System.Security.SecureString password, System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileName, class System.Security.SecureString password, valuetype System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.#ctor(System.String,System.Security.SecureString,System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileName As String, password As SecureString, keyStorageFlags As X509KeyStorageFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; X509Certificate2(System::String ^ fileName, System::Security::SecureString ^ password, System::Security::Cryptography::X509Certificates::X509KeyStorageFlags keyStorageFlags);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.X509Certificates.X509Certificate2 : string * System.Security.SecureString * System.Security.Cryptography.X509Certificates.X509KeyStorageFlags -&gt; System.Security.Cryptography.X509Certificates.X509Certificate2" Usage="new System.Security.Cryptography.X509Certificates.X509Certificate2 (fileName, password, keyStorageFlags)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="password" Type="System.Security.SecureString" />
        <Parameter Name="keyStorageFlags" Type="System.Security.Cryptography.X509Certificates.X509KeyStorageFlags" />
      </Parameters>
      <Docs>
        <param name="fileName">Nazwa pliku certyfikatu.</param>
        <param name="password">Hasło wymagane do uzyskania dostępu do danych certyfikatu X.509.</param>
        <param name="keyStorageFlags">Bitowe połączenie wyliczenia wartości tego formantu, jak i gdzie można zaimportować certyfikatu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> przy użyciu nazwy pliku certyfikatu, hasło i flagę magazynu kluczy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku utworzenia <xref:System.Security.Cryptography.X509Certificates.X509Certificate> certyfikatu za pośrednictwem sklepu podpisany plik PKCS7 dla `fileName`, <xref:System.Security.Cryptography.X509Certificates.X509Certificate> jest tworzony dla certyfikatu, który podpisał magazynu, a nie dla każdego certyfikaty w magazynie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Występuje błąd z certyfikatem. Na przykład:-plik certyfikatu, który nie istnieje.  -Certyfikat jest nieprawidłowy.  — Hasło do certyfikatu jest nieprawidłowy.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać dostęp do kodu niezarządzanego. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public X509Certificate2 (string fileName, string password, System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileName, string password, valuetype System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.#ctor(System.String,System.String,System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileName As String, password As String, keyStorageFlags As X509KeyStorageFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; X509Certificate2(System::String ^ fileName, System::String ^ password, System::Security::Cryptography::X509Certificates::X509KeyStorageFlags keyStorageFlags);" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.X509Certificates.X509Certificate2 : string * string * System.Security.Cryptography.X509Certificates.X509KeyStorageFlags -&gt; System.Security.Cryptography.X509Certificates.X509Certificate2" Usage="new System.Security.Cryptography.X509Certificates.X509Certificate2 (fileName, password, keyStorageFlags)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="password" Type="System.String" />
        <Parameter Name="keyStorageFlags" Type="System.Security.Cryptography.X509Certificates.X509KeyStorageFlags" />
      </Parameters>
      <Docs>
        <param name="fileName">Nazwa pliku certyfikatu.</param>
        <param name="password">Hasło wymagane do uzyskania dostępu do danych certyfikatu X.509.</param>
        <param name="keyStorageFlags">Bitowe połączenie wyliczenia wartości tego formantu, jak i gdzie można zaimportować certyfikatu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> nazwę klasy przy użyciu pliku certyfikatu, hasło używane do dostępu do certyfikatu i flagę magazynu kluczy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor tworzy nową <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> name obiektu przy użyciu pliku certyfikatu, hasło potrzebne do dostępu do certyfikatu i flagę magazynu kluczy.  
  
> [!IMPORTANT]
>  Kodu nigdy nie silne hasło w kodzie źródłowym.  Ustalony hasła mogą być pobierane z zestawu za pomocą [Ildasm.exe (dezasembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), Edytor szesnastkowych, lub po prostu otwarcie zestawu w edytorze tekstu, takich jak Notepad.exe.  
  
 W przypadku utworzenia <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> certyfikatu za pośrednictwem sklepu podpisany plik PKCS7 dla `fileName`, <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> jest tworzony dla certyfikatu, który podpisał magazynu, a nie dla każdego certyfikaty w magazynie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Występuje błąd z certyfikatem. Na przykład:-plik certyfikatu, który nie istnieje.  -Certyfikat jest nieprawidłowy.  — Hasło do certyfikatu jest nieprawidłowy.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać dostęp do kodu niezarządzanego. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Archived">
      <MemberSignature Language="C#" Value="public bool Archived { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Archived" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.X509Certificates.X509Certificate2.Archived" />
      <MemberSignature Language="VB.NET" Value="Public Property Archived As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Archived { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Archived : bool with get, set" Usage="System.Security.Cryptography.X509Certificates.X509Certificate2.Archived" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, że certyfikat X.509 zostaną zarchiwizowane.</summary>
        <value>
          <see langword="true" /> Jeśli certyfikat jest zarchiwizowany, <see langword="false" /> Jeśli certyfikat nie zostaną zarchiwizowane.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest ustawiona tylko dla certyfikatu, który jest skojarzony z magazynem. Jeśli właściwość jest ustawiona, i dodaniu certyfikatu do magazynu certyfikatów, wartość jest trwały. Jeśli właściwość jest ustawiona na certyfikat pobrany z magazynu, wartość jest trwały natychmiast.  
  
 W magazynie X.509 zarchiwizowane certyfikaty nie są uwzględniane w zwróconym <xref:System.Security.Cryptography.X509Certificates.X509Certificate2Collection> obiektów, chyba że <xref:System.Security.Cryptography.X509Certificates.X509Certificate2.Archived%2A> właściwość jest ustawiona na `true`. Żadnej aktywności archiwizacji fizycznych występuje podczas <xref:System.Security.Cryptography.X509Certificates.X509Certificate2.Archived%2A> wartość jest ustawiona lub nie ustawiono.  
  
   
  
## Examples  
 Poniższy przykład kodu otwiera magazynie certyfikatów bieżącego użytkownika, wybiera tylko aktywne certyfikaty, a następnie umożliwia użytkownikowi wybranie co najmniej jednego certyfikatu. Przykład następnie zapisuje informacje o certyfikacie w konsoli.  
  
 [!code-cpp[CertSelect#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertSelect/CPP/certselect.cpp#1)]
 [!code-csharp[CertSelect#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertSelect/CS/certselect.cs#1)]
 [!code-vb[CertSelect#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertSelect/VB/certselect.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Certyfikat jest niemożliwe do odczytania.</exception>
      </Docs>
    </Member>
    <Member MemberName="Export">
      <MemberSignature Language="C#" Value="public override byte[] Export (System.Security.Cryptography.X509Certificates.X509ContentType contentType, string password);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] Export(valuetype System.Security.Cryptography.X509Certificates.X509ContentType contentType, string password) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.Export(System.Security.Cryptography.X509Certificates.X509ContentType,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Export (contentType As X509ContentType, password As String) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Byte&gt; ^ Export(System::Security::Cryptography::X509Certificates::X509ContentType contentType, System::String ^ password);" />
      <MemberSignature Language="F#" Value="abstract member Export : System.Security.Cryptography.X509Certificates.X509ContentType * string -&gt; byte[]&#xA;override this.Export : System.Security.Cryptography.X509Certificates.X509ContentType * string -&gt; byte[]" Usage="x509Certificate2.Export (contentType, password)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("X509ContentType.SerializedCert is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="contentType" Type="System.Security.Cryptography.X509Certificates.X509ContentType" />
        <Parameter Name="password" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="contentType">To be added.</param>
        <param name="password">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Extensions">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.X509Certificates.X509ExtensionCollection Extensions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.X509Certificates.X509ExtensionCollection Extensions" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.X509Certificates.X509Certificate2.Extensions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Extensions As X509ExtensionCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::X509Certificates::X509ExtensionCollection ^ Extensions { System::Security::Cryptography::X509Certificates::X509ExtensionCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Extensions : System.Security.Cryptography.X509Certificates.X509ExtensionCollection" Usage="System.Security.Cryptography.X509Certificates.X509Certificate2.Extensions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509ExtensionCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję <see cref="T:System.Security.Cryptography.X509Certificates.X509Extension" /> obiektów.</summary>
        <value>
          <see cref="T:System.Security.Cryptography.X509Certificates.X509ExtensionCollection" /> Obiektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rozszerzenia zdefiniowane w formacie certyfikatu X.509 v3 Zezwalaj na dodatkowe dane mają być uwzględnione w certyfikacie. Szereg rozszerzeń są definiowane przez ISO w definicji X.509 v3, a także PKIX w dokumencie RFC 3280, "[certyfikat i profil listy odwołania certyfikatów](http://go.microsoft.com/fwlink/?LinkId=45286)." Typowe rozszerzenia zawierają informacje dotyczące użycia klucza (<xref:System.Security.Cryptography.X509Certificates.X509KeyUsageExtension>), klucz identyfikatorów (<xref:System.Security.Cryptography.X509Certificates.X509SubjectKeyIdentifierExtension>), zasad, informacje o odwołaniu (rozszerzenie punkt dystrybucji listy CRL) i innych celów certyfikatu.  
  
   
  
## Examples  
 Poniższy przykład kodu otwiera magazynie certyfikatów bieżącego użytkownika, wybiera tylko aktywne certyfikaty, a następnie umożliwia użytkownikowi wybranie co najmniej jednego certyfikatu. Przykład następnie zapisuje informacje o certyfikacie w konsoli.  
  
 [!code-cpp[CertSelect#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertSelect/CPP/certselect.cpp#1)]
 [!code-csharp[CertSelect#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertSelect/CS/certselect.cs#1)]
 [!code-vb[CertSelect#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertSelect/VB/certselect.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Certyfikat jest niemożliwe do odczytania.</exception>
      </Docs>
    </Member>
    <Member MemberName="FriendlyName">
      <MemberSignature Language="C#" Value="public string FriendlyName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FriendlyName" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.X509Certificates.X509Certificate2.FriendlyName" />
      <MemberSignature Language="VB.NET" Value="Public Property FriendlyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FriendlyName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.FriendlyName : string with get, set" Usage="System.Security.Cryptography.X509Certificates.X509Certificate2.FriendlyName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia skojarzone alias dla certyfikatu.</summary>
        <value>Przyjazna nazwa certyfikatu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przyjazne nazwy są właściwościami w magazynie certyfikatów X.509, który można ustawić. Są one używane, aby umożliwić użytkownikowi kojarzenie aliasy za pomocą certyfikatów, aby można je łatwo zidentyfikować.  
  
 Jeśli nie podano przyjaznej nazwy istnieje dla certyfikatu, ciąg pusty ("") jest zwracany.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy pliku wykonywalnego wiersza polecenia, która przyjmuje pliku certyfikatu jako argument i wyświetla różne właściwości certyfikatu do konsoli.  
  
 [!code-cpp[CertInfo#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertInfo/CPP/certinfo.cpp#1)]
 [!code-csharp[CertInfo#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertInfo/CS/certinfo.cs#1)]
 [!code-vb[CertInfo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertInfo/VB/certinfo.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Certyfikat jest niemożliwe do odczytania.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCertContentType">
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wskazuje typ certyfikatu jest zawarty w tablicy bajtowej lub pliku.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCertContentType">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.X509Certificates.X509ContentType GetCertContentType (byte[] rawData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Security.Cryptography.X509Certificates.X509ContentType GetCertContentType(unsigned int8[] rawData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.GetCertContentType(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCertContentType (rawData As Byte()) As X509ContentType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Cryptography::X509Certificates::X509ContentType GetCertContentType(cli::array &lt;System::Byte&gt; ^ rawData);" />
      <MemberSignature Language="F#" Value="static member GetCertContentType : byte[] -&gt; System.Security.Cryptography.X509Certificates.X509ContentType" Usage="System.Security.Cryptography.X509Certificates.X509Certificate2.GetCertContentType rawData" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Detection limited to Cert, Pfx, Pkcs12, Pkcs7 and Unknown")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509ContentType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawData" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawData">Tablica bajtów zawierająca dane z certyfikatu X.509.</param>
        <summary>Wskazuje typ certyfikatu jest zawarty w tablicy bajtów.</summary>
        <returns>
          <see cref="T:System.Security.Cryptography.X509Certificates.X509ContentType" /> Obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia odnalezienie typu certyfikatu w pliku.  
  
   
  
## Examples  
 Poniższy przykład kodu otwiera magazynie certyfikatów bieżącego użytkownika, wybiera tylko aktywne certyfikaty, a następnie umożliwia użytkownikowi wybranie co najmniej jednego certyfikatu. Przykład następnie zapisuje informacje o certyfikacie w konsoli.  
  
 [!code-cpp[CertSelect#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertSelect/CPP/certselect.cpp#1)]
 [!code-csharp[CertSelect#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertSelect/CS/certselect.cs#1)]
 [!code-vb[CertSelect#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertSelect/VB/certselect.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="rawData" /> o zerowej długości lub <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCertContentType">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.X509Certificates.X509ContentType GetCertContentType (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Security.Cryptography.X509Certificates.X509ContentType GetCertContentType(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.GetCertContentType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCertContentType (fileName As String) As X509ContentType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Cryptography::X509Certificates::X509ContentType GetCertContentType(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="static member GetCertContentType : string -&gt; System.Security.Cryptography.X509Certificates.X509ContentType" Usage="System.Security.Cryptography.X509Certificates.X509Certificate2.GetCertContentType fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Detection limited to Cert, Pfx, Pkcs12 and Unknown")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509ContentType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nazwa pliku certyfikatu.</param>
        <summary>Wskazuje typ certyfikatu jest zawarty w pliku.</summary>
        <returns>
          <see cref="T:System.Security.Cryptography.X509Certificates.X509ContentType" /> Obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia odnalezienie typu certyfikatu w pliku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="fileName" /> jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania certyfikatu. Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Wyliczenie skojarzone: <see cref="F:System.IO.FileAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetNameInfo">
      <MemberSignature Language="C#" Value="public string GetNameInfo (System.Security.Cryptography.X509Certificates.X509NameType nameType, bool forIssuer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetNameInfo(valuetype System.Security.Cryptography.X509Certificates.X509NameType nameType, bool forIssuer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.GetNameInfo(System.Security.Cryptography.X509Certificates.X509NameType,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNameInfo (nameType As X509NameType, forIssuer As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetNameInfo(System::Security::Cryptography::X509Certificates::X509NameType nameType, bool forIssuer);" />
      <MemberSignature Language="F#" Value="member this.GetNameInfo : System.Security.Cryptography.X509Certificates.X509NameType * bool -&gt; string" Usage="x509Certificate2.GetNameInfo (nameType, forIssuer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("always return String.Empty for UpnName, DnsFromAlternativeName and UrlName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nameType" Type="System.Security.Cryptography.X509Certificates.X509NameType" />
        <Parameter Name="forIssuer" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="nameType">
          <see cref="T:System.Security.Cryptography.X509Certificates.X509NameType" /> Wartość dla podmiotu.</param>
        <param name="forIssuer">
          <see langword="true" /> Aby uwzględnić nazwę wystawcy; w przeciwnym razie <see langword="false" />.</param>
        <summary>Pobiera podmiot i Wystawca nazwy z certyfikatu.</summary>
        <returns>Nazwa certyfikatu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zawsze należy używać zamiast analizy certyfikatu, ponieważ wiele wartości nazw może znajdować się w wielu lokalizacjach. Za pomocą tej metody gwarantuje, że zwracana jest nazwa odpowiednie.  
  
   
  
## Examples  
 Poniższy przykład kodu otwiera magazynie certyfikatów bieżącego użytkownika, wybiera tylko aktywne certyfikaty, a następnie umożliwia użytkownikowi wybranie co najmniej jednego certyfikatu. Przykład następnie zapisuje informacje o certyfikacie w konsoli.  
  
 [!code-cpp[CertSelect#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertSelect/CPP/certselect.cpp#1)]
 [!code-csharp[CertSelect#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertSelect/CS/certselect.cs#1)]
 [!code-vb[CertSelect#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertSelect/VB/certselect.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasPrivateKey">
      <MemberSignature Language="C#" Value="public bool HasPrivateKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasPrivateKey" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.X509Certificates.X509Certificate2.HasPrivateKey" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasPrivateKey As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasPrivateKey { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasPrivateKey : bool" Usage="System.Security.Cryptography.X509Certificates.X509Certificate2.HasPrivateKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> obiektów zawiera klucz prywatny.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> obiekt zawiera prywatnej klucza; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Kontekst certyfikatu jest nieprawidłowy.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Import">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wypełnia <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> obiektu o podane informacje o certyfikacie.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Import">
      <MemberSignature Language="C#" Value="public override void Import (byte[] rawData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Import(unsigned int8[] rawData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.Import(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Import (rawData As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Import(cli::array &lt;System::Byte&gt; ^ rawData);" />
      <MemberSignature Language="F#" Value="abstract member Import : byte[] -&gt; unit&#xA;override this.Import : byte[] -&gt; unit" Usage="x509Certificate2.Import rawData" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawData" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawData">Tablica bajtów zawierająca dane z certyfikatu X.509.</param>
        <summary>Wypełnia <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> obiektu z danych z tablicy bajtów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może służyć do podjęcia bajtowych tablicę certyfikat X.509 i wypełnić <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> obiektu skojarzone z nim wartości.  
  
 Ponieważ ta metoda przyjmuje tablicy bajtów, może służyć tylko dla typów certyfikatów, które nie wymagają hasła, w tym certyfikat x.509 szyfrowany algorytmem Base64 lub algorytmem DER lub certyfikatu PFX/PKCS12. Należy pamiętać, że certyfikat PFX/PKCS12 może zawierać więcej niż jeden certyfikat. W takim przypadku służy pierwszy certyfikat skojarzony z kluczem prywatnym, lub jeśli zostanie znaleziony żaden klucz prywatny, pierwszy certyfikat jest używany.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">aby uzyskać pełne zaufanie dla obiektów dziedziczących. Ten element członkowski nie może być dziedziczona przez kod częściowo zaufany.</permission>
      </Docs>
    </Member>
    <Member MemberName="Import">
      <MemberSignature Language="C#" Value="public override void Import (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Import(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.Import(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Import (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Import(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="abstract member Import : string -&gt; unit&#xA;override this.Import : string -&gt; unit" Usage="x509Certificate2.Import fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nazwa certyfikatu.</param>
        <summary>Wypełnia <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> obiektu o informacje z pliku certyfikatu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa pliku certyfikatu, takie jak plik z rozszerzeniem cer, reprezentuje certyfikatu X.509, który wypełnia <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> obiektu przy użyciu certyfikatu zawiera plik.  
  
 Tej metody można użyć z kilku typów certyfikatów, tym certyfikaty x.509 szyfrowany algorytmem Base64 lub algorytmem DER, certyfikaty PFX/PKCS12 i podpisujący certyfikaty, jak Authenticode. Należy pamiętać, że certyfikat PFX/PKCS12 może zawierać więcej niż jeden certyfikat. W takim przypadku służy pierwszy certyfikat skojarzony z kluczem prywatnym, lub jeśli zostanie znaleziony żaden klucz prywatny, pierwszy certyfikat jest używany.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">aby uzyskać pełne zaufanie dla obiektów dziedziczących. Ten element członkowski nie może być dziedziczona przez kod częściowo zaufany.</permission>
      </Docs>
    </Member>
    <Member MemberName="Import">
      <MemberSignature Language="C#" Value="public override void Import (byte[] rawData, System.Security.SecureString password, System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Import(unsigned int8[] rawData, class System.Security.SecureString password, valuetype System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.Import(System.Byte[],System.Security.SecureString,System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Import (rawData As Byte(), password As SecureString, keyStorageFlags As X509KeyStorageFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Import(cli::array &lt;System::Byte&gt; ^ rawData, System::Security::SecureString ^ password, System::Security::Cryptography::X509Certificates::X509KeyStorageFlags keyStorageFlags);" />
      <MemberSignature Language="F#" Value="abstract member Import : byte[] * System.Security.SecureString * System.Security.Cryptography.X509Certificates.X509KeyStorageFlags -&gt; unit&#xA;override this.Import : byte[] * System.Security.SecureString * System.Security.Cryptography.X509Certificates.X509KeyStorageFlags -&gt; unit" Usage="x509Certificate2.Import (rawData, password, keyStorageFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("SecureString is incomplete")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawData" Type="System.Byte[]" />
        <Parameter Name="password" Type="System.Security.SecureString" />
        <Parameter Name="keyStorageFlags" Type="System.Security.Cryptography.X509Certificates.X509KeyStorageFlags" />
      </Parameters>
      <Docs>
        <param name="rawData">Tablica bajtów, który zawiera dane z certyfikatu X.509.</param>
        <param name="password">Hasło wymagane do uzyskania dostępu do danych certyfikatu X.509.</param>
        <param name="keyStorageFlags">Bitowe połączenie wyliczenia wartości tego formantu, jak i gdzie można zaimportować certyfikatu.</param>
        <summary>Wypełnia <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> przy użyciu danych z tablicy bajtów, hasło i flagę magazynu kluczy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do typów certyfikatów, takich jak certyfikaty x.509 szyfrowany algorytmem Base64 lub algorytmem DER lub certyfikatów PFX/PKCS12. Należy pamiętać, że certyfikat PFX/PKCS12 może zawierać więcej niż jeden certyfikat. W takim przypadku służy pierwszy certyfikat skojarzony z kluczem prywatnym, lub jeśli zostanie znaleziony żaden klucz prywatny, pierwszy certyfikat jest używany.  
  
> [!IMPORTANT]
>  Kodu nigdy nie silne hasło w kodzie źródłowym.  Ustalony hasła mogą być pobierane z zestawu za pomocą [Ildasm.exe (dezasembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), Edytor szesnastkowych, lub po prostu otwarcie zestawu w edytorze tekstu, takich jak Notepad.exe.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">aby uzyskać pełne zaufanie dla obiektów dziedziczących. Ten element członkowski nie może być dziedziczona przez kod częściowo zaufany.</permission>
      </Docs>
    </Member>
    <Member MemberName="Import">
      <MemberSignature Language="C#" Value="public override void Import (byte[] rawData, string password, System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Import(unsigned int8[] rawData, string password, valuetype System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.Import(System.Byte[],System.String,System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Import (rawData As Byte(), password As String, keyStorageFlags As X509KeyStorageFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Import(cli::array &lt;System::Byte&gt; ^ rawData, System::String ^ password, System::Security::Cryptography::X509Certificates::X509KeyStorageFlags keyStorageFlags);" />
      <MemberSignature Language="F#" Value="abstract member Import : byte[] * string * System.Security.Cryptography.X509Certificates.X509KeyStorageFlags -&gt; unit&#xA;override this.Import : byte[] * string * System.Security.Cryptography.X509Certificates.X509KeyStorageFlags -&gt; unit" Usage="x509Certificate2.Import (rawData, password, keyStorageFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("missing KeyStorageFlags support")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawData" Type="System.Byte[]" />
        <Parameter Name="password" Type="System.String" />
        <Parameter Name="keyStorageFlags" Type="System.Security.Cryptography.X509Certificates.X509KeyStorageFlags" />
      </Parameters>
      <Docs>
        <param name="rawData">Tablica bajtów zawierająca dane z certyfikatu X.509.</param>
        <param name="password">Hasło wymagane do uzyskania dostępu do danych certyfikatu X.509.</param>
        <param name="keyStorageFlags">Bitowe połączenie wyliczenia wartości tego formantu, jak i gdzie można zaimportować certyfikatu.</param>
        <summary>Wypełnia <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> przy użyciu danych z tablicy bajtów, hasło i flag określając sposób importowania klucza prywatnego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do wypełniania <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> przy użyciu hasła certyfikatu reprezentowany przez tablicy bajtów. <xref:System.Security.Cryptography.X509Certificates.X509KeyStorageFlags> Wartość może być używana do sterowania, jak i gdzie można zaimportować klucza prywatnego.  
  
 Ta metoda przyjmuje tablicę bajtów i może służyć do typów certyfikatów, takich jak certyfikaty x.509 szyfrowany algorytmem Base64 lub algorytmem DER lub certyfikatów PFX/PKCS12. Należy pamiętać, że certyfikat PFX/PKCS12 może zawierać więcej niż jeden certyfikat. W takim przypadku służy pierwszy certyfikat skojarzony z kluczem prywatnym, lub jeśli zostanie znaleziony żaden klucz prywatny, pierwszy certyfikat jest używany.  
  
> [!IMPORTANT]
>  Kodu nigdy nie silne hasło w kodzie źródłowym.  Ustalony hasła mogą być pobierane z zestawu za pomocą [Ildasm.exe (dezasembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), Edytor szesnastkowych, lub po prostu otwarcie zestawu w edytorze tekstu, takich jak Notepad.exe.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy pliku wykonywalnego wiersza polecenia, która przyjmuje pliku certyfikatu jako argument i wyświetla różne właściwości certyfikatu do konsoli.  
  
 [!code-cpp[CertInfo#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertInfo/CPP/certinfo.cpp#1)]
 [!code-csharp[CertInfo#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertInfo/CS/certinfo.cs#1)]
 [!code-vb[CertInfo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertInfo/VB/certinfo.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">aby uzyskać pełne zaufanie dla obiektów dziedziczących. Ten element członkowski nie może być dziedziczona przez kod częściowo zaufany.</permission>
      </Docs>
    </Member>
    <Member MemberName="Import">
      <MemberSignature Language="C#" Value="public override void Import (string fileName, System.Security.SecureString password, System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Import(string fileName, class System.Security.SecureString password, valuetype System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.Import(System.String,System.Security.SecureString,System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Import (fileName As String, password As SecureString, keyStorageFlags As X509KeyStorageFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Import(System::String ^ fileName, System::Security::SecureString ^ password, System::Security::Cryptography::X509Certificates::X509KeyStorageFlags keyStorageFlags);" />
      <MemberSignature Language="F#" Value="abstract member Import : string * System.Security.SecureString * System.Security.Cryptography.X509Certificates.X509KeyStorageFlags -&gt; unit&#xA;override this.Import : string * System.Security.SecureString * System.Security.Cryptography.X509Certificates.X509KeyStorageFlags -&gt; unit" Usage="x509Certificate2.Import (fileName, password, keyStorageFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("SecureString is incomplete")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="password" Type="System.Security.SecureString" />
        <Parameter Name="keyStorageFlags" Type="System.Security.Cryptography.X509Certificates.X509KeyStorageFlags" />
      </Parameters>
      <Docs>
        <param name="fileName">Nazwa pliku certyfikatu.</param>
        <param name="password">Hasło wymagane do uzyskania dostępu do danych certyfikatu X.509.</param>
        <param name="keyStorageFlags">Bitowe połączenie wyliczenia wartości tego formantu, jak i gdzie można zaimportować certyfikatu.</param>
        <summary>Wypełnia <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> obiektu informacjami uzyskanymi z pliku certyfikatu, hasła oraz flagę magazynu kluczy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 **Uwaga dotycząca zabezpieczeń** kodu nigdy nie silne hasło w kodzie źródłowym.  Ustalony hasła mogą być pobierane z zestawu za pomocą [Ildasm.exe (dezasembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), Edytor szesnastkowych, lub po prostu otwarcie zestawu w edytorze tekstu, takich jak Notepad.exe.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
      </Docs>
    </Member>
    <Member MemberName="Import">
      <MemberSignature Language="C#" Value="public override void Import (string fileName, string password, System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Import(string fileName, string password, valuetype System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.Import(System.String,System.String,System.Security.Cryptography.X509Certificates.X509KeyStorageFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Import (fileName As String, password As String, keyStorageFlags As X509KeyStorageFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Import(System::String ^ fileName, System::String ^ password, System::Security::Cryptography::X509Certificates::X509KeyStorageFlags keyStorageFlags);" />
      <MemberSignature Language="F#" Value="abstract member Import : string * string * System.Security.Cryptography.X509Certificates.X509KeyStorageFlags -&gt; unit&#xA;override this.Import : string * string * System.Security.Cryptography.X509Certificates.X509KeyStorageFlags -&gt; unit" Usage="x509Certificate2.Import (fileName, password, keyStorageFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("missing KeyStorageFlags support")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="password" Type="System.String" />
        <Parameter Name="keyStorageFlags" Type="System.Security.Cryptography.X509Certificates.X509KeyStorageFlags" />
      </Parameters>
      <Docs>
        <param name="fileName">Nazwa pliku certyfikatu.</param>
        <param name="password">Hasło wymagane do uzyskania dostępu do danych certyfikatu X.509.</param>
        <param name="keyStorageFlags">Bitowe połączenie wyliczenia wartości tego formantu, jak i gdzie można zaimportować certyfikatu.</param>
        <summary>Wypełnia <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> obiektu o informacje z pliku certyfikatu hasła, a <see cref="T:System.Security.Cryptography.X509Certificates.X509KeyStorageFlags" /> wartość.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może być używana wypełnić <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> obiektu o informacje z pliku certyfikatu, hasło i <xref:System.Security.Cryptography.X509Certificates.X509KeyStorageFlags> wartość.  
  
> [!IMPORTANT]
>  Kodu nigdy nie silne hasło w kodzie źródłowym.  Ustalony hasła mogą być pobierane z zestawu za pomocą [Ildasm.exe (dezasembler IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), Edytor szesnastkowych, lub po prostu otwarcie zestawu w edytorze tekstu, takich jak Notepad.exe.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">aby uzyskać pełne zaufanie dla obiektów dziedziczących. Ten element członkowski nie może być dziedziczona przez kod częściowo zaufany.</permission>
      </Docs>
    </Member>
    <Member MemberName="IssuerName">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.X509Certificates.X500DistinguishedName IssuerName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.X509Certificates.X500DistinguishedName IssuerName" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.X509Certificates.X509Certificate2.IssuerName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IssuerName As X500DistinguishedName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::X509Certificates::X500DistinguishedName ^ IssuerName { System::Security::Cryptography::X509Certificates::X500DistinguishedName ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.IssuerName : System.Security.Cryptography.X509Certificates.X500DistinguishedName" Usage="System.Security.Cryptography.X509Certificates.X509Certificate2.IssuerName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X500DistinguishedName</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwa wyróżniająca wystawcy certyfikatu.</summary>
        <value>
          <see cref="T:System.Security.Cryptography.X509Certificates.X500DistinguishedName" /> Obiekt, który zawiera nazwy wystawcy certyfikatu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zawiera nazwę urzędu certyfikacji (CA), który wystawił certyfikat. Aby uzyskać nazwę certyfikatu, należy użyć <xref:System.Security.Cryptography.X509Certificates.X509Certificate2.GetNameInfo%2A> metody.  
  
 Nazwa wyróżniająca dla certyfikatu jest tekstową reprezentację wartości podmiotu certyfikatu lub wystawcy. Taka reprezentacja składa się z atrybutami name (na przykład "CN = Mójużytkownik, OU = Moja_jednostka_org, C = US").  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy plik wykonywalny wiersza polecenia, która przyjmuje pliku certyfikatu jako argument i wyświetla różne właściwości certyfikatu do konsoli.  
  
 [!code-cpp[CertInfo#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertInfo/CPP/certinfo.cpp#1)]
 [!code-csharp[CertInfo#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertInfo/CS/certinfo.cs#1)]
 [!code-vb[CertInfo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertInfo/VB/certinfo.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Kontekst certyfikatu jest nieprawidłowy.</exception>
      </Docs>
    </Member>
    <Member MemberName="NotAfter">
      <MemberSignature Language="C#" Value="public DateTime NotAfter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime NotAfter" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.X509Certificates.X509Certificate2.NotAfter" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NotAfter As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime NotAfter { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.NotAfter : DateTime" Usage="System.Security.Cryptography.X509Certificates.X509Certificate2.NotAfter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera Data według czasu lokalnego, po której certyfikat nie jest już prawidłowy.</summary>
        <value>A <see cref="T:System.DateTime" /> obiekt reprezentujący datę wygaśnięcia certyfikatu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość wskazuje datę wygaśnięcia, na którym certyfikat jest nieprawidłowy.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy pliku wykonywalnego wiersza polecenia, która przyjmuje pliku certyfikatu jako argument i wyświetla różne właściwości certyfikatu do konsoli.  
  
 [!code-cpp[CertInfo#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertInfo/CPP/certinfo.cpp#1)]
 [!code-csharp[CertInfo#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertInfo/CS/certinfo.cs#1)]
 [!code-vb[CertInfo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertInfo/VB/certinfo.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Certyfikat jest niemożliwe do odczytania.</exception>
      </Docs>
    </Member>
    <Member MemberName="NotBefore">
      <MemberSignature Language="C#" Value="public DateTime NotBefore { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime NotBefore" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.X509Certificates.X509Certificate2.NotBefore" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NotBefore As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime NotBefore { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.NotBefore : DateTime" Usage="System.Security.Cryptography.X509Certificates.X509Certificate2.NotBefore" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera Data według czasu lokalnego, od której zaczyna obowiązywać certyfikat.</summary>
        <value>A <see cref="T:System.DateTime" /> obiekt, który reprezentuje wejścia w życie certyfikatu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość wskazuje Data, od której zaczyna obowiązywać certyfikat.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy pliku wykonywalnego wiersza polecenia, która przyjmuje pliku certyfikatu jako argument i wyświetla różne właściwości certyfikatu do konsoli.  
  
 [!code-cpp[CertInfo#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertInfo/CPP/certinfo.cpp#1)]
 [!code-csharp[CertInfo#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertInfo/CS/certinfo.cs#1)]
 [!code-vb[CertInfo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertInfo/VB/certinfo.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Certyfikat jest niemożliwe do odczytania.</exception>
      </Docs>
    </Member>
    <Member MemberName="PrivateKey">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.AsymmetricAlgorithm PrivateKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.AsymmetricAlgorithm PrivateKey" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.X509Certificates.X509Certificate2.PrivateKey" />
      <MemberSignature Language="VB.NET" Value="Public Property PrivateKey As AsymmetricAlgorithm" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::AsymmetricAlgorithm ^ PrivateKey { System::Security::Cryptography::AsymmetricAlgorithm ^ get(); void set(System::Security::Cryptography::AsymmetricAlgorithm ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PrivateKey : System.Security.Cryptography.AsymmetricAlgorithm with get, set" Usage="System.Security.Cryptography.X509Certificates.X509Certificate2.PrivateKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.AsymmetricAlgorithm</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Security.Cryptography.AsymmetricAlgorithm" /> obiekt, który reprezentuje klucz prywatny skojarzony z certyfikatem.</summary>
        <value>
          <see cref="T:System.Security.Cryptography.AsymmetricAlgorithm" /> Obiektu, który jest RSA albo DSA dostawcy usług kryptograficznych.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obecnie ta właściwość obsługuje tylko kluczy RSA lub DSA, tak aby zwracało albo <xref:System.Security.Cryptography.RSACryptoServiceProvider> lub <xref:System.Security.Cryptography.DSACryptoServiceProvider> obiektu. Jeśli klucza prywatnego, nie ma skojarzonego z certyfikatem, zwraca `null`.  
  
> [!WARNING]
>  Jeśli ta właściwość jest ustawiona na `null` lub do innego klucza bez uprzedniego usunięcia pliku klucza prywatnego pozostaje na dysku.  
  
 Aby prawidłowo usunąć klucz prywatny skojarzony z tą właściwością, ustaw `PersistKeyInCsp` do `false`, a następnie wywołać <xref:System.Security.Cryptography.AsymmetricAlgorithm.Clear%2A> — metoda.  
  
   
  
## Examples  
 Poniższy przykład kodu otwiera magazynie certyfikatów bieżącego użytkownika, wybiera tylko aktywne certyfikaty, a następnie umożliwia użytkownikowi wybranie co najmniej jednego certyfikatu. Przykład następnie zapisuje informacje o certyfikacie w konsoli.  
  
 [!code-cpp[CertSelect#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertSelect/CPP/certselect.cpp#1)]
 [!code-csharp[CertSelect#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertSelect/CS/certselect.cs#1)]
 [!code-vb[CertSelect#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertSelect/VB/certselect.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Wartość tego klucza nie jest kluczem RSA lub DSA lub klucz jest niemożliwe do odczytania.</exception>
        <exception cref="T:System.ArgumentNullException">Ustawienie dla tej właściwości jest wartości <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Algorytm klucza klucz prywatny nie jest obsługiwane.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicUnexpectedOperationException">Klucze X.509 nie pasują do siebie.</exception>
        <exception cref="T:System.ArgumentException">Klucz dostawcy usług kryptograficznych jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="PublicKey">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.X509Certificates.PublicKey PublicKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.X509Certificates.PublicKey PublicKey" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.X509Certificates.X509Certificate2.PublicKey" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PublicKey As PublicKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::X509Certificates::PublicKey ^ PublicKey { System::Security::Cryptography::X509Certificates::PublicKey ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PublicKey : System.Security.Cryptography.X509Certificates.PublicKey" Usage="System.Security.Cryptography.X509Certificates.X509Certificate2.PublicKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.PublicKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="P:System.Security.Cryptography.X509Certificates.X509Certificate2.PublicKey" /> obiekt skojarzony z certyfikatem.</summary>
        <value>A <see cref="P:System.Security.Cryptography.X509Certificates.X509Certificate2.PublicKey" /> obiektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zwraca <xref:System.Security.Cryptography.X509Certificates.X509Certificate2.PublicKey%2A> obiekt, który zawiera identyfikator obiektu (<xref:System.Security.Cryptography.Oid>) reprezentujący algorytm klucza publicznego, parametry kodowany w formacie ASN.1 i kodowany w formacie ASN.1 wartości klucza.  
  
 Możesz również uzyskać klucz jako <xref:System.Security.Cryptography.AsymmetricAlgorithm> obiektu za pomocą odwołań do <xref:System.Security.Cryptography.X509Certificates.X509Certificate2.PublicKey%2A> właściwości. Ta właściwość obsługuje tylko kluczy RSA lub DSA, tak aby zwracało albo <xref:System.Security.Cryptography.RSACryptoServiceProvider> lub <xref:System.Security.Cryptography.DSACryptoServiceProvider> obiekt, który reprezentuje klucz publiczny.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy pliku wykonywalnego wiersza polecenia, która przyjmuje pliku certyfikatu jako argument i wyświetla różne właściwości certyfikatu do konsoli.  
  
 [!code-cpp[CertSelect#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertSelect/CPP/certselect.cpp#1)]
 [!code-csharp[CertSelect#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertSelect/CS/certselect.cs#1)]
 [!code-vb[CertSelect#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertSelect/VB/certselect.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Wartość tego klucza nie jest kluczem RSA lub DSA lub klucz jest niemożliwe do odczytania.</exception>
      </Docs>
    </Member>
    <Member MemberName="RawData">
      <MemberSignature Language="C#" Value="public byte[] RawData { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] RawData" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.X509Certificates.X509Certificate2.RawData" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RawData As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ RawData { cli::array &lt;System::Byte&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RawData : byte[]" Usage="System.Security.Cryptography.X509Certificates.X509Certificate2.RawData" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera dane pierwotne certyfikatu.</summary>
        <value>Dane pierwotne certyfikatu w postaci tablicy bajtów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu tworzy pliku wykonywalnego wiersza polecenia, która przyjmuje pliku certyfikatu jako argument i wyświetla różne właściwości certyfikatu do konsoli.  
  
 [!code-cpp[CertSelect#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertSelect/CPP/certselect.cpp#1)]
 [!code-csharp[CertSelect#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertSelect/CS/certselect.cs#1)]
 [!code-vb[CertSelect#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertSelect/VB/certselect.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public override void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Reset();" />
      <MemberSignature Language="F#" Value="abstract member Reset : unit -&gt; unit&#xA;override this.Reset : unit -&gt; unit" Usage="x509Certificate2.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Resetuje stan <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia resetowanie stanu certyfikatu. Zwalnia wszystkie zasoby skojarzone z certyfikatem.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">aby uzyskać pełne zaufanie dla bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez kod częściowo zaufany.</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">aby uzyskać pełne zaufanie dla obiektów dziedziczących. Ten element członkowski nie może być dziedziczona przez kod częściowo zaufany.</permission>
      </Docs>
    </Member>
    <Member MemberName="SerialNumber">
      <MemberSignature Language="C#" Value="public string SerialNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SerialNumber" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.X509Certificates.X509Certificate2.SerialNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SerialNumber As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ SerialNumber { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SerialNumber : string" Usage="System.Security.Cryptography.X509Certificates.X509Certificate2.SerialNumber" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera numer seryjny certyfikatu jako ciąg szesnastkowy big-endian.</summary>
        <value>Numer seryjny certyfikatu jako ciąg szesnastkowy big-endian.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Numer seryjny certyfikatu jest częścią oryginalnego protokołu X.509. Numer seryjny jest unikatowy numer wystawiony przez wystawcy certyfikatu, który jest również nazywany certyfikatu urzędu certyfikacji.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy pliku wykonywalnego wiersza polecenia, która przyjmuje pliku certyfikatu jako argument i wyświetla różne właściwości certyfikatu do konsoli.  
  
 [!code-cpp[CertInfo#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertInfo/CPP/certinfo.cpp#1)]
 [!code-csharp[CertInfo#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertInfo/CS/certinfo.cs#1)]
 [!code-vb[CertInfo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertInfo/VB/certinfo.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SignatureAlgorithm">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.Oid SignatureAlgorithm { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.Oid SignatureAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.X509Certificates.X509Certificate2.SignatureAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SignatureAlgorithm As Oid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::Oid ^ SignatureAlgorithm { System::Security::Cryptography::Oid ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SignatureAlgorithm : System.Security.Cryptography.Oid" Usage="System.Security.Cryptography.X509Certificates.X509Certificate2.SignatureAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.Oid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera algorytm używany do tworzenia podpisu certyfikatu.</summary>
        <value>Zwraca identyfikator obiektu (<see cref="T:System.Security.Cryptography.Oid" />) algorytmu podpisu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identyfikator obiektu (<xref:System.Security.Cryptography.Oid>) określa typ algorytmu sygnatury używanego przez certyfikat.  
  
   
  
## Examples  
 Poniższy przykład kodu otwiera magazynie certyfikatów bieżącego użytkownika, wybiera tylko aktywne certyfikaty, a następnie umożliwia użytkownikowi wybranie co najmniej jednego certyfikatu. Przykład następnie zapisuje informacje o certyfikacie w konsoli.  
  
 [!code-cpp[CertSelect#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertSelect/CPP/certselect.cpp#1)]
 [!code-csharp[CertSelect#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertSelect/CS/certselect.cs#1)]
 [!code-vb[CertSelect#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertSelect/VB/certselect.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Certyfikat jest niemożliwe do odczytania.</exception>
      </Docs>
    </Member>
    <Member MemberName="SubjectName">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.X509Certificates.X500DistinguishedName SubjectName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.X509Certificates.X500DistinguishedName SubjectName" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.X509Certificates.X509Certificate2.SubjectName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SubjectName As X500DistinguishedName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::X509Certificates::X500DistinguishedName ^ SubjectName { System::Security::Cryptography::X509Certificates::X500DistinguishedName ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SubjectName : System.Security.Cryptography.X509Certificates.X500DistinguishedName" Usage="System.Security.Cryptography.X509Certificates.X509Certificate2.SubjectName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X500DistinguishedName</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwa wyróżniająca podmiotu z certyfikatu.</summary>
        <value>
          <see cref="T:System.Security.Cryptography.X509Certificates.X500DistinguishedName" /> Obiekt, który reprezentuje nazwę podmiotu certyfikatu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nazwa wyróżniająca podmiotu jest nazwa użytkownika certyfikatu. Nazwa wyróżniająca dla certyfikatu jest tekstową reprezentację wartości podmiotu lub wystawcy certyfikatu. Taka reprezentacja składa się z atrybutami name, na przykład "CN = Mójużytkownik, OU = Moja_jednostka_org, C = US".  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy pliku wykonywalnego wiersza polecenia, która przyjmuje pliku certyfikatu jako argument i wyświetla różne właściwości certyfikatu do konsoli.  
  
 [!code-cpp[CertInfo#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertInfo/CPP/certinfo.cpp#1)]
 [!code-csharp[CertInfo#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertInfo/CS/certinfo.cs#1)]
 [!code-vb[CertInfo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertInfo/VB/certinfo.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Kontekst certyfikatu jest nieprawidłowy.</exception>
      </Docs>
    </Member>
    <Member MemberName="Thumbprint">
      <MemberSignature Language="C#" Value="public string Thumbprint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Thumbprint" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.X509Certificates.X509Certificate2.Thumbprint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Thumbprint As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Thumbprint { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Thumbprint : string" Usage="System.Security.Cryptography.X509Certificates.X509Certificate2.Thumbprint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera odcisk palca certyfikatu.</summary>
        <value>Odcisk palca certyfikatu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Odcisk palca dynamicznie jest generowany przy użyciu algorytmu SHA1 i nie istnieje fizycznie w certyfikacie. Ponieważ odcisk palca jest unikatową wartość dla certyfikatu, jest często używana można znaleźć określonego certyfikatu w magazynie certyfikatów.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy pliku wykonywalnego wiersza polecenia, która przyjmuje pliku certyfikatu jako argument i wyświetla różne właściwości certyfikatu do konsoli.  
  
 [!code-cpp[CertInfo#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertInfo/CPP/certinfo.cpp#1)]
 [!code-csharp[CertInfo#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertInfo/CS/certinfo.cs#1)]
 [!code-vb[CertInfo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertInfo/VB/certinfo.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wyświetla certyfikat X.509 w formacie tekstowym.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="abstract member ToString : unit -&gt; string&#xA;override this.ToString : unit -&gt; string" Usage="x509Certificate2.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wyświetla certyfikat X.509 w formacie tekstowym.</summary>
        <returns>Informacje o certyfikacie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jak w przypadku wszystkich `ToString` metod, dane wyjściowe może nie być spójność w ramach wersji programu .NET Framework, więc wyników — metoda nie powinna być analizowana pod kątem zawartości. Użyj właściwości na <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> obiekt, aby uzyskać dokładne informacje o zawartości lub użyj <xref:System.Security.Cryptography.X509Certificates.X509Certificate2.ToString%2A> metodę, aby uzyskać informacje o certyfikacie.  
  
 Ta metoda Wyświetla certyfikatu w formacie tekstowym.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy pliku wykonywalnego wiersza polecenia, która przyjmuje pliku certyfikatu jako argument i wyświetla różne właściwości certyfikatu do konsoli.  
  
 [!code-cpp[CertInfo#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertInfo/CPP/certinfo.cpp#1)]
 [!code-csharp[CertInfo#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertInfo/CS/certinfo.cs#1)]
 [!code-vb[CertInfo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertInfo/VB/certinfo.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString (bool verbose);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString(bool verbose) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.ToString(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString (verbose As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString(bool verbose);" />
      <MemberSignature Language="F#" Value="abstract member ToString : bool -&gt; string&#xA;override this.ToString : bool -&gt; string" Usage="x509Certificate2.ToString verbose" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="verbose" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="verbose">
          <see langword="true" /> Aby wyświetlić klucz publiczny, klucz prywatny, rozszerzenia i tak dalej; <see langword="false" /> do wyświetlania informacji, która jest podobna do <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> klasy, w tym odciskiem palca, numer seryjny, nazwy podmiotu i wystawcy i tak dalej.</param>
        <summary>Wyświetla certyfikat X.509 w formacie tekstowym.</summary>
        <returns>Informacje o certyfikacie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jak w przypadku wszystkich `ToString` metod, dane wyjściowe może nie być spójność w ramach wersji programu .NET Framework, więc wyników — metoda nie powinna być analizowana pod kątem zawartości. Użyj właściwości na <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> obiekt, aby uzyskać dokładne informacje.  
  
 Ta metoda Wyświetla certyfikatu w formacie tekstowym. Jeśli `verbose` ustawiono parametr `true`, wyświetlanie tekstu zawiera klucz publiczny, klucz prywatny i rozszerzenia. Jeśli `verbose` ma ustawioną wartość `false`, wyświetlanie tekstu zawiera te pola, które są dostępne z certyfikatu X.509, w tym odciskiem palca, numer seryjny, nazwy podmiotu i wystawcy i informacje o dacie ważności.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy wykonywalny Wiersz polecenia, który przyjmuje pliku certyfikatu jako argument i wyświetla różne właściwości certyfikatu do konsoli.  
  
 [!code-cpp[CertInfo#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertInfo/CPP/certinfo.cpp#1)]
 [!code-csharp[CertInfo#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertInfo/CS/certinfo.cs#1)]
 [!code-vb[CertInfo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertInfo/VB/certinfo.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Verify">
      <MemberSignature Language="C#" Value="public bool Verify ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Verify() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.X509Certificates.X509Certificate2.Verify" />
      <MemberSignature Language="VB.NET" Value="Public Function Verify () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Verify();" />
      <MemberSignature Language="F#" Value="member this.Verify : unit -&gt; bool" Usage="x509Certificate2.Verify " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("by default this depends on the incomplete X509Chain")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sprawdza poprawność łańcucha X.509, za pomocą zasad podstawowe sprawdzanie poprawności.</summary>
        <returns>
          <see langword="true" /> Jeśli weryfikacja zakończy się pomyślnie; <see langword="false" /> w przypadku niepowodzenia weryfikacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda tworzy prosty łańcucha certyfikatu i stosuje podstawowe zasady do tego łańcucha. Aby uzyskać więcej informacji na temat niepowodzenia weryfikacji certyfikatu bezpośrednio przy użyciu <xref:System.Security.Cryptography.X509Certificates.X509Chain> obiektu.  
  
 Należy pamiętać, że domyślna łańcucha aparat można przesłonić przy użyciu <xref:System.Security.Cryptography.CryptoConfig> klasy. Microsoft Windows Server 2003, domyślny aparat zgodny ze specyfikacją opisanego w RFC3280, "[certyfikat i profil listy odwołania certyfikatów](http://go.microsoft.com/fwlink/?LinkId=45286)."  
  
   
  
## Examples  
 Poniższy przykład kodu otwiera magazynie certyfikatów bieżącego użytkownika, wybiera tylko aktywne certyfikaty, a następnie umożliwia użytkownikowi wybranie co najmniej jednego certyfikatu. Przykład następnie zapisuje informacje o certyfikacie w konsoli.  
  
 [!code-cpp[CertSelect#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertSelect/CPP/certselect.cpp#1)]
 [!code-csharp[CertSelect#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertSelect/CS/certselect.cs#1)]
 [!code-vb[CertSelect#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertSelect/VB/certselect.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Certyfikat jest niemożliwe do odczytania.</exception>
      </Docs>
    </Member>
    <Member MemberName="Version">
      <MemberSignature Language="C#" Value="public int Version { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Version" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.X509Certificates.X509Certificate2.Version" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Version As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Version { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Version : int" Usage="System.Security.Cryptography.X509Certificates.X509Certificate2.Version" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.X509Certificates</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wersja formatu X.509 certyfikatu.</summary>
        <value>Format certyfikatu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dostępne są różne wersje certyfikatów X.509. Ta właściwość określa, który format używa certyfikatu. Na przykład "3" jest zwracana certyfikatu w wersji 3.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy pliku wykonywalnego wiersza polecenia, która przyjmuje pliku certyfikatu jako argument i wyświetla różne właściwości certyfikatu do konsoli.  
  
 [!code-cpp[CertInfo#1](~/samples/snippets/cpp/VS_Snippets_CLR/CertInfo/CPP/certinfo.cpp#1)]
 [!code-csharp[CertInfo#1](~/samples/snippets/csharp/VS_Snippets_CLR/CertInfo/CS/certinfo.cs#1)]
 [!code-vb[CertInfo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CertInfo/VB/certinfo.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Certyfikat jest niemożliwe do odczytania.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="XNode" FullName="System.Xml.Linq.XNode">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f001654247344cf25b9ac07d23e7fb08ac4c201a" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class XNode : System.Xml.Linq.XObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit XNode extends System.Xml.Linq.XObject" />
  <TypeSignature Language="DocId" Value="T:System.Xml.Linq.XNode" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class XNode&#xA;Inherits XObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class XNode abstract : System::Xml::Linq::XObject" />
  <AssemblyInfo>
    <AssemblyName>System.Xml.XDocument</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml.Linq</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Xml.Linq.XObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <span data-ttu-id="bb6c8-101">Reprezentuje abstrakcyjne pojęcie (element, komentarza, typu dokumentu, instrukcji przetwarzania lub węzeł tekstowy) węzeł w drzewie XML.</span>
      <span class="sxs-lookup">
        <span data-stu-id="bb6c8-101">Represents the abstract concept of a node (element, comment, document type, processing instruction, or text node) in the XML tree.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bb6c8-102"><xref:System.Xml.Linq.XNode> jest abstrakcyjna klasa podstawowa typowe dla następujących typów:</span><span class="sxs-lookup"><span data-stu-id="bb6c8-102"><xref:System.Xml.Linq.XNode> is an abstract common base class for the following types:</span></span>  
  
-   <xref:System.Xml.Linq.XComment>  
  
-   <xref:System.Xml.Linq.XContainer>  
  
-   <xref:System.Xml.Linq.XDocumentType>  
  
-   <xref:System.Xml.Linq.XProcessingInstruction>  
  
-   <xref:System.Xml.Linq.XText>  
  
 <span data-ttu-id="bb6c8-103"><xref:System.Xml.Linq.XContainer> jest abstrakcyjna klasa podstawowa typowe dla następujących typów:</span><span class="sxs-lookup"><span data-stu-id="bb6c8-103"><xref:System.Xml.Linq.XContainer> is an abstract common base class for the following types:</span></span>  
  
-   <xref:System.Xml.Linq.XDocument>  
  
-   <xref:System.Xml.Linq.XElement>  
  
 <span data-ttu-id="bb6c8-104">Obiekty klas, które pochodzą z <xref:System.Xml.Linq.XContainer> może zawierać węzłów podrzędnych.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-104">Objects of classes that derive from <xref:System.Xml.Linq.XContainer> can contain child nodes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bb6c8-105"><xref:System.Xml.Linq.XAttribute> Nie jest <xref:System.Xml.Linq.XNode>.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-105">An <xref:System.Xml.Linq.XAttribute> is not an <xref:System.Xml.Linq.XNode>.</span></span> <span data-ttu-id="bb6c8-106">Atrybuty są obsługiwane jako listę par nazwa/wartość w elemencie.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-106">Attributes are maintained as a list of name/value pairs on an element.</span></span>  
  
 <span data-ttu-id="bb6c8-107">Jeśli piszesz złożonych aplikacji XML, na przykład edytora XML lub edytorze tekstów, służący do przechowywania zawartości w formacie XML, często będą działać na poziomie węzła.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-107">If you are writing a complex XML application, such as an XML editor or a word processor that stores content as XML, you will often work at the node level.</span></span> <span data-ttu-id="bb6c8-108">Typowe działania podczas pracy na poziomie węzła obejmują dodawanie węzłów, usuwanie węzłów, przekształcanie węzłów i iteracji osi, które zwracają kolekcje węzłów.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-108">Typical activities when working at the node level include adding nodes, deleting nodes, transforming nodes, and iterating through axes that return collections of nodes.</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="AddAfterSelf">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="bb6c8-109">Dodaje określoną zawartością natychmiast po tym węźle.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-109">Adds the specified content immediately after this node.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bb6c8-110">Aby uzyskać szczegółowe informacje o prawidłowej zawartości, które mogą zostać przekazane do tej metody, zobacz [Nieprawidłowa zawartość klasy XElement i obiektów klasy XDocument](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span><span class="sxs-lookup"><span data-stu-id="bb6c8-110">For details about the valid content that can be passed to this method, see [Valid Content of XElement and XDocument Objects](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span></span>  
  
 <span data-ttu-id="bb6c8-111">Ta metoda zostanie podniesiony <xref:System.Xml.Linq.XObject.Changed> i <xref:System.Xml.Linq.XObject.Changing> zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-111">This method will raise the <xref:System.Xml.Linq.XObject.Changed> and the <xref:System.Xml.Linq.XObject.Changing> events.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bb6c8-112">W poniższym przykładzie użyto zapytania LINQ, aby utworzyć <xref:System.Collections.Generic.IEnumerable%601> z <xref:System.Xml.Linq.XElement>, który następnie przekazuje do tej metody.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-112">The following example uses a LINQ query to create an <xref:System.Collections.Generic.IEnumerable%601> of <xref:System.Xml.Linq.XElement>, which it then passes to this method.</span></span> <span data-ttu-id="bb6c8-113">Spowoduje to dodanie wyników zapytania do drzewa w dowolnym miejscu.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-113">This adds the results of a query to the tree in the desired location.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
    new XElement("Element1", 1),  
    new XElement("Element2", 2),  
    new XElement("Element3", 3),  
    new XElement("Element4", 4),  
    new XElement("Element5", 5)  
);  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5)  
);  
XElement child1 = xmlTree.Element("Child1");  
child1.AddAfterSelf(  
    from el in srcTree.Elements()  
    where (int)el > 3  
    select el  
);  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Dim srcTree As XElement = _  
    <Root>  
        <Element1>1</Element1>  
        <Element2>2</Element2>  
        <Element3>3</Element3>  
        <Element4>4</Element4>  
        <Element5>5</Element5>  
    </Root>  
  
Dim xmlTree As XElement = _  
    <Root>  
        <Child1>1</Child1>  
        <Child2>2</Child2>  
        <Child3>3</Child3>  
        <Child4>4</Child4>  
        <Child5>5</Child5>  
    </Root>  
  
Dim child1 As XElement = xmlTree.<Child1>(0)  
child1.AddAfterSelf( _  
    From el In srcTree.Elements() _  
    Where CInt(el) > 3 _  
    Select el _  
)  
Console.WriteLine(xmlTree)  
```  
  
 <span data-ttu-id="bb6c8-114">Ten przykład generuje następujące wyniki:</span><span class="sxs-lookup"><span data-stu-id="bb6c8-114">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <Child1>1</Child1>  
  <Element4>4</Element4>  
  <Element5>5</Element5>  
  <Child2>2</Child2>  
  <Child3>3</Child3>  
  <Child4>4</Child4>  
  <Child5>5</Child5>  
</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddAfterSelf">
      <MemberSignature Language="C#" Value="public void AddAfterSelf (object content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddAfterSelf(object content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.AddAfterSelf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddAfterSelf (content As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddAfterSelf(System::Object ^ content);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="content">
          <span data-ttu-id="bb6c8-115">Obiekt zawartości zawiera zawartość prostą lub kolekcję obiektów zawartości ma zostać dodana po tego węzła.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-115">A content object that contains simple content or a collection of content objects to be added after this node.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bb6c8-116">Dodaje określoną zawartością natychmiast po tym węźle.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-116">Adds the specified content immediately after this node.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bb6c8-117">Aby uzyskać szczegółowe informacje o prawidłowej zawartości, które mogą zostać przekazane do tej metody, zobacz [Nieprawidłowa zawartość klasy XElement i obiektów klasy XDocument](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span><span class="sxs-lookup"><span data-stu-id="bb6c8-117">For details about the valid content that can be passed to this method, see [Valid Content of XElement and XDocument Objects](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span></span>  
  
 <span data-ttu-id="bb6c8-118"><xref:System.Xml.Linq.XObject.Changing> zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-118"><xref:System.Xml.Linq.XObject.Changing> events.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bb6c8-119">W poniższym przykładzie użyto tej metody można dodać elementu do drzewa.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-119">The following example uses this method to add an element into the tree.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5)  
);  
XElement child1 = xmlTree.Element("Child1");  
child1.AddAfterSelf(  
    new XElement("NewChild", 10)  
);  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <Child3>3</Child3>  
            <Child4>4</Child4>  
            <Child5>5</Child5>  
        </Root>  
  
Dim child1 As XElement = xmlTree.<Child1>(0)  
child1.AddAfterSelf(New XElement("NewChild", 10))  
Console.WriteLine(xmlTree)  
```  
  
 <span data-ttu-id="bb6c8-120">Ten przykład generuje następujące wyniki:</span><span class="sxs-lookup"><span data-stu-id="bb6c8-120">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <Child1>1</Child1>  
  <NewChild>10</NewChild>  
  <Child2>2</Child2>  
  <Child3>3</Child3>  
  <Child4>4</Child4>  
  <Child5>5</Child5>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="bb6c8-121">Element nadrzędny jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-121">The parent is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="AddAfterSelf">
      <MemberSignature Language="C#" Value="public void AddAfterSelf (params object[] content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddAfterSelf(object[] content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.AddAfterSelf(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddAfterSelf (ParamArray content As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddAfterSelf(... cli::array &lt;System::Object ^&gt; ^ content);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="content">
          <span data-ttu-id="bb6c8-122">Lista parametrów obiekty zawartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-122">A parameter list of content objects.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bb6c8-123">Dodaje określoną zawartością natychmiast po tym węźle.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-123">Adds the specified content immediately after this node.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bb6c8-124">Aby uzyskać szczegółowe informacje o prawidłowej zawartości, które mogą zostać przekazane do tej metody, zobacz [Nieprawidłowa zawartość klasy XElement i obiektów klasy XDocument](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span><span class="sxs-lookup"><span data-stu-id="bb6c8-124">For details about the valid content that can be passed to this method, see [Valid Content of XElement and XDocument Objects](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span></span>  
  
 <span data-ttu-id="bb6c8-125">Ta metoda zostanie podniesiony <xref:System.Xml.Linq.XObject.Changed> i <xref:System.Xml.Linq.XObject.Changing> zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-125">This method will raise the <xref:System.Xml.Linq.XObject.Changed> and the <xref:System.Xml.Linq.XObject.Changing> events.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bb6c8-126">W poniższym przykładzie użyto zapytania LINQ, aby utworzyć <xref:System.Collections.Generic.IEnumerable%601> z <xref:System.Xml.Linq.XElement>, który następnie przekazuje do tej metody.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-126">The following example uses a LINQ query to create an <xref:System.Collections.Generic.IEnumerable%601> of <xref:System.Xml.Linq.XElement>, which it then passes to this method.</span></span> <span data-ttu-id="bb6c8-127">Spowoduje to dodanie wyników zapytania do drzewa w dowolnym miejscu.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-127">This adds the results of a query to the tree in the desired location.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
    new XElement("Element1", 1),  
    new XElement("Element2", 2),  
    new XElement("Element3", 3),  
    new XElement("Element4", 4),  
    new XElement("Element5", 5)  
);  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5)  
);  
XElement child1 = xmlTree.Element("Child1");  
child1.AddAfterSelf(  
    from el in srcTree.Elements()  
    where (int)el > 3  
    select el  
);  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Dim srcTree As XElement = _   
        <Root>  
            <Element1>1</Element1>  
            <Element2>2</Element2>  
            <Element3>3</Element3>  
            <Element4>4</Element4>  
            <Element5>5</Element5>  
        </Root>  
  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <Child3>3</Child3>  
            <Child4>4</Child4>  
            <Child5>5</Child5>  
        </Root>  
  
Dim child1 As XElement = xmlTree.<Child1>(0)  
child1.AddAfterSelf( _  
    From el In srcTree.Elements() _  
    Where CInt(el) > 3 _  
    Select el)  
Console.WriteLine(xmlTree)  
```  
  
 <span data-ttu-id="bb6c8-128">Ten przykład generuje następujące wyniki:</span><span class="sxs-lookup"><span data-stu-id="bb6c8-128">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <Child1>1</Child1>  
  <Element4>4</Element4>  
  <Element5>5</Element5>  
  <Child2>2</Child2>  
  <Child3>3</Child3>  
  <Child4>4</Child4>  
  <Child5>5</Child5>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="bb6c8-129">Element nadrzędny jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-129">The parent is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddBeforeSelf">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="bb6c8-130">Dodaje określony zawartości bezpośrednio przed tym węźle.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-130">Adds the specified content immediately before this node.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bb6c8-131">Aby uzyskać szczegółowe informacje o prawidłowej zawartości, które mogą zostać przekazane do tej metody, zobacz [Nieprawidłowa zawartość klasy XElement i obiektów klasy XDocument](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span><span class="sxs-lookup"><span data-stu-id="bb6c8-131">For details about the valid content that can be passed to this method, see [Valid Content of XElement and XDocument Objects](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span></span>  
  
 <span data-ttu-id="bb6c8-132">Ta metoda zostanie podniesiony <xref:System.Xml.Linq.XObject.Changed> i <xref:System.Xml.Linq.XObject.Changing> zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-132">This method will raise the <xref:System.Xml.Linq.XObject.Changed> and <xref:System.Xml.Linq.XObject.Changing> events.</span></span>  
  
 <span data-ttu-id="bb6c8-133"><xref:System.Xml.Linq.XContainer> Przechowuje informacje o jego podrzędnych jako listę pojedynczo połączone <xref:System.Xml.Linq.XNode> obiektów.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-133">The <xref:System.Xml.Linq.XContainer> stores its child notes as a singly-linked list of <xref:System.Xml.Linq.XNode> objects.</span></span> <span data-ttu-id="bb6c8-134">Oznacza to, że <xref:System.Xml.Linq.XNode.AddBeforeSelf%2A> metody muszą przejść listy węzłów bezpośrednich podrzędnych w kontenerze nadrzędnym.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-134">This means that the <xref:System.Xml.Linq.XNode.AddBeforeSelf%2A> method must traverse the list of direct child nodes under the parent container.</span></span> <span data-ttu-id="bb6c8-135">W związku z tym za pomocą tej metody może wpłynąć na wydajność.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-135">Therefore, using this method might  affect your performance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bb6c8-136">W poniższym przykładzie użyto zapytania LINQ, aby utworzyć <xref:System.Collections.Generic.IEnumerable%601> z <xref:System.Xml.Linq.XElement>, który następnie przekazuje do tej metody.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-136">The following example uses a LINQ query to create an <xref:System.Collections.Generic.IEnumerable%601> of <xref:System.Xml.Linq.XElement>, which it then passes to this method.</span></span> <span data-ttu-id="bb6c8-137">Spowoduje to dodanie wyników zapytania do drzewa w dowolnym miejscu.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-137">This adds the results of a query to the tree in the desired location.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
    new XElement("Element1", 1),  
    new XElement("Element2", 2),  
    new XElement("Element3", 3),  
    new XElement("Element4", 4),  
    new XElement("Element5", 5)  
);  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5)  
);  
XElement child1 = xmlTree.Element("Child1");  
child1.AddBeforeSelf(  
    from el in srcTree.Elements()  
    where (int)el > 3  
    select el  
);  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Dim srcTree As XElement = _   
        <Root>  
            <Element1>1</Element1>  
            <Element2>2</Element2>  
            <Element3>3</Element3>  
            <Element4>4</Element4>  
            <Element5>5</Element5>  
        </Root>  
  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <Child3>3</Child3>  
            <Child4>4</Child4>  
            <Child5>5</Child5>  
        </Root>  
  
Dim child1 As XElement = xmlTree.<Child1>(0)  
child1.AddBeforeSelf( _  
From el In srcTree.Elements() _  
Where CInt(el) > 3 _  
Select el)  
  
Console.WriteLine(xmlTree)  
```  
  
 <span data-ttu-id="bb6c8-138">Ten przykład generuje następujące wyniki:</span><span class="sxs-lookup"><span data-stu-id="bb6c8-138">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <Element4>4</Element4>  
  <Element5>5</Element5>  
  <Child1>1</Child1>  
  <Child2>2</Child2>  
  <Child3>3</Child3>  
  <Child4>4</Child4>  
  <Child5>5</Child5>  
</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddBeforeSelf">
      <MemberSignature Language="C#" Value="public void AddBeforeSelf (object content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddBeforeSelf(object content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddBeforeSelf (content As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddBeforeSelf(System::Object ^ content);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="content">
          <span data-ttu-id="bb6c8-139">Obiekt zawartości zawiera zawartość prostą lub kolekcję obiektów zawartości ma zostać dodana przed tego węzła.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-139">A content object that contains simple content or a collection of content objects to be added before this node.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bb6c8-140">Dodaje określony zawartości bezpośrednio przed tym węźle.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-140">Adds the specified content immediately before this node.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bb6c8-141">Aby uzyskać szczegółowe informacje o prawidłowej zawartości, które mogą zostać przekazane do tej metody, zobacz [Nieprawidłowa zawartość klasy XElement i obiektów klasy XDocument](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span><span class="sxs-lookup"><span data-stu-id="bb6c8-141">For details about the valid content that can be passed to this method, see [Valid Content of XElement and XDocument Objects](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span></span>  
  
 <span data-ttu-id="bb6c8-142">Ta metoda zostanie podniesiony <xref:System.Xml.Linq.XObject.Changed> i <xref:System.Xml.Linq.XObject.Changing> zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-142">This method will raise the <xref:System.Xml.Linq.XObject.Changed> and the <xref:System.Xml.Linq.XObject.Changing> events.</span></span>  
  
 <span data-ttu-id="bb6c8-143"><xref:System.Xml.Linq.XContainer> Przechowuje węzły podrzędne jako listę pojedynczo połączone <xref:System.Xml.Linq.XNode> obiektów.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-143">The <xref:System.Xml.Linq.XContainer> stores its child nodes as a singly-linked list of <xref:System.Xml.Linq.XNode> objects.</span></span> <span data-ttu-id="bb6c8-144">Oznacza to, że <xref:System.Xml.Linq.XNode.AddBeforeSelf%2A> metody muszą przejść listy węzłów bezpośrednich podrzędnych w kontenerze nadrzędnym.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-144">This means that the <xref:System.Xml.Linq.XNode.AddBeforeSelf%2A> method must traverse the list of direct child nodes under the parent container.</span></span> <span data-ttu-id="bb6c8-145">W związku z tym za pomocą tej metody może wpłynąć na wydajność.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-145">Therefore, using this method might  affect your performance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bb6c8-146">W poniższym przykładzie użyto tej metody można dodać elementu do drzewa.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-146">The following example uses this method to add an element into the tree.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5)  
);  
XElement child1 = xmlTree.Element("Child1");  
child1.AddBeforeSelf(  
    new XElement("NewChild", 10)  
);  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <Child3>3</Child3>  
            <Child4>4</Child4>  
            <Child5>5</Child5>  
        </Root>  
  
Dim child1 As XElement = xmlTree.<Child1>(0)  
child1.AddBeforeSelf(New XElement("NewChild", 10))  
Console.WriteLine(xmlTree)  
```  
  
 <span data-ttu-id="bb6c8-147">Ten przykład generuje następujące wyniki:</span><span class="sxs-lookup"><span data-stu-id="bb6c8-147">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <NewChild>10</NewChild>  
  <Child1>1</Child1>  
  <Child2>2</Child2>  
  <Child3>3</Child3>  
  <Child4>4</Child4>  
  <Child5>5</Child5>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="bb6c8-148">Element nadrzędny jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-148">The parent is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="AddBeforeSelf">
      <MemberSignature Language="C#" Value="public void AddBeforeSelf (params object[] content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddBeforeSelf(object[] content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddBeforeSelf (ParamArray content As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddBeforeSelf(... cli::array &lt;System::Object ^&gt; ^ content);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="content">
          <span data-ttu-id="bb6c8-149">Lista parametrów obiekty zawartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-149">A parameter list of content objects.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bb6c8-150">Dodaje określony zawartości bezpośrednio przed tym węźle.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-150">Adds the specified content immediately before this node.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bb6c8-151">Aby uzyskać szczegółowe informacje o prawidłowej zawartości, które mogą zostać przekazane do tej metody, zobacz [Nieprawidłowa zawartość klasy XElement i obiektów klasy XDocument](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span><span class="sxs-lookup"><span data-stu-id="bb6c8-151">For details about the valid content that can be passed to this method, see [Valid Content of XElement and XDocument Objects](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span></span>  
  
 <span data-ttu-id="bb6c8-152">Ta metoda zostanie podniesiony <xref:System.Xml.Linq.XObject.Changed> i <xref:System.Xml.Linq.XObject.Changing> zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-152">This method will raise the <xref:System.Xml.Linq.XObject.Changed> and the <xref:System.Xml.Linq.XObject.Changing> events.</span></span>  
  
 <span data-ttu-id="bb6c8-153"><xref:System.Xml.Linq.XContainer> Przechowuje węzły podrzędne jako listę pojedynczo połączone <xref:System.Xml.Linq.XNode> obiektów.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-153">The <xref:System.Xml.Linq.XContainer> stores its child nodes as a singly-linked list of <xref:System.Xml.Linq.XNode> objects.</span></span> <span data-ttu-id="bb6c8-154">Oznacza to, że <xref:System.Xml.Linq.XNode.AddBeforeSelf%2A> metody muszą przejść listy węzłów bezpośrednich podrzędnych w kontenerze nadrzędnym.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-154">This means that the <xref:System.Xml.Linq.XNode.AddBeforeSelf%2A> method must traverse the list of direct child nodes under the parent container.</span></span> <span data-ttu-id="bb6c8-155">W związku z tym za pomocą tej funkcji mogą mieć wpływ na wydajność.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-155">Therefore, using this function might affect your performance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bb6c8-156">W poniższym przykładzie użyto zapytania LINQ, aby utworzyć <xref:System.Collections.Generic.IEnumerable%601> z <xref:System.Xml.Linq.XElement>, który następnie przekazuje do tej metody.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-156">The following example uses a LINQ query to create an <xref:System.Collections.Generic.IEnumerable%601> of <xref:System.Xml.Linq.XElement>, which it then passes to this method.</span></span> <span data-ttu-id="bb6c8-157">Spowoduje to dodanie wyników zapytania do drzewa w dowolnym miejscu.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-157">This adds the results of a query to the tree in the desired location.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
    new XElement("Element1", 1),  
    new XElement("Element2", 2),  
    new XElement("Element3", 3),  
    new XElement("Element4", 4),  
    new XElement("Element5", 5)  
);  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5)  
);  
XElement child1 = xmlTree.Element("Child1");  
child1.AddBeforeSelf(  
    from el in srcTree.Elements()  
    where (int)el > 3  
    select el  
);  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Dim srcTree As XElement = _   
        <Root>  
            <Element1>1</Element1>  
            <Element2>2</Element2>  
            <Element3>3</Element3>  
            <Element4>4</Element4>  
            <Element5>5</Element5>  
        </Root>  
  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <Child3>3</Child3>  
            <Child4>4</Child4>  
            <Child5>5</Child5>  
        </Root>  
  
Dim child1 As XElement = xmlTree.<Child1>(0)  
child1.AddBeforeSelf( _  
    From el In srcTree.Elements() _  
    Where CInt(el) > 3 _  
    Select el)  
  
Console.WriteLine(xmlTree)  
```  
  
 <span data-ttu-id="bb6c8-158">Ten przykład generuje następujące wyniki:</span><span class="sxs-lookup"><span data-stu-id="bb6c8-158">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <Element4>4</Element4>  
  <Element5>5</Element5>  
  <Child1>1</Child1>  
  <Child2>2</Child2>  
  <Child3>3</Child3>  
  <Child4>4</Child4>  
  <Child5>5</Child5>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="bb6c8-159">Element nadrzędny jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-159">The parent is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Ancestors">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="bb6c8-160">Zwraca kolekcję element nadrzędny elementy tego węzła.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-160">Returns a collection of the ancestor elements of this node.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bb6c8-161">Opcjonalnie można określić nazwy węzła do filtrowania dla elementów nadrzędnych o określonej nazwie.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-161">Optionally a node name can be specified to filter for ancestor elements with a specific name.</span></span>  
  
 <span data-ttu-id="bb6c8-162">Węzeł w zwracanej kolekcji znajduje się w kolejności odwrotnej dokumentu.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-162">The nodes in the returned collection are in reverse document order.</span></span>  
  
 <span data-ttu-id="bb6c8-163">Ta metoda używa odroczonego wykonania.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-163">This method uses deferred execution.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Ancestors">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; Ancestors ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; Ancestors() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.Ancestors" />
      <MemberSignature Language="VB.NET" Value="Public Function Ancestors () As IEnumerable(Of XElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XElement ^&gt; ^ Ancestors();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="bb6c8-164">Zwraca kolekcję element nadrzędny elementy tego węzła.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-164">Returns a collection of the ancestor elements of this node.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bb6c8-165">
            <see cref="T:System.Collections.Generic.IEnumerable`1" /> z <see cref="T:System.Xml.Linq.XElement" /> elementów nadrzędny tego węzła.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-165">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:System.Xml.Linq.XElement" /> of the ancestor elements of this node.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bb6c8-166">Ta metoda nie zwraca się w wynikach.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-166">This method does not return itself in the results.</span></span>  
  
 <span data-ttu-id="bb6c8-167">Węzeł w zwracanej kolekcji znajduje się w kolejności odwrotnej dokumentu.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-167">The nodes in the returned collection are in reverse document order.</span></span>  
  
 <span data-ttu-id="bb6c8-168">Ta metoda używa odroczonego wykonania.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-168">This method uses deferred execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bb6c8-169">W poniższym przykładzie użyto tej metody wyliczania elementów nadrzędnych węzła.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-169">The following example uses this method to enumerate the ancestors of a node.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child",   
        new XElement("GrandChild", "content")  
    )  
);  
IEnumerable<XElement> grandChild = xmlTree.Descendants("GrandChild");  
foreach (XElement el in grandChild.Ancestors())  
    Console.WriteLine(el.Name);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>  
            <Child>  
                <GrandChild>content</GrandChild>  
            </Child>  
        </Root>  
  
Dim grandChild As IEnumerable(Of XElement) = xmlTree...<GrandChild>  
For Each el In grandChild.Ancestors()  
    Console.WriteLine(el.Name)  
Next  
```  
  
 <span data-ttu-id="bb6c8-170">Ten przykład generuje następujące wyniki:</span><span class="sxs-lookup"><span data-stu-id="bb6c8-170">This example produces the following output:</span></span>  
  
```  
Child  
Root  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ancestors">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; Ancestors (System.Xml.Linq.XName name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; Ancestors(class System.Xml.Linq.XName name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.Ancestors(System.Xml.Linq.XName)" />
      <MemberSignature Language="VB.NET" Value="Public Function Ancestors (name As XName) As IEnumerable(Of XElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XElement ^&gt; ^ Ancestors(System::Xml::Linq::XName ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="bb6c8-171">
            <see cref="T:System.Xml.Linq.XName" /> Do dopasowania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-171">The <see cref="T:System.Xml.Linq.XName" /> to match.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bb6c8-172">Zwraca kolekcję filtrowane element nadrzędny elementy tego węzła.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-172">Returns a filtered collection of the ancestor elements of this node.</span>
          </span>
          <span data-ttu-id="bb6c8-173">Tylko elementy, które pasują do <see cref="T:System.Xml.Linq.XName" /> znajdują się w kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-173">Only elements that have a matching <see cref="T:System.Xml.Linq.XName" /> are included in the collection.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bb6c8-174">
            <see cref="T:System.Collections.Generic.IEnumerable`1" /> z <see cref="T:System.Xml.Linq.XElement" /> elementów nadrzędny tego węzła.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-174">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:System.Xml.Linq.XElement" /> of the ancestor elements of this node.</span>
          </span>
          <span data-ttu-id="bb6c8-175">Tylko elementy, które pasują do <see cref="T:System.Xml.Linq.XName" /> znajdują się w kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-175">Only elements that have a matching <see cref="T:System.Xml.Linq.XName" /> are included in the collection.</span>
          </span>
          <span data-ttu-id="bb6c8-176">Węzeł w zwracanej kolekcji znajduje się w kolejności odwrotnej dokumentu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-176">The nodes in the returned collection are in reverse document order.</span>
          </span>
          <span data-ttu-id="bb6c8-177">Ta metoda używa odroczonego wykonania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-177">This method uses deferred execution.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bb6c8-178">Ta metoda nie zwróci się w wynikach.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-178">This method will not return itself in the results.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bb6c8-179">W poniższym przykładzie użyto tej metody.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-179">The following example uses this method.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child",   
        new XElement("GrandChild", "content")  
    )  
);  
IEnumerable<XElement> grandChild = xmlTree.Descendants("GrandChild");  
foreach (XElement el in grandChild.Ancestors("Child"))  
    Console.WriteLine(el.Name);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>  
            <Child>  
                <GrandChild>content</GrandChild>  
            </Child>  
        </Root>  
  
Dim grandChild As IEnumerable(Of XElement) = xmlTree...<GrandChild>  
For Each el In grandChild.Ancestors("Child")  
    Console.WriteLine(el.Name)  
Next  
```  
  
 <span data-ttu-id="bb6c8-180">Ten przykład generuje następujące wyniki:</span><span class="sxs-lookup"><span data-stu-id="bb6c8-180">This example produces the following output:</span></span>  
  
```  
Child  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompareDocumentOrder">
      <MemberSignature Language="C#" Value="public static int CompareDocumentOrder (System.Xml.Linq.XNode n1, System.Xml.Linq.XNode n2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareDocumentOrder(class System.Xml.Linq.XNode n1, class System.Xml.Linq.XNode n2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.CompareDocumentOrder(System.Xml.Linq.XNode,System.Xml.Linq.XNode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareDocumentOrder (n1 As XNode, n2 As XNode) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareDocumentOrder(System::Xml::Linq::XNode ^ n1, System::Xml::Linq::XNode ^ n2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="n1" Type="System.Xml.Linq.XNode" />
        <Parameter Name="n2" Type="System.Xml.Linq.XNode" />
      </Parameters>
      <Docs>
        <param name="n1">
          <span data-ttu-id="bb6c8-181">Pierwszy <see cref="T:System.Xml.Linq.XNode" /> do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-181">First <see cref="T:System.Xml.Linq.XNode" /> to compare.</span>
          </span>
        </param>
        <param name="n2">
          <span data-ttu-id="bb6c8-182">Drugi <see cref="T:System.Xml.Linq.XNode" /> do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-182">Second <see cref="T:System.Xml.Linq.XNode" /> to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bb6c8-183">Porównuje dwa węzły, aby określić ich względne kolejności dokumentu XML.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-183">Compares two nodes to determine their relative XML document order.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bb6c8-184">
            <see langword="int" /> Zawierające 0, jeśli węzły są równe; -1 Jeśli <paramref name="n1" /> przed <paramref name="n2" />; 1, gdy <paramref name="n1" /> po <paramref name="n2" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-184">An <see langword="int" /> containing 0 if the nodes are equal; -1 if <paramref name="n1" /> is before <paramref name="n2" />; 1 if <paramref name="n1" /> is after <paramref name="n2" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bb6c8-185"><xref:System.Xml.Linq.XContainer> Przechowuje węzły podrzędne jako listę pojedynczo połączone <xref:System.Xml.Linq.XNode> obiektów.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-185">The <xref:System.Xml.Linq.XContainer> stores its child nodes as a singly-linked list of <xref:System.Xml.Linq.XNode> objects.</span></span> <span data-ttu-id="bb6c8-186">Oznacza to, że <xref:System.Xml.Linq.XNode.CompareDocumentOrder%2A> metody muszą przejść elementów nadrzędnych elementu dwa węzły są porównywane aż do znalezienia Wspólnemu elementowi nadrzędnemu.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-186">This means that the <xref:System.Xml.Linq.XNode.CompareDocumentOrder%2A> method must traverse the ancestors of the two nodes being compared until it finds the common parent.</span></span> <span data-ttu-id="bb6c8-187">Następnie należy go przechodzenie listy Wspólnemu elementowi nadrzędnemu węzłów podrzędnych można określić kolejność dwa węzły są porównywane.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-187">Then it must traverse the list of the common parent’s child nodes to determine the order of the two nodes being compared.</span></span> <span data-ttu-id="bb6c8-188">W związku z tym za pomocą tej metody może wpłynąć na wydajność.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-188">Therefore, using this method might affect your performance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bb6c8-189">W poniższym przykładzie użyto tej metody.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-189">The following example uses this method.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1",  
        new XElement("GrandChild1", 1),  
        new XElement("GrandChild2", 2),  
        new XElement("GrandChild3", 3)  
    ),  
    new XElement("Child2",  
        new XElement("GrandChild4", 4),  
        new XElement("GrandChild5", 5),  
        new XElement("GrandChild6", 6)  
    )  
);  
XElement el1 = xmlTree.Descendants("GrandChild2").First();  
XElement el2 = xmlTree.Descendants("GrandChild6").First();  
if (XElement.CompareDocumentOrder(el1, el2) == 0)  
    Console.WriteLine("Compared elements are the same element");  
else if (XElement.CompareDocumentOrder(el1, el2) > 0)  
    Console.WriteLine("el1 is after el2");  
else  
    Console.WriteLine("el1 is before el2");  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>  
                <GrandChild1>1</GrandChild1>  
                <GrandChild2>2</GrandChild2>  
                <GrandChild3>3</GrandChild3>  
            </Child1>  
            <Child2>  
                <GrandChild4>4</GrandChild4>  
                <GrandChild5>5</GrandChild5>  
                <GrandChild6>6</GrandChild6>  
            </Child2>  
        </Root>  
  
Dim el1 As XElement = xmlTree...<GrandChild2>(0)  
Dim el2 As XElement = xmlTree...<GrandChild6>(0)  
  
If (XElement.CompareDocumentOrder(el1, el2) = 0) Then  
    Console.WriteLine("Compared elements are the same element")  
ElseIf (XElement.CompareDocumentOrder(el1, el2) > 0) Then  
    Console.WriteLine("el1 is after el2")  
Else  
    Console.WriteLine("el1 is before el2")  
End If  
```  
  
 <span data-ttu-id="bb6c8-190">Ten przykład generuje następujące wyniki:</span><span class="sxs-lookup"><span data-stu-id="bb6c8-190">This example produces the following output:</span></span>  
  
```  
el1 is before el2  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="bb6c8-191">Dwa węzły nie współużytkują wspólnego elementu nadrzędnego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-191">The two nodes do not share a common ancestor.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateReader">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="bb6c8-192">Tworzy <see cref="T:System.Xml.XmlReader" /> dla tego węzła.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-192">Creates an <see cref="T:System.Xml.XmlReader" /> for this node.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateReader">
      <MemberSignature Language="C#" Value="public System.Xml.XmlReader CreateReader ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.XmlReader CreateReader() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.CreateReader" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateReader () As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xml::XmlReader ^ CreateReader();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="bb6c8-193">Tworzy <see cref="T:System.Xml.XmlReader" /> dla tego węzła.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-193">Creates an <see cref="T:System.Xml.XmlReader" /> for this node.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bb6c8-194">
            <see cref="T:System.Xml.XmlReader" /> Można odczytać ten węzeł i jego obiektów podrzędnych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-194">An <see cref="T:System.Xml.XmlReader" /> that can be used to read this node and its descendants.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bb6c8-195">Zazwyczaj używana tej metody, gdy trzeba podawać innego składnika o <xref:System.Xml.XmlReader>.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-195">You typically use this method when you have to supply another component with an <xref:System.Xml.XmlReader>.</span></span> <span data-ttu-id="bb6c8-196">Na przykład można utworzyć <xref:System.Xml.XmlReader> z [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] drzewa, a następnie przekazać ten czytnik do <xref:System.Xml.XmlDocument.Load%2A>.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-196">For example, you can create an <xref:System.Xml.XmlReader> from a [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] tree, and then pass that reader to <xref:System.Xml.XmlDocument.Load%2A>.</span></span>  
  
 <span data-ttu-id="bb6c8-197">Wszystkie czytników zwrócony przez <xref:System.Xml.XmlReader.Create%2A> są normalizacji czytników.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-197">All of the readers returned by <xref:System.Xml.XmlReader.Create%2A> are normalizing readers.</span></span> <span data-ttu-id="bb6c8-198">Zawsze wykonują normalizacji podział wiersza i pełne normalizacją atrybutów.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-198">They always perform line break normalization and full normalization of attributes.</span></span> <span data-ttu-id="bb6c8-199">Z kolei <xref:System.Xml.XmlReader> zwrócony przez <xref:System.Xml.Linq.XNode.CreateReader%2A> nie jest normalizing czytnika.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-199">In contrast, the <xref:System.Xml.XmlReader> returned by <xref:System.Xml.Linq.XNode.CreateReader%2A> is not a normalizing reader.</span></span> <span data-ttu-id="bb6c8-200">Przekształca żadnego odstępu.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-200">It does not transform any white space.</span></span> <span data-ttu-id="bb6c8-201">Zwraca także atrybutów, w kolejności, że zostały one dodane, a nie w kolejności nazwa atrybutu.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-201">It also returns attributes in the order that they were added, not in attribute name order.</span></span>  
  
 [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)]<span data-ttu-id="bb6c8-202"> nie przechowuje informacji na temat tego, czy atrybuty są domyślne atrybuty.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-202"> does not keep information about whether attributes are default attributes.</span></span> <span data-ttu-id="bb6c8-203"><xref:System.Xml.XmlReader.IsDefault%2A> zawsze zwraca wartość false, niezależnie od tego, czy ten atrybut został wypełniony z wartości domyślnej lub nie.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-203"><xref:System.Xml.XmlReader.IsDefault%2A> will always return false regardless of whether the attribute was populated from a default value or not.</span></span>  
  
 <span data-ttu-id="bb6c8-204">`PUBLIC` i `SYSTEM` pseudo atrybutów na <xref:System.Xml.Linq.XDocumentType> nie są dostępne za pośrednictwem <xref:System.Xml.XmlReader.MoveToAttribute%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-204">The `PUBLIC` and `SYSTEM` pseudo attributes on <xref:System.Xml.Linq.XDocumentType> are not available through the <xref:System.Xml.XmlReader.MoveToAttribute%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="bb6c8-205">Są one dostępne za pośrednictwem tylko <xref:System.Xml.XmlReader.GetAttribute%2A?displayProperty=nameWithType> metody pobierającej kwalifikowana nazwa atrybutu jako parametr.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-205">They are only available through the <xref:System.Xml.XmlReader.GetAttribute%2A?displayProperty=nameWithType> method that takes the qualified name of the attribute as a parameter.</span></span> <span data-ttu-id="bb6c8-206">Jeśli masz pobrać `PUBLIC` lub `SYSTEM` atrybuty, należy użyć <xref:System.Xml.XmlReader.GetAttribute%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-206">If you have to retrieve the `PUBLIC` or `SYSTEM` attributes, you should use the <xref:System.Xml.XmlReader.GetAttribute%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="bb6c8-207">Base64 i BinHex dane nie są obsługiwane.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-207">Base64 and BinHex data are not supported.</span></span> <span data-ttu-id="bb6c8-208">Jeśli próba pobrania tych typów danych (na przykład wywołując <xref:System.Xml.XmlReader.ReadElementContentAsBase64%2A>), zgłosi czytnik <xref:System.NotSupportedException>.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-208">If you attempt to retrieve these types of data (for example, by calling <xref:System.Xml.XmlReader.ReadElementContentAsBase64%2A>), the reader will throw <xref:System.NotSupportedException>.</span></span>  
  
 <span data-ttu-id="bb6c8-209">`xml` Deklaracja nie jest udostępniane przez czytnik.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-209">The `xml` declaration is not surfaced by the reader.</span></span> <span data-ttu-id="bb6c8-210">Podczas odczytu, nie wystąpi węzła typu <xref:System.Xml.XmlNodeType.XmlDeclaration>.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-210">While reading, you will not encounter a node of type <xref:System.Xml.XmlNodeType.XmlDeclaration>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bb6c8-211">Poniższy przykład tworzy drzewo XML, tworzy <xref:System.Xml.XmlReader> za pomocą <xref:System.Xml.Linq.XNode.CreateReader%2A> metody i tworzy <xref:System.Xml.XmlDocument> przy użyciu czytnika.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-211">The following example creates an XML tree, creates an <xref:System.Xml.XmlReader> by using the <xref:System.Xml.Linq.XNode.CreateReader%2A> method, and creates an <xref:System.Xml.XmlDocument> by using the reader.</span></span>  
  
```csharp  
XDocument xmlTree = new XDocument(  
    new XElement("Root",  
        new XAttribute("Att1", "Attribute Content"),  
        new XElement("Child1", 1),  
        new XElement("Child2", 2)  
    )  
);  
XmlReader reader = xmlTree.CreateReader();  
reader.MoveToContent();  
XmlDocument doc = new XmlDocument();  
XmlNode cd = doc.ReadNode(reader);  
doc.AppendChild(cd);  
Console.WriteLine(doc.OuterXml);  
```  
  
```vb  
Dim xmlTree As XDocument =  _   
    <?xml version="1.0" encoding="utf-8" standalone="yes"?>  
        <Root Att1="Attribute Content">  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
        </Root>  
Dim reader As XmlReader = xmlTree.CreateReader()  
reader.MoveToContent()  
Dim doc As XmlDocument = New XmlDocument()  
Dim cd As XmlNode = doc.ReadNode(reader)  
doc.AppendChild(cd)  
Console.WriteLine(doc.OuterXml)  
```  
  
 <span data-ttu-id="bb6c8-212">Ten przykład generuje następujące wyniki:</span><span class="sxs-lookup"><span data-stu-id="bb6c8-212">This example produces the following output:</span></span>  
  
```xml  
<Root Att1="Attribute Content"><Child1>1</Child1><Child2>2</Child2></Root>  
```  
  
 <span data-ttu-id="bb6c8-213">Inny Użyj tej metody jest przekształcenie XSLT.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-213">Another use for this method is to do an XSLT transformation.</span></span> <span data-ttu-id="bb6c8-214">Można utworzyć drzewa XML, Utwórz <xref:System.Xml.XmlReader> z drzewa XML, Utwórz nowy dokument, a następnie utwórz <xref:System.Xml.XmlWriter> która będzie zapisywała do nowego dokumentu.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-214">You can create an XML tree, create an <xref:System.Xml.XmlReader> from the XML tree, create a new document, and create an <xref:System.Xml.XmlWriter> that will write into the new document.</span></span> <span data-ttu-id="bb6c8-215">Następnie można wywołać przekształcenia XSLT, przekazywanie <xref:System.Xml.XmlReader> i <xref:System.Xml.XmlWriter> do przekształcania.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-215">Then, you can invoke the XSLT transformation, passing the <xref:System.Xml.XmlReader> and <xref:System.Xml.XmlWriter> to the transformation.</span></span> <span data-ttu-id="bb6c8-216">Po pomyślnym zakończeniu transformacja, nowe drzewo XML jest wypełniana wyniki transformacji.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-216">After the transformation successfully completes, the new XML tree is populated with the results of the transform.</span></span>  
  
```csharp  
string xslMarkup = @"<?xml version='1.0'?>  
<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='1.0'>  
    <xsl:template match='/Parent'>  
        <Root>  
            <C1>  
            <xsl:value-of select='Child1'/>  
            </C1>  
            <C2>  
            <xsl:value-of select='Child2'/>  
            </C2>  
        </Root>  
    </xsl:template>  
</xsl:stylesheet>";  
  
XDocument xmlTree = new XDocument(  
    new XElement("Parent",  
        new XElement("Child1", "Child1 data"),  
        new XElement("Child2", "Child2 data")  
    )  
);  
  
XDocument newTree = new XDocument();  
using (XmlWriter writer = newTree.CreateWriter()) {  
    // Load the style sheet.  
    XslCompiledTransform xslt = new XslCompiledTransform();  
    xslt.Load(XmlReader.Create(new StringReader(xslMarkup)));  
  
    // Execute the transform and output the results to a writer.  
    xslt.Transform(xmlTree.CreateReader(), writer);  
}  
  
Console.WriteLine(newTree);  
```  
  
```vb  
Dim xslMarkup As XDocument = _   
    <?xml version='1.0'?>  
    <xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='1.0'>  
        <xsl:template match='/Parent'>  
            <Root>  
                <C1>  
                    <xsl:value-of select='Child1'/>  
                </C1>  
                <C2>  
                    <xsl:value-of select='Child2'/>  
                </C2>  
            </Root>  
        </xsl:template>  
    </xsl:stylesheet>  
  
Dim xmlTree As XElement = _   
        <Parent>  
            <Child1>Child1 data</Child1>  
            <Child2>Child2 data</Child2>  
        </Parent>  
  
Dim newTree As XDocument = New XDocument()  
  
Using writer As XmlWriter = newTree.CreateWriter()  
    ' Load the style sheet.  
    Dim xslt As XslCompiledTransform = _  
        New XslCompiledTransform()  
    xslt.Load(xslMarkup.CreateReader())  
  
    ' Execute the transform and output the results to a writer.  
    xslt.Transform(xmlTree.CreateReader(), writer)  
End Using  
  
Console.WriteLine(newTree)  
```  
  
 <span data-ttu-id="bb6c8-217">Ten przykład generuje następujące wyniki:</span><span class="sxs-lookup"><span data-stu-id="bb6c8-217">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <C1>Child1 data</C1>  
  <C2>Child2 data</C2>  
</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateReader">
      <MemberSignature Language="C#" Value="public System.Xml.XmlReader CreateReader (System.Xml.Linq.ReaderOptions readerOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.XmlReader CreateReader(valuetype System.Xml.Linq.ReaderOptions readerOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.CreateReader(System.Xml.Linq.ReaderOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xml::XmlReader ^ CreateReader(System::Xml::Linq::ReaderOptions readerOptions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="readerOptions" Type="System.Xml.Linq.ReaderOptions" />
      </Parameters>
      <Docs>
        <param name="readerOptions">
          <span data-ttu-id="bb6c8-218">A <see cref="T:System.Xml.Linq.ReaderOptions" /> obiekt, który określa, czy pominąć zduplikowanych przestrzeni nazw.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-218">A <see cref="T:System.Xml.Linq.ReaderOptions" /> object that specifies whether to omit duplicate namespaces.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bb6c8-219">Tworzy <see cref="T:System.Xml.XmlReader" /> z opcjami określonymi przez <paramref name="readerOptions" /> parametru.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-219">Creates an <see cref="T:System.Xml.XmlReader" /> with the options specified by the <paramref name="readerOptions" /> parameter.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bb6c8-220">
            <see cref="T:System.Xml.XmlReader" /> Obiektu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-220">An <see cref="T:System.Xml.XmlReader" /> object.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeepEquals">
      <MemberSignature Language="C#" Value="public static bool DeepEquals (System.Xml.Linq.XNode n1, System.Xml.Linq.XNode n2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool DeepEquals(class System.Xml.Linq.XNode n1, class System.Xml.Linq.XNode n2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.DeepEquals(System.Xml.Linq.XNode,System.Xml.Linq.XNode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DeepEquals (n1 As XNode, n2 As XNode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool DeepEquals(System::Xml::Linq::XNode ^ n1, System::Xml::Linq::XNode ^ n2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="n1" Type="System.Xml.Linq.XNode" />
        <Parameter Name="n2" Type="System.Xml.Linq.XNode" />
      </Parameters>
      <Docs>
        <param name="n1">
          <span data-ttu-id="bb6c8-221">Pierwszy <see cref="T:System.Xml.Linq.XNode" /> do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-221">The first <see cref="T:System.Xml.Linq.XNode" /> to compare.</span>
          </span>
        </param>
        <param name="n2">
          <span data-ttu-id="bb6c8-222">Drugi <see cref="T:System.Xml.Linq.XNode" /> do porównania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-222">The second <see cref="T:System.Xml.Linq.XNode" /> to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bb6c8-223">Porównuje wartości dwa węzły, w tym wartości wszystkich węzłów podrzędnych.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-223">Compares the values of two nodes, including the values of all descendant nodes.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bb6c8-224">
            <see langword="true" /> Jeśli węzły są równe; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-224">
              <see langword="true" /> if the nodes are equal; otherwise <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bb6c8-225">Czy dwa węzły są takie same należy ustalić następujące kryteria:</span><span class="sxs-lookup"><span data-stu-id="bb6c8-225">The following criteria determine whether two nodes are equal:</span></span>  
  
-   <span data-ttu-id="bb6c8-226">A `null` węzeł jest równa innej `null` węzła, ale nierówne niż`null` węzła.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-226">A `null` node is equal to another `null` node but unequal to a non-`null` node.</span></span>  
  
-   <span data-ttu-id="bb6c8-227">Dwa <xref:System.Xml.Linq.XNode> obiekty o różnych typach nigdy nie są takie same.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-227">Two <xref:System.Xml.Linq.XNode> objects of different types are never equal.</span></span>  
  
-   <span data-ttu-id="bb6c8-228">Dwa <xref:System.Xml.Linq.XText> węzły są takie same, które zawierają ten sam tekst.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-228">Two <xref:System.Xml.Linq.XText> nodes are equal if they contain the same text.</span></span>  
  
-   <span data-ttu-id="bb6c8-229">Dwa <xref:System.Xml.Linq.XElement> węzły są takie same, gdy mają one taką samą nazwę tagu, ten sam zestaw atrybutów, które mają takie same wartości, a (Ignorowanie komentarze i instrukcji przetwarzania) zawiera dwie sekwencje równej długości równy węzłów zawartości.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-229">Two <xref:System.Xml.Linq.XElement> nodes are equal if they have the same tag name, the same set of attributes with the same values, and (ignoring comments and processing instructions) contain two equal length sequences of equal content nodes.</span></span>  
  
-   <span data-ttu-id="bb6c8-230">Dwa <xref:System.Xml.Linq.XDocument> węzły są takie same, jeśli ich węzłów głównych są takie same.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-230">Two <xref:System.Xml.Linq.XDocument> nodes are equal if their root nodes are equal.</span></span>  
  
-   <span data-ttu-id="bb6c8-231">Dwa <xref:System.Xml.Linq.XComment> węzły są takie same, które zawierają ten sam tekst komentarza.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-231">Two <xref:System.Xml.Linq.XComment> nodes are equal if they contain the same comment text.</span></span>  
  
-   <span data-ttu-id="bb6c8-232">Dwa <xref:System.Xml.Linq.XProcessingInstruction> węzły są takie same, jeśli mają one taką samą docelowych i danych.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-232">Two <xref:System.Xml.Linq.XProcessingInstruction> nodes are equal if they have the same target and data.</span></span>  
  
-   <span data-ttu-id="bb6c8-233">Dwa <xref:System.Xml.Linq.XDocumentType> węzły są takie same Jeśli mieć tej samej nazwy, identyfikator publiczny, identyfikator systemowy i podzestawu wewnętrznego.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-233">Two <xref:System.Xml.Linq.XDocumentType> nodes are equal if the have the same name, public ID, system ID, and internal subset.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bb6c8-234">W poniższym przykładzie użyto tej metody, aby porównać dwa drzewa XML.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-234">The following example uses this method to compare two XML trees.</span></span>  
  
```csharp  
XElement xmlTree1 = new XElement("Root",  
    new XAttribute("Att1", 1),  
    new XAttribute("Att2", 2),  
    new XElement("Child1", 1),  
    new XElement("Child2", "some content")  
);  
XElement xmlTree2 = new XElement("Root",  
    new XAttribute("Att1", 1),  
    new XAttribute("Att2", 2),  
    new XElement("Child1", 1),  
    new XElement("Child2", "some content")  
);  
Console.WriteLine(XNode.DeepEquals(xmlTree1, xmlTree2));  
```  
  
```vb  
Dim xmlTree1 As XElement = _   
        <Root Att1="1" Att2="2">  
            <Child1>1</Child1>  
            <Child2>some content</Child2>  
        </Root>  
  
Dim xmlTree2 As XElement = _   
        <Root Att1="1" Att2="2">  
            <Child1>1</Child1>  
            <Child2>some content</Child2>  
        </Root>  
  
Console.WriteLine(XNode.DeepEquals(xmlTree1, xmlTree2))  
```  
  
 <span data-ttu-id="bb6c8-235">Ten przykład generuje następujące wyniki:</span><span class="sxs-lookup"><span data-stu-id="bb6c8-235">This example produces the following output:</span></span>  
  
```  
True  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DocumentOrderComparer">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XNodeDocumentOrderComparer DocumentOrderComparer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Xml.Linq.XNodeDocumentOrderComparer DocumentOrderComparer" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XNode.DocumentOrderComparer" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DocumentOrderComparer As XNodeDocumentOrderComparer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Xml::Linq::XNodeDocumentOrderComparer ^ DocumentOrderComparer { System::Xml::Linq::XNodeDocumentOrderComparer ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XNodeDocumentOrderComparer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="bb6c8-236">Pobiera moduł porównujący, który można porównać pozycji względnej z dwóch węzłów.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-236">Gets a comparer that can compare the relative position of two nodes.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="bb6c8-237">
            <see cref="T:System.Xml.Linq.XNodeDocumentOrderComparer" /> Porównujące względne położenie dwa węzły.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-237">An <see cref="T:System.Xml.Linq.XNodeDocumentOrderComparer" /> that can compare the relative position of two nodes.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bb6c8-238">Ta właściwość jest głównie używana wewnętrznie do implementacja <xref:System.Xml.Linq.Extensions.InDocumentOrder%2A> — metoda rozszerzenia.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-238">This property is primarily used internally for implementing the <xref:System.Xml.Linq.Extensions.InDocumentOrder%2A> extension method.</span></span> <span data-ttu-id="bb6c8-239">Zalecanym podejściem jest zamiast bezpośrednio za pomocą tej właściwości przy użyciu tej metody rozszerzenia.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-239">The recommended approach is to use that extension method instead of using this property directly.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bb6c8-240">Poniższy przykład tworzy drzewo XML z niektórych elementów.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-240">The following example creates an XML tree with some elements.</span></span> <span data-ttu-id="bb6c8-241">Następnie tworzy <xref:System.Collections.Generic.List%601> z <xref:System.Xml.Linq.XNode> losowo zawiera niektóre elementy z drzewa XML.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-241">It then creates a <xref:System.Collections.Generic.List%601> of <xref:System.Xml.Linq.XNode> that contains some elements from the XML tree at random.</span></span> <span data-ttu-id="bb6c8-242">Sortuje listę za pomocą tej właściwości można pobrać <xref:System.Xml.Linq.XNodeDocumentOrderComparer>, który implementuje <xref:System.Collections.IComparer?displayProperty=nameWithType> i <xref:System.Collections.Generic.IComparer%601?displayProperty=nameWithType> interfejsów.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-242">It sorts the list, using this property to retrieve a <xref:System.Xml.Linq.XNodeDocumentOrderComparer>, which implements the <xref:System.Collections.IComparer?displayProperty=nameWithType> and <xref:System.Collections.Generic.IComparer%601?displayProperty=nameWithType> interfaces.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5)  
);  
  
List<XNode> nodeList = new List<XNode>();  
nodeList.Add(xmlTree.Element("Child5"));  
nodeList.Add(xmlTree.Element("Child3"));  
nodeList.Add(xmlTree.Element("Child1"));  
  
// Sort nodes in document order.  
nodeList.Sort(XNode.DocumentOrderComparer);  
  
foreach (XElement el in nodeList)  
    Console.WriteLine(el);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <Child3>3</Child3>  
            <Child4>4</Child4>  
            <Child5>5</Child5>  
        </Root>  
  
Dim nodeList As List(Of XNode) = New List(Of XNode)()  
nodeList.Add(xmlTree.Element("Child5"))  
nodeList.Add(xmlTree.Element("Child3"))  
nodeList.Add(xmlTree.Element("Child1"))  
  
' Sort nodes in document order.  
nodeList.Sort(XNode.DocumentOrderComparer)  
  
For Each el In nodeList  
    Console.WriteLine(el)  
Next  
```  
  
 <span data-ttu-id="bb6c8-243">Ten przykład generuje następujące wyniki:</span><span class="sxs-lookup"><span data-stu-id="bb6c8-243">This example produces the following output:</span></span>  
  
```  
<Child1>1</Child1>  
<Child3>3</Child3>  
<Child5>5</Child5>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ElementsAfterSelf">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="bb6c8-244">Zwraca kolekcję równorzędnym elementy tego węzła, w kolejności dokumentu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-244">Returns a collection of the sibling elements after this node, in document order.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bb6c8-245">Ta metoda używa odroczonego wykonania.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-245">This method uses deferred execution.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="ElementsAfterSelf">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; ElementsAfterSelf ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; ElementsAfterSelf() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.ElementsAfterSelf" />
      <MemberSignature Language="VB.NET" Value="Public Function ElementsAfterSelf () As IEnumerable(Of XElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XElement ^&gt; ^ ElementsAfterSelf();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="bb6c8-246">Zwraca kolekcję równorzędnym elementy tego węzła, w kolejności dokumentu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-246">Returns a collection of the sibling elements after this node, in document order.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bb6c8-247">
            <see cref="T:System.Collections.Generic.IEnumerable`1" /> z <see cref="T:System.Xml.Linq.XElement" /> z elementów równorzędnych po tego węzła, w kolejności dokumentu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-247">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:System.Xml.Linq.XElement" /> of the sibling elements after this node, in document order.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bb6c8-248">Ta metoda obejmuje tylko elementów równorzędnych w zwracanej kolekcji.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-248">This method only includes siblings in the returned collection.</span></span> <span data-ttu-id="bb6c8-249">Nie ma obiektów podrzędnych.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-249">It does not include descendants.</span></span>  
  
 <span data-ttu-id="bb6c8-250">Ta metoda używa odroczonego wykonania.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-250">This method uses deferred execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bb6c8-251">Poniższy przykład tworzy element z niektórych zawartością złożoną.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-251">The following example creates an element with some complex content.</span></span> <span data-ttu-id="bb6c8-252">Następnie używa tej metody do pobierania węzłów w kolejności dokumentu.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-252">It then uses this method to retrieve the nodes in document order.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XText("Text content."),  
    new XElement("Child1", "child1 content"),  
    new XElement("Child2", "child2 content"),  
    new XElement("Child3", "child3 content"),  
    new XText("More text content."),  
    new XElement("Child4", "child4 content"),  
    new XElement("Child5", "child5 content")  
);  
XElement child = xmlTree.Element("Child3");  
IEnumerable<XElement> elements = child.ElementsAfterSelf();  
foreach (XElement el in elements)  
    Console.WriteLine(el.Name);  
```  
  
```vb  
Dim xmlTree As XElement = _  
        <Root>Text content.  
            <Child1>child1 content</Child1>  
            <Child2>child2 content</Child2>  
            <Child3>child3 content</Child3>More text content.  
            <Child4>child4 content</Child4>  
            <Child5>child5 content</Child5>  
        </Root>  
  
Dim child As XElement = xmlTree.<Child3>(0)  
Dim elements As IEnumerable(Of XElement) = child.ElementsAfterSelf()  
For Each el In elements  
    Console.WriteLine(el.Name)  
Next  
```  
  
 <span data-ttu-id="bb6c8-253">Ten przykład generuje następujące wyniki:</span><span class="sxs-lookup"><span data-stu-id="bb6c8-253">This example produces the following output:</span></span>  
  
```  
Child4  
Child5  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ElementsAfterSelf">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; ElementsAfterSelf (System.Xml.Linq.XName name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; ElementsAfterSelf(class System.Xml.Linq.XName name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.ElementsAfterSelf(System.Xml.Linq.XName)" />
      <MemberSignature Language="VB.NET" Value="Public Function ElementsAfterSelf (name As XName) As IEnumerable(Of XElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XElement ^&gt; ^ ElementsAfterSelf(System::Xml::Linq::XName ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="bb6c8-254">
            <see cref="T:System.Xml.Linq.XName" /> Do dopasowania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-254">The <see cref="T:System.Xml.Linq.XName" /> to match.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bb6c8-255">Zwraca kolekcję filtrowane elementu równorzędnego elementy tego węzła, w kolejności dokumentu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-255">Returns a filtered collection of the sibling elements after this node, in document order.</span>
          </span>
          <span data-ttu-id="bb6c8-256">Tylko elementy, które pasują do <see cref="T:System.Xml.Linq.XName" /> znajdują się w kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-256">Only elements that have a matching <see cref="T:System.Xml.Linq.XName" /> are included in the collection.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bb6c8-257">
            <see cref="T:System.Collections.Generic.IEnumerable`1" /> z <see cref="T:System.Xml.Linq.XElement" /> z elementów równorzędnych po tego węzła, w kolejności dokumentu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-257">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:System.Xml.Linq.XElement" /> of the sibling elements after this node, in document order.</span>
          </span>
          <span data-ttu-id="bb6c8-258">Tylko elementy, które pasują do <see cref="T:System.Xml.Linq.XName" /> znajdują się w kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-258">Only elements that have a matching <see cref="T:System.Xml.Linq.XName" /> are included in the collection.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bb6c8-259">Ta metoda obejmuje tylko elementów równorzędnych w zwracanej kolekcji.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-259">This method only includes siblings in the returned collection.</span></span> <span data-ttu-id="bb6c8-260">Nie ma obiektów podrzędnych.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-260">It does not include descendants.</span></span>  
  
 <span data-ttu-id="bb6c8-261">Ta metoda używa odroczonego wykonania.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-261">This method uses deferred execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bb6c8-262">Poniższy przykład tworzy element z niektórych zawartością złożoną.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-262">The following example creates an element with some complex content.</span></span> <span data-ttu-id="bb6c8-263">Następnie używa tej metody można pobrać elementów równorzędnych w kolejności dokumentu.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-263">It then uses this method to retrieve the sibling elements, in document order.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XText("Text content."),  
    new XElement("Child1", "child1 content"),  
    new XElement("Child2", "child2 content"),  
    new XElement("Child3", "child3 content"),  
    new XText("More text content."),  
    new XElement("Child4", "child4 content"),  
    new XElement("Child5", "child5 content")  
);  
XElement child = xmlTree.Element("Child3");  
IEnumerable<XElement> elements = child.ElementsAfterSelf("Child4");  
foreach (XElement el in elements)  
    Console.WriteLine(el.Name);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>Text content.  
            <Child1>child1 content</Child1>  
            <Child2>child2 content</Child2>  
            <Child3>child3 content</Child3>More text content.  
            <Child4>child4 content</Child4>  
            <Child5>child5 content</Child5>  
        </Root>  
  
Dim child As XElement = xmlTree.<Child3>(0)  
Dim elements As IEnumerable(Of XElement) = child.ElementsAfterSelf("Child4")  
  
For Each el In elements  
    Console.WriteLine(el.Name)  
Next  
```  
  
 <span data-ttu-id="bb6c8-264">Ten przykład generuje następujące wyniki:</span><span class="sxs-lookup"><span data-stu-id="bb6c8-264">This example produces the following output:</span></span>  
  
```  
Child4  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ElementsBeforeSelf">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="bb6c8-265">Zwraca kolekcję równorzędnym elementów przed tego węzła, w kolejności dokumentu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-265">Returns a collection of the sibling elements before this node, in document order.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bb6c8-266">Ta metoda używa odroczonego wykonania.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-266">This method uses deferred execution.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="ElementsBeforeSelf">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; ElementsBeforeSelf ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; ElementsBeforeSelf() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.ElementsBeforeSelf" />
      <MemberSignature Language="VB.NET" Value="Public Function ElementsBeforeSelf () As IEnumerable(Of XElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XElement ^&gt; ^ ElementsBeforeSelf();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="bb6c8-267">Zwraca kolekcję równorzędnym elementów przed tego węzła, w kolejności dokumentu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-267">Returns a collection of the sibling elements before this node, in document order.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bb6c8-268">
            <see cref="T:System.Collections.Generic.IEnumerable`1" /> z <see cref="T:System.Xml.Linq.XElement" /> z elementów równorzędnych przed tego węzła, w kolejności dokumentu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-268">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:System.Xml.Linq.XElement" /> of the sibling elements before this node, in document order.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bb6c8-269">Ta metoda obejmuje tylko elementów równorzędnych w zwracanej kolekcji.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-269">This method only includes siblings in the returned collection.</span></span> <span data-ttu-id="bb6c8-270">Nie ma obiektów podrzędnych.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-270">It does not include descendants.</span></span>  
  
 <span data-ttu-id="bb6c8-271">Ta metoda używa odroczonego wykonania.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-271">This method uses deferred execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bb6c8-272">W poniższym przykładzie użyto metody tej osi.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-272">The following example uses this axis method.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XText("Text content."),  
    new XElement("Child1", "child1 content"),  
    new XElement("Child2", "child2 content"),  
    new XElement("Child3", "child3 content"),  
    new XText("More text content."),  
    new XElement("Child4", "child4 content"),  
    new XElement("Child5", "child5 content")  
);  
XElement child = xmlTree.Element("Child3");  
IEnumerable<XElement> elements = child.ElementsBeforeSelf();  
foreach (XElement el in elements)  
    Console.WriteLine(el.Name);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>Text content.  
            <Child1>child1 content</Child1>  
            <Child2>child2 content</Child2>  
            <Child3>child3 content</Child3>More text content.  
            <Child4>child4 content</Child4>  
            <Child5>child5 content</Child5>  
        </Root>  
  
Dim child As XElement = xmlTree.<Child3>(0)  
Dim elements As IEnumerable(Of XElement) = child.ElementsBeforeSelf()  
  
For Each el In elements  
    Console.WriteLine(el.Name)  
Next  
```  
  
 <span data-ttu-id="bb6c8-273">Ten przykład generuje następujące wyniki:</span><span class="sxs-lookup"><span data-stu-id="bb6c8-273">This example produces the following output:</span></span>  
  
```  
Child1  
Child2  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ElementsBeforeSelf">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; ElementsBeforeSelf (System.Xml.Linq.XName name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; ElementsBeforeSelf(class System.Xml.Linq.XName name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.ElementsBeforeSelf(System.Xml.Linq.XName)" />
      <MemberSignature Language="VB.NET" Value="Public Function ElementsBeforeSelf (name As XName) As IEnumerable(Of XElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XElement ^&gt; ^ ElementsBeforeSelf(System::Xml::Linq::XName ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="bb6c8-274">
            <see cref="T:System.Xml.Linq.XName" /> Do dopasowania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-274">The <see cref="T:System.Xml.Linq.XName" /> to match.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bb6c8-275">Zwraca kolekcję filtrowane elementu równorzędnego elementów przed tego węzła, w kolejności dokumentu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-275">Returns a filtered collection of the sibling elements before this node, in document order.</span>
          </span>
          <span data-ttu-id="bb6c8-276">Tylko elementy, które pasują do <see cref="T:System.Xml.Linq.XName" /> znajdują się w kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-276">Only elements that have a matching <see cref="T:System.Xml.Linq.XName" /> are included in the collection.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bb6c8-277">
            <see cref="T:System.Collections.Generic.IEnumerable`1" /> z <see cref="T:System.Xml.Linq.XElement" /> z elementów równorzędnych przed tego węzła, w kolejności dokumentu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-277">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:System.Xml.Linq.XElement" /> of the sibling elements before this node, in document order.</span>
          </span>
          <span data-ttu-id="bb6c8-278">Tylko elementy, które pasują do <see cref="T:System.Xml.Linq.XName" /> znajdują się w kolekcji.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-278">Only elements that have a matching <see cref="T:System.Xml.Linq.XName" /> are included in the collection.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bb6c8-279">Ta metoda obejmuje tylko elementów równorzędnych w zwracanej kolekcji.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-279">This method only includes siblings in the returned collection.</span></span> <span data-ttu-id="bb6c8-280">Nie ma obiektów podrzędnych.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-280">It does not include descendants.</span></span>  
  
 <span data-ttu-id="bb6c8-281">Ta metoda używa odroczonego wykonania.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-281">This method uses deferred execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bb6c8-282">W poniższym przykładzie użyto tej metody.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-282">The following example uses this method.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XText("Text content."),  
    new XElement("Child1", "child1 content"),  
    new XElement("Child2", "child2 content"),  
    new XElement("Child3", "child3 content"),  
    new XText("More text content."),  
    new XElement("Child4", "child4 content"),  
    new XElement("Child5", "child5 content")  
);  
XElement child = xmlTree.Element("Child3");  
IEnumerable<XElement> elements = child.ElementsBeforeSelf("Child2");  
foreach (XElement el in elements)  
    Console.WriteLine(el.Name);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>Text content.  
            <Child1>child1 content</Child1>  
            <Child2>child2 content</Child2>  
            <Child3>child3 content</Child3>More text content.  
            <Child4>child4 content</Child4>  
            <Child5>child5 content</Child5>  
        </Root>  
  
Dim child As XElement = xmlTree.<Child3>(0)  
Dim elements As IEnumerable(Of XElement) = child.ElementsBeforeSelf("Child2")  
  
For Each el In elements  
    Console.WriteLine(el.Name)  
Next  
```  
  
 <span data-ttu-id="bb6c8-283">Ten przykład generuje następujące wyniki:</span><span class="sxs-lookup"><span data-stu-id="bb6c8-283">This example produces the following output:</span></span>  
  
```  
Child2  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EqualityComparer">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XNodeEqualityComparer EqualityComparer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Xml.Linq.XNodeEqualityComparer EqualityComparer" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XNode.EqualityComparer" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property EqualityComparer As XNodeEqualityComparer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Xml::Linq::XNodeEqualityComparer ^ EqualityComparer { System::Xml::Linq::XNodeEqualityComparer ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XNodeEqualityComparer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="bb6c8-284">Pobiera moduł porównujący, który można porównać dwa węzły równości wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-284">Gets a comparer that can compare two nodes for value equality.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="bb6c8-285">A <see cref="T:System.Xml.Linq.XNodeEqualityComparer" /> porównujące dwa węzły równości wartości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-285">A <see cref="T:System.Xml.Linq.XNodeEqualityComparer" /> that can compare two nodes for value equality.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="bb6c8-286">W poniższym przykładzie użyto tej właściwości można pobrać <xref:System.Xml.Linq.XNodeEqualityComparer>, który implementuje <xref:System.Collections.IEqualityComparer?displayProperty=nameWithType> i <xref:System.Collections.Generic.IEqualityComparer%601?displayProperty=nameWithType> interfejsów.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-286">The following example uses this property to retrieve an <xref:System.Xml.Linq.XNodeEqualityComparer>, which implements the <xref:System.Collections.IEqualityComparer?displayProperty=nameWithType> and <xref:System.Collections.Generic.IEqualityComparer%601?displayProperty=nameWithType> interfaces.</span></span> <span data-ttu-id="bb6c8-287">Tworzy słownik, który używa tej właściwości.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-287">It creates a dictionary that uses this property.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5)  
);  
  
Dictionary<XNode, string> nodeDictionary = new Dictionary<XNode, string>(XNode.EqualityComparer);  
nodeDictionary.Add(xmlTree.Element("Child5"), "Child 5 Information");  
nodeDictionary.Add(xmlTree.Element("Child3"), "Child 3 Information");  
nodeDictionary.Add(xmlTree.Element("Child1"), "Child 1 Information");  
  
string str = nodeDictionary[xmlTree.Element("Child3")];  
Console.WriteLine(str);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <Child3>3</Child3>  
            <Child4>4</Child4>  
            <Child5>5</Child5>  
        </Root>  
  
Dim nodeDictionary As Dictionary(Of XNode, String) = New Dictionary(Of XNode, String)(XNode.EqualityComparer)  
nodeDictionary.Add(xmlTree.Element("Child5"), "Child 5 Information")  
nodeDictionary.Add(xmlTree.Element("Child3"), "Child 3 Information")  
nodeDictionary.Add(xmlTree.Element("Child1"), "Child 1 Information")  
  
Dim str As String = nodeDictionary(xmlTree.Element("Child3"))  
Console.WriteLine(str)  
```  
  
 <span data-ttu-id="bb6c8-288">Ten przykład generuje następujące wyniki:</span><span class="sxs-lookup"><span data-stu-id="bb6c8-288">This example produces the following output:</span></span>  
  
```  
Child 3 Information  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAfter">
      <MemberSignature Language="C#" Value="public bool IsAfter (System.Xml.Linq.XNode node);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsAfter(class System.Xml.Linq.XNode node) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.IsAfter(System.Xml.Linq.XNode)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsAfter (node As XNode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsAfter(System::Xml::Linq::XNode ^ node);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Xml.Linq.XNode" />
      </Parameters>
      <Docs>
        <param name="node">
          <span data-ttu-id="bb6c8-289">
            <see cref="T:System.Xml.Linq.XNode" /> Do porównania dla kolejności dokumentu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-289">The <see cref="T:System.Xml.Linq.XNode" /> to compare for document order.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bb6c8-290">Określa, czy bieżący węzeł widoczny po określony węzeł pod względem kolejności dokumentu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-290">Determines if the current node appears after a specified node in terms of document order.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bb6c8-291">
            <see langword="true" /> Jeśli ten węzeł jest dostępny po określony węzeł; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-291">
              <see langword="true" /> if this node appears after the specified node; otherwise <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bb6c8-292"><xref:System.Xml.Linq.XContainer> Przechowuje węzły podrzędne jako listę pojedynczo połączone <xref:System.Xml.Linq.XNode> obiektów.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-292">The <xref:System.Xml.Linq.XContainer> stores its child nodes as a singly-linked list of <xref:System.Xml.Linq.XNode> objects.</span></span> <span data-ttu-id="bb6c8-293">Oznacza to, że <xref:System.Xml.Linq.XNode.CompareDocumentOrder%2A> metody muszą przejść elementów nadrzędnych elementu dwa węzły są porównywane aż do znalezienia Wspólnemu elementowi nadrzędnemu.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-293">This means that the <xref:System.Xml.Linq.XNode.CompareDocumentOrder%2A> method must traverse the ancestors of the two nodes being compared until it finds the common parent.</span></span> <span data-ttu-id="bb6c8-294">Następnie należy go przechodzenie listy Wspólnemu elementowi nadrzędnemu węzłów podrzędnych można określić kolejność dwa węzły są porównywane.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-294">Then it must traverse the list of the common parent’s child nodes to determine the order of the two nodes being compared.</span></span> <span data-ttu-id="bb6c8-295">W związku z tym za pomocą tej metody może wpłynąć na wydajność.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-295">Therefore, using this method might affect your performance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bb6c8-296">W poniższym przykładzie użyto tej metody.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-296">The following example uses this method.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XText("Text content."),  
    new XElement("Child1", "child1 content"),  
    new XElement("Child2", "child2 content"),  
    new XElement("Child3", "child3 content"),  
    new XText("More text content."),  
    new XElement("Child4", "child4 content"),  
    new XElement("Child5", "child5 content")  
);  
XElement child3 = xmlTree.Element("Child3");  
XElement child5 = xmlTree.Element("Child5");  
if (child5.IsAfter(child3))  
    Console.WriteLine("Child5 is after Child3");  
else  
    Console.WriteLine("Child5 is not after Child3");  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>Text content.  
            <Child1>child1 content</Child1>  
            <Child2>child2 content</Child2>  
            <Child3>child3 content</Child3>More text content.  
            <Child4>child4 content</Child4>  
            <Child5>child5 content</Child5>  
        </Root>  
  
Dim child3 As XElement = xmlTree.<Child3>(0)  
Dim child5 As XElement = xmlTree.<Child5>(0)  
If (child5.IsAfter(child3)) Then  
    Console.WriteLine("Child5 is after Child3")  
Else  
    Console.WriteLine("Child5 is not after Child3")  
End If  
```  
  
 <span data-ttu-id="bb6c8-297">Ten przykład generuje następujące wyniki:</span><span class="sxs-lookup"><span data-stu-id="bb6c8-297">This example produces the following output:</span></span>  
  
```  
Child5 is after Child3  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBefore">
      <MemberSignature Language="C#" Value="public bool IsBefore (System.Xml.Linq.XNode node);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsBefore(class System.Xml.Linq.XNode node) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.IsBefore(System.Xml.Linq.XNode)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsBefore (node As XNode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsBefore(System::Xml::Linq::XNode ^ node);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Xml.Linq.XNode" />
      </Parameters>
      <Docs>
        <param name="node">
          <span data-ttu-id="bb6c8-298">
            <see cref="T:System.Xml.Linq.XNode" /> Do porównania dla kolejności dokumentu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-298">The <see cref="T:System.Xml.Linq.XNode" /> to compare for document order.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bb6c8-299">Określa, czy bieżący węzeł widoczny przed określony węzeł pod względem kolejności dokumentu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-299">Determines if the current node appears before a specified node in terms of document order.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bb6c8-300">
            <see langword="true" /> Jeśli ten węzeł jest dostępny przed określony węzeł; w przeciwnym razie <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-300">
              <see langword="true" /> if this node appears before the specified node; otherwise <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bb6c8-301"><xref:System.Xml.Linq.XContainer> Przechowuje węzły podrzędne jako listę pojedynczo połączone <xref:System.Xml.Linq.XNode> obiektów.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-301">The <xref:System.Xml.Linq.XContainer> stores its child nodes as a singly-linked list of <xref:System.Xml.Linq.XNode> objects.</span></span> <span data-ttu-id="bb6c8-302">Oznacza to, że <xref:System.Xml.Linq.XNode.IsBefore%2A> metody muszą przejść elementów nadrzędnych elementu dwa węzły są porównywane aż do znalezienia Wspólnemu elementowi nadrzędnemu.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-302">This means that the <xref:System.Xml.Linq.XNode.IsBefore%2A> method must traverse the ancestors of the two nodes being compared until it finds the common parent.</span></span> <span data-ttu-id="bb6c8-303">Następnie należy go przechodzenie listy Wspólnemu elementowi nadrzędnemu węzłów podrzędnych można określić kolejność dwa węzły są porównywane.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-303">Then it must traverse the list of the common parent’s child nodes to determine the order of the two nodes being compared.</span></span> <span data-ttu-id="bb6c8-304">W związku z tym za pomocą tej metody może wpłynąć na wydajność.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-304">Therefore, using this method might affect your performance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bb6c8-305">W poniższym przykładzie użyto tej metody.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-305">The following example uses this method.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XText("Text content."),  
    new XElement("Child1", "child1 content"),  
    new XElement("Child2", "child2 content"),  
    new XElement("Child3", "child3 content"),  
    new XText("More text content."),  
    new XElement("Child4", "child4 content"),  
    new XElement("Child5", "child5 content")  
);  
XElement child3 = xmlTree.Element("Child3");  
XElement child5 = xmlTree.Element("Child5");  
if (child5.IsBefore(child3))  
    Console.WriteLine("Child5 is before Child3");  
else  
    Console.WriteLine("Child5 is not before Child3");  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>Text content.  
            <Child1>child1 content</Child1>  
            <Child2>child2 content</Child2>  
            <Child3>child3 content</Child3>More text content.  
            <Child4>child4 content</Child4>  
            <Child5>child5 content</Child5>  
        </Root>  
  
Dim child3 As XElement = xmlTree.<Child3>(0)  
Dim child5 As XElement = xmlTree.<Child5>(0)  
If (child5.IsBefore(child3)) Then  
    Console.WriteLine("Child5 is before Child3")  
Else  
    Console.WriteLine("Child5 is not before Child3")  
End If  
```  
  
 <span data-ttu-id="bb6c8-306">Ten przykład generuje następujące wyniki:</span><span class="sxs-lookup"><span data-stu-id="bb6c8-306">This example produces the following output:</span></span>  
  
```  
Child5 is not before Child3  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NextNode">
      <MemberSignature Language="C#" Value="public System.Xml.Linq.XNode NextNode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Linq.XNode NextNode" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XNode.NextNode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NextNode As XNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::Linq::XNode ^ NextNode { System::Xml::Linq::XNode ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XNode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="bb6c8-307">Pobiera węzeł równorzędny next tego węzła.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-307">Gets the next sibling node of this node.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="bb6c8-308">
            <see cref="T:System.Xml.Linq.XNode" /> Zawierający następny węzeł równorzędny.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-308">The <see cref="T:System.Xml.Linq.XNode" /> that contains the next sibling node.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bb6c8-309">Jeśli <xref:System.Xml.Linq.XNode> jest nie ma rekordu nadrzędnego, lub jeśli nie ma żadnego węzła dalej, ta właściwość zwraca `null`.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-309">If this <xref:System.Xml.Linq.XNode> does not have a parent, or if there is no next node, this property returns `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bb6c8-310">W poniższym przykładzie użyto tej właściwości pętli węzłów.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-310">The following example uses this property to loop through nodes.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XText("Some Text"),  
    new XElement("Child2",  
        2,  
        new XElement("GrandChild", "GrandChild Content")  
    ),  
    new XComment("a comment"),  
    new XElement("Child3")  
);  
XNode node = xmlTree.Element("Child2");  
do {  
    StringBuilder sb = new StringBuilder();  
    sb.Append(String.Format("NodeType: {0}", node.NodeType.ToString().PadRight(10)));  
    switch (node.NodeType)  
    {  
        case XmlNodeType.Text:  
            sb.Append((node as XText).Value);  
            break;  
        case XmlNodeType.Element:  
            sb.Append((node as XElement).Name);  
            break;  
        case XmlNodeType.Comment:  
            sb.Append((node as XComment).Value);  
            break;  
    }  
    Console.WriteLine(sb.ToString());  
}  
while ((node = node.NextNode) != null);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>1</Child1>Some Text  
            <Child2>2  
                <GrandChild>GrandChild Content</GrandChild>  
            </Child2>  
            <!--a comment-->  
            <Child3>3</Child3>  
        </Root>  
  
Dim node As XNode = xmlTree.Element("Child2")  
Do  
    Dim sb As StringBuilder = New StringBuilder()  
    sb.Append(String.Format("NodeType: {0}", node.NodeType.ToString().PadRight(10)))  
    Select Case node.NodeType  
        Case XmlNodeType.Text  
            sb.Append(DirectCast(node, XText).Value)  
        Case XmlNodeType.Element  
            sb.Append(DirectCast(node, XElement).Name)  
        Case XmlNodeType.Comment  
            sb.Append(DirectCast(node, XComment).Value)  
    End Select  
    Console.WriteLine(sb.ToString())  
  
    node = node.NextNode  
Loop While (Not (node Is Nothing))  
```  
  
 <span data-ttu-id="bb6c8-311">Ten przykład generuje następujące wyniki:</span><span class="sxs-lookup"><span data-stu-id="bb6c8-311">This example produces the following output:</span></span>  
  
```  
NodeType: Element   Child2  
NodeType: Comment   a comment  
NodeType: Element   Child3  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NodesAfterSelf">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XNode&gt; NodesAfterSelf ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XNode&gt; NodesAfterSelf() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.NodesAfterSelf" />
      <MemberSignature Language="VB.NET" Value="Public Function NodesAfterSelf () As IEnumerable(Of XNode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XNode ^&gt; ^ NodesAfterSelf();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XNode&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="bb6c8-312">Zwraca kolekcję równorzędnym węzły tego węzła, w kolejności dokumentu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-312">Returns a collection of the sibling nodes after this node, in document order.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bb6c8-313">
            <see cref="T:System.Collections.Generic.IEnumerable`1" /> z <see cref="T:System.Xml.Linq.XNode" /> węzły równorzędne po tego węzła, w kolejności dokumentu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-313">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:System.Xml.Linq.XNode" /> of the sibling nodes after this node, in document order.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bb6c8-314">Ta metoda obejmuje tylko elementów równorzędnych w zwracanej kolekcji.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-314">This method only includes siblings in the returned collection.</span></span> <span data-ttu-id="bb6c8-315">Nie ma obiektów podrzędnych.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-315">It does not include descendants.</span></span>  
  
 <span data-ttu-id="bb6c8-316">Ta metoda używa odroczonego wykonania.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-316">This method uses deferred execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bb6c8-317">Poniższy przykład tworzy drzewo XML, a następnie wysyła zapytanie do drzewa, za pomocą tej metody osi.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-317">The following example creates an XML tree, and then queries the tree using this axis method.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XText("Text content."),  
    new XElement("Child1", "child1 content"),  
    new XElement("Child2", "child2 content"),  
    new XText("More text content."),  
    new XElement("child3", "child3 content")  
);  
XElement child = xmlTree.Element("Child2");  
IEnumerable<XNode> nodes =  
    from node in child.NodesAfterSelf()  
    select node;  
foreach (XNode node in nodes)  
{  
    Console.WriteLine("Node type: {0}  {1}",  
        node.NodeType,  
        node.NodeType == XmlNodeType.Text ? (node as XText).Value : "");  
}  
```  
  
```vb  
Dim xmlTree As XElement = New XElement("Root", _New XText("Text content."), _  
    New XElement("Child1", "child1 content"), _  
    New XElement("Child2", "child2 content"), _  
    New XText("More text content."), _  
    New XElement("child3", "child3 content") _  
)  
  
Dim child As XElement = xmlTree.Element("Child2")  
Dim nodes As IEnumerable(Of XNode) = _  
    From node In child.NodesAfterSelf() _  
    Select node  
For Each node As XNode In nodes  
    Dim s As String = ""  
    If node.NodeType = XmlNodeType.Text Then  
        s = DirectCast(node, XText).Value  
    End If  
    Console.WriteLine("Node type: {0}  {1}", node.NodeType, s)  
Next  
```  
  
 <span data-ttu-id="bb6c8-318">Ten przykład generuje następujące wyniki:</span><span class="sxs-lookup"><span data-stu-id="bb6c8-318">This example produces the following output:</span></span>  
  
```  
Node type: Text  More text content.  
Node type: Element  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NodesBeforeSelf">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XNode&gt; NodesBeforeSelf ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XNode&gt; NodesBeforeSelf() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.NodesBeforeSelf" />
      <MemberSignature Language="VB.NET" Value="Public Function NodesBeforeSelf () As IEnumerable(Of XNode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XNode ^&gt; ^ NodesBeforeSelf();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XNode&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="bb6c8-319">Zwraca kolekcję równorzędnym węzły przed tego węzła, w kolejności dokumentu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-319">Returns a collection of the sibling nodes before this node, in document order.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bb6c8-320">
            <see cref="T:System.Collections.Generic.IEnumerable`1" /> z <see cref="T:System.Xml.Linq.XNode" /> węzły równorzędne przed tego węzła, w kolejności dokumentu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-320">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:System.Xml.Linq.XNode" /> of the sibling nodes before this node, in document order.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bb6c8-321">Ta metoda obejmuje tylko elementów równorzędnych w zwracanej kolekcji.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-321">This method only includes siblings in the returned collection.</span></span> <span data-ttu-id="bb6c8-322">Nie ma obiektów podrzędnych.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-322">It does not include descendants.</span></span>  
  
 <span data-ttu-id="bb6c8-323">Ta metoda używa odroczonego wykonania.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-323">This method uses deferred execution.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bb6c8-324">Poniższy przykład tworzy drzewo XML, a następnie wysyła zapytanie do drzewa, za pomocą tej metody osi.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-324">The following example creates an XML tree, and then queries the tree using this axis method.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XText("Text content."),  
    new XElement("Child1", "child1 content"),  
    new XElement("Child2", "child2 content"),  
    new XText("More text content."),  
    new XElement("child3", "child3 content")  
);  
XElement child = xmlTree.Element("Child2");  
IEnumerable<XNode> nodes =  
    from node in child.NodesBeforeSelf()  
    select node;  
foreach (XNode node in nodes)  
    Console.WriteLine("Node type: {0}  {1}",  
        node.NodeType,  
        node.NodeType == XmlNodeType.Text ? (node as XText).Value : "");  
```  
  
```vb  
Dim xmlTree As XElement = New XElement("Root", _  
    New XText("Text content."), _  
    New XElement("Child1", "child1 content"), _  
    New XElement("Child2", "child2 content"), _  
    New XText("More text content."), _  
    New XElement("child3", "child3 content") _  
)  
  
Dim child As XElement = xmlTree.Element("Child2")  
Dim nodes As IEnumerable(Of XNode) = _  
    From node In child.NodesBeforeSelf() _  
    Select node  
For Each node As XNode In nodes  
    Dim s As String = ""  
    If node.NodeType = XmlNodeType.Text Then  
        s = DirectCast(node, XText).Value  
    End If  
    Console.WriteLine("Node type: {0}  {1}", node.NodeType, s)  
Next  
```  
  
 <span data-ttu-id="bb6c8-325">Ten przykład generuje następujące wyniki:</span><span class="sxs-lookup"><span data-stu-id="bb6c8-325">This example produces the following output:</span></span>  
  
```  
Node type: Text  Text content.  
Node type: Element  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviousNode">
      <MemberSignature Language="C#" Value="public System.Xml.Linq.XNode PreviousNode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Linq.XNode PreviousNode" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XNode.PreviousNode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PreviousNode As XNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::Linq::XNode ^ PreviousNode { System::Xml::Linq::XNode ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XNode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="bb6c8-326">Pobiera poprzedni węzeł równorzędny tego węzła.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-326">Gets the previous sibling node of this node.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="bb6c8-327">
            <see cref="T:System.Xml.Linq.XNode" /> Zawierający poprzedniego węzła tego samego poziomu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-327">The <see cref="T:System.Xml.Linq.XNode" /> that contains the previous sibling node.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bb6c8-328">Jeśli <xref:System.Xml.Linq.XNode> jest nie ma rekordu nadrzędnego, lub jeśli nie ma żadnego poprzedniego węzła, ta właściwość zwraca `null`.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-328">If this <xref:System.Xml.Linq.XNode> does not have a parent, or if there is no previous node, this property returns `null`.</span></span>  
  
 <span data-ttu-id="bb6c8-329"><xref:System.Xml.Linq.XContainer> Przechowuje węzły podrzędne jako listę pojedynczo połączone <xref:System.Xml.Linq.XNode> obiektów.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-329">The <xref:System.Xml.Linq.XContainer> stores its child nodes as a singly-linked list of <xref:System.Xml.Linq.XNode> objects.</span></span> <span data-ttu-id="bb6c8-330">Oznacza to, że <xref:System.Xml.Linq.XNode.PreviousNode%2A> właściwości musi przejść przez listę węzłów bezpośrednich podrzędnych w kontenerze nadrzędnym.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-330">This means that the <xref:System.Xml.Linq.XNode.PreviousNode%2A> property must traverse the list of direct child nodes under the parent container.</span></span> <span data-ttu-id="bb6c8-331">W związku z tym za pomocą tej właściwości może mieć wpływ na wydajność.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-331">Therefore, using this property might affect your performance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bb6c8-332">W poniższym przykładzie użyto tej właściwości pętli węzłów.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-332">The following example uses this property to loop through nodes.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XText("Some Text"),  
    new XElement("Child2",  
        2,  
        new XElement("GrandChild", "GrandChild Content")  
    ),  
    new XComment("a comment"),  
    new XElement("Child3")  
);  
XNode node = xmlTree.Element("Child2");  
do {  
    StringBuilder sb = new StringBuilder();  
    sb.Append(String.Format("NodeType: {0}", node.NodeType.ToString().PadRight(10)));  
    switch (node.NodeType)  
    {  
        case XmlNodeType.Text:  
            sb.Append((node as XText).Value);  
            break;  
        case XmlNodeType.Element:  
            sb.Append((node as XElement).Name);  
            break;  
        case XmlNodeType.Comment:  
            sb.Append((node as XComment).Value);  
            break;  
    }  
    Console.WriteLine(sb.ToString());  
}  
while ((node = node.PreviousNode) != null);  
```  
  
```vb  
Dim xmlTree As XElement = _  
    <Root>  
        <Child1>1</Child1>Some Text<Child2>2  
            <GrandChild>GrandChild Content</GrandChild>  
        </Child2>  
        <!--a comment-->  
        <Child3>3</Child3>  
    </Root>  
  
Dim node As XNode = xmlTree.Element("Child2")  
Do  
    Dim sb As StringBuilder = New StringBuilder()  
    sb.Append(String.Format("NodeType: {0}", node.NodeType.ToString().PadRight(10)))  
    Select Case node.NodeType  
        Case XmlNodeType.Text  
            sb.Append(DirectCast(node, XText).Value)  
        Case XmlNodeType.Element  
            sb.Append(DirectCast(node, XElement).Name)  
        Case XmlNodeType.Comment  
            sb.Append(DirectCast(node, XComment).Value)  
    End Select  
    Console.WriteLine(sb.ToString())  
  
    node = node.PreviousNode  
Loop While (Not (node Is Nothing))  
```  
  
 <span data-ttu-id="bb6c8-333">Ten przykład generuje następujące wyniki:</span><span class="sxs-lookup"><span data-stu-id="bb6c8-333">This example produces the following output:</span></span>  
  
```  
NodeType: Element   Child2  
NodeType: Text      Some Text  
NodeType: Element   Child1  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadFrom">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XNode ReadFrom (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XNode ReadFrom(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadFrom (reader As XmlReader) As XNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Linq::XNode ^ ReadFrom(System::Xml::XmlReader ^ reader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <span data-ttu-id="bb6c8-334">
            <see cref="T:System.Xml.XmlReader" /> Znajduje się w węźle do odczytu do tego <see cref="T:System.Xml.Linq.XNode" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-334">An <see cref="T:System.Xml.XmlReader" /> positioned at the node to read into this <see cref="T:System.Xml.Linq.XNode" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bb6c8-335">Tworzy <see cref="T:System.Xml.Linq.XNode" /> z <see cref="T:System.Xml.XmlReader" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-335">Creates an <see cref="T:System.Xml.Linq.XNode" /> from an <see cref="T:System.Xml.XmlReader" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bb6c8-336">
            <see cref="T:System.Xml.Linq.XNode" /> Zawiera węzeł i jego węzły podrzędne, które zostały odczytane z czytnika.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-336">An <see cref="T:System.Xml.Linq.XNode" /> that contains the node and its descendant nodes that were read from the reader.</span>
          </span>
          <span data-ttu-id="bb6c8-337">Typ środowiska uruchomieniowego węzła jest określana przez typ węzła (<see cref="P:System.Xml.Linq.XObject.NodeType" />) pierwszego węzła napotkano w czytniku.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-337">The runtime type of the node is determined by the node type (<see cref="P:System.Xml.Linq.XObject.NodeType" />) of the first node encountered in the reader.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bb6c8-338">Ta metoda umożliwia napisanie metody, która zwraca zbiór węzłów, każdy węzeł reaguje, węzeł jest w trybie do odczytu z czytnika.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-338">You can use this method to write a method that returns a collection of nodes, yielding each node as the node is read from the reader.</span></span> <span data-ttu-id="bb6c8-339">Ta metoda umożliwia przetwarzanie arbitralnie dużych plików XML z zużycie pamięci bardzo mała.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-339">This method enables you to process arbitrarily large XML files with a very small memory footprint.</span></span>  
  
 <span data-ttu-id="bb6c8-340">Czytnik, który jest przekazywany do tej metody może zgłaszają wyjątki.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-340">The reader that you pass to this method might throw exceptions.</span></span> <span data-ttu-id="bb6c8-341"><xref:System.Xml.Linq.XNode.ReadFrom%2A> wszystkie nie przechwytuje wyjątków zgłaszanych przez czytnik; nieobsługiwane wyjątki bąbelkowy do kodu, który wywołał <xref:System.Xml.Linq.XNode.ReadFrom%2A>.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-341"><xref:System.Xml.Linq.XNode.ReadFrom%2A> does not catch all exceptions thrown by the reader; the unhandled exceptions bubble up to the code that called <xref:System.Xml.Linq.XNode.ReadFrom%2A>.</span></span> <span data-ttu-id="bb6c8-342">W szczególności należy przygotować swój kod obsługi <xref:System.Xml.XmlException>.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-342">In particular, your code should be prepared to handle <xref:System.Xml.XmlException>.</span></span>  
  
 <span data-ttu-id="bb6c8-343">Na przykład sposobu strumienia dokumentów złożonych zobacz [porady: fragmenty XML strumienia z dostępem do informacji w nagłówku](http://msdn.microsoft.com/library/01311522-9d03-4977-8641-2932c6f56092).</span><span class="sxs-lookup"><span data-stu-id="bb6c8-343">For an example of how to stream a more complex document, see [How to: Stream XML Fragments with Access to Header Information](http://msdn.microsoft.com/library/01311522-9d03-4977-8641-2932c6f56092).</span></span>  
  
 <span data-ttu-id="bb6c8-344">Niektóre standardowy kwerendy operatorów, takich jak <xref:System.Linq.Enumerable.OrderBy%2A>, iteracji ich źródłem Zbieraj wszystkie dane, sortowanie ich i ostatecznie yield pierwszego elementu w sekwencji.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-344">Certain standard query operators, such as <xref:System.Linq.Enumerable.OrderBy%2A>, iterate their source, collect all of the data, sort it, and then finally yield the first item in the sequence.</span></span> <span data-ttu-id="bb6c8-345">Jeśli używasz operator zapytania, który zostaje źródła przed reaguje pierwszy element rozmiaru pamięci nie zostaną zachowane.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-345">If you use a query operator that materializes its source before yielding the first item, you will not retain a small memory footprint.</span></span>  
  
 <span data-ttu-id="bb6c8-346">Przykład za pomocą [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] do transformacji dokumentów XML wyjątkowa przy zachowaniu zużycia pamięci, zobacz [porady: wykonaj przesyłania strumieniowego przekształcenie o dużych dokumentów XML](http://msdn.microsoft.com/library/0759e428-6e59-4d80-a506-365d3a6a2b73).</span><span class="sxs-lookup"><span data-stu-id="bb6c8-346">For an example of using [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] to transform extremely large XML documents while maintaining a small memory footprint, see [How to: Perform Streaming Transform of Large XML Documents](http://msdn.microsoft.com/library/0759e428-6e59-4d80-a506-365d3a6a2b73).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bb6c8-347">W tym przykładzie używane następującego pliku XML o nazwie Source.xml:</span><span class="sxs-lookup"><span data-stu-id="bb6c8-347">This example uses the following XML file, named Source.xml:</span></span>  
  
```xml  
<?xml version="1.0" encoding="utf-8" ?>   
<Root>  
  <Child Key="01">  
    <GrandChild>aaa</GrandChild>  
  </Child>  
  <Child Key="02">  
    <GrandChild>bbb</GrandChild>  
  </Child>  
  <Child Key="03">  
    <GrandChild>ccc</GrandChild>  
  </Child>  
</Root>  
```  
  
 <span data-ttu-id="bb6c8-348">W tym przykładzie tworzy niestandardowe osi metody, która używa <xref:System.Xml.Linq.XNode.ReadFrom%2A>.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-348">This example creates a custom axis method that uses <xref:System.Xml.Linq.XNode.ReadFrom%2A>.</span></span> <span data-ttu-id="bb6c8-349">Niestandardowe osi można badać przy użyciu zapytania LINQ.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-349">You can query the custom axis by using a LINQ query.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="bb6c8-350">W poniższym przykładzie użyto yield return konstrukcja języka C#.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-350">The following example uses the yield return construct of C#.</span></span> <span data-ttu-id="bb6c8-351">Ponieważ nie istnieje żadne funkcje w [!INCLUDE[vb_orcas_long](~/includes/vb-orcas-long-md.md)], w tym przykładzie jest dostępne tylko w języku C#.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-351">Because there is no equivalent feature in [!INCLUDE[vb_orcas_long](~/includes/vb-orcas-long-md.md)], this example is provided only in C#.</span></span>  
  
```csharp  
class Program  
{  
    static IEnumerable<XElement> StreamRootChildDoc(string uri)  
    {  
        using (XmlReader reader = XmlReader.Create(uri))  
        {  
            reader.MoveToContent();  
            // Parse the file and display each of the nodes.  
            while (reader.Read())  
            {  
                switch (reader.NodeType)  
                {  
                    case XmlNodeType.Element:  
                        if (reader.Name == "Child")  
                        {  
                            XElement el = XElement.ReadFrom(reader) as XElement;  
                            if (el != null)  
                                yield return el;  
                        }  
                        break;  
                }  
            }  
        }  
    }  
  
    static void Main(string[] args)  
    {  
        IEnumerable<string> grandChildData =  
            from el in StreamRootChildDoc("Source.xml")  
            where (int)el.Attribute("Key") > 1  
            select (string)el.Element("GrandChild");  
  
        foreach (string str in grandChildData)  
            Console.WriteLine(str);  
    }  
}  
```  
  
 <span data-ttu-id="bb6c8-352">W tym przykładzie tworzy następujące dane wyjściowe.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-352">This example produces the following output.</span></span>  
  
```  
bbb  
ccc  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="bb6c8-353">
            <see cref="T:System.Xml.XmlReader" /> Nie jest ustawiony na typ węzła rozpoznany.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-353">The <see cref="T:System.Xml.XmlReader" /> is not positioned on a recognized node type.</span>
          </span>
        </exception>
        <exception cref="T:System.Xml.XmlException">
          <span data-ttu-id="bb6c8-354">Podstawowa <see cref="T:System.Xml.XmlReader" /> zgłasza wyjątek.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-354">The underlying <see cref="T:System.Xml.XmlReader" /> throws an exception.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ReadFromAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Xml.Linq.XNode&gt; ReadFromAsync (System.Xml.XmlReader reader, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Xml.Linq.XNode&gt; ReadFromAsync(class System.Xml.XmlReader reader, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.ReadFromAsync(System.Xml.XmlReader,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task&lt;System::Xml::Linq::XNode ^&gt; ^ ReadFromAsync(System::Xml::XmlReader ^ reader, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Xml.Linq.XNode&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="reader">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public void Remove ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Remove() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.Remove" />
      <MemberSignature Language="VB.NET" Value="Public Sub Remove ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Remove();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="bb6c8-355">Usuwa ten węzeł po swoim obiekcie nadrzędnym.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-355">Removes this node from its parent.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bb6c8-356">W [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] programowania, nie należy manipulować ani zmodyfikować zestaw węzłów, gdy jest kwerenda dla węzłów w tym zestawie.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-356">In [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] programming, you should not manipulate or modify a set of nodes while you are querying for nodes in that set.</span></span> <span data-ttu-id="bb6c8-357">W praktyce to oznacza, że należy nie iteracja zestawu węzłów i usuń je.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-357">In practical terms, this means that you should not iterate over a set of nodes and remove them.</span></span> <span data-ttu-id="bb6c8-358">Zamiast tego należy je do zmaterializowania <xref:System.Collections.Generic.List%601> za pomocą <xref:System.Linq.Enumerable.ToList%2A> — metoda rozszerzenia.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-358">Instead, you should materialize them into a <xref:System.Collections.Generic.List%601> by using the <xref:System.Linq.Enumerable.ToList%2A> extension method.</span></span> <span data-ttu-id="bb6c8-359">Następnie można iteracja listy do usuwania węzłów.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-359">Then, you can iterate over the list to remove the nodes.</span></span> <span data-ttu-id="bb6c8-360">Aby uzyskać więcej informacji, zobacz [mieszanych deklaratywne usterki kodu kodu/Imperatywne (LINQ do XML)](http://msdn.microsoft.com/library/d9a5c404-2b0e-46cd-a358-0e78773b3094).</span><span class="sxs-lookup"><span data-stu-id="bb6c8-360">For more information, see [Mixed Declarative Code/Imperative Code Bugs (LINQ to XML)](http://msdn.microsoft.com/library/d9a5c404-2b0e-46cd-a358-0e78773b3094).</span></span>  
  
 <span data-ttu-id="bb6c8-361">Alternatywnie, jeśli chcesz usunąć zestaw węzłów, zalecane jest używanie <xref:System.Xml.Linq.Extensions.Remove%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-361">Alternatively, if you want to remove a set of nodes, it is recommended that you use the <xref:System.Xml.Linq.Extensions.Remove%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="bb6c8-362">Ta metoda kopiuje węzły do listy, a następnie wykonuje iterację na liście, aby usunąć węzłów.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-362">This method copies the nodes to a list, and then iterates over the list to remove the nodes.</span></span>  
  
 <span data-ttu-id="bb6c8-363">Ta metoda zostanie podniesiony <xref:System.Xml.Linq.XObject.Changed> i <xref:System.Xml.Linq.XObject.Changing> zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-363">This method will raise the <xref:System.Xml.Linq.XObject.Changed> and the <xref:System.Xml.Linq.XObject.Changing> events.</span></span>  
  
 <span data-ttu-id="bb6c8-364"><xref:System.Xml.Linq.XContainer> Przechowuje węzły podrzędne jako listę pojedynczo połączone <xref:System.Xml.Linq.XNode> obiektów.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-364">The <xref:System.Xml.Linq.XContainer> stores its child nodes as a singly-linked list of <xref:System.Xml.Linq.XNode> objects.</span></span> <span data-ttu-id="bb6c8-365">Oznacza to, że <xref:System.Xml.Linq.XNode.Remove%2A> metody muszą przejść listy węzłów bezpośrednich podrzędnych w kontenerze nadrzędnym.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-365">This means that the <xref:System.Xml.Linq.XNode.Remove%2A> method must traverse the list of direct child nodes under the parent container.</span></span> <span data-ttu-id="bb6c8-366">W związku z tym za pomocą tej metody może wpłynąć na wydajność.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-366">Therefore, using this method might affect your performance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bb6c8-367">Poniższy przykład umożliwia usunięcie węzła po swoim obiekcie nadrzędnym.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-367">The following example removes a node from its parent.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", "child1 content"),  
    new XElement("Child2", "child2 content"),  
    new XElement("Child3", "child3 content"),  
    new XElement("Child4", "child4 content"),  
    new XElement("Child5", "child5 content")  
);  
XElement child3 = xmlTree.Element("Child3");  
child3.Remove();  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>child1 content</Child1>  
            <Child2>child2 content</Child2>  
            <Child3>child3 content</Child3>  
            <Child4>child4 content</Child4>  
            <Child5>child5 content</Child5>  
        </Root>  
  
Dim child3 As XElement = xmlTree.<Child3>(0)  
child3.Remove()  
Console.WriteLine(xmlTree)  
```  
  
 <span data-ttu-id="bb6c8-368">Ten przykład generuje następujące wyniki:</span><span class="sxs-lookup"><span data-stu-id="bb6c8-368">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <Child1>child1 content</Child1>  
  <Child2>child2 content</Child2>  
  <Child4>child4 content</Child4>  
  <Child5>child5 content</Child5>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="bb6c8-369">Element nadrzędny jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-369">The parent is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReplaceWith">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="bb6c8-370">Zastępuje ten węzeł z określoną zawartością.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-370">Replaces this node with the specified content.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bb6c8-371">Aby uzyskać szczegółowe informacje o prawidłowej zawartości, które mogą zostać przekazane do tej metody, zobacz [Nieprawidłowa zawartość klasy XElement i obiektów klasy XDocument](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span><span class="sxs-lookup"><span data-stu-id="bb6c8-371">For details about the valid content that can be passed to this method, see [Valid Content of XElement and XDocument Objects](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span></span>  
  
 <span data-ttu-id="bb6c8-372">Ta metoda zostanie podniesiony <xref:System.Xml.Linq.XObject.Changed> i <xref:System.Xml.Linq.XObject.Changing> zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-372">This method will raise the <xref:System.Xml.Linq.XObject.Changed> and the <xref:System.Xml.Linq.XObject.Changing> events.</span></span>  
  
 <span data-ttu-id="bb6c8-373"><xref:System.Xml.Linq.XContainer> Przechowuje węzły podrzędne jako listę pojedynczo połączone <xref:System.Xml.Linq.XNode> obiektów.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-373">The <xref:System.Xml.Linq.XContainer> stores its child nodes as a singly-linked list of <xref:System.Xml.Linq.XNode> objects.</span></span> <span data-ttu-id="bb6c8-374">Oznacza to, że <xref:System.Xml.Linq.XNode.ReplaceWith%2A> metody muszą przejść listy węzłów bezpośrednich podrzędnych w kontenerze nadrzędnym.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-374">This means that the <xref:System.Xml.Linq.XNode.ReplaceWith%2A> method must  traverse the list of direct child nodes under the parent container.</span></span> <span data-ttu-id="bb6c8-375">W związku z tym za pomocą tej metody może wpłynąć na wydajność.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-375">Therefore, using this method might affect your performance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bb6c8-376">W poniższym przykładzie użyto tej metody, aby zastąpić zawartość węzła z inną zawartością.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-376">The following example uses this method to replace the contents of a node with different content.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", "child1 content"),  
    new XElement("Child2", "child2 content"),  
    new XElement("Child3", "child3 content"),  
    new XElement("Child4", "child4 content"),  
    new XElement("Child5", "child5 content")  
);  
XElement child3 = xmlTree.Element("Child3");  
child3.ReplaceWith(  
    new XElement("NewChild", "new content")  
);  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>child1 content</Child1>  
            <Child2>child2 content</Child2>  
            <Child3>child3 content</Child3>  
            <Child4>child4 content</Child4>  
            <Child5>child5 content</Child5>  
        </Root>  
  
Dim child3 As XElement = xmlTree.<Child3>(0)  
child3.ReplaceWith(<NewChild>new content</NewChild>)  
Console.WriteLine(xmlTree)  
```  
  
 <span data-ttu-id="bb6c8-377">Ten przykład generuje następujące wyniki:</span><span class="sxs-lookup"><span data-stu-id="bb6c8-377">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <Child1>child1 content</Child1>  
  <Child2>child2 content</Child2>  
  <NewChild>new content</NewChild>  
  <Child4>child4 content</Child4>  
  <Child5>child5 content</Child5>  
</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReplaceWith">
      <MemberSignature Language="C#" Value="public void ReplaceWith (object content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReplaceWith(object content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.ReplaceWith(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReplaceWith (content As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReplaceWith(System::Object ^ content);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="content">
          <span data-ttu-id="bb6c8-378">Zawartość, która zastępuje tego węzła.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-378">Content that replaces this node.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bb6c8-379">Zastępuje ten węzeł z określoną zawartością.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-379">Replaces this node with the specified content.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bb6c8-380">Ta metoda najpierw usuwa ten węzeł po swoim obiekcie nadrzędnym, a następnie dodanie określonej zawartości do tego węzła nadrzędnego, miejsca tego węzła.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-380">This method first removes this node from its parent, and then adds the specified content to this node's parent, in the place of this node.</span></span>  
  
 <span data-ttu-id="bb6c8-381"><xref:System.Xml.Linq.XContainer> Przechowuje węzły podrzędne jako listę pojedynczo połączone <xref:System.Xml.Linq.XNode> obiektów.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-381">The <xref:System.Xml.Linq.XContainer> stores its child nodes as a singly-linked list of <xref:System.Xml.Linq.XNode> objects.</span></span> <span data-ttu-id="bb6c8-382">Oznacza to, że <xref:System.Xml.Linq.XNode.ReplaceWith%2A> metody muszą przejść listy węzłów bezpośrednich podrzędnych w kontenerze nadrzędnym.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-382">This means that the <xref:System.Xml.Linq.XNode.ReplaceWith%2A> method must traverse the list of direct child nodes under the parent container.</span></span> <span data-ttu-id="bb6c8-383">W związku z tym za pomocą tej metody może wpłynąć na wydajność.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-383">Therefore, using this method might affect your performance.</span></span>  
  
 <span data-ttu-id="bb6c8-384">Aby uzyskać szczegółowe informacje o prawidłowej zawartości, które mogą zostać przekazane do tej metody, zobacz [Nieprawidłowa zawartość klasy XElement i obiektów klasy XDocument](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span><span class="sxs-lookup"><span data-stu-id="bb6c8-384">For details about the valid content that can be passed to this method, see [Valid Content of XElement and XDocument Objects](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span></span>  
  
 <span data-ttu-id="bb6c8-385">Ta metoda zostanie podniesiony <xref:System.Xml.Linq.XObject.Changed> i <xref:System.Xml.Linq.XObject.Changing> zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-385">This method will raise the <xref:System.Xml.Linq.XObject.Changed> and the <xref:System.Xml.Linq.XObject.Changing> events.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bb6c8-386">W poniższym przykładzie użyto tej metody, aby zastąpić zawartość węzła z inną zawartością.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-386">The following example uses this method to replace the contents of a node with different content.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", "child1 content"),  
    new XElement("Child2", "child2 content"),  
    new XElement("Child3", "child3 content"),  
    new XElement("Child4", "child4 content"),  
    new XElement("Child5", "child5 content")  
);  
XElement child3 = xmlTree.Element("Child3");  
child3.ReplaceWith(  
    new XElement("NewChild", "new content")  
);  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>child1 content</Child1>  
            <Child2>child2 content</Child2>  
            <Child3>child3 content</Child3>  
            <Child4>child4 content</Child4>  
            <Child5>child5 content</Child5>  
        </Root>  
  
Dim child3 As XElement = xmlTree.<Child3>(0)  
child3.ReplaceWith(<NewChild>new content</NewChild>)  
Console.WriteLine(xmlTree)  
```  
  
 <span data-ttu-id="bb6c8-387">Ten przykład generuje następujące wyniki:</span><span class="sxs-lookup"><span data-stu-id="bb6c8-387">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <Child1>child1 content</Child1>  
  <Child2>child2 content</Child2>  
  <NewChild>new content</NewChild>  
  <Child4>child4 content</Child4>  
  <Child5>child5 content</Child5>  
</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReplaceWith">
      <MemberSignature Language="C#" Value="public void ReplaceWith (params object[] content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReplaceWith(object[] content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.ReplaceWith(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReplaceWith (ParamArray content As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReplaceWith(... cli::array &lt;System::Object ^&gt; ^ content);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="content">
          <span data-ttu-id="bb6c8-388">Lista parametrów nową zawartość.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-388">A parameter list of the new content.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bb6c8-389">Zastępuje ten węzeł z określoną zawartością.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-389">Replaces this node with the specified content.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bb6c8-390">Ta metoda najpierw usuwa ten węzeł po swoim obiekcie nadrzędnym, a następnie dodanie określonej zawartości do tego węzła nadrzędnego, miejsca tego węzła.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-390">This method first removes this node from its parent, and then adds the specified content to this node's parent, in the place of this node.</span></span>  
  
 <span data-ttu-id="bb6c8-391"><xref:System.Xml.Linq.XContainer> Przechowuje węzły podrzędne jako listę pojedynczo połączone <xref:System.Xml.Linq.XNode> obiektów.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-391">The <xref:System.Xml.Linq.XContainer> stores its child nodes as a singly-linked list of <xref:System.Xml.Linq.XNode> objects.</span></span> <span data-ttu-id="bb6c8-392">Oznacza to, że <xref:System.Xml.Linq.XNode.ReplaceWith%2A> metody muszą przejść listy węzłów bezpośrednich podrzędnych w kontenerze nadrzędnym.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-392">This means that the <xref:System.Xml.Linq.XNode.ReplaceWith%2A> method must traverse the list of direct child nodes under the parent container.</span></span> <span data-ttu-id="bb6c8-393">W związku z tym za pomocą tej metody może wpłynąć na wydajność.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-393">Therefore, using this method might affect your performance.</span></span>  
  
 <span data-ttu-id="bb6c8-394">Aby uzyskać szczegółowe informacje o prawidłowej zawartości, które mogą zostać przekazane do tej metody, zobacz [Nieprawidłowa zawartość klasy XElement i obiektów klasy XDocument](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span><span class="sxs-lookup"><span data-stu-id="bb6c8-394">For details about the valid content that can be passed to this method, see [Valid Content of XElement and XDocument Objects](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span></span>  
  
 <span data-ttu-id="bb6c8-395">Ta metoda zostanie podniesiony <xref:System.Xml.Linq.XObject.Changed> i <xref:System.Xml.Linq.XObject.Changing> zdarzenia.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-395">This method will raise the <xref:System.Xml.Linq.XObject.Changed> and the <xref:System.Xml.Linq.XObject.Changing> events.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bb6c8-396">Poniższy przykład przedstawia użycie wyniki [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] zapytania jako dane wejściowe do tej metody.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-396">The following example shows using the results of a [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] query as the input to this method.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
    new XElement("Element1", 1),  
    new XElement("Element2", 2),  
    new XElement("Element3", 3),  
    new XElement("Element4", 4),  
    new XElement("Element5", 5)  
);  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5)  
);  
XElement child3 = xmlTree.Element("Child3");  
child3.ReplaceWith(  
    from el in srcTree.Elements()  
    where (int)el > 3  
    select el  
);  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Dim srcTree As XElement = _   
        <Root>  
            <Element1>1</Element1>  
            <Element2>2</Element2>  
            <Element3>3</Element3>  
            <Element4>4</Element4>  
            <Element5>5</Element5>  
        </Root>  
  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <Child3>3</Child3>  
            <Child4>4</Child4>  
            <Child5>5</Child5>  
        </Root>  
  
Dim child3 As XElement = xmlTree.<Child3>(0)  
child3.ReplaceWith( _  
    From el In srcTree.Elements() _  
    Where (CInt(el) > 3) _  
    Select el)  
  
Console.WriteLine(xmlTree)  
```  
  
 <span data-ttu-id="bb6c8-397">Ten przykład generuje następujące wyniki:</span><span class="sxs-lookup"><span data-stu-id="bb6c8-397">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <Child1>1</Child1>  
  <Child2>2</Child2>  
  <Element4>4</Element4>  
  <Element5>5</Element5>  
  <Child4>4</Child4>  
  <Child5>5</Child5>  
</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="bb6c8-398">Zwraca XML dla tego węzła, opcjonalnie wyłączenie formatowania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-398">Returns the XML for this node, optionally disabling formatting.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="bb6c8-399">Zwraca wcięta XML dla tego węzła.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-399">Returns the indented XML for this node.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bb6c8-400">A <see cref="T:System.String" /> zawierający wcięta XML.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-400">A <see cref="T:System.String" /> containing the indented XML.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="bb6c8-401">W poniższym przykładzie użyto tej metody można pobrać z wcięciami XML.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-401">The following example uses this method to retrieve indented XML.</span></span>  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1)  
);  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>1</Child1>  
        </Root>  
  
Console.WriteLine(xmlTree)  
```  
  
 <span data-ttu-id="bb6c8-402">Ten przykład generuje następujące wyniki:</span><span class="sxs-lookup"><span data-stu-id="bb6c8-402">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <Child1>1</Child1>  
</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (System.Xml.Linq.SaveOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(valuetype System.Xml.Linq.SaveOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.ToString(System.Xml.Linq.SaveOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (options As SaveOptions) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::Xml::Linq::SaveOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Xml.Linq.SaveOptions" />
      </Parameters>
      <Docs>
        <param name="options">
          <span data-ttu-id="bb6c8-403">A <see cref="T:System.Xml.Linq.SaveOptions" /> , który określa zachowania formatowania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-403">A <see cref="T:System.Xml.Linq.SaveOptions" /> that specifies formatting behavior.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bb6c8-404">Zwraca XML dla tego węzła, opcjonalnie wyłączenie formatowania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-404">Returns the XML for this node, optionally disabling formatting.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="bb6c8-405">A <see cref="T:System.String" /> zawierające kod XML.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-405">A <see cref="T:System.String" /> containing the XML.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="bb6c8-406">W poniższym przykładzie użyto tej metody można pobrać niesformatowany i sformatowany XML.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-406">The following example uses this method to retrieve unformatted and formatted XML.</span></span>  
  
```csharp  
XElement root = XElement.Parse("<Root><Child/></Root>");  
Console.WriteLine(root.ToString(SaveOptions.DisableFormatting));  
Console.WriteLine("---");  
Console.WriteLine(root.ToString(SaveOptions.None));  
```  
  
```vb  
Dim root As XElement = <Root>  
                           <Child/>  
                       </Root>  
Console.WriteLine(root.ToString(SaveOptions.DisableFormatting))  
Console.WriteLine("---")  
Console.WriteLine(root.ToString(SaveOptions.None))  
```  
  
 <span data-ttu-id="bb6c8-407">Ten przykład generuje następujące wyniki:</span><span class="sxs-lookup"><span data-stu-id="bb6c8-407">This example produces the following output:</span></span>  
  
```  
<Root><Child /></Root>  
---  
<Root>  
  <Child />  
</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteTo">
      <MemberSignature Language="C#" Value="public abstract void WriteTo (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteTo(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.WriteTo(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub WriteTo (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void WriteTo(System::Xml::XmlWriter ^ writer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <span data-ttu-id="bb6c8-408">
            <see cref="T:System.Xml.XmlWriter" /> Do będzie zapisywać tej metody.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-408">An <see cref="T:System.Xml.XmlWriter" /> into which this method will write.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="bb6c8-409">Zapisuje ten węzeł, aby <see cref="T:System.Xml.XmlWriter" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="bb6c8-409">Writes this node to an <see cref="T:System.Xml.XmlWriter" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bb6c8-410">Ta metoda służy do pisania kodu, który wykonuje przesyłania strumieniowego transformacji bardzo dużych dokumentu.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-410">You can use this method to write code that does a streaming transform of a very large document.</span></span> <span data-ttu-id="bb6c8-411">Aby uzyskać więcej informacji, zobacz [porady: wykonaj przesyłania strumieniowego przekształcenie o dużych dokumentów XML](http://msdn.microsoft.com/library/0759e428-6e59-4d80-a506-365d3a6a2b73).</span><span class="sxs-lookup"><span data-stu-id="bb6c8-411">For more information, see [How to: Perform Streaming Transform of Large XML Documents](http://msdn.microsoft.com/library/0759e428-6e59-4d80-a506-365d3a6a2b73).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bb6c8-412">Poniższy przykład tworzy <xref:System.Xml.XmlWriter> który zapisuje <xref:System.Text.StringBuilder>.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-412">The following example creates an <xref:System.Xml.XmlWriter> that writes to a <xref:System.Text.StringBuilder>.</span></span> <span data-ttu-id="bb6c8-413">Następnie używa tej metody można zapisać dwa drzewa XML do usługi składnika zapisywania.</span><span class="sxs-lookup"><span data-stu-id="bb6c8-413">It then uses this method to write two XML trees to the writer.</span></span>  
  
```csharp  
StringBuilder sb = new StringBuilder();  
XmlWriterSettings xws = new XmlWriterSettings();  
xws.OmitXmlDeclaration = true;  
xws.Indent = true;  
  
using (XmlWriter xw = XmlWriter.Create(sb, xws)) {  
    xw.WriteStartElement("Root");  
    XElement child1 = new XElement("Child",  
        new XElement("GrandChild", "some content")  
    );  
    child1.WriteTo(xw);  
    XElement child2 = new XElement("AnotherChild",  
        new XElement("GrandChild", "different content")  
    );  
    child2.WriteTo(xw);  
    xw.WriteEndElement();  
}  
Console.WriteLine(sb.ToString());  
```  
  
```vb  
Dim sb As StringBuilder = New StringBuilder()  
Dim xws As XmlWriterSettings = New XmlWriterSettings()  
xws.OmitXmlDeclaration = True  
xws.Indent = True  
  
Using xw = XmlWriter.Create(sb, xws)  
    xw.WriteStartElement("Root")  
    Dim child1 As XElement = <Child>  
                                 <GrandChild>some content</GrandChild>  
                             </Child>  
    child1.WriteTo(xw)  
    Dim child2 As XElement = <AnotherChild>  
                                 <GrandChild>different content</GrandChild>  
                             </AnotherChild>  
    child2.WriteTo(xw)  
    xw.WriteEndElement()  
End Using  
  
Console.WriteLine(sb.ToString())  
```  
  
 <span data-ttu-id="bb6c8-414">Ten przykład generuje następujące wyniki:</span><span class="sxs-lookup"><span data-stu-id="bb6c8-414">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <Child>  
    <GrandChild>some content</GrandChild>  
  </Child>  
  <AnotherChild>  
    <GrandChild>different content</GrandChild>  
  </AnotherChild>  
</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteToAsync">
      <MemberSignature Language="C#" Value="public abstract System.Threading.Tasks.Task WriteToAsync (System.Xml.XmlWriter writer, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task WriteToAsync(class System.Xml.XmlWriter writer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.WriteToAsync(System.Xml.XmlWriter,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Threading::Tasks::Task ^ WriteToAsync(System::Xml::XmlWriter ^ writer, System::Threading::CancellationToken cancellationToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="writer">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
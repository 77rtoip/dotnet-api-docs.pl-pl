<Type Name="XNode" FullName="System.Xml.Linq.XNode">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="595113f80f95211e4fbb23fd03ecd79f1e392465" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36443119" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class XNode : System.Xml.Linq.XObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit XNode extends System.Xml.Linq.XObject" />
  <TypeSignature Language="DocId" Value="T:System.Xml.Linq.XNode" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class XNode&#xA;Inherits XObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class XNode abstract : System::Xml::Linq::XObject" />
  <TypeSignature Language="F#" Value="type XNode = class&#xA;    inherit XObject" />
  <AssemblyInfo>
    <AssemblyName>System.Xml.XDocument</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml.Linq</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Xml.Linq.XObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Reprezentuje abstrakcyjne pojęcie (element, komentarza, typu dokumentu, instrukcji przetwarzania lub węzeł tekstowy) węzeł w drzewie XML.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.Linq.XNode> jest abstrakcyjna klasa podstawowa typowe dla następujących typów:  
  
-   <xref:System.Xml.Linq.XComment>  
  
-   <xref:System.Xml.Linq.XContainer>  
  
-   <xref:System.Xml.Linq.XDocumentType>  
  
-   <xref:System.Xml.Linq.XProcessingInstruction>  
  
-   <xref:System.Xml.Linq.XText>  
  
 <xref:System.Xml.Linq.XContainer> jest abstrakcyjna klasa podstawowa typowe dla następujących typów:  
  
-   <xref:System.Xml.Linq.XDocument>  
  
-   <xref:System.Xml.Linq.XElement>  
  
 Obiekty klas, które pochodzą z <xref:System.Xml.Linq.XContainer> może zawierać węzłów podrzędnych.  
  
> [!NOTE]
>  <xref:System.Xml.Linq.XAttribute> Nie jest <xref:System.Xml.Linq.XNode>. Atrybuty są obsługiwane jako listę par nazwa/wartość w elemencie.  
  
 Jeśli piszesz złożonych aplikacji XML, na przykład edytora XML lub edytorze tekstów, służący do przechowywania zawartości w formacie XML, często będą działać na poziomie węzła. Typowe działania podczas pracy na poziomie węzła obejmują dodawanie węzłów, usuwanie węzłów, przekształcanie węzłów i iteracji osi, które zwracają kolekcje węzłów.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="AddAfterSelf">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dodaje określoną zawartością natychmiast po tym węźle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać szczegółowe informacje o prawidłowej zawartości, które mogą zostać przekazane do tej metody, zobacz [Nieprawidłowa zawartość klasy XElement i obiektów klasy XDocument](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).  
  
 Ta metoda zostanie podniesiony <xref:System.Xml.Linq.XObject.Changed> i <xref:System.Xml.Linq.XObject.Changing> zdarzenia.  
  
   
  
## Examples  
 W poniższym przykładzie użyto zapytania LINQ, aby utworzyć <xref:System.Collections.Generic.IEnumerable%601> z <xref:System.Xml.Linq.XElement>, który następnie przekazuje do tej metody. Spowoduje to dodanie wyników zapytania do drzewa w dowolnym miejscu.  
  
```csharp  
XElement srcTree = new XElement("Root",  
    new XElement("Element1", 1),  
    new XElement("Element2", 2),  
    new XElement("Element3", 3),  
    new XElement("Element4", 4),  
    new XElement("Element5", 5)  
);  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5)  
);  
XElement child1 = xmlTree.Element("Child1");  
child1.AddAfterSelf(  
    from el in srcTree.Elements()  
    where (int)el > 3  
    select el  
);  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Dim srcTree As XElement = _  
    <Root>  
        <Element1>1</Element1>  
        <Element2>2</Element2>  
        <Element3>3</Element3>  
        <Element4>4</Element4>  
        <Element5>5</Element5>  
    </Root>  
  
Dim xmlTree As XElement = _  
    <Root>  
        <Child1>1</Child1>  
        <Child2>2</Child2>  
        <Child3>3</Child3>  
        <Child4>4</Child4>  
        <Child5>5</Child5>  
    </Root>  
  
Dim child1 As XElement = xmlTree.<Child1>(0)  
child1.AddAfterSelf( _  
    From el In srcTree.Elements() _  
    Where CInt(el) > 3 _  
    Select el _  
)  
Console.WriteLine(xmlTree)  
```  
  
 Ten przykład generuje następujące wyniki:  
  
```xml  
<Root>  
  <Child1>1</Child1>  
  <Element4>4</Element4>  
  <Element5>5</Element5>  
  <Child2>2</Child2>  
  <Child3>3</Child3>  
  <Child4>4</Child4>  
  <Child5>5</Child5>  
</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddAfterSelf">
      <MemberSignature Language="C#" Value="public void AddAfterSelf (object content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddAfterSelf(object content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.AddAfterSelf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddAfterSelf (content As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddAfterSelf(System::Object ^ content);" />
      <MemberSignature Language="F#" Value="member this.AddAfterSelf : obj -&gt; unit" Usage="xNode.AddAfterSelf content" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="content">Obiekt zawartości zawiera zawartość prostą lub kolekcję obiektów zawartości ma zostać dodana po tego węzła.</param>
        <summary>Dodaje określoną zawartością natychmiast po tym węźle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać szczegółowe informacje o prawidłowej zawartości, które mogą zostać przekazane do tej metody, zobacz [Nieprawidłowa zawartość klasy XElement i obiektów klasy XDocument](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).  
  
 <xref:System.Xml.Linq.XObject.Changing> zdarzenia.  
  
   
  
## Examples  
 W poniższym przykładzie użyto tej metody można dodać elementu do drzewa.  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5)  
);  
XElement child1 = xmlTree.Element("Child1");  
child1.AddAfterSelf(  
    new XElement("NewChild", 10)  
);  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <Child3>3</Child3>  
            <Child4>4</Child4>  
            <Child5>5</Child5>  
        </Root>  
  
Dim child1 As XElement = xmlTree.<Child1>(0)  
child1.AddAfterSelf(New XElement("NewChild", 10))  
Console.WriteLine(xmlTree)  
```  
  
 Ten przykład generuje następujące wyniki:  
  
```xml  
<Root>  
  <Child1>1</Child1>  
  <NewChild>10</NewChild>  
  <Child2>2</Child2>  
  <Child3>3</Child3>  
  <Child4>4</Child4>  
  <Child5>5</Child5>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Element nadrzędny jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddAfterSelf">
      <MemberSignature Language="C#" Value="public void AddAfterSelf (params object[] content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddAfterSelf(object[] content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.AddAfterSelf(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddAfterSelf (ParamArray content As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddAfterSelf(... cli::array &lt;System::Object ^&gt; ^ content);" />
      <MemberSignature Language="F#" Value="member this.AddAfterSelf : obj[] -&gt; unit" Usage="xNode.AddAfterSelf content" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="content">Lista parametrów obiekty zawartości.</param>
        <summary>Dodaje określoną zawartością natychmiast po tym węźle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać szczegółowe informacje o prawidłowej zawartości, które mogą zostać przekazane do tej metody, zobacz [Nieprawidłowa zawartość klasy XElement i obiektów klasy XDocument](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).  
  
 Ta metoda zostanie podniesiony <xref:System.Xml.Linq.XObject.Changed> i <xref:System.Xml.Linq.XObject.Changing> zdarzenia.  
  
   
  
## Examples  
 W poniższym przykładzie użyto zapytania LINQ, aby utworzyć <xref:System.Collections.Generic.IEnumerable%601> z <xref:System.Xml.Linq.XElement>, który następnie przekazuje do tej metody. Spowoduje to dodanie wyników zapytania do drzewa w dowolnym miejscu.  
  
```csharp  
XElement srcTree = new XElement("Root",  
    new XElement("Element1", 1),  
    new XElement("Element2", 2),  
    new XElement("Element3", 3),  
    new XElement("Element4", 4),  
    new XElement("Element5", 5)  
);  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5)  
);  
XElement child1 = xmlTree.Element("Child1");  
child1.AddAfterSelf(  
    from el in srcTree.Elements()  
    where (int)el > 3  
    select el  
);  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Dim srcTree As XElement = _   
        <Root>  
            <Element1>1</Element1>  
            <Element2>2</Element2>  
            <Element3>3</Element3>  
            <Element4>4</Element4>  
            <Element5>5</Element5>  
        </Root>  
  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <Child3>3</Child3>  
            <Child4>4</Child4>  
            <Child5>5</Child5>  
        </Root>  
  
Dim child1 As XElement = xmlTree.<Child1>(0)  
child1.AddAfterSelf( _  
    From el In srcTree.Elements() _  
    Where CInt(el) > 3 _  
    Select el)  
Console.WriteLine(xmlTree)  
```  
  
 Ten przykład generuje następujące wyniki:  
  
```xml  
<Root>  
  <Child1>1</Child1>  
  <Element4>4</Element4>  
  <Element5>5</Element5>  
  <Child2>2</Child2>  
  <Child3>3</Child3>  
  <Child4>4</Child4>  
  <Child5>5</Child5>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Element nadrzędny jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddBeforeSelf">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dodaje określony zawartości bezpośrednio przed tym węźle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać szczegółowe informacje o prawidłowej zawartości, które mogą zostać przekazane do tej metody, zobacz [Nieprawidłowa zawartość klasy XElement i obiektów klasy XDocument](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).  
  
 Ta metoda zostanie podniesiony <xref:System.Xml.Linq.XObject.Changed> i <xref:System.Xml.Linq.XObject.Changing> zdarzenia.  
  
 <xref:System.Xml.Linq.XContainer> Przechowuje informacje o jego podrzędnych jako listę pojedynczo połączone <xref:System.Xml.Linq.XNode> obiektów. Oznacza to, że <xref:System.Xml.Linq.XNode.AddBeforeSelf%2A> metody muszą przejść listy węzłów bezpośrednich podrzędnych w kontenerze nadrzędnym. W związku z tym za pomocą tej metody może wpłynąć na wydajność.  
  
   
  
## Examples  
 W poniższym przykładzie użyto zapytania LINQ, aby utworzyć <xref:System.Collections.Generic.IEnumerable%601> z <xref:System.Xml.Linq.XElement>, który następnie przekazuje do tej metody. Spowoduje to dodanie wyników zapytania do drzewa w dowolnym miejscu.  
  
```csharp  
XElement srcTree = new XElement("Root",  
    new XElement("Element1", 1),  
    new XElement("Element2", 2),  
    new XElement("Element3", 3),  
    new XElement("Element4", 4),  
    new XElement("Element5", 5)  
);  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5)  
);  
XElement child1 = xmlTree.Element("Child1");  
child1.AddBeforeSelf(  
    from el in srcTree.Elements()  
    where (int)el > 3  
    select el  
);  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Dim srcTree As XElement = _   
        <Root>  
            <Element1>1</Element1>  
            <Element2>2</Element2>  
            <Element3>3</Element3>  
            <Element4>4</Element4>  
            <Element5>5</Element5>  
        </Root>  
  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <Child3>3</Child3>  
            <Child4>4</Child4>  
            <Child5>5</Child5>  
        </Root>  
  
Dim child1 As XElement = xmlTree.<Child1>(0)  
child1.AddBeforeSelf( _  
From el In srcTree.Elements() _  
Where CInt(el) > 3 _  
Select el)  
  
Console.WriteLine(xmlTree)  
```  
  
 Ten przykład generuje następujące wyniki:  
  
```xml  
<Root>  
  <Element4>4</Element4>  
  <Element5>5</Element5>  
  <Child1>1</Child1>  
  <Child2>2</Child2>  
  <Child3>3</Child3>  
  <Child4>4</Child4>  
  <Child5>5</Child5>  
</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddBeforeSelf">
      <MemberSignature Language="C#" Value="public void AddBeforeSelf (object content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddBeforeSelf(object content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddBeforeSelf (content As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddBeforeSelf(System::Object ^ content);" />
      <MemberSignature Language="F#" Value="member this.AddBeforeSelf : obj -&gt; unit" Usage="xNode.AddBeforeSelf content" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="content">Obiekt zawartości zawiera zawartość prostą lub kolekcję obiektów zawartości ma zostać dodana przed tego węzła.</param>
        <summary>Dodaje określony zawartości bezpośrednio przed tym węźle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać szczegółowe informacje o prawidłowej zawartości, które mogą zostać przekazane do tej metody, zobacz [Nieprawidłowa zawartość klasy XElement i obiektów klasy XDocument](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).  
  
 Ta metoda zostanie podniesiony <xref:System.Xml.Linq.XObject.Changed> i <xref:System.Xml.Linq.XObject.Changing> zdarzenia.  
  
 <xref:System.Xml.Linq.XContainer> Przechowuje węzły podrzędne jako listę pojedynczo połączone <xref:System.Xml.Linq.XNode> obiektów. Oznacza to, że <xref:System.Xml.Linq.XNode.AddBeforeSelf%2A> metody muszą przejść listy węzłów bezpośrednich podrzędnych w kontenerze nadrzędnym. W związku z tym za pomocą tej metody może wpłynąć na wydajność.  
  
   
  
## Examples  
 W poniższym przykładzie użyto tej metody można dodać elementu do drzewa.  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5)  
);  
XElement child1 = xmlTree.Element("Child1");  
child1.AddBeforeSelf(  
    new XElement("NewChild", 10)  
);  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <Child3>3</Child3>  
            <Child4>4</Child4>  
            <Child5>5</Child5>  
        </Root>  
  
Dim child1 As XElement = xmlTree.<Child1>(0)  
child1.AddBeforeSelf(New XElement("NewChild", 10))  
Console.WriteLine(xmlTree)  
```  
  
 Ten przykład generuje następujące wyniki:  
  
```xml  
<Root>  
  <NewChild>10</NewChild>  
  <Child1>1</Child1>  
  <Child2>2</Child2>  
  <Child3>3</Child3>  
  <Child4>4</Child4>  
  <Child5>5</Child5>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Element nadrzędny jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddBeforeSelf">
      <MemberSignature Language="C#" Value="public void AddBeforeSelf (params object[] content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddBeforeSelf(object[] content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddBeforeSelf (ParamArray content As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddBeforeSelf(... cli::array &lt;System::Object ^&gt; ^ content);" />
      <MemberSignature Language="F#" Value="member this.AddBeforeSelf : obj[] -&gt; unit" Usage="xNode.AddBeforeSelf content" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="content">Lista parametrów obiekty zawartości.</param>
        <summary>Dodaje określony zawartości bezpośrednio przed tym węźle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać szczegółowe informacje o prawidłowej zawartości, które mogą zostać przekazane do tej metody, zobacz [Nieprawidłowa zawartość klasy XElement i obiektów klasy XDocument](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).  
  
 Ta metoda zostanie podniesiony <xref:System.Xml.Linq.XObject.Changed> i <xref:System.Xml.Linq.XObject.Changing> zdarzenia.  
  
 <xref:System.Xml.Linq.XContainer> Przechowuje węzły podrzędne jako listę pojedynczo połączone <xref:System.Xml.Linq.XNode> obiektów. Oznacza to, że <xref:System.Xml.Linq.XNode.AddBeforeSelf%2A> metody muszą przejść listy węzłów bezpośrednich podrzędnych w kontenerze nadrzędnym. W związku z tym za pomocą tej funkcji mogą mieć wpływ na wydajność.  
  
   
  
## Examples  
 W poniższym przykładzie użyto zapytania LINQ, aby utworzyć <xref:System.Collections.Generic.IEnumerable%601> z <xref:System.Xml.Linq.XElement>, który następnie przekazuje do tej metody. Spowoduje to dodanie wyników zapytania do drzewa w dowolnym miejscu.  
  
```csharp  
XElement srcTree = new XElement("Root",  
    new XElement("Element1", 1),  
    new XElement("Element2", 2),  
    new XElement("Element3", 3),  
    new XElement("Element4", 4),  
    new XElement("Element5", 5)  
);  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5)  
);  
XElement child1 = xmlTree.Element("Child1");  
child1.AddBeforeSelf(  
    from el in srcTree.Elements()  
    where (int)el > 3  
    select el  
);  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Dim srcTree As XElement = _   
        <Root>  
            <Element1>1</Element1>  
            <Element2>2</Element2>  
            <Element3>3</Element3>  
            <Element4>4</Element4>  
            <Element5>5</Element5>  
        </Root>  
  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <Child3>3</Child3>  
            <Child4>4</Child4>  
            <Child5>5</Child5>  
        </Root>  
  
Dim child1 As XElement = xmlTree.<Child1>(0)  
child1.AddBeforeSelf( _  
    From el In srcTree.Elements() _  
    Where CInt(el) > 3 _  
    Select el)  
  
Console.WriteLine(xmlTree)  
```  
  
 Ten przykład generuje następujące wyniki:  
  
```xml  
<Root>  
  <Element4>4</Element4>  
  <Element5>5</Element5>  
  <Child1>1</Child1>  
  <Child2>2</Child2>  
  <Child3>3</Child3>  
  <Child4>4</Child4>  
  <Child5>5</Child5>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Element nadrzędny jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Ancestors">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca kolekcję element nadrzędny elementy tego węzła.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Opcjonalnie można określić nazwy węzła do filtrowania dla elementów nadrzędnych o określonej nazwie.  
  
 Węzeł w zwracanej kolekcji znajduje się w kolejności odwrotnej dokumentu.  
  
 Ta metoda używa odroczonego wykonania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Ancestors">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; Ancestors ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; Ancestors() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.Ancestors" />
      <MemberSignature Language="VB.NET" Value="Public Function Ancestors () As IEnumerable(Of XElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XElement ^&gt; ^ Ancestors();" />
      <MemberSignature Language="F#" Value="member this.Ancestors : unit -&gt; seq&lt;System.Xml.Linq.XElement&gt;" Usage="xNode.Ancestors " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca kolekcję element nadrzędny elementy tego węzła.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> z <see cref="T:System.Xml.Linq.XElement" /> elementów nadrzędny tego węzła.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie zwraca się w wynikach.  
  
 Węzeł w zwracanej kolekcji znajduje się w kolejności odwrotnej dokumentu.  
  
 Ta metoda używa odroczonego wykonania.  
  
   
  
## Examples  
 W poniższym przykładzie użyto tej metody wyliczania elementów nadrzędnych węzła.  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child",   
        new XElement("GrandChild", "content")  
    )  
);  
IEnumerable<XElement> grandChild = xmlTree.Descendants("GrandChild");  
foreach (XElement el in grandChild.Ancestors())  
    Console.WriteLine(el.Name);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>  
            <Child>  
                <GrandChild>content</GrandChild>  
            </Child>  
        </Root>  
  
Dim grandChild As IEnumerable(Of XElement) = xmlTree...<GrandChild>  
For Each el In grandChild.Ancestors()  
    Console.WriteLine(el.Name)  
Next  
```  
  
 Ten przykład generuje następujące wyniki:  
  
```  
Child  
Root  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ancestors">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; Ancestors (System.Xml.Linq.XName name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; Ancestors(class System.Xml.Linq.XName name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.Ancestors(System.Xml.Linq.XName)" />
      <MemberSignature Language="VB.NET" Value="Public Function Ancestors (name As XName) As IEnumerable(Of XElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XElement ^&gt; ^ Ancestors(System::Xml::Linq::XName ^ name);" />
      <MemberSignature Language="F#" Value="member this.Ancestors : System.Xml.Linq.XName -&gt; seq&lt;System.Xml.Linq.XElement&gt;" Usage="xNode.Ancestors name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
      </Parameters>
      <Docs>
        <param name="name">
          <see cref="T:System.Xml.Linq.XName" /> Do dopasowania.</param>
        <summary>Zwraca kolekcję filtrowane element nadrzędny elementy tego węzła. Tylko elementy, które pasują do <see cref="T:System.Xml.Linq.XName" /> znajdują się w kolekcji.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> z <see cref="T:System.Xml.Linq.XElement" /> elementów nadrzędny tego węzła. Tylko elementy, które pasują do <see cref="T:System.Xml.Linq.XName" /> znajdują się w kolekcji.  Węzeł w zwracanej kolekcji znajduje się w kolejności odwrotnej dokumentu.  Ta metoda używa odroczonego wykonania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie zwróci się w wynikach.  
  
   
  
## Examples  
 W poniższym przykładzie użyto tej metody.  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child",   
        new XElement("GrandChild", "content")  
    )  
);  
IEnumerable<XElement> grandChild = xmlTree.Descendants("GrandChild");  
foreach (XElement el in grandChild.Ancestors("Child"))  
    Console.WriteLine(el.Name);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>  
            <Child>  
                <GrandChild>content</GrandChild>  
            </Child>  
        </Root>  
  
Dim grandChild As IEnumerable(Of XElement) = xmlTree...<GrandChild>  
For Each el In grandChild.Ancestors("Child")  
    Console.WriteLine(el.Name)  
Next  
```  
  
 Ten przykład generuje następujące wyniki:  
  
```  
Child  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompareDocumentOrder">
      <MemberSignature Language="C#" Value="public static int CompareDocumentOrder (System.Xml.Linq.XNode n1, System.Xml.Linq.XNode n2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareDocumentOrder(class System.Xml.Linq.XNode n1, class System.Xml.Linq.XNode n2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.CompareDocumentOrder(System.Xml.Linq.XNode,System.Xml.Linq.XNode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareDocumentOrder (n1 As XNode, n2 As XNode) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareDocumentOrder(System::Xml::Linq::XNode ^ n1, System::Xml::Linq::XNode ^ n2);" />
      <MemberSignature Language="F#" Value="static member CompareDocumentOrder : System.Xml.Linq.XNode * System.Xml.Linq.XNode -&gt; int" Usage="System.Xml.Linq.XNode.CompareDocumentOrder (n1, n2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="n1" Type="System.Xml.Linq.XNode" />
        <Parameter Name="n2" Type="System.Xml.Linq.XNode" />
      </Parameters>
      <Docs>
        <param name="n1">Pierwszy <see cref="T:System.Xml.Linq.XNode" /> do porównania.</param>
        <param name="n2">Drugi <see cref="T:System.Xml.Linq.XNode" /> do porównania.</param>
        <summary>Porównuje dwa węzły, aby określić ich względne kolejności dokumentu XML.</summary>
        <returns>
          <see langword="int" /> Zawierające 0, jeśli węzły są równe; -1 Jeśli <paramref name="n1" /> przed <paramref name="n2" />; 1, gdy <paramref name="n1" /> po <paramref name="n2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.Linq.XContainer> Przechowuje węzły podrzędne jako listę pojedynczo połączone <xref:System.Xml.Linq.XNode> obiektów. Oznacza to, że <xref:System.Xml.Linq.XNode.CompareDocumentOrder%2A> metody muszą przejść elementów nadrzędnych elementu dwa węzły są porównywane aż do znalezienia Wspólnemu elementowi nadrzędnemu. Następnie należy go przechodzenie listy Wspólnemu elementowi nadrzędnemu węzłów podrzędnych można określić kolejność dwa węzły są porównywane. W związku z tym za pomocą tej metody może wpłynąć na wydajność.  
  
   
  
## Examples  
 W poniższym przykładzie użyto tej metody.  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1",  
        new XElement("GrandChild1", 1),  
        new XElement("GrandChild2", 2),  
        new XElement("GrandChild3", 3)  
    ),  
    new XElement("Child2",  
        new XElement("GrandChild4", 4),  
        new XElement("GrandChild5", 5),  
        new XElement("GrandChild6", 6)  
    )  
);  
XElement el1 = xmlTree.Descendants("GrandChild2").First();  
XElement el2 = xmlTree.Descendants("GrandChild6").First();  
if (XElement.CompareDocumentOrder(el1, el2) == 0)  
    Console.WriteLine("Compared elements are the same element");  
else if (XElement.CompareDocumentOrder(el1, el2) > 0)  
    Console.WriteLine("el1 is after el2");  
else  
    Console.WriteLine("el1 is before el2");  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>  
                <GrandChild1>1</GrandChild1>  
                <GrandChild2>2</GrandChild2>  
                <GrandChild3>3</GrandChild3>  
            </Child1>  
            <Child2>  
                <GrandChild4>4</GrandChild4>  
                <GrandChild5>5</GrandChild5>  
                <GrandChild6>6</GrandChild6>  
            </Child2>  
        </Root>  
  
Dim el1 As XElement = xmlTree...<GrandChild2>(0)  
Dim el2 As XElement = xmlTree...<GrandChild6>(0)  
  
If (XElement.CompareDocumentOrder(el1, el2) = 0) Then  
    Console.WriteLine("Compared elements are the same element")  
ElseIf (XElement.CompareDocumentOrder(el1, el2) > 0) Then  
    Console.WriteLine("el1 is after el2")  
Else  
    Console.WriteLine("el1 is before el2")  
End If  
```  
  
 Ten przykład generuje następujące wyniki:  
  
```  
el1 is before el2  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Dwa węzły nie współużytkują wspólnego elementu nadrzędnego.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateReader">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy <see cref="T:System.Xml.XmlReader" /> dla tego węzła.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateReader">
      <MemberSignature Language="C#" Value="public System.Xml.XmlReader CreateReader ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.XmlReader CreateReader() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.CreateReader" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateReader () As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xml::XmlReader ^ CreateReader();" />
      <MemberSignature Language="F#" Value="member this.CreateReader : unit -&gt; System.Xml.XmlReader" Usage="xNode.CreateReader " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy <see cref="T:System.Xml.XmlReader" /> dla tego węzła.</summary>
        <returns>
          <see cref="T:System.Xml.XmlReader" /> Można odczytać ten węzeł i jego obiektów podrzędnych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj używana tej metody, gdy trzeba podawać innego składnika o <xref:System.Xml.XmlReader>. Na przykład można utworzyć <xref:System.Xml.XmlReader> z [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] drzewa, a następnie przekazać ten czytnik do <xref:System.Xml.XmlDocument.Load%2A>.  
  
 Wszystkie czytników zwrócony przez <xref:System.Xml.XmlReader.Create%2A> są normalizacji czytników. Zawsze wykonują normalizacji podział wiersza i pełne normalizacją atrybutów. Z kolei <xref:System.Xml.XmlReader> zwrócony przez <xref:System.Xml.Linq.XNode.CreateReader%2A> nie jest normalizing czytnika. Przekształca żadnego odstępu. Zwraca także atrybutów, w kolejności, że zostały one dodane, a nie w kolejności nazwa atrybutu.  
  
 [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] nie przechowuje informacji na temat tego, czy atrybuty są domyślne atrybuty. <xref:System.Xml.XmlReader.IsDefault%2A> zawsze zwraca wartość false, niezależnie od tego, czy ten atrybut został wypełniony z wartości domyślnej lub nie.  
  
 `PUBLIC` i `SYSTEM` pseudo atrybutów na <xref:System.Xml.Linq.XDocumentType> nie są dostępne za pośrednictwem <xref:System.Xml.XmlReader.MoveToAttribute%2A?displayProperty=nameWithType> metody. Są one dostępne za pośrednictwem tylko <xref:System.Xml.XmlReader.GetAttribute%2A?displayProperty=nameWithType> metody pobierającej kwalifikowana nazwa atrybutu jako parametr. Jeśli masz pobrać `PUBLIC` lub `SYSTEM` atrybuty, należy użyć <xref:System.Xml.XmlReader.GetAttribute%2A?displayProperty=nameWithType> metody.  
  
 Base64 i BinHex dane nie są obsługiwane. Jeśli próba pobrania tych typów danych (na przykład wywołując <xref:System.Xml.XmlReader.ReadElementContentAsBase64%2A>), zgłosi czytnik <xref:System.NotSupportedException>.  
  
 `xml` Deklaracja nie jest udostępniane przez czytnik. Podczas odczytu, nie wystąpi węzła typu <xref:System.Xml.XmlNodeType.XmlDeclaration>.  
  
   
  
## Examples  
 Poniższy przykład tworzy drzewo XML, tworzy <xref:System.Xml.XmlReader> za pomocą <xref:System.Xml.Linq.XNode.CreateReader%2A> metody i tworzy <xref:System.Xml.XmlDocument> przy użyciu czytnika.  
  
```csharp  
XDocument xmlTree = new XDocument(  
    new XElement("Root",  
        new XAttribute("Att1", "Attribute Content"),  
        new XElement("Child1", 1),  
        new XElement("Child2", 2)  
    )  
);  
XmlReader reader = xmlTree.CreateReader();  
reader.MoveToContent();  
XmlDocument doc = new XmlDocument();  
XmlNode cd = doc.ReadNode(reader);  
doc.AppendChild(cd);  
Console.WriteLine(doc.OuterXml);  
```  
  
```vb  
Dim xmlTree As XDocument =  _   
    <?xml version="1.0" encoding="utf-8" standalone="yes"?>  
        <Root Att1="Attribute Content">  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
        </Root>  
Dim reader As XmlReader = xmlTree.CreateReader()  
reader.MoveToContent()  
Dim doc As XmlDocument = New XmlDocument()  
Dim cd As XmlNode = doc.ReadNode(reader)  
doc.AppendChild(cd)  
Console.WriteLine(doc.OuterXml)  
```  
  
 Ten przykład generuje następujące wyniki:  
  
```xml  
<Root Att1="Attribute Content"><Child1>1</Child1><Child2>2</Child2></Root>  
```  
  
 Inny Użyj tej metody jest przekształcenie XSLT. Można utworzyć drzewa XML, Utwórz <xref:System.Xml.XmlReader> z drzewa XML, Utwórz nowy dokument, a następnie utwórz <xref:System.Xml.XmlWriter> która będzie zapisywała do nowego dokumentu. Następnie można wywołać przekształcenia XSLT, przekazywanie <xref:System.Xml.XmlReader> i <xref:System.Xml.XmlWriter> do przekształcania. Po pomyślnym zakończeniu transformacja, nowe drzewo XML jest wypełniana wyniki transformacji.  
  
```csharp  
string xslMarkup = @"<?xml version='1.0'?>  
<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='1.0'>  
    <xsl:template match='/Parent'>  
        <Root>  
            <C1>  
            <xsl:value-of select='Child1'/>  
            </C1>  
            <C2>  
            <xsl:value-of select='Child2'/>  
            </C2>  
        </Root>  
    </xsl:template>  
</xsl:stylesheet>";  
  
XDocument xmlTree = new XDocument(  
    new XElement("Parent",  
        new XElement("Child1", "Child1 data"),  
        new XElement("Child2", "Child2 data")  
    )  
);  
  
XDocument newTree = new XDocument();  
using (XmlWriter writer = newTree.CreateWriter()) {  
    // Load the style sheet.  
    XslCompiledTransform xslt = new XslCompiledTransform();  
    xslt.Load(XmlReader.Create(new StringReader(xslMarkup)));  
  
    // Execute the transform and output the results to a writer.  
    xslt.Transform(xmlTree.CreateReader(), writer);  
}  
  
Console.WriteLine(newTree);  
```  
  
```vb  
Dim xslMarkup As XDocument = _   
    <?xml version='1.0'?>  
    <xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='1.0'>  
        <xsl:template match='/Parent'>  
            <Root>  
                <C1>  
                    <xsl:value-of select='Child1'/>  
                </C1>  
                <C2>  
                    <xsl:value-of select='Child2'/>  
                </C2>  
            </Root>  
        </xsl:template>  
    </xsl:stylesheet>  
  
Dim xmlTree As XElement = _   
        <Parent>  
            <Child1>Child1 data</Child1>  
            <Child2>Child2 data</Child2>  
        </Parent>  
  
Dim newTree As XDocument = New XDocument()  
  
Using writer As XmlWriter = newTree.CreateWriter()  
    ' Load the style sheet.  
    Dim xslt As XslCompiledTransform = _  
        New XslCompiledTransform()  
    xslt.Load(xslMarkup.CreateReader())  
  
    ' Execute the transform and output the results to a writer.  
    xslt.Transform(xmlTree.CreateReader(), writer)  
End Using  
  
Console.WriteLine(newTree)  
```  
  
 Ten przykład generuje następujące wyniki:  
  
```xml  
<Root>  
  <C1>Child1 data</C1>  
  <C2>Child2 data</C2>  
</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateReader">
      <MemberSignature Language="C#" Value="public System.Xml.XmlReader CreateReader (System.Xml.Linq.ReaderOptions readerOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.XmlReader CreateReader(valuetype System.Xml.Linq.ReaderOptions readerOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.CreateReader(System.Xml.Linq.ReaderOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xml::XmlReader ^ CreateReader(System::Xml::Linq::ReaderOptions readerOptions);" />
      <MemberSignature Language="F#" Value="member this.CreateReader : System.Xml.Linq.ReaderOptions -&gt; System.Xml.XmlReader" Usage="xNode.CreateReader readerOptions" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="readerOptions" Type="System.Xml.Linq.ReaderOptions" />
      </Parameters>
      <Docs>
        <param name="readerOptions">A <see cref="T:System.Xml.Linq.ReaderOptions" /> obiekt, który określa, czy pominąć zduplikowanych przestrzeni nazw.</param>
        <summary>Tworzy <see cref="T:System.Xml.XmlReader" /> z opcjami określonymi przez <paramref name="readerOptions" /> parametru.</summary>
        <returns>
          <see cref="T:System.Xml.XmlReader" /> Obiektu.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeepEquals">
      <MemberSignature Language="C#" Value="public static bool DeepEquals (System.Xml.Linq.XNode n1, System.Xml.Linq.XNode n2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool DeepEquals(class System.Xml.Linq.XNode n1, class System.Xml.Linq.XNode n2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.DeepEquals(System.Xml.Linq.XNode,System.Xml.Linq.XNode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DeepEquals (n1 As XNode, n2 As XNode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool DeepEquals(System::Xml::Linq::XNode ^ n1, System::Xml::Linq::XNode ^ n2);" />
      <MemberSignature Language="F#" Value="static member DeepEquals : System.Xml.Linq.XNode * System.Xml.Linq.XNode -&gt; bool" Usage="System.Xml.Linq.XNode.DeepEquals (n1, n2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="n1" Type="System.Xml.Linq.XNode" />
        <Parameter Name="n2" Type="System.Xml.Linq.XNode" />
      </Parameters>
      <Docs>
        <param name="n1">Pierwszy <see cref="T:System.Xml.Linq.XNode" /> do porównania.</param>
        <param name="n2">Drugi <see cref="T:System.Xml.Linq.XNode" /> do porównania.</param>
        <summary>Porównuje wartości dwa węzły, w tym wartości wszystkich węzłów podrzędnych.</summary>
        <returns>
          <see langword="true" /> Jeśli węzły są równe; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Czy dwa węzły są takie same należy ustalić następujące kryteria:  
  
-   A `null` węzeł jest równa innej `null` węzła, ale nierówne niż`null` węzła.  
  
-   Dwa <xref:System.Xml.Linq.XNode> obiekty o różnych typach nigdy nie są takie same.  
  
-   Dwa <xref:System.Xml.Linq.XText> węzły są takie same, które zawierają ten sam tekst.  
  
-   Dwa <xref:System.Xml.Linq.XElement> węzły są takie same, gdy mają one taką samą nazwę tagu, ten sam zestaw atrybutów, które mają takie same wartości, a (Ignorowanie komentarze i instrukcji przetwarzania) zawiera dwie sekwencje równej długości równy węzłów zawartości.  
  
-   Dwa <xref:System.Xml.Linq.XDocument> węzły są takie same, jeśli ich węzłów głównych są takie same.  
  
-   Dwa <xref:System.Xml.Linq.XComment> węzły są takie same, które zawierają ten sam tekst komentarza.  
  
-   Dwa <xref:System.Xml.Linq.XProcessingInstruction> węzły są takie same, jeśli mają one taką samą docelowych i danych.  
  
-   Dwa <xref:System.Xml.Linq.XDocumentType> węzły są takie same Jeśli mieć tej samej nazwy, identyfikator publiczny, identyfikator systemowy i podzestawu wewnętrznego.  
  
   
  
## Examples  
 W poniższym przykładzie użyto tej metody, aby porównać dwa drzewa XML.  
  
```csharp  
XElement xmlTree1 = new XElement("Root",  
    new XAttribute("Att1", 1),  
    new XAttribute("Att2", 2),  
    new XElement("Child1", 1),  
    new XElement("Child2", "some content")  
);  
XElement xmlTree2 = new XElement("Root",  
    new XAttribute("Att1", 1),  
    new XAttribute("Att2", 2),  
    new XElement("Child1", 1),  
    new XElement("Child2", "some content")  
);  
Console.WriteLine(XNode.DeepEquals(xmlTree1, xmlTree2));  
```  
  
```vb  
Dim xmlTree1 As XElement = _   
        <Root Att1="1" Att2="2">  
            <Child1>1</Child1>  
            <Child2>some content</Child2>  
        </Root>  
  
Dim xmlTree2 As XElement = _   
        <Root Att1="1" Att2="2">  
            <Child1>1</Child1>  
            <Child2>some content</Child2>  
        </Root>  
  
Console.WriteLine(XNode.DeepEquals(xmlTree1, xmlTree2))  
```  
  
 Ten przykład generuje następujące wyniki:  
  
```  
True  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DocumentOrderComparer">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XNodeDocumentOrderComparer DocumentOrderComparer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Xml.Linq.XNodeDocumentOrderComparer DocumentOrderComparer" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XNode.DocumentOrderComparer" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DocumentOrderComparer As XNodeDocumentOrderComparer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Xml::Linq::XNodeDocumentOrderComparer ^ DocumentOrderComparer { System::Xml::Linq::XNodeDocumentOrderComparer ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DocumentOrderComparer : System.Xml.Linq.XNodeDocumentOrderComparer" Usage="System.Xml.Linq.XNode.DocumentOrderComparer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XNodeDocumentOrderComparer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera moduł porównujący, który można porównać pozycji względnej z dwóch węzłów.</summary>
        <value>
          <see cref="T:System.Xml.Linq.XNodeDocumentOrderComparer" /> Porównujące względne położenie dwa węzły.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest głównie używana wewnętrznie do implementacja <xref:System.Xml.Linq.Extensions.InDocumentOrder%2A> — metoda rozszerzenia. Zalecanym podejściem jest zamiast bezpośrednio za pomocą tej właściwości przy użyciu tej metody rozszerzenia.  
  
   
  
## Examples  
 Poniższy przykład tworzy drzewo XML z niektórych elementów. Następnie tworzy <xref:System.Collections.Generic.List%601> z <xref:System.Xml.Linq.XNode> losowo zawiera niektóre elementy z drzewa XML. Sortuje listę za pomocą tej właściwości można pobrać <xref:System.Xml.Linq.XNodeDocumentOrderComparer>, który implementuje <xref:System.Collections.IComparer?displayProperty=nameWithType> i <xref:System.Collections.Generic.IComparer%601?displayProperty=nameWithType> interfejsów.  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5)  
);  
  
List<XNode> nodeList = new List<XNode>();  
nodeList.Add(xmlTree.Element("Child5"));  
nodeList.Add(xmlTree.Element("Child3"));  
nodeList.Add(xmlTree.Element("Child1"));  
  
// Sort nodes in document order.  
nodeList.Sort(XNode.DocumentOrderComparer);  
  
foreach (XElement el in nodeList)  
    Console.WriteLine(el);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <Child3>3</Child3>  
            <Child4>4</Child4>  
            <Child5>5</Child5>  
        </Root>  
  
Dim nodeList As List(Of XNode) = New List(Of XNode)()  
nodeList.Add(xmlTree.Element("Child5"))  
nodeList.Add(xmlTree.Element("Child3"))  
nodeList.Add(xmlTree.Element("Child1"))  
  
' Sort nodes in document order.  
nodeList.Sort(XNode.DocumentOrderComparer)  
  
For Each el In nodeList  
    Console.WriteLine(el)  
Next  
```  
  
 Ten przykład generuje następujące wyniki:  
  
```  
<Child1>1</Child1>  
<Child3>3</Child3>  
<Child5>5</Child5>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ElementsAfterSelf">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca kolekcję równorzędnym elementy tego węzła, w kolejności dokumentu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa odroczonego wykonania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="ElementsAfterSelf">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; ElementsAfterSelf ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; ElementsAfterSelf() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.ElementsAfterSelf" />
      <MemberSignature Language="VB.NET" Value="Public Function ElementsAfterSelf () As IEnumerable(Of XElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XElement ^&gt; ^ ElementsAfterSelf();" />
      <MemberSignature Language="F#" Value="member this.ElementsAfterSelf : unit -&gt; seq&lt;System.Xml.Linq.XElement&gt;" Usage="xNode.ElementsAfterSelf " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca kolekcję równorzędnym elementy tego węzła, w kolejności dokumentu.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> z <see cref="T:System.Xml.Linq.XElement" /> z elementów równorzędnych po tego węzła, w kolejności dokumentu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda obejmuje tylko elementów równorzędnych w zwracanej kolekcji. Nie ma obiektów podrzędnych.  
  
 Ta metoda używa odroczonego wykonania.  
  
   
  
## Examples  
 Poniższy przykład tworzy element z niektórych zawartością złożoną. Następnie używa tej metody do pobierania węzłów w kolejności dokumentu.  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XText("Text content."),  
    new XElement("Child1", "child1 content"),  
    new XElement("Child2", "child2 content"),  
    new XElement("Child3", "child3 content"),  
    new XText("More text content."),  
    new XElement("Child4", "child4 content"),  
    new XElement("Child5", "child5 content")  
);  
XElement child = xmlTree.Element("Child3");  
IEnumerable<XElement> elements = child.ElementsAfterSelf();  
foreach (XElement el in elements)  
    Console.WriteLine(el.Name);  
```  
  
```vb  
Dim xmlTree As XElement = _  
        <Root>Text content.  
            <Child1>child1 content</Child1>  
            <Child2>child2 content</Child2>  
            <Child3>child3 content</Child3>More text content.  
            <Child4>child4 content</Child4>  
            <Child5>child5 content</Child5>  
        </Root>  
  
Dim child As XElement = xmlTree.<Child3>(0)  
Dim elements As IEnumerable(Of XElement) = child.ElementsAfterSelf()  
For Each el In elements  
    Console.WriteLine(el.Name)  
Next  
```  
  
 Ten przykład generuje następujące wyniki:  
  
```  
Child4  
Child5  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ElementsAfterSelf">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; ElementsAfterSelf (System.Xml.Linq.XName name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; ElementsAfterSelf(class System.Xml.Linq.XName name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.ElementsAfterSelf(System.Xml.Linq.XName)" />
      <MemberSignature Language="VB.NET" Value="Public Function ElementsAfterSelf (name As XName) As IEnumerable(Of XElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XElement ^&gt; ^ ElementsAfterSelf(System::Xml::Linq::XName ^ name);" />
      <MemberSignature Language="F#" Value="member this.ElementsAfterSelf : System.Xml.Linq.XName -&gt; seq&lt;System.Xml.Linq.XElement&gt;" Usage="xNode.ElementsAfterSelf name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
      </Parameters>
      <Docs>
        <param name="name">
          <see cref="T:System.Xml.Linq.XName" /> Do dopasowania.</param>
        <summary>Zwraca kolekcję filtrowane elementu równorzędnego elementy tego węzła, w kolejności dokumentu. Tylko elementy, które pasują do <see cref="T:System.Xml.Linq.XName" /> znajdują się w kolekcji.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> z <see cref="T:System.Xml.Linq.XElement" /> z elementów równorzędnych po tego węzła, w kolejności dokumentu. Tylko elementy, które pasują do <see cref="T:System.Xml.Linq.XName" /> znajdują się w kolekcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda obejmuje tylko elementów równorzędnych w zwracanej kolekcji. Nie ma obiektów podrzędnych.  
  
 Ta metoda używa odroczonego wykonania.  
  
   
  
## Examples  
 Poniższy przykład tworzy element z niektórych zawartością złożoną. Następnie używa tej metody można pobrać elementów równorzędnych w kolejności dokumentu.  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XText("Text content."),  
    new XElement("Child1", "child1 content"),  
    new XElement("Child2", "child2 content"),  
    new XElement("Child3", "child3 content"),  
    new XText("More text content."),  
    new XElement("Child4", "child4 content"),  
    new XElement("Child5", "child5 content")  
);  
XElement child = xmlTree.Element("Child3");  
IEnumerable<XElement> elements = child.ElementsAfterSelf("Child4");  
foreach (XElement el in elements)  
    Console.WriteLine(el.Name);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>Text content.  
            <Child1>child1 content</Child1>  
            <Child2>child2 content</Child2>  
            <Child3>child3 content</Child3>More text content.  
            <Child4>child4 content</Child4>  
            <Child5>child5 content</Child5>  
        </Root>  
  
Dim child As XElement = xmlTree.<Child3>(0)  
Dim elements As IEnumerable(Of XElement) = child.ElementsAfterSelf("Child4")  
  
For Each el In elements  
    Console.WriteLine(el.Name)  
Next  
```  
  
 Ten przykład generuje następujące wyniki:  
  
```  
Child4  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ElementsBeforeSelf">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca kolekcję równorzędnym elementów przed tego węzła, w kolejności dokumentu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa odroczonego wykonania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="ElementsBeforeSelf">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; ElementsBeforeSelf ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; ElementsBeforeSelf() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.ElementsBeforeSelf" />
      <MemberSignature Language="VB.NET" Value="Public Function ElementsBeforeSelf () As IEnumerable(Of XElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XElement ^&gt; ^ ElementsBeforeSelf();" />
      <MemberSignature Language="F#" Value="member this.ElementsBeforeSelf : unit -&gt; seq&lt;System.Xml.Linq.XElement&gt;" Usage="xNode.ElementsBeforeSelf " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca kolekcję równorzędnym elementów przed tego węzła, w kolejności dokumentu.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> z <see cref="T:System.Xml.Linq.XElement" /> z elementów równorzędnych przed tego węzła, w kolejności dokumentu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda obejmuje tylko elementów równorzędnych w zwracanej kolekcji. Nie ma obiektów podrzędnych.  
  
 Ta metoda używa odroczonego wykonania.  
  
   
  
## Examples  
 W poniższym przykładzie użyto metody tej osi.  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XText("Text content."),  
    new XElement("Child1", "child1 content"),  
    new XElement("Child2", "child2 content"),  
    new XElement("Child3", "child3 content"),  
    new XText("More text content."),  
    new XElement("Child4", "child4 content"),  
    new XElement("Child5", "child5 content")  
);  
XElement child = xmlTree.Element("Child3");  
IEnumerable<XElement> elements = child.ElementsBeforeSelf();  
foreach (XElement el in elements)  
    Console.WriteLine(el.Name);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>Text content.  
            <Child1>child1 content</Child1>  
            <Child2>child2 content</Child2>  
            <Child3>child3 content</Child3>More text content.  
            <Child4>child4 content</Child4>  
            <Child5>child5 content</Child5>  
        </Root>  
  
Dim child As XElement = xmlTree.<Child3>(0)  
Dim elements As IEnumerable(Of XElement) = child.ElementsBeforeSelf()  
  
For Each el In elements  
    Console.WriteLine(el.Name)  
Next  
```  
  
 Ten przykład generuje następujące wyniki:  
  
```  
Child1  
Child2  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ElementsBeforeSelf">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; ElementsBeforeSelf (System.Xml.Linq.XName name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; ElementsBeforeSelf(class System.Xml.Linq.XName name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.ElementsBeforeSelf(System.Xml.Linq.XName)" />
      <MemberSignature Language="VB.NET" Value="Public Function ElementsBeforeSelf (name As XName) As IEnumerable(Of XElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XElement ^&gt; ^ ElementsBeforeSelf(System::Xml::Linq::XName ^ name);" />
      <MemberSignature Language="F#" Value="member this.ElementsBeforeSelf : System.Xml.Linq.XName -&gt; seq&lt;System.Xml.Linq.XElement&gt;" Usage="xNode.ElementsBeforeSelf name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
      </Parameters>
      <Docs>
        <param name="name">
          <see cref="T:System.Xml.Linq.XName" /> Do dopasowania.</param>
        <summary>Zwraca kolekcję filtrowane elementu równorzędnego elementów przed tego węzła, w kolejności dokumentu. Tylko elementy, które pasują do <see cref="T:System.Xml.Linq.XName" /> znajdują się w kolekcji.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> z <see cref="T:System.Xml.Linq.XElement" /> z elementów równorzędnych przed tego węzła, w kolejności dokumentu. Tylko elementy, które pasują do <see cref="T:System.Xml.Linq.XName" /> znajdują się w kolekcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda obejmuje tylko elementów równorzędnych w zwracanej kolekcji. Nie ma obiektów podrzędnych.  
  
 Ta metoda używa odroczonego wykonania.  
  
   
  
## Examples  
 W poniższym przykładzie użyto tej metody.  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XText("Text content."),  
    new XElement("Child1", "child1 content"),  
    new XElement("Child2", "child2 content"),  
    new XElement("Child3", "child3 content"),  
    new XText("More text content."),  
    new XElement("Child4", "child4 content"),  
    new XElement("Child5", "child5 content")  
);  
XElement child = xmlTree.Element("Child3");  
IEnumerable<XElement> elements = child.ElementsBeforeSelf("Child2");  
foreach (XElement el in elements)  
    Console.WriteLine(el.Name);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>Text content.  
            <Child1>child1 content</Child1>  
            <Child2>child2 content</Child2>  
            <Child3>child3 content</Child3>More text content.  
            <Child4>child4 content</Child4>  
            <Child5>child5 content</Child5>  
        </Root>  
  
Dim child As XElement = xmlTree.<Child3>(0)  
Dim elements As IEnumerable(Of XElement) = child.ElementsBeforeSelf("Child2")  
  
For Each el In elements  
    Console.WriteLine(el.Name)  
Next  
```  
  
 Ten przykład generuje następujące wyniki:  
  
```  
Child2  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EqualityComparer">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XNodeEqualityComparer EqualityComparer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Xml.Linq.XNodeEqualityComparer EqualityComparer" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XNode.EqualityComparer" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property EqualityComparer As XNodeEqualityComparer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Xml::Linq::XNodeEqualityComparer ^ EqualityComparer { System::Xml::Linq::XNodeEqualityComparer ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EqualityComparer : System.Xml.Linq.XNodeEqualityComparer" Usage="System.Xml.Linq.XNode.EqualityComparer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XNodeEqualityComparer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera moduł porównujący, który można porównać dwa węzły równości wartości.</summary>
        <value>A <see cref="T:System.Xml.Linq.XNodeEqualityComparer" /> porównujące dwa węzły równości wartości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie użyto tej właściwości można pobrać <xref:System.Xml.Linq.XNodeEqualityComparer>, który implementuje <xref:System.Collections.IEqualityComparer?displayProperty=nameWithType> i <xref:System.Collections.Generic.IEqualityComparer%601?displayProperty=nameWithType> interfejsów. Tworzy słownik, który używa tej właściwości.  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5)  
);  
  
Dictionary<XNode, string> nodeDictionary = new Dictionary<XNode, string>(XNode.EqualityComparer);  
nodeDictionary.Add(xmlTree.Element("Child5"), "Child 5 Information");  
nodeDictionary.Add(xmlTree.Element("Child3"), "Child 3 Information");  
nodeDictionary.Add(xmlTree.Element("Child1"), "Child 1 Information");  
  
string str = nodeDictionary[xmlTree.Element("Child3")];  
Console.WriteLine(str);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <Child3>3</Child3>  
            <Child4>4</Child4>  
            <Child5>5</Child5>  
        </Root>  
  
Dim nodeDictionary As Dictionary(Of XNode, String) = New Dictionary(Of XNode, String)(XNode.EqualityComparer)  
nodeDictionary.Add(xmlTree.Element("Child5"), "Child 5 Information")  
nodeDictionary.Add(xmlTree.Element("Child3"), "Child 3 Information")  
nodeDictionary.Add(xmlTree.Element("Child1"), "Child 1 Information")  
  
Dim str As String = nodeDictionary(xmlTree.Element("Child3"))  
Console.WriteLine(str)  
```  
  
 Ten przykład generuje następujące wyniki:  
  
```  
Child 3 Information  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAfter">
      <MemberSignature Language="C#" Value="public bool IsAfter (System.Xml.Linq.XNode node);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsAfter(class System.Xml.Linq.XNode node) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.IsAfter(System.Xml.Linq.XNode)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsAfter (node As XNode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsAfter(System::Xml::Linq::XNode ^ node);" />
      <MemberSignature Language="F#" Value="member this.IsAfter : System.Xml.Linq.XNode -&gt; bool" Usage="xNode.IsAfter node" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Xml.Linq.XNode" />
      </Parameters>
      <Docs>
        <param name="node">
          <see cref="T:System.Xml.Linq.XNode" /> Do porównania dla kolejności dokumentu.</param>
        <summary>Określa, czy bieżący węzeł widoczny po określony węzeł pod względem kolejności dokumentu.</summary>
        <returns>
          <see langword="true" /> Jeśli ten węzeł jest dostępny po określony węzeł; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.Linq.XContainer> Przechowuje węzły podrzędne jako listę pojedynczo połączone <xref:System.Xml.Linq.XNode> obiektów. Oznacza to, że <xref:System.Xml.Linq.XNode.CompareDocumentOrder%2A> metody muszą przejść elementów nadrzędnych elementu dwa węzły są porównywane aż do znalezienia Wspólnemu elementowi nadrzędnemu. Następnie należy go przechodzenie listy Wspólnemu elementowi nadrzędnemu węzłów podrzędnych można określić kolejność dwa węzły są porównywane. W związku z tym za pomocą tej metody może wpłynąć na wydajność.  
  
   
  
## Examples  
 W poniższym przykładzie użyto tej metody.  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XText("Text content."),  
    new XElement("Child1", "child1 content"),  
    new XElement("Child2", "child2 content"),  
    new XElement("Child3", "child3 content"),  
    new XText("More text content."),  
    new XElement("Child4", "child4 content"),  
    new XElement("Child5", "child5 content")  
);  
XElement child3 = xmlTree.Element("Child3");  
XElement child5 = xmlTree.Element("Child5");  
if (child5.IsAfter(child3))  
    Console.WriteLine("Child5 is after Child3");  
else  
    Console.WriteLine("Child5 is not after Child3");  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>Text content.  
            <Child1>child1 content</Child1>  
            <Child2>child2 content</Child2>  
            <Child3>child3 content</Child3>More text content.  
            <Child4>child4 content</Child4>  
            <Child5>child5 content</Child5>  
        </Root>  
  
Dim child3 As XElement = xmlTree.<Child3>(0)  
Dim child5 As XElement = xmlTree.<Child5>(0)  
If (child5.IsAfter(child3)) Then  
    Console.WriteLine("Child5 is after Child3")  
Else  
    Console.WriteLine("Child5 is not after Child3")  
End If  
```  
  
 Ten przykład generuje następujące wyniki:  
  
```  
Child5 is after Child3  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBefore">
      <MemberSignature Language="C#" Value="public bool IsBefore (System.Xml.Linq.XNode node);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsBefore(class System.Xml.Linq.XNode node) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.IsBefore(System.Xml.Linq.XNode)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsBefore (node As XNode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsBefore(System::Xml::Linq::XNode ^ node);" />
      <MemberSignature Language="F#" Value="member this.IsBefore : System.Xml.Linq.XNode -&gt; bool" Usage="xNode.IsBefore node" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Xml.Linq.XNode" />
      </Parameters>
      <Docs>
        <param name="node">
          <see cref="T:System.Xml.Linq.XNode" /> Do porównania dla kolejności dokumentu.</param>
        <summary>Określa, czy bieżący węzeł widoczny przed określony węzeł pod względem kolejności dokumentu.</summary>
        <returns>
          <see langword="true" /> Jeśli ten węzeł jest dostępny przed określony węzeł; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.Linq.XContainer> Przechowuje węzły podrzędne jako listę pojedynczo połączone <xref:System.Xml.Linq.XNode> obiektów. Oznacza to, że <xref:System.Xml.Linq.XNode.IsBefore%2A> metody muszą przejść elementów nadrzędnych elementu dwa węzły są porównywane aż do znalezienia Wspólnemu elementowi nadrzędnemu. Następnie należy go przechodzenie listy Wspólnemu elementowi nadrzędnemu węzłów podrzędnych można określić kolejność dwa węzły są porównywane. W związku z tym za pomocą tej metody może wpłynąć na wydajność.  
  
   
  
## Examples  
 W poniższym przykładzie użyto tej metody.  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XText("Text content."),  
    new XElement("Child1", "child1 content"),  
    new XElement("Child2", "child2 content"),  
    new XElement("Child3", "child3 content"),  
    new XText("More text content."),  
    new XElement("Child4", "child4 content"),  
    new XElement("Child5", "child5 content")  
);  
XElement child3 = xmlTree.Element("Child3");  
XElement child5 = xmlTree.Element("Child5");  
if (child5.IsBefore(child3))  
    Console.WriteLine("Child5 is before Child3");  
else  
    Console.WriteLine("Child5 is not before Child3");  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>Text content.  
            <Child1>child1 content</Child1>  
            <Child2>child2 content</Child2>  
            <Child3>child3 content</Child3>More text content.  
            <Child4>child4 content</Child4>  
            <Child5>child5 content</Child5>  
        </Root>  
  
Dim child3 As XElement = xmlTree.<Child3>(0)  
Dim child5 As XElement = xmlTree.<Child5>(0)  
If (child5.IsBefore(child3)) Then  
    Console.WriteLine("Child5 is before Child3")  
Else  
    Console.WriteLine("Child5 is not before Child3")  
End If  
```  
  
 Ten przykład generuje następujące wyniki:  
  
```  
Child5 is not before Child3  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NextNode">
      <MemberSignature Language="C#" Value="public System.Xml.Linq.XNode NextNode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Linq.XNode NextNode" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XNode.NextNode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NextNode As XNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::Linq::XNode ^ NextNode { System::Xml::Linq::XNode ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NextNode : System.Xml.Linq.XNode" Usage="System.Xml.Linq.XNode.NextNode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XNode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera węzeł równorzędny next tego węzła.</summary>
        <value>
          <see cref="T:System.Xml.Linq.XNode" /> Zawierający następny węzeł równorzędny.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Xml.Linq.XNode> jest nie ma rekordu nadrzędnego, lub jeśli nie ma żadnego węzła dalej, ta właściwość zwraca `null`.  
  
   
  
## Examples  
 W poniższym przykładzie użyto tej właściwości pętli węzłów.  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XText("Some Text"),  
    new XElement("Child2",  
        2,  
        new XElement("GrandChild", "GrandChild Content")  
    ),  
    new XComment("a comment"),  
    new XElement("Child3")  
);  
XNode node = xmlTree.Element("Child2");  
do {  
    StringBuilder sb = new StringBuilder();  
    sb.Append(String.Format("NodeType: {0}", node.NodeType.ToString().PadRight(10)));  
    switch (node.NodeType)  
    {  
        case XmlNodeType.Text:  
            sb.Append((node as XText).Value);  
            break;  
        case XmlNodeType.Element:  
            sb.Append((node as XElement).Name);  
            break;  
        case XmlNodeType.Comment:  
            sb.Append((node as XComment).Value);  
            break;  
    }  
    Console.WriteLine(sb.ToString());  
}  
while ((node = node.NextNode) != null);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>1</Child1>Some Text  
            <Child2>2  
                <GrandChild>GrandChild Content</GrandChild>  
            </Child2>  
            <!--a comment-->  
            <Child3>3</Child3>  
        </Root>  
  
Dim node As XNode = xmlTree.Element("Child2")  
Do  
    Dim sb As StringBuilder = New StringBuilder()  
    sb.Append(String.Format("NodeType: {0}", node.NodeType.ToString().PadRight(10)))  
    Select Case node.NodeType  
        Case XmlNodeType.Text  
            sb.Append(DirectCast(node, XText).Value)  
        Case XmlNodeType.Element  
            sb.Append(DirectCast(node, XElement).Name)  
        Case XmlNodeType.Comment  
            sb.Append(DirectCast(node, XComment).Value)  
    End Select  
    Console.WriteLine(sb.ToString())  
  
    node = node.NextNode  
Loop While (Not (node Is Nothing))  
```  
  
 Ten przykład generuje następujące wyniki:  
  
```  
NodeType: Element   Child2  
NodeType: Comment   a comment  
NodeType: Element   Child3  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NodesAfterSelf">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XNode&gt; NodesAfterSelf ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XNode&gt; NodesAfterSelf() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.NodesAfterSelf" />
      <MemberSignature Language="VB.NET" Value="Public Function NodesAfterSelf () As IEnumerable(Of XNode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XNode ^&gt; ^ NodesAfterSelf();" />
      <MemberSignature Language="F#" Value="member this.NodesAfterSelf : unit -&gt; seq&lt;System.Xml.Linq.XNode&gt;" Usage="xNode.NodesAfterSelf " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XNode&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca kolekcję równorzędnym węzły tego węzła, w kolejności dokumentu.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> z <see cref="T:System.Xml.Linq.XNode" /> węzły równorzędne po tego węzła, w kolejności dokumentu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda obejmuje tylko elementów równorzędnych w zwracanej kolekcji. Nie ma obiektów podrzędnych.  
  
 Ta metoda używa odroczonego wykonania.  
  
   
  
## Examples  
 Poniższy przykład tworzy drzewo XML, a następnie wysyła zapytanie do drzewa, za pomocą tej metody osi.  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XText("Text content."),  
    new XElement("Child1", "child1 content"),  
    new XElement("Child2", "child2 content"),  
    new XText("More text content."),  
    new XElement("child3", "child3 content")  
);  
XElement child = xmlTree.Element("Child2");  
IEnumerable<XNode> nodes =  
    from node in child.NodesAfterSelf()  
    select node;  
foreach (XNode node in nodes)  
{  
    Console.WriteLine("Node type: {0}  {1}",  
        node.NodeType,  
        node.NodeType == XmlNodeType.Text ? (node as XText).Value : "");  
}  
```  
  
```vb  
Dim xmlTree As XElement = New XElement("Root", _New XText("Text content."), _  
    New XElement("Child1", "child1 content"), _  
    New XElement("Child2", "child2 content"), _  
    New XText("More text content."), _  
    New XElement("child3", "child3 content") _  
)  
  
Dim child As XElement = xmlTree.Element("Child2")  
Dim nodes As IEnumerable(Of XNode) = _  
    From node In child.NodesAfterSelf() _  
    Select node  
For Each node As XNode In nodes  
    Dim s As String = ""  
    If node.NodeType = XmlNodeType.Text Then  
        s = DirectCast(node, XText).Value  
    End If  
    Console.WriteLine("Node type: {0}  {1}", node.NodeType, s)  
Next  
```  
  
 Ten przykład generuje następujące wyniki:  
  
```  
Node type: Text  More text content.  
Node type: Element  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NodesBeforeSelf">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XNode&gt; NodesBeforeSelf ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XNode&gt; NodesBeforeSelf() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.NodesBeforeSelf" />
      <MemberSignature Language="VB.NET" Value="Public Function NodesBeforeSelf () As IEnumerable(Of XNode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XNode ^&gt; ^ NodesBeforeSelf();" />
      <MemberSignature Language="F#" Value="member this.NodesBeforeSelf : unit -&gt; seq&lt;System.Xml.Linq.XNode&gt;" Usage="xNode.NodesBeforeSelf " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XNode&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca kolekcję równorzędnym węzły przed tego węzła, w kolejności dokumentu.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> z <see cref="T:System.Xml.Linq.XNode" /> węzły równorzędne przed tego węzła, w kolejności dokumentu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda obejmuje tylko elementów równorzędnych w zwracanej kolekcji. Nie ma obiektów podrzędnych.  
  
 Ta metoda używa odroczonego wykonania.  
  
   
  
## Examples  
 Poniższy przykład tworzy drzewo XML, a następnie wysyła zapytanie do drzewa, za pomocą tej metody osi.  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XText("Text content."),  
    new XElement("Child1", "child1 content"),  
    new XElement("Child2", "child2 content"),  
    new XText("More text content."),  
    new XElement("child3", "child3 content")  
);  
XElement child = xmlTree.Element("Child2");  
IEnumerable<XNode> nodes =  
    from node in child.NodesBeforeSelf()  
    select node;  
foreach (XNode node in nodes)  
    Console.WriteLine("Node type: {0}  {1}",  
        node.NodeType,  
        node.NodeType == XmlNodeType.Text ? (node as XText).Value : "");  
```  
  
```vb  
Dim xmlTree As XElement = New XElement("Root", _  
    New XText("Text content."), _  
    New XElement("Child1", "child1 content"), _  
    New XElement("Child2", "child2 content"), _  
    New XText("More text content."), _  
    New XElement("child3", "child3 content") _  
)  
  
Dim child As XElement = xmlTree.Element("Child2")  
Dim nodes As IEnumerable(Of XNode) = _  
    From node In child.NodesBeforeSelf() _  
    Select node  
For Each node As XNode In nodes  
    Dim s As String = ""  
    If node.NodeType = XmlNodeType.Text Then  
        s = DirectCast(node, XText).Value  
    End If  
    Console.WriteLine("Node type: {0}  {1}", node.NodeType, s)  
Next  
```  
  
 Ten przykład generuje następujące wyniki:  
  
```  
Node type: Text  Text content.  
Node type: Element  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviousNode">
      <MemberSignature Language="C#" Value="public System.Xml.Linq.XNode PreviousNode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Linq.XNode PreviousNode" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XNode.PreviousNode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PreviousNode As XNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::Linq::XNode ^ PreviousNode { System::Xml::Linq::XNode ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PreviousNode : System.Xml.Linq.XNode" Usage="System.Xml.Linq.XNode.PreviousNode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XNode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera poprzedni węzeł równorzędny tego węzła.</summary>
        <value>
          <see cref="T:System.Xml.Linq.XNode" /> Zawierający poprzedniego węzła tego samego poziomu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Xml.Linq.XNode> jest nie ma rekordu nadrzędnego, lub jeśli nie ma żadnego poprzedniego węzła, ta właściwość zwraca `null`.  
  
 <xref:System.Xml.Linq.XContainer> Przechowuje węzły podrzędne jako listę pojedynczo połączone <xref:System.Xml.Linq.XNode> obiektów. Oznacza to, że <xref:System.Xml.Linq.XNode.PreviousNode%2A> właściwości musi przejść przez listę węzłów bezpośrednich podrzędnych w kontenerze nadrzędnym. W związku z tym za pomocą tej właściwości może mieć wpływ na wydajność.  
  
   
  
## Examples  
 W poniższym przykładzie użyto tej właściwości pętli węzłów.  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XText("Some Text"),  
    new XElement("Child2",  
        2,  
        new XElement("GrandChild", "GrandChild Content")  
    ),  
    new XComment("a comment"),  
    new XElement("Child3")  
);  
XNode node = xmlTree.Element("Child2");  
do {  
    StringBuilder sb = new StringBuilder();  
    sb.Append(String.Format("NodeType: {0}", node.NodeType.ToString().PadRight(10)));  
    switch (node.NodeType)  
    {  
        case XmlNodeType.Text:  
            sb.Append((node as XText).Value);  
            break;  
        case XmlNodeType.Element:  
            sb.Append((node as XElement).Name);  
            break;  
        case XmlNodeType.Comment:  
            sb.Append((node as XComment).Value);  
            break;  
    }  
    Console.WriteLine(sb.ToString());  
}  
while ((node = node.PreviousNode) != null);  
```  
  
```vb  
Dim xmlTree As XElement = _  
    <Root>  
        <Child1>1</Child1>Some Text<Child2>2  
            <GrandChild>GrandChild Content</GrandChild>  
        </Child2>  
        <!--a comment-->  
        <Child3>3</Child3>  
    </Root>  
  
Dim node As XNode = xmlTree.Element("Child2")  
Do  
    Dim sb As StringBuilder = New StringBuilder()  
    sb.Append(String.Format("NodeType: {0}", node.NodeType.ToString().PadRight(10)))  
    Select Case node.NodeType  
        Case XmlNodeType.Text  
            sb.Append(DirectCast(node, XText).Value)  
        Case XmlNodeType.Element  
            sb.Append(DirectCast(node, XElement).Name)  
        Case XmlNodeType.Comment  
            sb.Append(DirectCast(node, XComment).Value)  
    End Select  
    Console.WriteLine(sb.ToString())  
  
    node = node.PreviousNode  
Loop While (Not (node Is Nothing))  
```  
  
 Ten przykład generuje następujące wyniki:  
  
```  
NodeType: Element   Child2  
NodeType: Text      Some Text  
NodeType: Element   Child1  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadFrom">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XNode ReadFrom (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XNode ReadFrom(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadFrom (reader As XmlReader) As XNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Linq::XNode ^ ReadFrom(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="static member ReadFrom : System.Xml.XmlReader -&gt; System.Xml.Linq.XNode" Usage="System.Xml.Linq.XNode.ReadFrom reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Xml.XmlReader" /> Znajduje się w węźle do odczytu do tego <see cref="T:System.Xml.Linq.XNode" />.</param>
        <summary>Tworzy <see cref="T:System.Xml.Linq.XNode" /> z <see cref="T:System.Xml.XmlReader" />.</summary>
        <returns>
          <see cref="T:System.Xml.Linq.XNode" /> Zawiera węzeł i jego węzły podrzędne, które zostały odczytane z czytnika. Typ środowiska uruchomieniowego węzła jest określana przez typ węzła (<see cref="P:System.Xml.Linq.XObject.NodeType" />) pierwszego węzła napotkano w czytniku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia napisanie metody, która zwraca zbiór węzłów, każdy węzeł reaguje, węzeł jest w trybie do odczytu z czytnika. Ta metoda umożliwia przetwarzanie arbitralnie dużych plików XML z zużycie pamięci bardzo mała.  
  
 Czytnik, który jest przekazywany do tej metody może zgłaszają wyjątki. <xref:System.Xml.Linq.XNode.ReadFrom%2A> wszystkie nie przechwytuje wyjątków zgłaszanych przez czytnik; nieobsługiwane wyjątki bąbelkowy do kodu, który wywołał <xref:System.Xml.Linq.XNode.ReadFrom%2A>. W szczególności należy przygotować swój kod obsługi <xref:System.Xml.XmlException>.  
  
 Na przykład sposobu strumienia dokumentów złożonych zobacz [porady: fragmenty XML strumienia z dostępem do informacji w nagłówku](http://msdn.microsoft.com/library/01311522-9d03-4977-8641-2932c6f56092).  
  
 Niektóre standardowy kwerendy operatorów, takich jak <xref:System.Linq.Enumerable.OrderBy%2A>, iteracji ich źródłem Zbieraj wszystkie dane, sortowanie ich i ostatecznie yield pierwszego elementu w sekwencji. Jeśli używasz operator zapytania, który zostaje źródła przed reaguje pierwszy element rozmiaru pamięci nie zostaną zachowane.  
  
 Przykład za pomocą [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] do transformacji dokumentów XML wyjątkowa przy zachowaniu zużycia pamięci, zobacz [porady: wykonaj przesyłania strumieniowego przekształcenie o dużych dokumentów XML](http://msdn.microsoft.com/library/0759e428-6e59-4d80-a506-365d3a6a2b73).  
  
## Examples

W tym przykładzie użyto następującego pliku XML o nazwie *Source.xml*:

[!code-xml[Source.xml](~/samples/snippets/csharp/api/system.xml.linq/xnode/readfrom/Source.xml)]

Poniższy przykład tworzy niestandardowe osi metody, która używa <xref:System.Xml.Linq.XNode.ReadFrom%2A> , a następnie sprawdza osi niestandardowych za pomocą zapytania LINQ:

[!code-csharp[XNode.ReadFromCS](~/samples/snippets/csharp/api/system.xml.linq/xnode/readfrom/Program.cs)]
[!code-vb[XNode.ReadFromVB](~/samples/snippets/visualbasic/api/system.xml.linq/xnode/readfrom/Program.vb)]

Ten przykład generuje następujące wyniki:

```  
bbb  
ccc  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Xml.XmlReader" /> Nie jest ustawiony na typ węzła rozpoznany.</exception>
        <exception cref="T:System.Xml.XmlException">Podstawowa <see cref="T:System.Xml.XmlReader" /> zgłasza wyjątek.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadFromAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Xml.Linq.XNode&gt; ReadFromAsync (System.Xml.XmlReader reader, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Xml.Linq.XNode&gt; ReadFromAsync(class System.Xml.XmlReader reader, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.ReadFromAsync(System.Xml.XmlReader,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task&lt;System::Xml::Linq::XNode ^&gt; ^ ReadFromAsync(System::Xml::XmlReader ^ reader, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member ReadFromAsync : System.Xml.XmlReader * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;System.Xml.Linq.XNode&gt;" Usage="System.Xml.Linq.XNode.ReadFromAsync (reader, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Xml.Linq.XNode&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="reader">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public void Remove ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Remove() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.Remove" />
      <MemberSignature Language="VB.NET" Value="Public Sub Remove ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Remove();" />
      <MemberSignature Language="F#" Value="member this.Remove : unit -&gt; unit" Usage="xNode.Remove " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa ten węzeł po swoim obiekcie nadrzędnym.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] programowania, nie należy manipulować ani zmodyfikować zestaw węzłów, gdy jest kwerenda dla węzłów w tym zestawie. W praktyce to oznacza, że należy nie iteracja zestawu węzłów i usuń je. Zamiast tego należy je do zmaterializowania <xref:System.Collections.Generic.List%601> za pomocą <xref:System.Linq.Enumerable.ToList%2A> — metoda rozszerzenia. Następnie można iteracja listy do usuwania węzłów. Aby uzyskać więcej informacji, zobacz [mieszanych deklaratywne usterki kodu kodu/Imperatywne (LINQ do XML)](http://msdn.microsoft.com/library/d9a5c404-2b0e-46cd-a358-0e78773b3094).  
  
 Alternatywnie, jeśli chcesz usunąć zestaw węzłów, zalecane jest używanie <xref:System.Xml.Linq.Extensions.Remove%2A?displayProperty=nameWithType> metody. Ta metoda kopiuje węzły do listy, a następnie wykonuje iterację na liście, aby usunąć węzłów.  
  
 Ta metoda zostanie podniesiony <xref:System.Xml.Linq.XObject.Changed> i <xref:System.Xml.Linq.XObject.Changing> zdarzenia.  
  
 <xref:System.Xml.Linq.XContainer> Przechowuje węzły podrzędne jako listę pojedynczo połączone <xref:System.Xml.Linq.XNode> obiektów. Oznacza to, że <xref:System.Xml.Linq.XNode.Remove%2A> metody muszą przejść listy węzłów bezpośrednich podrzędnych w kontenerze nadrzędnym. W związku z tym za pomocą tej metody może wpłynąć na wydajność.  
  
   
  
## Examples  
 Poniższy przykład umożliwia usunięcie węzła po swoim obiekcie nadrzędnym.  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", "child1 content"),  
    new XElement("Child2", "child2 content"),  
    new XElement("Child3", "child3 content"),  
    new XElement("Child4", "child4 content"),  
    new XElement("Child5", "child5 content")  
);  
XElement child3 = xmlTree.Element("Child3");  
child3.Remove();  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>child1 content</Child1>  
            <Child2>child2 content</Child2>  
            <Child3>child3 content</Child3>  
            <Child4>child4 content</Child4>  
            <Child5>child5 content</Child5>  
        </Root>  
  
Dim child3 As XElement = xmlTree.<Child3>(0)  
child3.Remove()  
Console.WriteLine(xmlTree)  
```  
  
 Ten przykład generuje następujące wyniki:  
  
```xml  
<Root>  
  <Child1>child1 content</Child1>  
  <Child2>child2 content</Child2>  
  <Child4>child4 content</Child4>  
  <Child5>child5 content</Child5>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Element nadrzędny jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReplaceWith">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zastępuje ten węzeł z określoną zawartością.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać szczegółowe informacje o prawidłowej zawartości, które mogą zostać przekazane do tej metody, zobacz [Nieprawidłowa zawartość klasy XElement i obiektów klasy XDocument](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).  
  
 Ta metoda zostanie podniesiony <xref:System.Xml.Linq.XObject.Changed> i <xref:System.Xml.Linq.XObject.Changing> zdarzenia.  
  
 <xref:System.Xml.Linq.XContainer> Przechowuje węzły podrzędne jako listę pojedynczo połączone <xref:System.Xml.Linq.XNode> obiektów. Oznacza to, że <xref:System.Xml.Linq.XNode.ReplaceWith%2A> metody muszą przejść listy węzłów bezpośrednich podrzędnych w kontenerze nadrzędnym. W związku z tym za pomocą tej metody może wpłynąć na wydajność.  
  
   
  
## Examples  
 W poniższym przykładzie użyto tej metody, aby zastąpić zawartość węzła z inną zawartością.  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", "child1 content"),  
    new XElement("Child2", "child2 content"),  
    new XElement("Child3", "child3 content"),  
    new XElement("Child4", "child4 content"),  
    new XElement("Child5", "child5 content")  
);  
XElement child3 = xmlTree.Element("Child3");  
child3.ReplaceWith(  
    new XElement("NewChild", "new content")  
);  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>child1 content</Child1>  
            <Child2>child2 content</Child2>  
            <Child3>child3 content</Child3>  
            <Child4>child4 content</Child4>  
            <Child5>child5 content</Child5>  
        </Root>  
  
Dim child3 As XElement = xmlTree.<Child3>(0)  
child3.ReplaceWith(<NewChild>new content</NewChild>)  
Console.WriteLine(xmlTree)  
```  
  
 Ten przykład generuje następujące wyniki:  
  
```xml  
<Root>  
  <Child1>child1 content</Child1>  
  <Child2>child2 content</Child2>  
  <NewChild>new content</NewChild>  
  <Child4>child4 content</Child4>  
  <Child5>child5 content</Child5>  
</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReplaceWith">
      <MemberSignature Language="C#" Value="public void ReplaceWith (object content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReplaceWith(object content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.ReplaceWith(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReplaceWith (content As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReplaceWith(System::Object ^ content);" />
      <MemberSignature Language="F#" Value="member this.ReplaceWith : obj -&gt; unit" Usage="xNode.ReplaceWith content" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="content">Zawartość, która zastępuje tego węzła.</param>
        <summary>Zastępuje ten węzeł z określoną zawartością.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda najpierw usuwa ten węzeł po swoim obiekcie nadrzędnym, a następnie dodanie określonej zawartości do tego węzła nadrzędnego, miejsca tego węzła.  
  
 <xref:System.Xml.Linq.XContainer> Przechowuje węzły podrzędne jako listę pojedynczo połączone <xref:System.Xml.Linq.XNode> obiektów. Oznacza to, że <xref:System.Xml.Linq.XNode.ReplaceWith%2A> metody muszą przejść listy węzłów bezpośrednich podrzędnych w kontenerze nadrzędnym. W związku z tym za pomocą tej metody może wpłynąć na wydajność.  
  
 Aby uzyskać szczegółowe informacje o prawidłowej zawartości, które mogą zostać przekazane do tej metody, zobacz [Nieprawidłowa zawartość klasy XElement i obiektów klasy XDocument](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).  
  
 Ta metoda zostanie podniesiony <xref:System.Xml.Linq.XObject.Changed> i <xref:System.Xml.Linq.XObject.Changing> zdarzenia.  
  
   
  
## Examples  
 W poniższym przykładzie użyto tej metody, aby zastąpić zawartość węzła z inną zawartością.  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", "child1 content"),  
    new XElement("Child2", "child2 content"),  
    new XElement("Child3", "child3 content"),  
    new XElement("Child4", "child4 content"),  
    new XElement("Child5", "child5 content")  
);  
XElement child3 = xmlTree.Element("Child3");  
child3.ReplaceWith(  
    new XElement("NewChild", "new content")  
);  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>child1 content</Child1>  
            <Child2>child2 content</Child2>  
            <Child3>child3 content</Child3>  
            <Child4>child4 content</Child4>  
            <Child5>child5 content</Child5>  
        </Root>  
  
Dim child3 As XElement = xmlTree.<Child3>(0)  
child3.ReplaceWith(<NewChild>new content</NewChild>)  
Console.WriteLine(xmlTree)  
```  
  
 Ten przykład generuje następujące wyniki:  
  
```xml  
<Root>  
  <Child1>child1 content</Child1>  
  <Child2>child2 content</Child2>  
  <NewChild>new content</NewChild>  
  <Child4>child4 content</Child4>  
  <Child5>child5 content</Child5>  
</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReplaceWith">
      <MemberSignature Language="C#" Value="public void ReplaceWith (params object[] content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReplaceWith(object[] content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.ReplaceWith(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReplaceWith (ParamArray content As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReplaceWith(... cli::array &lt;System::Object ^&gt; ^ content);" />
      <MemberSignature Language="F#" Value="member this.ReplaceWith : obj[] -&gt; unit" Usage="xNode.ReplaceWith content" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="content">Lista parametrów nową zawartość.</param>
        <summary>Zastępuje ten węzeł z określoną zawartością.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda najpierw usuwa ten węzeł po swoim obiekcie nadrzędnym, a następnie dodanie określonej zawartości do tego węzła nadrzędnego, miejsca tego węzła.  
  
 <xref:System.Xml.Linq.XContainer> Przechowuje węzły podrzędne jako listę pojedynczo połączone <xref:System.Xml.Linq.XNode> obiektów. Oznacza to, że <xref:System.Xml.Linq.XNode.ReplaceWith%2A> metody muszą przejść listy węzłów bezpośrednich podrzędnych w kontenerze nadrzędnym. W związku z tym za pomocą tej metody może wpłynąć na wydajność.  
  
 Aby uzyskać szczegółowe informacje o prawidłowej zawartości, które mogą zostać przekazane do tej metody, zobacz [Nieprawidłowa zawartość klasy XElement i obiektów klasy XDocument](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).  
  
 Ta metoda zostanie podniesiony <xref:System.Xml.Linq.XObject.Changed> i <xref:System.Xml.Linq.XObject.Changing> zdarzenia.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie wyniki [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] zapytania jako dane wejściowe do tej metody.  
  
```csharp  
XElement srcTree = new XElement("Root",  
    new XElement("Element1", 1),  
    new XElement("Element2", 2),  
    new XElement("Element3", 3),  
    new XElement("Element4", 4),  
    new XElement("Element5", 5)  
);  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5)  
);  
XElement child3 = xmlTree.Element("Child3");  
child3.ReplaceWith(  
    from el in srcTree.Elements()  
    where (int)el > 3  
    select el  
);  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Dim srcTree As XElement = _   
        <Root>  
            <Element1>1</Element1>  
            <Element2>2</Element2>  
            <Element3>3</Element3>  
            <Element4>4</Element4>  
            <Element5>5</Element5>  
        </Root>  
  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <Child3>3</Child3>  
            <Child4>4</Child4>  
            <Child5>5</Child5>  
        </Root>  
  
Dim child3 As XElement = xmlTree.<Child3>(0)  
child3.ReplaceWith( _  
    From el In srcTree.Elements() _  
    Where (CInt(el) > 3) _  
    Select el)  
  
Console.WriteLine(xmlTree)  
```  
  
 Ten przykład generuje następujące wyniki:  
  
```xml  
<Root>  
  <Child1>1</Child1>  
  <Child2>2</Child2>  
  <Element4>4</Element4>  
  <Element5>5</Element5>  
  <Child4>4</Child4>  
  <Child5>5</Child5>  
</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca XML dla tego węzła, opcjonalnie wyłączenie formatowania.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="xNode.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wcięta XML dla tego węzła.</summary>
        <returns>A <see cref="T:System.String" /> zawierający wcięta XML.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie użyto tej metody można pobrać z wcięciami XML.  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1)  
);  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>1</Child1>  
        </Root>  
  
Console.WriteLine(xmlTree)  
```  
  
 Ten przykład generuje następujące wyniki:  
  
```xml  
<Root>  
  <Child1>1</Child1>  
</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (System.Xml.Linq.SaveOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(valuetype System.Xml.Linq.SaveOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.ToString(System.Xml.Linq.SaveOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (options As SaveOptions) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::Xml::Linq::SaveOptions options);" />
      <MemberSignature Language="F#" Value="override this.ToString : System.Xml.Linq.SaveOptions -&gt; string" Usage="xNode.ToString options" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Xml.Linq.SaveOptions" />
      </Parameters>
      <Docs>
        <param name="options">A <see cref="T:System.Xml.Linq.SaveOptions" /> , który określa zachowania formatowania.</param>
        <summary>Zwraca XML dla tego węzła, opcjonalnie wyłączenie formatowania.</summary>
        <returns>A <see cref="T:System.String" /> zawierające kod XML.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie użyto tej metody można pobrać niesformatowany i sformatowany XML.  
  
```csharp  
XElement root = XElement.Parse("<Root><Child/></Root>");  
Console.WriteLine(root.ToString(SaveOptions.DisableFormatting));  
Console.WriteLine("---");  
Console.WriteLine(root.ToString(SaveOptions.None));  
```  
  
```vb  
Dim root As XElement = <Root>  
                           <Child/>  
                       </Root>  
Console.WriteLine(root.ToString(SaveOptions.DisableFormatting))  
Console.WriteLine("---")  
Console.WriteLine(root.ToString(SaveOptions.None))  
```  
  
 Ten przykład generuje następujące wyniki:  
  
```  
<Root><Child /></Root>  
---  
<Root>  
  <Child />  
</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteTo">
      <MemberSignature Language="C#" Value="public abstract void WriteTo (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteTo(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.WriteTo(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub WriteTo (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void WriteTo(System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member WriteTo : System.Xml.XmlWriter -&gt; unit" Usage="xNode.WriteTo writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.Xml.XmlWriter" /> Do będzie zapisywać tej metody.</param>
        <summary>Zapisuje ten węzeł, aby <see cref="T:System.Xml.XmlWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do pisania kodu, który wykonuje przesyłania strumieniowego transformacji bardzo dużych dokumentu. Aby uzyskać więcej informacji, zobacz [porady: wykonaj przesyłania strumieniowego przekształcenie o dużych dokumentów XML](http://msdn.microsoft.com/library/0759e428-6e59-4d80-a506-365d3a6a2b73).  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Xml.XmlWriter> który zapisuje <xref:System.Text.StringBuilder>. Następnie używa tej metody można zapisać dwa drzewa XML do usługi składnika zapisywania.  
  
```csharp  
StringBuilder sb = new StringBuilder();  
XmlWriterSettings xws = new XmlWriterSettings();  
xws.OmitXmlDeclaration = true;  
xws.Indent = true;  
  
using (XmlWriter xw = XmlWriter.Create(sb, xws)) {  
    xw.WriteStartElement("Root");  
    XElement child1 = new XElement("Child",  
        new XElement("GrandChild", "some content")  
    );  
    child1.WriteTo(xw);  
    XElement child2 = new XElement("AnotherChild",  
        new XElement("GrandChild", "different content")  
    );  
    child2.WriteTo(xw);  
    xw.WriteEndElement();  
}  
Console.WriteLine(sb.ToString());  
```  
  
```vb  
Dim sb As StringBuilder = New StringBuilder()  
Dim xws As XmlWriterSettings = New XmlWriterSettings()  
xws.OmitXmlDeclaration = True  
xws.Indent = True  
  
Using xw = XmlWriter.Create(sb, xws)  
    xw.WriteStartElement("Root")  
    Dim child1 As XElement = <Child>  
                                 <GrandChild>some content</GrandChild>  
                             </Child>  
    child1.WriteTo(xw)  
    Dim child2 As XElement = <AnotherChild>  
                                 <GrandChild>different content</GrandChild>  
                             </AnotherChild>  
    child2.WriteTo(xw)  
    xw.WriteEndElement()  
End Using  
  
Console.WriteLine(sb.ToString())  
```  
  
 Ten przykład generuje następujące wyniki:  
  
```xml  
<Root>  
  <Child>  
    <GrandChild>some content</GrandChild>  
  </Child>  
  <AnotherChild>  
    <GrandChild>different content</GrandChild>  
  </AnotherChild>  
</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteToAsync">
      <MemberSignature Language="C#" Value="public abstract System.Threading.Tasks.Task WriteToAsync (System.Xml.XmlWriter writer, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task WriteToAsync(class System.Xml.XmlWriter writer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XNode.WriteToAsync(System.Xml.XmlWriter,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Threading::Tasks::Task ^ WriteToAsync(System::Xml::XmlWriter ^ writer, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="abstract member WriteToAsync : System.Xml.XmlWriter * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="xNode.WriteToAsync (writer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="writer">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
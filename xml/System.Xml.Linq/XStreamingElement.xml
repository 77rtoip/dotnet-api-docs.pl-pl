<Type Name="XStreamingElement" FullName="System.Xml.Linq.XStreamingElement">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a860d5aaf67164c2d82b51f8917f71556dbf07cf" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36443305" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class XStreamingElement" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XStreamingElement extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Xml.Linq.XStreamingElement" />
  <TypeSignature Language="VB.NET" Value="Public Class XStreamingElement" />
  <TypeSignature Language="C++ CLI" Value="public ref class XStreamingElement" />
  <TypeSignature Language="F#" Value="type XStreamingElement = class" />
  <AssemblyInfo>
    <AssemblyName>System.Xml.XDocument</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml.Linq</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Reprezentuje elementy drzewa XML, który obsługuje odroczonego przesyłania strumieniowego danych wyjściowych.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta klasa służy do tworzenia drzewa XML, który obsługuje odroczonego przesyłania strumieniowego danych wyjściowych. Ta klasa umożliwia tworzenie drzewo XML w bardzo podobnie do tworzenia drzewa XML przy użyciu <xref:System.Xml.Linq.XElement>. Istnieje jednak różnica podstawowych. Jeśli używasz zapytania LINQ do określania zawartości, gdy tworzenie XML drzewa przy użyciu <xref:System.Xml.Linq.XElement>zmienną zapytania jest iterowane w czasie tworzenia drzewa XML i wyniki zapytania są dodawane do drzewa XML. Z kolei, podczas tworzenia drzewa XML przy użyciu <xref:System.Xml.Linq.XStreamingElement>, odwołanie do zmiennej zapytania przechowywanego w drzewie XML bez trwa iterowane. Zapytania są iterowane dopiero po serializacji. Dzięki temu można utworzyć większą drzew XML przy zachowaniu mniejsze zużycie pamięci.  
  
 Jeśli są strumieniowego ze źródła danych wejściowych, na przykład plik tekstowy można odczytywanie pliku tekstowego bardzo dużych i generować bardzo duże dokumentu XML przy zachowaniu zużycia pamięci.  
  
 Inny scenariusz jest duża drzewo XML, które zostało załadowane do pamięci, czy chcesz utworzyć przekształcone wersji dokumentu. W przypadku utworzenia nowego dokumentu przy użyciu <xref:System.Xml.Linq.XElement>, a następnie będzie mieć dwa dużych drzew XML w pamięci po zakończeniu transformacji. Jednak w przypadku utworzenia nowego XML drzewa przy użyciu <xref:System.Xml.Linq.XStreamingElement>, a następnie zestaw roboczy będzie efektywnie podzielone na pół.  
  
 Należy pamiętać, że podczas debugowania program, który używa <xref:System.Xml.Linq.XStreamingElement>, wyświetlania wartości obiektu powoduje, że jego <xref:System.Xml.Linq.XStreamingElement.ToString%2A> wywoływanej metody. Powoduje to XML można było serializować. Jeśli semantykę przesyłania strumieniowego zapytania elementu tak, aby element przesyłania strumieniowego przesyłane strumieniowo tylko raz, to może spowodować niepożądane zachowanie środowiska debugowania.  
  
   
  
## Examples  
 Poniższy przykład tworzy najpierw drzewa XML źródła. Następnie tworzy transformacji użycia drzewa XML źródła <xref:System.Xml.Linq.XElement>. Tej transformacji tworzy nowe drzewo w pamięci. Następnie tworzy transformacji użycia drzewa XML źródła <xref:System.Xml.Linq.XStreamingElement>. Tej transformacji nie wykonać zapytanie, aż po przekształceniu drzewa jest serializowany w konsoli. Jego użycie pamięci jest mniejsza.  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
XElement dstTree1 = new XElement("NewRoot",  
                        from el in srcTree.Elements()  
                        where (int)el >= 3  
                        select new XElement("DifferentChild", (int)el)  
                    );  
  
XStreamingElement dstTree2 = new XStreamingElement("NewRoot",  
                        from el in srcTree.Elements()  
                        where (int)el >= 3  
                        select new XElement("DifferentChild", (int)el)  
                    );  
  
Console.WriteLine(dstTree1);  
Console.WriteLine("------");  
Console.WriteLine(dstTree2);  
```  
  
```vb  
Dim srcTree As XElement = _  
        <Root>  
            <Child>1</Child>  
            <Child>2</Child>  
            <Child>3</Child>  
            <Child>4</Child>  
            <Child>5</Child>  
        </Root>  
  
Dim dstTree1 As XElement = _  
    <NewRoot>  
        <%= From el In srcTree.Elements _  
            Where (el.Value >= 3) _  
            Select <DifferentChild><%= el.Value %></DifferentChild> %>  
    </NewRoot>  
  
Dim dstTree2 As XStreamingElement = New XStreamingElement("NewRoot", _  
                From el In srcTree.Elements _  
                Where el.Value >= 3 _  
                Select <DifferentChild><%= el.Value %></DifferentChild> _  
            )  
  
Console.WriteLine(dstTree1)  
Console.WriteLine("------")  
Console.WriteLine(dstTree2)  
```  
  
 Ten przykład generuje następujące wyniki:  
  
```  
<NewRoot>  
  <DifferentChild>3</DifferentChild>  
  <DifferentChild>4</DifferentChild>  
  <DifferentChild>5</DifferentChild>  
</NewRoot>  
------  
<NewRoot>  
  <DifferentChild>3</DifferentChild>  
  <DifferentChild>4</DifferentChild>  
  <DifferentChild>5</DifferentChild>  
</NewRoot>  
```  
  
 Jeden ze sposobów przetwarzania pliku tekstowego służy do zapisania — metoda rozszerzenia pliku tekstowego strumieni linii w czasie przy użyciu `yield return` utworzenia. Następnie można pisać zapytania LINQ, który przetwarza w pliku tekstowym w sposób odroczonego opóźnieniem. Jeśli następnie użyć <xref:System.Xml.Linq.XStreamingElement> do strumienia wyjściowego, następnie można utworzyć transformacji w pliku tekstowym na kod XML, który używa minimalnej ilości pamięci, niezależnie od rozmiaru pliku źródłowego.  
  
 Następujący plik tekstowy, People.txt, jest źródła w ramach tego przykładu.  
  
```  
#This is a comment  
1,Tai,Yee,Writer  
2,Nikolay,Grachev,Programmer  
3,David,Wright,Inventor  
```  
  
 Poniższy kod zawiera metody rozszerzenia, które wiersze w pliku tekstowym w sposób odroczonego strumieni.  
  
```csharp  
public static class StreamReaderSequence  
{  
    public static IEnumerable<string> Lines(this StreamReader source)  
    {  
        String line;  
  
        if (source == null)  
            throw new ArgumentNullException("source");  
        while ((line = source.ReadLine()) != null)  
        {  
            yield return line;  
        }  
    }  
}  
  
class Program  
{  
    static void Main(string[] args)  
    {  
        StreamReader sr = new StreamReader("People.txt");  
        XStreamingElement xmlTree = new XStreamingElement("Root",  
            from line in sr.Lines()  
            let items = line.Split(',')  
            where !line.StartsWith("#")  
            select new XElement("Person",  
                       new XAttribute("ID", items[0]),  
                       new XElement("First", items[1]),  
                       new XElement("Last", items[2]),  
                       new XElement("Occupation", items[3])  
                   )  
        );  
        Console.WriteLine(xmlTree);  
        sr.Close();  
    }  
}  
```  
  
```vb  
Module StreamReaderSequence  
  
    <Runtime.CompilerServices.Extension>  
    Public Iterator Function Lines(source As IO.StreamReader) As IEnumerable(Of String)  
        If source Is Nothing Then Throw New ArgumentNullException("source")  
        Dim line As String = source.ReadLine()  
        While (line <> Nothing)  
            Yield line  
            line = source.ReadLine()  
        End While  
    End Function  
  
End Module  
  
Module Module1  
    Sub Main()  
        Dim sr As New IO.StreamReader("People.txt")  
        Dim xmlTree As New XStreamingElement("Root",  
            From line In sr.Lines()  
            Let items = line.Split(","c)  
            Where Not line.StartsWith("#")  
            Select <Person ID=<%= items(0) %>>  
                       <First><%= items(1) %></First>  
                       <Last><%= items(2) %></Last>  
                       <Occupation><%= items(3) %></Occupation>  
                   </Person>)  
        Console.WriteLine(xmlTree)  
        sr.Close()  
    End Sub  
End Module  
```  
  
 Ten przykład generuje następujące wyniki:  
  
```xml  
<Root>  
  <Person ID="1">  
    <First>Tai</First>  
    <Last>Yee</Last>  
    <Occupation>Writer</Occupation>  
  </Person>  
  <Person ID="2">  
    <First>Nikolay</First>  
    <Last>Grachev</Last>  
    <Occupation>Programmer</Occupation>  
  </Person>  
  <Person ID="3">  
    <First>David</First>  
    <Last>Wright</Last>  
    <Occupation>Inventor</Occupation>  
  </Person>  
</Root>  
```  
  
 Czasami trzeba transformacji dużych plików XML i zapisać aplikacji, dzięki czemu zużycie pamięci aplikacji jest atrybutem wartości prognozowanych. Jeśli spróbujesz wypełnić drzewo XML z bardzo dużych plików XML, użycie pamięci będzie proporcjonalny do rozmiaru pliku (to znaczy nadmiernego). W związku z tym należy w zamian użyj technika przesyłania strumieniowego.  
  
 Niektóre standardowy kwerendy operatorów, takich jak <xref:System.Linq.Enumerable.OrderBy%2A>, iteracji ich źródłem Zbieraj wszystkie dane, sortowanie ich i ostatecznie yield pierwszego elementu w sekwencji. Należy pamiętać, że użycie operatora zapytania, który zostaje źródła przed reaguje pierwszy element można nie zostaną zachowane zużycie pamięci dla aplikacji.  
  
 Nawet jeśli używasz techniki opisane w, Jeśli spróbujesz złóż drzewa XML, który zawiera dokument przekształcone, użycie pamięci może być zbyt duża.  
  
 Poniższy przykład tworzy na przykład w [porady: strumień fragmenty XML z dostępem do informacji w nagłówku](http://msdn.microsoft.com/library/01311522-9d03-4977-8641-2932c6f56092).  
  
 W tym przykładzie użyto możliwości wykonanie odroczone <xref:System.Xml.Linq.XStreamingElement> do strumienia wyjściowego.  
  
 Należy pamiętać, że niestandardowe osi (`StreamCustomerItem`), aby oczekuje, że dokument jest opracowane specjalnie mający `Customer`, `Name`, i `Item` elementy i rozmieszczenia tych elementów, jak w następującym dokumencie Source.xml. Jednak implementacja bardziej niezawodne, czy albo sprawdza, czy dokument źródłowy schematu XSD lub jest gotowy do analizy nieprawidłowy dokument.  
  
 Poniżej przedstawiono dokument źródłowy Source.xml:  
  
```xml  
<?xml version="1.0" encoding="utf-8" ?>   
<Root>  
  <Customer>  
    <Name>A. Datum Corporation</Name>  
    <Item>  
      <Key>0001</Key>  
    </Item>  
    <Item>  
      <Key>0002</Key>  
    </Item>  
    <Item>  
      <Key>0003</Key>  
    </Item>  
    <Item>  
      <Key>0004</Key>  
    </Item>  
  </Customer>  
  <Customer>  
    <Name>Fabrikam, Inc.</Name>  
    <Item>  
      <Key>0005</Key>  
    </Item>  
    <Item>  
      <Key>0006</Key>  
    </Item>  
    <Item>  
      <Key>0007</Key>  
    </Item>  
    <Item>  
      <Key>0008</Key>  
    </Item>  
  </Customer>  
  <Customer>  
    <Name>Southridge Video</Name>  
    <Item>  
      <Key>0009</Key>  
    </Item>  
    <Item>  
      <Key>0010</Key>  
    </Item>  
  </Customer>  
</Root>  
```  
  
 Poniższy kod zawiera metody, która używa <xref:System.Xml.XmlReader> strumieniowe źródło XML. Używa <xref:System.Xml.Linq.XStreamingElement> do strumienia nowego pliku XML.  
  
```csharp  
static IEnumerable<XElement> StreamCustomerItem(string uri)  
{  
    using (XmlReader reader = XmlReader.Create(uri))  
    {  
        XElement name = null;  
        XElement item = null;  
  
        reader.MoveToContent();  
  
        // Parse the file, save header information when encountered, and yield the  
        // Item XElement objects as they are created.  
  
        // loop through Customer elements  
        while (reader.Read())  
        {  
            if (reader.NodeType == XmlNodeType.Element  
                && reader.Name == "Customer")  
            {  
                // move to Name element  
                while (reader.Read())  
                {  
                    if (reader.NodeType == XmlNodeType.Element &&  
                        reader.Name == "Name")  
                    {  
                        name = XElement.ReadFrom(reader) as XElement;  
                        break;  
                    }  
                }  
  
                // loop through Item elements  
                while (reader.Read())  
                {  
                    if (reader.NodeType == XmlNodeType.EndElement)  
                        break;  
                    if (reader.NodeType == XmlNodeType.Element  
                        && reader.Name == "Item")  
                    {  
                        item = XElement.ReadFrom(reader) as XElement;  
                        if (item != null)  
                        {  
                            XElement tempRoot = new XElement("Root",  
                                new XElement(name)  
                            );  
                            tempRoot.Add(item);  
                            yield return item;  
                        }  
                    }  
                }  
            }  
        }  
    }  
}  
  
static void Main(string[] args)  
{  
    XStreamingElement root = new XStreamingElement("Root",  
        from el in StreamCustomerItem("Source.xml")  
        select new XElement("Item",  
            new XElement("Customer", (string)el.Parent.Element("Name")),  
            new XElement(el.Element("Key"))  
        )  
    );  
    root.Save("Test.xml");  
    Console.WriteLine(File.ReadAllText("Test.xml"));  
}  
```  
  
```vb  
Iterator Function StreamCustomerItem(uri As String) As IEnumerable(Of XElement)  
  
    Dim name As XElement = Nothing  
    Dim item As XElement = Nothing  
  
    Dim reader As XmlReader = XmlReader.Create(uri)  
    reader.MoveToContent()  
  
    ' Parse the file, save header information when encountered, and yield the  
    ' Item XElement objects as they are created.  
  
    ' Loop through Customer elements.  
    While (reader.Read())  
        If (reader.NodeType = XmlNodeType.Element And reader.Name = "Customer") Then  
            While (reader.Read())  
                ' Move to Name element  
                If (reader.NodeType = XmlNodeType.Element And reader.Name = "Name") Then  
                    name = CType(XElement.ReadFrom(reader), XElement)  
                    Exit While  
                End If  
            End While  
  
            ' Loop through Item elements  
            While (reader.Read())  
                If (reader.NodeType = XmlNodeType.EndElement) Then  
                    Exit While  
                End If  
  
                If (reader.NodeType = XmlNodeType.Element And reader.Name = "Item") Then  
                    item = CType(XElement.ReadFrom(reader), XElement)  
                    If (Not (item Is Nothing)) Then  
                        Dim tempRoot = New XElement("Root",  
                            New XElement(name)  
                        )  
                        tempRoot.Add(item)  
                        Yield item  
                     End If  
                End If  
            End While  
        End If  
     End While  
    reader.Close()  
End Function  
  
Sub Main()  
    Dim root As New XStreamingElement("Root",  
        From el In StreamCustomerItem("c:\trash\Source.xml")  
        Select New XElement("Item",  
            New XElement("Customer", CStr(el.Parent.Element("Name"))),  
            New XElement(el.Element("Key"))))  
    root.Save("c:\trash\Test.xml")  
    Console.WriteLine(System.IO.File.ReadAllText("c:\trash\Test.xml"))  
End Sub  
```  
  
 Ten przykład generuje następujące wyniki:  
  
```xml  
<?xml version="1.0" encoding="utf-8"?>  
<Root>  
  <Item>  
    <Customer>A. Datum Corporation</Customer>  
    <Key>0001</Key>  
  </Item>  
  <Item>  
    <Customer>A. Datum Corporation</Customer>  
    <Key>0002</Key>  
  </Item>  
  <Item>  
    <Customer>A. Datum Corporation</Customer>  
    <Key>0003</Key>  
  </Item>  
  <Item>  
    <Customer>A. Datum Corporation</Customer>  
    <Key>0004</Key>  
  </Item>  
  <Item>  
    <Customer>Fabrikam, Inc.</Customer>  
    <Key>0005</Key>  
  </Item>  
  <Item>  
    <Customer>Fabrikam, Inc.</Customer>  
    <Key>0006</Key>  
  </Item>  
  <Item>  
    <Customer>Fabrikam, Inc.</Customer>  
    <Key>0007</Key>  
  </Item>  
  <Item>  
    <Customer>Fabrikam, Inc.</Customer>  
    <Key>0008</Key>  
  </Item>  
  <Item>  
    <Customer>Southridge Video</Customer>  
    <Key>0009</Key>  
  </Item>  
  <Item>  
    <Customer>Southridge Video</Customer>  
    <Key>0010</Key>  
  </Item>  
</Root>  
```  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Xml.Linq.XStreamingElement" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zapytania nie są iterowane do <xref:System.Xml.Linq.XStreamingElement> jest serializowany. Dzięki temu nie trzeba za pomocą zapytań dla zawartości <xref:System.Xml.Linq.XElement>, których kwerendy są iterowane w czasie tworzenia nowej <xref:System.Xml.Linq.XElement>.  
  
 Aby uzyskać szczegółowe informacje o prawidłowej zawartości, które mogą zostać przekazane do tego konstruktora, zobacz [Nieprawidłowa zawartość klasy XElement i obiektów klasy XDocument](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XStreamingElement (System.Xml.Linq.XName name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.Linq.XName name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.#ctor(System.Xml.Linq.XName)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As XName)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XStreamingElement(System::Xml::Linq::XName ^ name);" />
      <MemberSignature Language="F#" Value="new System.Xml.Linq.XStreamingElement : System.Xml.Linq.XName -&gt; System.Xml.Linq.XStreamingElement" Usage="new System.Xml.Linq.XStreamingElement name" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
      </Parameters>
      <Docs>
        <param name="name">
          <see cref="T:System.Xml.Linq.XName" /> Zawierającą nazwę elementu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Xml.Linq.XElement" /> klasy z określonego <see cref="T:System.Xml.Linq.XName" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor tworzy przesyłania strumieniowego element zawartości i żadne atrybuty.  
  
 Istnieje niejawna konwersja z ciągu na <xref:System.Xml.Linq.XName>. Typowym zastosowaniem tego konstruktora jest określenie ciągu jako parametr zamiast tworzenia nowego <xref:System.Xml.Linq.XName>.  
  
   
  
## Examples  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
XStreamingElement dstTree = new XStreamingElement("NewRoot",  
                        from el in srcTree.Elements()  
                        where (int)el >= 3  
                        select new XElement("DifferentChild", (int)el)  
                    );  
  
Console.WriteLine(dstTree);  
```  
  
```vb  
Dim srcTree As XElement = _  
        <Root>  
            <Child>1</Child>  
            <Child>2</Child>  
            <Child>3</Child>  
            <Child>4</Child>  
            <Child>5</Child>  
        </Root>  
  
Dim dstTree As XStreamingElement = New XStreamingElement("NewRoot", _  
                From el In srcTree.Elements _  
                Where el.Value >= 3 _  
                Select <DifferentChild><%= el.Value %></DifferentChild> _  
            )  
  
Console.WriteLine(dstTree)  
```  
  
 Ten przykład generuje następujące wyniki:  
  
```  
<NewRoot>  
  <DifferentChild>3</DifferentChild>  
  <DifferentChild>4</DifferentChild>  
  <DifferentChild>5</DifferentChild>  
</NewRoot>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XStreamingElement (System.Xml.Linq.XName name, object content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.Linq.XName name, object content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.#ctor(System.Xml.Linq.XName,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As XName, content As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XStreamingElement(System::Xml::Linq::XName ^ name, System::Object ^ content);" />
      <MemberSignature Language="F#" Value="new System.Xml.Linq.XStreamingElement : System.Xml.Linq.XName * obj -&gt; System.Xml.Linq.XStreamingElement" Usage="new System.Xml.Linq.XStreamingElement (name, content)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
        <Parameter Name="content" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">
          <see cref="T:System.Xml.Linq.XName" /> Zawierający w nazwie elementu.</param>
        <param name="content">Zawartość elementu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Xml.Linq.XStreamingElement" /> z określoną nazwą i zawartości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor tworzy przesyłania strumieniowego element z określoną zawartością i atrybutów.  
  
 Istnieje niejawna konwersja z ciągu na <xref:System.Xml.Linq.XName>. Typowym zastosowaniem tego konstruktora jest określenie ciągu jako parametr zamiast tworzenia nowego <xref:System.Xml.Linq.XName>.  
  
 Zapytania nie są iterowane do <xref:System.Xml.Linq.XStreamingElement> jest serializowany. Dzięki temu nie trzeba za pomocą zapytań dla zawartości <xref:System.Xml.Linq.XElement>, których kwerendy są iterowane w czasie tworzenia nowej <xref:System.Xml.Linq.XElement>.  
  
 Aby uzyskać szczegółowe informacje o prawidłowej zawartości, które mogą zostać przekazane do tego konstruktora, zobacz [Nieprawidłowa zawartość klasy XElement i obiektów klasy XDocument](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).  
  
   
  
## Examples  
 W tym przykładzie używane następującego pliku XML o nazwie Source.xml:  
  
```xml  
<?xml version="1.0" encoding="utf-8" ?>   
<Root>  
  <Child Key="01">  
    <GrandChild>aaa</GrandChild>  
  </Child>  
  <Child Key="02">  
    <GrandChild>bbb</GrandChild>  
  </Child>  
  <Child Key="03">  
    <GrandChild>ccc</GrandChild>  
  </Child>  
</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XStreamingElement (System.Xml.Linq.XName name, params object[] content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.Linq.XName name, object[] content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.#ctor(System.Xml.Linq.XName,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As XName, ParamArray content As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XStreamingElement(System::Xml::Linq::XName ^ name, ... cli::array &lt;System::Object ^&gt; ^ content);" />
      <MemberSignature Language="F#" Value="new System.Xml.Linq.XStreamingElement : System.Xml.Linq.XName * obj[] -&gt; System.Xml.Linq.XStreamingElement" Usage="new System.Xml.Linq.XStreamingElement (name, content)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
        <Parameter Name="content" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="name">
          <see cref="T:System.Xml.Linq.XName" /> Zawierający w nazwie elementu.</param>
        <param name="content">Zawartość elementu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Xml.Linq.XStreamingElement" /> z określoną nazwą i zawartości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor tworzy przesyłania strumieniowego element z określoną zawartością i atrybutów.  
  
 Istnieje niejawna konwersja z ciągu na <xref:System.Xml.Linq.XName>. Typowym zastosowaniem tego konstruktora jest określenie ciągu jako parametr zamiast tworzenia nowego <xref:System.Xml.Linq.XName>.  
  
 Zapytania nie są iterowane do <xref:System.Xml.Linq.XStreamingElement> jest serializowany. Dzięki temu nie trzeba za pomocą zapytań dla zawartości <xref:System.Xml.Linq.XElement>, których kwerendy są iterowane w czasie tworzenia nowej <xref:System.Xml.Linq.XElement>.  
  
 Aby uzyskać szczegółowe informacje o prawidłowej zawartości, które mogą zostać przekazane do tej funkcji, zobacz [Nieprawidłowa zawartość klasy XElement i obiektów klasy XDocument](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).  
  
   
  
## Examples  
 W tym przykładzie używane następującego pliku XML o nazwie Source.xml:  
  
```xml  
<?xml version="1.0" encoding="utf-8" ?>   
<Root>  
  <Child Key="01">  
    <GrandChild>aaa</GrandChild>  
  </Child>  
  <Child Key="02">  
    <GrandChild>bbb</GrandChild>  
  </Child>  
  <Child Key="03">  
    <GrandChild>ccc</GrandChild>  
  </Child>  
</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dodaje zawartość określonego jako elementy podrzędne tej <see cref="T:System.Xml.Linq.XStreamingElement" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (object content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Add(object content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (content As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Add(System::Object ^ content);" />
      <MemberSignature Language="F#" Value="member this.Add : obj -&gt; unit" Usage="xStreamingElement.Add content" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="content">Zawartość ma zostać dodana do elementu przesyłania strumieniowego.</param>
        <summary>Dodaje zawartość określonego jako elementy podrzędne tej <see cref="T:System.Xml.Linq.XStreamingElement" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor dodaje określoną zawartością i atrybuty do <xref:System.Xml.Linq.XStreamingElement>. Mimo że często jest możliwa do utworzenia <xref:System.Xml.Linq.XStreamingElement> w jednej instrukcji, jest czasami więcej wygodny można dodać zawartości do przesyłania strumieniowego element przyrostowo.  
  
 Zapytania nie są iterowane do <xref:System.Xml.Linq.XStreamingElement> jest serializowany. Dzięki temu nie trzeba za pomocą zapytań dla zawartości <xref:System.Xml.Linq.XElement>, których kwerendy są iterowane w czasie tworzenia nowej <xref:System.Xml.Linq.XElement>.  
  
 Aby uzyskać szczegółowe informacje o prawidłowej zawartości, które mogą zostać przekazane do tej funkcji, zobacz [Nieprawidłowa zawartość klasy XElement i obiektów klasy XDocument](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).  
  
   
  
## Examples  
 Poniższy przykład tworzy nową <xref:System.Xml.Linq.XStreamingElement>. Następnie dodaje dwa zapytania do elementu przesyłania strumieniowego. Zapytania nie są iterowane, dopóki nie jest serializowany element przesyłania strumieniowego.  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
XStreamingElement dstTree = new XStreamingElement("NewRoot");  
  
dstTree.Add(  
    from el in srcTree.Elements()  
    where (int)el <= 1  
    select new XElement("Child", (int)el)  
);  
  
dstTree.Add(  
    from el in srcTree.Elements()  
    where (int)el >= 3  
    select new XElement("DifferentChild", (int)el)  
);  
  
Console.WriteLine(dstTree);  
```  
  
```vb  
Dim srcTree As XElement = _  
    <Root>  
        <Child>1</Child>  
        <Child>2</Child>  
        <Child>3</Child>  
        <Child>4</Child>  
        <Child>5</Child>  
    </Root>  
  
Dim dstTree As XStreamingElement = New XStreamingElement("NewRoot")  
  
dstTree.Add( _  
    From el In srcTree.Elements() _  
    Where el.Value <= 1 _  
    Select <Child><%= el.Value %></Child> _  
)  
  
dstTree.Add( _  
    From el In srcTree.Elements() _  
    Where el.Value >= 3 _  
    Select <DifferentChild><%= el.Value %></DifferentChild> _  
)  
  
Console.WriteLine(dstTree)  
```  
  
 Ten przykład generuje następujące wyniki:  
  
```xml  
<NewRoot>  
  <Child>1</Child>  
  <DifferentChild>3</DifferentChild>  
  <DifferentChild>4</DifferentChild>  
  <DifferentChild>5</DifferentChild>  
</NewRoot>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (params object[] content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Add(object[] content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.Add(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (ParamArray content As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Add(... cli::array &lt;System::Object ^&gt; ^ content);" />
      <MemberSignature Language="F#" Value="member this.Add : obj[] -&gt; unit" Usage="xStreamingElement.Add content" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="content">Zawartość ma zostać dodana do elementu przesyłania strumieniowego.</param>
        <summary>Dodaje zawartość określonego jako elementy podrzędne tej <see cref="T:System.Xml.Linq.XStreamingElement" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor dodaje określoną zawartością i atrybuty do <xref:System.Xml.Linq.XStreamingElement>. Mimo że często jest możliwa do utworzenia <xref:System.Xml.Linq.XStreamingElement> w jednej instrukcji, jest czasami więcej wygodny można dodać zawartości do przesyłania strumieniowego element przyrostowo.  
  
 Zapytania nie są iterowane do <xref:System.Xml.Linq.XStreamingElement> jest serializowany. Dzięki temu nie trzeba za pomocą zapytań dla zawartości <xref:System.Xml.Linq.XElement>, których kwerendy są iterowane w czasie tworzenia nowej <xref:System.Xml.Linq.XElement>.  
  
 Aby uzyskać szczegółowe informacje o prawidłowej zawartości, które mogą zostać przekazane do tej funkcji, zobacz [Nieprawidłowa zawartość klasy XElement i obiektów klasy XDocument](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).  
  
   
  
## Examples  
 Poniższy przykład tworzy nową <xref:System.Xml.Linq.XStreamingElement>. Następnie dodaje dwa zapytania do elementu przesyłania strumieniowego. Zapytania nie są iterowane, dopóki nie jest serializowany element przesyłania strumieniowego.  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
XStreamingElement dstTree = new XStreamingElement("NewRoot");  
  
dstTree.Add(  
    from el in srcTree.Elements()  
    where (int)el <= 1  
    select new XElement("Child", (int)el)  
);  
  
dstTree.Add(  
    from el in srcTree.Elements()  
    where (int)el >= 3  
    select new XElement("DifferentChild", (int)el)  
);  
  
Console.WriteLine(dstTree);  
```  
  
```vb  
Dim srcTree As XElement = _  
    <Root>  
        <Child>1</Child>  
        <Child>2</Child>  
        <Child>3</Child>  
        <Child>4</Child>  
        <Child>5</Child>  
    </Root>  
  
Dim dstTree As XStreamingElement = New XStreamingElement("NewRoot")  
  
dstTree.Add( _  
    From el In srcTree.Elements() _  
    Where el.Value <= 1 _  
    Select <Child><%= el.Value %></Child> _  
)  
  
dstTree.Add( _  
    From el In srcTree.Elements() _  
    Where el.Value >= 3 _  
    Select <DifferentChild><%= el.Value %></DifferentChild> _  
)  
  
Console.WriteLine(dstTree)  
```  
  
 Ten przykład generuje następujące wyniki:  
  
```xml  
<NewRoot>  
  <Child>1</Child>  
  <DifferentChild>3</DifferentChild>  
  <DifferentChild>4</DifferentChild>  
  <DifferentChild>5</DifferentChild>  
</NewRoot>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public System.Xml.Linq.XName Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Linq.XName Name" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XStreamingElement.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As XName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::Linq::XName ^ Name { System::Xml::Linq::XName ^ get(); void set(System::Xml::Linq::XName ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : System.Xml.Linq.XName with get, set" Usage="System.Xml.Linq.XStreamingElement.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XName</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę tego elementu przesyłania strumieniowego.</summary>
        <value>
          <see cref="T:System.Xml.Linq.XName" /> Zawierający nazwę tego elementu przesyłania strumieniowego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W tym przykładzie tworzy nowy element przesyłania strumieniowego, a następnie wyświetla nazwę elementu.  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
XStreamingElement dstTree = new XStreamingElement("NewRoot",  
                        from el in srcTree.Elements()  
                        where (int)el >= 3  
                        select new XElement("DifferentChild", (int)el)  
                    );  
  
Console.WriteLine(dstTree.Name);  
```  
  
```vb  
Dim srcTree As XElement = _  
        <Root>  
            <Child>1</Child>  
            <Child>2</Child>  
            <Child>3</Child>  
            <Child>4</Child>  
            <Child>5</Child>  
        </Root>  
  
Dim dstTree As XStreamingElement = New XStreamingElement("NewRoot", _  
                From el In srcTree.Elements _  
                Where el.Value >= 3 _  
                Select <DifferentChild><%= el.Value %></DifferentChild> _  
            )  
  
Console.WriteLine(dstTree.Name)  
```  
  
 Ten przykład generuje następujące wyniki:  
  
```  
NewRoot  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Save">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Serializować tego elementu przesyłania strumieniowego. Dane wyjściowe mogą być zapisywane w pliku <see cref="T:System.Xml.XmlTextWriter" />, <see cref="T:System.IO.TextWriter" />, lub <see cref="T:System.Xml.XmlWriter" />. Opcjonalnie formatowanie (wcięcia), można wyłączyć.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.Save(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.Save : System.IO.Stream -&gt; unit" Usage="xStreamingElement.Save stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Strumień do wyjściowego to <see cref="T:System.Xml.Linq.XDocument" /> do.</param>
        <summary>Generuje to <see cref="T:System.Xml.Linq.XStreamingElement" /> do określonego <see cref="T:System.IO.Stream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Serializacji XML zostaną zastosowane. Zostaną usunięte wszystkie nieważny biały znak, i tak, aby XML prawidłowo wcięta zostaną dodane dodatkowe biały znak. Zachowanie tej metody jest tym nieważny biały znak nie zostaną zachowane.  
  
 Jeśli chcesz kontrolować białe miejsca, użyj przeciążenia <xref:System.Xml.Linq.XStreamingElement.Save%2A> pobierającej <xref:System.Xml.Linq.SaveOptions> jako parametr. Użyj <xref:System.Xml.Linq.SaveOptions.DisableFormatting> opcję, aby zapisać niewciętego XML. To spowoduje, że moduł zapisujący dokładnie reprezentowany w drzewie XML zapisu wszystkie białe znaki.  
  
 Użyj <xref:System.Xml.Linq.SaveOptions.OmitDuplicateNamespaces> opcji w przypadku, gdy chcesz usunąć deklaracji zduplikowanych przestrzeni nazw.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.IO.TextWriter textWriter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.IO.TextWriter textWriter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.Save(System.IO.TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::IO::TextWriter ^ textWriter);" />
      <MemberSignature Language="F#" Value="member this.Save : System.IO.TextWriter -&gt; unit" Usage="xStreamingElement.Save textWriter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textWriter" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="textWriter">A <see cref="T:System.IO.TextWriter" /> który <see cref="T:System.Xml.Linq.XStreamingElement" /> zostanie zapisany.</param>
        <summary>Tego elementu przesyłania strumieniowego, aby serializować <see cref="T:System.IO.TextWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Serializacji XML zostaną zastosowane. Zostaną usunięte wszystkie nieważny biały znak, i tak, aby XML prawidłowo wcięta zostaną dodane dodatkowe biały znak. Tej metody jest tym nieważny biały znak, który węzłów w drzewie XML nie zostaną zachowane.  
  
 Jeśli chcesz kontrolować białe miejsca, użyj jednej z przeciążeń <xref:System.Xml.Linq.XStreamingElement.Save%2A> które trwają <xref:System.Xml.Linq.SaveOptions> jako parametr. Aby uzyskać więcej informacji, zobacz [zachowania biały znak podczas ładowania lub analiza kodu XML](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d) i [zachowania biały znak podczas serializowania](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939).  
  
   
  
## Examples  
 Poniższy przykład tworzy drzewo XML źródła, a następnie tworzy <xref:System.Xml.Linq.XStreamingElement> za pomocą zapytania na drzewo składni XML źródła. Następnie zapisuje przesyłania strumieniowego element, aby <xref:System.IO.StringWriter>.  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
XStreamingElement dstTree = new XStreamingElement("NewRoot",  
                        from el in srcTree.Elements()  
                        where (int)el >= 3  
                        select new XElement("DifferentChild", (int)el)  
                    );  
  
StringBuilder sb = new StringBuilder();  
dstTree.Save(new StringWriter(sb));  
Console.WriteLine(sb.ToString());  
```  
  
```vb  
Dim srcTree As XElement = _  
    <Root>  
        <Child>1</Child>  
        <Child>2</Child>  
        <Child>3</Child>  
        <Child>4</Child>  
        <Child>5</Child>  
    </Root>  
  
Dim dstTree As XStreamingElement = New XStreamingElement("NewRoot", _  
                        From el In srcTree.Elements() _  
                        Where el.Value >= 3 _  
                        Select <DifferentChild><%= el.Value %></DifferentChild> _  
                    )  
  
Dim sb As StringBuilder = New StringBuilder()  
dstTree.Save(New StringWriter(sb))  
Console.WriteLine(sb.ToString())  
```  
  
 Ten przykład generuje następujące wyniki:  
  
```xml  
<?xml version="1.0" encoding="utf-16"?>  
<NewRoot>  
  <DifferentChild>3</DifferentChild>  
  <DifferentChild>4</DifferentChild>  
  <DifferentChild>5</DifferentChild>  
</NewRoot>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.Save(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.Save : string -&gt; unit" Usage="xStreamingElement.Save fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">A <see cref="T:System.String" /> zawierający nazwę pliku.</param>
        <summary>Serializować tego elementu przesyłania strumieniowego do pliku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Serializacji XML zostaną zastosowane. Zostaną usunięte wszystkie nieważny biały znak, i tak, aby XML prawidłowo wcięta zostaną dodane dodatkowe biały znak. Tej metody jest tym nieważny biały znak, który węzłów w drzewie XML nie zostaną zachowane.  
  
 Jeśli chcesz kontrolować białe miejsca, użyj jednej z przeciążeń <xref:System.Xml.Linq.XStreamingElement.Save%2A> które trwają <xref:System.Xml.Linq.SaveOptions> jako parametr. Aby uzyskać więcej informacji, zobacz [zachowania biały znak podczas ładowania lub analiza kodu XML](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d) i [zachowania biały znak podczas serializowania](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939).  
  
   
  
## Examples  
 Poniższy przykład tworzy przesyłania strumieniowego drzewo składni XML. Następnie wykonuje serializację przesyłania strumieniowego drzewa XML w pliku.  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
XStreamingElement dstTree = new XStreamingElement("NewRoot",  
                        from el in srcTree.Elements()  
                        where (int)el >= 3  
                        select new XElement("DifferentChild", (int)el)  
                    );  
  
dstTree.Save("Test.xml");  
Console.WriteLine(File.ReadAllText("Test.xml"));  
```  
  
```vb  
Dim srcTree As XElement = _  
    <Root>  
        <Child>1</Child>  
        <Child>2</Child>  
        <Child>3</Child>  
        <Child>4</Child>  
        <Child>5</Child>  
    </Root>  
  
Dim dstTree As XStreamingElement = New XStreamingElement("NewRoot", _  
                        From el In srcTree.Elements() _  
                        Where el.Value >= 3 _  
                        Select <DifferentChild><%= el.Value %></DifferentChild> _  
                    )  
  
dstTree.Save("Test.xml")  
Console.WriteLine(File.ReadAllText("Test.xml"))  
```  
  
 Ten przykład generuje następujące wyniki:  
  
```xml  
<?xml version="1.0" encoding="utf-8"?>  
<NewRoot>  
  <DifferentChild>3</DifferentChild>  
  <DifferentChild>4</DifferentChild>  
  <DifferentChild>5</DifferentChild>  
</NewRoot>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.Save(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.Save : System.Xml.XmlWriter -&gt; unit" Usage="xStreamingElement.Save writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">A <see cref="T:System.Xml.XmlWriter" /> który <see cref="T:System.Xml.Linq.XElement" /> zostanie zapisany.</param>
        <summary>Tego elementu przesyłania strumieniowego, aby serializować <see cref="T:System.Xml.XmlWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy <xref:System.Xml.Linq.XStreamingElement> i zapisuje go do <xref:System.Xml.XmlWriter>.  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
StringBuilder sb = new StringBuilder();  
XmlWriterSettings xws = new XmlWriterSettings();  
xws.OmitXmlDeclaration = true;  
using (XmlWriter xw = XmlWriter.Create(sb, xws))  
{  
    XStreamingElement dstTree = new XStreamingElement("NewRoot",  
                            from el in srcTree.Elements()  
                            where (int)el == 5  
                            select new XElement("DifferentChild", (int)el)  
                        );  
  
    dstTree.Save(xw);  
}  
Console.WriteLine(sb.ToString());  
```  
  
```vb  
Dim srcTree As XElement = _  
    <Root>  
        <Child>1</Child>  
        <Child>2</Child>  
        <Child>3</Child>  
        <Child>4</Child>  
        <Child>5</Child>  
    </Root>  
  
Dim sb As StringBuilder = New StringBuilder()  
Dim xws As XmlWriterSettings = New XmlWriterSettings()  
xws.OmitXmlDeclaration = True  
Using xw As XmlWriter = XmlWriter.Create(sb, xws)  
    Dim dstTree As XStreamingElement = New XStreamingElement("NewRoot", _  
                            From el In srcTree.Elements() _  
                            Where el.Value = 5 _  
                            Select <DifferentChild><%= el.Value %></DifferentChild> _  
                        )  
    dstTree.Save(xw)  
End Using  
Console.WriteLine(sb.ToString())  
```  
  
 Ten przykład generuje następujące wyniki:  
  
```xml  
<NewRoot><DifferentChild>5</DifferentChild></NewRoot>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.IO.Stream stream, System.Xml.Linq.SaveOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.IO.Stream stream, valuetype System.Xml.Linq.SaveOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.Save(System.IO.Stream,System.Xml.Linq.SaveOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::IO::Stream ^ stream, System::Xml::Linq::SaveOptions options);" />
      <MemberSignature Language="F#" Value="member this.Save : System.IO.Stream * System.Xml.Linq.SaveOptions -&gt; unit" Usage="xStreamingElement.Save (stream, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="options" Type="System.Xml.Linq.SaveOptions" />
      </Parameters>
      <Docs>
        <param name="stream">Strumień do wyjściowego to <see cref="T:System.Xml.Linq.XDocument" /> do.</param>
        <param name="options">A <see cref="T:System.Xml.Linq.SaveOptions" /> obiekt, który określa sposób formatowania.</param>
        <summary>Generuje to <see cref="T:System.Xml.Linq.XStreamingElement" /> do określonego <see cref="T:System.IO.Stream" />, opcjonalnie określania zachowania formatowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie `options` są ustawione na <xref:System.Xml.Linq.SaveOptions.None>. Ta opcja Usuń wszystkie nadmiarowe nieważny biały znak i dodać odpowiednie nieważny biały znak, dzięki czemu kod XML jest prawidłowo wcięcia.  
  
 Jeśli chcesz zapisać niewciętego XML, określ <xref:System.Xml.Linq.SaveOptions.DisableFormatting> flagę dla `options`. To spowoduje, że moduł zapisujący dokładnie reprezentowany w drzewie XML zapisu wszystkie białe znaki.  
  
 Użyj <xref:System.Xml.Linq.SaveOptions.OmitDuplicateNamespaces> opcji w przypadku, gdy chcesz usunąć deklaracji zduplikowanych przestrzeni nazw.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.IO.TextWriter textWriter, System.Xml.Linq.SaveOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.IO.TextWriter textWriter, valuetype System.Xml.Linq.SaveOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.Save(System.IO.TextWriter,System.Xml.Linq.SaveOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::IO::TextWriter ^ textWriter, System::Xml::Linq::SaveOptions options);" />
      <MemberSignature Language="F#" Value="member this.Save : System.IO.TextWriter * System.Xml.Linq.SaveOptions -&gt; unit" Usage="xStreamingElement.Save (textWriter, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textWriter" Type="System.IO.TextWriter" />
        <Parameter Name="options" Type="System.Xml.Linq.SaveOptions" />
      </Parameters>
      <Docs>
        <param name="textWriter">
          <see cref="T:System.IO.TextWriter" /> Do wypełniania wyjściowego pliku XML do.</param>
        <param name="options">A <see cref="T:System.Xml.Linq.SaveOptions" /> , który określa zachowania formatowania.</param>
        <summary>Tego elementu przesyłania strumieniowego, aby serializować <see cref="T:System.IO.TextWriter" />, opcjonalnie wyłączenie formatowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli chcesz zapisać niewciętego XML, określ <xref:System.Xml.Linq.SaveOptions.DisableFormatting> flagę dla `options`. To spowoduje, że moduł zapisujący dokładnie reprezentowany w drzewie XML zapis wszystkich biały znak.  
  
 Jeśli chcesz zapisać wcięta XML, nie należy określać <xref:System.Xml.Linq.SaveOptions.DisableFormatting> flagę dla `options`. To spowoduje usunięcie wszystkich nadmiarowe nieważny biały znak i dodać odpowiednie nieważny biały znak, dzięki czemu kod XML jest prawidłowo wcięcia. Jest to domyślne zachowanie i zachowanie przeciążeń <xref:System.Xml.Linq.XElement.Save%2A> metod, które nie przyjmują `options` jako parametr.  
  
 Aby uzyskać więcej informacji, zobacz [zachowania biały znak podczas ładowania lub analiza kodu XML](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d) i [zachowania biały znak podczas serializowania](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939).  
  
   
  
## Examples  
 Poniższy przykład przedstawia dwa zastosowania tej metody. Pierwsze użycie zachowuje biały znak. Serializuje drugi <xref:System.Xml.Linq.XStreamingElement> z formatowaniem.  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
XStreamingElement dstTree = new XStreamingElement("NewRoot",  
                        from el in srcTree.Elements()  
                        where (int)el == 3  
                        select new XElement("DifferentChild", (int)el)  
                    );  
  
StringBuilder sb = new StringBuilder();  
dstTree.Save(new StringWriter(sb), SaveOptions.DisableFormatting);  
Console.WriteLine(sb.ToString());  
Console.WriteLine("------");  
sb = new StringBuilder();  
dstTree.Save(new StringWriter(sb), SaveOptions.None);  
Console.WriteLine(sb.ToString());  
```  
  
```vb  
Dim srcTree As XElement = _  
    <Root>  
        <Child>1</Child>  
        <Child>2</Child>  
        <Child>3</Child>  
        <Child>4</Child>  
        <Child>5</Child>  
    </Root>  
  
Dim dstTree As XStreamingElement = New XStreamingElement("NewRoot", _  
                        From el In srcTree.Elements() _  
                        Where el.Value = 3 _  
                        Select <DifferentChild><%= el.Value %></DifferentChild> _  
                    )  
  
Dim sb As StringBuilder = New StringBuilder()  
dstTree.Save(New StringWriter(sb), SaveOptions.DisableFormatting)  
Console.WriteLine(sb.ToString())  
Console.WriteLine("------")  
sb = New StringBuilder()  
dstTree.Save(New StringWriter(sb), SaveOptions.None)  
Console.WriteLine(sb.ToString())  
```  
  
 Ten przykład generuje następujące wyniki:  
  
```xml  
<?xml version="1.0" encoding="utf-16"?><NewRoot><DifferentChild>3</DifferentChild></NewRoot>  
------  
<?xml version="1.0" encoding="utf-16"?>  
<NewRoot>  
  <DifferentChild>3</DifferentChild>  
</NewRoot>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (string fileName, System.Xml.Linq.SaveOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(string fileName, valuetype System.Xml.Linq.SaveOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.Save(System.String,System.Xml.Linq.SaveOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save (fileName As String, options As SaveOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::String ^ fileName, System::Xml::Linq::SaveOptions options);" />
      <MemberSignature Language="F#" Value="member this.Save : string * System.Xml.Linq.SaveOptions -&gt; unit" Usage="xStreamingElement.Save (fileName, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="options" Type="System.Xml.Linq.SaveOptions" />
      </Parameters>
      <Docs>
        <param name="fileName">A <see cref="T:System.String" /> zawierający nazwę pliku.</param>
        <param name="options">A <see cref="T:System.Xml.Linq.SaveOptions" /> obiekt, który określa sposób formatowania.</param>
        <summary>Serializować tego elementu przesyłania strumieniowego do pliku, opcjonalnie wyłączenie formatowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli chcesz zapisać niewciętego XML, określ <xref:System.Xml.Linq.SaveOptions.DisableFormatting> flagę dla `options`. To spowoduje, że moduł zapisujący dokładnie reprezentowany w drzewie XML zapis wszystkich biały znak.  
  
 Jeśli chcesz zapisać wcięta XML, nie należy określać <xref:System.Xml.Linq.SaveOptions.DisableFormatting> flagę dla `options`. To spowoduje usunięcie wszystkich nadmiarowe nieważny biały znak i dodać odpowiednie nieważny biały znak, dzięki czemu kod XML jest prawidłowo wcięcia. Jest to domyślne zachowanie i zachowanie przeciążeń <xref:System.Xml.Linq.XElement.Save%2A> metod, które nie przyjmują `options` jako parametr.  
  
 Aby uzyskać więcej informacji, zobacz [zachowania biały znak podczas ładowania lub analiza kodu XML](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d) i [zachowania biały znak podczas serializowania](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939).  
  
   
  
## Examples  
 Poniższy przykład przedstawia dwa zastosowania tej metody. Pierwsze użycie zachowuje biały znak. Serializuje drugi <xref:System.Xml.Linq.XStreamingElement> z formatowaniem.  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
XStreamingElement dstTree = new XStreamingElement("NewRoot",  
                        from el in srcTree.Elements()  
                        where (int)el == 3  
                        select new XElement("DifferentChild", (int)el)  
                    );  
  
dstTree.Save("Test1.xml", SaveOptions.DisableFormatting);  
dstTree.Save("Test2.xml", SaveOptions.None);  
Console.WriteLine(File.ReadAllText("Test1.xml"));  
Console.WriteLine("------");  
Console.WriteLine(File.ReadAllText("Test2.xml"));  
```  
  
```vb  
Dim srcTree As XElement = _  
    <Root>  
        <Child>1</Child>  
        <Child>2</Child>  
        <Child>3</Child>  
        <Child>4</Child>  
        <Child>5</Child>  
    </Root>  
  
Dim dstTree As XStreamingElement = New XStreamingElement("NewRoot", _  
                        From el In srcTree.Elements() _  
                        Where el.Value = 3 _  
                        Select <DifferentChild><%= el.Value %></DifferentChild> _  
                    )  
  
dstTree.Save("Test1.xml", SaveOptions.DisableFormatting)  
dstTree.Save("Test2.xml", SaveOptions.None)  
Console.WriteLine(File.ReadAllText("Test1.xml"))  
Console.WriteLine("------")  
Console.WriteLine(File.ReadAllText("Test2.xml"))  
```  
  
 Ten przykład generuje następujące wyniki:  
  
```  
<?xml version="1.0" encoding="utf-8"?><NewRoot><DifferentChild>3</DifferentChild></NewRoot>  
------  
<?xml version="1.0" encoding="utf-8"?>  
<NewRoot>  
  <DifferentChild>3</DifferentChild>  
</NewRoot>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca XML dla tego elementu przesyłania strumieniowego, opcjonalnie wyłączenie formatowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy pamiętać, że podczas debugowania program, który używa <xref:System.Xml.Linq.XStreamingElement>, wyświetlania wartości obiektu powoduje, że jego <xref:System.Xml.Linq.XStreamingElement.ToString%2A> wywoływanej metody. Powoduje to XML można było serializować. Jeśli semantykę przesyłania strumieniowego zapytania elementu tak, aby element przesyłania strumieniowego przesyłane strumieniowo tylko raz, to może spowodować niepożądane zachowanie środowiska debugowania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="xStreamingElement.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca sformatowany XML (wcięta) dla tego elementu przesyłania strumieniowego.</summary>
        <returns>A <see cref="T:System.String" /> zawierający wcięta XML.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy pamiętać, że podczas debugowania program, który używa <xref:System.Xml.Linq.XStreamingElement>, wyświetlania wartości obiektu powoduje, że jego <xref:System.Xml.Linq.XStreamingElement.ToString%2A> wywoływanej metody. Powoduje to XML można było serializować. Jeśli semantykę przesyłania strumieniowego zapytania elementu tak, aby element przesyłania strumieniowego przesyłane strumieniowo tylko raz, to może spowodować niepożądane zachowanie środowiska debugowania.  
  
   
  
## Examples  
 Poniższy przykład przedstawia dwa zastosowania <xref:System.Xml.Linq.XStreamingElement.ToString%2A>. Pierwsze użycie zachowuje biały znak. Serializuje drugi <xref:System.Xml.Linq.XStreamingElement> z formatowaniem.  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
XStreamingElement dstTree = new XStreamingElement("NewRoot",  
                        from el in srcTree.Elements()  
                        where (int)el == 3  
                        select new XElement("DifferentChild", (int)el)  
                    );  
  
Console.WriteLine(dstTree.ToString(SaveOptions.DisableFormatting));  
Console.WriteLine("------");  
Console.WriteLine(dstTree.ToString());  
```  
  
```vb  
Dim srcTree As XElement = _  
    <Root>  
        <Child>1</Child>  
        <Child>2</Child>  
        <Child>3</Child>  
        <Child>4</Child>  
        <Child>5</Child>  
    </Root>  
  
Dim dstTree As XStreamingElement = New XStreamingElement("NewRoot", _  
                        From el In srcTree.Elements() _  
                        Where el.Value = 3 _  
                        Select <DifferentChild><%= el.Value %></DifferentChild> _  
                    )  
  
Console.WriteLine(dstTree.ToString(SaveOptions.DisableFormatting))  
Console.WriteLine("------")  
Console.WriteLine(dstTree.ToString())  
```  
  
 Ten przykład generuje następujące wyniki:  
  
```  
<NewRoot><DifferentChild>3</DifferentChild></NewRoot>  
------  
<NewRoot>  
  <DifferentChild>3</DifferentChild>  
</NewRoot>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (System.Xml.Linq.SaveOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(valuetype System.Xml.Linq.SaveOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.ToString(System.Xml.Linq.SaveOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (options As SaveOptions) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::Xml::Linq::SaveOptions options);" />
      <MemberSignature Language="F#" Value="override this.ToString : System.Xml.Linq.SaveOptions -&gt; string" Usage="xStreamingElement.ToString options" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Xml.Linq.SaveOptions" />
      </Parameters>
      <Docs>
        <param name="options">A <see cref="T:System.Xml.Linq.SaveOptions" /> , który określa zachowania formatowania.</param>
        <summary>Zwraca XML dla tego elementu przesyłania strumieniowego, opcjonalnie wyłączenie formatowania.</summary>
        <returns>A <see cref="T:System.String" /> zawierające kod XML.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy pamiętać, że podczas debugowania program, który używa <xref:System.Xml.Linq.XStreamingElement>, wyświetlania wartości obiektu powoduje, że jego <xref:System.Xml.Linq.XStreamingElement.ToString%2A> wywoływanej metody. Powoduje to XML można było serializować. Jeśli semantykę przesyłania strumieniowego zapytania elementu tak, aby element przesyłania strumieniowego przesyłane strumieniowo tylko raz, to może spowodować niepożądane zachowanie środowiska debugowania.  
  
   
  
## Examples  
 Poniższy przykład przedstawia dwa zastosowania <xref:System.Xml.Linq.XStreamingElement.ToString%2A>. Pierwsze użycie zachowuje biały znak. Serializuje drugi <xref:System.Xml.Linq.XStreamingElement> z formatowaniem.  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
XStreamingElement dstTree = new XStreamingElement("NewRoot",  
                        from el in srcTree.Elements()  
                        where (int)el == 3  
                        select new XElement("DifferentChild", (int)el)  
                    );  
  
Console.WriteLine(dstTree.ToString(SaveOptions.DisableFormatting));  
Console.WriteLine("------");  
Console.WriteLine(dstTree.ToString());  
```  
  
```vb  
Dim srcTree As XElement = _  
    <Root>  
        <Child>1</Child>  
        <Child>2</Child>  
        <Child>3</Child>  
        <Child>4</Child>  
        <Child>5</Child>  
    </Root>  
  
Dim dstTree As XStreamingElement = New XStreamingElement("NewRoot", _  
                        From el In srcTree.Elements() _  
                        Where el.Value = 3 _  
                        Select <DifferentChild><%= el.Value %></DifferentChild> _  
                    )  
  
Console.WriteLine(dstTree.ToString(SaveOptions.DisableFormatting))  
Console.WriteLine("------")  
Console.WriteLine(dstTree.ToString())  
```  
  
 Ten przykład generuje następujące wyniki:  
  
```  
<NewRoot><DifferentChild>3</DifferentChild></NewRoot>  
------  
<NewRoot>  
  <DifferentChild>3</DifferentChild>  
</NewRoot>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteTo">
      <MemberSignature Language="C#" Value="public void WriteTo (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteTo(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.WriteTo(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteTo (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteTo(System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteTo : System.Xml.XmlWriter -&gt; unit" Usage="xStreamingElement.WriteTo writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.Xml.XmlWriter" /> Do będzie zapisywać tej metody.</param>
        <summary>Zapisuje tego elementu przesyłania strumieniowego <see cref="T:System.Xml.XmlWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy drzewa XML przy użyciu <xref:System.Xml.Linq.XStreamingElement>. Następnie zapisuje przesyłania strumieniowego element, aby <xref:System.Xml.XmlWriter>.  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
XStreamingElement dstTree = new XStreamingElement("NewRoot",  
                        from el in srcTree.Elements()  
                        where (int)el == 3  
                        select new XElement("DifferentChild", (int)el)  
                    );  
  
StringBuilder sb = new StringBuilder();  
XmlWriterSettings xws = new XmlWriterSettings();  
xws.OmitXmlDeclaration = true;  
xws.Indent = true;  
  
using (XmlWriter xw = XmlWriter.Create(sb, xws))  
{  
    dstTree.WriteTo(xw);  
}  
Console.WriteLine(sb.ToString());  
```  
  
```vb  
Dim srcTree As XElement = _  
    <Root>  
        <Child>1</Child>  
        <Child>2</Child>  
        <Child>3</Child>  
        <Child>4</Child>  
        <Child>5</Child>  
    </Root>  
  
Dim dstTree As XStreamingElement = _   
    New XStreamingElement("NewRoot", _  
        From el In srcTree.Elements() _  
        Where el.Value = 3 _  
        Select <DifferentChild><%= el.Value %></DifferentChild> )  
  
Dim sb As StringBuilder = New StringBuilder()  
Dim xws As XmlWriterSettings = New XmlWriterSettings()  
xws.OmitXmlDeclaration = True  
xws.Indent = True  
  
Using xw As XmlWriter = XmlWriter.Create(sb, xws)  
    dstTree.WriteTo(xw)  
End Using  
Console.WriteLine(sb.ToString())  
```  
  
 Ten przykład generuje następujące wyniki:  
  
```xml  
<NewRoot>  
  <DifferentChild>3</DifferentChild>  
</NewRoot>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
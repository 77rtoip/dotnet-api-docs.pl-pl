<Type Name="XName" FullName="System.Xml.Linq.XName">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f88de854b13c3d00d1e85fb6af8e0208e7b9dc62" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36443432" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class XName : IEquatable&lt;System.Xml.Linq.XName&gt;, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit XName extends System.Object implements class System.IEquatable`1&lt;class System.Xml.Linq.XName&gt;, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Xml.Linq.XName" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class XName&#xA;Implements IEquatable(Of XName), ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class XName sealed : IEquatable&lt;System::Xml::Linq::XName ^&gt;, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type XName = class&#xA;    interface IEquatable&lt;XName&gt;&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Xml.XDocument</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml.Linq</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Xml.Linq.XName&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.Serialization.KnownType(typeof(System.Xml.Linq.NameSerializer))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje nazwę elementu lub atrybutu XML.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nazwy XML zawierają przestrzeni nazw i nazwę lokalną. A *w pełni kwalifikowana nazwa* jest kombinacją przestrzeń nazw i nazwę lokalnego.  
  
## <a name="creating-an-xname-object"></a>Tworzenie obiektu XName  
 <xref:System.Xml.Linq.XName> nie zawiera żadnych konstruktorów publicznych. Jednak ta klasa udostępnia niejawna konwersja z <xref:System.String> umożliwiająca tworzenie <xref:System.Xml.Linq.XName>. Najbardziej typowe miejsce użyj ta konwersja jest podczas tworzenia elementu lub atrybutu: pierwszy argument <xref:System.Xml.Linq.XElement> Konstruktor jest <xref:System.Xml.Linq.XName>. Przez przekazanie ciąg, możesz korzystać z niejawnej konwersji. Poniższy kod tworzy element z nazwą obszaru nazw.  
  
```csharp  
XElement root = new XElement("ElementName", "content");  
Console.WriteLine(root);  
```  
  
 W języku Visual Basic jest bardziej odpowiednie do użycia w literałach XML:  
  
```vb  
Dim root As XElement = <ElementName>content</ElementName>  
Console.WriteLine(root)  
```  
  
 Ten przykład generuje następujące wyniki:  
  
```xml  
<ElementName>content</ElementName>  
```  
  
 Przypisywanie ciąg <xref:System.Xml.Linq.XName> używa niejawna konwersja z <xref:System.String>.  
  
 Przykład Visual Basic tworzy <xref:System.Xml.Linq.XElement> przy użyciu literałów XML. Mimo że literałów XML są używane, <xref:System.Xml.Linq.XName> obiekt jest tworzony dla <xref:System.Xml.Linq.XElement>.  
  
 Ponadto można wywołać <xref:System.Xml.Linq.XName.Get%2A> metodę <xref:System.Xml.Linq.XName> obiektu. Jednak zalecaną metodą jest użycie niejawna konwersja z ciągu.  
  
## <a name="creating-an-xname-in-a-namespace"></a>Tworzenie XName w Namespace  
 Podobnie jak w przypadku XML, <xref:System.Xml.Linq.XName> może znajdować się w przestrzeni nazw lub można ją bez przestrzeni nazw.  
  
 Język C#, zalecane podejście do tworzenia <xref:System.Xml.Linq.XName> w przestrzeni nazw jest aby zadeklarować <xref:System.Xml.Linq.XNamespace> obiekt, a następnie użyj zastąpienie operator dodawania.  
  
 W języku Visual Basic Zalecanym podejściem jest umożliwiają utworzenie XML, który znajduje się w przestrzeni nazw literały XML i deklaracji globalnej przestrzeni nazw.  
  
```csharp  
XNamespace aw = "http://www.adventure-works.com";  
XElement root = new XElement(aw + "ElementName", "content");  
Console.WriteLine(root);  
```  
  
```vb  
Imports <xmlns="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim root As XElement = <ElementName>content</ElementName>  
        Console.WriteLine(root)  
    End Sub  
End Module  
```  
  
 Ten przykład generuje następujące wyniki:  
  
```xml  
<ElementName xmlns="http://www.adventure-works.com">content</ElementName>  
```  
  
## <a name="creating-an-xname-in-no-namespace"></a>Tworzenie XName nie Namespace  
 <xref:System.Xml.Linq.XName.Namespace%2A> Właściwość <xref:System.Xml.Linq.XName> obiektu jest gwarantowana nie mieć wartości null. Jeśli <xref:System.Xml.Linq.XName> w bez przestrzeni nazw, a następnie <xref:System.Xml.Linq.XName.Namespace%2A> właściwość zostanie ustawiona do <xref:System.Xml.Linq.XNamespace.None%2A>. Poniższy kod ilustruje to:  
  
```csharp  
XElement root = new XElement("ElementName", "content");  
if (root.Name.Namespace == XNamespace.None)  
    Console.WriteLine("The element is in no namespace.");  
else  
    Console.WriteLine("The element is in a namespace.");  
```  
  
```vb  
Dim root As XElement = <ElementName>content</ElementName>  
If (root.Name.Namespace Is XNamespace.None) Then  
    Console.WriteLine("The element is in no namespace.")  
Else  
    Console.WriteLine("The element is in a namespace.")  
End If  
```  
  
 Ten przykład generuje następujące wyniki:  
  
```  
The element is in no namespace.  
```  
  
## <a name="using-expanded-names"></a>Przy użyciu nazw rozszerzonej  
 Można również utworzyć <xref:System.Xml.Linq.XName> z rozwiniętą nazwą XML w formularzu `{namespace}localname`:  
  
```csharp  
XElement root = new XElement("{http://www.adventure-works.com}ElementName", "content");  
Console.WriteLine(root);  
```  
  
```vb  
Dim root As XElement = New XElement("{http://www.adventure-works.com}ElementName", "content")  
Console.WriteLine(root)  
```  
  
 Ten przykład generuje następujące wyniki:  
  
```xml  
<ElementName xmlns="http://www.adventure-works.com">content</ElementName>  
```  
  
 Należy pamiętać, że tworzenie <xref:System.Xml.Linq.XName> za pośrednictwem rozwiniętą nazwą jest mniej wydajne niż tworzenie <xref:System.Xml.Linq.XNamespace> obiekt i za pomocą zastąpienia operator dodawania. Jest również mniej wydajne niż importowanie globalnej przestrzeni nazw i użyciu literałów XML w Visual Basic.  
  
 W przypadku utworzenia <xref:System.Xml.Linq.XName> przy użyciu nazwy rozwinięte, LINQ do XML musi znaleźć wystąpienia atomized przestrzeni nazw. Tej pracy należy powtórzyć dla każdego Użyj rozwiniętą nazwą. To dodatkowy czas prawdopodobnie jest bez znaczenia, gdy Pisanie zapytań LINQ; jednak może być istotne podczas tworzenia dużych drzewo składni XML.  
  
## <a name="xname-objects-are-atomized"></a>Obiekty XName są Atomized  
 <xref:System.Xml.Linq.XName> obiekty dotrą do atomized; oznacza to, że jeśli dwie <xref:System.Xml.Linq.XName> obiekty mają dokładnie tego samego obszaru nazw i dokładnie taką samą nazwę lokalnego, będą miały tego samego wystąpienia. Operatory równości i porównanie podawane są również jawnie w tym celu.  
  
 Wśród innych korzyści ta funkcja umożliwia szybsze wykonywanie zapytań. Podczas filtrowania nazwy elementów lub atrybutów, porównania wyrażone w predykatach Użyj tożsamości porównanie, nie porównania wartości. Jest znacznie szybsze, aby określić, że dwa odwołania faktycznie odwołują się do tego samego obiektu niż Aby porównać dwa ciągi.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XName.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="xName.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <see cref="T:System.Xml.Linq.XName" /> Do porównania z bieżącą <see cref="T:System.Xml.Linq.XName" />.</param>
        <summary>Określa, czy określony <see cref="T:System.Xml.Linq.XName" /> jest taki sam <see cref="T:System.Xml.Linq.XName" />.</summary>
        <returns>
          <see langword="true" /> Jeśli określony <see cref="T:System.Xml.Linq.XName" /> jest taki sam, jak bieżący <see cref="T:System.Xml.Linq.XName" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dla dwóch <xref:System.Xml.Linq.XName> obiektów jako równe, muszą mieć taką samą nazwę rozwinięte.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Get">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera <see cref="T:System.Xml.Linq.XName" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zapewnia przeciążeń, które pozwalają tworzyć <xref:System.Xml.Linq.XName> z rozwiniętą nazwą XML. Można utworzyć <xref:System.Xml.Linq.XName> z ciągiem w postaci `{namespace}localname`, lub z obszaru nazw i nazwę lokalną określane oddzielnie.  
  
 Znacznie więcej typowe i łatwiejsze sposobem tworzenia <xref:System.Xml.Linq.XName> jest użycie niejawna konwersja z ciągu. Aby utworzyć nazwę, która znajduje się w przestrzeni nazw, typowym podejściem jest użycie dodanie przeciążenia operatora, które umożliwia połączenie <xref:System.Xml.Linq.XNamespace> obiekt i ciąg.  
  
 Aby uzyskać dodatkowe informacje i przykłady, zobacz [porady: Tworzenie dokumentu z przestrzeni nazw (C#) (LINQ do XML)](http://msdn.microsoft.com/library/af4a595e-ffb2-4187-a61b-d5ed71642c4c).  
  
 Aby uzyskać więcej informacji na temat używania przestrzeni nazw w języku Visual Basic, zobacz [przestrzeni nazw w języku Visual Basic (LINQ do XML)](http://msdn.microsoft.com/library/10b7ba7b-518c-4f14-899f-892575d14dcc).  
  
 Ponieważ <xref:System.Xml.Linq.XName> obiekty są atomized, jeśli istnieje <xref:System.Xml.Linq.XName> o dokładnie takiej samej nazwie, zmienna przypisanej odnoszą się do istniejącego <xref:System.Xml.Linq.XName>. Jeśli nie istnieje <xref:System.Xml.Linq.XName>, nowy jedną zostanie utworzone i zainicjowane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Get">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XName Get (string expandedName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XName Get(string expandedName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XName.Get(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Get (expandedName As String) As XName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Linq::XName ^ Get(System::String ^ expandedName);" />
      <MemberSignature Language="F#" Value="static member Get : string -&gt; System.Xml.Linq.XName" Usage="System.Xml.Linq.XName.Get expandedName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XName</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expandedName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expandedName">A <see cref="T:System.String" /> zawierający rozwinięte nazwy XML w formacie <c>localname {przestrzeń nazw}</c>.</param>
        <summary>Pobiera <see cref="T:System.Xml.Linq.XName" /> obiektu z rozwiniętą nazwą.</summary>
        <returns>
          <see cref="T:System.Xml.Linq.XName" /> Utworzone na podstawie rozwiniętą nazwą obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zawiera przeciążeń, które pozwalają tworzyć <xref:System.Xml.Linq.XName>. Można go utworzyć, korzystając z rozwiniętą nazwą XML w formie `{namespace}localname`, lub z obszaru nazw i nazwę lokalną określane oddzielnie.  
  
 Znacznie więcej typowe i łatwiejsze sposobem tworzenia <xref:System.Xml.Linq.XName> jest użycie niejawna konwersja z ciągu.  
  
 Ponieważ <xref:System.Xml.Linq.XName> są atomized, jeśli istnieje <xref:System.Xml.Linq.XName> o dokładnie takiej samej nazwie, zmienna przypisanej odnoszą się do istniejącego <xref:System.Xml.Linq.XName>. Jeśli nie istnieje <xref:System.Xml.Linq.XName>, nowy jedną zostanie utworzone i zainicjowane.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie tej metody.  
  
```csharp  
XName name = XName.Get("{http://www.adventure-works.com}Root");  
XElement el = new XElement(name, "content");  
Console.WriteLine(el);  
  
// This is the preferred approach for specifying the XName in the  
// constructor of XElement.  
XNamespace aw = "http://www.adventure-works.com";  
XElement el2 = new XElement(aw + "Root", "content");  
Console.WriteLine(el2);  
```  
  
```vb  
Imports <xmlns="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim name As XName = XName.Get("{http://www.adventure-works.com}Root")  
        Dim el As XElement = New XElement(name, "content")  
        Console.WriteLine(el)  
  
        ' The preferred approach for specifying an XName in a namespace  
        ' for Visual Basic is to import a global namespace.  
        Dim el2 As XElement = <Root>content</Root>  
        Console.WriteLine(el2)  
    End Sub  
End Module  
```  
  
 Ten przykład generuje następujące wyniki:  
  
```  
<Root xmlns="http://www.adventure-works.com">content</Root>  
<Root xmlns="http://www.adventure-works.com">content</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Get">
      <MemberSignature Language="C#" Value="public static System.Xml.Linq.XName Get (string localName, string namespaceName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Linq.XName Get(string localName, string namespaceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XName.Get(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Get (localName As String, namespaceName As String) As XName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Linq::XName ^ Get(System::String ^ localName, System::String ^ namespaceName);" />
      <MemberSignature Language="F#" Value="static member Get : string * string -&gt; System.Xml.Linq.XName" Usage="System.Xml.Linq.XName.Get (localName, namespaceName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XName</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Lokalna nazwa (niekwalifikowane).</param>
        <param name="namespaceName">Przestrzeń nazw XML.</param>
        <summary>Pobiera <see cref="T:System.Xml.Linq.XName" /> obiektu z nazwą lokalną i przestrzeni nazw.</summary>
        <returns>
          <see cref="T:System.Xml.Linq.XName" /> Obiektu utworzone na podstawie określonej nazwy lokalnej i przestrzeni nazw.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zawiera przeciążeń, które pozwalają tworzyć <xref:System.Xml.Linq.XName>. Można go utworzyć, korzystając z rozwiniętą nazwą XML w formie `{namespace}localname`, lub z obszaru nazw i nazwę lokalną określane oddzielnie.  
  
 Znacznie więcej typowe i łatwiejsze sposobem tworzenia <xref:System.Xml.Linq.XName> jest użycie niejawna konwersja z ciągu.  
  
 Ponieważ <xref:System.Xml.Linq.XName> są atomized, jeśli istnieje <xref:System.Xml.Linq.XName> o dokładnie takiej samej nazwie, zmienna przypisanej odnoszą się do istniejącego <xref:System.Xml.Linq.XName>. Jeśli nie istnieje <xref:System.Xml.Linq.XName>, nowy jedną zostanie utworzone i zainicjowane.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie tej metody.  
  
```csharp  
XName name = XName.Get("Root", "http://www.adventure-works.com");  
XElement el = new XElement(name, "content");  
Console.WriteLine(el);  
  
// This is the preferred form.  
XNamespace aw = "http://www.adventure-works.com";  
XElement el2 = new XElement(aw + "Root", "content");  
Console.WriteLine(el2);  
```  
  
```vb  
Imports <xmlns="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim name As XName = XName.Get("{http://www.adventure-works.com}Root")  
        Dim el As XElement = New XElement(name, "content")  
        Console.WriteLine(el)  
  
        ' The preferred approach for specifying an XName in a namespace  
        ' for Visual Basic is to import a global namespace.  
        Dim el2 As XElement = <Root>content</Root>  
        Console.WriteLine(el2)  
    End Sub  
End Module  
```  
  
 Ten przykład generuje następujące wyniki:  
  
```  
<Root xmlns="http://www.adventure-works.com">content</Root>  
<Root xmlns="http://www.adventure-works.com">content</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XName.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="xName.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera wartość skrótu dla tego <see cref="T:System.Xml.Linq.XName" />.</summary>
        <returns>
          <see cref="T:System.Int32" /> Zawierający wartość skrótu dla <see cref="T:System.Xml.Linq.XName" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy jako funkcji wyznaczania wartości skrótu dla <xref:System.Xml.Linq.XName>. Można użyć <xref:System.Xml.Linq.XName.GetHashCode%2A> algorytmów mieszania lub struktury danych, takich jak tablicy skrótów.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LocalName">
      <MemberSignature Language="C#" Value="public string LocalName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LocalName" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XName.LocalName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ LocalName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalName : string" Usage="System.Xml.Linq.XName.LocalName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lokalne (niekwalifikowane) część nazwy.</summary>
        <value>A <see cref="T:System.String" /> zawiera lokalne (niekwalifikowane) część nazwy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest gwarancji nie `null`.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie tej właściwości.  
  
```csharp  
XNamespace ns = "http://www.adventure-works.com";  
XElement root = new XElement(ns + "Root", "content");  
Console.WriteLine(root.Name);  
Console.WriteLine(root.Name.LocalName);  
Console.WriteLine(root.Name.Namespace);  
```  
  
```vb  
Imports <xmlns="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim root As XElement = <Root/>  
        Console.WriteLine(root.Name)  
        Console.WriteLine(root.Name.LocalName)  
        Console.WriteLine(root.Name.Namespace)  
    End Sub  
End Module  
```  
  
 Ten przykład generuje następujące wyniki:  
  
```  
{http://www.adventure-works.com}Root  
Root  
http://www.adventure-works.com  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xml.Linq.XName.Namespace" />
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public System.Xml.Linq.XNamespace Namespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Linq.XNamespace Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XName.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Namespace As XNamespace" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::Linq::XNamespace ^ Namespace { System::Xml::Linq::XNamespace ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : System.Xml.Linq.XNamespace" Usage="System.Xml.Linq.XName.Namespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XNamespace</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera część w pełni kwalifikowana nazwa przestrzeni nazw.</summary>
        <value>
          <see cref="T:System.Xml.Linq.XNamespace" /> Zawierającą przestrzeń nazw część nazwy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.Linq.XName.Namespace%2A> Właściwości jest gwarancji nie `null`. Jeśli <xref:System.Xml.Linq.XName> jest bez przestrzeni nazw, ta właściwość zwraca <xref:System.Xml.Linq.XNamespace.None%2A>.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie tej właściwości.  
  
```csharp  
XNamespace ns = "http://www.adventure-works.com";  
XElement root = new XElement(ns + "Root", "content");  
Console.WriteLine(root.Name);  
Console.WriteLine(root.Name.LocalName);  
Console.WriteLine(root.Name.Namespace);  
```  
  
```vb  
Imports <xmlns="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim root As XElement = <Root/>  
        Console.WriteLine(root.Name)  
        Console.WriteLine(root.Name.LocalName)  
        Console.WriteLine(root.Name.Namespace)  
    End Sub  
End Module  
```  
  
 Ten przykład generuje następujące wyniki:  
  
```  
{http://www.adventure-works.com}Root  
Root  
http://www.adventure-works.com  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NamespaceName">
      <MemberSignature Language="C#" Value="public string NamespaceName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string NamespaceName" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XName.NamespaceName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NamespaceName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ NamespaceName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NamespaceName : string" Usage="System.Xml.Linq.XName.NamespaceName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zwraca identyfikator URI <see cref="T:System.Xml.Linq.XNamespace" /> dla tego <see cref="T:System.Xml.Linq.XName" />.</summary>
        <value>Identyfikator URI <see cref="T:System.Xml.Linq.XNamespace" /> dla tego <see cref="T:System.Xml.Linq.XName" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to właściwość wygody, aby uzyskać nazwę przestrzeni nazw z <xref:System.Xml.Linq.XName>.  
  
   
  
## Examples  
 W tym przykładzie tworzy element w przestrzeni nazw, a następnie drukuje obszar nazw elementu.  
  
```csharp  
XNamespace aw = "http://www.adventure-works.com";  
XElement root = new XElement(aw + "Root");  
Console.WriteLine(root.Name.NamespaceName);  
```  
  
```vb  
Imports <xmlns="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim root As XElement = <Root/>  
        Console.WriteLine(root.Name.NamespaceName)  
    End Sub  
End Module  
```  
  
 Ten przykład generuje następujące wyniki:  
  
```  
http://www.adventure-works.com  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Xml.Linq.XName left, System.Xml.Linq.XName right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Xml.Linq.XName left, class System.Xml.Linq.XName right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XName.op_Equality(System.Xml.Linq.XName,System.Xml.Linq.XName)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As XName, right As XName) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Xml::Linq::XName ^ left, System::Xml::Linq::XName ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Xml.Linq.XName * System.Xml.Linq.XName -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Xml.Linq.XName" />
        <Parameter Name="right" Type="System.Xml.Linq.XName" />
      </Parameters>
      <Docs>
        <param name="left">Pierwszy <see cref="T:System.Xml.Linq.XName" /> do porównania.</param>
        <param name="right">Drugi <see cref="T:System.Xml.Linq.XName" /> do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy dwa wystąpienia elementu <see cref="T:System.Xml.Linq.XName" /> są takie same.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> i <paramref name="right" /> są równe; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążenia operatorów `==` i `!=` uwzględniono umożliwia porównanie <xref:System.Xml.Linq.XName> i `string`, takich jak`element.Name == "SomeElementName"`. Operatory porównania wstępnie zdefiniowanych odwołanie w C# wymaga jednego argumentu możliwa do przekonwertowania na typ innych za pomocą tylko konwersje odwołań. Tych operatorów nie należy traktować niejawna konwersja z ciągu na <xref:System.Xml.Linq.XName>.  
  
## Examples  
 W poniższym przykładzie przedstawiono niektóre porównanie <xref:System.Xml.Linq.XName> obiektów i ciągów.  
  
```csharp  
XName xn;  
xn = XName.Get("Root");  
Console.WriteLine(xn == "Root");  
  
xn = XName.Get("Root", "http://www.adventure-works.com");  
Console.WriteLine(xn == "{http://www.adventure-works.com}Root");  
  
XElement root = new XElement("Root", "content");  
Console.WriteLine(root.Name == "Root");  
```  
  
```vb  
Dim xn As XName  
xn = XName.Get("Root")  
Console.WriteLine(xn = "Root")  
  
xn = XName.Get("Root", "http://www.adventure-works.com")  
Console.WriteLine(xn = "{http://www.adventure-works.com}Root")  
  
Dim root As XElement = New XElement("Root", "content")  
Console.WriteLine(root.Name = "Root")  
```  
  
 Ten przykład generuje następujące wyniki:  
  
```  
True  
True  
True  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Xml.Linq.XName (string expandedName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Xml.Linq.XName op_Implicit(string expandedName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XName.op_Implicit(System.String)~System.Xml.Linq.XName" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (expandedName As String) As XName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Xml::Linq::XName ^(System::String ^ expandedName);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : string -&gt; System.Xml.Linq.XName" Usage="System.Xml.Linq.XName.op_Implicit expandedName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XName</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expandedName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expandedName">Ciąg zawierający rozwinięte nazwy XML w formacie <c>localname {przestrzeń nazw}</c>.</param>
        <summary>Konwertuje ciąg w formacie rozwiniętą nazwą XML (to znaczy<c>localname {przestrzeń nazw}</c>) do <see cref="T:System.Xml.Linq.XName" /> obiektu.</summary>
        <returns>
          <see cref="T:System.Xml.Linq.XName" /> Utworzone na podstawie rozwiniętą nazwą obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Korzystasz z tego operatora niejawnej podczas tworzenia <xref:System.Xml.Linq.XElement> lub <xref:System.Xml.Linq.XAttribute> przez przekazanie ciąg do odpowiedniego konstruktora.  
  
## Examples  
 Poniższy przykład tworzy <xref:System.Xml.Linq.XName> przypisując do niej ciąg, który wywołuje ten operator niejawnej konwersji.  
  
```csharp  
XElement el = new XElement("{http://www.adventure-works.com}Root", "content");  
Console.WriteLine(el);  
  
// The preferred approach is to initialize an XNamespace object  
// and use the overload of the addition operator.  
XNamespace aw = "http://www.adventure-works.com";  
XElement root = new XElement(aw + "Root", "content");  
Console.WriteLine(root);  
```  
  
```vb  
Imports <xmlns="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim el As XElement = New XElement("{http://www.adventure-works.com}Root", "content")  
        Console.WriteLine(el)  
  
        ' The preferred approach is to import a global namespace and   
        ' use an XML literal.  
        Dim root As XElement = <Root>content</Root>  
        Console.WriteLine(root)  
    End Sub  
End Module  
```  
  
 Ten przykład generuje następujące wyniki:  
  
```  
<Root xmlns="http://www.adventure-works.com">content</Root>  
<Root xmlns="http://www.adventure-works.com">content</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Xml.Linq.XName left, System.Xml.Linq.XName right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Xml.Linq.XName left, class System.Xml.Linq.XName right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XName.op_Inequality(System.Xml.Linq.XName,System.Xml.Linq.XName)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As XName, right As XName) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Xml::Linq::XName ^ left, System::Xml::Linq::XName ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Xml.Linq.XName * System.Xml.Linq.XName -&gt; bool" Usage="System.Xml.Linq.XName.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Xml.Linq.XName" />
        <Parameter Name="right" Type="System.Xml.Linq.XName" />
      </Parameters>
      <Docs>
        <param name="left">Pierwszy <see cref="T:System.Xml.Linq.XName" /> do porównania.</param>
        <param name="right">Drugi <see cref="T:System.Xml.Linq.XName" /> do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy dwa wystąpienia elementu <see cref="T:System.Xml.Linq.XName" /> nie są takie same.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="left" /> i <paramref name="right" /> nie są równe; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przeciążenia operatorów `==` i `!=` uwzględniono umożliwia porównanie <xref:System.Xml.Linq.XName> i ciąg, takich jak`element.Name == "SomeElementName"`. Operatory porównania wstępnie zdefiniowanych odwołanie w C# wymaga jednego argumentu możliwa do przekonwertowania na typ innych za pomocą tylko konwersje odwołań. Tych operatorów nie należy traktować niejawna konwersja z ciągu na <xref:System.Xml.Linq.XName>.  
  
## Examples  
 W poniższym przykładzie C# porównuje <xref:System.Xml.Linq.XName> obiektu na ciąg, który wywołuje tego operatora.  
  
```csharp  
XNamespace aw = "http://www.adventure-works.com";  
XElement root = new XElement(aw + "Root", "content");  
  
Console.WriteLine(root.Name != "{http://www.adventure-works.com}Root");  
  
// the following is the preferred idiom  
Console.WriteLine(root.Name != aw + "Root");  
```  
  
```vb  
Imports <xmlns="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim root As XElement = <Root>content</Root>  
        Console.WriteLine(root.Name <> "{http://www.adventure-works.com}Root")  
  
        ' the following is the preferred idiom  
        Console.WriteLine(root.Name <> GetXmlNamespace() + "Root")  
    End Sub  
End Module  
```  
  
 Ten przykład generuje następujące wyniki:  
  
```  
False  
False  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IEquatable&lt;System.Xml.Linq.XName&gt;.Equals">
      <MemberSignature Language="C#" Value="bool IEquatable&lt;XName&gt;.Equals (System.Xml.Linq.XName other);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IEquatable&lt;System.Xml.Linq.XName&gt;.Equals(class System.Xml.Linq.XName other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XName.System#IEquatable&lt;System#Xml#Linq#XName&gt;#Equals(System.Xml.Linq.XName)" />
      <MemberSignature Language="VB.NET" Value="Function Equals (other As XName) As Boolean Implements IEquatable(Of XName).Equals" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IEquatable&lt;System.Xml.Linq.XName&gt;.Equals(System::Xml::Linq::XName ^ other) = IEquatable&lt;System::Xml::Linq::XName ^&gt;::Equals;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Xml.Linq.XName" />
      </Parameters>
      <Docs>
        <param name="other">
          <see cref="T:System.Xml.Linq.XName" /> Do porównania z tym <see cref="T:System.Xml.Linq.XName" />.</param>
        <summary>Wskazuje, czy bieżący <see cref="T:System.Xml.Linq.XName" /> jest równa określonej <see cref="T:System.Xml.Linq.XName" />.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="T:System.Xml.Linq.XName" /> jest równa określonej <see cref="T:System.Xml.Linq.XName" />, w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XName.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">
          <see cref="T:System.Runtime.Serialization.SerializationInfo" /> Do wypełniania danych.</param>
        <param name="context">Miejsce docelowe (zobacz <see cref="T:System.Runtime.Serialization.StreamingContext" />) tej serializacji.</param>
        <summary>Wypełnia <see cref="T:System.Runtime.Serialization.SerializationInfo" /> przy użyciu danych wymaganych do zserializowania obiektu docelowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest używana wewnętrznie do serializacji wykresów obiektów, które zawierają LINQ do obiektów XML.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XName.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="xName.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca rozwiniętą nazwą XML w formacie <c>localname {przestrzeń nazw}</c>.</summary>
        <returns>A <see cref="T:System.String" /> zawierający rozwiniętą nazwą XML w formacie <c>localname {przestrzeń nazw}</c>.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Następujące przykładowe wywołania <xref:System.Console.WriteLine%2A>, przechodzącą <xref:System.Xml.Linq.XName>. Powoduje to <xref:System.Xml.Linq.XName.ToString%2A> wywoływanej metody.  
  
```csharp  
XNamespace ns = "http://www.adventure-works.com";  
XElement root = new XElement(ns + "Root", "content");  
Console.WriteLine(root.Name);  
Console.WriteLine(root.Name.LocalName);  
Console.WriteLine(root.Name.Namespace);  
```  
  
```vb  
Imports <xmlns="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim root As XElement = <Root>content</Root>  
        Console.WriteLine(root.Name)  
        Console.WriteLine(root.Name.LocalName)  
        Console.WriteLine(root.Name.Namespace)  
    End Sub  
End Module  
```  
  
 Ten przykład generuje następujące wyniki:  
  
```  
{http://www.adventure-works.com}Root  
Root  
http://www.adventure-works.com  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
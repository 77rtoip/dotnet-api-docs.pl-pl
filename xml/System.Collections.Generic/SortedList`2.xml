<Type Name="SortedList&lt;TKey,TValue&gt;" FullName="System.Collections.Generic.SortedList&lt;TKey,TValue&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="272c864c4033fc8c2d326b44f279502155890076" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69334733" /></Metadata><TypeSignature Language="C#" Value="public class SortedList&lt;TKey,TValue&gt; : System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;, System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;, System.Collections.Generic.IReadOnlyCollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;, System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;, System.Collections.IDictionary" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit SortedList`2&lt;TKey, TValue&gt; extends System.Object implements class System.Collections.Generic.ICollection`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt;, class System.Collections.Generic.IDictionary`2&lt;!TKey, !TValue&gt;, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt;, class System.Collections.Generic.IReadOnlyDictionary`2&lt;!TKey, !TValue&gt;, class System.Collections.ICollection, class System.Collections.IDictionary, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Generic.SortedList`2" />
  <TypeSignature Language="VB.NET" Value="Public Class SortedList(Of TKey, TValue)&#xA;Implements ICollection(Of KeyValuePair(Of TKey, TValue)), IDictionary, IDictionary(Of TKey, TValue), IEnumerable(Of KeyValuePair(Of TKey, TValue)), IReadOnlyCollection(Of KeyValuePair(Of TKey, TValue)), IReadOnlyDictionary(Of TKey, TValue)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TKey, typename TValue&gt;&#xA;public ref class SortedList : System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;, System::Collections::Generic::IDictionary&lt;TKey, TValue&gt;, System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;, System::Collections::Generic::IReadOnlyCollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;, System::Collections::Generic::IReadOnlyDictionary&lt;TKey, TValue&gt;, System::Collections::IDictionary" />
  <TypeSignature Language="F#" Value="type SortedList&lt;'Key, 'Value&gt; = class&#xA;    interface IDictionary&lt;'Key, 'Value&gt;&#xA;    interface IDictionary&#xA;    interface IReadOnlyDictionary&lt;'Key, 'Value&gt;&#xA;    interface ICollection&lt;KeyValuePair&lt;'Key, 'Value&gt;&gt;&#xA;    interface seq&lt;KeyValuePair&lt;'Key, 'Value&gt;&gt;&#xA;    interface IEnumerable&#xA;    interface ICollection&#xA;    interface IReadOnlyCollection&lt;KeyValuePair&lt;'Key, 'Value&gt;&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Collections</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TKey" />
    <TypeParameter Name="TValue" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IDictionary</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.System_DictionaryDebugView`2))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="TKey">Typ kluczy w kolekcji.</typeparam>
    <typeparam name="TValue">Typ wartości w kolekcji.</typeparam>
    <summary>Reprezentuje kolekcję par klucz/wartość, które są posortowane według klucza w oparciu o <see cref="T:System.Collections.Generic.IComparer`1" /> skojarzoną implementację.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasa generyczna jest tablicą par klucz/wartość z pobraniem (log `n`), gdzie n to liczba elementów w słowniku. <xref:System.Collections.Generic.SortedList%602> W tym celu jest podobna do <xref:System.Collections.Generic.SortedDictionary%602> klasy generycznej. Dwie klasy mają podobne modele obiektów, a oba mają pobieranie (log `n`). W przypadku, gdy obie klasy różnią się w zakresie wykorzystania pamięci i szybkości wstawiania i usuwania:  
  
-   <xref:System.Collections.Generic.SortedList%602>używa mniejszej ilości <xref:System.Collections.Generic.SortedDictionary%602>pamięci niż.  
  
-   <xref:System.Collections.Generic.SortedDictionary%602>Program ma szybsze operacje wstawiania i usuwania dla niesortowanych danych, O ( `n`log) w przeciwieństwie do o`n`() <xref:System.Collections.Generic.SortedList%602>dla.  
  
-   Jeśli lista jest wypełniana jednocześnie na podstawie posortowanych danych <xref:System.Collections.Generic.SortedList%602> , jest szybsza <xref:System.Collections.Generic.SortedDictionary%602>niż.  
  
 Kolejną różnicą między <xref:System.Collections.Generic.SortedDictionary%602> klasami i <xref:System.Collections.Generic.SortedList%602> jest <xref:System.Collections.Generic.SortedList%602> to, że program obsługuje wydajne indeksowane pobieranie kluczy <xref:System.Collections.Generic.SortedList%602.Keys%2A> i wartości za pomocą kolekcji zwracanych przez właściwości i <xref:System.Collections.Generic.SortedList%602.Values%2A> . Nie jest konieczne ponowne generowanie list podczas uzyskiwania dostępu do właściwości, ponieważ listy są tylko otokami dla wewnętrznych tablic kluczy i wartości. Poniższy kod przedstawia użycie <xref:System.Collections.Generic.SortedList%602.Values%2A> właściwości do indeksowanego pobierania wartości z posortowanej listy ciągów:  
  
 [!code-cpp[Generic.SortedList#11](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/remarks.cpp#11)]
 [!code-csharp[Generic.SortedList#11](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/remarks.cs#11)]
 [!code-vb[Generic.SortedList#11](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/remarks.vb#11)]  
  
 <xref:System.Collections.Generic.SortedList%602>jest zaimplementowany jako Tablica par klucz/wartość, posortowane według klucza.  Każdy element można pobrać jako <xref:System.Collections.Generic.KeyValuePair%602> obiekt.  
  
 Obiekty kluczowe muszą być niezmienne, o ile są używane jako klucze w <xref:System.Collections.Generic.SortedList%602>. Każdy klucz w a <xref:System.Collections.Generic.SortedList%602> musi być unikatowy. Klucz nie może być `null`, ale wartość może być, jeśli typ wartości na liście, `TValue`jest typem referencyjnym.  
  
 <xref:System.Collections.Generic.SortedList%602>wymaga implementacji porównania, aby sortować i wykonywać porównania.  Domyślne ustawienia porównujące <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> sprawdzają, czy `TKey` typ <xref:System.IComparable%601?displayProperty=nameWithType> klucza implementuje i używa tej implementacji, jeśli jest dostępny.  Jeśli nie, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> sprawdza, czy typ `TKey` klucza implementuje <xref:System.IComparable?displayProperty=nameWithType>.  Jeśli typ `TKey` klucza nie implementuje żadnego interfejsu, można <xref:System.Collections.Generic.IComparer%601?displayProperty=nameWithType> określić implementację w Przeciążenie `comparer` konstruktora, który akceptuje parametr.  
  
 Pojemność a to liczba <xref:System.Collections.Generic.SortedList%602> elementów, które <xref:System.Collections.Generic.SortedList%602> mogą być przechowywane. Gdy elementy są dodawane do <xref:System.Collections.Generic.SortedList%602>, pojemność jest automatycznie zwiększana zgodnie z wymaganiami przez ponowną alokację tablicy wewnętrznej. Wydajność można zmniejszyć przez wywołanie <xref:System.Collections.Generic.SortedList%602.TrimExcess%2A> lub przez <xref:System.Collections.Generic.SortedList%602.Capacity%2A> ustawienie właściwości jawnie. Zmniejszenie pojemności powoduje ponowną alokację pamięci i skopiowanie wszystkich elementów w <xref:System.Collections.Generic.SortedList%602>.  
  
 **Tylko .NET Framework:** W przypadku bardzo <xref:System.Collections.Generic.SortedList%602> dużych obiektów można zwiększyć maksymalną pojemność do 2 000 000 000 elementów w systemie 64-bitowym, `enabled` ustawiając atrybut [`<gcAllowVeryLargeObjects>`](~/docs/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element.md) elementu konfiguracji na `true` w środowisku wykonawczym.  
  
 `foreach` Instrukcja C# języka(`for each` C++w ,`For Each` w Visual Basic) zwraca obiekt typu elementów w kolekcji. Ponieważ elementy <xref:System.Collections.Generic.SortedList%602> są par klucz/wartość, typ elementu nie jest typem klucza ani typem wartości. Zamiast tego typ elementu to <xref:System.Collections.Generic.KeyValuePair%602>. Na przykład:  
  
 [!code-cpp[Generic.SortedList#12](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/remarks.cpp#12)]
 [!code-csharp[Generic.SortedList#12](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/remarks.cs#12)]
 [!code-vb[Generic.SortedList#12](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/remarks.vb#12)]  
  
 `foreach` Instrukcja to otoka wokół modułu wyliczającego, która umożliwia odczyt z kolekcji.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy puste <xref:System.Collections.Generic.SortedList%602> ciągi z kluczami ciągu i <xref:System.Collections.Generic.SortedList%602.Add%2A> używa metody do dodawania niektórych elementów. W przykładzie pokazano, że <xref:System.Collections.Generic.SortedList%602.Add%2A> Metoda <xref:System.ArgumentException> zgłasza podczas próby dodania zduplikowanego klucza.  
  
 W przykładzie zastosowano <xref:System.Collections.Generic.SortedList%602.Item%2A> Właściwość (indeksator w C#) do pobierania wartości, <xref:System.Collections.Generic.KeyNotFoundException> pokazując, że jest zgłaszany, gdy żądany klucz nie jest obecny i wskazuje, że wartość skojarzona z kluczem może zostać zastąpiona.  
  
 Przykład pokazuje, jak użyć metody <xref:System.Collections.Generic.SortedList%602.TryGetValue%2A> jako bardziej efektywnego sposobu pobierania wartości, jeśli program często musi wypróbować kluczowe wartości, które nie znajdują się na posortowanej liście, i pokazuje, jak użyć metody <xref:System.Collections.Generic.SortedList%602.ContainsKey%2A>, aby sprawdzić, czy klucz istnieje przed wywołaniem metoda <xref:System.Collections.Generic.SortedList%602.Add%2A>.  
  
 W przykładzie pokazano, jak wyliczyć klucze i wartości na sortowanej liście oraz jak wyliczyć klucze i wartości przy użyciu <xref:System.Collections.Generic.SortedList%602.Keys%2A> właściwości <xref:System.Collections.Generic.SortedList%602.Values%2A> i właściwości.  
  
 Na koniec przykład ilustruje <xref:System.Collections.Generic.SortedList%602.Remove%2A> metodę.  
  
 [!code-cpp[Generic.SortedList#1](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#1)]
 [!code-csharp[Generic.SortedList#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#1)]
 [!code-vb[Generic.SortedList#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Publiczne statyczne (<see langword="Shared" /> w Visual Basic) członkowie tego typu są bezpieczne wątkowo. Wystąpienia elementów członkowskich nie dają gwarancji bezpieczeństwa wątków.  
  
<see cref="T:System.Collections.Generic.SortedList`2" /> Może obsługiwać wielu czytników współbieżnie, o ile kolekcja nie jest modyfikowana.  Nawet w ten sposób Wyliczanie za pomocą kolekcji nie jest w sposób wewnętrzny bezpieczny dla wątków.  Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania.  Aby zezwolić wielu wątkom na dostęp do kolekcji w celu odczytu i zapisu danych, należy zaimplementować własny mechanizm synchronizacji.</threadsafe>
    <altmember cref="T:System.Collections.Generic.IDictionary`2" />
    <altmember cref="T:System.Collections.Generic.Dictionary`2" />
    <altmember cref="T:System.Collections.Generic.SortedDictionary`2" />
    <altmember cref="T:System.Collections.Generic.KeyValuePair`2" />
    <altmember cref="T:System.Collections.Generic.IComparer`1" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Collections.Generic.SortedList`2" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedList();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Collections.Generic.SortedList`2" /> klasy, która jest pusta, ma domyślną pojemność początkową i używa wartości domyślnej <see cref="T:System.Collections.Generic.IComparer`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy klucz w a <xref:System.Collections.Generic.SortedList%602> musi być unikatowy zgodnie z domyślną wartością porównującą.  
  
 Ten konstruktor używa wartości domyślnej dla początkowej pojemności <xref:System.Collections.Generic.SortedList%602>. Aby ustawić pojemność początkową, użyj <xref:System.Collections.Generic.SortedList%602.%23ctor%28System.Int32%29> konstruktora. Jeśli końcowy rozmiar kolekcji można oszacować, określenie początkowej pojemności eliminuje konieczność wykonywania wielu operacji zmiany rozmiaru podczas dodawania elementów do <xref:System.Collections.Generic.SortedList%602>.  
  
 Ten konstruktor używa domyślnej usługi porównującej `TKey`dla. Aby określić moduł porównujący, należy <xref:System.Collections.Generic.SortedList%602.%23ctor%28System.Collections.Generic.IComparer%7B%600%7D%29> użyć konstruktora. Domyślne ustawienia porównujące <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> sprawdzają, czy `TKey` typ <xref:System.IComparable%601?displayProperty=nameWithType> klucza implementuje i używa tej implementacji, jeśli jest dostępny.  Jeśli nie, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> sprawdza, czy typ `TKey` klucza implementuje <xref:System.IComparable?displayProperty=nameWithType>.  Jeśli typ `TKey` klucza nie implementuje żadnego interfejsu, można <xref:System.Collections.Generic.IComparer%601?displayProperty=nameWithType> określić implementację w Przeciążenie `comparer` konstruktora, który akceptuje parametr.  
  
 Ten konstruktor jest operacją O (1).  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy puste <xref:System.Collections.Generic.SortedList%602> ciągi z kluczami ciągu i <xref:System.Collections.Generic.SortedList%602.Add%2A> używa metody do dodawania niektórych elementów. W przykładzie pokazano, że <xref:System.Collections.Generic.SortedList%602.Add%2A> Metoda <xref:System.ArgumentException> zgłasza podczas próby dodania zduplikowanego klucza.  
  
 Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.Collections.Generic.SortedList%602> klasy.  
  
 [!code-cpp[Generic.SortedList#2](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#2)]
 [!code-csharp[Generic.SortedList#2](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#2)]
 [!code-vb[Generic.SortedList#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Generic.Comparer`1.Default" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="T:System.IComparable" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList (System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IComparer`1&lt;!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.#ctor(System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (comparer As IComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedList(System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.SortedList&lt;'Key, 'Value&gt; : System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; System.Collections.Generic.SortedList&lt;'Key, 'Value&gt;" Usage="new System.Collections.Generic.SortedList&lt;'Key, 'Value&gt; comparer" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <param name="comparer"><see cref="T:System.Collections.Generic.IComparer`1" /> Implementacja do użycia podczas porównywania kluczy.  
  
—lub— 
 <see langword="null" />, aby użyć wartości <see cref="T:System.Collections.Generic.Comparer`1" /> domyślnej dla typu klucza.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Collections.Generic.SortedList`2" /> klasy, która jest pusta, ma domyślną pojemność początkową i używa określonego <see cref="T:System.Collections.Generic.IComparer`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy klucz w a <xref:System.Collections.Generic.SortedList%602> musi być unikatowy zgodnie z określoną regułą porównującą.  
  
 Ten konstruktor używa wartości domyślnej dla początkowej pojemności <xref:System.Collections.Generic.SortedList%602>. Aby ustawić pojemność początkową, użyj <xref:System.Collections.Generic.SortedList%602.%23ctor%28System.Int32%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> konstruktora. Jeśli końcowy rozmiar kolekcji można oszacować, określenie początkowej pojemności eliminuje konieczność wykonywania wielu operacji zmiany rozmiaru podczas dodawania elementów do <xref:System.Collections.Generic.SortedList%602>.  
  
 Ten konstruktor jest operacją O (1).  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy posortowaną listę z niezależnym od wielkości literą dla bieżącej kultury. Przykład dodaje cztery elementy, niektóre z kluczami małych liter i niektóre z kluczami wielkich liter. Przykład próbuje dodać element z kluczem, który różni się od istniejącego klucza tylko w przypadku, przechwytuje wyjątek, a następnie wyświetla komunikat o błędzie. Na koniec przykład wyświetla elementy w kolejności sortowania bez uwzględniania wielkości liter.  
  
 [!code-csharp[Generic.SortedList.ctor_IComp#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.ctor_IComp/CS/source.cs#1)]
 [!code-vb[Generic.SortedList.ctor_IComp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.ctor_IComp/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="P:System.Collections.Generic.Comparer`1.Default" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="T:System.IComparable" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList (System.Collections.Generic.IDictionary&lt;TKey,TValue&gt; dictionary);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IDictionary`2&lt;!TKey, !TValue&gt; dictionary) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dictionary As IDictionary(Of TKey, TValue))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedList(System::Collections::Generic::IDictionary&lt;TKey, TValue&gt; ^ dictionary);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.SortedList&lt;'Key, 'Value&gt; : System.Collections.Generic.IDictionary&lt;'Key, 'Value&gt; -&gt; System.Collections.Generic.SortedList&lt;'Key, 'Value&gt;" Usage="new System.Collections.Generic.SortedList&lt;'Key, 'Value&gt; dictionary" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="dictionary" Type="System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;" />
      </Parameters>
      <Docs>
        <param name="dictionary">Elementów <see cref="T:System.Collections.Generic.IDictionary`2" /> , których elementy są kopiowane do nowego <see cref="T:System.Collections.Generic.SortedList`2" />.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Collections.Generic.SortedList`2" /> klasy, która zawiera elementy skopiowane z określonego <see cref="T:System.Collections.Generic.IDictionary`2" />, ma wystarczającą pojemność, aby pomieścić liczbę skopiowanych elementów i używa wartości domyślnej <see cref="T:System.Collections.Generic.IComparer`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy klucz w a <xref:System.Collections.Generic.SortedList%602> musi być unikatowy zgodnie z domyślną wartością porównującą; podobnie, każdy klucz w źródle `dictionary` musi również być unikatowy zgodnie z domyślną wartością porównującą.  
  
 Pojemność nowej <xref:System.Collections.Generic.SortedList%602> jest ustawiona na liczbę elementów w `dictionary`, więc nie ma potrzeby zmiany rozmiarów, gdy lista jest wypełniana.  
  
 Ten konstruktor używa domyślnej usługi porównującej `TKey`dla. Aby określić moduł porównujący, należy <xref:System.Collections.Generic.SortedList%602.%23ctor%28System.Collections.Generic.IDictionary%7B%600%2C%601%7D%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> użyć konstruktora. Domyślne ustawienia porównujące <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> sprawdzają, czy `TKey` typ <xref:System.IComparable%601?displayProperty=nameWithType> klucza implementuje i używa tej implementacji, jeśli jest dostępny.  Jeśli nie, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> sprawdza, czy typ `TKey` klucza implementuje <xref:System.IComparable?displayProperty=nameWithType>.  Jeśli typ `TKey` klucza nie implementuje żadnego interfejsu, można <xref:System.Collections.Generic.IComparer%601?displayProperty=nameWithType> określić implementację w Przeciążenie `comparer` konstruktora, który akceptuje parametr.  
  
 Jeśli `dictionary` dane w są sortowane, ten konstruktor jest operacją o`n`(), gdzie `n` jest liczbą elementów w `dictionary`. W przeciwnym razie jest to operacja`n`o (*`n`).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak <xref:System.Collections.Generic.SortedList%602> używać do tworzenia posortowanej kopii informacji w a <xref:System.Collections.Generic.Dictionary%602>, przekazując <xref:System.Collections.Generic.Dictionary%602> do <xref:System.Collections.Generic.SortedList%602.%23ctor%28System.Collections.Generic.IDictionary%7B%600%2C%601%7D%29> konstruktora.  
  
 [!code-csharp[Generic.SortedList.ctor_IDic#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.ctor_IDic/CS/source.cs#1)]
 [!code-vb[Generic.SortedList.ctor_IDic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.ctor_IDic/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="dictionary" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="dictionary" />zawiera co najmniej jeden zduplikowany klucz.</exception>
        <altmember cref="T:System.Collections.Generic.IDictionary`2" />
        <altmember cref="P:System.Collections.Generic.Comparer`1.Default" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="T:System.IComparable" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedList(int capacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.SortedList&lt;'Key, 'Value&gt; : int -&gt; System.Collections.Generic.SortedList&lt;'Key, 'Value&gt;" Usage="new System.Collections.Generic.SortedList&lt;'Key, 'Value&gt; capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Początkowa liczba elementów, które <see cref="T:System.Collections.Generic.SortedList`2" /> może zawierać.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Collections.Generic.SortedList`2" /> klasy, która jest pusta, ma określoną pojemność początkową i używa wartości domyślnej <see cref="T:System.Collections.Generic.IComparer`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy klucz w a <xref:System.Collections.Generic.SortedList%602> musi być unikatowy zgodnie z domyślną wartością porównującą.  
  
 Pojemność programu to liczba <xref:System.Collections.Generic.SortedList%602> elementów <xref:System.Collections.Generic.SortedList%602> , które mogą być przechowywane przed zmianą rozmiarów. Gdy elementy są dodawane do <xref:System.Collections.Generic.SortedList%602>, pojemność jest automatycznie zwiększana zgodnie z wymaganiami przez ponowną alokację tablicy wewnętrznej.  
  
 Jeśli rozmiar kolekcji można oszacować, określenie początkowej pojemności eliminuje konieczność wykonywania wielu operacji zmiany rozmiaru podczas dodawania elementów do <xref:System.Collections.Generic.SortedList%602>.  
  
 Wydajność można zmniejszyć przez wywołanie <xref:System.Collections.Generic.SortedList%602.TrimExcess%2A> lub przez <xref:System.Collections.Generic.SortedList%602.Capacity%2A> ustawienie właściwości jawnie. Zmniejszenie pojemności powoduje ponowną alokację pamięci i skopiowanie wszystkich elementów w <xref:System.Collections.Generic.SortedList%602>.  
  
 Ten konstruktor używa domyślnej usługi porównującej `TKey`dla. Aby określić moduł porównujący, należy <xref:System.Collections.Generic.SortedList%602.%23ctor%28System.Int32%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> użyć konstruktora. Domyślne ustawienia porównujące <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> sprawdzają, czy `TKey` typ <xref:System.IComparable%601?displayProperty=nameWithType> klucza implementuje i używa tej implementacji, jeśli jest dostępny.  Jeśli nie, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> sprawdza, czy typ `TKey` klucza implementuje <xref:System.IComparable?displayProperty=nameWithType>.  Jeśli typ `TKey` klucza nie implementuje żadnego interfejsu, można <xref:System.Collections.Generic.IComparer%601?displayProperty=nameWithType> określić implementację w Przeciążenie `comparer` konstruktora, który akceptuje parametr.  
  
 Ten konstruktor jest operacją o`n`(), gdzie `n` is `capacity`.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy posortowaną listę z początkową pojemnością 4 i wypełnia ją 4 wpisami.  
  
 [!code-csharp[Generic.SortedList.ctor_Int32#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.ctor_Int32/CS/source.cs#1)]
 [!code-vb[Generic.SortedList.ctor_Int32#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.ctor_Int32/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" />jest mniejsza od zera.</exception>
        <altmember cref="P:System.Collections.Generic.SortedList`2.Capacity" />
        <altmember cref="P:System.Collections.Generic.Comparer`1.Default" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="T:System.IComparable" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList (System.Collections.Generic.IDictionary&lt;TKey,TValue&gt; dictionary, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IDictionary`2&lt;!TKey, !TValue&gt; dictionary, class System.Collections.Generic.IComparer`1&lt;!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.#ctor(System.Collections.Generic.IDictionary{`0,`1},System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dictionary As IDictionary(Of TKey, TValue), comparer As IComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedList(System::Collections::Generic::IDictionary&lt;TKey, TValue&gt; ^ dictionary, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.SortedList&lt;'Key, 'Value&gt; : System.Collections.Generic.IDictionary&lt;'Key, 'Value&gt; * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; System.Collections.Generic.SortedList&lt;'Key, 'Value&gt;" Usage="new System.Collections.Generic.SortedList&lt;'Key, 'Value&gt; (dictionary, comparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dictionary" Type="System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <param name="dictionary">Elementów <see cref="T:System.Collections.Generic.IDictionary`2" /> , których elementy są kopiowane do nowego <see cref="T:System.Collections.Generic.SortedList`2" />.</param>
        <param name="comparer"><see cref="T:System.Collections.Generic.IComparer`1" /> Implementacja do użycia podczas porównywania kluczy.  
  
—lub— 
 <see langword="null" />, aby użyć wartości <see cref="T:System.Collections.Generic.Comparer`1" /> domyślnej dla typu klucza.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Collections.Generic.SortedList`2" /> klasy, która zawiera elementy skopiowane z określonego <see cref="T:System.Collections.Generic.IDictionary`2" />, ma wystarczającą pojemność, aby pomieścić liczbę skopiowanych elementów i używa określonego <see cref="T:System.Collections.Generic.IComparer`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy klucz w a <xref:System.Collections.Generic.SortedList%602> musi być unikatowy zgodnie z określoną regułą porównującą; podobnie, każdy klucz w źródle `dictionary` musi również być unikatowy zgodnie z określoną regułą porównującą.  
  
 Pojemność nowej <xref:System.Collections.Generic.SortedList%602> jest ustawiona na liczbę elementów w `dictionary`, więc nie ma potrzeby zmiany rozmiarów, gdy lista jest wypełniana.  
  
 Jeśli `dictionary` dane w są sortowane, ten konstruktor jest operacją o`n`(), gdzie `n` jest liczbą elementów w `dictionary`. W przeciwnym razie jest to operacja`n`o (*`n`).  
  
   
  
## Examples  
 <xref:System.Collections.Generic.SortedList%602> Poniższy przykład kodu pokazuje <xref:System.Collections.Generic.Dictionary%602>, jak używać do tworzenia posortowanej bez uwzględniania wielkości liter podczas sortowania informacji w przypadku, przekazując <xref:System.Collections.Generic.Dictionary%602> do <xref:System.Collections.Generic.SortedList%602.%23ctor%28System.Collections.Generic.IDictionary%7B%600%2C%601%7D%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> konstruktora. W tym przykładzie, porównujące bez uwzględniania wielkości liter są dla bieżącej kultury.  
  
 [!code-csharp[Generic.SortedList.ctor_IDicIComp#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.ctor_IDicIComp/CS/source.cs#1)]
 [!code-vb[Generic.SortedList.ctor_IDicIComp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.ctor_IDicIComp/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="dictionary" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="dictionary" />zawiera co najmniej jeden zduplikowany klucz.</exception>
        <altmember cref="T:System.Collections.Generic.IDictionary`2" />
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="P:System.Collections.Generic.Comparer`1.Default" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="T:System.IComparable" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedList (int capacity, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, class System.Collections.Generic.IComparer`1&lt;!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.#ctor(System.Int32,System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, comparer As IComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedList(int capacity, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.SortedList&lt;'Key, 'Value&gt; : int * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; System.Collections.Generic.SortedList&lt;'Key, 'Value&gt;" Usage="new System.Collections.Generic.SortedList&lt;'Key, 'Value&gt; (capacity, comparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <param name="capacity">Początkowa liczba elementów, które <see cref="T:System.Collections.Generic.SortedList`2" /> może zawierać.</param>
        <param name="comparer"><see cref="T:System.Collections.Generic.IComparer`1" /> Implementacja do użycia podczas porównywania kluczy.  
  
—lub— 
 <see langword="null" />, aby użyć wartości <see cref="T:System.Collections.Generic.Comparer`1" /> domyślnej dla typu klucza.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Collections.Generic.SortedList`2" /> klasy, która jest pusta, ma określoną pojemność początkową i używa określonego <see cref="T:System.Collections.Generic.IComparer`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy klucz w a <xref:System.Collections.Generic.SortedList%602> musi być unikatowy zgodnie z określoną regułą porównującą.  
  
 Pojemność programu to liczba <xref:System.Collections.Generic.SortedList%602> elementów <xref:System.Collections.Generic.SortedList%602> , które mogą być przechowywane przed zmianą rozmiarów. Gdy elementy są dodawane do <xref:System.Collections.Generic.SortedList%602>, pojemność jest automatycznie zwiększana zgodnie z wymaganiami przez ponowną alokację tablicy wewnętrznej.  
  
 Jeśli rozmiar kolekcji można oszacować, określenie początkowej pojemności eliminuje konieczność wykonywania wielu operacji zmiany rozmiaru podczas dodawania elementów do <xref:System.Collections.Generic.SortedList%602>.  
  
 Wydajność można zmniejszyć przez wywołanie <xref:System.Collections.Generic.SortedList%602.TrimExcess%2A> lub przez <xref:System.Collections.Generic.SortedList%602.Capacity%2A> ustawienie właściwości jawnie. Zmniejszenie pojemności powoduje ponowną alokację pamięci i skopiowanie wszystkich elementów w <xref:System.Collections.Generic.SortedList%602>.  
  
 Ten konstruktor jest operacją o`n`(), gdzie `n` is `capacity`.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy posortowaną listę z początkową pojemnością 5 i niezależną od wielkości liter dla bieżącej kultury. Przykład dodaje cztery elementy, niektóre z kluczami małych liter i niektóre z kluczami wielkich liter. Przykład próbuje dodać element z kluczem, który różni się od istniejącego klucza tylko w przypadku, przechwytuje wyjątek, a następnie wyświetla komunikat o błędzie. Na koniec przykład wyświetla elementy w kolejności sortowania bez uwzględniania wielkości liter.  
  
 [!code-csharp[Generic.SortedList.ctor_Int32IComp#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.ctor_Int32IComp/CS/source.cs#1)]
 [!code-vb[Generic.SortedList.ctor_Int32IComp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.ctor_Int32IComp/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" />jest mniejsza od zera.</exception>
        <altmember cref="P:System.Collections.Generic.SortedList`2.Capacity" />
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="P:System.Collections.Generic.Comparer`1.Default" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="T:System.IComparable" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (TKey key, TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(!TKey key, !TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.Add(`0,`1)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (key As TKey, value As TValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(TKey key, TValue value);" />
      <MemberSignature Language="F#" Value="abstract member Add : 'Key * 'Value -&gt; unit&#xA;override this.Add : 'Key * 'Value -&gt; unit" Usage="sortedList.Add (key, value)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.Add(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="key">Klucz elementu do dodania.</param>
        <param name="value">Wartość elementu do dodania. Wartość może być <see langword="null" /> dla typów referencyjnych.</param>
        <summary>Dodaje element z określonym kluczem i wartością do <see cref="T:System.Collections.Generic.SortedList`2" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klucz nie może być `null`, ale wartość może być, jeśli typ wartości na sortowanej liście, `TValue`jest typem referencyjnym.  
  
 Można również użyć <xref:System.Collections.Generic.SortedList%602.Item%2A> właściwości, aby dodać nowe elementy przez ustawienie wartości klucza, który nie istnieje <xref:System.Collections.Generic.SortedList%602>w, na przykład `myCollection["myNonexistentKey"] = myValue`. Jeśli jednak określony klucz już istnieje w <xref:System.Collections.Generic.SortedList%602>, <xref:System.Collections.Generic.SortedList%602.Item%2A> ustawienie właściwości zastępuje starą wartość. Z kolei <xref:System.Collections.Generic.SortedList%602.Add%2A> Metoda nie modyfikuje istniejących elementów.  
  
 Jeśli <xref:System.Collections.Generic.SortedList%602.Count%2A> już jest <xref:System.Collections.Generic.SortedList%602.Capacity%2A>równa <xref:System.Collections.Generic.SortedList%602> , Pojemność programu jest zwiększana przez automatyczne ponowne przydzielanie tablicy wewnętrznej, a istniejące elementy są kopiowane do nowej tablicy przed dodaniem nowego elementu.  
  
 Ta metoda jest operacją o`n`() dla niesortowanych danych, gdzie `n` is <xref:System.Collections.Generic.SortedList%602.Count%2A>. Jest to operacja o (log `n`), jeśli nowy element zostanie dodany na końcu listy. Jeśli Wstaw powoduje zmianę rozmiaru, operacja ma wartość O (`n`).  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy puste <xref:System.Collections.Generic.SortedList%602> ciągi z kluczami ciągu i <xref:System.Collections.Generic.SortedList%602.Add%2A> używa metody do dodawania niektórych elementów. W przykładzie pokazano, że <xref:System.Collections.Generic.SortedList%602.Add%2A> Metoda <xref:System.ArgumentException> zgłasza podczas próby dodania zduplikowanego klucza.  
  
 Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.Collections.Generic.SortedList%602> klasy.  
  
 [!code-cpp[Generic.SortedList#2](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#2)]
 [!code-csharp[Generic.SortedList#2](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#2)]
 [!code-vb[Generic.SortedList#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Element z tym samym kluczem już istnieje w <see cref="T:System.Collections.Generic.SortedList`2" />.</exception>
        <altmember cref="M:System.Collections.Generic.SortedList`2.Remove(`0)" />
        <altmember cref="P:System.Collections.Generic.SortedList`2.Item(`0)" />
        <altmember cref="M:System.Collections.Generic.IDictionary`2.Add(`0,`1)" />
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.Capacity" />
      <MemberSignature Language="VB.NET" Value="Public Property Capacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Capacity { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Capacity : int with get, set" Usage="System.Collections.Generic.SortedList&lt;'Key, 'Value&gt;.Capacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia liczbę elementów, które <see cref="T:System.Collections.Generic.SortedList`2" /> może zawierać.</summary>
        <value>Liczba elementów, które <see cref="T:System.Collections.Generic.SortedList`2" /> może zawierać.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.SortedList%602.Capacity%2A>to liczba elementów, które <xref:System.Collections.Generic.SortedList%602> mogą być przechowywane. <xref:System.Collections.Generic.SortedList%602.Count%2A>to liczba elementów, które faktycznie znajdują się w <xref:System.Collections.Generic.SortedList%602>.  
  
 <xref:System.Collections.Generic.SortedList%602.Capacity%2A>jest zawsze większa lub równa <xref:System.Collections.Generic.SortedList%602.Count%2A>. Jeśli <xref:System.Collections.Generic.SortedList%602.Count%2A> program <xref:System.Collections.Generic.SortedList%602.Capacity%2A> przekracza podczas dodawania elementów, wydajność jest zwiększana przez automatyczne ponowne przydzielanie tablicy wewnętrznej przed skopiowaniem starych elementów i dodaniem nowych elementów.  
  
 Wydajność można zmniejszyć przez wywołanie <xref:System.Collections.Generic.SortedList%602.TrimExcess%2A> lub przez <xref:System.Collections.Generic.SortedList%602.Capacity%2A> ustawienie właściwości jawnie. Gdy wartość <xref:System.Collections.Generic.SortedList%602.Capacity%2A> jest ustawiona jawnie, tablica wewnętrzna również jest przyalokowana ponownie w celu uwzględnienia określonej pojemności.  
  
 Pobieranie wartości tej właściwości jest operacją O (1); ustawienie właściwości jest operacją o (`n`), gdzie `n` jest nowa pojemność.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><see cref="P:System.Collections.Generic.SortedList`2.Capacity" />jest ustawiona na wartość, która jest mniejsza niż <see cref="P:System.Collections.Generic.SortedList`2.Count" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Za mało dostępnej pamięci w systemie.</exception>
        <altmember cref="P:System.Collections.Generic.SortedList`2.Count" />
        <altmember cref="M:System.Collections.Generic.SortedList`2.TrimExcess" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="sortedList.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Clear</InterfaceMember>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa wszystkie elementy z <see cref="T:System.Collections.Generic.SortedList`2" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.SortedList%602.Count%2A>jest ustawiona na zero, a odwołania do innych obiektów z elementów kolekcji również są wydane.  
  
 <xref:System.Collections.Generic.SortedList%602.Capacity%2A>pozostaje niezmieniony. Aby zresetować pojemność <xref:System.Collections.Generic.SortedList%602>, wywołaj <xref:System.Collections.Generic.SortedList%602.TrimExcess%2A> lub ustaw <xref:System.Collections.Generic.SortedList%602.Capacity%2A> właściwość bezpośrednio. Przycinanie pustego <xref:System.Collections.Generic.SortedList%602> zestawu ustawia pojemność <xref:System.Collections.Generic.SortedList%602> do pojemności domyślnej.  
  
 Ta metoda jest operacją o`n`(), gdzie `n` is <xref:System.Collections.Generic.SortedList%602.Count%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.SortedList`2.TrimExcess" />
        <altmember cref="M:System.Collections.Generic.SortedList`2.Remove(`0)" />
        <altmember cref="M:System.Collections.Generic.SortedList`2.RemoveAt(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Comparer">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IComparer&lt;TKey&gt; Comparer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IComparer`1&lt;!TKey&gt; Comparer" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.Comparer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Comparer As IComparer(Of TKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IComparer&lt;TKey&gt; ^ Comparer { System::Collections::Generic::IComparer&lt;TKey&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Comparer : System.Collections.Generic.IComparer&lt;'Key&gt;" Usage="System.Collections.Generic.SortedList&lt;'Key, 'Value&gt;.Comparer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IComparer&lt;TKey&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Collections.Generic.IComparer`1" /> Pobiera dla posortowanej listy.</summary>
        <value><see cref="T:System.IComparable`1" /> Dla bieżącego<see cref="T:System.Collections.Generic.SortedList`2" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainsKey">
      <MemberSignature Language="C#" Value="public bool ContainsKey (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ContainsKey(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.ContainsKey(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContainsKey (key As TKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ContainsKey(TKey key);" />
      <MemberSignature Language="F#" Value="abstract member ContainsKey : 'Key -&gt; bool&#xA;override this.ContainsKey : 'Key -&gt; bool" Usage="sortedList.ContainsKey key" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.ContainsKey(`0)</InterfaceMember>
        <InterfaceMember>M:System.Collections.Generic.IReadOnlyDictionary`2.ContainsKey(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Klucz, który ma zostać zlokalizowany w <see cref="T:System.Collections.Generic.SortedList`2" />.</param>
        <summary>Określa, <see cref="T:System.Collections.Generic.SortedList`2" /> czy zawiera określony klucz.</summary>
        <returns><see langword="true" />Jeśli zawiera element z określonym kluczem; w przeciwnym razie, <see langword="false" />. <see cref="T:System.Collections.Generic.SortedList`2" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest operacją o ( `n`log), gdzie `n` is <xref:System.Collections.Generic.SortedList%602.Count%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, <xref:System.Collections.Generic.SortedList%602.ContainsKey%2A> jak używać metody do testowania, czy klucz istnieje przed <xref:System.Collections.Generic.SortedList%602.Add%2A> wywołaniem metody. Pokazano również, jak używać <xref:System.Collections.Generic.SortedList%602.TryGetValue%2A> metody do pobierania wartości, co jest wydajnym sposobem pobierania wartości, gdy program często próbuje klucze, które nie znajdują się na sortowanej liście. Na koniec pokazuje najmniej wydajny sposób sprawdzenia, czy klucze istnieją, przy użyciu <xref:System.Collections.Generic.SortedList%602.Item%2A> właściwości (indeksator w programie C#).  
  
 Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.Collections.Generic.SortedList%602> klasy.  
  
 [!code-cpp[Generic.SortedList#6](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#6)]
 [!code-csharp[Generic.SortedList#6](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#6)]
 [!code-vb[Generic.SortedList#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#6)]  
[!code-cpp[Generic.SortedList#5](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#5)]
[!code-csharp[Generic.SortedList#5](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#5)]
[!code-vb[Generic.SortedList#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#5)]  
[!code-cpp[Generic.SortedList#4](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#4)]
[!code-csharp[Generic.SortedList#4](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#4)]
[!code-vb[Generic.SortedList#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" />jest <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.SortedList`2.IndexOfKey(`0)" />
        <altmember cref="M:System.Collections.Generic.SortedList`2.ContainsValue(`1)" />
      </Docs>
    </Member>
    <Member MemberName="ContainsValue">
      <MemberSignature Language="C#" Value="public bool ContainsValue (TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ContainsValue(!TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.ContainsValue(`1)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContainsValue (value As TValue) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ContainsValue(TValue value);" />
      <MemberSignature Language="F#" Value="member this.ContainsValue : 'Value -&gt; bool" Usage="sortedList.ContainsValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="value">Wartość, która ma zostać zlokalizowana w <see cref="T:System.Collections.Generic.SortedList`2" />. Wartość może być <see langword="null" /> dla typów referencyjnych.</param>
        <summary>Określa, <see cref="T:System.Collections.Generic.SortedList`2" /> czy zawiera konkretną wartość.</summary>
        <returns><see langword="true" />Jeśli zawiera element z określoną wartością; <see langword="false" />w przeciwnym razie. <see cref="T:System.Collections.Generic.SortedList`2" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda określa równość przy użyciu domyślnej funkcji <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> porównującej dla typu `TValue`wartości.  <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>sprawdza, czy typ `TValue` wartości implementuje <xref:System.IComparable%601?displayProperty=nameWithType> i używa tej implementacji, jeśli jest dostępny.  Jeśli nie, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> sprawdza, czy typ `TValue` wartości implementuje <xref:System.IComparable?displayProperty=nameWithType>.  Jeśli typ `TValue` wartości nie implementuje żadnego interfejsu, ta metoda używa <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Ta metoda przeprowadza wyszukiwanie liniowe; w związku z tym średni czas wykonywania jest proporcjonalny do <xref:System.Collections.Generic.SortedList%602.Count%2A>. Oznacza to, że ta metoda jest operacją`n`o (), `n` gdzie <xref:System.Collections.Generic.SortedList%602.Count%2A>is.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.SortedList`2.IndexOfValue(`1)" />
        <altmember cref="M:System.Collections.Generic.SortedList`2.ContainsKey(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.Generic.SortedList&lt;'Key, 'Value&gt;.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyCollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę par klucz/wartość zawartych w <see cref="T:System.Collections.Generic.SortedList`2" />.</summary>
        <value>Liczba par klucz/wartość zawartych w <see cref="T:System.Collections.Generic.SortedList`2" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.SortedList%602.Capacity%2A>to liczba elementów, które <xref:System.Collections.Generic.SortedList%602> mogą być przechowywane. <xref:System.Collections.Generic.SortedList%602.Count%2A>to liczba elementów, które faktycznie znajdują się w <xref:System.Collections.Generic.SortedList%602>.  
  
 <xref:System.Collections.Generic.SortedList%602.Capacity%2A>jest zawsze większa lub równa <xref:System.Collections.Generic.SortedList%602.Count%2A>. Jeśli <xref:System.Collections.Generic.SortedList%602.Count%2A> program <xref:System.Collections.Generic.SortedList%602.Capacity%2A> przekracza podczas dodawania elementów, wydajność jest zwiększana przez automatyczne ponowne przydzielanie tablicy wewnętrznej przed skopiowaniem starych elementów i dodaniem nowych elementów.  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Generic.SortedList`2.Capacity" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt; GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator(Of KeyValuePair(Of TKey, TValue))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerator&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt; ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;'Key, 'Value&gt;&gt;" Usage="sortedList.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca moduł wyliczający, który wykonuje iterację przez <see cref="T:System.Collections.Generic.SortedList`2" />.</summary>
        <returns><see cref="T:System.Collections.Generic.IEnumerator`1" /> Typu<see cref="T:System.Collections.Generic.KeyValuePair`2" /> dla .<see cref="T:System.Collections.Generic.SortedList`2" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `foreach` Instrukcja C# języka(`for each` C++w VisualBasic)ukrywazłożonośćmodułówwyliczających.`For Each`  W związku z `foreach` tym zaleca się użycie zamiast bezpośredniego manipulowania modułem wyliczającym.  
  
 Moduły wyliczające mogą służyć do odczytu danych w kolekcji, ale nie można za ich pomocą modyfikować kolekcji źródłowej.  
  
 Słownik jest przechowywany w kolejności posortowanej przy użyciu wewnętrznego drzewa. Każdy nowy element jest pozycjonowany w poprawnej pozycji sortowania, a drzewo jest dostosowywane do zachowywania kolejności sortowania przy każdym usunięciu elementu. Podczas wyliczania jest zachowywany porządek sortowania.  
  
 Początkowo moduł wyliczający jest umieszczony przed pierwszym elementem w kolekcji. W tym miejscu <xref:System.Collections.Generic.IEnumerator%601.Current%2A> nie jest zdefiniowane. W związku z tym przed <xref:System.Collections.IEnumerator.MoveNext%2A> przeczytaniem <xref:System.Collections.Generic.IEnumerator%601.Current%2A>wartości parametru należy wywołać metodę wyliczającą do pierwszego elementu kolekcji.  
  
 <xref:System.Collections.Generic.IEnumerator%601.Current%2A>zwraca ten sam obiekt do <xref:System.Collections.IEnumerator.MoveNext%2A> momentu wywołania metody. <xref:System.Collections.IEnumerator.MoveNext%2A>ustawia <xref:System.Collections.Generic.IEnumerator%601.Current%2A> do następnego elementu.  
  
 Jeśli <xref:System.Collections.IEnumerator.MoveNext%2A> przekazuje koniec kolekcji, moduł wyliczający jest umieszczony po ostatnim elemencie w kolekcji i <xref:System.Collections.IEnumerator.MoveNext%2A> zwraca `false`. Gdy moduł wyliczający znajduje się w tym miejscu, kolejne <xref:System.Collections.IEnumerator.MoveNext%2A> wywołania `false`do zwrócenia. Jeśli ostatnie wywołanie <xref:System.Collections.IEnumerator.MoveNext%2A> zwrócone `false`, <xref:System.Collections.Generic.IEnumerator%601.Current%2A> nie jest zdefiniowane. Nie można ponownie <xref:System.Collections.Generic.IEnumerator%601.Current%2A> ustawić na pierwszy element kolekcji; zamiast tego należy utworzyć nowe wystąpienie modułu wyliczającego.  
  
 Moduł wyliczający zachowuje ważność tak długo, jak długo kolekcja pozostaje niezmieniona. Jeśli w kolekcji zostaną wprowadzone zmiany, takie jak dodanie, zmodyfikowanie lub usunięcie elementów, moduł wyliczający jest nieodwracalnie unieważniony i następne wywołanie <xref:System.Collections.IEnumerator.MoveNext%2A> lub <xref:System.Collections.IEnumerator.Reset%2A> wygeneruje <xref:System.InvalidOperationException>.  
  
 Moduł wyliczający nie ma wyłącznego dostępu do kolekcji, w związku z tym wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość. Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania.  Aby zezwolić wielu wątkom na dostęp do kolekcji w celu odczytu i zapisu danych, należy zaimplementować własny mechanizm synchronizacji.  
  
 Implementacje domyślne kolekcji w <xref:System.Collections.Generic?displayProperty=nameWithType> programie nie są zsynchronizowane.  
  
 Ta metoda jest operacją O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfKey">
      <MemberSignature Language="C#" Value="public int IndexOfKey (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfKey(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.IndexOfKey(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfKey (key As TKey) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfKey(TKey key);" />
      <MemberSignature Language="F#" Value="member this.IndexOfKey : 'Key -&gt; int" Usage="sortedList.IndexOfKey key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Klucz, który ma zostać zlokalizowany w <see cref="T:System.Collections.Generic.SortedList`2" />.</param>
        <summary>Wyszukuje określony klucz i zwraca indeks (liczony od zera) w całości <see cref="T:System.Collections.Generic.SortedList`2" />.</summary>
        <returns>Indeks <paramref name="key" /> (liczony od zera) w całym <see cref="T:System.Collections.Generic.SortedList`2" />, jeśli został znaleziony; w przeciwnym razie-1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przeprowadza wyszukiwanie binarne; w związku z tym ta metoda jest operacją `n`o (log) `n` , <xref:System.Collections.Generic.SortedList%602.Count%2A>gdzie is.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" />jest <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.SortedList`2.ContainsKey(`0)" />
        <altmember cref="M:System.Collections.Generic.SortedList`2.IndexOfValue(`1)" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfValue">
      <MemberSignature Language="C#" Value="public int IndexOfValue (TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfValue(!TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.IndexOfValue(`1)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfValue (value As TValue) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfValue(TValue value);" />
      <MemberSignature Language="F#" Value="member this.IndexOfValue : 'Value -&gt; int" Usage="sortedList.IndexOfValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="value">Wartość, która ma zostać zlokalizowana w <see cref="T:System.Collections.Generic.SortedList`2" />.  Wartość może być <see langword="null" /> dla typów referencyjnych.</param>
        <summary>Wyszukuje określoną wartość i zwraca indeks (liczony od zera) pierwszego wystąpienia w całości <see cref="T:System.Collections.Generic.SortedList`2" />.</summary>
        <returns>Indeks (liczony od zera) pierwszego wystąpienia <paramref name="value" /> w całości <see cref="T:System.Collections.Generic.SortedList`2" />, jeśli został znaleziony; w przeciwnym razie-1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda określa równość przy użyciu domyślnej funkcji <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> porównującej dla typu `TValue`wartości.  <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>sprawdza, czy typ `TValue` wartości implementuje <xref:System.IComparable%601?displayProperty=nameWithType> i używa tej implementacji, jeśli jest dostępny.  Jeśli nie, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> sprawdza, czy typ `TValue` wartości implementuje <xref:System.IComparable?displayProperty=nameWithType>.  Jeśli typ `TValue` wartości nie implementuje żadnego interfejsu, ta metoda używa <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Ta metoda przeprowadza wyszukiwanie liniowe; w związku z tym średni czas wykonywania jest proporcjonalny do <xref:System.Collections.Generic.SortedList%602.Count%2A>. Oznacza to, że ta metoda jest operacją`n`o (), `n` gdzie <xref:System.Collections.Generic.SortedList%602.Count%2A>is.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.SortedList`2.ContainsValue(`1)" />
        <altmember cref="M:System.Collections.Generic.SortedList`2.IndexOfKey(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public TValue this[TKey key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !TValue Item(!TKey)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.Item(`0)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Item(key As TKey) As TValue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TValue default[TKey] { TValue get(TKey key); void set(TKey key, TValue value); };" />
      <MemberSignature Language="F#" Value="member this.Item('Key) : 'Value with get, set" Usage="System.Collections.Generic.SortedList&lt;'Key, 'Value&gt;.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IDictionary`2.Item(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Klucz, którego wartość ma zostać pobrana lub ustawiona.</param>
        <summary>Pobiera lub ustawia wartość skojarzoną z określonym kluczem.</summary>
        <value>Wartość skojarzona z określonym kluczem. Jeśli określony klucz nie zostanie znaleziony, operacja <see cref="T:System.Collections.Generic.KeyNotFoundException" /> get wyrzuca i tworzy nowy element przy użyciu określonego klucza.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zapewnia możliwość dostępu do określonego elementu w kolekcji przy użyciu następującej składni: `myCollection[key]`.  
  
 Klucz nie może być `null`, ale wartość może być, jeśli typ wartości na liście, `TValue`jest typem referencyjnym.  
  
 Jeśli klucz nie zostanie znaleziony, gdy wartość jest pobierana, <xref:System.Collections.Generic.KeyNotFoundException> jest generowany. Jeśli klucz nie zostanie znaleziony podczas ustawiania wartości, zostanie dodany klucz i wartość.  
  
 Można również użyć <xref:System.Collections.Generic.SortedList%602.Item%2A> właściwości, aby dodać nowe elementy przez ustawienie wartości klucza, który nie istnieje <xref:System.Collections.Generic.SortedList%602>w, na przykład `myCollection["myNonexistentKey"] = myValue`. Jeśli jednak określony klucz już istnieje w <xref:System.Collections.Generic.SortedList%602>, <xref:System.Collections.Generic.SortedList%602.Item%2A> ustawienie właściwości zastępuje starą wartość. Z kolei <xref:System.Collections.Generic.SortedList%602.Add%2A> Metoda nie modyfikuje istniejących elementów.  
  
 C# Język używa [`this`](~/docs/csharp/language-reference/keywords/this.md) słowa kluczowego do definiowania indeksatorów <xref:System.Collections.Generic.SortedList%602.Item%2A> zamiast implementowania właściwości. Visual Basic implementuje <xref:System.Collections.Generic.SortedList%602.Item%2A> jako właściwość domyślną, która zapewnia te same funkcje indeksowania.  
  
 Pobieranie wartości tej właściwości jest operacją o (log `n`), gdzie n to. <xref:System.Collections.Generic.SortedList%602.Count%2A> Ustawienie właściwości jest operacją o (log `n`), jeśli klucz już znajduje się <xref:System.Collections.Generic.SortedList%602>w. Jeśli klucz nie znajduje się na liście, ustawienie właściwości jest operacją o (`n`) dla danych niesortowanych lub O (log `n`), jeśli nowy element zostanie dodany na końcu listy. Jeśli Wstaw powoduje zmianę rozmiaru, operacja ma wartość O (`n`).  
  
   
  
## Examples  
 Poniższy przykład kodu używa <xref:System.Collections.Generic.SortedList%602.Item%2A> właściwości (indeksator w C#) do pobierania wartości, <xref:System.Collections.Generic.KeyNotFoundException> pokazując, że jest zgłaszane, gdy żądany klucz nie jest obecny i pokazuje, że wartość skojarzona z kluczem może zostać zamieniona.  
  
 W przykładzie pokazano również, jak używać <xref:System.Collections.Generic.SortedList%602.TryGetValue%2A> metody jako wydajniejszego sposobu pobierania wartości, jeśli program często musi wypróbować wartości klucza, które nie znajdują się na sortowanej liście.  
  
 Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.Collections.Generic.SortedList%602> klasy.  
  
 [!code-cpp[Generic.SortedList#3](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#3)]
 [!code-csharp[Generic.SortedList#3](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#3)]
 [!code-vb[Generic.SortedList#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#3)]  
[!code-cpp[Generic.SortedList#4](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#4)]
[!code-csharp[Generic.SortedList#4](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#4)]
[!code-vb[Generic.SortedList#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#4)]  
[!code-cpp[Generic.SortedList#5](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#5)]
[!code-csharp[Generic.SortedList#5](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#5)]
[!code-vb[Generic.SortedList#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Collections.Generic.KeyNotFoundException">Właściwość jest pobierana i <paramref name="key" /> nie istnieje w kolekcji.</exception>
        <altmember cref="M:System.Collections.Generic.SortedList`2.Add(`0,`1)" />
      </Docs>
    </Member>
    <Member MemberName="Keys">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;TKey&gt; Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;!TKey&gt; Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.Keys" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Keys As IList(Of TKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;TKey&gt; ^ Keys { System::Collections::Generic::IList&lt;TKey&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Keys : System.Collections.Generic.IList&lt;'Key&gt;" Usage="System.Collections.Generic.SortedList&lt;'Key, 'Value&gt;.Keys" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;TKey&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję zawierającą klucze w <see cref="T:System.Collections.Generic.SortedList`2" />, w kolejności posortowanej.</summary>
        <value><see cref="T:System.Collections.Generic.IList`1" /> Zawierający klucze <see cref="T:System.Collections.Generic.SortedList`2" />w.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kolejność kluczy w <xref:System.Collections.Generic.IList%601> elemencie jest taka sama jak kolejność <xref:System.Collections.Generic.SortedList%602>w.  
  
 Zwracana <xref:System.Collections.Generic.IList%601> wartość nie jest kopią statyczną; zamiast tego <xref:System.Collections.Generic.IList%601> odwołuje się do kluczy w oryginalnym <xref:System.Collections.Generic.SortedList%602>. W związku z tym zmiany <xref:System.Collections.Generic.SortedList%602> w dalszym ciągu zostaną odzwierciedlone w. <xref:System.Collections.Generic.IList%601>  
  
 Kolekcja zwracana przez <xref:System.Collections.Generic.SortedList%602.Keys%2A> Właściwość zapewnia wydajny sposób pobierania kluczy według indeksu. Nie jest konieczne ponowne generowanie listy podczas uzyskiwania dostępu do właściwości, ponieważ lista jest tylko otoką dla wewnętrznej tablicy kluczy. Poniższy kod ilustruje użycie <xref:System.Collections.Generic.SortedList%602.Keys%2A> właściwości do indeksowanego pobierania kluczy z posortowanej listy elementów z kluczami ciągów:  
  
 [!code-cpp[Generic.SortedList#11](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/remarks.cpp#11)]
 [!code-csharp[Generic.SortedList#11](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/remarks.cs#11)]
 [!code-vb[Generic.SortedList#11](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/remarks.vb#11)]  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak wyliczyć klucze na posortowanej liście przy użyciu <xref:System.Collections.Generic.SortedList%602.Keys%2A> właściwości oraz jak wyliczyć klucze i wartości z listy sortowanej.  
  
 W przykładzie pokazano również, <xref:System.Collections.Generic.SortedList%602.Keys%2A> jak używać właściwości do wydajnego indeksowanego pobierania kluczy.  
  
 Ten kod jest częścią większego przykładu, który można skompilować i wykonać. Zobacz <xref:System.Collections.Generic.SortedList%602>.  
  
 [!code-cpp[Generic.SortedList#9](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#9)]
 [!code-csharp[Generic.SortedList#9](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#9)]
 [!code-vb[Generic.SortedList#9](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#9)]  
[!code-cpp[Generic.SortedList#7](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#7)]
[!code-csharp[Generic.SortedList#7](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#7)]
[!code-vb[Generic.SortedList#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IList`1" />
        <altmember cref="P:System.Collections.Generic.SortedList`2.Values" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (key As TKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Remove(TKey key);" />
      <MemberSignature Language="F#" Value="abstract member Remove : 'Key -&gt; bool&#xA;override this.Remove : 'Key -&gt; bool" Usage="sortedList.Remove key" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Klucz elementu do usunięcia.</param>
        <summary>Usuwa element z określonym kluczem z <see cref="T:System.Collections.Generic.SortedList`2" />.</summary>
        <returns><see langword="true" />Jeśli element został pomyślnie usunięty; w przeciwnym razie. <see langword="false" />  Ta metoda zwraca również <see langword="false" /> wartość <paramref name="key" /> , jeśli nie została znaleziona <see cref="T:System.Collections.Generic.SortedList`2" />w oryginalnym.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przeprowadza wyszukiwanie binarne; jednak elementy są przesuwane do wypełnienia w otwartym miejscu, dlatego ta metoda jest operacją o (`n`), gdzie `n` is <xref:System.Collections.Generic.SortedList%602.Count%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak usunąć parę klucz/wartość z posortowanej listy przy użyciu <xref:System.Collections.Generic.SortedList%602.Remove%2A> metody.  
  
 Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.Collections.Generic.SortedList%602> klasy.  
  
 [!code-cpp[Generic.SortedList#10](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#10)]
 [!code-csharp[Generic.SortedList#10](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#10)]
 [!code-vb[Generic.SortedList#10](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" />jest <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.SortedList`2.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Collections.Generic.SortedList`2.Clear" />
        <altmember cref="M:System.Collections.Generic.SortedList`2.Add(`0,`1)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public void RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAt (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAt(int index);" />
      <MemberSignature Language="F#" Value="member this.RemoveAt : int -&gt; unit" Usage="sortedList.RemoveAt index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Indeks (liczony od zera) elementu do usunięcia.</param>
        <summary>Usuwa element w określonym indeksie <see cref="T:System.Collections.Generic.SortedList`2" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przeprowadza wyszukiwanie binarne; jednak elementy są przesuwane do wypełnienia w otwartym miejscu, dlatego ta metoda jest operacją o (`n`), gdzie `n` is <xref:System.Collections.Generic.SortedList%602.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />jest mniejsza od zera.  
  
—lub— 
 <paramref name="index" />jest równa lub większa niż <see cref="P:System.Collections.Generic.SortedList`2.Count" />.</exception>
        <altmember cref="M:System.Collections.Generic.SortedList`2.Remove(`0)" />
        <altmember cref="M:System.Collections.Generic.SortedList`2.Clear" />
        <altmember cref="M:System.Collections.Generic.SortedList`2.Add(`0,`1)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Add">
      <MemberSignature Language="C#" Value="void ICollection&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.Add (System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt; keyValuePair);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Add(valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt; keyValuePair) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#Add(System.Collections.Generic.KeyValuePair{`0,`1})" />
      <MemberSignature Language="VB.NET" Value="Sub Add (keyValuePair As KeyValuePair(Of TKey, TValue)) Implements ICollection(Of KeyValuePair(Of TKey, TValue)).Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Add(System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt; keyValuePair) = System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyValuePair" Type="System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;" />
      </Parameters>
      <Docs>
        <param name="keyValuePair">, <see cref="T:System.Collections.Generic.KeyValuePair`2" /> Aby dodać <see cref="T:System.Collections.Generic.ICollection`1" />do.</param>
        <summary>Dodaje parę klucz/wartość do <see cref="T:System.Collections.Generic.ICollection`1" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Contains">
      <MemberSignature Language="C#" Value="bool ICollection&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.Contains (System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt; keyValuePair);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Contains(valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt; keyValuePair) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#Contains(System.Collections.Generic.KeyValuePair{`0,`1})" />
      <MemberSignature Language="VB.NET" Value="Function Contains (keyValuePair As KeyValuePair(Of TKey, TValue)) As Boolean Implements ICollection(Of KeyValuePair(Of TKey, TValue)).Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Contains(System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt; keyValuePair) = System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyValuePair" Type="System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;" />
      </Parameters>
      <Docs>
        <param name="keyValuePair"><see cref="T:System.Collections.Generic.KeyValuePair`2" /> Aby zlokalizować <see cref="T:System.Collections.Generic.ICollection`1" />w.</param>
        <summary>Określa, <see cref="T:System.Collections.Generic.ICollection`1" /> czy zawiera określony element.</summary>
        <returns><see langword="true" />Jeśli <paramref name="keyValuePair" /> znajduje się <see cref="T:System.Collections.Generic.ICollection`1" />w; w przeciwnym razie <see langword="false" />,.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.CopyTo (System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.CopyTo(valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Sub CopyTo (array As KeyValuePair(Of TKey, TValue)(), arrayIndex As Integer) Implements ICollection(Of KeyValuePair(Of TKey, TValue)).CopyTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.CopyTo(cli::array &lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt; ^ array, int arrayIndex) = System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;::CopyTo;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Jednowymiarowy <see cref="T:System.Array" /> , który jest miejscem docelowym elementów skopiowanych z <see cref="T:System.Collections.Generic.ICollection`1" />. <see cref="T:System.Array" /> Musi mieć indeksowanie oparte na zero.</param>
        <param name="arrayIndex">Indeks (liczony od zera) <paramref name="array" /> , w którym rozpoczyna się kopiowanie.</param>
        <summary>Kopiuje elementy <see cref="T:System.Collections.Generic.ICollection`1" /> <see cref="T:System.Array" />do, zaczynając od określonego <see cref="T:System.Array" /> indeksu.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="arrayIndex" />jest mniejsza od zera.</exception>
        <exception cref="T:System.ArgumentException">Liczba elementów w źródle <see cref="T:System.Collections.Generic.ICollection`1" /> jest większa niż dostępne miejsce od <paramref name="arrayIndex" /> do końca miejsca docelowego <paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements ICollection(Of KeyValuePair(Of TKey, TValue)).IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey,TValue&gt;&gt;::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy jest <see cref="T:System.Collections.Generic.ICollection`1" /> tylko do odczytu.</summary>
        <value><see langword="true" />Jeśli jest <see cref="T:System.Collections.Generic.ICollection`1" /> tylko do odczytu; <see langword="false" />w przeciwnym razie. W domyślnej implementacji programu <see cref="T:System.Collections.Generic.SortedList`2" />ta właściwość zawsze zwraca wartość. <see langword="false" /></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Remove">
      <MemberSignature Language="C#" Value="bool ICollection&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.Remove (System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt; keyValuePair);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Remove(valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt; keyValuePair) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#Remove(System.Collections.Generic.KeyValuePair{`0,`1})" />
      <MemberSignature Language="VB.NET" Value="Function Remove (keyValuePair As KeyValuePair(Of TKey, TValue)) As Boolean Implements ICollection(Of KeyValuePair(Of TKey, TValue)).Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Remove(System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt; keyValuePair) = System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyValuePair" Type="System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;" />
      </Parameters>
      <Docs>
        <param name="keyValuePair"><see cref="T:System.Collections.Generic.KeyValuePair`2" /> Do usunięcia <see cref="T:System.Collections.Generic.ICollection`1" />z.</param>
        <summary>Usuwa pierwsze wystąpienie określonej pary klucz/wartość z <see cref="T:System.Collections.Generic.ICollection`1" />.</summary>
        <returns><see langword="true" />Jeśli <paramref name="keyValuePair" /> <see cref="T:System.Collections.Generic.ICollection`1" />program został<see langword="false" />pomyślnie usunięty z programu; w przeciwnym razie. Ta metoda zwraca również <see langword="false" /> wartość <paramref name="keyValuePair" /> , jeśli nie została znaleziona <see cref="T:System.Collections.Generic.ICollection`1" />w oryginalnym.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Keys">
      <MemberSignature Language="C#" Value="System.Collections.Generic.ICollection&lt;TKey&gt; System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;!TKey&gt; System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.System#Collections#Generic#IDictionary&lt;TKey,TValue&gt;#Keys" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Keys As ICollection(Of TKey) Implements IDictionary(Of TKey, TValue).Keys" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::Generic::ICollection&lt;TKey&gt; ^ System::Collections::Generic::IDictionary&lt;TKey,TValue&gt;::Keys { System::Collections::Generic::ICollection&lt;TKey&gt; ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Keys" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IDictionary`2.Keys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;TKey&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera zawierający klucze <see cref="T:System.Collections.Generic.IDictionary`2" />. <see cref="T:System.Collections.Generic.ICollection`1" /></summary>
        <value><see cref="T:System.Collections.Generic.ICollection`1" /> Zawierający klucze<see cref="T:System.Collections.Generic.IDictionary`2" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Values">
      <MemberSignature Language="C#" Value="System.Collections.Generic.ICollection&lt;TValue&gt; System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;!TValue&gt; System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.System#Collections#Generic#IDictionary&lt;TKey,TValue&gt;#Values" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Values As ICollection(Of TValue) Implements IDictionary(Of TKey, TValue).Values" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::Generic::ICollection&lt;TValue&gt; ^ System::Collections::Generic::IDictionary&lt;TKey,TValue&gt;::Values { System::Collections::Generic::ICollection&lt;TValue&gt; ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Values" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IDictionary`2.Values</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;TValue&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera zawierający wartości z <see cref="T:System.Collections.Generic.IDictionary`2" />. <see cref="T:System.Collections.Generic.ICollection`1" /></summary>
        <value>Obiekt zawierający wartości w <see cref="T:System.Collections.Generic.IDictionary`2" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt; IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt; System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.System#Collections#Generic#IEnumerable&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of KeyValuePair(Of TKey, TValue)) Implements IEnumerable(Of KeyValuePair(Of TKey, TValue)).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt; ^ System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca moduł wyliczający, który dokonuje iteracji w kolekcji.</summary>
        <returns><see cref="T:System.Collections.Generic.IEnumerator`1" /> , Który może być używany do iteracji kolekcji.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Keys">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;TKey&gt; System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;!TKey&gt; System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.System#Collections#Generic#IReadOnlyDictionary&lt;TKey,TValue&gt;#Keys" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Keys As IEnumerable(Of TKey) Implements IReadOnlyDictionary(Of TKey, TValue).Keys" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::Generic::IEnumerable&lt;TKey&gt; ^ System::Collections::Generic::IReadOnlyDictionary&lt;TKey,TValue&gt;::Keys { System::Collections::Generic::IEnumerable&lt;TKey&gt; ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Keys" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyDictionary`2.Keys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TKey&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wyliczalną kolekcję, która zawiera klucze w słowniku tylko do odczytu.</summary>
        <value>Wyliczalna Kolekcja zawierająca klucze w słowniku tylko do odczytu.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Values">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;TValue&gt; System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;!TValue&gt; System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.System#Collections#Generic#IReadOnlyDictionary&lt;TKey,TValue&gt;#Values" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Values As IEnumerable(Of TValue) Implements IReadOnlyDictionary(Of TKey, TValue).Values" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::Generic::IEnumerable&lt;TValue&gt; ^ System::Collections::Generic::IReadOnlyDictionary&lt;TKey,TValue&gt;::Values { System::Collections::Generic::IEnumerable&lt;TValue&gt; ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Values" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyDictionary`2.Values</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TValue&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wyliczalną kolekcję zawierającą wartości w słowniku tylko do odczytu.</summary>
        <value>Wyliczalna Kolekcja zawierająca wartości w słowniku tylko do odczytu.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int arrayIndex);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 arrayIndex) cil managed" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int arrayIndex) = System::Collections::ICollection::CopyTo;" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Jednowymiarowy <see cref="T:System.Array" /> , który jest miejscem docelowym elementów skopiowanych z <see cref="T:System.Collections.ICollection" />. <see cref="T:System.Array" /> Musi mieć indeksowanie oparte na zero.</param>
        <param name="arrayIndex">Indeks (liczony od zera) <paramref name="array" /> , w którym rozpoczyna się kopiowanie.</param>
        <summary>Kopiuje elementy <see cref="T:System.Collections.ICollection" /> <see cref="T:System.Array" />do, zaczynając od określonego <see cref="T:System.Array" /> indeksu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Jeśli nie można automatycznie rzutować <xref:System.Collections.ICollection> typu źródła na typ docelowy `array`, nieogólne implementacje <xref:System.Collections.ICollection.CopyTo%2A?displayProperty=nameWithType> throw <xref:System.InvalidCastException>, podczas gdy ogólna implementacja <xref:System.ArgumentException>zgłasza.  
  
 Ta metoda jest operacją o`n`(), gdzie `n` is <xref:System.Collections.Generic.SortedList%602.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="arrayIndex" />jest mniejsza od zera.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="array" />jest wielowymiarowych.  
  
—lub— 
 <paramref name="array" />nie ma indeksowania opartego na zero.  
  
—lub— 
Liczba elementów w źródle <see cref="T:System.Collections.ICollection" /> jest większa niż dostępne miejsce od <paramref name="arrayIndex" /> do końca miejsca docelowego <paramref name="array" />.  
  
—lub— 
Nie można automatycznie rzutować <see cref="T:System.Collections.ICollection" /> typu źródła na typ docelowy. <paramref name="array" /></exception>
        <altmember cref="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, <see cref="T:System.Collections.ICollection" /> czy dostęp do elementu jest synchronizowany (bezpieczny wątkowo).</summary>
        <value><see langword="true" />Jeśli dostęp do programu <see cref="T:System.Collections.ICollection" /> jest synchronizowany (wątek bezpieczny); <see langword="false" />w przeciwnym razie.  W domyślnej implementacji programu <see cref="T:System.Collections.Generic.SortedList`2" />ta właściwość zawsze zwraca wartość. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Implementacje domyślne kolekcji w <xref:System.Collections.Generic?displayProperty=nameWithType> programie nie są zsynchronizowane.  
  
 Wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość.  Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania.  Aby zezwolić wielu wątkom na dostęp do kolekcji w celu odczytu i zapisu danych, należy zaimplementować własny mechanizm synchronizacji.  
  
 Właściwość zwraca obiekt, którego można użyć do synchronizowania dostępu <xref:System.Collections.ICollection>do. <xref:System.Collections.ICollection.SyncRoot%2A> Synchronizacja jest skuteczna tylko wtedy, gdy wszystkie wątki blokują ten obiekt przed uzyskaniem dostępu do kolekcji.  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera obiekt, który może służyć do synchronizowania dostępu do <see cref="T:System.Collections.ICollection" />.</summary>
        <value>Obiekt, który może służyć do synchronizowania dostępu do <see cref="T:System.Collections.ICollection" />.  W domyślnej implementacji programu <see cref="T:System.Collections.Generic.SortedList`2" />ta właściwość zawsze zwraca bieżące wystąpienie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Implementacje domyślne kolekcji w <xref:System.Collections.Generic?displayProperty=nameWithType> programie nie są zsynchronizowane.  
  
 Wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość. Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania. Aby zezwolić wielu wątkom na dostęp do kolekcji w celu odczytu i zapisu danych, należy zaimplementować własny mechanizm synchronizacji.  
  
 Właściwość zwraca obiekt, którego można użyć do synchronizowania dostępu <xref:System.Collections.ICollection>do. <xref:System.Collections.ICollection.SyncRoot%2A> Synchronizacja jest skuteczna tylko wtedy, gdy wszystkie wątki blokują ten obiekt przed uzyskaniem dostępu do kolekcji. Poniższy kod przedstawia użycie <xref:System.Collections.ICollection.SyncRoot%2A> właściwości dla C#, C++i Visual Basic.  
  
```csharp  
ICollection ic = ...;  
lock (ic.SyncRoot) {  
   // Access the collection.  
}  
```  
  
```vb  
Dim ic As ICollection = ...  
SyncLock ic.SyncRoot  
   ' Access the collection.  
End SyncLock  
```  
  
```cpp#  
ICollection^ ic = ...;  
try {  
   Monitor::Enter(ic->SyncRoot);  
   // Access the collection.  
}  
finally {  
   Monitor::Exit(ic->SyncRoot);  
}  
```  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Add">
      <MemberSignature Language="C#" Value="void IDictionary.Add (object key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IDictionary.Add(object key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.System#Collections#IDictionary#Add(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Add (key As Object, value As Object) Implements IDictionary.Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IDictionary.Add(System::Object ^ key, System::Object ^ value) = System::Collections::IDictionary::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Add(System.Object,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key"><see cref="T:System.Object" /> Do użycia jako klucz elementu do dodania.</param>
        <param name="value"><see cref="T:System.Object" /> Do użycia jako wartość elementu do dodania.</param>
        <summary>Dodaje element z podanym kluczem i wartością do <see cref="T:System.Collections.IDictionary" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można również użyć <xref:System.Collections.IDictionary.Item%2A> właściwości, aby dodać nowe elementy przez ustawienie wartości klucza, który nie istnieje w słowniku, na `myCollection["myNonexistentKey"] = myValue`przykład. Jeśli jednak określony klucz już istnieje w słowniku, ustawienie <xref:System.Collections.IDictionary.Item%2A> właściwości zastępuje starą wartość. Z kolei <xref:System.Collections.IDictionary.Add%2A> Metoda nie modyfikuje istniejących elementów.  
  
 Ta metoda jest operacją o`n`() dla niesortowanych danych, gdzie `n` is <xref:System.Collections.Generic.SortedList%602.Count%2A>. Jest to operacja o (log `n`), jeśli nowy element zostanie dodany na końcu listy. Jeśli Wstaw powoduje zmianę rozmiaru, operacja ma wartość O (`n`).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, <xref:System.Collections.Generic.SortedList%602> jak uzyskać dostęp do klasy <xref:System.Collections.IDictionary?displayProperty=nameWithType> za pomocą interfejsu. Przykładowy kod tworzy puste <xref:System.Collections.Generic.SortedList%602> ciągi z kluczami ciągu i <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Add%2A> używa metody do dodawania niektórych elementów. W przykładzie pokazano, że <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Add%2A> Metoda <xref:System.ArgumentException> zgłasza podczas próby dodania zduplikowanego klucza lub gdy podano klucz lub wartość błędnego typu danych.  
  
 Przykład kodu demonstruje użycie kilku innych elementów członkowskich <xref:System.Collections.IDictionary?displayProperty=nameWithType> interfejsu.  
  
 [!code-csharp[Generic.SortedList.IDictionary#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#1)]
 [!code-vb[Generic.SortedList.IDictionary#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="key" />jest typu, którego nie można przypisać do typu <paramref name="TKey" /> <see cref="T:System.Collections.IDictionary" />klucza.  
  
—lub— 
 <paramref name="value" />jest typu, którego nie można przypisać do typu <paramref name="TValue" /> <see cref="T:System.Collections.IDictionary" />wartości.  
  
—lub— 
Element z tym samym kluczem już istnieje w <see cref="T:System.Collections.IDictionary" />.</exception>
        <altmember cref="P:System.Collections.IDictionary.Item(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Contains">
      <MemberSignature Language="C#" Value="bool IDictionary.Contains (object key);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IDictionary.Contains(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.System#Collections#IDictionary#Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Contains (key As Object) As Boolean Implements IDictionary.Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IDictionary.Contains(System::Object ^ key) = System::Collections::IDictionary::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Klucz, który ma zostać zlokalizowany w <see cref="T:System.Collections.IDictionary" />.</param>
        <summary>Określa, <see cref="T:System.Collections.IDictionary" /> czy zawiera element z określonym kluczem.</summary>
        <returns><see langword="true" />Jeśli zawiera element z kluczem; w przeciwnym razie, <see langword="false" />. <see cref="T:System.Collections.IDictionary" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca `false` wartość `key` , jeśli jest typu, którego nie można przypisać do typu `TKey` <xref:System.Collections.Generic.SortedList%602>klucza.  
  
 Ta metoda jest operacją o ( `n`log), gdzie `n` is <xref:System.Collections.Generic.SortedList%602.Count%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Contains%2A> jak używać metody <xref:System.Collections.IDictionary?displayProperty=nameWithType> interfejsu z <xref:System.Collections.Generic.SortedList%602>. Przykład pokazuje, że metoda zwraca `false` , jeśli podano klucz nieprawidłowego typu danych.  
  
 Przykład kodu jest częścią większego przykładu, łącznie z danymi wyjściowymi dostarczonymi <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Add%2A> dla metody.  
  
 [!code-csharp[Generic.SortedList.IDictionary#31](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#31)]
 [!code-vb[Generic.SortedList.IDictionary#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#31)]  
[!code-csharp[Generic.SortedList.IDictionary#6](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#6)]
[!code-vb[Generic.SortedList.IDictionary#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#6)]  
[!code-csharp[Generic.SortedList.IDictionary#32](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#32)]
[!code-vb[Generic.SortedList.IDictionary#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" />jest <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.SortedList`2.ContainsKey(`0)" />
        <altmember cref="M:System.Collections.Generic.SortedList`2.ContainsValue(`1)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IDictionaryEnumerator IDictionary.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.System#Collections#IDictionary#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IDictionaryEnumerator Implements IDictionary.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IDictionaryEnumerator ^ System.Collections.IDictionary.GetEnumerator() = System::Collections::IDictionary::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionaryEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Collections.IDictionaryEnumerator" /> Zwraca wartość<see cref="T:System.Collections.IDictionary" />dla.</summary>
        <returns><see cref="T:System.Collections.IDictionaryEnumerator" /> Dla .<see cref="T:System.Collections.IDictionary" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `foreach` Instrukcja C# języka(`for each` C++w VisualBasic)ukrywazłożonośćmodułówwyliczających.`For Each`  W związku z `foreach` tym zaleca się użycie zamiast bezpośredniego manipulowania modułem wyliczającym.  
  
 Moduły wyliczające mogą służyć do odczytu danych w kolekcji, ale nie można za ich pomocą modyfikować kolekcji źródłowej.  
  
 Początkowo moduł wyliczający jest umieszczony przed pierwszym elementem w kolekcji. <xref:System.Collections.IEnumerator.Reset%2A>przywraca również moduł wyliczający z powrotem do tego położenia.  W tym miejscu <xref:System.Collections.IDictionaryEnumerator.Entry%2A> nie jest zdefiniowane. W związku z tym przed <xref:System.Collections.IEnumerator.MoveNext%2A> przeczytaniem <xref:System.Collections.IDictionaryEnumerator.Entry%2A>wartości parametru należy wywołać metodę wyliczającą do pierwszego elementu kolekcji.  
  
 <xref:System.Collections.IDictionaryEnumerator.Entry%2A>zwraca ten sam obiekt do <xref:System.Collections.IEnumerator.MoveNext%2A> momentu <xref:System.Collections.IEnumerator.Reset%2A> wywołania metody lub. <xref:System.Collections.IEnumerator.MoveNext%2A>ustawia <xref:System.Collections.IDictionaryEnumerator.Entry%2A> do następnego elementu.  
  
 Jeśli <xref:System.Collections.IEnumerator.MoveNext%2A> przekazuje koniec kolekcji, moduł wyliczający jest umieszczony po ostatnim elemencie w kolekcji i <xref:System.Collections.IEnumerator.MoveNext%2A> zwraca `false`. Gdy moduł wyliczający znajduje się w tym miejscu, kolejne <xref:System.Collections.IEnumerator.MoveNext%2A> wywołania również `false`zwracają. Jeśli ostatnie wywołanie <xref:System.Collections.IEnumerator.MoveNext%2A> zwrócone `false`, <xref:System.Collections.IDictionaryEnumerator.Entry%2A> nie jest zdefiniowane. Aby ponownie <xref:System.Collections.IDictionaryEnumerator.Entry%2A> ustawić na pierwszy element kolekcji, możesz wywołać metodę <xref:System.Collections.IEnumerator.Reset%2A> i <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Moduł wyliczający zachowuje ważność tak długo, jak długo kolekcja pozostaje niezmieniona. Jeśli w kolekcji zostaną wprowadzone zmiany, takie jak dodanie, zmodyfikowanie lub usunięcie elementów, moduł wyliczający jest nieodwracalnie unieważniony i następne wywołanie <xref:System.Collections.IEnumerator.MoveNext%2A> lub <xref:System.Collections.IEnumerator.Reset%2A> wygeneruje <xref:System.InvalidOperationException>.  
  
 Moduł wyliczający nie ma wyłącznego dostępu do kolekcji, w związku z tym wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość.  Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania.  Aby zezwolić wielu wątkom na dostęp do kolekcji w celu odczytu i zapisu danych, należy zaimplementować własny mechanizm synchronizacji.  
  
 Implementacje domyślne kolekcji w <xref:System.Collections.Generic?displayProperty=nameWithType> programie nie są zsynchronizowane.  
  
 Ta metoda jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak wyliczyć pary klucz/wartość na posortowanej `foreach` liście przy użyciu instrukcji (`For Each` w Visual Basic, `for each` w C++), która ukrywa użycie modułu wyliczającego. W szczególności należy zauważyć, że moduł wyliczający <xref:System.Collections.IDictionary?displayProperty=nameWithType> dla interfejsu <xref:System.Collections.DictionaryEntry> zwraca obiekty, <xref:System.Collections.Generic.KeyValuePair%602> a nie obiekty.  
  
 Przykład kodu jest częścią większego przykładu, łącznie z danymi wyjściowymi dostarczonymi <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Add%2A> dla metody.  
  
 [!code-csharp[Generic.SortedList.IDictionary#31](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#31)]
 [!code-vb[Generic.SortedList.IDictionary#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#31)]  
[!code-csharp[Generic.SortedList.IDictionary#7](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#7)]
[!code-vb[Generic.SortedList.IDictionary#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#7)]  
[!code-csharp[Generic.SortedList.IDictionary#32](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#32)]
[!code-vb[Generic.SortedList.IDictionary#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.SortedList`2.GetEnumerator" />
        <altmember cref="T:System.Collections.IDictionaryEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IDictionary.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IDictionary.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.System#Collections#IDictionary#IsFixedSize" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFixedSize As Boolean Implements IDictionary.IsFixedSize" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IDictionary::IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IDictionary.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, <see cref="T:System.Collections.IDictionary" /> czy ma stały rozmiar.</summary>
        <value><see langword="true" />Jeśli ma stały rozmiar; <see langword="false" />w przeciwnym razie. <see cref="T:System.Collections.IDictionary" />  W domyślnej implementacji programu <see cref="T:System.Collections.Generic.SortedList`2" />ta właściwość zawsze zwraca wartość. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W kolekcji o stałym rozmiarze po jej utworzeniu nie można dodawać ani usuwać elementów, jednak można modyfikować istniejące elementy.  
  
 Kolekcja o stałym rozmiarze jest po prostu kolekcją z otoką, która zapobiega dodawaniu i usuwaniu elementów; w związku z tym, jeśli wprowadzono zmiany do źródłowej kolekcji, w tym dodawanie lub usuwanie elementów, kolekcja o stałym rozmiarze odzwierciedla te zmiany.  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.IDictionary.IsFixedSize" />
        <altmember cref="P:System.Collections.IDictionary.IsReadOnly" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IDictionary.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IDictionary.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.System#Collections#IDictionary#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements IDictionary.IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IDictionary::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IDictionary.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy jest <see cref="T:System.Collections.IDictionary" /> tylko do odczytu.</summary>
        <value><see langword="true" />Jeśli jest <see cref="T:System.Collections.IDictionary" /> tylko do odczytu; <see langword="false" />w przeciwnym razie.  W domyślnej implementacji programu <see cref="T:System.Collections.Generic.SortedList`2" />ta właściwość zawsze zwraca wartość. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W kolekcji tylko do odczytu po jej utworzeniu nie można dodawać, usuwać ani modyfikować elementów.  
  
 Kolekcja, która jest tylko do odczytu, jest po prostu zbiorem z otoką uniemożliwiającą zmianę kolekcji; w związku z tym, jeśli zmiany zostaną wprowadzone do podstawowej kolekcji, kolekcja tylko do odczytu uwzględni te zmiany.  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.IDictionary.IsReadOnly" />
        <altmember cref="P:System.Collections.IDictionary.IsFixedSize" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IDictionary.Item[object key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IDictionary.Item(object)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.System#Collections#IDictionary#Item(System.Object)" />
      <MemberSignature Language="VB.NET" Value=" Property Item(key As Object) As Object Implements IDictionary.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::IDictionary::Item[System::Object ^] { System::Object ^ get(System::Object ^ key); void set(System::Object ^ key, System::Object ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IDictionary.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Item(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Klucz elementu do pobrania lub ustawienia.</param>
        <summary>Pobiera lub ustawia element z określonym kluczem.</summary>
        <value>Element z określonym kluczem lub <see langword="null" /> Jeśli <paramref name="key" /> nie znajduje się w słowniku lub <paramref name="key" /> jest typu, którego nie można <see cref="T:System.Collections.Generic.SortedList`2" />przypisać do typu <paramref name="TKey" /> klucza.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zwraca `null` wartość `key` , jeśli jest typu, którego nie można przypisać do typu `TKey` <xref:System.Collections.Generic.SortedList%602>klucza.  
  
 Ta właściwość zapewnia możliwość dostępu do określonego elementu w kolekcji przy użyciu następującej składni: `myCollection[key]`.  
  
 Można również użyć <xref:System.Collections.IDictionary.Item%2A> właściwości, aby dodać nowe elementy przez ustawienie wartości klucza, który nie istnieje w słowniku, na `myCollection["myNonexistentKey"] = myValue`przykład. Jeśli jednak określony klucz już istnieje w słowniku, ustawienie <xref:System.Collections.IDictionary.Item%2A> właściwości zastępuje starą wartość. Z kolei <xref:System.Collections.IDictionary.Add%2A> Metoda nie modyfikuje istniejących elementów.  
  
 Język używa [tego](~/docs/csharp/language-reference/keywords/this.md) słowa kluczowego, aby zdefiniować indeksatory zamiast implementowania <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Item%2A> właściwości. C# Visual Basic implementuje <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Item%2A> jako właściwość domyślną, która zapewnia te same funkcje indeksowania.  
  
 Pobieranie wartości tej właściwości jest operacją o (log `n`), gdzie n to. <xref:System.Collections.Generic.SortedList%602.Count%2A> Ustawienie właściwości jest operacją o (log `n`), jeśli klucz już znajduje się <xref:System.Collections.Generic.SortedList%602>w. Jeśli klucz nie znajduje się na liście, ustawienie właściwości jest operacją o (`n`) dla danych niesortowanych lub O (log `n`), jeśli nowy element zostanie dodany na końcu listy. Jeśli Wstaw powoduje zmianę rozmiaru, operacja ma wartość O (`n`).  
  
   
  
## Examples  
 Poniższy przykład kodu <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Item%2A> pokazuje <xref:System.Collections.Generic.SortedList%602>, jak używać właściwości (indeksator w C#języku) <xref:System.Collections.IDictionary?displayProperty=nameWithType> interfejsu z, i sposoby, aby właściwość była inna od <xref:System.Collections.Generic.SortedList%602.Item%2A?displayProperty=nameWithType> właściwości.  
  
 Przykład pokazuje, że <xref:System.Collections.Generic.SortedList%602.Item%2A?displayProperty=nameWithType> <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Item%2A?displayProperty=nameWithType> właściwość może zmienić wartość skojarzoną z istniejącym kluczem i może być użyta do dodania nowej pary klucz/wartość, jeśli określony klucz nie znajduje się na liście posortowanych. Przykład pokazuje również, że w przeciwieństwie <xref:System.Collections.Generic.SortedList%602.Item%2A?displayProperty=nameWithType> do właściwości <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Item%2A?displayProperty=nameWithType> właściwość nie zgłasza wyjątku, jeśli `key` nie znajduje się na liście sortowanej, zwracając odwołanie o wartości null. Na koniec przykład pokazuje, że pobranie <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Item%2A?displayProperty=nameWithType> właściwości zwraca odwołanie o wartości null, jeśli `key` nie jest poprawnym typem danych i że ustawienie właściwości zgłasza wyjątek, jeśli `key` nie jest poprawnym typem danych.  
  
 Przykład kodu jest częścią większego przykładu, łącznie z danymi wyjściowymi dostarczonymi <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Add%2A> dla metody.  
  
 [!code-csharp[Generic.SortedList.IDictionary#31](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#31)]
 [!code-vb[Generic.SortedList.IDictionary#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#31)]  
[!code-csharp[Generic.SortedList.IDictionary#3](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#3)]
[!code-vb[Generic.SortedList.IDictionary#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#3)]  
[!code-csharp[Generic.SortedList.IDictionary#4](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#4)]
[!code-vb[Generic.SortedList.IDictionary#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#4)]  
[!code-csharp[Generic.SortedList.IDictionary#32](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#32)]
[!code-vb[Generic.SortedList.IDictionary#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Przypisuje się wartość i <paramref name="key" /> jest typu, którego nie można przypisać do typu <paramref name="TKey" /> <see cref="T:System.Collections.Generic.SortedList`2" />klucza.  
  
—lub— 
Przypisuje się wartość i <paramref name="value" /> jest typu, którego nie można przypisać do typu <paramref name="TValue" /> <see cref="T:System.Collections.Generic.SortedList`2" />wartości.</exception>
        <altmember cref="P:System.Collections.Generic.SortedList`2.Item(`0)" />
        <altmember cref="M:System.Collections.IDictionary.Add(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Keys">
      <MemberSignature Language="C#" Value="System.Collections.ICollection System.Collections.IDictionary.Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection System.Collections.IDictionary.Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.System#Collections#IDictionary#Keys" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Keys As ICollection Implements IDictionary.Keys" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::ICollection ^ System::Collections::IDictionary::Keys { System::Collections::ICollection ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IDictionary.Keys" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Keys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera zawierający klucze <see cref="T:System.Collections.IDictionary" />. <see cref="T:System.Collections.ICollection" /></summary>
        <value><see cref="T:System.Collections.ICollection" /> Zawierający klucze<see cref="T:System.Collections.IDictionary" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kolejność kluczy w <xref:System.Collections.ICollection> elemencie jest taka sama jak kolejność <xref:System.Collections.Generic.SortedList%602>w.  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje <xref:System.Collections.IDictionary.Keys%2A> <xref:System.Collections.Generic.SortedDictionary%602>, jak używać właściwości <xref:System.Collections.IDictionary?displayProperty=nameWithType> interfejsu z, aby wyświetlić listę kluczy w słowniku. W przykładzie pokazano również, jak wyliczyć pary klucz/wartość na sortowanej liście; Należy zauważyć, że moduł wyliczający <xref:System.Collections.IDictionary?displayProperty=nameWithType> dla <xref:System.Collections.DictionaryEntry> interfejsu zwraca obiekty <xref:System.Collections.Generic.KeyValuePair%602> , a nie obiekty.  
  
 Przykład kodu jest częścią większego przykładu, łącznie z danymi wyjściowymi dostarczonymi <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Add%2A> dla metody.  
  
 [!code-csharp[Generic.SortedList.IDictionary#31](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#31)]
 [!code-vb[Generic.SortedList.IDictionary#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#31)]  
[!code-csharp[Generic.SortedList.IDictionary#9](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#9)]
[!code-vb[Generic.SortedList.IDictionary#9](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#9)]  
[!code-csharp[Generic.SortedList.IDictionary#7](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#7)]
[!code-vb[Generic.SortedList.IDictionary#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#7)]  
[!code-csharp[Generic.SortedList.IDictionary#32](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#32)]
[!code-vb[Generic.SortedList.IDictionary#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="P:System.Collections.Generic.SortedList`2.Keys" />
        <altmember cref="P:System.Collections.Generic.SortedList`2.Values" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Remove">
      <MemberSignature Language="C#" Value="void IDictionary.Remove (object key);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IDictionary.Remove(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.System#Collections#IDictionary#Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Remove (key As Object) Implements IDictionary.Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IDictionary.Remove(System::Object ^ key) = System::Collections::IDictionary::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Klucz elementu do usunięcia.</param>
        <summary>Usuwa element z określonym kluczem z <see cref="T:System.Collections.IDictionary" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przeprowadza wyszukiwanie binarne; jednak elementy są przesuwane do wypełnienia w otwartym miejscu, dlatego ta metoda jest operacją o (`n`), gdzie `n` is <xref:System.Collections.Generic.SortedList%602.Count%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Remove%2A> <xref:System.Collections.IDictionary?displayProperty=nameWithType> jak używać interfejsu z <xref:System.Collections.Generic.SortedList%602>.  
  
 Przykład kodu jest częścią większego przykładu, łącznie z danymi wyjściowymi dostarczonymi <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Add%2A> dla metody.  
  
 [!code-csharp[Generic.SortedList.IDictionary#31](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#31)]
 [!code-vb[Generic.SortedList.IDictionary#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#31)]  
[!code-csharp[Generic.SortedList.IDictionary#10](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#10)]
[!code-vb[Generic.SortedList.IDictionary#10](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#10)]  
[!code-csharp[Generic.SortedList.IDictionary#32](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#32)]
[!code-vb[Generic.SortedList.IDictionary#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" />jest <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.SortedList`2.Remove(`0)" />
        <altmember cref="M:System.Collections.Generic.SortedList`2.RemoveAt(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Values">
      <MemberSignature Language="C#" Value="System.Collections.ICollection System.Collections.IDictionary.Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection System.Collections.IDictionary.Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.System#Collections#IDictionary#Values" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Values As ICollection Implements IDictionary.Values" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::ICollection ^ System::Collections::IDictionary::Values { System::Collections::ICollection ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IDictionary.Values" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Values</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera zawierający wartości z <see cref="T:System.Collections.IDictionary" />. <see cref="T:System.Collections.ICollection" /></summary>
        <value><see cref="T:System.Collections.ICollection" /> Zawierający wartości <see cref="T:System.Collections.IDictionary" />z.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kolejność wartości w <xref:System.Collections.ICollection> elemencie jest taka sama jak kolejność <xref:System.Collections.Generic.SortedList%602>w.  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Values%2A> <xref:System.Collections.Generic.SortedList%602>, jak używać właściwości <xref:System.Collections.IDictionary?displayProperty=nameWithType> interfejsu z, aby wyświetlić listę wartości z listy posortowanej. W przykładzie pokazano również, jak wyliczyć pary klucz/wartość na sortowanej liście; Należy zauważyć, że moduł wyliczający <xref:System.Collections.IDictionary?displayProperty=nameWithType> dla <xref:System.Collections.DictionaryEntry> interfejsu zwraca obiekty <xref:System.Collections.Generic.KeyValuePair%602> , a nie obiekty.  
  
 Przykład kodu jest częścią większego przykładu, łącznie z danymi wyjściowymi dostarczonymi <xref:System.Collections.Generic.SortedList%602.System%23Collections%23IDictionary%23Add%2A> dla metody.  
  
 [!code-csharp[Generic.SortedList.IDictionary#31](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#31)]
 [!code-vb[Generic.SortedList.IDictionary#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#31)]  
[!code-csharp[Generic.SortedList.IDictionary#8](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#8)]
[!code-vb[Generic.SortedList.IDictionary#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#8)]  
[!code-csharp[Generic.SortedList.IDictionary#7](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#7)]
[!code-vb[Generic.SortedList.IDictionary#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#7)]  
[!code-csharp[Generic.SortedList.IDictionary#32](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList.IDictionary/CS/source.cs#32)]
[!code-vb[Generic.SortedList.IDictionary#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList.IDictionary/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="P:System.Collections.Generic.SortedList`2.Keys" />
        <altmember cref="P:System.Collections.Generic.SortedList`2.Values" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca moduł wyliczający, który dokonuje iteracji w kolekcji.</summary>
        <returns><see cref="T:System.Collections.IEnumerator" /> , Który może być używany do iteracji kolekcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `foreach` Instrukcja C# języka(`for each` C++w VisualBasic)ukrywazłożonośćmodułówwyliczających.`For Each`  W związku z `foreach` tym zaleca się użycie zamiast bezpośredniego manipulowania modułem wyliczającym.  
  
 Moduły wyliczające mogą służyć do odczytu danych w kolekcji, ale nie można za ich pomocą modyfikować kolekcji źródłowej.  
  
 Początkowo moduł wyliczający jest umieszczony przed pierwszym elementem w kolekcji. <xref:System.Collections.IEnumerator.Reset%2A>przywraca również moduł wyliczający z powrotem do tego położenia.  W tym miejscu <xref:System.Collections.IEnumerator.Current%2A> nie jest zdefiniowane. W związku z tym przed <xref:System.Collections.IEnumerator.MoveNext%2A> przeczytaniem <xref:System.Collections.IEnumerator.Current%2A>wartości parametru należy wywołać metodę wyliczającą do pierwszego elementu kolekcji.  
  
 <xref:System.Collections.IEnumerator.Current%2A>zwraca ten sam obiekt do <xref:System.Collections.IEnumerator.MoveNext%2A> momentu <xref:System.Collections.IEnumerator.Reset%2A> wywołania metody lub. <xref:System.Collections.IEnumerator.MoveNext%2A>ustawia <xref:System.Collections.IEnumerator.Current%2A> do następnego elementu.  
  
 Jeśli <xref:System.Collections.IEnumerator.MoveNext%2A> przekazuje koniec kolekcji, moduł wyliczający jest umieszczony po ostatnim elemencie w kolekcji i <xref:System.Collections.IEnumerator.MoveNext%2A> zwraca `false`. Gdy moduł wyliczający znajduje się w tym miejscu, kolejne <xref:System.Collections.IEnumerator.MoveNext%2A> wywołania również `false`zwracają. Jeśli ostatnie wywołanie <xref:System.Collections.IEnumerator.MoveNext%2A> zwrócone `false`, <xref:System.Collections.IEnumerator.Current%2A> nie jest zdefiniowane. Aby ponownie <xref:System.Collections.IEnumerator.Current%2A> ustawić na pierwszy element kolekcji, możesz wywołać metodę <xref:System.Collections.IEnumerator.Reset%2A> i <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Moduł wyliczający zachowuje ważność tak długo, jak długo kolekcja pozostaje niezmieniona. Jeśli w kolekcji zostaną wprowadzone zmiany, takie jak dodanie, zmodyfikowanie lub usunięcie elementów, moduł wyliczający jest nieodwracalnie unieważniony i następne wywołanie <xref:System.Collections.IEnumerator.MoveNext%2A> lub <xref:System.Collections.IEnumerator.Reset%2A> wygeneruje <xref:System.InvalidOperationException>.  
  
 Moduł wyliczający nie ma wyłącznego dostępu do kolekcji, w związku z tym wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość.  Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania.  Aby zezwolić wielu wątkom na dostęp do kolekcji w celu odczytu i zapisu danych, należy zaimplementować własny mechanizm synchronizacji.  
  
 Implementacje domyślne kolekcji w <xref:System.Collections.Generic?displayProperty=nameWithType> programie nie są zsynchronizowane.  
  
 Ta metoda jest operacją O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.SortedList`2.GetEnumerator" />
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="TrimExcess">
      <MemberSignature Language="C#" Value="public void TrimExcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TrimExcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.TrimExcess" />
      <MemberSignature Language="VB.NET" Value="Public Sub TrimExcess ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TrimExcess();" />
      <MemberSignature Language="F#" Value="member this.TrimExcess : unit -&gt; unit" Usage="sortedList.TrimExcess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ustawia pojemność na rzeczywistą liczbę elementów w <see cref="T:System.Collections.Generic.SortedList`2" />, jeśli ta liczba jest mniejsza niż 90% bieżącej pojemności.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tej metody można użyć do zminimalizowania obciążenia pamięci kolekcji, jeśli do kolekcji nie zostaną dodane żadne nowe elementy. Koszt ponownej alokacji i kopiowania dużego <xref:System.Collections.Generic.SortedList%602> może być istotny, <xref:System.Collections.Generic.SortedList%602.TrimExcess%2A> Dlatego metoda nie robi nic, jeśli lista ma więcej niż 90% pojemności. Pozwala to uniknąć ponoszenia dużego kosztu ponownego alokacji dla stosunkowo małego wzmocnienia.  
  
 Ta metoda jest operacją o`n`(), gdzie `n` is <xref:System.Collections.Generic.SortedList%602.Count%2A>.  
  
 Aby zresetować <xref:System.Collections.Generic.SortedList%602> do stanu początkowego, należy <xref:System.Collections.Generic.SortedList%602.Clear%2A> wywołać metodę przed wywołaniem <xref:System.Collections.Generic.SortedList%602.TrimExcess%2A> metody. Przycinanie pustego <xref:System.Collections.Generic.SortedList%602> zestawu ustawia pojemność <xref:System.Collections.Generic.SortedList%602> do pojemności domyślnej.  
  
 Wydajność można również ustawić przy użyciu <xref:System.Collections.Generic.SortedList%602.Capacity%2A> właściwości.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.SortedList`2.Clear" />
        <altmember cref="P:System.Collections.Generic.SortedList`2.Capacity" />
        <altmember cref="P:System.Collections.Generic.SortedList`2.Count" />
      </Docs>
    </Member>
    <Member MemberName="TryGetValue">
      <MemberSignature Language="C#" Value="public bool TryGetValue (TKey key, out TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryGetValue(!TKey key, [out] !TValue&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedList`2.TryGetValue(`0,`1@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetValue (key As TKey, ByRef value As TValue) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryGetValue(TKey key, [Runtime::InteropServices::Out] TValue % value);" />
      <MemberSignature Language="F#" Value="abstract member TryGetValue : 'Key *  -&gt; bool&#xA;override this.TryGetValue : 'Key *  -&gt; bool" Usage="sortedList.TryGetValue (key, value)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.TryGetValue(`0,`1@)</InterfaceMember>
        <InterfaceMember>M:System.Collections.Generic.IReadOnlyDictionary`2.TryGetValue(`0,`1@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" RefType="out" />
      </Parameters>
      <Docs>
        <param name="key">Klucz, którego wartość ma zostać pobrana.</param>
        <param name="value">Gdy ta metoda zwraca, wartość skojarzona z określonym kluczem, jeśli klucz zostanie znaleziony; w przeciwnym razie wartość domyślna dla typu <paramref name="value" /> parametru. Ten parametr jest przekazywany niezainicjowany.</param>
        <summary>Pobiera wartość skojarzoną z określonym kluczem.</summary>
        <returns><see langword="true" />Jeśli zawiera element z określonym kluczem; w przeciwnym razie, <see langword="false" />. <see cref="T:System.Collections.Generic.SortedList`2" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda łączy funkcjonalność <xref:System.Collections.Generic.SortedList%602.ContainsKey%2A> metody <xref:System.Collections.Generic.SortedList%602.Item%2A> i właściwości.  
  
 Jeśli klucz nie zostanie znaleziony `value` , parametr pobiera odpowiednią wartość domyślną dla typu `TValue`wartości, na przykład zero (0) dla typów całkowitych, `false` dla typów logicznych i `null` dla typów referencyjnych.  
  
 Ta metoda przeprowadza wyszukiwanie binarne; w związku z tym ta metoda jest operacją `n`o (log) `n` , <xref:System.Collections.Generic.SortedList%602.Count%2A>gdzie is.  
  
   
  
## Examples  
 W przykładzie pokazano, jak używać <xref:System.Collections.Generic.SortedList%602.TryGetValue%2A> metody jako wydajniejszego sposobu pobierania wartości w programie, który często próbuje klucze, które nie znajdują się na sortowanej liście. Z kolei przykład pokazuje również, jak <xref:System.Collections.Generic.SortedList%602.Item%2A> Właściwość (indeksator w C#) zgłasza wyjątki podczas próby pobrania nieistniejących kluczy.  
  
 Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.Collections.Generic.SortedList%602> klasy.  
  
 [!code-cpp[Generic.SortedList#5](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#5)]
 [!code-csharp[Generic.SortedList#5](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#5)]
 [!code-vb[Generic.SortedList#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#5)]  
[!code-cpp[Generic.SortedList#4](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#4)]
[!code-csharp[Generic.SortedList#4](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#4)]
[!code-vb[Generic.SortedList#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" />jest <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.SortedList`2.ContainsKey(`0)" />
        <altmember cref="P:System.Collections.Generic.SortedList`2.Item(`0)" />
        <altmember cref="M:System.Collections.Generic.SortedList`2.ContainsValue(`1)" />
        <altmember cref="M:System.Collections.Generic.SortedList`2.IndexOfValue(`1)" />
      </Docs>
    </Member>
    <Member MemberName="Values">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;TValue&gt; Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;!TValue&gt; Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedList`2.Values" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Values As IList(Of TValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;TValue&gt; ^ Values { System::Collections::Generic::IList&lt;TValue&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Values : System.Collections.Generic.IList&lt;'Value&gt;" Usage="System.Collections.Generic.SortedList&lt;'Key, 'Value&gt;.Values" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;TValue&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję zawierającą wartości <see cref="T:System.Collections.Generic.SortedList`2" />z.</summary>
        <value>A <see cref="T:System.Collections.Generic.IList`1" /> zawierający wartości <see cref="T:System.Collections.Generic.SortedList`2" />z.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kolejność wartości w <xref:System.Collections.Generic.IList%601> elemencie jest taka sama jak kolejność <xref:System.Collections.Generic.SortedList%602>w.  
  
 Zwracana <xref:System.Collections.Generic.IList%601> wartość nie jest kopią statyczną; zamiast tego <xref:System.Collections.Generic.IList%601> odwołuje się do wartości w oryginale <xref:System.Collections.Generic.SortedList%602>. W związku z tym zmiany <xref:System.Collections.Generic.SortedList%602> w dalszym ciągu zostaną odzwierciedlone w. <xref:System.Collections.Generic.IList%601>  
  
 Kolekcja zwrócona przez <xref:System.Collections.Generic.SortedList%602.Values%2A> Właściwość zapewnia efektywny sposób pobierania wartości według indeksu. Nie jest konieczne ponowne generowanie listy podczas uzyskiwania dostępu do właściwości, ponieważ lista jest tylko otoką dla wewnętrznej tablicy wartości. Poniższy kod przedstawia użycie <xref:System.Collections.Generic.SortedList%602.Values%2A> właściwości do indeksowanego pobierania wartości z posortowanej listy ciągów:  
  
 [!code-cpp[Generic.SortedList#11](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/remarks.cpp#11)]
 [!code-csharp[Generic.SortedList#11](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/remarks.cs#11)]
 [!code-vb[Generic.SortedList#11](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/remarks.vb#11)]  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
   
  
## Examples  
 Ten przykład kodu pokazuje, jak wyliczyć wartości z posortowanej listy przy <xref:System.Collections.Generic.SortedList%602.Values%2A> użyciu właściwości oraz jak wyliczyć klucze i wartości z listy posortowanej.  
  
 W przykładzie pokazano również, <xref:System.Collections.Generic.SortedList%602.Values%2A> jak używać właściwości do wydajnego indeksowanego pobierania wartości.  
  
 Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.Collections.Generic.SortedList%602> klasy.  
  
 [!code-cpp[Generic.SortedList#8](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#8)]
 [!code-csharp[Generic.SortedList#8](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#8)]
 [!code-vb[Generic.SortedList#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#8)]  
[!code-cpp[Generic.SortedList#7](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.SortedList/cpp/source.cpp#7)]
[!code-csharp[Generic.SortedList#7](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedList/CS/source.cs#7)]
[!code-vb[Generic.SortedList#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedList/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IList`1" />
        <altmember cref="P:System.Collections.Generic.SortedList`2.Keys" />
      </Docs>
    </Member>
  </Members>
</Type>

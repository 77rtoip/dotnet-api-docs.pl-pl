<Type Name="SortedDictionary&lt;TKey,TValue&gt;" FullName="System.Collections.Generic.SortedDictionary&lt;TKey,TValue&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="f20f7650e39f8565f4f0ddeade8f1a64c4f1f78c" /><Meta Name="ms.sourcegitcommit" Value="b0551d7828f015124aca601dbb64bd913cc5067d" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="12/13/2018" /><Meta Name="ms.locfileid" Value="53333342" /></Metadata><TypeSignature Language="C#" Value="public class SortedDictionary&lt;TKey,TValue&gt; : System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;, System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;, System.Collections.Generic.IReadOnlyCollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;, System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;, System.Collections.IDictionary" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit SortedDictionary`2&lt;TKey, TValue&gt; extends System.Object implements class System.Collections.Generic.ICollection`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt;, class System.Collections.Generic.IDictionary`2&lt;!TKey, !TValue&gt;, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt;, class System.Collections.Generic.IReadOnlyDictionary`2&lt;!TKey, !TValue&gt;, class System.Collections.ICollection, class System.Collections.IDictionary, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Generic.SortedDictionary`2" />
  <TypeSignature Language="VB.NET" Value="Public Class SortedDictionary(Of TKey, TValue)&#xA;Implements ICollection(Of KeyValuePair(Of TKey, TValue)), IDictionary, IDictionary(Of TKey, TValue), IEnumerable(Of KeyValuePair(Of TKey, TValue)), IReadOnlyCollection(Of KeyValuePair(Of TKey, TValue)), IReadOnlyDictionary(Of TKey, TValue)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TKey, typename TValue&gt;&#xA;public ref class SortedDictionary : System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;, System::Collections::Generic::IDictionary&lt;TKey, TValue&gt;, System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;, System::Collections::Generic::IReadOnlyCollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;, System::Collections::Generic::IReadOnlyDictionary&lt;TKey, TValue&gt;, System::Collections::IDictionary" />
  <TypeSignature Language="F#" Value="type SortedDictionary&lt;'Key, 'Value&gt; = class&#xA;    interface IDictionary&lt;'Key, 'Value&gt;&#xA;    interface IDictionary&#xA;    interface IReadOnlyDictionary&lt;'Key, 'Value&gt;&#xA;    interface ICollection&lt;KeyValuePair&lt;'Key, 'Value&gt;&gt;&#xA;    interface seq&lt;KeyValuePair&lt;'Key, 'Value&gt;&gt;&#xA;    interface IEnumerable&#xA;    interface ICollection&#xA;    interface IReadOnlyCollection&lt;KeyValuePair&lt;'Key, 'Value&gt;&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Collections</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TKey" />
    <TypeParameter Name="TValue" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IDictionary</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.System_DictionaryDebugView`2))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="TKey">Typ kluczy w słowniku.</typeparam>
    <typeparam name="TValue">Typ wartości w słowniku.</typeparam>
    <summary>Przedstawia kolekcję par klucz wartość, które są sortowane według klucza.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.SortedDictionary%602> Klasy generycznej jest drzewo binarnego wyszukiwania za pomocą pobierania O (log n), gdzie n to liczba elementów w słowniku. W tym zakresie, jest on podobny do <xref:System.Collections.Generic.SortedList%602> klasy ogólnej. Dwie klasy posiadają podobne modele obiektów i mają pobierania O (log n). Których różnią się dwie klasy jest wykorzystanie pamięci oraz szybkości wstawiania i usuwania:  
  
-   <xref:System.Collections.Generic.SortedList%602> wykorzystuje mniej pamięci niż <xref:System.Collections.Generic.SortedDictionary%602>.  
  
-   <xref:System.Collections.Generic.SortedDictionary%602> są szybsze operacje wstawiania i usuwania nieposortowane dane: O (log n), w przeciwieństwie do O(n) dla <xref:System.Collections.Generic.SortedList%602>.  
  
-   Jeśli lista jest wypełniana w całości z posortowane dane <xref:System.Collections.Generic.SortedList%602> jest szybsza niż <xref:System.Collections.Generic.SortedDictionary%602>.  
  
 Każda para klucza i wartości mogą być pobierane jako <xref:System.Collections.Generic.KeyValuePair%602> struktury, lub jako <xref:System.Collections.DictionaryEntry> za pośrednictwem nongeneric <xref:System.Collections.IDictionary> interfejsu.  
  
 Klucze muszą być niezmienne, tak długo, jak są używane jako klucze w <xref:System.Collections.Generic.SortedDictionary%602>. Każdy klucz w <xref:System.Collections.Generic.SortedDictionary%602> muszą być unikatowe. Klucz nie może być `null`, ale wartość może być, jeśli typ wartości `TValue` jest typem referencyjnym.  
  
 <xref:System.Collections.Generic.SortedDictionary%602> wymaga wykonania porównania do wykonania porównania klucza. Można określić implementację <xref:System.Collections.Generic.IComparer%601> ogólny interfejs za pomocą konstruktora, który akceptuje `comparer` parametru; Jeśli nie określisz implementacja genericcomparer — domyślne <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> jest używany. Jeśli typ `TKey` implementuje <xref:System.IComparable%601?displayProperty=nameWithType> ogólny interfejs, domyślny moduł porównujący wykorzystuje tę implementację.  
  
 `foreach` Instrukcja języka C# (`for each` w języku C++, `For Each` w języku Visual Basic) zwraca obiekt typu elementów w kolekcji. Ponieważ każdy element obiektu <xref:System.Collections.Generic.SortedDictionary%602> to para klucz/wartość typu elementu nie jest typ klucza lub typu wartości. Typ elementu to <xref:System.Collections.Generic.KeyValuePair%602>. Poniższy kod przedstawia składnię języka C#, C++ i Visual Basic.  
  
 [!code-cpp[Generic.Dictionary#11](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.Dictionary/cpp/source2.cpp#11)]
 [!code-csharp[Generic.Dictionary#11](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary/CS/source2.cs#11)]
 [!code-vb[Generic.Dictionary#11](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary/VB/source2.vb#11)]  
  
 `foreach` Instrukcja jest otokę moduł wyliczający, który pozwala tylko do odczytu z kolekcji, nie zapisywania.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy pustą <xref:System.Collections.Generic.SortedDictionary%602> ciągów za pomocą kluczy ciągu i używa <xref:System.Collections.Generic.SortedDictionary%602.Add%2A> metodę, aby dodać niektóre elementy. W przykładzie pokazano, że <xref:System.Collections.Generic.SortedDictionary%602.Add%2A> metoda zgłasza wyjątek <xref:System.ArgumentException> podczas próby dodania zduplikowany klucz.  
  
 W przykładzie użyto <xref:System.Collections.Generic.SortedDictionary%602.Item%2A> właściwości (indeksatora w języku C#) można pobrać wartości, demonstrując, <xref:System.Collections.Generic.KeyNotFoundException> jest zgłaszany, gdy żądana klucz jest nieobecny i mogą być zastępowane przedstawiający, że wartość skojarzoną z kluczem.  
  
 Przykład pokazuje, jak użyć metody <xref:System.Collections.Generic.SortedDictionary%602.TryGetValue%2A> jako bardziej efektywnego sposobu pobierania wartości, jeśli program często musi wypróbowywać kluczowe wartości, które nie znajdują się w słowniku, i pokazuje, jak użyć metody <xref:System.Collections.Generic.SortedDictionary%602.ContainsKey%2A>, aby sprawdzić, czy klucz istnieje przed wywołaniem <xref:System.Collections.Generic.SortedDictionary%602.Add%2A> metoda.  
  
 W przykładzie pokazano, jak wyliczyć kluczy i wartości w słowniku i jak można wyliczyć kluczy i wartości, samodzielnie przy użyciu <xref:System.Collections.Generic.SortedDictionary%602.Keys%2A> właściwości i <xref:System.Collections.Generic.SortedDictionary%602.Values%2A> właściwości.  
  
 Ponadto w przykładzie pokazano <xref:System.Collections.Generic.SortedDictionary%602.Remove%2A> metody.  
  
 [!code-csharp[Generic.SortedDictionary#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary/CS/source.cs#1)]
 [!code-vb[Generic.SortedDictionary#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Publiczne statyczne (<see langword="Shared" /> w języku Visual Basic) elementy członkowskie tego typu są bezpieczne dla wątków. Wystąpienia elementów członkowskich nie dają gwarancji bezpieczeństwa wątków.  
  
Element <see cref="T:System.Collections.Generic.SortedDictionary`2" /> może obsługiwać wielu elementów odczytujących współbieżnie, tak długo, jak długo Kolekcja nie jest modyfikowany.  Nawet w takim przypadku wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną.  Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania.  Aby zezwolić wielu wątkom na dostęp do kolekcji w celu odczytu i zapisu danych, należy zaimplementować własny mechanizm synchronizacji.</threadsafe>
    <altmember cref="T:System.Collections.SortedList" />
    <altmember cref="T:System.Collections.Generic.Dictionary`2" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Collections.Generic.SortedDictionary`2" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedDictionary ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedDictionary`2.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedDictionary();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Collections.Generic.SortedDictionary`2" /> klasy, która jest pusta i używa domyślnego <see cref="T:System.Collections.Generic.IComparer`1" /> implementacji typu klucza.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy klucz w <xref:System.Collections.Generic.SortedDictionary%602> muszą być unikatowe, zgodnie z domyślna funkcja porównująca.  
  
 <xref:System.Collections.Generic.SortedDictionary%602> wymaga wykonania porównania do wykonania porównania klucza. Ten konstruktor korzysta z domyślny moduł porównujący równość ogólny <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>. Jeśli typ `TKey` implementuje <xref:System.IComparable%601?displayProperty=nameWithType> ogólny interfejs, domyślny moduł porównujący wykorzystuje tę implementację. Alternatywnie, można określić implementację <xref:System.Collections.Generic.IComparer%601> ogólny interfejs za pomocą konstruktora, który akceptuje `comparer` parametru.  
  
 Ten konstruktor jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy pustą <xref:System.Collections.Generic.SortedDictionary%602> ciągów za pomocą kluczy ciągu i używa <xref:System.Collections.Generic.SortedDictionary%602.Add%2A> metodę, aby dodać niektóre elementy. W przykładzie pokazano, że <xref:System.Collections.Generic.SortedDictionary%602.Add%2A> metoda zgłasza wyjątek <xref:System.ArgumentException> podczas próby dodania zduplikowany klucz.  
  
 Ten przykład kodu jest częścią większego przykładu przewidzianego dla <xref:System.Collections.Generic.SortedDictionary%602> klasy.  
  
 [!code-csharp[Generic.SortedDictionary#2](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary/CS/source.cs#2)]
 [!code-vb[Generic.SortedDictionary#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Generic.Comparer`1.Default" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="T:System.IComparable" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedDictionary (System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IComparer`1&lt;!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedDictionary`2.#ctor(System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (comparer As IComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedDictionary(System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.SortedDictionary&lt;'Key, 'Value&gt; : System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; System.Collections.Generic.SortedDictionary&lt;'Key, 'Value&gt;" Usage="new System.Collections.Generic.SortedDictionary&lt;'Key, 'Value&gt; comparer" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <param name="comparer"><see cref="T:System.Collections.Generic.IComparer`1" /> Wdrożenia do użycia podczas porównywania kluczy lub <see langword="null" /> użyta domyślna <see cref="T:System.Collections.Generic.Comparer`1" /> dla typu klucza.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Collections.Generic.SortedDictionary`2" /> klasy, która jest pusta i używa określonego <see cref="T:System.Collections.Generic.IComparer`1" /> implementacji do porównywania kluczy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy klucz w <xref:System.Collections.Generic.SortedDictionary%602> muszą być unikatowe, zgodnie z określona funkcja porównująca.  
  
 <xref:System.Collections.Generic.SortedDictionary%602> wymaga wykonania porównania do wykonania porównania klucza. Jeśli `comparer` jest `null`, domyślny moduł porównujący równość ogólny, korzysta z tego konstruktora <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>. Jeśli typ `TKey` implementuje <xref:System.IComparable%601?displayProperty=nameWithType> ogólny interfejs, domyślny moduł porównujący wykorzystuje tę implementację.  
  
 Ten konstruktor jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy <xref:System.Collections.Generic.SortedDictionary%602> z funkcję porównującą bez uwzględniania wielkości liter dla bieżącej kultury. W przykładzie dodano czterech elementów: niektóre z kluczami małe i niektóre z kluczami wielkie litery. Przykład, a następnie próbuje dodać element z kluczem, który różni się od istniejącego klucza tylko wielkością liter, przechwytuje wyjątek wynikowy i wyświetla komunikat o błędzie. Ponadto w przykładzie są wyświetlane elementy w kolejności sortowania bez uwzględniania wielkości liter.  
  
 [!code-csharp[Generic.SortedDictionary.ctor_IComp#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.ctor_IComp/CS/source.cs#1)]
 [!code-vb[Generic.SortedDictionary.ctor_IComp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.ctor_IComp/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="P:System.Collections.Generic.Comparer`1.Default" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="T:System.IComparable" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedDictionary (System.Collections.Generic.IDictionary&lt;TKey,TValue&gt; dictionary);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IDictionary`2&lt;!TKey, !TValue&gt; dictionary) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedDictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dictionary As IDictionary(Of TKey, TValue))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedDictionary(System::Collections::Generic::IDictionary&lt;TKey, TValue&gt; ^ dictionary);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.SortedDictionary&lt;'Key, 'Value&gt; : System.Collections.Generic.IDictionary&lt;'Key, 'Value&gt; -&gt; System.Collections.Generic.SortedDictionary&lt;'Key, 'Value&gt;" Usage="new System.Collections.Generic.SortedDictionary&lt;'Key, 'Value&gt; dictionary" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="dictionary" Type="System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;" />
      </Parameters>
      <Docs>
        <param name="dictionary"><see cref="T:System.Collections.Generic.IDictionary`2" /> Której elementy są kopiowane do nowego <see cref="T:System.Collections.Generic.SortedDictionary`2" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Collections.Generic.SortedDictionary`2" /> klasy, która zawiera elementy kopiowane z określonego <see cref="T:System.Collections.Generic.IDictionary`2" /> i używa domyślnego <see cref="T:System.Collections.Generic.IComparer`1" /> implementacji typu klucza.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy klucz w <xref:System.Collections.Generic.SortedDictionary%602> muszą być unikatowe, zgodnie z domyślną modułu porównującego; w związku z tym, każdy klucz w źródle `dictionary` również musi być unikatowa, zgodnie z domyślna funkcja porównująca.  
  
 <xref:System.Collections.Generic.SortedDictionary%602> wymaga wykonania porównania do wykonania porównania klucza. Ten konstruktor korzysta z domyślny moduł porównujący równość ogólny, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>. Jeśli typ `TKey` implementuje <xref:System.IComparable%601?displayProperty=nameWithType> ogólny interfejs, domyślny moduł porównujący wykorzystuje tę implementację. Alternatywnie, można określić implementację <xref:System.Collections.Generic.IComparer%601> ogólny interfejs za pomocą konstruktora, który akceptuje `comparer` parametru.  
  
 Ten konstruktor jest O (`n` dziennika `n`) operacji, gdzie `n` jest liczba elementów w `dictionary`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób użycia <xref:System.Collections.Generic.SortedDictionary%602> do utworzenia kopii posortowany informacji w <xref:System.Collections.Generic.Dictionary%602>, przekazując <xref:System.Collections.Generic.Dictionary%602> do <xref:System.Collections.Generic.SortedDictionary%602.%23ctor%28System.Collections.Generic.IComparer%7B%600%7D%29> konstruktora.  
  
 [!code-csharp[Generic.SortedDictionary.ctor_IDic#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.ctor_IDic/CS/source.cs#1)]
 [!code-vb[Generic.SortedDictionary.ctor_IDic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.ctor_IDic/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="dictionary" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="dictionary" /> zawiera co najmniej jeden zduplikowany klucz.</exception>
        <altmember cref="T:System.Collections.Generic.IDictionary`2" />
        <altmember cref="P:System.Collections.Generic.Comparer`1.Default" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="T:System.IComparable" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SortedDictionary (System.Collections.Generic.IDictionary&lt;TKey,TValue&gt; dictionary, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IDictionary`2&lt;!TKey, !TValue&gt; dictionary, class System.Collections.Generic.IComparer`1&lt;!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedDictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1},System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dictionary As IDictionary(Of TKey, TValue), comparer As IComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SortedDictionary(System::Collections::Generic::IDictionary&lt;TKey, TValue&gt; ^ dictionary, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.SortedDictionary&lt;'Key, 'Value&gt; : System.Collections.Generic.IDictionary&lt;'Key, 'Value&gt; * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; System.Collections.Generic.SortedDictionary&lt;'Key, 'Value&gt;" Usage="new System.Collections.Generic.SortedDictionary&lt;'Key, 'Value&gt; (dictionary, comparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dictionary" Type="System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <param name="dictionary"><see cref="T:System.Collections.Generic.IDictionary`2" /> Której elementy są kopiowane do nowego <see cref="T:System.Collections.Generic.SortedDictionary`2" />.</param>
        <param name="comparer"><see cref="T:System.Collections.Generic.IComparer`1" /> Wdrożenia do użycia podczas porównywania kluczy lub <see langword="null" /> użyta domyślna <see cref="T:System.Collections.Generic.Comparer`1" /> dla typu klucza.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Collections.Generic.SortedDictionary`2" /> klasy, która zawiera elementy kopiowane z określonego <see cref="T:System.Collections.Generic.IDictionary`2" /> i używa określonego <see cref="T:System.Collections.Generic.IComparer`1" /> implementacji do porównywania kluczy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy klucz w <xref:System.Collections.Generic.SortedDictionary%602> muszą być unikatowe, zgodnie z określonym moduł porównujący; w związku z tym, każdy klucz w źródle `dictionary` również musi być unikatowa, zgodnie z określona funkcja porównująca.  
  
 <xref:System.Collections.Generic.SortedDictionary%602> wymaga wykonania porównania do wykonania porównania klucza. Jeśli `comparer` jest `null`, domyślny moduł porównujący równość ogólny, korzysta z tego konstruktora <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>. Jeśli typ `TKey` implementuje <xref:System.IComparable%601?displayProperty=nameWithType> ogólny interfejs, domyślny moduł porównujący wykorzystuje tę implementację.  
  
 Ten konstruktor jest O (`n` dziennika `n`) operacji, gdzie `n` jest liczba elementów w `dictionary`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób użycia <xref:System.Collections.Generic.SortedDictionary%602> utworzyć bez uwzględniania wielkości liter sortowania kopiowania informacji z bez uwzględniania wielkości liter <xref:System.Collections.Generic.Dictionary%602>, przekazując <xref:System.Collections.Generic.Dictionary%602> do <xref:System.Collections.Generic.SortedDictionary%602.%23ctor%28System.Collections.Generic.IDictionary%7B%600%2C%601%7D%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> konstruktora. Porównywanie bez uwzględniania wielkości liter w tym przykładzie są przeznaczone dla bieżącej kultury.  
  
 [!code-csharp[Generic.SortedDictionary.ctor_IDicIComp#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.ctor_IDicIComp/CS/source.cs#1)]
 [!code-vb[Generic.SortedDictionary.ctor_IDicIComp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.ctor_IDicIComp/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="dictionary" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="dictionary" /> zawiera co najmniej jeden zduplikowany klucz.</exception>
        <altmember cref="T:System.Collections.Generic.IDictionary`2" />
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="P:System.Collections.Generic.Comparer`1.Default" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="T:System.IComparable" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (TKey key, TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(!TKey key, !TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedDictionary`2.Add(`0,`1)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (key As TKey, value As TValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(TKey key, TValue value);" />
      <MemberSignature Language="F#" Value="abstract member Add : 'Key * 'Value -&gt; unit&#xA;override this.Add : 'Key * 'Value -&gt; unit" Usage="sortedDictionary.Add (key, value)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.Add(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="key">Klucz elementu do dodania.</param>
        <param name="value">Wartość elementu do dodania. Wartość może być <see langword="null" /> dla typów odwołań.</param>
        <summary>Dodaje element z określonym kluczem i określoną wartością do <see cref="T:System.Collections.Generic.SortedDictionary`2" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można również użyć <xref:System.Collections.Generic.SortedDictionary%602.Item%2A> właściwości, aby dodać nowe elementy, ustawiając wartość klucza, który nie istnieje w <xref:System.Collections.Generic.SortedDictionary%602>, na przykład `myCollection["myNonexistentKey"] = myValue` (w języku Visual Basic `myCollection("myNonexistantKey") = myValue`). Jednakże jeśli określony klucz już istnieje w <xref:System.Collections.Generic.SortedDictionary%602>, ustawiając <xref:System.Collections.Generic.SortedDictionary%602.Item%2A> właściwość zastępuje starą wartość. Z kolei <xref:System.Collections.Generic.SortedDictionary%602.Add%2A> metoda zgłasza wyjątek, jeśli element z określonym kluczem już istnieje.  
  
 Klucz nie może być `null`, ale wartość może być, jeśli typ wartości `TValue` jest typem referencyjnym.  
  
 Ta metoda jest O (log `n`) operacji, gdzie `n` jest <xref:System.Collections.Generic.SortedDictionary%602.Count%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy pustą <xref:System.Collections.Generic.SortedDictionary%602> ciągów za pomocą kluczy ciągu i używa <xref:System.Collections.Generic.SortedDictionary%602.Add%2A> metodę, aby dodać niektóre elementy. W przykładzie pokazano, że <xref:System.Collections.Generic.SortedDictionary%602.Add%2A> metoda zgłasza wyjątek <xref:System.ArgumentException> podczas próby dodania zduplikowany klucz.  
  
 Ten przykład kodu jest częścią większego przykładu przewidzianego dla <xref:System.Collections.Generic.SortedDictionary%602> klasy.  
  
 [!code-csharp[Generic.SortedDictionary#2](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary/CS/source.cs#2)]
 [!code-vb[Generic.SortedDictionary#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Element o takim samym kluczem już istnieje w <see cref="T:System.Collections.Generic.SortedDictionary`2" />.</exception>
        <altmember cref="M:System.Collections.Generic.SortedDictionary`2.Remove(`0)" />
        <altmember cref="P:System.Collections.Generic.SortedDictionary`2.Item(`0)" />
        <altmember cref="M:System.Collections.Generic.IDictionary`2.Add(`0,`1)" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedDictionary`2.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="sortedDictionary.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Clear</InterfaceMember>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa wszystkie elementy z <see cref="T:System.Collections.Generic.SortedDictionary`2" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.SortedDictionary%602.Count%2A> Właściwość jest ustawiona na 0, a ponadto są również zwalniane odwołania do innych obiektów z elementów kolekcji.  
  
 Ta metoda jest operacją O(1), po prostu wydaniu głównego struktur danych wewnętrznych do wyrzucania elementów bezużytecznych.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Comparer">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IComparer&lt;TKey&gt; Comparer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IComparer`1&lt;!TKey&gt; Comparer" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedDictionary`2.Comparer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Comparer As IComparer(Of TKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IComparer&lt;TKey&gt; ^ Comparer { System::Collections::Generic::IComparer&lt;TKey&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Comparer : System.Collections.Generic.IComparer&lt;'Key&gt;" Usage="System.Collections.Generic.SortedDictionary&lt;'Key, 'Value&gt;.Comparer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IComparer&lt;TKey&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Collections.Generic.IComparer`1" /> porządkowania elementów <see cref="T:System.Collections.Generic.SortedDictionary`2" />.</summary>
        <value><see cref="T:System.Collections.Generic.IComparer`1" /> Porządkowania elementów <see cref="T:System.Collections.Generic.SortedDictionary`2" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.SortedDictionary%602> wymaga wykonania porównania do wykonania porównania klucza. Można określić implementację <xref:System.Collections.Generic.IComparer%601> ogólny interfejs za pomocą konstruktora, który akceptuje `comparer` parametru. W przeciwnym razie, domyślny moduł porównujący równość ogólny, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>, jest używany. Jeśli typ `TKey` implementuje <xref:System.IComparable%601?displayProperty=nameWithType> ogólny interfejs, domyślny moduł porównujący wykorzystuje tę implementację.  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Collections.Generic.SortedDictionary`2.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="ContainsKey">
      <MemberSignature Language="C#" Value="public bool ContainsKey (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ContainsKey(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedDictionary`2.ContainsKey(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContainsKey (key As TKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ContainsKey(TKey key);" />
      <MemberSignature Language="F#" Value="abstract member ContainsKey : 'Key -&gt; bool&#xA;override this.ContainsKey : 'Key -&gt; bool" Usage="sortedDictionary.ContainsKey key" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.ContainsKey(`0)</InterfaceMember>
        <InterfaceMember>M:System.Collections.Generic.IReadOnlyDictionary`2.ContainsKey(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Klucz do zlokalizowania w <see cref="T:System.Collections.Generic.SortedDictionary`2" />.</param>
        <summary>Określa, czy <see cref="T:System.Collections.Generic.SortedDictionary`2" /> zawiera element z określonym kluczem.</summary>
        <returns><see langword="true" /> Jeśli <see cref="T:System.Collections.Generic.SortedDictionary`2" /> zawiera element z określonym kluczem, a w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest O (log `n`) operacji.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób użycia <xref:System.Collections.Generic.SortedDictionary%602.ContainsKey%2A> metodę, aby sprawdzić, czy klucz istnieje przed wywołaniem <xref:System.Collections.Generic.SortedDictionary%602.Add%2A> metody. Prezentuje sposób użycia <xref:System.Collections.Generic.SortedDictionary%602.TryGetValue%2A> metody do pobierania wartości, która jest wydajny sposób, aby pobrać wartości, gdy program próbuje często klucze, które nie znajdują się w słowniku. Na koniec pokazuje najmniej efektywny sposób, aby sprawdzić czy klucze, istnieją przy użyciu <xref:System.Collections.Generic.SortedDictionary%602.Item%2A> właściwości (indeksatora w języku C#).  
  
 Ten przykład kodu jest częścią większego przykładu przewidzianego dla <xref:System.Collections.Generic.SortedDictionary%602> klasy.  
  
 [!code-csharp[Generic.SortedDictionary#6](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary/CS/source.cs#6)]
 [!code-vb[Generic.SortedDictionary#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary/VB/source.vb#6)]  
[!code-csharp[Generic.SortedDictionary#5](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary/CS/source.cs#5)]
[!code-vb[Generic.SortedDictionary#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary/VB/source.vb#5)]  
[!code-csharp[Generic.SortedDictionary#4](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary/CS/source.cs#4)]
[!code-vb[Generic.SortedDictionary#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.SortedDictionary`2.ContainsValue(`1)" />
      </Docs>
    </Member>
    <Member MemberName="ContainsValue">
      <MemberSignature Language="C#" Value="public bool ContainsValue (TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ContainsValue(!TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedDictionary`2.ContainsValue(`1)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContainsValue (value As TValue) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ContainsValue(TValue value);" />
      <MemberSignature Language="F#" Value="member this.ContainsValue : 'Value -&gt; bool" Usage="sortedDictionary.ContainsValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="value">Wartość do zlokalizowania w <see cref="T:System.Collections.Generic.SortedDictionary`2" />. Wartość może być <see langword="null" /> dla typów odwołań.</param>
        <summary>Określa, czy <see cref="T:System.Collections.Generic.SortedDictionary`2" /> zawiera element z określoną wartością.</summary>
        <returns><see langword="true" /> Jeśli <see cref="T:System.Collections.Generic.SortedDictionary`2" /> zawiera element z określoną wartością; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda określa równość za pomocą domyślny moduł porównujący równość <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> dla typu wartości `TValue`.  
  
 Ta metoda przeprowadza wyszukiwanie liniowe; w związku z tym, Średni czas wykonywania jest proporcjonalna do <xref:System.Collections.Generic.SortedDictionary%602.Count%2A> właściwości. Ta metoda jest O (`n`) operacji, gdzie `n` jest <xref:System.Collections.Generic.SortedDictionary%602.Count%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.SortedDictionary`2.ContainsKey(`0)" />
        <altmember cref="P:System.Collections.Generic.EqualityComparer`1.Default" />
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;[] array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;[] array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedDictionary`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As KeyValuePair(Of TKey, TValue)(), index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(cli::array &lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt; ^ array, int index);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : System.Collections.Generic.KeyValuePair&lt;'Key, 'Value&gt;[] * int -&gt; unit&#xA;override this.CopyTo : System.Collections.Generic.KeyValuePair&lt;'Key, 'Value&gt;[] * int -&gt; unit" Usage="sortedDictionary.CopyTo (array, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;[]" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Jednowymiarowa tablica <see cref="T:System.Collections.Generic.KeyValuePair`2" /> struktur, które jest lokalizacją docelową elementów skopiowane z bieżącej <see cref="T:System.Collections.Generic.SortedDictionary`2" /> tablicy musi mieć Indeksowanie oparte na zerze.</param>
        <param name="index">Liczony od zera indeks w <paramref name="array" /> od rozpoczyna się kopiowanie które.</param>
        <summary>Kopiuje elementy ze <see cref="T:System.Collections.Generic.SortedDictionary`2" /> do określonej tablicy <see cref="T:System.Collections.Generic.KeyValuePair`2" /> struktur, rozpoczynając od określonego indeksu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Jeśli typ źródła <xref:System.Collections.Generic.SortedDictionary%602> nie można automatycznie rzutować na typ docelowy `array`, nierodzajowymi implementacje <xref:System.Collections.ICollection.CopyTo%2A?displayProperty=nameWithType> throw <xref:System.InvalidCastException>, podczas gdy throw ogólnego implementacje <xref:System.ArgumentException>.  
  
 Ta metoda jest O (`n`) operacji, gdzie `n` jest <xref:System.Collections.Generic.SortedDictionary%602.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> jest mniejsza niż 0.</exception>
        <exception cref="T:System.ArgumentException">Liczba elementów w źródle <see cref="T:System.Collections.Generic.SortedDictionary`2" /> jest większa niż dostępna ilość miejsca od <paramref name="index" /> do końca tablicy docelowej <paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedDictionary`2.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.Generic.SortedDictionary&lt;'Key, 'Value&gt;.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyCollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę par klucz/wartość zawartych w <see cref="T:System.Collections.Generic.SortedDictionary`2" />.</summary>
        <value>Liczba par klucz/wartość zawartych w <see cref="T:System.Collections.Generic.SortedDictionary`2" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.SortedDictionary&lt;TKey,TValue&gt;.Enumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Collections.Generic.SortedDictionary`2/Enumerator&lt;!TKey, !TValue&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedDictionary`2.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As SortedDictionary(Of TKey, TValue).Enumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::SortedDictionary&lt;TKey, TValue&gt;::Enumerator GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; System.Collections.Generic.SortedDictionary&lt;'Key, 'Value&gt;.Enumerator" Usage="sortedDictionary.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.SortedDictionary&lt;TKey,TValue&gt;+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca moduł wyliczający, który iteruje po <see cref="T:System.Collections.Generic.SortedDictionary`2" />.</summary>
        <returns>A <see cref="T:System.Collections.Generic.SortedDictionary`2.Enumerator" /> dla <see cref="T:System.Collections.Generic.SortedDictionary`2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W celu wyliczenia, każdy element jest <xref:System.Collections.Generic.KeyValuePair%602> struktury reprezentujący wartość i klucza.  
  
 `foreach` Instrukcja języka C# (`for each` w języku C++, `For Each` w języku Visual Basic) powoduje ukrycie złożoności modułów wyliczających. W związku z tym, za pomocą `foreach` jest to zalecane, zamiast bezpośredniego wykonywania operacji modułu wyliczającego.  
  
 Moduły wyliczające mogą służyć do odczytu danych w kolekcji, ale nie można za ich pomocą modyfikować kolekcji źródłowej.  
  
 Słownik jest zachowywana w kolejności posortowanej przy użyciu drzewo wewnętrznych. Każdy nowy element znajduje się w położeniu poprawne sortowanie i drzewa jest dostosowywana do utrzymania porządku sortowania, zawsze wtedy, gdy element zostanie usunięty. Podczas wyliczania, kolejność sortowania jest zachowywana.  
  
 Początkowo moduł wyliczający jest umieszczony przed pierwszym elementem w kolekcji. W tym miejscu <xref:System.Collections.Generic.SortedDictionary%602.Enumerator.Current%2A> właściwość jest niezdefiniowana. W związku z tym, należy wywołać <xref:System.Collections.Generic.SortedDictionary%602.Enumerator.MoveNext%2A> metody wyprzedzeniem modułu wyliczającego do pierwszego elementu kolekcji przed odczytaniem wartości właściwości <xref:System.Collections.Generic.SortedDictionary%602.Enumerator.Current%2A>.  
  
 <xref:System.Collections.Generic.SortedDictionary%602.Enumerator.Current%2A> Właściwość zwraca ten sam element do momentu <xref:System.Collections.Generic.SortedDictionary%602.Enumerator.MoveNext%2A> metoda jest wywoływana. <xref:System.Collections.Generic.SortedDictionary%602.Enumerator.MoveNext%2A> Ustawia <xref:System.Collections.Generic.SortedDictionary%602.Enumerator.Current%2A> do następnego elementu.  
  
 Jeśli <xref:System.Collections.Generic.SortedDictionary%602.Enumerator.MoveNext%2A> przebiegów koniec kolekcji, moduł wyliczający jest umieszczany za ostatnim elementem w kolekcji i <xref:System.Collections.Generic.SortedDictionary%602.Enumerator.MoveNext%2A> zwraca `false`. Gdy moduł wyliczający jest w tym miejscu, kolejne wywołania <xref:System.Collections.Generic.SortedDictionary%602.Enumerator.MoveNext%2A> również zwracać `false`. Jeśli ostatnie wywołanie <xref:System.Collections.Generic.SortedDictionary%602.Enumerator.MoveNext%2A> zwrócił `false`, <xref:System.Collections.Generic.SortedDictionary%602.Enumerator.Current%2A> jest niezdefiniowana. Nie można ustawić <xref:System.Collections.Generic.SortedDictionary%602.Enumerator.Current%2A> do pierwszego elementu w kolekcji; należy utworzyć nowe wystąpienie modułu wyliczającego zamiast tego.  
  
 Moduł wyliczający zachowuje ważność tak długo, jak długo kolekcja pozostaje niezmieniona. Jeśli zmiany zostały wprowadzone do kolekcji, takie jak dodawanie, modyfikowanie lub usuwanie elementów, moduł wyliczający jest nieodwracalnie unieważnione, a następne wywołanie <xref:System.Collections.Generic.SortedDictionary%602.Enumerator.MoveNext%2A> lub <xref:System.Collections.Generic.SortedDictionary%602.Enumerator.System%23Collections%23IEnumerator%23Reset%2A> zgłasza <xref:System.InvalidOperationException>.  
  
 Moduł wyliczający nie ma wyłącznego dostępu do kolekcji, w związku z tym wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość. Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania.  Aby zezwolić wielu wątkom na dostęp do kolekcji w celu odczytu i zapisu danych, należy zaimplementować własny mechanizm synchronizacji.  
  
 Domyślne implementacje kolekcji w <xref:System.Collections.Generic?displayProperty=nameWithType> przestrzeni nazw nie są zsynchronizowane.  
  
 Ta metoda jest operacją O (log n), gdzie n to liczba.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.SortedDictionary`2.Enumerator" />
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public TValue this[TKey key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !TValue Item(!TKey)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedDictionary`2.Item(`0)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Item(key As TKey) As TValue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TValue default[TKey] { TValue get(TKey key); void set(TKey key, TValue value); };" />
      <MemberSignature Language="F#" Value="member this.Item('Key) : 'Value with get, set" Usage="System.Collections.Generic.SortedDictionary&lt;'Key, 'Value&gt;.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IDictionary`2.Item(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Klucz wartości do pobrania lub ustawienia.</param>
        <summary>Pobiera lub ustawia wartość skojarzoną z określonym kluczem.</summary>
        <value>Wartość skojarzona z określonym kluczem. Jeśli określony klucz nie zostanie znaleziony, operacja get zgłasza <see cref="T:System.Collections.Generic.KeyNotFoundException" />, oraz operacji zestawu tworzy nowy element z określonym kluczem.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość umożliwia dostęp do określonego elementu w kolekcji przy użyciu następującej składni języka C#: `myCollection[key]` (`myCollection(key)` w języku Visual Basic).  
  
 Można również użyć <xref:System.Collections.Generic.SortedDictionary%602.Item%2A> właściwości, aby dodać nowe elementy, ustawiając wartość klucza, który nie istnieje w <xref:System.Collections.Generic.SortedDictionary%602>, na przykład `myCollection["myNonexistentKey"] = myValue`. Jednakże jeśli określony klucz już istnieje w <xref:System.Collections.Generic.SortedDictionary%602>, ustawiając <xref:System.Collections.Generic.SortedDictionary%602.Item%2A> właściwość zastępuje starą wartość. Z kolei <xref:System.Collections.Generic.SortedDictionary%602.Add%2A> metoda nie modyfikować istniejące elementy.  
  
 Klucz nie może być `null`, ale wartość może być, jeśli typ wartości `TValue` jest typem referencyjnym.  
  
 W języku C# używa słowa kluczowego w celu zdefiniowania indeksatorów, a nie Implementowanie <xref:System.Collections.Generic.SortedDictionary%602.Item%2A> właściwości. Implementuje języka Visual Basic <xref:System.Collections.Generic.SortedDictionary%602.Item%2A> jako właściwość domyślną, która zapewnia taką samą funkcjonalność indeksowania.  
  
 Pobieranie wartości tej właściwości jest O (dziennik `n`) operacji; ustawienie właściwości jest również O (dziennik `n`) operacji.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Collections.Generic.SortedDictionary%602.Item%2A> właściwości (indeksatora w języku C#) można pobrać wartości, demonstrując, <xref:System.Collections.Generic.KeyNotFoundException> jest zgłaszany, gdy żądana klucz jest nieobecny i mogą być zastępowane przedstawiający, że wartość skojarzoną z kluczem.  
  
 W przykładzie pokazano również sposób użycia <xref:System.Collections.Generic.SortedDictionary%602.TryGetValue%2A> metodę jako bardziej wydajny sposób, aby pobrać wartości, jeśli program często będą musieli spróbować wartości klucza, które nie znajdują się w słowniku.  
  
 Ten przykład kodu jest częścią większego przykładu przewidzianego dla <xref:System.Collections.Generic.SortedDictionary%602> klasy.  
  
 [!code-csharp[Generic.SortedDictionary#3](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary/CS/source.cs#3)]
 [!code-vb[Generic.SortedDictionary#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary/VB/source.vb#3)]  
[!code-csharp[Generic.SortedDictionary#4](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary/CS/source.cs#4)]
[!code-vb[Generic.SortedDictionary#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary/VB/source.vb#4)]  
[!code-csharp[Generic.SortedDictionary#5](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary/CS/source.cs#5)]
[!code-vb[Generic.SortedDictionary#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Collections.Generic.KeyNotFoundException">Właściwości są pobierane i <paramref name="key" /> nie istnieje w kolekcji.</exception>
        <altmember cref="M:System.Collections.Generic.SortedDictionary`2.Add(`0,`1)" />
      </Docs>
    </Member>
    <Member MemberName="Keys">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.SortedDictionary&lt;TKey,TValue&gt;.KeyCollection Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.SortedDictionary`2/KeyCollection&lt;!TKey, !TValue&gt; Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedDictionary`2.Keys" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Keys As SortedDictionary(Of TKey, TValue).KeyCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::SortedDictionary&lt;TKey, TValue&gt;::KeyCollection ^ Keys { System::Collections::Generic::SortedDictionary&lt;TKey, TValue&gt;::KeyCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Keys : System.Collections.Generic.SortedDictionary&lt;'Key, 'Value&gt;.KeyCollection" Usage="System.Collections.Generic.SortedDictionary&lt;'Key, 'Value&gt;.Keys" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.SortedDictionary&lt;TKey,TValue&gt;+KeyCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję zawierającą klucze ze słownika <see cref="T:System.Collections.Generic.SortedDictionary`2" />.</summary>
        <value>A <see cref="T:System.Collections.Generic.SortedDictionary`2.KeyCollection" /> zawierającą klucze ze słownika <see cref="T:System.Collections.Generic.SortedDictionary`2" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klucze ze słownika <xref:System.Collections.Generic.SortedDictionary%602.KeyCollection> są sortowane według <xref:System.Collections.Generic.SortedDictionary%602.Comparer%2A> właściwości i są w tej samej kolejności, jak skojarzone wartości w <xref:System.Collections.Generic.SortedDictionary%602.ValueCollection> zwrócone przez <xref:System.Collections.Generic.SortedDictionary%602.Values%2A> właściwości.  
  
 Zwrócony <xref:System.Collections.Generic.SortedDictionary%602.KeyCollection> nie jest statyczne kopia; zamiast tego <xref:System.Collections.Generic.SortedDictionary%602.KeyCollection> odwołuje się do kluczy w oryginalnym <xref:System.Collections.Generic.SortedDictionary%602>. W związku z tym, zmienia się na <xref:System.Collections.Generic.SortedDictionary%602> odzwierciedlenie w dalszym ciągu <xref:System.Collections.Generic.SortedDictionary%602.KeyCollection>.  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak wyliczyć kluczy w słowniku, używając <xref:System.Collections.Generic.SortedDictionary%602.Keys%2A> właściwość i jak wyliczyć kluczy i wartości w słowniku.  
  
 Ten kod jest częścią większego przykładu, który zostanie skompilowany i wykonany. Zobacz <xref:System.Collections.Generic.SortedDictionary%602>.  
  
 [!code-csharp[Generic.SortedDictionary#9](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary/CS/source.cs#9)]
 [!code-vb[Generic.SortedDictionary#9](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary/VB/source.vb#9)]  
[!code-csharp[Generic.SortedDictionary#7](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary/CS/source.cs#7)]
[!code-vb[Generic.SortedDictionary#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.SortedDictionary`2.KeyCollection" />
        <altmember cref="P:System.Collections.Generic.SortedDictionary`2.Values" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedDictionary`2.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (key As TKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Remove(TKey key);" />
      <MemberSignature Language="F#" Value="abstract member Remove : 'Key -&gt; bool&#xA;override this.Remove : 'Key -&gt; bool" Usage="sortedDictionary.Remove key" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Klucz elementu do usunięcia.</param>
        <summary>Usuwa element z określonym kluczem z <see cref="T:System.Collections.Generic.SortedDictionary`2" />.</summary>
        <returns><see langword="true" /> Jeśli element został pomyślnie usunięty; w przeciwnym razie <see langword="false" />.  Ta metoda zwraca też wartość <see langword="false" /> Jeśli <paramref name="key" /> nie zostanie znaleziony w <see cref="T:System.Collections.Generic.SortedDictionary`2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Collections.Generic.SortedDictionary%602> nie zawiera element z określonym kluczem <xref:System.Collections.Generic.SortedDictionary%602> pozostaje bez zmian. Jest zgłaszany żaden wyjątek.  
  
 Ta metoda jest O (log `n`) operacji.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak usunąć parę klucza i wartości w słowniku przy użyciu <xref:System.Collections.Generic.SortedDictionary%602.Remove%2A> metody.  
  
 Ten przykład kodu jest częścią większego przykładu przewidzianego dla <xref:System.Collections.Generic.SortedDictionary%602> klasy.  
  
 [!code-csharp[Generic.SortedDictionary#10](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary/CS/source.cs#10)]
 [!code-vb[Generic.SortedDictionary#10](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.SortedDictionary`2.Add(`0,`1)" />
        <altmember cref="M:System.Collections.Generic.IDictionary`2.Remove(`0)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Add">
      <MemberSignature Language="C#" Value="void ICollection&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.Add (System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt; keyValuePair);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Add(valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt; keyValuePair) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedDictionary`2.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#Add(System.Collections.Generic.KeyValuePair{`0,`1})" />
      <MemberSignature Language="VB.NET" Value="Sub Add (keyValuePair As KeyValuePair(Of TKey, TValue)) Implements ICollection(Of KeyValuePair(Of TKey, TValue)).Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Add(System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt; keyValuePair) = System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyValuePair" Type="System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;" />
      </Parameters>
      <Docs>
        <param name="keyValuePair"><see cref="T:System.Collections.Generic.KeyValuePair`2" /> Struktury, aby dodać do <see cref="T:System.Collections.Generic.ICollection`1" />.</param>
        <summary>Dodaje element do <see cref="T:System.Collections.Generic.ICollection`1" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keyValuePair" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Element o takim samym kluczem już istnieje w <see cref="T:System.Collections.Generic.SortedDictionary`2" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Contains">
      <MemberSignature Language="C#" Value="bool ICollection&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.Contains (System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt; keyValuePair);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Contains(valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt; keyValuePair) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedDictionary`2.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#Contains(System.Collections.Generic.KeyValuePair{`0,`1})" />
      <MemberSignature Language="VB.NET" Value="Function Contains (keyValuePair As KeyValuePair(Of TKey, TValue)) As Boolean Implements ICollection(Of KeyValuePair(Of TKey, TValue)).Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Contains(System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt; keyValuePair) = System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyValuePair" Type="System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;" />
      </Parameters>
      <Docs>
        <param name="keyValuePair"><see cref="T:System.Collections.Generic.KeyValuePair`2" /> Struktury do zlokalizowania w <see cref="T:System.Collections.Generic.ICollection`1" />.</param>
        <summary>Określa, czy <see cref="T:System.Collections.Generic.ICollection`1" /> zawiera określony klucz i wartość.</summary>
        <returns><see langword="true" /> Jeśli <paramref name="keyValuePair" /> znajduje się w <see cref="T:System.Collections.Generic.ICollection`1" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Wykonywanie niezależnych od kultury operacji na ciągach w kolekcjach</related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedDictionary`2.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements ICollection(Of KeyValuePair(Of TKey, TValue)).IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey,TValue&gt;&gt;::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Collections.Generic.ICollection`1" /> jest tylko do odczytu.</summary>
        <value><see langword="true" /> Jeśli <see cref="T:System.Collections.Generic.ICollection`1" /> jest tylko do odczytu; w przeciwnym razie <see langword="false" />. W implementacji domyślnej <see cref="T:System.Collections.Generic.SortedDictionary`2" />, właściwość ta zwraca zawsze <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Remove">
      <MemberSignature Language="C#" Value="bool ICollection&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.Remove (System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt; keyValuePair);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Remove(valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt; keyValuePair) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedDictionary`2.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#Remove(System.Collections.Generic.KeyValuePair{`0,`1})" />
      <MemberSignature Language="VB.NET" Value="Function Remove (keyValuePair As KeyValuePair(Of TKey, TValue)) As Boolean Implements ICollection(Of KeyValuePair(Of TKey, TValue)).Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Remove(System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt; keyValuePair) = System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyValuePair" Type="System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;" />
      </Parameters>
      <Docs>
        <param name="keyValuePair"><see cref="T:System.Collections.Generic.KeyValuePair`2" /> Struktury, aby usunąć z <see cref="T:System.Collections.Generic.ICollection`1" />.</param>
        <summary>Usuwa pierwsze wystąpienie określonego elementu z <see cref="T:System.Collections.Generic.ICollection`1" />.</summary>
        <returns><see langword="true" /> Jeśli <paramref name="keyValuePair" /> został pomyślnie usunięty ze <see cref="T:System.Collections.Generic.ICollection`1" />; w przeciwnym razie <see langword="false" />. Ta metoda zwraca też wartość <see langword="false" /> Jeśli <paramref name="keyValuePair" /> nie został znaleziony w <see cref="T:System.Collections.Generic.ICollection`1" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Keys">
      <MemberSignature Language="C#" Value="System.Collections.Generic.ICollection&lt;TKey&gt; System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;!TKey&gt; System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedDictionary`2.System#Collections#Generic#IDictionary&lt;TKey,TValue&gt;#Keys" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Keys As ICollection(Of TKey) Implements IDictionary(Of TKey, TValue).Keys" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::Generic::ICollection&lt;TKey&gt; ^ System::Collections::Generic::IDictionary&lt;TKey,TValue&gt;::Keys { System::Collections::Generic::ICollection&lt;TKey&gt; ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Keys" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IDictionary`2.Keys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;TKey&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Collections.Generic.ICollection`1" /> zawierający klucze <see cref="T:System.Collections.Generic.IDictionary`2" />.</summary>
        <value><see cref="T:System.Collections.Generic.ICollection`1" /> Zawierający klucze <see cref="T:System.Collections.Generic.IDictionary`2" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Values">
      <MemberSignature Language="C#" Value="System.Collections.Generic.ICollection&lt;TValue&gt; System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;!TValue&gt; System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedDictionary`2.System#Collections#Generic#IDictionary&lt;TKey,TValue&gt;#Values" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Values As ICollection(Of TValue) Implements IDictionary(Of TKey, TValue).Values" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::Generic::ICollection&lt;TValue&gt; ^ System::Collections::Generic::IDictionary&lt;TKey,TValue&gt;::Values { System::Collections::Generic::ICollection&lt;TValue&gt; ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Values" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IDictionary`2.Values</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;TValue&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Collections.Generic.ICollection`1" /> zawierające wartości w <see cref="T:System.Collections.Generic.IDictionary`2" />.</summary>
        <value><see cref="T:System.Collections.Generic.ICollection`1" /> Zawierające wartości w <see cref="T:System.Collections.Generic.IDictionary`2" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt; IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt; System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedDictionary`2.System#Collections#Generic#IEnumerable&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of KeyValuePair(Of TKey, TValue)) Implements IEnumerable(Of KeyValuePair(Of TKey, TValue)).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt; ^ System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca moduł wyliczający, który dokonuje iteracji w kolekcji.</summary>
        <returns>Moduł wyliczający, który może służyć do iterowania po kolekcji.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Keys">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;TKey&gt; System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;!TKey&gt; System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedDictionary`2.System#Collections#Generic#IReadOnlyDictionary&lt;TKey,TValue&gt;#Keys" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Keys As IEnumerable(Of TKey) Implements IReadOnlyDictionary(Of TKey, TValue).Keys" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::Generic::IEnumerable&lt;TKey&gt; ^ System::Collections::Generic::IReadOnlyDictionary&lt;TKey,TValue&gt;::Keys { System::Collections::Generic::IEnumerable&lt;TKey&gt; ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Keys" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyDictionary`2.Keys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TKey&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję zawierającą klucze ze słownika <see cref="T:System.Collections.Generic.SortedDictionary`2" />.</summary>
        <value>Kolekcja zawierająca klucze ze słownika <see cref="T:System.Collections.Generic.SortedDictionary`2" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Values">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;TValue&gt; System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;!TValue&gt; System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedDictionary`2.System#Collections#Generic#IReadOnlyDictionary&lt;TKey,TValue&gt;#Values" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Values As IEnumerable(Of TValue) Implements IReadOnlyDictionary(Of TKey, TValue).Values" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::Generic::IEnumerable&lt;TValue&gt; ^ System::Collections::Generic::IReadOnlyDictionary&lt;TKey,TValue&gt;::Values { System::Collections::Generic::IEnumerable&lt;TValue&gt; ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Values" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyDictionary`2.Values</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TValue&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję zawierającą wartości z <see cref="T:System.Collections.Generic.SortedDictionary`2" />.</summary>
        <value>Kolekcja zawierająca wartości w <see cref="T:System.Collections.Generic.SortedDictionary`2" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedDictionary`2.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int index) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Jednowymiarowa tablica, która jest lokalizacją docelową elementów kopiowanych z <see cref="T:System.Collections.Generic.ICollection`1" />. Tablica musi mieć indeksowane zaczynające od zera.</param>
        <param name="index">Liczony od zera indeks w <paramref name="array" /> od rozpoczyna się kopiowanie które.</param>
        <summary>Kopiuje elementy ze <see cref="T:System.Collections.Generic.ICollection`1" /> do tablicy, zaczynając od określonego indeksu tablicy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Jeśli typ źródła <xref:System.Collections.ICollection> nie można automatycznie rzutować na typ docelowy `array`, nierodzajowymi implementacje <xref:System.Collections.ICollection.CopyTo%2A?displayProperty=nameWithType> throw <xref:System.InvalidCastException>, podczas gdy throw ogólnego implementacje <xref:System.ArgumentException>.  
  
 Ta metoda jest O (`n`) operacji, gdzie `n` jest <xref:System.Collections.Generic.SortedDictionary%602.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> jest mniejsza niż 0.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="array" /> ma charakter wielowymiarowy.  
  
—lub— 
 <paramref name="array" /> nie ma indeksowania zaczynającego się od zera.  
  
—lub— 
Liczba elementów w źródle <see cref="T:System.Collections.Generic.ICollection`1" /> jest większa niż dostępna ilość miejsca od <paramref name="index" /> do końca tablicy docelowej <paramref name="array" />.  
  
—lub— 
Typ źródła <see cref="T:System.Collections.Generic.ICollection`1" /> nie można automatycznie rzutować na typ docelowy <paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedDictionary`2.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy dostęp do <see cref="T:System.Collections.ICollection" /> jest synchronizowane (wątkowo).</summary>
        <value><see langword="true" /> Jeśli dostęp do <see cref="T:System.Collections.ICollection" /> jest synchronizowane (wątkowo); w przeciwnym razie <see langword="false" />.  W implementacji domyślnej <see cref="T:System.Collections.Generic.SortedDictionary`2" />, właściwość ta zwraca zawsze <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślne implementacje kolekcji w <xref:System.Collections.Generic?displayProperty=nameWithType> przestrzeni nazw nie są zsynchronizowane.  
  
 Wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość. Nawet gdy kolekcja jest synchronizowana, inne wątki nadal mogą ją modyfikować kolekcji, co może powodować modułu wyliczającego do zgłoszenia wyjątku. Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania albo rejestrować wyjątki wynikłe ze zmian wprowadzanych przez inne wątków.  
  
 <xref:System.Collections.Generic.SortedDictionary%602.System%23Collections%23ICollection%23SyncRoot%2A> Właściwość zwraca obiekt, który może służyć do synchronizowania dostępu do <xref:System.Collections.ICollection>. Synchronizacja jest efektywne tylko wtedy, gdy wszystkie wątki zablokować obiektu przed uzyskaniem dostępu do kolekcji.  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedDictionary`2.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera obiekt, który może służyć do synchronizowania dostępu do <see cref="T:System.Collections.ICollection" />.</summary>
        <value>Obiekt, który może służyć do synchronizowania dostępu do <see cref="T:System.Collections.ICollection" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślne implementacje kolekcji w <xref:System.Collections.Generic?displayProperty=nameWithType> przestrzeni nazw nie są zsynchronizowane.  
  
 Wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość.  Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania.  Aby zezwolić wielu wątkom na dostęp do kolekcji w celu odczytu i zapisu danych, należy zaimplementować własny mechanizm synchronizacji.  
  
 <xref:System.Collections.Generic.SortedDictionary%602.System%23Collections%23ICollection%23SyncRoot%2A> Właściwość zwraca obiekt, który może służyć do synchronizowania dostępu do <xref:System.Collections.ICollection>. Synchronizacja jest efektywne tylko wtedy, gdy wszystkie wątki zablokować obiektu przed uzyskaniem dostępu do kolekcji. Poniższy kod przedstawia użycie <xref:System.Collections.ICollection.SyncRoot%2A> właściwość dla języka C#, C++ i Visual Basic.  
  
```csharp  
ICollection ic = ...;  
lock (ic.SyncRoot)   
{  
    // Access the collection.  
}  
```  
  
```vb  
Dim ic As ICollection = ...  
SyncLock ic.SyncRoot  
    ' Access the collection.  
End SyncLock  
```  
  
```cpp#  
ICollection^ ic = ...;  
try   
{  
    Monitor::Enter(ic->SyncRoot);  
    // Access the collection.  
}  
finally   
{  
    Monitor::Exit(ic->SyncRoot);  
}  
```  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Add">
      <MemberSignature Language="C#" Value="void IDictionary.Add (object key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IDictionary.Add(object key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedDictionary`2.System#Collections#IDictionary#Add(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Add (key As Object, value As Object) Implements IDictionary.Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IDictionary.Add(System::Object ^ key, System::Object ^ value) = System::Collections::IDictionary::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Add(System.Object,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Obiekt do użycia jako klucz elementu do dodania.</param>
        <param name="value">Obiekt do użycia jako wartość elementu do dodania.</param>
        <summary>Dodaje element z podany klucz i wartość do <see cref="T:System.Collections.IDictionary" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można również użyć <xref:System.Collections.IDictionary.Item%2A> właściwości, aby dodać nowe elementy, ustawiając wartość klucza, który nie istnieje w słowniku; na przykład `myCollection["myNonexistentKey"] = myValue`. Jednakże, jeśli określony klucz już istnieje w słowniku, ustawienie <xref:System.Collections.IDictionary.Item%2A> właściwość zastępuje starą wartość. Z kolei <xref:System.Collections.IDictionary.Add%2A> metoda nie modyfikować istniejące elementy.  
  
 Ta metoda jest O (log `n`) operacji, gdzie `n` jest <xref:System.Collections.Generic.SortedDictionary%602.Count%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak uzyskać dostęp do <xref:System.Collections.Generic.SortedDictionary%602> klasy za pomocą <xref:System.Collections.IDictionary?displayProperty=nameWithType> interfejsu. Przykład kodu tworzy pustą <xref:System.Collections.Generic.SortedDictionary%602> ciągów za pomocą kluczy ciągu i używa <xref:System.Collections.Generic.SortedDictionary%602.System%23Collections%23IDictionary%23Add%2A> metodę, aby dodać niektóre elementy. W przykładzie pokazano, że <xref:System.Collections.Generic.SortedDictionary%602.System%23Collections%23IDictionary%23Add%2A> metoda zgłasza wyjątek <xref:System.ArgumentException> podczas próby dodania zduplikowanego klucza lub klucza lub wartość nieprawidłowego typu danych.  
  
 Przykład kodu demonstruje użycie kilku innych elementów członkowskich <xref:System.Collections.IDictionary?displayProperty=nameWithType> interfejsu.  
  
 [!code-csharp[Generic.SortedDictionary.IDictionary#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/CS/source.cs#1)]
 [!code-vb[Generic.SortedDictionary.IDictionary#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="key" /> jest typu, który nie jest możliwy do przypisania do klucza typu <paramref name="TKey" /> z <see cref="T:System.Collections.IDictionary" />.  
  
—lub— 
 <paramref name="value" /> jest typu, który nie jest możliwy do przypisania do typu wartości <paramref name="TValue" /> z <see cref="T:System.Collections.IDictionary" />.  
  
—lub— 
Element o takim samym kluczem już istnieje w <see cref="T:System.Collections.IDictionary" />.</exception>
        <altmember cref="P:System.Collections.IDictionary.Item(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Contains">
      <MemberSignature Language="C#" Value="bool IDictionary.Contains (object key);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IDictionary.Contains(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedDictionary`2.System#Collections#IDictionary#Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Contains (key As Object) As Boolean Implements IDictionary.Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IDictionary.Contains(System::Object ^ key) = System::Collections::IDictionary::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Klucz do zlokalizowania w <see cref="T:System.Collections.IDictionary" />.</param>
        <summary>Określa, czy <see cref="T:System.Collections.IDictionary" /> zawiera element z określonym kluczem.</summary>
        <returns><see langword="true" /> Jeśli <see cref="T:System.Collections.IDictionary" /> zawiera element z określonym kluczem; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca `false` Jeśli `key` typu, który nie jest możliwy do przypisania do klucza typu `TKey` z <xref:System.Collections.Generic.SortedDictionary%602>.  
  
 Ta metoda jest O (log `n`) operacji, gdzie `n` jest <xref:System.Collections.Generic.SortedDictionary%602.Count%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób użycia <xref:System.Collections.Generic.SortedDictionary%602.System%23Collections%23IDictionary%23Contains%2A> metody <xref:System.Collections.IDictionary?displayProperty=nameWithType> współpracować z usługą <xref:System.Collections.Generic.SortedDictionary%602>. W przykładzie pokazano, że metoda zwraca `false` Jeśli podano klucz do nieprawidłowego typu danych.  
  
 Przykład kodu jest częścią większego przykładu, w tym dane wyjściowe, aby uzyskać <xref:System.Collections.Generic.SortedDictionary%602.System%23Collections%23IDictionary%23Add%2A> metody.  
  
 [!code-csharp[Generic.SortedDictionary.IDictionary#31](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/CS/source.cs#31)]
 [!code-vb[Generic.SortedDictionary.IDictionary#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/VB/source.vb#31)]  
[!code-csharp[Generic.SortedDictionary.IDictionary#6](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/CS/source.cs#6)]
[!code-vb[Generic.SortedDictionary.IDictionary#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/VB/source.vb#6)]  
[!code-csharp[Generic.SortedDictionary.IDictionary#32](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/CS/source.cs#32)]
[!code-vb[Generic.SortedDictionary.IDictionary#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IDictionaryEnumerator IDictionary.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedDictionary`2.System#Collections#IDictionary#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IDictionaryEnumerator Implements IDictionary.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IDictionaryEnumerator ^ System.Collections.IDictionary.GetEnumerator() = System::Collections::IDictionary::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionaryEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.Collections.IDictionaryEnumerator" /> dla <see cref="T:System.Collections.IDictionary" />.</summary>
        <returns><see cref="T:System.Collections.IDictionaryEnumerator" /> Dla <see cref="T:System.Collections.IDictionary" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W celu wyliczenia, każdy element jest <xref:System.Collections.DictionaryEntry> struktury.  
  
 `foreach` Instrukcja języka C# (`for each` w języku C++, `For Each` w języku Visual Basic) powoduje ukrycie złożoności modułów wyliczających. W związku z tym, za pomocą `foreach` jest to zalecane, zamiast bezpośredniego wykonywania operacji modułu wyliczającego.  
  
 Moduły wyliczające mogą służyć do odczytu danych w kolekcji, ale nie można za ich pomocą modyfikować kolekcji źródłowej.  
  
 Początkowo moduł wyliczający jest umieszczony przed pierwszym elementem w kolekcji. <xref:System.Collections.IEnumerator.Reset%2A> Metoda przełącza moduł wyliczający do tej pozycji.  W tym miejscu <xref:System.Collections.IDictionaryEnumerator.Entry%2A> jest niezdefiniowana. W związku z tym, należy wywołać <xref:System.Collections.IEnumerator.MoveNext%2A> metody wyprzedzeniem modułu wyliczającego do pierwszego elementu kolekcji przed odczytaniem wartości właściwości <xref:System.Collections.IDictionaryEnumerator.Entry%2A>.  
  
 <xref:System.Collections.IDictionaryEnumerator.Entry%2A> Właściwość zwraca ten sam obiekt, do momentu <xref:System.Collections.IEnumerator.MoveNext%2A> lub <xref:System.Collections.IEnumerator.Reset%2A> jest wywoływana. <xref:System.Collections.IEnumerator.MoveNext%2A> Ustawia <xref:System.Collections.IDictionaryEnumerator.Entry%2A> do następnego elementu.  
  
 Jeśli <xref:System.Collections.IEnumerator.MoveNext%2A> przebiegów koniec kolekcji, moduł wyliczający jest umieszczany za ostatnim elementem w kolekcji i <xref:System.Collections.IEnumerator.MoveNext%2A> zwraca `false`. Gdy moduł wyliczający jest w tym miejscu, kolejne wywołania <xref:System.Collections.IEnumerator.MoveNext%2A> również zwracać `false`. Jeśli ostatnie wywołanie <xref:System.Collections.IEnumerator.MoveNext%2A> zwrócił `false`, <xref:System.Collections.IDictionaryEnumerator.Entry%2A> jest niezdefiniowana. Aby ustawić <xref:System.Collections.IDictionaryEnumerator.Entry%2A> do pierwszego elementu w kolekcji ponownie wywołaj <xref:System.Collections.IEnumerator.Reset%2A> następuje <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Moduł wyliczający zachowuje ważność tak długo, jak długo kolekcja pozostaje niezmieniona. Jeśli zmiany zostały wprowadzone do kolekcji, takie jak dodawanie, modyfikowanie lub usuwanie elementów, moduł wyliczający jest nieodwracalnie unieważnione, a następne wywołanie <xref:System.Collections.IEnumerator.MoveNext%2A> lub <xref:System.Collections.IEnumerator.Reset%2A> zgłasza <xref:System.InvalidOperationException>.  
  
 Moduł wyliczający nie ma wyłącznego dostępu do kolekcji, w związku z tym wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość.  Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania.  Aby zezwolić wielu wątkom na dostęp do kolekcji w celu odczytu i zapisu danych, należy zaimplementować własny mechanizm synchronizacji.  
  
 Domyślne implementacje kolekcji w <xref:System.Collections.Generic?displayProperty=nameWithType> przestrzeni nazw nie są zsynchronizowane.  
  
 Ta metoda jest operacją O (log n), gdzie n to liczba elementów w kolekcji.
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak wyliczyć pary klucz/wartość ze słownika przy użyciu `foreach` — instrukcja (`For Each` w języku Visual Basic `for each` w języku C++), która ukrywa użycie modułu wyliczającego. W szczególności należy pamiętać, że moduł wyliczający <xref:System.Collections.IDictionary?displayProperty=nameWithType> interfejsu zwraca <xref:System.Collections.DictionaryEntry> obiektów zamiast <xref:System.Collections.Generic.KeyValuePair%602> obiektów.  
  
 Przykład kodu jest częścią większego przykładu, w tym dane wyjściowe, aby uzyskać <xref:System.Collections.Generic.SortedDictionary%602.System%23Collections%23IDictionary%23Add%2A> metody.  
  
 [!code-csharp[Generic.SortedDictionary.IDictionary#31](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/CS/source.cs#31)]
 [!code-vb[Generic.SortedDictionary.IDictionary#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/VB/source.vb#31)]  
[!code-csharp[Generic.SortedDictionary.IDictionary#7](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/CS/source.cs#7)]
[!code-vb[Generic.SortedDictionary.IDictionary#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/VB/source.vb#7)]  
[!code-csharp[Generic.SortedDictionary.IDictionary#32](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/CS/source.cs#32)]
[!code-vb[Generic.SortedDictionary.IDictionary#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IDictionaryEnumerator" />
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IDictionary.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IDictionary.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedDictionary`2.System#Collections#IDictionary#IsFixedSize" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFixedSize As Boolean Implements IDictionary.IsFixedSize" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IDictionary::IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IDictionary.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Collections.IDictionary" /> ma stały rozmiar.</summary>
        <value><see langword="true" /> Jeśli <see cref="T:System.Collections.IDictionary" /> ma stały rozmiar; w przeciwnym razie <see langword="false" />.  W implementacji domyślnej <see cref="T:System.Collections.Generic.SortedDictionary`2" />, właściwość ta zwraca zawsze <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W kolekcji o stałym rozmiarze po jej utworzeniu nie można dodawać ani usuwać elementów, jednak można modyfikować istniejące elementy.  
  
 Kolekcja o stałym rozmiarze jest po prostu zbiorem z otoką, który uniemożliwia Dodawanie i usuwanie elementów; w związku z tym jeśli zmiany zostały wprowadzone do podstawowej kolekcji, w tym dodawania lub usuwania elementów kolekcji o stałym rozmiarze uwzględni te zmiany.  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IDictionary.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IDictionary.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedDictionary`2.System#Collections#IDictionary#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements IDictionary.IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IDictionary::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IDictionary.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Collections.IDictionary" /> jest tylko do odczytu.</summary>
        <value><see langword="true" /> Jeśli <see cref="T:System.Collections.IDictionary" /> jest tylko do odczytu; w przeciwnym razie <see langword="false" />.  W implementacji domyślnej <see cref="T:System.Collections.Generic.SortedDictionary`2" />, właściwość ta zwraca zawsze <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W kolekcji tylko do odczytu po jej utworzeniu nie można dodawać, usuwać ani modyfikować elementów.  
  
 Kolekcja, która jest tylko do odczytu, jest po prostu zbiorem z otoką uniemożliwiającą zmianę kolekcji; w związku z tym, jeśli zmiany zostaną wprowadzone do podstawowej kolekcji, kolekcja tylko do odczytu uwzględni te zmiany.  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IDictionary.Item[object key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IDictionary.Item(object)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedDictionary`2.System#Collections#IDictionary#Item(System.Object)" />
      <MemberSignature Language="VB.NET" Value=" Property Item(key As Object) As Object Implements IDictionary.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::IDictionary::Item[System::Object ^] { System::Object ^ get(System::Object ^ key); void set(System::Object ^ key, System::Object ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IDictionary.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Item(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Klucz elementu do pobrania.</param>
        <summary>Pobiera lub ustawia element z określonym kluczem.</summary>
        <value>Element z określonym kluczem, lub <see langword="null" /> Jeśli <paramref name="key" /> nie znajduje się w słowniku lub <paramref name="key" /> typu, który nie jest możliwy do przypisania do klucza typu <paramref name="TKey" /> z <see cref="T:System.Collections.Generic.SortedDictionary`2" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość umożliwia dostęp do określonego elementu w kolekcji przy użyciu następującej składni języka C#: `myCollection[key]` (`myCollection(key)` w języku Visual Basic).  
  
 Można również użyć <xref:System.Collections.IDictionary.Item%2A> właściwości, aby dodać nowe elementy, ustawiając wartość klucza, który nie istnieje w słowniku; na przykład `myCollection["myNonexistentKey"] = myValue`. Jednakże, jeśli określony klucz już istnieje w słowniku, ustawienie <xref:System.Collections.IDictionary.Item%2A> właściwość zastępuje starą wartość. Z kolei <xref:System.Collections.Generic.SortedDictionary%602.System%23Collections%23IDictionary%23Add%2A> metoda nie modyfikować istniejące elementy.  
  
 Język C# używa [to](~/docs/csharp/language-reference/keywords/this.md) — słowo kluczowe, aby zdefiniować indeksatorów, a nie Implementowanie <xref:System.Collections.Generic.SortedDictionary%602.System%23Collections%23IDictionary%23Item%2A> właściwości. Implementuje języka Visual Basic <xref:System.Collections.Generic.SortedDictionary%602.System%23Collections%23IDictionary%23Item%2A> jako właściwość domyślną, która zapewnia taką samą funkcjonalność indeksowania.  
  
 Pobieranie wartości tej właściwości jest O (dziennik `n`) operacji; ustawienie właściwości jest również O (dziennik `n`) operacji.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób użycia <xref:System.Collections.Generic.SortedDictionary%602.System%23Collections%23IDictionary%23Item%2A> własności (indeksatora w języku C#) <xref:System.Collections.IDictionary?displayProperty=nameWithType> współpracować z usługą <xref:System.Collections.Generic.SortedDictionary%602>i sposoby właściwość różni się od <xref:System.Collections.Generic.SortedDictionary%602.Item%2A?displayProperty=nameWithType> właściwości.  
  
 W przykładzie pokazano, jak <xref:System.Collections.Generic.SortedDictionary%602.Item%2A?displayProperty=nameWithType> właściwości <xref:System.Collections.Generic.SortedDictionary%602.System%23Collections%23IDictionary%23Item%2A?displayProperty=nameWithType> właściwość można zmienić wartość skojarzoną z istniejącego klucza i może służyć do Dodaj nową parę klucz wartość, jeśli określony klucz nie znajduje się w słowniku. W przykładzie pokazano również, w odróżnieniu od <xref:System.Collections.Generic.SortedDictionary%602.Item%2A?displayProperty=nameWithType> właściwości <xref:System.Collections.Generic.SortedDictionary%602.System%23Collections%23IDictionary%23Item%2A?displayProperty=nameWithType> właściwości wyjątku, jeśli `key` nie w słowniku, zwraca odwołanie o wartości null zamiast tego. Ponadto w przykładzie pokazano, że wprowadzenie <xref:System.Collections.Generic.SortedDictionary%602.System%23Collections%23IDictionary%23Item%2A?displayProperty=nameWithType> właściwość zwraca odwołanie o wartości null, jeśli `key` nie jest poprawnym typie danych i ustawienie właściwości zgłasza wyjątek, jeśli `key` nie jest poprawnym typie danych.  
  
 Przykład kodu jest częścią większego przykładu, w tym dane wyjściowe, aby uzyskać <xref:System.Collections.Generic.SortedDictionary%602.System%23Collections%23IDictionary%23Add%2A> metody.  
  
 [!code-csharp[Generic.SortedDictionary.IDictionary#31](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/CS/source.cs#31)]
 [!code-vb[Generic.SortedDictionary.IDictionary#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/VB/source.vb#31)]  
[!code-csharp[Generic.SortedDictionary.IDictionary#3](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/CS/source.cs#3)]
[!code-vb[Generic.SortedDictionary.IDictionary#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/VB/source.vb#3)]  
[!code-csharp[Generic.SortedDictionary.IDictionary#4](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/CS/source.cs#4)]
[!code-vb[Generic.SortedDictionary.IDictionary#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/VB/source.vb#4)]  
[!code-csharp[Generic.SortedDictionary.IDictionary#32](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/CS/source.cs#32)]
[!code-vb[Generic.SortedDictionary.IDictionary#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Wartość jest przypisany, i <paramref name="key" /> typu, który nie jest możliwy do przypisania do klucza typu <paramref name="TKey" /> z <see cref="T:System.Collections.Generic.SortedDictionary`2" />.  
  
—lub— 
Wartość jest przypisany, i <paramref name="value" /> typu, który nie jest możliwy do przypisania do typu wartości <paramref name="TValue" /> z <see cref="T:System.Collections.Generic.SortedDictionary`2" />.</exception>
        <altmember cref="M:System.Collections.IDictionary.Add(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Keys">
      <MemberSignature Language="C#" Value="System.Collections.ICollection System.Collections.IDictionary.Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection System.Collections.IDictionary.Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedDictionary`2.System#Collections#IDictionary#Keys" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Keys As ICollection Implements IDictionary.Keys" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::ICollection ^ System::Collections::IDictionary::Keys { System::Collections::ICollection ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IDictionary.Keys" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Keys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Collections.ICollection" /> zawierający klucze <see cref="T:System.Collections.IDictionary" />.</summary>
        <value><see cref="T:System.Collections.ICollection" /> Zawierający klucze <see cref="T:System.Collections.IDictionary" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klucze w zwróconym elemencie <xref:System.Collections.ICollection> są sortowane według <xref:System.Collections.Generic.SortedDictionary%602.Comparer%2A> właściwości i są musi być w tej samej kolejności jak odpowiednie wartości w <xref:System.Collections.ICollection> zwrócone przez <xref:System.Collections.IDictionary.Values%2A> właściwości.  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób użycia <xref:System.Collections.IDictionary.Keys%2A> właściwość <xref:System.Collections.IDictionary?displayProperty=nameWithType> współpracować z usługą <xref:System.Collections.Generic.SortedDictionary%602>, aby wyświetlić listę kluczy w słowniku. W przykładzie pokazano również jak wyliczyć pary klucz/wartość w słowniku; należy pamiętać, że moduł wyliczający <xref:System.Collections.IDictionary?displayProperty=nameWithType> interfejsu zwraca <xref:System.Collections.DictionaryEntry> obiektów zamiast <xref:System.Collections.Generic.KeyValuePair%602> obiektów.  
  
 Przykład kodu jest częścią większego przykładu, w tym dane wyjściowe, aby uzyskać <xref:System.Collections.Generic.SortedDictionary%602.System%23Collections%23IDictionary%23Add%2A> metody.  
  
 [!code-csharp[Generic.SortedDictionary.IDictionary#31](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/CS/source.cs#31)]
 [!code-vb[Generic.SortedDictionary.IDictionary#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/VB/source.vb#31)]  
[!code-csharp[Generic.SortedDictionary.IDictionary#9](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/CS/source.cs#9)]
[!code-vb[Generic.SortedDictionary.IDictionary#9](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/VB/source.vb#9)]  
[!code-csharp[Generic.SortedDictionary.IDictionary#7](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/CS/source.cs#7)]
[!code-vb[Generic.SortedDictionary.IDictionary#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/VB/source.vb#7)]  
[!code-csharp[Generic.SortedDictionary.IDictionary#32](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/CS/source.cs#32)]
[!code-vb[Generic.SortedDictionary.IDictionary#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.ICollection" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Remove">
      <MemberSignature Language="C#" Value="void IDictionary.Remove (object key);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IDictionary.Remove(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedDictionary`2.System#Collections#IDictionary#Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Remove (key As Object) Implements IDictionary.Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IDictionary.Remove(System::Object ^ key) = System::Collections::IDictionary::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Klucz elementu do usunięcia.</param>
        <summary>Usuwa element z określonym kluczem z <see cref="T:System.Collections.IDictionary" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest O (log `n`) operacji.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób użycia <xref:System.Collections.Generic.SortedDictionary%602.System%23Collections%23IDictionary%23Remove%2A> z <xref:System.Collections.IDictionary?displayProperty=nameWithType> współpracować z usługą <xref:System.Collections.Generic.SortedDictionary%602>.  
  
 Przykład kodu jest częścią większego przykładu, w tym dane wyjściowe, aby uzyskać <xref:System.Collections.Generic.SortedDictionary%602.System%23Collections%23IDictionary%23Add%2A> metody.  
  
 [!code-csharp[Generic.SortedDictionary.IDictionary#31](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/CS/source.cs#31)]
 [!code-vb[Generic.SortedDictionary.IDictionary#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/VB/source.vb#31)]  
[!code-csharp[Generic.SortedDictionary.IDictionary#10](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/CS/source.cs#10)]
[!code-vb[Generic.SortedDictionary.IDictionary#10](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/VB/source.vb#10)]  
[!code-csharp[Generic.SortedDictionary.IDictionary#32](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/CS/source.cs#32)]
[!code-vb[Generic.SortedDictionary.IDictionary#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Values">
      <MemberSignature Language="C#" Value="System.Collections.ICollection System.Collections.IDictionary.Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection System.Collections.IDictionary.Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedDictionary`2.System#Collections#IDictionary#Values" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Values As ICollection Implements IDictionary.Values" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::ICollection ^ System::Collections::IDictionary::Values { System::Collections::ICollection ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IDictionary.Values" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Values</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Collections.ICollection" /> zawierające wartości w <see cref="T:System.Collections.IDictionary" />.</summary>
        <value><see cref="T:System.Collections.ICollection" /> Zawierające wartości w <see cref="T:System.Collections.IDictionary" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartości w zwróconym elemencie <xref:System.Collections.ICollection> są sortowane według <xref:System.Collections.Generic.SortedDictionary%602.Comparer%2A> właściwości i są musi być w tej samej kolejności jak w odpowiadających im kluczy w <xref:System.Collections.ICollection> zwrócony przez <xref:System.Collections.IDictionary.Keys%2A> właściwości.  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób użycia <xref:System.Collections.Generic.SortedDictionary%602.System%23Collections%23IDictionary%23Values%2A> właściwość <xref:System.Collections.IDictionary?displayProperty=nameWithType> współpracować z usługą <xref:System.Collections.Generic.SortedDictionary%602>, aby wyświetlić listę wartości w słowniku. W przykładzie pokazano również jak wyliczyć pary klucz/wartość w słowniku; należy pamiętać, że moduł wyliczający <xref:System.Collections.IDictionary?displayProperty=nameWithType> interfejsu zwraca <xref:System.Collections.DictionaryEntry> obiektów zamiast <xref:System.Collections.Generic.KeyValuePair%602> obiektów.  
  
 Przykład kodu jest częścią większego przykładu, w tym dane wyjściowe, aby uzyskać <xref:System.Collections.Generic.SortedDictionary%602.System%23Collections%23IDictionary%23Add%2A> metody.  
  
 [!code-csharp[Generic.SortedDictionary.IDictionary#31](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/CS/source.cs#31)]
 [!code-vb[Generic.SortedDictionary.IDictionary#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/VB/source.vb#31)]  
[!code-csharp[Generic.SortedDictionary.IDictionary#8](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/CS/source.cs#8)]
[!code-vb[Generic.SortedDictionary.IDictionary#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/VB/source.vb#8)]  
[!code-csharp[Generic.SortedDictionary.IDictionary#7](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/CS/source.cs#7)]
[!code-vb[Generic.SortedDictionary.IDictionary#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/VB/source.vb#7)]  
[!code-csharp[Generic.SortedDictionary.IDictionary#32](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/CS/source.cs#32)]
[!code-vb[Generic.SortedDictionary.IDictionary#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary.IDictionary/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.ICollection" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedDictionary`2.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca moduł wyliczający, który dokonuje iteracji w kolekcji.</summary>
        <returns><see cref="T:System.Collections.IEnumerator" /> Który może służyć do iterowania po kolekcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 `foreach` Instrukcja języka C# (`for each` w języku C++, `For Each` języka Visual Basic) powoduje ukrycie złożoności modułów wyliczających. W związku z tym, za pomocą `foreach` jest to zalecane, zamiast bezpośredniego wykonywania operacji modułu wyliczającego.  
  
 Moduły wyliczające mogą służyć do odczytu danych w kolekcji, ale nie można za ich pomocą modyfikować kolekcji źródłowej.  
  
 Początkowo moduł wyliczający jest umieszczony przed pierwszym elementem w kolekcji. W tym miejscu <xref:System.Collections.IEnumerator.Current%2A> właściwość jest niezdefiniowana. W związku z tym, należy wywołać <xref:System.Collections.IEnumerator.MoveNext%2A> metody wyprzedzeniem modułu wyliczającego do pierwszego elementu kolekcji przed odczytaniem wartości właściwości <xref:System.Collections.IEnumerator.Current%2A>.  
  
 <xref:System.Collections.IEnumerator.Current%2A> Właściwość zwraca ten sam element do momentu <xref:System.Collections.IEnumerator.MoveNext%2A> metoda jest wywoływana. <xref:System.Collections.IEnumerator.MoveNext%2A> Ustawia <xref:System.Collections.IEnumerator.Current%2A> do następnego elementu.  
  
 Jeśli <xref:System.Collections.IEnumerator.MoveNext%2A> przebiegów koniec kolekcji, moduł wyliczający jest umieszczany za ostatnim elementem w kolekcji i <xref:System.Collections.IEnumerator.MoveNext%2A> zwraca `false`. Gdy moduł wyliczający jest w tym miejscu, kolejne wywołania <xref:System.Collections.IEnumerator.MoveNext%2A> również zwracać `false`. Jeśli ostatnie wywołanie <xref:System.Collections.IEnumerator.MoveNext%2A> zwrócił `false`, <xref:System.Collections.IEnumerator.Current%2A> jest niezdefiniowana. Nie można ustawić <xref:System.Collections.IEnumerator.Current%2A> do pierwszego elementu w kolekcji; należy utworzyć nowe wystąpienie modułu wyliczającego zamiast tego.  
  
 Moduł wyliczający zachowuje ważność tak długo, jak długo kolekcja pozostaje niezmieniona. Jeśli zmiany zostały wprowadzone do kolekcji, takie jak dodawanie, modyfikowanie lub usuwanie elementów, moduł wyliczający jest nieodwracalnie unieważnione, a następne wywołanie <xref:System.Collections.IEnumerator.MoveNext%2A> lub <xref:System.Collections.IEnumerator.Reset%2A> zgłasza <xref:System.InvalidOperationException>.  
  
 Moduł wyliczający nie ma wyłącznego dostępu do kolekcji, w związku z tym wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość. Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania.  Aby zezwolić wielu wątkom na dostęp do kolekcji w celu odczytu i zapisu danych, należy zaimplementować własny mechanizm synchronizacji.  
  
 Domyślne implementacje kolekcji w <xref:System.Collections.Generic?displayProperty=nameWithType> przestrzeni nazw nie są zsynchronizowane.  
  
 Ta metoda jest operacją O (log n), gdzie n to liczba elementów w kolekcji.
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.SortedDictionary`2.GetEnumerator" />
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="TryGetValue">
      <MemberSignature Language="C#" Value="public bool TryGetValue (TKey key, out TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryGetValue(!TKey key, [out] !TValue&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.SortedDictionary`2.TryGetValue(`0,`1@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetValue (key As TKey, ByRef value As TValue) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryGetValue(TKey key, [Runtime::InteropServices::Out] TValue % value);" />
      <MemberSignature Language="F#" Value="abstract member TryGetValue : 'Key *  -&gt; bool&#xA;override this.TryGetValue : 'Key *  -&gt; bool" Usage="sortedDictionary.TryGetValue (key, value)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.TryGetValue(`0,`1@)</InterfaceMember>
        <InterfaceMember>M:System.Collections.Generic.IReadOnlyDictionary`2.TryGetValue(`0,`1@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" RefType="out" />
      </Parameters>
      <Docs>
        <param name="key">Klucz wartości do pobrania.</param>
        <param name="value">Gdy metoda zwróci wartość, wartość jest skojarzone z określonym kluczem, jeśli klucz zostanie znaleziony; w przeciwnym razie wartość domyślna dla typu <paramref name="value" /> parametru.</param>
        <summary>Pobiera wartość skojarzoną z określonym kluczem.</summary>
        <returns><see langword="true" /> Jeśli <see cref="T:System.Collections.Generic.SortedDictionary`2" /> zawiera element z określonym kluczem, a w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda łączy w sobie funkcje <xref:System.Collections.Generic.SortedDictionary%602.ContainsKey%2A> metody i <xref:System.Collections.Generic.SortedDictionary%602.Item%2A> właściwości.  
  
 Jeśli klucz nie zostanie znaleziony, a następnie `value` parametr pobiera wartość odpowiednią wartość domyślną dla typu wartości `TValue`; na przykład 0 (zero) dla typów całkowitoliczbowych `false` dotyczące typów logicznych i `null` dla typów odwołań.  
  
 Ta metoda jest O (log `n`) operacji.  
  
   
  
## Examples  
 W przykładzie pokazano sposób użycia <xref:System.Collections.Generic.SortedDictionary%602.TryGetValue%2A> metodę jako bardziej wydajny sposób, aby pobrać wartości w programie, który często podejmie klucze, które nie znajdują się w słowniku. Dla kontrastu, w przykładzie przedstawiono również sposób, w jaki <xref:System.Collections.Generic.SortedDictionary%602.Item%2A> właściwości (indeksatora w języku C#) zgłasza wyjątki podczas próby pobrania nieistniejącej kluczy.  
  
 Ten przykład kodu jest częścią większego przykładu przewidzianego dla <xref:System.Collections.Generic.SortedDictionary%602> klasy.  
  
 [!code-csharp[Generic.SortedDictionary#5](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary/CS/source.cs#5)]
 [!code-vb[Generic.SortedDictionary#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary/VB/source.vb#5)]  
[!code-csharp[Generic.SortedDictionary#4](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary/CS/source.cs#4)]
[!code-vb[Generic.SortedDictionary#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.SortedDictionary`2.ContainsKey(`0)" />
        <altmember cref="P:System.Collections.Generic.SortedDictionary`2.Item(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Values">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.SortedDictionary&lt;TKey,TValue&gt;.ValueCollection Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.SortedDictionary`2/ValueCollection&lt;!TKey, !TValue&gt; Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.SortedDictionary`2.Values" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Values As SortedDictionary(Of TKey, TValue).ValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::SortedDictionary&lt;TKey, TValue&gt;::ValueCollection ^ Values { System::Collections::Generic::SortedDictionary&lt;TKey, TValue&gt;::ValueCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Values : System.Collections.Generic.SortedDictionary&lt;'Key, 'Value&gt;.ValueCollection" Usage="System.Collections.Generic.SortedDictionary&lt;'Key, 'Value&gt;.Values" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.SortedDictionary&lt;TKey,TValue&gt;+ValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję zawierającą wartości z <see cref="T:System.Collections.Generic.SortedDictionary`2" />.</summary>
        <value>A <see cref="T:System.Collections.Generic.SortedDictionary`2.ValueCollection" /> zawierające wartości w <see cref="T:System.Collections.Generic.SortedDictionary`2" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartości w <xref:System.Collections.Generic.SortedDictionary%602.ValueCollection> są sortowane według <xref:System.Collections.Generic.SortedDictionary%602.Comparer%2A> właściwości i są w tej samej kolejności, jak klucze skojarzone z <xref:System.Collections.Generic.SortedDictionary%602.KeyCollection> zwrócone przez <xref:System.Collections.Generic.SortedDictionary%602.Keys%2A> właściwości.  
  
 Zwrócony <xref:System.Collections.Generic.SortedDictionary%602.ValueCollection> nie jest statyczne kopia; zamiast tego <xref:System.Collections.Generic.SortedDictionary%602.ValueCollection> odwołuje się do wartości w oryginalnym <xref:System.Collections.Generic.SortedDictionary%602>. W związku z tym, zmienia się na <xref:System.Collections.Generic.SortedDictionary%602> odzwierciedlenie w dalszym ciągu <xref:System.Collections.Generic.SortedDictionary%602.ValueCollection>.  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
   
  
## Examples  
 Ten przykład kodu pokazuje, jak wyliczyć wartości w słowniku, używając <xref:System.Collections.Generic.SortedDictionary%602.Values%2A> właściwość i jak wyliczyć kluczy i wartości w słowniku.  
  
 Ten przykład kodu jest częścią większego przykładu przewidzianego dla <xref:System.Collections.Generic.SortedDictionary%602> klasy.  
  
 [!code-csharp[Generic.SortedDictionary#8](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary/CS/source.cs#8)]
 [!code-vb[Generic.SortedDictionary#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary/VB/source.vb#8)]  
[!code-csharp[Generic.SortedDictionary#7](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.SortedDictionary/CS/source.cs#7)]
[!code-vb[Generic.SortedDictionary#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.SortedDictionary/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.SortedDictionary`2.ValueCollection" />
        <altmember cref="P:System.Collections.Generic.SortedDictionary`2.Keys" />
      </Docs>
    </Member>
  </Members>
</Type>

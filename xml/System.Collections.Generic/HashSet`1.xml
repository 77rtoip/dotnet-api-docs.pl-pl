<Type Name="HashSet&lt;T&gt;" FullName="System.Collections.Generic.HashSet&lt;T&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="bd933e80de574d8aae2219cedbe04d17a9cba262" /><Meta Name="ms.sourcegitcommit" Value="74239f3977d28923e5020663db2c4e91601bea79" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="07/24/2019" /><Meta Name="ms.locfileid" Value="68437454" /></Metadata><TypeSignature Language="C#" Value="public class HashSet&lt;T&gt; : System.Collections.Generic.ICollection&lt;T&gt;, System.Collections.Generic.IEnumerable&lt;T&gt;, System.Collections.Generic.IReadOnlyCollection&lt;T&gt;, System.Collections.Generic.ISet&lt;T&gt;, System.Runtime.Serialization.IDeserializationCallback, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit HashSet`1&lt;T&gt; extends System.Object implements class System.Collections.Generic.ICollection`1&lt;!T&gt;, class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;!T&gt;, class System.Collections.Generic.ISet`1&lt;!T&gt;, class System.Collections.IEnumerable, class System.Runtime.Serialization.IDeserializationCallback, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Generic.HashSet`1" />
  <TypeSignature Language="VB.NET" Value="Public Class HashSet(Of T)&#xA;Implements ICollection(Of T), IDeserializationCallback, IEnumerable(Of T), IReadOnlyCollection(Of T), ISerializable, ISet(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class HashSet : System::Collections::Generic::ICollection&lt;T&gt;, System::Collections::Generic::IEnumerable&lt;T&gt;, System::Collections::Generic::IReadOnlyCollection&lt;T&gt;, System::Collections::Generic::ISet&lt;T&gt;, System::Runtime::Serialization::IDeserializationCallback, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type HashSet&lt;'T&gt; = class&#xA;    interface ICollection&lt;'T&gt;&#xA;    interface ISerializable&#xA;    interface IDeserializationCallback&#xA;    interface ISet&lt;'T&gt;&#xA;    interface IReadOnlyCollection&lt;'T&gt;&#xA;    interface seq&lt;'T&gt;&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Collections</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.ISet&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.IDeserializationCallback</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.HashSetDebugView`1))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T"><span data-ttu-id="f6757-101">Typ elementów w zestawie skrótów.</span><span class="sxs-lookup"><span data-stu-id="f6757-101">The type of elements in the hash set.</span></span></typeparam>
    <summary><span data-ttu-id="f6757-102">Reprezentuje zestaw wartości.</span><span class="sxs-lookup"><span data-stu-id="f6757-102">Represents a set of values.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6757-103"><xref:System.Collections.Generic.HashSet%601> Klasa zawiera operacje zestawu o wysokiej wydajności.</span><span class="sxs-lookup"><span data-stu-id="f6757-103">The <xref:System.Collections.Generic.HashSet%601> class provides high-performance set operations.</span></span> <span data-ttu-id="f6757-104">Zestaw jest kolekcją, która nie zawiera zduplikowanych elementów i których elementy znajdują się w określonej kolejności.</span><span class="sxs-lookup"><span data-stu-id="f6757-104">A set is a collection that contains no duplicate elements, and whose elements are in no particular order.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f6757-105"><xref:System.Collections.Generic.HashSet%601>implementuje interfejs zaczynający [!INCLUDE[net_v46](~/includes/net-v46-md.md)]się od; we wcześniejszych wersjach .NET Framework, <xref:System.Collections.Generic.HashSet%601> Klasa nie zaimplementował tego interfejsu. <xref:System.Collections.Generic.IReadOnlyCollection%601></span><span class="sxs-lookup"><span data-stu-id="f6757-105"><xref:System.Collections.Generic.HashSet%601> implements the <xref:System.Collections.Generic.IReadOnlyCollection%601> interface starting with the [!INCLUDE[net_v46](~/includes/net-v46-md.md)]; in previous versions of the .NET Framework, the <xref:System.Collections.Generic.HashSet%601> class did not implement this interface.</span></span>  
  
 <span data-ttu-id="f6757-106">Pojemność <xref:System.Collections.Generic.HashSet%601> obiektu to liczba elementów, które mogą być przechowywane w obiekcie.</span><span class="sxs-lookup"><span data-stu-id="f6757-106">The capacity of a <xref:System.Collections.Generic.HashSet%601> object is the number of elements that the object can hold.</span></span> <span data-ttu-id="f6757-107">Pojemność <xref:System.Collections.Generic.HashSet%601> obiektu jest automatycznie zwiększana, gdy elementy są dodawane do obiektu.</span><span class="sxs-lookup"><span data-stu-id="f6757-107">A <xref:System.Collections.Generic.HashSet%601> object's capacity automatically increases as elements are added to the object.</span></span>  
  
 <span data-ttu-id="f6757-108">Klasa jest oparta na modelu zestawów matematycznych i zawiera operacje zestawu o wysokiej wydajności podobne do uzyskiwania dostępu do kluczy <xref:System.Collections.Generic.Dictionary%602> kolekcji lub <xref:System.Collections.Hashtable>. <xref:System.Collections.Generic.HashSet%601></span><span class="sxs-lookup"><span data-stu-id="f6757-108">The <xref:System.Collections.Generic.HashSet%601> class is based on the model of mathematical sets and provides high-performance set operations similar to accessing the keys of the <xref:System.Collections.Generic.Dictionary%602> or <xref:System.Collections.Hashtable> collections.</span></span> <span data-ttu-id="f6757-109">W prostych terminach <xref:System.Collections.Generic.HashSet%601> Klasa może być uważana <xref:System.Collections.Generic.Dictionary%602> za kolekcję bez wartości.</span><span class="sxs-lookup"><span data-stu-id="f6757-109">In simple terms, the <xref:System.Collections.Generic.HashSet%601> class can be thought of as a <xref:System.Collections.Generic.Dictionary%602> collection without values.</span></span>  
  
 <span data-ttu-id="f6757-110"><xref:System.Collections.Generic.HashSet%601> Kolekcja nie jest posortowana i nie może zawierać zduplikowanych elementów.</span><span class="sxs-lookup"><span data-stu-id="f6757-110">A <xref:System.Collections.Generic.HashSet%601> collection is not sorted and cannot contain duplicate elements.</span></span> <span data-ttu-id="f6757-111">Jeśli duplikowanie kolejności lub elementów jest ważniejsze niż wydajność aplikacji, rozważ użycie <xref:System.Collections.Generic.List%601> klasy razem <xref:System.Collections.Generic.List%601.Sort%2A> z metodą.</span><span class="sxs-lookup"><span data-stu-id="f6757-111">If order or element duplication is more important than performance for your application, consider using the <xref:System.Collections.Generic.List%601> class together with the <xref:System.Collections.Generic.List%601.Sort%2A> method.</span></span>  
  
 <span data-ttu-id="f6757-112"><xref:System.Collections.Generic.HashSet%601>oferuje wiele operacji zestawu matematycznego, takich jak dodawanie (unie) i Ustawianie odejmowania.</span><span class="sxs-lookup"><span data-stu-id="f6757-112"><xref:System.Collections.Generic.HashSet%601> provides many mathematical set operations, such as set addition (unions) and set subtraction.</span></span> <span data-ttu-id="f6757-113">Poniższa tabela zawiera listę podanych <xref:System.Collections.Generic.HashSet%601> operacji i ich odpowiedników matematycznych.</span><span class="sxs-lookup"><span data-stu-id="f6757-113">The following table lists the provided <xref:System.Collections.Generic.HashSet%601> operations and their mathematical equivalents.</span></span>  
  
|<span data-ttu-id="f6757-114">HashSet —, operacja</span><span class="sxs-lookup"><span data-stu-id="f6757-114">HashSet operation</span></span>|<span data-ttu-id="f6757-115">Odpowiednik matematyczny</span><span class="sxs-lookup"><span data-stu-id="f6757-115">Mathematical equivalent</span></span>|  
|-------------------------------|-----------------------------|  
|<xref:System.Collections.Generic.HashSet%601.UnionWith%2A>|<span data-ttu-id="f6757-116">Dodawanie Unii lub zestawów</span><span class="sxs-lookup"><span data-stu-id="f6757-116">Union or set addition</span></span>|  
|<xref:System.Collections.Generic.HashSet%601.IntersectWith%2A>|<span data-ttu-id="f6757-117">Część wspólna</span><span class="sxs-lookup"><span data-stu-id="f6757-117">Intersection</span></span>|  
|<xref:System.Collections.Generic.HashSet%601.ExceptWith%2A>|<span data-ttu-id="f6757-118">Ustawianie odejmowania</span><span class="sxs-lookup"><span data-stu-id="f6757-118">Set subtraction</span></span>|  
|<xref:System.Collections.Generic.HashSet%601.SymmetricExceptWith%2A>|<span data-ttu-id="f6757-119">Różnica symetryczna</span><span class="sxs-lookup"><span data-stu-id="f6757-119">Symmetric difference</span></span>|  
  
 <span data-ttu-id="f6757-120">Poza wymienionymi operacjami <xref:System.Collections.Generic.HashSet%601> zestawu Klasa zawiera również metody określania równości zestawu, nakładania się zestawów oraz tego, czy zestaw jest podzbiorem lub nadzbiorem innego zestawu.</span><span class="sxs-lookup"><span data-stu-id="f6757-120">In addition to the listed set operations, the <xref:System.Collections.Generic.HashSet%601> class also provides methods for determining set equality, overlap of sets, and whether a set is a subset or superset of another set.</span></span>  
  
<span data-ttu-id="f6757-121">**Tylko .NET Framework:** W przypadku bardzo <xref:System.Collections.Generic.HashSet%601> dużych obiektów można zwiększyć maksymalną pojemność do 2 000 000 000 elementów w systemie 64-bitowym, `enabled` ustawiając atrybut [`<gcAllowVeryLargeObjects>`](~/docs/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element.md) elementu konfiguracji na `true` w środowisku wykonawczym.</span><span class="sxs-lookup"><span data-stu-id="f6757-121">**.NET Framework only:** For very large <xref:System.Collections.Generic.HashSet%601> objects, you can increase the maximum capacity to 2 billion elements on a 64-bit system by setting the `enabled` attribute of the [`<gcAllowVeryLargeObjects>`](~/docs/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element.md) configuration element to `true` in the run-time environment.</span></span>  
  
 <span data-ttu-id="f6757-122">Począwszy od [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] <xref:System.Collections.Generic.ISet%601> , Klasa implementuje interfejs. <xref:System.Collections.Generic.HashSet%601></span><span class="sxs-lookup"><span data-stu-id="f6757-122">Starting with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the <xref:System.Collections.Generic.HashSet%601> class implements the <xref:System.Collections.Generic.ISet%601> interface.</span></span>  
  
## <a name="hashset-and-linq-set-operations"></a><span data-ttu-id="f6757-123">Operacje na zestawie HashSet i LINQ</span><span class="sxs-lookup"><span data-stu-id="f6757-123">HashSet and LINQ Set Operations</span></span>  
 <span data-ttu-id="f6757-124">`Distinct`LINQ zapewnia dostęp do operacji `Intersect` , `Union` `Except` i ustawia na dowolnym źródle danych, który implementuje <xref:System.Collections.IEnumerable> interfejsy lub <xref:System.Linq.IQueryable> .</span><span class="sxs-lookup"><span data-stu-id="f6757-124">LINQ provides access to the `Distinct`, `Union`, `Intersect` and `Except` set operations on any data source that implements the <xref:System.Collections.IEnumerable> or <xref:System.Linq.IQueryable> interfaces.</span></span>  <span data-ttu-id="f6757-125"><xref:System.Collections.Generic.HashSet%601>zapewnia większą i bardziej niezawodną kolekcję operacji zestawu.</span><span class="sxs-lookup"><span data-stu-id="f6757-125"><xref:System.Collections.Generic.HashSet%601> provides a larger and more robust collection of set operations.</span></span> <span data-ttu-id="f6757-126">Przykładowo zawiera <xref:System.Collections.Generic.HashSet%601> porównania, takie jak <xref:System.Collections.Generic.HashSet%601.IsSubsetOf%2A> i <xref:System.Collections.Generic.HashSet%601.IsSupersetOf%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6757-126">For example, <xref:System.Collections.Generic.HashSet%601> provides comparisons such as <xref:System.Collections.Generic.HashSet%601.IsSubsetOf%2A> and <xref:System.Collections.Generic.HashSet%601.IsSupersetOf%2A>.</span></span>  
  
 <span data-ttu-id="f6757-127">Podstawowa różnica między operacjami zestawu LINQ i <xref:System.Collections.Generic.HashSet%601> operacjami polega na tym, że operacje zestawu LINQ <xref:System.Collections.Generic.IEnumerable%601> zawsze zwracają nową kolekcję <xref:System.Collections.Generic.HashSet%601> , podczas gdy równoważne metody modyfikują bieżącą kolekcję.</span><span class="sxs-lookup"><span data-stu-id="f6757-127">The primary difference between LINQ set operations and <xref:System.Collections.Generic.HashSet%601> operations is that LINQ set operations always return a new <xref:System.Collections.Generic.IEnumerable%601> collection, whereas the <xref:System.Collections.Generic.HashSet%601> equivalent methods modify the current collection.</span></span>  
  
 <span data-ttu-id="f6757-128">Zazwyczaj jeśli trzeba utworzyć nowy zestaw lub jeśli aplikacja wymaga dostępu tylko do dostarczonych operacji zestawu, używanie operacji zestawu LINQ Set w dowolnej <xref:System.Collections.Generic.IEnumerable%601> kolekcji lub tablicy będzie wystarczające.</span><span class="sxs-lookup"><span data-stu-id="f6757-128">Typically, if you must create a new set or if your application needs access only to the provided set operations, using LINQ set operations on any <xref:System.Collections.Generic.IEnumerable%601> collection or array will be sufficient.</span></span> <span data-ttu-id="f6757-129">Jeśli jednak aplikacja wymaga dostępu do dodatkowych operacji zestawu lub jeśli nie jest to pożądane lub konieczne do utworzenia nowej kolekcji, użyj <xref:System.Collections.Generic.HashSet%601> klasy.</span><span class="sxs-lookup"><span data-stu-id="f6757-129">However, if your application requires access to additional set operations, or if it is not desirable or necessary to create a new collection, use the <xref:System.Collections.Generic.HashSet%601> class.</span></span>  
  
 <span data-ttu-id="f6757-130">W poniższej tabeli przedstawiono <xref:System.Collections.Generic.HashSet%601> operacje i ich równoważne operacje zestawu LINQ.</span><span class="sxs-lookup"><span data-stu-id="f6757-130">The following table shows the <xref:System.Collections.Generic.HashSet%601> operations and their equivalent LINQ set operations.</span></span>  
  
|<span data-ttu-id="f6757-131">HashSet —, operacja</span><span class="sxs-lookup"><span data-stu-id="f6757-131">HashSet operation</span></span>|<span data-ttu-id="f6757-132">Odpowiednik LINQ</span><span class="sxs-lookup"><span data-stu-id="f6757-132">LINQ equivalent</span></span>|  
|-------------------------------|---------------------|  
|<xref:System.Collections.Generic.HashSet%601.UnionWith%2A>|<xref:System.Linq.Enumerable.Union%2A>|  
|<xref:System.Collections.Generic.HashSet%601.IntersectWith%2A>|<xref:System.Linq.Enumerable.Intersect%2A>|  
|<xref:System.Collections.Generic.HashSet%601.ExceptWith%2A>|<xref:System.Linq.Enumerable.Except%2A>|  
|<span data-ttu-id="f6757-133">Nie podano.</span><span class="sxs-lookup"><span data-stu-id="f6757-133">Not provided.</span></span>|<xref:System.Linq.Enumerable.Distinct%2A>|  
|<xref:System.Collections.Generic.HashSet%601.SymmetricExceptWith%2A>|<span data-ttu-id="f6757-134">Nie podano.</span><span class="sxs-lookup"><span data-stu-id="f6757-134">Not provided.</span></span>|  
|<xref:System.Collections.Generic.HashSet%601.Overlaps%2A>|<span data-ttu-id="f6757-135">Nie podano.</span><span class="sxs-lookup"><span data-stu-id="f6757-135">Not provided.</span></span>|  
|<xref:System.Collections.Generic.HashSet%601.IsSubsetOf%2A>|<span data-ttu-id="f6757-136">Nie podano.</span><span class="sxs-lookup"><span data-stu-id="f6757-136">Not provided.</span></span>|  
|<xref:System.Collections.Generic.HashSet%601.IsProperSubsetOf%2A>|<span data-ttu-id="f6757-137">Nie podano.</span><span class="sxs-lookup"><span data-stu-id="f6757-137">Not provided.</span></span>|  
|<xref:System.Collections.Generic.HashSet%601.IsSupersetOf%2A>|<span data-ttu-id="f6757-138">Nie podano.</span><span class="sxs-lookup"><span data-stu-id="f6757-138">Not provided.</span></span>|  
|<xref:System.Collections.Generic.HashSet%601.IsProperSupersetOf%2A>|<span data-ttu-id="f6757-139">Nie podano.</span><span class="sxs-lookup"><span data-stu-id="f6757-139">Not provided.</span></span>|  
|<xref:System.Collections.Generic.HashSet%601.SetEquals%2A>|<span data-ttu-id="f6757-140">Nie podano.</span><span class="sxs-lookup"><span data-stu-id="f6757-140">Not provided.</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="f6757-141">Poniższy przykład pokazuje, jak scalić dwa różne zestawy.</span><span class="sxs-lookup"><span data-stu-id="f6757-141">The following example demonstrates how to merge two disparate sets.</span></span> <span data-ttu-id="f6757-142">Ten przykład tworzy dwa <xref:System.Collections.Generic.HashSet%601> obiekty i wypełnia je odpowiednio wartościami parzystymi i nieparzystymi.</span><span class="sxs-lookup"><span data-stu-id="f6757-142">This example creates two <xref:System.Collections.Generic.HashSet%601> objects, and populates them with even and odd numbers, respectively.</span></span> <span data-ttu-id="f6757-143">Trzeci <xref:System.Collections.Generic.HashSet%601> obiekt jest tworzony z zestawu, który zawiera liczby parzyste.</span><span class="sxs-lookup"><span data-stu-id="f6757-143">A third <xref:System.Collections.Generic.HashSet%601> object is created from the set that contains the even numbers.</span></span> <span data-ttu-id="f6757-144">Przykład następnie wywołuje <xref:System.Collections.Generic.HashSet%601.UnionWith%2A> metodę, która dodaje nieparzystą liczbę z zestawem trzecim.</span><span class="sxs-lookup"><span data-stu-id="f6757-144">The example then calls the <xref:System.Collections.Generic.HashSet%601.UnionWith%2A> method, which adds the odd number set to the third set.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_UnionWith#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/cs/Program.cs#01)]
 [!code-vb[System.Collections.Generic.HashSet_UnionWith#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/vb/Program.vb#01)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Collections.Generic.SortedSet`1" />
    <altmember cref="T:System.Collections.Generic.ISet`1" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f6757-145">Inicjuje nowe wystąpienie klasy <see cref="T:System.Collections.Generic.HashSet`1" /> klasy.</span><span class="sxs-lookup"><span data-stu-id="f6757-145">Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HashSet ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HashSet();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f6757-146">Inicjuje nowe wystąpienie <see cref="T:System.Collections.Generic.HashSet`1" /> klasy, która jest pusta, i używa domyślnej wartości porównującej równość dla typu zestawu.</span><span class="sxs-lookup"><span data-stu-id="f6757-146">Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class that is empty and uses the default equality comparer for the set type.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6757-147">Pojemność <xref:System.Collections.Generic.HashSet%601> obiektu to liczba elementów, które mogą być przechowywane w obiekcie.</span><span class="sxs-lookup"><span data-stu-id="f6757-147">The capacity of a <xref:System.Collections.Generic.HashSet%601> object is the number of elements that the object can hold.</span></span> <span data-ttu-id="f6757-148">Pojemność <xref:System.Collections.Generic.HashSet%601> obiektu jest automatycznie zwiększana, gdy elementy są dodawane do obiektu.</span><span class="sxs-lookup"><span data-stu-id="f6757-148">A <xref:System.Collections.Generic.HashSet%601> object's capacity automatically increases as elements are added to the object.</span></span>  
  
 <span data-ttu-id="f6757-149">Ten konstruktor jest operacją O (1).</span><span class="sxs-lookup"><span data-stu-id="f6757-149">This constructor is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6757-150">Poniższy przykład ilustruje sposób tworzenia i wypełniania dwóch <xref:System.Collections.Generic.HashSet%601> obiektów.</span><span class="sxs-lookup"><span data-stu-id="f6757-150">The following example demonstrates how to create and populate two <xref:System.Collections.Generic.HashSet%601> objects.</span></span> <span data-ttu-id="f6757-151">Ten przykład jest częścią większego przykładu dostarczonego dla <xref:System.Collections.Generic.HashSet%601.UnionWith%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="f6757-151">This example is part of a larger example provided for the <xref:System.Collections.Generic.HashSet%601.UnionWith%2A> method.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_UnionWith#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/cs/Program.cs#03)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HashSet (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HashSet(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.HashSet&lt;'T&gt; : seq&lt;'T&gt; -&gt; System.Collections.Generic.HashSet&lt;'T&gt;" Usage="new System.Collections.Generic.HashSet&lt;'T&gt; collection" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection"><span data-ttu-id="f6757-152">Kolekcja, której elementy są kopiowane do nowego zestawu.</span><span class="sxs-lookup"><span data-stu-id="f6757-152">The collection whose elements are copied to the new set.</span></span></param>
        <summary><span data-ttu-id="f6757-153">Inicjuje nowe wystąpienie <see cref="T:System.Collections.Generic.HashSet`1" /> klasy, która używa domyślnej opcji porównującej równość dla typu zestawu, zawiera elementy skopiowane z określonej kolekcji i ma wystarczającą pojemność, aby pomieścić liczbę skopiowanych elementów.</span><span class="sxs-lookup"><span data-stu-id="f6757-153">Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class that uses the default equality comparer for the set type, contains elements copied from the specified collection, and has sufficient capacity to accommodate the number of elements copied.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6757-154">Pojemność <xref:System.Collections.Generic.HashSet%601> obiektu to liczba elementów, które mogą być przechowywane w obiekcie.</span><span class="sxs-lookup"><span data-stu-id="f6757-154">The capacity of a <xref:System.Collections.Generic.HashSet%601> object is the number of elements that the object can hold.</span></span> <span data-ttu-id="f6757-155">Pojemność <xref:System.Collections.Generic.HashSet%601> obiektu jest automatycznie zwiększana, gdy elementy są dodawane do obiektu.</span><span class="sxs-lookup"><span data-stu-id="f6757-155">A <xref:System.Collections.Generic.HashSet%601> object's capacity automatically increases as elements are added to the object.</span></span>  
  
 <span data-ttu-id="f6757-156">Jeśli `collection` zawiera duplikaty, zestaw będzie zawierać jeden z każdego unikatowego elementu.</span><span class="sxs-lookup"><span data-stu-id="f6757-156">If `collection` contains duplicates, the set will contain one of each unique element.</span></span> <span data-ttu-id="f6757-157">Nie zostanie zgłoszony żaden wyjątek.</span><span class="sxs-lookup"><span data-stu-id="f6757-157">No exception will be thrown.</span></span> <span data-ttu-id="f6757-158">W związku z tym rozmiar zestawu wyników nie jest taki sam jak rozmiar `collection`.</span><span class="sxs-lookup"><span data-stu-id="f6757-158">Therefore, the size of the resulting set is not identical to the size of `collection`.</span></span>  
  
 <span data-ttu-id="f6757-159">Ten konstruktor jest operacją o`n`(), gdzie `n` jest `collection` liczbą elementów w parametrze.</span><span class="sxs-lookup"><span data-stu-id="f6757-159">This constructor is an O(`n`) operation, where `n` is the number of elements in the `collection` parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6757-160">Poniższy przykład pokazuje, jak utworzyć <xref:System.Collections.Generic.HashSet%601> kolekcję z istniejącego zestawu.</span><span class="sxs-lookup"><span data-stu-id="f6757-160">The following example shows how to create a <xref:System.Collections.Generic.HashSet%601> collection from an existing set.</span></span> <span data-ttu-id="f6757-161">W tym przykładzie dwa zestawy są tworzone z parzystą i nieparzystą liczbą całkowitą.</span><span class="sxs-lookup"><span data-stu-id="f6757-161">In this example, two sets are created with even and odd integers, respectively.</span></span> <span data-ttu-id="f6757-162">Trzeci <xref:System.Collections.Generic.HashSet%601> obiekt jest następnie tworzony z parzystej liczby całkowitej.</span><span class="sxs-lookup"><span data-stu-id="f6757-162">A third <xref:System.Collections.Generic.HashSet%601> object is then created from the even integer set.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_UnionWith#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_UnionWith#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6757-163"><paramref name="collection" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6757-163"><paramref name="collection" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HashSet (System.Collections.Generic.IEqualityComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEqualityComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (comparer As IEqualityComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HashSet(System::Collections::Generic::IEqualityComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.HashSet&lt;'T&gt; : System.Collections.Generic.IEqualityComparer&lt;'T&gt; -&gt; System.Collections.Generic.HashSet&lt;'T&gt;" Usage="new System.Collections.Generic.HashSet&lt;'T&gt; comparer" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="comparer"><span data-ttu-id="f6757-164">Implementacja do użycia podczas porównywania wartości w zestawie lub <see langword="null" /> do korzystania z domyślnej <see cref="T:System.Collections.Generic.EqualityComparer`1" /> implementacji dla typu zestawu. <see cref="T:System.Collections.Generic.IEqualityComparer`1" /></span><span class="sxs-lookup"><span data-stu-id="f6757-164">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation to use when comparing values in the set, or <see langword="null" /> to use the default <see cref="T:System.Collections.Generic.EqualityComparer`1" /> implementation for the set type.</span></span></param>
        <summary><span data-ttu-id="f6757-165">Inicjuje nowe wystąpienie <see cref="T:System.Collections.Generic.HashSet`1" /> klasy, która jest pusta i używa określonej metody porównującej równości dla typu zestawu.</span><span class="sxs-lookup"><span data-stu-id="f6757-165">Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class that is empty and uses the specified equality comparer for the set type.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6757-166">Pojemność <xref:System.Collections.Generic.HashSet%601> obiektu to liczba elementów, które mogą być przechowywane w obiekcie.</span><span class="sxs-lookup"><span data-stu-id="f6757-166">The capacity of a <xref:System.Collections.Generic.HashSet%601> object is the number of elements that the object can hold.</span></span> <span data-ttu-id="f6757-167">Pojemność <xref:System.Collections.Generic.HashSet%601> obiektu jest automatycznie zwiększana, gdy elementy są dodawane do obiektu.</span><span class="sxs-lookup"><span data-stu-id="f6757-167">A <xref:System.Collections.Generic.HashSet%601> object's capacity automatically increases as elements are added to the object.</span></span>  
  
 <span data-ttu-id="f6757-168">Ten konstruktor jest operacją O (1).</span><span class="sxs-lookup"><span data-stu-id="f6757-168">This constructor is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HashSet (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HashSet(int capacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.HashSet&lt;'T&gt; : int -&gt; System.Collections.Generic.HashSet&lt;'T&gt;" Usage="new System.Collections.Generic.HashSet&lt;'T&gt; capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="capacity"><span data-ttu-id="f6757-169">Początkowy rozmiar<see cref="T:System.Collections.Generic.HashSet`1" /></span><span class="sxs-lookup"><span data-stu-id="f6757-169">The initial size of the <see cref="T:System.Collections.Generic.HashSet`1" /></span></span></param>
        <summary><span data-ttu-id="f6757-170">Inicjuje nowe wystąpienie <see cref="T:System.Collections.Generic.HashSet`1" /> klasy, która jest pusta, ale ma zarezerwowane miejsce dla <paramref name="capacity" /> elementów i używa domyślnej opcji porównującej równość dla typu zestawu.</span><span class="sxs-lookup"><span data-stu-id="f6757-170">Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class that is empty, but has reserved space for <paramref name="capacity" /> items and uses the default equality comparer for the set type.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6757-171">Ponieważ zmiany rozmiaru są stosunkowo kosztowne (wymaga ponownej mieszania), to próbuje zminimalizować konieczność zmiany rozmiaru przez ustawienie początkowej wydajności na podstawie wartości `capacity`.</span><span class="sxs-lookup"><span data-stu-id="f6757-171">Since resizes are relatively expensive (require rehashing), this attempts to minimize the need to resize by setting the initial capacity based on the value of the `capacity`.</span></span>
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HashSet (System.Collections.Generic.IEnumerable&lt;T&gt; collection, System.Collections.Generic.IEqualityComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection, class System.Collections.Generic.IEqualityComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IEnumerable(Of T), comparer As IEqualityComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HashSet(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection, System::Collections::Generic::IEqualityComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.HashSet&lt;'T&gt; : seq&lt;'T&gt; * System.Collections.Generic.IEqualityComparer&lt;'T&gt; -&gt; System.Collections.Generic.HashSet&lt;'T&gt;" Usage="new System.Collections.Generic.HashSet&lt;'T&gt; (collection, comparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection"><span data-ttu-id="f6757-172">Kolekcja, której elementy są kopiowane do nowego zestawu.</span><span class="sxs-lookup"><span data-stu-id="f6757-172">The collection whose elements are copied to the new set.</span></span></param>
        <param name="comparer"><span data-ttu-id="f6757-173">Implementacja do użycia podczas porównywania wartości w zestawie lub <see langword="null" /> do korzystania z domyślnej <see cref="T:System.Collections.Generic.EqualityComparer`1" /> implementacji dla typu zestawu. <see cref="T:System.Collections.Generic.IEqualityComparer`1" /></span><span class="sxs-lookup"><span data-stu-id="f6757-173">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation to use when comparing values in the set, or <see langword="null" /> to use the default <see cref="T:System.Collections.Generic.EqualityComparer`1" /> implementation for the set type.</span></span></param>
        <summary><span data-ttu-id="f6757-174">Inicjuje nowe wystąpienie <see cref="T:System.Collections.Generic.HashSet`1" /> klasy, która używa określonej metody porównującej równości dla typu zestawu, zawiera elementy skopiowane z określonej kolekcji i ma wystarczającą pojemność, aby pomieścić liczbę skopiowanych elementów.</span><span class="sxs-lookup"><span data-stu-id="f6757-174">Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class that uses the specified equality comparer for the set type, contains elements copied from the specified collection, and has sufficient capacity to accommodate the number of elements copied.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6757-175">Pojemność <xref:System.Collections.Generic.HashSet%601> obiektu to liczba elementów, które mogą być przechowywane w obiekcie.</span><span class="sxs-lookup"><span data-stu-id="f6757-175">The capacity of a <xref:System.Collections.Generic.HashSet%601> object is the number of elements that the object can hold.</span></span> <span data-ttu-id="f6757-176">Pojemność <xref:System.Collections.Generic.HashSet%601> obiektu jest automatycznie zwiększana, gdy elementy są dodawane do obiektu.</span><span class="sxs-lookup"><span data-stu-id="f6757-176">A <xref:System.Collections.Generic.HashSet%601> object's capacity automatically increases as elements are added to the object.</span></span>  
  
 <span data-ttu-id="f6757-177">Jeśli `collection` zawiera duplikaty, zestaw będzie zawierać jeden z każdego unikatowego elementu.</span><span class="sxs-lookup"><span data-stu-id="f6757-177">If `collection` contains duplicates, the set will contain one of each unique element.</span></span> <span data-ttu-id="f6757-178">Nie zostanie zgłoszony żaden wyjątek.</span><span class="sxs-lookup"><span data-stu-id="f6757-178">No exception will be thrown.</span></span> <span data-ttu-id="f6757-179">W związku z tym rozmiar zestawu wyników nie jest taki sam jak rozmiar `collection`.</span><span class="sxs-lookup"><span data-stu-id="f6757-179">Therefore, the size of the resulting set is not identical to the size of `collection`.</span></span>  
  
 <span data-ttu-id="f6757-180">Ten konstruktor jest operacją o`n`(), gdzie `n` jest `collection` liczbą elementów w parametrze.</span><span class="sxs-lookup"><span data-stu-id="f6757-180">This constructor is an O(`n`) operation, where `n` is the number of elements in the `collection` parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6757-181">Poniższy przykład używa dostarczone <xref:System.Collections.Generic.IEqualityComparer%601> , aby zezwalać na porównywanie bez uwzględniania wielkości liter w elementach <xref:System.Collections.Generic.HashSet%601> kolekcji typów pojazdów.</span><span class="sxs-lookup"><span data-stu-id="f6757-181">The following example uses a supplied <xref:System.Collections.Generic.IEqualityComparer%601> to allow case-insensitive comparisons on the elements of a  <xref:System.Collections.Generic.HashSet%601> collection of vehicle types.</span></span>  
  
 [!code-cpp[System.Collections.Generic.HashSet_ExceptWith#03](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_ExceptWith/cpp/source2.cpp#03)]
 [!code-csharp[System.Collections.Generic.HashSet_ExceptWith#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_ExceptWith/cs/source2.cs#03)]
 [!code-vb[System.Collections.Generic.HashSet_ExceptWith#03](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_ExceptWith/vb/source2.vb#03)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6757-182"><paramref name="collection" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6757-182"><paramref name="collection" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HashSet (int capacity, System.Collections.Generic.IEqualityComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, class System.Collections.Generic.IEqualityComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, comparer As IEqualityComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HashSet(int capacity, System::Collections::Generic::IEqualityComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.HashSet&lt;'T&gt; : int * System.Collections.Generic.IEqualityComparer&lt;'T&gt; -&gt; System.Collections.Generic.HashSet&lt;'T&gt;" Usage="new System.Collections.Generic.HashSet&lt;'T&gt; (capacity, comparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;T&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="capacity"><span data-ttu-id="f6757-183">Początkowy rozmiar<see cref="T:System.Collections.Generic.HashSet`1" /></span><span class="sxs-lookup"><span data-stu-id="f6757-183">The initial size of the <see cref="T:System.Collections.Generic.HashSet`1" /></span></span></param>
        <param name="comparer"><span data-ttu-id="f6757-184">Implementacja do użycia podczas porównywania wartości w zestawie lub wartości null (Nothing w Visual Basic), aby użyć domyślnej <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementacji dla typu zestawu. <see cref="T:System.Collections.Generic.IEqualityComparer`1" /></span><span class="sxs-lookup"><span data-stu-id="f6757-184">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation to use when comparing values in the set, or null (Nothing in Visual Basic) to use the default <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation for the set type.</span></span></param>
        <summary><span data-ttu-id="f6757-185">Inicjuje nowe wystąpienie <see cref="T:System.Collections.Generic.HashSet`1" /> klasy, która używa określonej metody porównującej równości dla typu zestawu i ma wystarczającą pojemność, aby pomieścić <paramref name="capacity" /> elementy.</span><span class="sxs-lookup"><span data-stu-id="f6757-185">Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class that uses the specified equality comparer for the set type, and has sufficient capacity to accommodate <paramref name="capacity" /> elements.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6757-186">Ponieważ zmiany rozmiaru są stosunkowo kosztowne (wymaga ponownej mieszania), to próbuje zminimalizować konieczność zmiany rozmiaru przez ustawienie początkowej wydajności na podstawie wartości `capacity`.</span><span class="sxs-lookup"><span data-stu-id="f6757-186">Since resizes are relatively expensive (require rehashing), this attempts to minimize the need to resize by setting the initial capacity based on the value of the `capacity`.</span></span>
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected HashSet (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; HashSet(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.HashSet&lt;'T&gt; : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Collections.Generic.HashSet&lt;'T&gt;" Usage="new System.Collections.Generic.HashSet&lt;'T&gt; (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="info"><span data-ttu-id="f6757-187">Obiekt, który zawiera informacje wymagane do <see cref="T:System.Collections.Generic.HashSet`1" /> serializacji obiektu. <see cref="T:System.Runtime.Serialization.SerializationInfo" /></span><span class="sxs-lookup"><span data-stu-id="f6757-187">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object that contains the information required to serialize the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <param name="context"><span data-ttu-id="f6757-188">Struktura, która zawiera źródło i miejsce docelowe serializowanego strumienia skojarzonego <see cref="T:System.Collections.Generic.HashSet`1" /> z obiektem. <see cref="T:System.Runtime.Serialization.StreamingContext" /></span><span class="sxs-lookup"><span data-stu-id="f6757-188">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> structure that contains the source and destination of the serialized stream associated with the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <summary><span data-ttu-id="f6757-189">Inicjuje nowe wystąpienie klasy <see cref="T:System.Collections.Generic.HashSet`1" /> klasy z serializowanych danych.</span><span class="sxs-lookup"><span data-stu-id="f6757-189">Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class with serialized data.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6757-190">Ten konstruktor jest wywoływany podczas deserializacji w celu odtworzenia obiektu, który jest przesyłany przez strumień.</span><span class="sxs-lookup"><span data-stu-id="f6757-190">This constructor is called during deserialization to reconstitute an object that is transmitted over a stream.</span></span> <span data-ttu-id="f6757-191">Aby uzyskać więcej informacji, zobacz [XML oraz serializacji protokołu SOAP](~/docs/standard/serialization/xml-and-soap-serialization.md).</span><span class="sxs-lookup"><span data-stu-id="f6757-191">For more information, see [XML and SOAP Serialization](~/docs/standard/serialization/xml-and-soap-serialization.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public bool Add (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Add(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.Add(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Add (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Add(T item);" />
      <MemberSignature Language="F#" Value="abstract member Add : 'T -&gt; bool&#xA;override this.Add : 'T -&gt; bool" Usage="hashSet.Add item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item"><span data-ttu-id="f6757-192">Element, który ma zostać dodany do zestawu.</span><span class="sxs-lookup"><span data-stu-id="f6757-192">The element to add to the set.</span></span></param>
        <summary><span data-ttu-id="f6757-193">Dodaje określony element do zestawu.</span><span class="sxs-lookup"><span data-stu-id="f6757-193">Adds the specified element to a set.</span></span></summary>
        <returns><span data-ttu-id="f6757-194"><see langword="true" />Jeśli element zostanie dodany do <see cref="T:System.Collections.Generic.HashSet`1" /> obiektu; <see langword="false" /> Jeśli element jest już obecny.</span><span class="sxs-lookup"><span data-stu-id="f6757-194"><see langword="true" /> if the element is added to the <see cref="T:System.Collections.Generic.HashSet`1" /> object; <see langword="false" /> if the element is already present.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6757-195">Jeśli <xref:System.Collections.Generic.HashSet%601.Count%2A> jest już równa pojemności <xref:System.Collections.Generic.HashSet%601> obiektu, pojemność jest automatycznie dostosowywana w celu uwzględnienia nowego elementu.</span><span class="sxs-lookup"><span data-stu-id="f6757-195">If <xref:System.Collections.Generic.HashSet%601.Count%2A> already equals the capacity of the <xref:System.Collections.Generic.HashSet%601> object, the capacity is automatically adjusted to accommodate the new item.</span></span>  
  
 <span data-ttu-id="f6757-196">Jeśli <xref:System.Collections.Generic.HashSet%601.Count%2A> jest mniejsza niż pojemność tablicy wewnętrznej, ta metoda jest operacją o (1).</span><span class="sxs-lookup"><span data-stu-id="f6757-196">If <xref:System.Collections.Generic.HashSet%601.Count%2A> is less than the capacity of the internal array, this method is an O(1) operation.</span></span> <span data-ttu-id="f6757-197">Jeśli rozmiar`n` `n` <xref:System.Collections.Generic.HashSet%601.Count%2A>obiektu należy zmienić, ta metoda jest operacją o (), gdzie is. <xref:System.Collections.Generic.HashSet%601></span><span class="sxs-lookup"><span data-stu-id="f6757-197">If the <xref:System.Collections.Generic.HashSet%601> object must be resized, this method becomes an O(`n`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6757-198">Poniższy przykład ilustruje sposób tworzenia i wypełniania dwóch <xref:System.Collections.Generic.HashSet%601> obiektów.</span><span class="sxs-lookup"><span data-stu-id="f6757-198">The following example demonstrates how to create and populate two <xref:System.Collections.Generic.HashSet%601> objects.</span></span> <span data-ttu-id="f6757-199">Ten przykład jest częścią większego przykładu dostarczonego dla <xref:System.Collections.Generic.HashSet%601.UnionWith%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="f6757-199">This example is part of a larger example provided for the <xref:System.Collections.Generic.HashSet%601.UnionWith%2A> method.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_UnionWith#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/cs/Program.cs#03)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="hashSet.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f6757-200">Usuwa wszystkie elementy z <see cref="T:System.Collections.Generic.HashSet`1" /> obiektu.</span><span class="sxs-lookup"><span data-stu-id="f6757-200">Removes all elements from a <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6757-201"><xref:System.Collections.Generic.HashSet%601.Count%2A>jest ustawiona na zero, a odwołania do innych obiektów z elementów kolekcji również są wydane.</span><span class="sxs-lookup"><span data-stu-id="f6757-201"><xref:System.Collections.Generic.HashSet%601.Count%2A> is set to zero and references to other objects from elements of the collection are also released.</span></span> <span data-ttu-id="f6757-202">Pojemność pozostaje niezmieniona, dopóki nie <xref:System.Collections.Generic.HashSet%601.TrimExcess%2A> zostanie wykonane wywołanie.</span><span class="sxs-lookup"><span data-stu-id="f6757-202">The capacity remains unchanged until a call to <xref:System.Collections.Generic.HashSet%601.TrimExcess%2A> is made.</span></span>  
  
 <span data-ttu-id="f6757-203">Ta metoda jest operacją o`n`(), gdzie `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6757-203">This method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6757-204">Poniższy przykład tworzy i wypełnia <xref:System.Collections.Generic.HashSet%601> kolekcję, a następnie czyści ją i zwalnia pamięć, do której odwołuje się kolekcja.</span><span class="sxs-lookup"><span data-stu-id="f6757-204">The following example creates and populates a <xref:System.Collections.Generic.HashSet%601> collection, then clears it and releases the memory referenced by the collection.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_Clear#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_Clear/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_Clear#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_Clear/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Comparer">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEqualityComparer&lt;T&gt; Comparer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEqualityComparer`1&lt;!T&gt; Comparer" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.HashSet`1.Comparer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Comparer As IEqualityComparer(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEqualityComparer&lt;T&gt; ^ Comparer { System::Collections::Generic::IEqualityComparer&lt;T&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Comparer : System.Collections.Generic.IEqualityComparer&lt;'T&gt;" Usage="System.Collections.Generic.HashSet&lt;'T&gt;.Comparer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEqualityComparer&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f6757-205"><see cref="T:System.Collections.Generic.IEqualityComparer`1" /> Pobiera obiekt, który jest używany do określania równości dla wartości w zestawie.</span><span class="sxs-lookup"><span data-stu-id="f6757-205">Gets the <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> object that is used to determine equality for the values in the set.</span></span></summary>
        <value><span data-ttu-id="f6757-206"><see cref="T:System.Collections.Generic.IEqualityComparer`1" /> Obiekt, który jest używany do określania równości dla wartości w zestawie.</span><span class="sxs-lookup"><span data-stu-id="f6757-206">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> object that is used to determine equality for the values in the set.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6757-207">Pobieranie wartości tej właściwości jest operacją O(1).</span><span class="sxs-lookup"><span data-stu-id="f6757-207">Retrieving the value of this property is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.Contains(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(T item);" />
      <MemberSignature Language="F#" Value="abstract member Contains : 'T -&gt; bool&#xA;override this.Contains : 'T -&gt; bool" Usage="hashSet.Contains item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item"><span data-ttu-id="f6757-208">Element, który ma zostać zlokalizowany w <see cref="T:System.Collections.Generic.HashSet`1" /> obiekcie.</span><span class="sxs-lookup"><span data-stu-id="f6757-208">The element to locate in the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <summary><span data-ttu-id="f6757-209">Określa, czy <see cref="T:System.Collections.Generic.HashSet`1" /> obiekt zawiera określony element.</span><span class="sxs-lookup"><span data-stu-id="f6757-209">Determines whether a <see cref="T:System.Collections.Generic.HashSet`1" /> object contains the specified element.</span></span></summary>
        <returns><span data-ttu-id="f6757-210"><see langword="true" />Jeśli obiekt zawiera określony element; <see langword="false" />w przeciwnym razie. <see cref="T:System.Collections.Generic.HashSet`1" /></span><span class="sxs-lookup"><span data-stu-id="f6757-210"><see langword="true" /> if the <see cref="T:System.Collections.Generic.HashSet`1" /> object contains the specified element; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6757-211">Ta metoda jest operacją O(1).</span><span class="sxs-lookup"><span data-stu-id="f6757-211">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6757-212">Poniższy przykład ilustruje sposób usuwania wartości z <xref:System.Collections.Generic.HashSet%601> kolekcji <xref:System.Collections.Generic.HashSet%601.Remove%2A> przy użyciu metody.</span><span class="sxs-lookup"><span data-stu-id="f6757-212">The following example demonstrates how to remove values from a <xref:System.Collections.Generic.HashSet%601> collection using the <xref:System.Collections.Generic.HashSet%601.Remove%2A> method.</span></span> <span data-ttu-id="f6757-213">W tym przykładzie <xref:System.Collections.Generic.HashSet%601.Contains%2A> metoda weryfikuje, czy zestaw zawiera wartość przed usunięciem.</span><span class="sxs-lookup"><span data-stu-id="f6757-213">In this example, the <xref:System.Collections.Generic.HashSet%601.Contains%2A> method verifies that the set contains a value before removing it.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_RemoveWhere#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_RemoveWhere/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_RemoveWhere#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_RemoveWhere/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="f6757-214">Kopiuje elementy <see cref="T:System.Collections.Generic.HashSet`1" /> kolekcji do tablicy.</span><span class="sxs-lookup"><span data-stu-id="f6757-214">Copies the elements of a <see cref="T:System.Collections.Generic.HashSet`1" /> collection to an array.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.CopyTo(`0[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : 'T[] -&gt; unit" Usage="hashSet.CopyTo array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="f6757-215">Jednowymiarowa tablica, która jest miejscem docelowym elementów skopiowanych z <see cref="T:System.Collections.Generic.HashSet`1" /> obiektu.</span><span class="sxs-lookup"><span data-stu-id="f6757-215">The one-dimensional array that is the destination of the elements copied from the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span> <span data-ttu-id="f6757-216">Tablica musi mieć indeksowane zaczynające od zera.</span><span class="sxs-lookup"><span data-stu-id="f6757-216">The array must have zero-based indexing.</span></span></param>
        <summary><span data-ttu-id="f6757-217">Kopiuje elementy <see cref="T:System.Collections.Generic.HashSet`1" /> obiektu do tablicy.</span><span class="sxs-lookup"><span data-stu-id="f6757-217">Copies the elements of a <see cref="T:System.Collections.Generic.HashSet`1" /> object to an array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6757-218">Ta metoda jest operacją o`n`(), gdzie `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6757-218">This method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6757-219"><paramref name="array" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6757-219"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(!T[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.CopyTo(`0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T(), arrayIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(cli::array &lt;T&gt; ^ array, int arrayIndex);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : 'T[] * int -&gt; unit&#xA;override this.CopyTo : 'T[] * int -&gt; unit" Usage="hashSet.CopyTo (array, arrayIndex)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="f6757-220">Jednowymiarowa tablica, która jest miejscem docelowym elementów skopiowanych z <see cref="T:System.Collections.Generic.HashSet`1" /> obiektu.</span><span class="sxs-lookup"><span data-stu-id="f6757-220">The one-dimensional array that is the destination of the elements copied from the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span> <span data-ttu-id="f6757-221">Tablica musi mieć indeksowane zaczynające od zera.</span><span class="sxs-lookup"><span data-stu-id="f6757-221">The array must have zero-based indexing.</span></span></param>
        <param name="arrayIndex"><span data-ttu-id="f6757-222">Indeks (liczony od zera) <paramref name="array" /> , w którym rozpoczyna się kopiowanie.</span><span class="sxs-lookup"><span data-stu-id="f6757-222">The zero-based index in <paramref name="array" /> at which copying begins.</span></span></param>
        <summary><span data-ttu-id="f6757-223">Kopiuje elementy <see cref="T:System.Collections.Generic.HashSet`1" /> obiektu do tablicy, rozpoczynając od określonego indeksu tablicy.</span><span class="sxs-lookup"><span data-stu-id="f6757-223">Copies the elements of a <see cref="T:System.Collections.Generic.HashSet`1" /> object to an array, starting at the specified array index.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6757-224">Ta metoda jest operacją o`n`(), gdzie `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6757-224">This method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6757-225"><paramref name="array" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6757-225"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f6757-226"><paramref name="arrayIndex" />jest mniejsza niż 0.</span><span class="sxs-lookup"><span data-stu-id="f6757-226"><paramref name="arrayIndex" /> is less than 0.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f6757-227"><paramref name="arrayIndex" />jest większa niż długość miejsca docelowego <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="f6757-227"><paramref name="arrayIndex" /> is greater than the length of the destination <paramref name="array" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array, int arrayIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(!T[] array, int32 arrayIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.CopyTo(`0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T(), arrayIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;T&gt; ^ array, int arrayIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : 'T[] * int * int -&gt; unit" Usage="hashSet.CopyTo (array, arrayIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="f6757-228">Jednowymiarowa tablica, która jest miejscem docelowym elementów skopiowanych z <see cref="T:System.Collections.Generic.HashSet`1" /> obiektu.</span><span class="sxs-lookup"><span data-stu-id="f6757-228">The one-dimensional array that is the destination of the elements copied from the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span> <span data-ttu-id="f6757-229">Tablica musi mieć indeksowane zaczynające od zera.</span><span class="sxs-lookup"><span data-stu-id="f6757-229">The array must have zero-based indexing.</span></span></param>
        <param name="arrayIndex"><span data-ttu-id="f6757-230">Indeks (liczony od zera) <paramref name="array" /> , w którym rozpoczyna się kopiowanie.</span><span class="sxs-lookup"><span data-stu-id="f6757-230">The zero-based index in <paramref name="array" /> at which copying begins.</span></span></param>
        <param name="count"><span data-ttu-id="f6757-231">Liczba elementów do skopiowania <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="f6757-231">The number of elements to copy to <paramref name="array" />.</span></span></param>
        <summary><span data-ttu-id="f6757-232">Kopiuje określoną liczbę elementów <see cref="T:System.Collections.Generic.HashSet`1" /> obiektu do tablicy, rozpoczynając od określonego indeksu tablicy.</span><span class="sxs-lookup"><span data-stu-id="f6757-232">Copies the specified number of elements of a <see cref="T:System.Collections.Generic.HashSet`1" /> object to an array, starting at the specified array index.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6757-233">Ta metoda jest operacją o`n`(), gdzie `n` is `count`.</span><span class="sxs-lookup"><span data-stu-id="f6757-233">This method is an O(`n`) operation, where `n` is `count`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6757-234"><paramref name="array" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6757-234"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f6757-235"><paramref name="arrayIndex" />jest mniejsza niż 0.</span><span class="sxs-lookup"><span data-stu-id="f6757-235"><paramref name="arrayIndex" /> is less than 0.</span></span>  
  
<span data-ttu-id="f6757-236">—lub—</span><span class="sxs-lookup"><span data-stu-id="f6757-236">-or-</span></span> 
 <span data-ttu-id="f6757-237"><paramref name="count" />jest mniejsza niż 0.</span><span class="sxs-lookup"><span data-stu-id="f6757-237"><paramref name="count" /> is less than 0.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="f6757-238"><paramref name="arrayIndex" />jest większa niż długość miejsca docelowego <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="f6757-238"><paramref name="arrayIndex" /> is greater than the length of the destination <paramref name="array" />.</span></span>  
  
<span data-ttu-id="f6757-239">—lub—</span><span class="sxs-lookup"><span data-stu-id="f6757-239">-or-</span></span> 
 <span data-ttu-id="f6757-240"><paramref name="count" />jest większa niż dostępne miejsce od <paramref name="index" /> do końca miejsca docelowego. <paramref name="array" /></span><span class="sxs-lookup"><span data-stu-id="f6757-240"><paramref name="count" /> is greater than the available space from the <paramref name="index" /> to the end of the destination <paramref name="array" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.HashSet`1.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.Generic.HashSet&lt;'T&gt;.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyCollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f6757-241">Pobiera liczbę elementów zawartych w zestawie.</span><span class="sxs-lookup"><span data-stu-id="f6757-241">Gets the number of elements that are contained in a set.</span></span></summary>
        <value><span data-ttu-id="f6757-242">Liczba elementów, które są zawarte w zestawie.</span><span class="sxs-lookup"><span data-stu-id="f6757-242">The number of elements that are contained in the set.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6757-243">Pojemność <xref:System.Collections.Generic.HashSet%601> obiektu to liczba elementów, które mogą być przechowywane w obiekcie.</span><span class="sxs-lookup"><span data-stu-id="f6757-243">The capacity of a <xref:System.Collections.Generic.HashSet%601> object is the number of elements that the object can hold.</span></span> <span data-ttu-id="f6757-244">Pojemność <xref:System.Collections.Generic.HashSet%601> obiektu jest automatycznie zwiększana, gdy elementy są dodawane do obiektu.</span><span class="sxs-lookup"><span data-stu-id="f6757-244">A <xref:System.Collections.Generic.HashSet%601> object's capacity automatically increases as elements are added to the object.</span></span>  
  
 <span data-ttu-id="f6757-245">Pojemność jest zawsze większa lub równa <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6757-245">The capacity is always greater than or equal to <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span> <span data-ttu-id="f6757-246">W <xref:System.Collections.Generic.HashSet%601.Count%2A> przypadku przekroczenia pojemności przy dodawaniu elementów pojemność jest ustawiana na pierwszy początkowy numer, który jest większy od podwójnej poprzedniej pojemności.</span><span class="sxs-lookup"><span data-stu-id="f6757-246">If <xref:System.Collections.Generic.HashSet%601.Count%2A> exceeds the capacity while adding elements, the capacity is set to the first prime number that is greater than double the previous capacity.</span></span>  
  
 <span data-ttu-id="f6757-247">Pobieranie wartości tej właściwości jest operacją O(1).</span><span class="sxs-lookup"><span data-stu-id="f6757-247">Retrieving the value of this property is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6757-248">Poniższy przykład ilustruje sposób tworzenia, wypełniania i manipulowania dwoma <xref:System.Collections.Generic.HashSet%601> obiektami.</span><span class="sxs-lookup"><span data-stu-id="f6757-248">The following example demonstrates how to create, populate, and manipulate two <xref:System.Collections.Generic.HashSet%601> objects.</span></span> <span data-ttu-id="f6757-249">W tym przykładzie zarówno zawartość zestawu, jak i <xref:System.Collections.Generic.HashSet%601.Count%2A> wyświetlana w konsoli.</span><span class="sxs-lookup"><span data-stu-id="f6757-249">In this example, both the contents of the set and <xref:System.Collections.Generic.HashSet%601.Count%2A> display to the console.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_UnionWith#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/cs/Program.cs#01)]
 [!code-vb[System.Collections.Generic.HashSet_UnionWith#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/vb/Program.vb#01)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateSetComparer">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEqualityComparer&lt;System.Collections.Generic.HashSet&lt;T&gt;&gt; CreateSetComparer ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEqualityComparer`1&lt;class System.Collections.Generic.HashSet`1&lt;!T&gt;&gt; CreateSetComparer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.CreateSetComparer" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateSetComparer () As IEqualityComparer(Of HashSet(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEqualityComparer&lt;System::Collections::Generic::HashSet&lt;T&gt; ^&gt; ^ CreateSetComparer();" />
      <MemberSignature Language="F#" Value="static member CreateSetComparer : unit -&gt; System.Collections.Generic.IEqualityComparer&lt;System.Collections.Generic.HashSet&lt;'T&gt;&gt;" Usage="System.Collections.Generic.HashSet&lt;'T&gt;.CreateSetComparer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEqualityComparer&lt;System.Collections.Generic.HashSet&lt;T&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f6757-250">Zwraca obiekt, który może być używany do testowania <see cref="T:System.Collections.Generic.HashSet`1" /> równości obiektu. <see cref="T:System.Collections.IEqualityComparer" /></span><span class="sxs-lookup"><span data-stu-id="f6757-250">Returns an <see cref="T:System.Collections.IEqualityComparer" /> object that can be used for equality testing of a <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></summary>
        <returns><span data-ttu-id="f6757-251">Obiekt, który może służyć do dokładnego testowania <see cref="T:System.Collections.Generic.HashSet`1" /> równości dla obiektu. <see cref="T:System.Collections.IEqualityComparer" /></span><span class="sxs-lookup"><span data-stu-id="f6757-251">An <see cref="T:System.Collections.IEqualityComparer" /> object that can be used for deep equality testing of the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6757-252"><xref:System.Collections.IEqualityComparer> Obiekt sprawdza równość tylko na jednym poziomie. można jednak łączyć się ze sobą za pomocą porównań na dodatkowych poziomach w celu przeprowadzenia dokładniejszych testów równości.</span><span class="sxs-lookup"><span data-stu-id="f6757-252">The <xref:System.Collections.IEqualityComparer> object checks for equality at only one level; however, you can chain together comparers at additional levels to perform deeper equality testing.</span></span>  
  
 <span data-ttu-id="f6757-253">Wywołanie tej metody jest operacją O (1).</span><span class="sxs-lookup"><span data-stu-id="f6757-253">Calling this method is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnsureCapacity">
      <MemberSignature Language="C#" Value="public int EnsureCapacity (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EnsureCapacity(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.EnsureCapacity(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function EnsureCapacity (capacity As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EnsureCapacity(int capacity);" />
      <MemberSignature Language="F#" Value="member this.EnsureCapacity : int -&gt; int" Usage="hashSet.EnsureCapacity capacity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="capacity"><span data-ttu-id="f6757-254">Minimalna pojemność do zapewnienia.</span><span class="sxs-lookup"><span data-stu-id="f6757-254">The minimum capacity to ensure.</span></span></param>
        <summary><span data-ttu-id="f6757-255">Zapewnia, że ten zestaw skrótów może zawierać określoną liczbę elementów bez wzrostu.</span><span class="sxs-lookup"><span data-stu-id="f6757-255">Ensures that this hash set can hold the specified number of elements without growing.</span></span></summary>
        <returns><span data-ttu-id="f6757-256">Nowa pojemność tego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="f6757-256">The new capacity of this instance.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="f6757-257"><paramref name="capacity" />jest mniejsza od zera.</span><span class="sxs-lookup"><span data-stu-id="f6757-257"><paramref name="capacity" /> is less than zero.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ExceptWith">
      <MemberSignature Language="C#" Value="public void ExceptWith (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ExceptWith(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExceptWith (other As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ExceptWith(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member ExceptWith : seq&lt;'T&gt; -&gt; unit&#xA;override this.ExceptWith : seq&lt;'T&gt; -&gt; unit" Usage="hashSet.ExceptWith other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="f6757-258">Kolekcja elementów do usunięcia z <see cref="T:System.Collections.Generic.HashSet`1" /> obiektu.</span><span class="sxs-lookup"><span data-stu-id="f6757-258">The collection of items to remove from the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <summary><span data-ttu-id="f6757-259">Usuwa wszystkie elementy w określonej kolekcji z bieżącego <see cref="T:System.Collections.Generic.HashSet`1" /> obiektu.</span><span class="sxs-lookup"><span data-stu-id="f6757-259">Removes all elements in the specified collection from the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6757-260"><xref:System.Collections.Generic.HashSet%601.ExceptWith%2A> Metoda jest odpowiednikiem odejmowania zestawu matematycznego.</span><span class="sxs-lookup"><span data-stu-id="f6757-260">The <xref:System.Collections.Generic.HashSet%601.ExceptWith%2A> method is the equivalent of mathematical set subtraction.</span></span>  
  
 <span data-ttu-id="f6757-261">Ta metoda jest operacją o`n`(), gdzie `n` jest `other` liczbą elementów w parametrze.</span><span class="sxs-lookup"><span data-stu-id="f6757-261">This method is an O(`n`) operation, where `n` is the number of elements in the `other` parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6757-262">Poniższy przykład tworzy dwie <xref:System.Collections.Generic.HashSet%601> kolekcje z nakładającymi się zestawami danych.</span><span class="sxs-lookup"><span data-stu-id="f6757-262">The following example creates two <xref:System.Collections.Generic.HashSet%601> collections with overlapping sets of data.</span></span> <span data-ttu-id="f6757-263">Dolny zakres wartości jest następnie usuwany z większego zestawu przy użyciu <xref:System.Collections.Generic.HashSet%601.ExceptWith%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="f6757-263">The lower range of values is then removed from the larger set using the <xref:System.Collections.Generic.HashSet%601.ExceptWith%2A> method.</span></span>  
  
 [!code-cpp[System.Collections.Generic.HashSet_ExceptWith#02](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_ExceptWith/cpp/program.cpp#02)]
 [!code-csharp[System.Collections.Generic.HashSet_ExceptWith#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_ExceptWith/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_ExceptWith#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_ExceptWith/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6757-264"><paramref name="other" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6757-264"><paramref name="other" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.HashSet&lt;T&gt;.Enumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Collections.Generic.HashSet`1/Enumerator&lt;!T&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As HashSet(Of T).Enumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::HashSet&lt;T&gt;::Enumerator GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; System.Collections.Generic.HashSet&lt;'T&gt;.Enumerator" Usage="hashSet.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.HashSet&lt;T&gt;+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f6757-265">Zwraca moduł wyliczający, który wykonuje iterację przez <see cref="T:System.Collections.Generic.HashSet`1" /> obiekt.</span><span class="sxs-lookup"><span data-stu-id="f6757-265">Returns an enumerator that iterates through a <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></summary>
        <returns><span data-ttu-id="f6757-266"><see cref="T:System.Collections.Generic.HashSet`1.Enumerator" /> Obiekt<see cref="T:System.Collections.Generic.HashSet`1" /> dla obiektu.</span><span class="sxs-lookup"><span data-stu-id="f6757-266">A <see cref="T:System.Collections.Generic.HashSet`1.Enumerator" /> object for the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6757-267">`foreach` Instrukcja C# języka(`for each` C++w VisualBasic)ukrywazłożonośćmodułówwyliczających.`For Each`</span><span class="sxs-lookup"><span data-stu-id="f6757-267">The `foreach` statement of the C# language (`for each` in C++, `For Each` in Visual Basic) hides the complexity of enumerators.</span></span> <span data-ttu-id="f6757-268">W związku z `foreach` tym użycie jest zalecane zamiast bezpośredniego manipulowania modułem wyliczania.</span><span class="sxs-lookup"><span data-stu-id="f6757-268">Therefore, using `foreach` is recommended instead of directly manipulating the enumerator.</span></span>  
  
 <span data-ttu-id="f6757-269">Moduły wyliczające mogą służyć do odczytu danych w kolekcji, ale nie można za ich pomocą modyfikować kolekcji źródłowej.</span><span class="sxs-lookup"><span data-stu-id="f6757-269">Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</span></span>  
  
 <span data-ttu-id="f6757-270">Początkowo moduł wyliczający jest umieszczony przed pierwszym elementem w kolekcji.</span><span class="sxs-lookup"><span data-stu-id="f6757-270">Initially, the enumerator is positioned before the first element in the collection.</span></span> <span data-ttu-id="f6757-271">W tym miejscu <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> właściwość jest niezdefiniowana.</span><span class="sxs-lookup"><span data-stu-id="f6757-271">At this position, the <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> property is undefined.</span></span> <span data-ttu-id="f6757-272">W związku z tym, należy <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> wywołać metodę, aby wykonać przechodzenie modułu wyliczającego do pierwszego elementu kolekcji przed odczytem <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A>wartości.</span><span class="sxs-lookup"><span data-stu-id="f6757-272">Therefore, you must call the <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> method to advance the enumerator to the first element of the collection before reading the value of <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A>.</span></span>  
  
 <span data-ttu-id="f6757-273">Właściwość zwraca ten sam obiekt, dopóki <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> nie zostanie wywołana. <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A></span><span class="sxs-lookup"><span data-stu-id="f6757-273">The <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> property returns the same object until <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> is called.</span></span> <span data-ttu-id="f6757-274"><xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A>ustawia <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> do następnego elementu.</span><span class="sxs-lookup"><span data-stu-id="f6757-274"><xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> sets <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> to the next element.</span></span>  
  
 <span data-ttu-id="f6757-275">Jeśli <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> przekazuje koniec kolekcji, moduł wyliczający jest umieszczony po ostatnim elemencie w kolekcji i <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> zwraca `false`.</span><span class="sxs-lookup"><span data-stu-id="f6757-275">If <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> passes the end of the collection, the enumerator is positioned after the last element in the collection and <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> returns `false`.</span></span> <span data-ttu-id="f6757-276">Gdy moduł wyliczający znajduje się w tym miejscu, kolejne <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> wywołania również `false`zwracają.</span><span class="sxs-lookup"><span data-stu-id="f6757-276">When the enumerator is at this position, subsequent calls to <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> also return `false`.</span></span> <span data-ttu-id="f6757-277">Jeśli ostatnie wywołanie <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> zwrócone `false`, <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> nie jest zdefiniowane.</span><span class="sxs-lookup"><span data-stu-id="f6757-277">If the last call to <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> returned `false`, <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> is undefined.</span></span> <span data-ttu-id="f6757-278">Nie można ponownie <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> ustawić na pierwszy element kolekcji; zamiast tego należy utworzyć nowy obiekt modułu wyliczającego.</span><span class="sxs-lookup"><span data-stu-id="f6757-278">You cannot set <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> to the first element of the collection again; you must create a new enumerator object instead.</span></span>  
  
 <span data-ttu-id="f6757-279">Moduł wyliczający zachowuje ważność tak długo, jak długo kolekcja pozostaje niezmieniona.</span><span class="sxs-lookup"><span data-stu-id="f6757-279">An enumerator remains valid as long as the collection remains unchanged.</span></span> <span data-ttu-id="f6757-280">Jeśli w kolekcji zostaną wprowadzone zmiany, takie jak dodanie, zmodyfikowanie lub usunięcie elementów, moduł wyliczający jest nieodwracalnie unieważniony i następne wywołanie <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> lub <xref:System.Collections.Generic.HashSet%601.Enumerator.System%23Collections%23IEnumerator%23Reset%2A> wygeneruje <xref:System.InvalidOperationException>.</span><span class="sxs-lookup"><span data-stu-id="f6757-280">If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and the next call to <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> or <xref:System.Collections.Generic.HashSet%601.Enumerator.System%23Collections%23IEnumerator%23Reset%2A> throws an <xref:System.InvalidOperationException>.</span></span>  
  
 <span data-ttu-id="f6757-281">Moduł wyliczający nie ma wyłącznego dostępu do kolekcji, w związku z tym wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość.</span><span class="sxs-lookup"><span data-stu-id="f6757-281">The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread-safe procedure.</span></span> <span data-ttu-id="f6757-282">Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania.</span><span class="sxs-lookup"><span data-stu-id="f6757-282">To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration.</span></span>  <span data-ttu-id="f6757-283">Aby zezwolić wielu wątkom na dostęp do kolekcji w celu odczytu i zapisu danych, należy zaimplementować własny mechanizm synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="f6757-283">To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.</span></span>  
  
 <span data-ttu-id="f6757-284">Domyślne implementacje kolekcji w <xref:System.Collections.Generic?displayProperty=nameWithType> przestrzeni nazw nie są zsynchronizowane.</span><span class="sxs-lookup"><span data-stu-id="f6757-284">Default implementations of collections in the <xref:System.Collections.Generic?displayProperty=nameWithType> namespace are not synchronized.</span></span>  
  
 <span data-ttu-id="f6757-285">Ta metoda jest operacją O(1).</span><span class="sxs-lookup"><span data-stu-id="f6757-285">This method is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="hashSet.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="info"><span data-ttu-id="f6757-286">Obiekt, który zawiera informacje wymagane do <see cref="T:System.Collections.Generic.HashSet`1" /> serializacji obiektu. <see cref="T:System.Runtime.Serialization.SerializationInfo" /></span><span class="sxs-lookup"><span data-stu-id="f6757-286">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object that contains the information required to serialize the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <param name="context"><span data-ttu-id="f6757-287">Struktura, która zawiera źródło i miejsce docelowe serializowanego strumienia skojarzonego <see cref="T:System.Collections.Generic.HashSet`1" /> z obiektem. <see cref="T:System.Runtime.Serialization.StreamingContext" /></span><span class="sxs-lookup"><span data-stu-id="f6757-287">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> structure that contains the source and destination of the serialized stream associated with the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <summary><span data-ttu-id="f6757-288">Implementuje interfejs i zwraca dane, które są konieczne do <see cref="T:System.Collections.Generic.HashSet`1" /> serializacji obiektu. <see cref="T:System.Runtime.Serialization.ISerializable" /></span><span class="sxs-lookup"><span data-stu-id="f6757-288">Implements the <see cref="T:System.Runtime.Serialization.ISerializable" /> interface and returns the data needed to serialize a <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6757-289">Wywołanie tej metody jest operacją o`n`(), gdzie `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6757-289">Calling this method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6757-290"><paramref name="info" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6757-290"><paramref name="info" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="f6757-291">w celu świadczenia usług serializacji.</span><span class="sxs-lookup"><span data-stu-id="f6757-291">for providing serialization services.</span></span> <span data-ttu-id="f6757-292">Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span><span class="sxs-lookup"><span data-stu-id="f6757-292">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span></span> <span data-ttu-id="f6757-293">Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" /></span><span class="sxs-lookup"><span data-stu-id="f6757-293">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="IntersectWith">
      <MemberSignature Language="C#" Value="public void IntersectWith (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void IntersectWith(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.IntersectWith(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub IntersectWith (other As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void IntersectWith(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member IntersectWith : seq&lt;'T&gt; -&gt; unit&#xA;override this.IntersectWith : seq&lt;'T&gt; -&gt; unit" Usage="hashSet.IntersectWith other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.IntersectWith(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="f6757-294">Kolekcja do porównania z bieżącym <see cref="T:System.Collections.Generic.HashSet`1" /> obiektem.</span><span class="sxs-lookup"><span data-stu-id="f6757-294">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <summary><span data-ttu-id="f6757-295">Modyfikuje bieżący <see cref="T:System.Collections.Generic.HashSet`1" /> obiekt, aby zawierał tylko elementy, które są obecne w tym obiekcie i w określonej kolekcji.</span><span class="sxs-lookup"><span data-stu-id="f6757-295">Modifies the current <see cref="T:System.Collections.Generic.HashSet`1" /> object to contain only elements that are present in that object and in the specified collection.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6757-296">Jeśli kolekcja reprezentowana `other` przez parametr <xref:System.Collections.Generic.HashSet%601> jest kolekcją z tym samym modułem porównującym równość co bieżący <xref:System.Collections.Generic.HashSet%601> obiekt, ta metoda jest operacją o`n`().</span><span class="sxs-lookup"><span data-stu-id="f6757-296">If the collection represented by the `other` parameter is a <xref:System.Collections.Generic.HashSet%601> collection with the same equality comparer as the current <xref:System.Collections.Generic.HashSet%601> object, this method is an O(`n`) operation.</span></span> <span data-ttu-id="f6757-297">W przeciwnym razie ta metoda jest operacją`n`O ( <xref:System.Collections.Generic.HashSet%601.Count%2A> `other` `n` `m` + ), gdzie is `m` i jest liczbą elementów w.</span><span class="sxs-lookup"><span data-stu-id="f6757-297">Otherwise, this method is an O(`n` + `m`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A> and `m` is the number of elements in `other`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6757-298"><paramref name="other" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6757-298"><paramref name="other" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsProperSubsetOf">
      <MemberSignature Language="C#" Value="public bool IsProperSubsetOf (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsProperSubsetOf(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function IsProperSubsetOf (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsProperSubsetOf(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member IsProperSubsetOf : seq&lt;'T&gt; -&gt; bool&#xA;override this.IsProperSubsetOf : seq&lt;'T&gt; -&gt; bool" Usage="hashSet.IsProperSubsetOf other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="f6757-299">Kolekcja do porównania z bieżącym <see cref="T:System.Collections.Generic.HashSet`1" /> obiektem.</span><span class="sxs-lookup"><span data-stu-id="f6757-299">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <summary><span data-ttu-id="f6757-300">Określa, czy <see cref="T:System.Collections.Generic.HashSet`1" /> obiekt jest prawidłowym podzbiorem określonej kolekcji.</span><span class="sxs-lookup"><span data-stu-id="f6757-300">Determines whether a <see cref="T:System.Collections.Generic.HashSet`1" /> object is a proper subset of the specified collection.</span></span></summary>
        <returns><span data-ttu-id="f6757-301"><see langword="true" />Jeśli obiekt jest prawidłowym <paramref name="other" />podzbiorem; w przeciwnym <see langword="false" />razie. <see cref="T:System.Collections.Generic.HashSet`1" /></span><span class="sxs-lookup"><span data-stu-id="f6757-301"><see langword="true" /> if the <see cref="T:System.Collections.Generic.HashSet`1" /> object is a proper subset of <paramref name="other" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6757-302">Pusty zestaw jest poprawnym podzbiorem każdej innej kolekcji.</span><span class="sxs-lookup"><span data-stu-id="f6757-302">An empty set is a proper subset of any other collection.</span></span> <span data-ttu-id="f6757-303">W związku z tym ta `true` Metoda zwraca wartość, jeśli kolekcja reprezentowana <xref:System.Collections.Generic.HashSet%601> przez bieżący `other` obiekt jest pusta, chyba że parametr jest również pustym zestawem.</span><span class="sxs-lookup"><span data-stu-id="f6757-303">Therefore, this method returns `true` if the collection represented by the current <xref:System.Collections.Generic.HashSet%601> object is empty unless the `other` parameter is also an empty set.</span></span>  
  
 <span data-ttu-id="f6757-304">Ta metoda zawsze zwraca `false` wartość <xref:System.Collections.Generic.HashSet%601.Count%2A> , jeśli jest większa lub równa liczbie elementów w `other`.</span><span class="sxs-lookup"><span data-stu-id="f6757-304">This method always returns `false` if <xref:System.Collections.Generic.HashSet%601.Count%2A> is greater than or equal to the number of elements in `other`.</span></span>  
  
 <span data-ttu-id="f6757-305">Jeśli kolekcja reprezentowana `other` przez program <xref:System.Collections.Generic.HashSet%601> jest kolekcją z tym samym modułem porównującym równość <xref:System.Collections.Generic.HashSet%601> co bieżący obiekt, ta metoda jest operacją`n`o ().</span><span class="sxs-lookup"><span data-stu-id="f6757-305">If the collection represented by `other` is a <xref:System.Collections.Generic.HashSet%601> collection with the same equality comparer as the current <xref:System.Collections.Generic.HashSet%601> object, then this method is an O(`n`) operation.</span></span> <span data-ttu-id="f6757-306">W przeciwnym razie ta metoda jest operacją`n`O ( <xref:System.Collections.Generic.HashSet%601.Count%2A> `other` `n` `m` + ), gdzie is `m` i jest liczbą elementów w.</span><span class="sxs-lookup"><span data-stu-id="f6757-306">Otherwise, this method is an O(`n` + `m`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A> and `m` is the number of elements in `other`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6757-307">Poniższy przykład tworzy dwa <xref:System.Collections.Generic.HashSet%601> różne obiekty i porównuje je ze sobą.</span><span class="sxs-lookup"><span data-stu-id="f6757-307">The following example creates two disparate <xref:System.Collections.Generic.HashSet%601> objects and compares them to each other.</span></span> <span data-ttu-id="f6757-308">W tym przykładzie `lowNumbers` jest podzbiorem i prawidłowym `allNumbers` podzbiorem do `allNumbers` czasu modyfikacji, przy użyciu <xref:System.Collections.Generic.HashSet%601.IntersectWith%2A> metody, aby zawierała tylko wartości, które są obecne w obu zestawach.</span><span class="sxs-lookup"><span data-stu-id="f6757-308">In this example, `lowNumbers` is both a subset and a proper subset of `allNumbers` until `allNumbers` is modified, using the <xref:System.Collections.Generic.HashSet%601.IntersectWith%2A> method, to contain only values that are present in both sets.</span></span> <span data-ttu-id="f6757-309">Jeden `allNumbers` raz `lowNumbers` i są identyczne `lowNumbers` , jest nadal podzbiorem `allNumbers` , ale nie jest już poprawnym podzbiorem.</span><span class="sxs-lookup"><span data-stu-id="f6757-309">Once `allNumbers` and `lowNumbers` are identical, `lowNumbers` is still a subset of `allNumbers` but is no longer a proper subset.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6757-310"><paramref name="other" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6757-310"><paramref name="other" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsProperSupersetOf">
      <MemberSignature Language="C#" Value="public bool IsProperSupersetOf (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsProperSupersetOf(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function IsProperSupersetOf (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsProperSupersetOf(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member IsProperSupersetOf : seq&lt;'T&gt; -&gt; bool&#xA;override this.IsProperSupersetOf : seq&lt;'T&gt; -&gt; bool" Usage="hashSet.IsProperSupersetOf other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="f6757-311">Kolekcja do porównania z bieżącym <see cref="T:System.Collections.Generic.HashSet`1" /> obiektem.</span><span class="sxs-lookup"><span data-stu-id="f6757-311">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <summary><span data-ttu-id="f6757-312">Określa, czy <see cref="T:System.Collections.Generic.HashSet`1" /> obiekt jest prawidłowym nadzbiorem określonej kolekcji.</span><span class="sxs-lookup"><span data-stu-id="f6757-312">Determines whether a <see cref="T:System.Collections.Generic.HashSet`1" /> object is a proper superset of the specified collection.</span></span></summary>
        <returns><span data-ttu-id="f6757-313"><see langword="true" />Jeśli obiekt jest prawidłowym <paramref name="other" />nadzbiorem; w przeciwnym <see langword="false" />razie. <see cref="T:System.Collections.Generic.HashSet`1" /></span><span class="sxs-lookup"><span data-stu-id="f6757-313"><see langword="true" /> if the <see cref="T:System.Collections.Generic.HashSet`1" /> object is a proper superset of <paramref name="other" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6757-314">Pusty zestaw jest poprawnym nadzbiorem każdej innej kolekcji.</span><span class="sxs-lookup"><span data-stu-id="f6757-314">An empty set is a proper superset of any other collection.</span></span> <span data-ttu-id="f6757-315">W związku z tym ta `true` Metoda zwraca wartość, jeśli kolekcja `other` reprezentowana przez parametr jest pusta, <xref:System.Collections.Generic.HashSet%601> chyba że bieżąca kolekcja jest również pusta.</span><span class="sxs-lookup"><span data-stu-id="f6757-315">Therefore, this method returns `true` if the collection represented by the `other` parameter is empty unless the current <xref:System.Collections.Generic.HashSet%601> collection is also empty.</span></span>  
  
 <span data-ttu-id="f6757-316">Ta metoda zawsze zwraca `false` wartość <xref:System.Collections.Generic.HashSet%601.Count%2A> , jeśli jest mniejsza lub równa liczbie elementów w `other`.</span><span class="sxs-lookup"><span data-stu-id="f6757-316">This method always returns `false` if <xref:System.Collections.Generic.HashSet%601.Count%2A> is less than or equal to the number of elements in `other`.</span></span>  
  
 <span data-ttu-id="f6757-317">Jeśli kolekcja reprezentowana `other` przez program <xref:System.Collections.Generic.HashSet%601> jest kolekcją z tym samym modułem porównującym równość <xref:System.Collections.Generic.HashSet%601> co bieżący obiekt, ta metoda jest operacją o (`n`).</span><span class="sxs-lookup"><span data-stu-id="f6757-317">If the collection represented by `other` is a <xref:System.Collections.Generic.HashSet%601> collection with the same equality comparer as the current <xref:System.Collections.Generic.HashSet%601> object, this method is an O(`n`) operation.</span></span> <span data-ttu-id="f6757-318">W przeciwnym razie ta metoda jest operacją`n`o ( `other` `m` `n`  + `m`), gdzie jest liczbą elementów w i jest <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6757-318">Otherwise, this method is an O(`n` + `m`) operation, where `n` is the number of elements in `other` and `m` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6757-319">Poniższy przykład tworzy dwa <xref:System.Collections.Generic.HashSet%601> różne obiekty i porównuje je ze sobą.</span><span class="sxs-lookup"><span data-stu-id="f6757-319">The following example creates two disparate <xref:System.Collections.Generic.HashSet%601> objects and compares them to each other.</span></span> <span data-ttu-id="f6757-320">W tym przykładzie `allNumbers` jest to zarówno nadzbiór, jak i właściwy `lowNumbers` nadzbiór `allNumbers` , dopóki jest modyfikowany <xref:System.Collections.Generic.HashSet%601.IntersectWith%2A> przy użyciu metody, aby zawierała tylko wartości, które są obecne w obu zestawach.</span><span class="sxs-lookup"><span data-stu-id="f6757-320">In this example, `allNumbers` is both a superset and a proper superset of `lowNumbers` until `allNumbers` is modified, using the <xref:System.Collections.Generic.HashSet%601.IntersectWith%2A> method, to contain only values that are present in both sets.</span></span> <span data-ttu-id="f6757-321">Jeden `allNumbers` raz `lowNumbers` i są identyczne `allNumbers` , jest nadal nadzbiorem `lowNumbers` , ale nie jest już prawidłowym nadzbiorem.</span><span class="sxs-lookup"><span data-stu-id="f6757-321">Once `allNumbers` and `lowNumbers` are identical, `allNumbers` is still a superset of `lowNumbers` but is no longer a proper superset.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6757-322"><paramref name="other" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6757-322"><paramref name="other" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsSubsetOf">
      <MemberSignature Language="C#" Value="public bool IsSubsetOf (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSubsetOf(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function IsSubsetOf (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsSubsetOf(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member IsSubsetOf : seq&lt;'T&gt; -&gt; bool&#xA;override this.IsSubsetOf : seq&lt;'T&gt; -&gt; bool" Usage="hashSet.IsSubsetOf other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="f6757-323">Kolekcja do porównania z bieżącym <see cref="T:System.Collections.Generic.HashSet`1" /> obiektem.</span><span class="sxs-lookup"><span data-stu-id="f6757-323">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <summary><span data-ttu-id="f6757-324">Określa, czy <see cref="T:System.Collections.Generic.HashSet`1" /> obiekt jest podzbiorem określonej kolekcji.</span><span class="sxs-lookup"><span data-stu-id="f6757-324">Determines whether a <see cref="T:System.Collections.Generic.HashSet`1" /> object is a subset of the specified collection.</span></span></summary>
        <returns><span data-ttu-id="f6757-325"><see langword="true" />Jeśli obiekt jest <paramref name="other" />podzbiorem; w przeciwnym razie <see langword="false" />. <see cref="T:System.Collections.Generic.HashSet`1" /></span><span class="sxs-lookup"><span data-stu-id="f6757-325"><see langword="true" /> if the <see cref="T:System.Collections.Generic.HashSet`1" /> object is a subset of <paramref name="other" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6757-326">Pusty zestaw jest podzbiorem każdej innej kolekcji, w tym pustym zestawem; w związku z tym ta `true` Metoda zwraca wartość, jeśli kolekcja reprezentowana <xref:System.Collections.Generic.HashSet%601> przez bieżący obiekt jest `other` pusta, nawet jeśli parametr jest pustym zestawem.</span><span class="sxs-lookup"><span data-stu-id="f6757-326">An empty set is a subset of any other collection, including an empty set; therefore, this method returns `true` if the collection represented by the current <xref:System.Collections.Generic.HashSet%601> object is empty, even if the `other` parameter is an empty set.</span></span>  
  
 <span data-ttu-id="f6757-327">Ta metoda zawsze zwraca `false` wartość <xref:System.Collections.Generic.HashSet%601.Count%2A> , jeśli jest większa niż liczba elementów w `other`.</span><span class="sxs-lookup"><span data-stu-id="f6757-327">This method always returns `false` if <xref:System.Collections.Generic.HashSet%601.Count%2A> is greater than the number of elements in `other`.</span></span>  
  
 <span data-ttu-id="f6757-328">Jeśli kolekcja reprezentowana `other` przez program <xref:System.Collections.Generic.HashSet%601> jest kolekcją z tym samym modułem porównującym równość <xref:System.Collections.Generic.HashSet%601> co bieżący obiekt, ta metoda jest operacją o (`n`).</span><span class="sxs-lookup"><span data-stu-id="f6757-328">If the collection represented by `other` is a <xref:System.Collections.Generic.HashSet%601> collection with the same equality comparer as the current <xref:System.Collections.Generic.HashSet%601> object, this method is an O(`n`) operation.</span></span> <span data-ttu-id="f6757-329">W przeciwnym razie ta metoda jest operacją`n`O ( <xref:System.Collections.Generic.HashSet%601.Count%2A> `other` `n` `m` + ), gdzie is `m` i jest liczbą elementów w.</span><span class="sxs-lookup"><span data-stu-id="f6757-329">Otherwise, this method is an O(`n` + `m`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A> and `m` is the number of elements in `other`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6757-330">Poniższy przykład tworzy dwa <xref:System.Collections.Generic.HashSet%601> różne obiekty i porównuje je ze sobą.</span><span class="sxs-lookup"><span data-stu-id="f6757-330">The following example creates two disparate <xref:System.Collections.Generic.HashSet%601> objects and compares them to each other.</span></span> <span data-ttu-id="f6757-331">W tym przykładzie `lowNumbers` jest podzbiorem i prawidłowym `allNumbers` podzbiorem do `allNumbers` czasu modyfikacji, przy użyciu <xref:System.Collections.Generic.HashSet%601.IntersectWith%2A> metody, aby zawierała tylko wartości, które są obecne w obu zestawach.</span><span class="sxs-lookup"><span data-stu-id="f6757-331">In this example, `lowNumbers` is both a subset and a proper subset of `allNumbers` until `allNumbers` is modified, using the <xref:System.Collections.Generic.HashSet%601.IntersectWith%2A> method, to contain only values that are present in both sets.</span></span> <span data-ttu-id="f6757-332">Jeden `allNumbers` raz `lowNumbers` i są identyczne `lowNumbers` , jest nadal podzbiorem `allNumbers` , ale nie jest już poprawnym podzbiorem.</span><span class="sxs-lookup"><span data-stu-id="f6757-332">Once `allNumbers` and `lowNumbers` are identical, `lowNumbers` is still a subset of `allNumbers` but is no longer a proper subset.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6757-333"><paramref name="other" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6757-333"><paramref name="other" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsSupersetOf">
      <MemberSignature Language="C#" Value="public bool IsSupersetOf (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSupersetOf(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function IsSupersetOf (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsSupersetOf(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member IsSupersetOf : seq&lt;'T&gt; -&gt; bool&#xA;override this.IsSupersetOf : seq&lt;'T&gt; -&gt; bool" Usage="hashSet.IsSupersetOf other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="f6757-334">Kolekcja do porównania z bieżącym <see cref="T:System.Collections.Generic.HashSet`1" /> obiektem.</span><span class="sxs-lookup"><span data-stu-id="f6757-334">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <summary><span data-ttu-id="f6757-335">Określa, czy <see cref="T:System.Collections.Generic.HashSet`1" /> obiekt jest nadzbiorem określonej kolekcji.</span><span class="sxs-lookup"><span data-stu-id="f6757-335">Determines whether a <see cref="T:System.Collections.Generic.HashSet`1" /> object is a superset of the specified collection.</span></span></summary>
        <returns><span data-ttu-id="f6757-336"><see langword="true" />Jeśli obiekt jest <paramref name="other" />nadzbiorem; w przeciwnym razie <see langword="false" />,. <see cref="T:System.Collections.Generic.HashSet`1" /></span><span class="sxs-lookup"><span data-stu-id="f6757-336"><see langword="true" /> if the <see cref="T:System.Collections.Generic.HashSet`1" /> object is a superset of <paramref name="other" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6757-337">Wszystkie kolekcje, w tym pusty zestaw, są nadzbiorami pustego zestawu.</span><span class="sxs-lookup"><span data-stu-id="f6757-337">All collections, including the empty set, are supersets of the empty set.</span></span> <span data-ttu-id="f6757-338">W związku z tym ta `true` Metoda zwraca wartość, jeśli kolekcja `other` reprezentowana przez parametr jest pusta, nawet jeśli <xref:System.Collections.Generic.HashSet%601> bieżący obiekt jest pusty.</span><span class="sxs-lookup"><span data-stu-id="f6757-338">Therefore, this method returns `true` if the collection represented by the `other` parameter is empty, even if the current <xref:System.Collections.Generic.HashSet%601> object is empty.</span></span>  
  
 <span data-ttu-id="f6757-339">Ta metoda zawsze zwraca `false` wartość <xref:System.Collections.Generic.HashSet%601.Count%2A> , jeśli jest mniejsza niż liczba elementów w `other`.</span><span class="sxs-lookup"><span data-stu-id="f6757-339">This method always returns `false` if <xref:System.Collections.Generic.HashSet%601.Count%2A> is less than the number of elements in `other`.</span></span>  
  
 <span data-ttu-id="f6757-340">Jeśli kolekcja reprezentowana `other` przez program <xref:System.Collections.Generic.HashSet%601> jest kolekcją z tym samym modułem porównującym równość <xref:System.Collections.Generic.HashSet%601> co bieżący obiekt, ta metoda jest operacją o (`n`).</span><span class="sxs-lookup"><span data-stu-id="f6757-340">If the collection represented by `other` is a <xref:System.Collections.Generic.HashSet%601> collection with the same equality comparer as the current <xref:System.Collections.Generic.HashSet%601> object, this method is an O(`n`) operation.</span></span> <span data-ttu-id="f6757-341">W przeciwnym razie ta metoda jest operacją`n`o ( `other` `m` `n`  + `m`), gdzie jest liczbą elementów w i jest <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6757-341">Otherwise, this method is an O(`n` + `m`) operation, where `n` is the number of elements in `other` and `m` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6757-342">Poniższy przykład tworzy dwa <xref:System.Collections.Generic.HashSet%601> różne obiekty i porównuje je ze sobą.</span><span class="sxs-lookup"><span data-stu-id="f6757-342">The following example creates two disparate <xref:System.Collections.Generic.HashSet%601> objects and compares them to each other.</span></span> <span data-ttu-id="f6757-343">W tym przykładzie `allNumbers` jest to zarówno nadzbiór, jak i właściwy `lowNumbers` nadzbiór `allNumbers` , dopóki jest modyfikowany <xref:System.Collections.Generic.HashSet%601.IntersectWith%2A> przy użyciu metody, aby zawierała tylko wartości, które są obecne w obu zestawach.</span><span class="sxs-lookup"><span data-stu-id="f6757-343">In this example, `allNumbers` is both a superset and a proper superset of `lowNumbers` until `allNumbers` is modified, using the <xref:System.Collections.Generic.HashSet%601.IntersectWith%2A> method, to contain only values that are present in both sets.</span></span> <span data-ttu-id="f6757-344">Jeden `allNumbers` raz `lowNumbers` i są identyczne `allNumbers` , jest nadal nadzbiorem `lowNumbers` , ale nie jest już prawidłowym nadzbiorem.</span><span class="sxs-lookup"><span data-stu-id="f6757-344">Once `allNumbers` and `lowNumbers` are identical, `allNumbers` is still a superset of `lowNumbers` but is no longer a proper superset.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6757-345"><paramref name="other" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6757-345"><paramref name="other" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="OnDeserialization">
      <MemberSignature Language="C#" Value="public virtual void OnDeserialization (object sender);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnDeserialization(object sender) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.OnDeserialization(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub OnDeserialization (sender As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void OnDeserialization(System::Object ^ sender);" />
      <MemberSignature Language="F#" Value="abstract member OnDeserialization : obj -&gt; unit&#xA;override this.OnDeserialization : obj -&gt; unit" Usage="hashSet.OnDeserialization sender" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="sender"><span data-ttu-id="f6757-346">Źródło zdarzenia deserializacji.</span><span class="sxs-lookup"><span data-stu-id="f6757-346">The source of the deserialization event.</span></span></param>
        <summary><span data-ttu-id="f6757-347"><see cref="T:System.Runtime.Serialization.ISerializable" /> Implementuje interfejs i wywołuje zdarzenie deserializacji po zakończeniu deserializacji.</span><span class="sxs-lookup"><span data-stu-id="f6757-347">Implements the <see cref="T:System.Runtime.Serialization.ISerializable" /> interface and raises the deserialization event when the deserialization is complete.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6757-348">Wywołanie tej metody jest operacją o`n`(), gdzie `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6757-348">Calling this method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Serialization.SerializationException"><span data-ttu-id="f6757-349">Obiekt skojarzony z bieżącym <see cref="T:System.Collections.Generic.HashSet`1" /> obiektem jest nieprawidłowy. <see cref="T:System.Runtime.Serialization.SerializationInfo" /></span><span class="sxs-lookup"><span data-stu-id="f6757-349">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object associated with the current <see cref="T:System.Collections.Generic.HashSet`1" /> object is invalid.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Overlaps">
      <MemberSignature Language="C#" Value="public bool Overlaps (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Overlaps(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Overlaps (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Overlaps(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member Overlaps : seq&lt;'T&gt; -&gt; bool&#xA;override this.Overlaps : seq&lt;'T&gt; -&gt; bool" Usage="hashSet.Overlaps other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="f6757-350">Kolekcja do porównania z bieżącym <see cref="T:System.Collections.Generic.HashSet`1" /> obiektem.</span><span class="sxs-lookup"><span data-stu-id="f6757-350">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <summary><span data-ttu-id="f6757-351">Określa, czy bieżący <see cref="T:System.Collections.Generic.HashSet`1" /> obiekt i określona kolekcja udostępniają wspólne elementy.</span><span class="sxs-lookup"><span data-stu-id="f6757-351">Determines whether the current <see cref="T:System.Collections.Generic.HashSet`1" /> object and a specified collection share common elements.</span></span></summary>
        <returns><span data-ttu-id="f6757-352"><see langword="true" />Jeśli obiekt i <paramref name="other" /> udostępnisz co najmniej jeden wspólny element; w przeciwnym <see langword="false" />razie,. <see cref="T:System.Collections.Generic.HashSet`1" /></span><span class="sxs-lookup"><span data-stu-id="f6757-352"><see langword="true" /> if the <see cref="T:System.Collections.Generic.HashSet`1" /> object and <paramref name="other" /> share at least one common element; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6757-353">Ta metoda jest operacją o`n`(), gdzie `n` jest liczbą elementów w `other`.</span><span class="sxs-lookup"><span data-stu-id="f6757-353">This method is an O(`n`) operation, where `n` is the number of elements in `other`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6757-354">Poniższy przykład tworzy dwa <xref:System.Collections.Generic.HashSet%601> różne obiekty i porównuje je ze sobą.</span><span class="sxs-lookup"><span data-stu-id="f6757-354">The following example creates two disparate <xref:System.Collections.Generic.HashSet%601> objects and compares them to each another.</span></span> <span data-ttu-id="f6757-355">W tym przykładzie `allNumbers` i `lowNumbers` są wyświetlane w celu <xref:System.Collections.Generic.HashSet%601.Overlaps%2A> udostępniania wspólnych elementów przy użyciu metody.</span><span class="sxs-lookup"><span data-stu-id="f6757-355">In this example, `allNumbers` and `lowNumbers` are shown to share common elements using the <xref:System.Collections.Generic.HashSet%601.Overlaps%2A> method.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6757-356"><paramref name="other" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6757-356"><paramref name="other" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Remove(T item);" />
      <MemberSignature Language="F#" Value="abstract member Remove : 'T -&gt; bool&#xA;override this.Remove : 'T -&gt; bool" Usage="hashSet.Remove item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item"><span data-ttu-id="f6757-357">Element do usunięcia.</span><span class="sxs-lookup"><span data-stu-id="f6757-357">The element to remove.</span></span></param>
        <summary><span data-ttu-id="f6757-358">Usuwa określony element z <see cref="T:System.Collections.Generic.HashSet`1" /> obiektu.</span><span class="sxs-lookup"><span data-stu-id="f6757-358">Removes the specified element from a <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></summary>
        <returns><span data-ttu-id="f6757-359"><see langword="true" />Jeśli element zostanie pomyślnie znaleziony i usunięty; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="f6757-359"><see langword="true" /> if the element is successfully found and removed; otherwise, <see langword="false" />.</span></span>  <span data-ttu-id="f6757-360">Ta metoda zwraca <see langword="false" /> wartość <paramref name="item" /> , jeśli nie <see cref="T:System.Collections.Generic.HashSet`1" /> została znaleziona w obiekcie.</span><span class="sxs-lookup"><span data-stu-id="f6757-360">This method returns <see langword="false" /> if <paramref name="item" /> is not found in the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6757-361"><xref:System.Collections.Generic.HashSet%601> Jeśli obiekt nie zawiera określonego elementu, obiekt pozostaje niezmieniony.</span><span class="sxs-lookup"><span data-stu-id="f6757-361">If the <xref:System.Collections.Generic.HashSet%601> object does not contain the specified element, the object remains unchanged.</span></span> <span data-ttu-id="f6757-362">Nie zgłoszono żadnego wyjątku.</span><span class="sxs-lookup"><span data-stu-id="f6757-362">No exception is thrown.</span></span>  
  
 <span data-ttu-id="f6757-363">Ta metoda jest operacją O(1).</span><span class="sxs-lookup"><span data-stu-id="f6757-363">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6757-364">Poniższy przykład ilustruje sposób usuwania wartości z <xref:System.Collections.Generic.HashSet%601> kolekcji <xref:System.Collections.Generic.HashSet%601.Remove%2A> przy użyciu metody.</span><span class="sxs-lookup"><span data-stu-id="f6757-364">The following example demonstrates how to remove values from a <xref:System.Collections.Generic.HashSet%601> collection using the <xref:System.Collections.Generic.HashSet%601.Remove%2A> method.</span></span> <span data-ttu-id="f6757-365">W tym przykładzie zero jest arbitralnie usuwane z <xref:System.Collections.Generic.HashSet%601> kolekcji.</span><span class="sxs-lookup"><span data-stu-id="f6757-365">In this example, zero is arbitrarily removed from the <xref:System.Collections.Generic.HashSet%601> collection.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_RemoveWhere#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_RemoveWhere/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_RemoveWhere#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_RemoveWhere/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveWhere">
      <MemberSignature Language="C#" Value="public int RemoveWhere (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 RemoveWhere(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.RemoveWhere(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveWhere (match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int RemoveWhere(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.RemoveWhere : Predicate&lt;'T&gt; -&gt; int" Usage="hashSet.RemoveWhere match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match"><span data-ttu-id="f6757-366"><see cref="T:System.Predicate`1" /> Delegat, który definiuje warunki elementów do usunięcia.</span><span class="sxs-lookup"><span data-stu-id="f6757-366">The <see cref="T:System.Predicate`1" /> delegate that defines the conditions of the elements to remove.</span></span></param>
        <summary><span data-ttu-id="f6757-367">Usuwa wszystkie elementy, które pasują do warunków zdefiniowanych przez określony predykat z <see cref="T:System.Collections.Generic.HashSet`1" /> kolekcji.</span><span class="sxs-lookup"><span data-stu-id="f6757-367">Removes all elements that match the conditions defined by the specified predicate from a <see cref="T:System.Collections.Generic.HashSet`1" /> collection.</span></span></summary>
        <returns><span data-ttu-id="f6757-368">Liczba elementów, które zostały usunięte z <see cref="T:System.Collections.Generic.HashSet`1" /> kolekcji.</span><span class="sxs-lookup"><span data-stu-id="f6757-368">The number of elements that were removed from the <see cref="T:System.Collections.Generic.HashSet`1" /> collection.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6757-369">Wywołanie tej metody jest operacją o`n`(), gdzie `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6757-369">Calling this method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6757-370">Poniższy przykład ilustruje sposób usuwania wartości z <xref:System.Collections.Generic.HashSet%601> kolekcji <xref:System.Collections.Generic.HashSet%601.Remove%2A> przy użyciu metody.</span><span class="sxs-lookup"><span data-stu-id="f6757-370">The following example demonstrates how to remove values from a <xref:System.Collections.Generic.HashSet%601> collection using the <xref:System.Collections.Generic.HashSet%601.Remove%2A> method.</span></span> <span data-ttu-id="f6757-371">W tym przykładzie wszystkie nieparzyste liczby całkowite są usuwane z <xref:System.Collections.Generic.HashSet%601> kolekcji określonej `match` przez delegata.</span><span class="sxs-lookup"><span data-stu-id="f6757-371">In this example, all odd integers are removed from the <xref:System.Collections.Generic.HashSet%601> collection as specified by the `match` delegate.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_RemoveWhere#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_RemoveWhere/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_RemoveWhere#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_RemoveWhere/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6757-372"><paramref name="match" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6757-372"><paramref name="match" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SetEquals">
      <MemberSignature Language="C#" Value="public bool SetEquals (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool SetEquals(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function SetEquals (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool SetEquals(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member SetEquals : seq&lt;'T&gt; -&gt; bool&#xA;override this.SetEquals : seq&lt;'T&gt; -&gt; bool" Usage="hashSet.SetEquals other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="f6757-373">Kolekcja do porównania z bieżącym <see cref="T:System.Collections.Generic.HashSet`1" /> obiektem.</span><span class="sxs-lookup"><span data-stu-id="f6757-373">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <summary><span data-ttu-id="f6757-374">Określa, czy <see cref="T:System.Collections.Generic.HashSet`1" /> obiekt i określona kolekcja zawierają te same elementy.</span><span class="sxs-lookup"><span data-stu-id="f6757-374">Determines whether a <see cref="T:System.Collections.Generic.HashSet`1" /> object and the specified collection contain the same elements.</span></span></summary>
        <returns><span data-ttu-id="f6757-375"><see langword="true" />Jeśli obiekt jest <paramref name="other" />równy; w przeciwnym razie, FAŁSZ. <see cref="T:System.Collections.Generic.HashSet`1" /></span><span class="sxs-lookup"><span data-stu-id="f6757-375"><see langword="true" /> if the <see cref="T:System.Collections.Generic.HashSet`1" /> object is equal to <paramref name="other" />; otherwise, false.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6757-376">Metoda ignoruje zduplikowane wpisy i kolejność elementów `other` w parametrze. <xref:System.Collections.Generic.HashSet%601.SetEquals%2A></span><span class="sxs-lookup"><span data-stu-id="f6757-376">The <xref:System.Collections.Generic.HashSet%601.SetEquals%2A> method ignores duplicate entries and the order of elements in the `other` parameter.</span></span>  
  
 <span data-ttu-id="f6757-377">Jeśli kolekcja reprezentowana `other` przez program <xref:System.Collections.Generic.HashSet%601> jest kolekcją z tym samym modułem porównującym równość <xref:System.Collections.Generic.HashSet%601> co bieżący obiekt, ta metoda jest operacją o (`n`).</span><span class="sxs-lookup"><span data-stu-id="f6757-377">If the collection represented by `other` is a <xref:System.Collections.Generic.HashSet%601> collection with the same equality comparer as the current <xref:System.Collections.Generic.HashSet%601> object, this method is an O(`n`) operation.</span></span> <span data-ttu-id="f6757-378">W przeciwnym razie ta metoda jest operacją`n`o ( `other` `m` `n`  + `m`), gdzie jest liczbą elementów w i jest <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6757-378">Otherwise, this method is an O(`n` + `m`) operation, where `n` is the number of elements in `other` and `m` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6757-379">Poniższy przykład tworzy dwa <xref:System.Collections.Generic.HashSet%601> różne obiekty i porównuje je ze sobą.</span><span class="sxs-lookup"><span data-stu-id="f6757-379">The following example creates two disparate <xref:System.Collections.Generic.HashSet%601> objects and compares them to each another.</span></span> <span data-ttu-id="f6757-380">Początkowo dwa zestawy nie są równe, które są zademonstrowane przy użyciu <xref:System.Collections.Generic.HashSet%601.SetEquals%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="f6757-380">Initially, the two sets are not equal, which is demonstrated by using the <xref:System.Collections.Generic.HashSet%601.SetEquals%2A> method.</span></span> <span data-ttu-id="f6757-381">`allNumbers` Następnieobiektjestmodyfikowany,po<xref:System.Collections.Generic.HashSet%601> którym zestawy są równe.</span><span class="sxs-lookup"><span data-stu-id="f6757-381">The `allNumbers`<xref:System.Collections.Generic.HashSet%601> object is then modified, after which the sets are equal.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6757-382"><paramref name="other" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6757-382"><paramref name="other" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SymmetricExceptWith">
      <MemberSignature Language="C#" Value="public void SymmetricExceptWith (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SymmetricExceptWith(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub SymmetricExceptWith (other As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SymmetricExceptWith(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member SymmetricExceptWith : seq&lt;'T&gt; -&gt; unit&#xA;override this.SymmetricExceptWith : seq&lt;'T&gt; -&gt; unit" Usage="hashSet.SymmetricExceptWith other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="f6757-383">Kolekcja do porównania z bieżącym <see cref="T:System.Collections.Generic.HashSet`1" /> obiektem.</span><span class="sxs-lookup"><span data-stu-id="f6757-383">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <summary><span data-ttu-id="f6757-384">Modyfikuje bieżący <see cref="T:System.Collections.Generic.HashSet`1" /> obiekt, aby zawierał tylko elementy, które są obecne w tym obiekcie lub w określonej kolekcji, ale nie oba.</span><span class="sxs-lookup"><span data-stu-id="f6757-384">Modifies the current <see cref="T:System.Collections.Generic.HashSet`1" /> object to contain only elements that are present either in that object or in the specified collection, but not both.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6757-385">Jeśli parametr jest kolekcją z tym samym modułem porównującym równość co <xref:System.Collections.Generic.HashSet%601> bieżący obiekt, ta metoda jest operacją`n`o (). <xref:System.Collections.Generic.HashSet%601> `other`</span><span class="sxs-lookup"><span data-stu-id="f6757-385">If the `other` parameter is a <xref:System.Collections.Generic.HashSet%601> collection with the same equality comparer as the current <xref:System.Collections.Generic.HashSet%601> object, this method is an O(`n`) operation.</span></span> <span data-ttu-id="f6757-386">W przeciwnym razie ta metoda jest operacją`n`o ( `other` `m` `n`  + `m`), gdzie jest liczbą elementów w i jest <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6757-386">Otherwise, this method is an O(`n` + `m`) operation, where `n` is the number of elements in `other` and `m` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6757-387">Poniższy przykład tworzy dwie <xref:System.Collections.Generic.HashSet%601> kolekcje z nakładającymi się zestawami danych.</span><span class="sxs-lookup"><span data-stu-id="f6757-387">The following example creates two <xref:System.Collections.Generic.HashSet%601> collections with overlapping sets of data.</span></span> <span data-ttu-id="f6757-388">Zestaw zawierający mniejsze wartości jest następnie modyfikowany przy użyciu <xref:System.Collections.Generic.HashSet%601.SymmetricExceptWith%2A> metody, aby zawierała tylko te wartości, które nie są obecne w obu zestawach.</span><span class="sxs-lookup"><span data-stu-id="f6757-388">The set that contains the lower values is then modified, using the <xref:System.Collections.Generic.HashSet%601.SymmetricExceptWith%2A> method, to contain only the values that are not present in both sets.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_SymmetricExceptWith#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_SymmetricExceptWith/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_SymmetricExceptWith#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_SymmetricExceptWith/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6757-389"><paramref name="other" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6757-389"><paramref name="other" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;T&gt;.Add">
      <MemberSignature Language="C#" Value="void ICollection&lt;T&gt;.Add (T item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;T&gt;.Add(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#ICollection&lt;T&gt;#Add(`0)" />
      <MemberSignature Language="VB.NET" Value="Sub Add (item As T) Implements ICollection(Of T).Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.ICollection&lt;T&gt;.Add(T item) = System::Collections::Generic::ICollection&lt;T&gt;::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item"><span data-ttu-id="f6757-390">Obiekt, który ma zostać dodany <see cref="T:System.Collections.Generic.ICollection`1" /> do obiektu.</span><span class="sxs-lookup"><span data-stu-id="f6757-390">The object to add to the <see cref="T:System.Collections.Generic.ICollection`1" /> object.</span></span></param>
        <summary><span data-ttu-id="f6757-391">Dodaje element do <see cref="T:System.Collections.Generic.ICollection`1" /> obiektu.</span><span class="sxs-lookup"><span data-stu-id="f6757-391">Adds an item to an <see cref="T:System.Collections.Generic.ICollection`1" /> object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6757-392">Jeśli <xref:System.Collections.Generic.List%601.Count%2A> jest mniejsza niż <xref:System.Collections.Generic.List%601.Capacity%2A>, ta metoda jest operacją o (1).</span><span class="sxs-lookup"><span data-stu-id="f6757-392">If <xref:System.Collections.Generic.List%601.Count%2A> is less than <xref:System.Collections.Generic.List%601.Capacity%2A>, this method is an O(1) operation.</span></span> <span data-ttu-id="f6757-393">Jeśli pojemność musi być zwiększona w celu uwzględnienia nowego elementu, ta metoda jest operacją o`n`(), gdzie `n` is <xref:System.Collections.Generic.List%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6757-393">If the capacity must be increased to accommodate the new element, this method becomes an O(`n`) operation, where `n` is <xref:System.Collections.Generic.List%601.Count%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="f6757-394">Jest <see cref="T:System.Collections.Generic.ICollection`1" /> tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="f6757-394">The <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.HashSet`1.System#Collections#Generic#ICollection&lt;T&gt;#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements ICollection(Of T).IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::Generic::ICollection&lt;T&gt;::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="f6757-395">Pobiera wartość wskazującą, czy kolekcja jest tylko do odczytu.</span><span class="sxs-lookup"><span data-stu-id="f6757-395">Gets a value indicating whether a collection is read-only.</span></span></summary>
        <value><span data-ttu-id="f6757-396"><see langword="true" />Jeśli kolekcja jest tylko do odczytu; w przeciwnym razie. <see langword="false" /></span><span class="sxs-lookup"><span data-stu-id="f6757-396"><see langword="true" /> if the collection is read-only; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6757-397">Pobieranie wartości tej właściwości jest operacją O(1).</span><span class="sxs-lookup"><span data-stu-id="f6757-397">Retrieving the value of this property is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;!T&gt; System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#IEnumerable&lt;T&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of T) Implements IEnumerable(Of T).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;T&gt; ^ System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;T&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f6757-398">Zwraca moduł wyliczający, który dokonuje iteracji w kolekcji.</span><span class="sxs-lookup"><span data-stu-id="f6757-398">Returns an enumerator that iterates through a collection.</span></span></summary>
        <returns><span data-ttu-id="f6757-399"><see cref="T:System.Collections.Generic.IEnumerator`1" /> Obiekt, którego można użyć do iteracji w kolekcji.</span><span class="sxs-lookup"><span data-stu-id="f6757-399">An <see cref="T:System.Collections.Generic.IEnumerator`1" /> object that can be used to iterate through the collection.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6757-400">`foreach` Instrukcja C# języka(`for each` C++w VisualBasic)ukrywazłożonośćmodułówwyliczających.`For Each`</span><span class="sxs-lookup"><span data-stu-id="f6757-400">The `foreach` statement of the C# language (`for each` in C++, `For Each` in Visual Basic) hides the complexity of enumerators.</span></span> <span data-ttu-id="f6757-401">W związku z `foreach` tym zaleca się użycie zamiast bezpośredniego manipulowania modułem wyliczającym.</span><span class="sxs-lookup"><span data-stu-id="f6757-401">Therefore, using `foreach` is recommended, instead of directly manipulating the enumerator.</span></span>  
  
 <span data-ttu-id="f6757-402">Moduły wyliczające mogą służyć do odczytu danych w kolekcji, ale nie można za ich pomocą modyfikować kolekcji źródłowej.</span><span class="sxs-lookup"><span data-stu-id="f6757-402">Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</span></span>  
  
 <span data-ttu-id="f6757-403">Początkowo moduł wyliczający jest umieszczony przed pierwszym elementem w kolekcji.</span><span class="sxs-lookup"><span data-stu-id="f6757-403">Initially, the enumerator is positioned before the first element in the collection.</span></span> <span data-ttu-id="f6757-404">W tym miejscu <xref:System.Collections.Generic.IEnumerator%601.Current%2A> właściwość jest niezdefiniowana.</span><span class="sxs-lookup"><span data-stu-id="f6757-404">At this position, the <xref:System.Collections.Generic.IEnumerator%601.Current%2A> property is undefined.</span></span> <span data-ttu-id="f6757-405">W związku z tym, należy <xref:System.Collections.IEnumerator.MoveNext%2A> wywołać metodę, aby wykonać przechodzenie modułu wyliczającego do pierwszego elementu kolekcji przed odczytem <xref:System.Collections.Generic.IEnumerator%601.Current%2A>wartości.</span><span class="sxs-lookup"><span data-stu-id="f6757-405">Therefore, you must call the <xref:System.Collections.IEnumerator.MoveNext%2A> method to advance the enumerator to the first element of the collection before reading the value of <xref:System.Collections.Generic.IEnumerator%601.Current%2A>.</span></span>  
  
 <span data-ttu-id="f6757-406">Właściwość zwraca ten sam obiekt, dopóki <xref:System.Collections.IEnumerator.MoveNext%2A> nie zostanie wywołana. <xref:System.Collections.Generic.IEnumerator%601.Current%2A></span><span class="sxs-lookup"><span data-stu-id="f6757-406">The <xref:System.Collections.Generic.IEnumerator%601.Current%2A> property returns the same object until <xref:System.Collections.IEnumerator.MoveNext%2A> is called.</span></span> <span data-ttu-id="f6757-407"><xref:System.Collections.IEnumerator.MoveNext%2A>ustawia <xref:System.Collections.Generic.IEnumerator%601.Current%2A> do następnego elementu.</span><span class="sxs-lookup"><span data-stu-id="f6757-407"><xref:System.Collections.IEnumerator.MoveNext%2A> sets <xref:System.Collections.Generic.IEnumerator%601.Current%2A> to the next element.</span></span>  
  
 <span data-ttu-id="f6757-408">Jeśli <xref:System.Collections.IEnumerator.MoveNext%2A> przekazuje koniec kolekcji, moduł wyliczający jest umieszczony po ostatnim elemencie w kolekcji i <xref:System.Collections.IEnumerator.MoveNext%2A> zwraca `false`.</span><span class="sxs-lookup"><span data-stu-id="f6757-408">If <xref:System.Collections.IEnumerator.MoveNext%2A> passes the end of the collection, the enumerator is positioned after the last element in the collection and <xref:System.Collections.IEnumerator.MoveNext%2A> returns `false`.</span></span> <span data-ttu-id="f6757-409">Gdy moduł wyliczający znajduje się w tym miejscu, kolejne <xref:System.Collections.IEnumerator.MoveNext%2A> wywołania również `false`zwracają.</span><span class="sxs-lookup"><span data-stu-id="f6757-409">When the enumerator is at this position, subsequent calls to <xref:System.Collections.IEnumerator.MoveNext%2A> also return `false`.</span></span> <span data-ttu-id="f6757-410">Jeśli ostatnie wywołanie <xref:System.Collections.IEnumerator.MoveNext%2A> zwrócone `false`, <xref:System.Collections.Generic.IEnumerator%601.Current%2A> nie jest zdefiniowane.</span><span class="sxs-lookup"><span data-stu-id="f6757-410">If the last call to <xref:System.Collections.IEnumerator.MoveNext%2A> returned `false`, <xref:System.Collections.Generic.IEnumerator%601.Current%2A> is undefined.</span></span> <span data-ttu-id="f6757-411">Nie można ponownie <xref:System.Collections.Generic.IEnumerator%601.Current%2A> ustawić na pierwszy element kolekcji; zamiast tego należy utworzyć nowy obiekt modułu wyliczającego.</span><span class="sxs-lookup"><span data-stu-id="f6757-411">You cannot set <xref:System.Collections.Generic.IEnumerator%601.Current%2A> to the first element of the collection again; you must create a new enumerator object instead.</span></span>  
  
 <span data-ttu-id="f6757-412">Moduł wyliczający zachowuje ważność tak długo, jak długo kolekcja pozostaje niezmieniona.</span><span class="sxs-lookup"><span data-stu-id="f6757-412">An enumerator remains valid as long as the collection remains unchanged.</span></span> <span data-ttu-id="f6757-413">Jeśli w kolekcji zostaną wprowadzone zmiany, takie jak dodanie, zmodyfikowanie czy usunięcie elementów, moduł wyliczający jest nieodwracalnie unieważniany, a jego zachowanie staje się niezdefiniowane.</span><span class="sxs-lookup"><span data-stu-id="f6757-413">If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and its behavior is undefined.</span></span>  
  
 <span data-ttu-id="f6757-414">Moduł wyliczający nie ma wyłącznego dostępu do kolekcji, w związku z tym wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość.</span><span class="sxs-lookup"><span data-stu-id="f6757-414">The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread-safe procedure.</span></span> <span data-ttu-id="f6757-415">Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania.</span><span class="sxs-lookup"><span data-stu-id="f6757-415">To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration.</span></span>  <span data-ttu-id="f6757-416">Aby zezwolić wielu wątkom na dostęp do kolekcji w celu odczytu i zapisu danych, należy zaimplementować własny mechanizm synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="f6757-416">To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.</span></span>  
  
 <span data-ttu-id="f6757-417">Domyślne implementacje kolekcji w <xref:System.Collections.Generic?displayProperty=nameWithType> przestrzeni nazw nie są zsynchronizowane.</span><span class="sxs-lookup"><span data-stu-id="f6757-417">Default implementations of collections in the <xref:System.Collections.Generic?displayProperty=nameWithType> namespace are not synchronized.</span></span>  
  
 <span data-ttu-id="f6757-418">Ta metoda jest operacją O(1).</span><span class="sxs-lookup"><span data-stu-id="f6757-418">This method is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f6757-419">Zwraca moduł wyliczający, który dokonuje iteracji w kolekcji.</span><span class="sxs-lookup"><span data-stu-id="f6757-419">Returns an enumerator that iterates through a collection.</span></span></summary>
        <returns><span data-ttu-id="f6757-420"><see cref="T:System.Collections.IEnumerator" /> Obiekt, którego można użyć do iteracji w kolekcji.</span><span class="sxs-lookup"><span data-stu-id="f6757-420">An <see cref="T:System.Collections.IEnumerator" /> object that can be used to iterate through the collection.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6757-421">`foreach` Instrukcja C# języka(`for each` C++w VisualBasic)ukrywazłożonośćmodułówwyliczających.`For Each`</span><span class="sxs-lookup"><span data-stu-id="f6757-421">The `foreach` statement of the C# language (`for each` in C++, `For Each` in Visual Basic) hides the complexity of enumerators.</span></span> <span data-ttu-id="f6757-422">W związku z `foreach` tym zaleca się użycie zamiast bezpośredniego manipulowania modułem wyliczającym.</span><span class="sxs-lookup"><span data-stu-id="f6757-422">Therefore, using `foreach` is recommended, instead of directly manipulating the enumerator.</span></span>  
  
 <span data-ttu-id="f6757-423">Moduły wyliczające mogą służyć do odczytu danych w kolekcji, ale nie można za ich pomocą modyfikować kolekcji źródłowej.</span><span class="sxs-lookup"><span data-stu-id="f6757-423">Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</span></span>  
  
 <span data-ttu-id="f6757-424">Początkowo moduł wyliczający jest umieszczony przed pierwszym elementem w kolekcji.</span><span class="sxs-lookup"><span data-stu-id="f6757-424">Initially, the enumerator is positioned before the first element in the collection.</span></span> <span data-ttu-id="f6757-425"><xref:System.Collections.IEnumerator.Reset%2A>przywraca również moduł wyliczający z powrotem do tego położenia.</span><span class="sxs-lookup"><span data-stu-id="f6757-425"><xref:System.Collections.IEnumerator.Reset%2A> also brings the enumerator back to this position.</span></span>  <span data-ttu-id="f6757-426">W tym miejscu <xref:System.Collections.IEnumerator.Current%2A> właściwość jest niezdefiniowana.</span><span class="sxs-lookup"><span data-stu-id="f6757-426">At this position, the <xref:System.Collections.IEnumerator.Current%2A> property is undefined.</span></span> <span data-ttu-id="f6757-427">W związku z tym, należy <xref:System.Collections.IEnumerator.MoveNext%2A> wywołać metodę, aby wykonać przechodzenie modułu wyliczającego do pierwszego elementu kolekcji przed odczytem <xref:System.Collections.IEnumerator.Current%2A>wartości.</span><span class="sxs-lookup"><span data-stu-id="f6757-427">Therefore, you must call the <xref:System.Collections.IEnumerator.MoveNext%2A> method to advance the enumerator to the first element of the collection before reading the value of <xref:System.Collections.IEnumerator.Current%2A>.</span></span>  
  
 <span data-ttu-id="f6757-428">Właściwość zwraca ten sam obiekt <xref:System.Collections.IEnumerator.MoveNext%2A> do momentu wywołania <xref:System.Collections.IEnumerator.Reset%2A>lub. <xref:System.Collections.IEnumerator.Current%2A></span><span class="sxs-lookup"><span data-stu-id="f6757-428">The <xref:System.Collections.IEnumerator.Current%2A> property returns the same object until either <xref:System.Collections.IEnumerator.MoveNext%2A> or <xref:System.Collections.IEnumerator.Reset%2A> is called.</span></span> <span data-ttu-id="f6757-429"><xref:System.Collections.IEnumerator.MoveNext%2A>ustawia <xref:System.Collections.IEnumerator.Current%2A> do następnego elementu.</span><span class="sxs-lookup"><span data-stu-id="f6757-429"><xref:System.Collections.IEnumerator.MoveNext%2A> sets <xref:System.Collections.IEnumerator.Current%2A> to the next element.</span></span>  
  
 <span data-ttu-id="f6757-430">Jeśli <xref:System.Collections.IEnumerator.MoveNext%2A> przekazuje koniec kolekcji, moduł wyliczający jest umieszczony po ostatnim elemencie w kolekcji i <xref:System.Collections.IEnumerator.MoveNext%2A> zwraca `false`.</span><span class="sxs-lookup"><span data-stu-id="f6757-430">If <xref:System.Collections.IEnumerator.MoveNext%2A> passes the end of the collection, the enumerator is positioned after the last element in the collection and <xref:System.Collections.IEnumerator.MoveNext%2A> returns `false`.</span></span> <span data-ttu-id="f6757-431">Gdy moduł wyliczający znajduje się w tym miejscu, kolejne <xref:System.Collections.IEnumerator.MoveNext%2A> wywołania również `false`zwracają.</span><span class="sxs-lookup"><span data-stu-id="f6757-431">When the enumerator is at this position, subsequent calls to <xref:System.Collections.IEnumerator.MoveNext%2A> also return `false`.</span></span> <span data-ttu-id="f6757-432">Jeśli ostatnie wywołanie <xref:System.Collections.IEnumerator.MoveNext%2A> zwrócone `false`, <xref:System.Collections.IEnumerator.Current%2A> nie jest zdefiniowane.</span><span class="sxs-lookup"><span data-stu-id="f6757-432">If the last call to <xref:System.Collections.IEnumerator.MoveNext%2A> returned `false`, <xref:System.Collections.IEnumerator.Current%2A> is undefined.</span></span> <span data-ttu-id="f6757-433">Aby ponownie <xref:System.Collections.IEnumerator.Current%2A> ustawić na pierwszy element kolekcji, możesz wywołać metodę <xref:System.Collections.IEnumerator.Reset%2A> i <xref:System.Collections.IEnumerator.MoveNext%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6757-433">To set <xref:System.Collections.IEnumerator.Current%2A> to the first element of the collection again, you can call <xref:System.Collections.IEnumerator.Reset%2A> followed by <xref:System.Collections.IEnumerator.MoveNext%2A>.</span></span>  
  
 <span data-ttu-id="f6757-434">Moduł wyliczający zachowuje ważność tak długo, jak długo kolekcja pozostaje niezmieniona.</span><span class="sxs-lookup"><span data-stu-id="f6757-434">An enumerator remains valid as long as the collection remains unchanged.</span></span> <span data-ttu-id="f6757-435">Jeśli w kolekcji zostaną wprowadzone zmiany, takie jak dodanie, zmodyfikowanie czy usunięcie elementów, moduł wyliczający jest nieodwracalnie unieważniany, a jego zachowanie staje się niezdefiniowane.</span><span class="sxs-lookup"><span data-stu-id="f6757-435">If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and its behavior is undefined.</span></span>  
  
 <span data-ttu-id="f6757-436">Moduł wyliczający nie ma wyłącznego dostępu do kolekcji, w związku z tym wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość.</span><span class="sxs-lookup"><span data-stu-id="f6757-436">The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread-safe procedure.</span></span>  <span data-ttu-id="f6757-437">Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania.</span><span class="sxs-lookup"><span data-stu-id="f6757-437">To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration.</span></span>  <span data-ttu-id="f6757-438">Aby zezwolić wielu wątkom na dostęp do kolekcji w celu odczytu i zapisu danych, należy zaimplementować własny mechanizm synchronizacji.</span><span class="sxs-lookup"><span data-stu-id="f6757-438">To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.</span></span>  
  
 <span data-ttu-id="f6757-439">Domyślne implementacje kolekcji w <xref:System.Collections.Generic?displayProperty=nameWithType> przestrzeni nazw nie są zsynchronizowane.</span><span class="sxs-lookup"><span data-stu-id="f6757-439">Default implementations of collections in the <xref:System.Collections.Generic?displayProperty=nameWithType> namespace are not synchronized.</span></span>  
  
 <span data-ttu-id="f6757-440">Ta metoda jest operacją O(1).</span><span class="sxs-lookup"><span data-stu-id="f6757-440">This method is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="TrimExcess">
      <MemberSignature Language="C#" Value="public void TrimExcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TrimExcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.TrimExcess" />
      <MemberSignature Language="VB.NET" Value="Public Sub TrimExcess ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TrimExcess();" />
      <MemberSignature Language="F#" Value="member this.TrimExcess : unit -&gt; unit" Usage="hashSet.TrimExcess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="f6757-441">Ustawia pojemność <see cref="T:System.Collections.Generic.HashSet`1" /> obiektu do rzeczywistej liczby elementów, które zawiera, zaokrągloną w górę do pobliskiej wartości specyficznej dla implementacji.</span><span class="sxs-lookup"><span data-stu-id="f6757-441">Sets the capacity of a <see cref="T:System.Collections.Generic.HashSet`1" /> object to the actual number of elements it contains, rounded up to a nearby, implementation-specific value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6757-442">Można użyć <xref:System.Collections.Generic.HashSet%601.TrimExcess%2A> metody, aby <xref:System.Collections.Generic.HashSet%601> zminimalizować obciążenie pamięci obiektu, gdy wiadomo, że nie zostaną dodane żadne nowe elementy.</span><span class="sxs-lookup"><span data-stu-id="f6757-442">You can use the <xref:System.Collections.Generic.HashSet%601.TrimExcess%2A> method to minimize a <xref:System.Collections.Generic.HashSet%601> object's memory overhead once it is known that no new elements will be added.</span></span> <span data-ttu-id="f6757-443">Aby całkowicie wyczyścić <xref:System.Collections.Generic.HashSet%601> obiekt i zwolnić wszystkie pamięci, do których się odwołuje, Wywołaj tę metodę <xref:System.Collections.Generic.HashSet%601.Clear%2A> po wywołaniu metody.</span><span class="sxs-lookup"><span data-stu-id="f6757-443">To completely clear a <xref:System.Collections.Generic.HashSet%601> object and release all memory referenced by it, call this method after calling the <xref:System.Collections.Generic.HashSet%601.Clear%2A> method.</span></span>  
  
 <span data-ttu-id="f6757-444">Ta metoda jest operacją o`n`(), gdzie `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6757-444">This method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6757-445">Poniższy przykład tworzy i wypełnia <xref:System.Collections.Generic.HashSet%601> kolekcję, a następnie czyści kolekcję i zwalnia pamięć, do której się odwołuje.</span><span class="sxs-lookup"><span data-stu-id="f6757-445">The following example creates and populates a <xref:System.Collections.Generic.HashSet%601> collection, and then clears the collection and releases the memory referenced by it.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_Clear#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_Clear/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_Clear#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_Clear/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetValue">
      <MemberSignature Language="C#" Value="public bool TryGetValue (T equalValue, out T actualValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetValue(!T equalValue, [out] !T&amp; actualValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.TryGetValue(`0,`0@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetValue (equalValue As T, ByRef actualValue As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetValue(T equalValue, [Runtime::InteropServices::Out] T % actualValue);" />
      <MemberSignature Language="F#" Value="member this.TryGetValue : 'T *  -&gt; bool" Usage="hashSet.TryGetValue (equalValue, actualValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="equalValue" Type="T" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
        <Parameter Name="actualValue" Type="T" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.7.2;netframework-4.8;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="equalValue"><span data-ttu-id="f6757-446">Wartość do wyszukania.</span><span class="sxs-lookup"><span data-stu-id="f6757-446">The value to search for.</span></span></param>
        <param name="actualValue"><span data-ttu-id="f6757-447">Wartość z zestawu znalezionego podczas wyszukiwania lub wartość domyślna T, gdy wyszukiwanie nie jest zgodne.</span><span class="sxs-lookup"><span data-stu-id="f6757-447">The value from the set that the search found, or the default value of T when the search yielded no match.</span></span></param>
        <summary><span data-ttu-id="f6757-448">Wyszukuje zestaw dla danej wartości i zwraca wartość równą znalezioną (jeśli istnieje).</span><span class="sxs-lookup"><span data-stu-id="f6757-448">Searches the set for a given value and returns the equal value it finds, if any.</span></span></summary>
        <returns><span data-ttu-id="f6757-449">Wartość wskazująca, czy wyszukiwanie zakończyło się pomyślnie.</span><span class="sxs-lookup"><span data-stu-id="f6757-449">A value indicating whether the search was successful.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6757-450">Może to być przydatne, jeśli chcesz ponownie użyć wcześniej przechowywanego odwołania zamiast nowo skonstruowanego elementu (tak, aby można było uzyskać więcej informacji o udostępnianiu odwołań) lub wyszukać wartość, która ma więcej kompletnych danych niż aktualnie posiadana wartość, chociaż ich funkcje porównujące wskaż, że są równe.</span><span class="sxs-lookup"><span data-stu-id="f6757-450">This can be useful when you want to reuse a previously stored reference instead of a newly constructed one (so that more sharing of references can occur) or to look up a value that has more complete data than the value you currently have, although their comparer functions indicate they are equal.</span></span>
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnionWith">
      <MemberSignature Language="C#" Value="public void UnionWith (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UnionWith(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnionWith (other As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void UnionWith(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member UnionWith : seq&lt;'T&gt; -&gt; unit&#xA;override this.UnionWith : seq&lt;'T&gt; -&gt; unit" Usage="hashSet.UnionWith other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ISet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="f6757-451">Kolekcja do porównania z bieżącym <see cref="T:System.Collections.Generic.HashSet`1" /> obiektem.</span><span class="sxs-lookup"><span data-stu-id="f6757-451">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span></span></param>
        <summary><span data-ttu-id="f6757-452">Modyfikuje bieżący <see cref="T:System.Collections.Generic.HashSet`1" /> obiekt w taki sposób, aby zawierał wszystkie elementy, które znajdują się w sobie, określonej kolekcji lub obu.</span><span class="sxs-lookup"><span data-stu-id="f6757-452">Modifies the current <see cref="T:System.Collections.Generic.HashSet`1" /> object to contain all elements that are present in itself, the specified collection, or both.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6757-453">Ta metoda jest operacją o`n`(), gdzie `n` jest `other` liczbą elementów w parametrze.</span><span class="sxs-lookup"><span data-stu-id="f6757-453">This method is an O(`n`) operation, where `n` is the number of elements in the `other` parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6757-454">Poniższy przykład pokazuje, jak scalić dwa różne zestawy.</span><span class="sxs-lookup"><span data-stu-id="f6757-454">The following example demonstrates how to merge two disparate sets.</span></span> <span data-ttu-id="f6757-455">Ten przykład tworzy dwa <xref:System.Collections.Generic.HashSet%601> obiekty i wypełnia je odpowiednio wartościami parzystymi i nieparzystymi.</span><span class="sxs-lookup"><span data-stu-id="f6757-455">This example creates two <xref:System.Collections.Generic.HashSet%601> objects, and populates them with even and odd numbers, respectively.</span></span> <span data-ttu-id="f6757-456">Trzeci <xref:System.Collections.Generic.HashSet%601> obiekt jest tworzony z zestawu, który zawiera liczby parzyste.</span><span class="sxs-lookup"><span data-stu-id="f6757-456">A third <xref:System.Collections.Generic.HashSet%601> object is created from the set that contains the even numbers.</span></span> <span data-ttu-id="f6757-457">Przykład następnie wywołuje <xref:System.Collections.Generic.HashSet%601.UnionWith%2A> metodę, która dodaje nieparzystą liczbę z zestawem trzecim.</span><span class="sxs-lookup"><span data-stu-id="f6757-457">The example then calls the <xref:System.Collections.Generic.HashSet%601.UnionWith%2A> method, which adds the odd number set to the third set.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_UnionWith#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/cs/Program.cs#01)]
 [!code-vb[System.Collections.Generic.HashSet_UnionWith#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/vb/Program.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="f6757-458"><paramref name="other" />jest <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="f6757-458"><paramref name="other" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>

<Type Name="Stack&lt;T&gt;" FullName="System.Collections.Generic.Stack&lt;T&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="0a5f625bde640333eddc536c6105addd602f183a" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36713844" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Stack&lt;T&gt; : System.Collections.Generic.IEnumerable&lt;T&gt;, System.Collections.Generic.IReadOnlyCollection&lt;T&gt;, System.Collections.ICollection" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Stack`1&lt;T&gt; extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;!T&gt;, class System.Collections.ICollection, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Generic.Stack`1" />
  <TypeSignature Language="VB.NET" Value="Public Class Stack(Of T)&#xA;Implements ICollection, IEnumerable(Of T), IReadOnlyCollection(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class Stack : System::Collections::Generic::IEnumerable&lt;T&gt;, System::Collections::Generic::IReadOnlyCollection&lt;T&gt;, System::Collections::ICollection" />
  <TypeSignature Language="F#" Value="type Stack&lt;'T&gt; = class&#xA;    interface seq&lt;'T&gt;&#xA;    interface ICollection&#xA;    interface IReadOnlyCollection&lt;'T&gt;&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Collections</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.System_StackDebugView`1))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">Określa typ elementów w stosie.</typeparam>
    <summary>Reprezentuje kolekcję (LIFO) ostatnich w pierwszym poza rozmiar zmiennej wystąpień tego samego typu określony.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.Stack%601> jest implementowany jako tablicy.  
  
 Stosów i kolejek są przydatne, gdy będziesz potrzebować tymczasowego przechowywania informacji; oznacza to, gdy można odrzucić elementu po pobraniu jej wartość. Użyj <xref:System.Collections.Generic.Queue%601> muszą uzyskać dostęp do informacji w tej samej kolejności, że jest on przechowywany w kolekcji. Użyj <xref:System.Collections.Generic.Stack%601?displayProperty=nameWithType> Jeśli musisz uzyskiwać dostęp do informacji w odwrotnej kolejności.  
  
 Użyj <xref:System.Collections.Concurrent.ConcurrentStack%601?displayProperty=nameWithType> i <xref:System.Collections.Concurrent.ConcurrentQueue%601?displayProperty=nameWithType> typy, gdy trzeba uzyskać dostępu do kolekcji przez wiele wątków jednocześnie.  
  
 Użycia <xref:System.Collections.Generic.Stack%601?displayProperty=nameWithType> jest zachowanie stanów zmiennej podczas wywołania do innych procedur.  
  
 Trzy główne operacje mogą być wykonywane na <xref:System.Collections.Generic.Stack%601?displayProperty=nameWithType> i jej elementów:  
  
-   <xref:System.Collections.Generic.Stack%601.Push%2A> Wstawia element w górnej części <xref:System.Collections.Stack>.  
  
-   <xref:System.Collections.Generic.Stack%601.Pop%2A> Usuwa element z góry <xref:System.Collections.Generic.Stack%601>.  
  
-   <xref:System.Collections.Generic.Stack%601.Peek%2A> Zwraca element, który znajduje się na początku <xref:System.Collections.Generic.Stack%601> , ale nie powoduje usunięcia go z <xref:System.Collections.Generic.Stack%601>.  
  
 Pojemność <xref:System.Collections.Generic.Stack%601> jest liczba elementów <xref:System.Collections.Generic.Stack%601> może przechowywać. Po dodaniu elementów do <xref:System.Collections.Generic.Stack%601>, automatycznie zostaje zwiększona wydajność zgodnie z żądaniem ponowne przydzielanie tablicy wewnętrznej. Można zmniejszyć pojemność przez wywołanie metody <xref:System.Collections.Generic.Stack%601.TrimExcess%2A>.  
  
 Jeśli <xref:System.Collections.Generic.Stack%601.Count%2A> jest mniejsza niż pojemność stosu, <xref:System.Collections.Generic.Stack%601.Push%2A> jest operacją O(1). Jeśli trzeba nowego elementu, można zwiększyć pojemność <xref:System.Collections.Generic.Stack%601.Push%2A> staje się O (`n`) operację, której `n` jest <xref:System.Collections.Generic.Stack%601.Count%2A>. <xref:System.Collections.Generic.Stack%601.Pop%2A> Operacja O(1) jest.  
  
 <xref:System.Collections.Generic.Stack%601> akceptuje `null` jako prawidłowa wartość dla odwołania do typów i umożliwia zduplikowane elementy.  
  
   
  
## Examples  
 W poniższym przykładzie kodu pokazano kilka metod <xref:System.Collections.Generic.Stack%601> klasy ogólnej. Przykład kodu tworzy stosu ciągów o pojemności domyślnej i używa <xref:System.Collections.Generic.Stack%601.Push%2A> metody do dystrybuowania pięć ciągów na stosie. Wyliczane są elementy stosu nie zmienia stanu stosu. <xref:System.Collections.Generic.Stack%601.Pop%2A> Metoda jest używana do pop pierwszy ciąg ze stosu. <xref:System.Collections.Generic.Stack%601.Peek%2A> Metodę spojrzeć na następny element na stosie, a następnie <xref:System.Collections.Generic.Stack%601.Pop%2A> metoda jest używana do Powiększ go.  
  
 <xref:System.Collections.Generic.Stack%601.ToArray%2A> Metoda jest używana do utworzenia tablicy i skopiuj do niego elementów stosu, a następnie tablicy jest przekazywana do <xref:System.Collections.Generic.Stack%601.%23ctor%2A> konstruktora przyjmującego <xref:System.Collections.Generic.IEnumerable%601>, tworząc kopię stosu w kolejności elementów wycofane. Elementy kopii są wyświetlane.  
  
 Tablica dwukrotnie rozmiar stosu jest tworzony i <xref:System.Collections.Generic.Stack%601.CopyTo%2A> metoda służy do kopiowania elementów tablicy, zaczynając od środka tablicy. <xref:System.Collections.Generic.Stack%601.%23ctor%2A> Konstruktor jest używany ponownie, aby utworzyć kopię stosu w kolejności elementów cofnąć; w związku z tym trzy elementy wartości null znajdują się na końcu.  
  
 <xref:System.Collections.Generic.Stack%601.Contains%2A> Metoda jest używana do pokazują, że ciąg "4" jest pierwsza kopia stosu, po którym <xref:System.Collections.Generic.Stack%601.Clear%2A> metoda usuwa kopię i <xref:System.Collections.Generic.Stack%601.Count%2A> właściwość pokazuje, że stos jest pusty.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Publiczne statyczne (<see langword="Shared" /> w języku Visual Basic) elementy członkowskie tego typu są bezpieczne dla wątków. Wystąpienia elementów członkowskich nie dają gwarancji bezpieczeństwa wątków.  A <see cref="T:System.Collections.Generic.Stack`1" /> może obsługiwać wielu czytników jednocześnie, jak długo kolekcji nie jest modyfikowany.  Mimo tego, wyliczania kolekcji leżą nie jest bezpieczne wątkowo procedurą.  Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania.  Aby zezwolić wielu wątkom na dostęp do kolekcji w celu odczytu i zapisu danych, należy zaimplementować własny mechanizm synchronizacji.</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Collections.Generic.Stack`1" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Stack ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Stack();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Collections.Generic.Stack`1" /> klasy, która jest pusty i ma początkowej wydajności domyślnej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pojemność <xref:System.Collections.Generic.Stack%601> jest liczba elementów który <xref:System.Collections.Generic.Stack%601> może przechowywać. Po dodaniu elementów do <xref:System.Collections.Generic.Stack%601>, automatycznie zostaje zwiększona wydajność zgodnie z żądaniem ponowne przydzielanie tablicy wewnętrznej.  
  
 Jeśli rozmiar kolekcji można oszacować, określając początkowa pojemność eliminuje konieczność wykonania wielu operacji zmiany rozmiaru podczas dodawania elementów do <xref:System.Collections.Generic.Stack%601>.  
  
 Można zmniejszyć pojemność przez wywołanie metody <xref:System.Collections.Generic.Stack%601.TrimExcess%2A>.  
  
 Ten konstruktor jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje ten konstruktor i kilka metod <xref:System.Collections.Generic.Stack%601> klasy ogólnej.  
  
 Przykład kodu tworzy stosu ciągów o pojemności domyślnej i używa <xref:System.Collections.Generic.Stack%601.Push%2A> metody do dystrybuowania pięć ciągów na stosie. Wyliczane są elementy stosu nie zmienia stanu stosu. <xref:System.Collections.Generic.Stack%601.Pop%2A> Metoda jest używana do pop pierwszy ciąg ze stosu. <xref:System.Collections.Generic.Stack%601.Peek%2A> Metodę spojrzeć na następny element na stosie, a następnie <xref:System.Collections.Generic.Stack%601.Pop%2A> metoda jest używana do Powiększ go.  
  
 <xref:System.Collections.Generic.Stack%601.ToArray%2A> Metoda jest używana do utworzenia tablicy i skopiuj do niego elementów stosu, a następnie tablicy jest przekazywana do <xref:System.Collections.Generic.Stack%601.%23ctor%2A> konstruktora przyjmującego <xref:System.Collections.Generic.IEnumerable%601>, tworząc kopię stosu w kolejności elementów wycofane. Elementy kopii są wyświetlane.  
  
 Tablica dwukrotnie rozmiar stosu jest tworzony i <xref:System.Collections.Generic.Stack%601.CopyTo%2A> metoda służy do kopiowania elementów tablicy, zaczynając od środka tablicy. <xref:System.Collections.Generic.Stack%601.%23ctor%2A> Konstruktor jest używany ponownie, aby utworzyć kopię stosu w kolejności elementów cofnąć; w związku z tym trzy elementy wartości null znajdują się na końcu.  
  
 <xref:System.Collections.Generic.Stack%601.Contains%2A> Metoda jest używana do pokazują, że ciąg "4" jest pierwsza kopia stosu, po którym <xref:System.Collections.Generic.Stack%601.Clear%2A> metoda usuwa kopię i <xref:System.Collections.Generic.Stack%601.Count%2A> właściwość pokazuje, że stos jest pusty.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Stack (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.#ctor(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Stack(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.Stack&lt;'T&gt; : seq&lt;'T&gt; -&gt; System.Collections.Generic.Stack&lt;'T&gt;" Usage="new System.Collections.Generic.Stack&lt;'T&gt; collection" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">Aby skopiować elementy z kolekcji.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Collections.Generic.Stack`1" /> skopiowane klasy, która zawiera elementów kopiowanych z określonej kolekcji i ma wystarczającej wydajności, aby pomieścić liczby elementów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pojemność <xref:System.Collections.Generic.Stack%601> jest liczba elementów który <xref:System.Collections.Generic.Stack%601> może przechowywać. Po dodaniu elementów do <xref:System.Collections.Generic.Stack%601>, automatycznie zostaje zwiększona wydajność zgodnie z żądaniem ponowne przydzielanie tablicy wewnętrznej.  
  
 Jeśli rozmiar kolekcji można oszacować, określając początkowa pojemność eliminuje konieczność wykonania wielu operacji zmiany rozmiaru podczas dodawania elementów do <xref:System.Collections.Generic.Stack%601>.  
  
 Można zmniejszyć pojemność przez wywołanie metody <xref:System.Collections.Generic.Stack%601.TrimExcess%2A>.  
  
 Elementy są kopiowane na <xref:System.Collections.Generic.Stack%601> w tej samej kolejności odczytywania ich przez <xref:System.Collections.Generic.IEnumerator%601> kolekcji.  
  
 Ten konstruktor jest O (`n`) operację, której `n` jest liczba elementów w `collection`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje ten konstruktor i kilka metod <xref:System.Collections.Generic.Stack%601> klasy ogólnej.  
  
 Przykład kodu tworzy stosu ciągów o pojemności domyślnej i używa <xref:System.Collections.Generic.Stack%601.Push%2A> metody do dystrybuowania pięć ciągów na stosie. Wyliczane są elementy stosu nie zmienia stanu stosu. <xref:System.Collections.Generic.Stack%601.Pop%2A> Metoda jest używana do pop pierwszy ciąg ze stosu. <xref:System.Collections.Generic.Stack%601.Peek%2A> Metodę spojrzeć na następny element na stosie, a następnie <xref:System.Collections.Generic.Stack%601.Pop%2A> metoda jest używana do Powiększ go.  
  
 <xref:System.Collections.Generic.Stack%601.ToArray%2A> Metoda jest używana do utworzenia tablicy i skopiuj do niego elementów stosu, a następnie tablicy jest przekazywana do <xref:System.Collections.Generic.Stack%601.%23ctor%2A> konstruktora przyjmującego <xref:System.Collections.Generic.IEnumerable%601>, tworząc kopię stosu w kolejności elementów wycofane. Elementy kopii są wyświetlane.  
  
 Tablica dwukrotnie rozmiar stosu jest tworzony i <xref:System.Collections.Generic.Stack%601.CopyTo%2A> metoda służy do kopiowania elementów tablicy, zaczynając od środka tablicy. <xref:System.Collections.Generic.Stack%601.%23ctor%2A> Konstruktor jest używany ponownie, aby utworzyć kopię stosu w kolejności elementów cofnąć; w związku z tym trzy elementy wartości null znajdują się na końcu.  
  
 <xref:System.Collections.Generic.Stack%601.Contains%2A> Metoda jest używana do pokazują, że ciąg "4" jest pierwsza kopia stosu, po którym <xref:System.Collections.Generic.Stack%601.Clear%2A> metoda usuwa kopię i <xref:System.Collections.Generic.Stack%601.Count%2A> właściwość pokazuje, że stos jest pusty.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collection" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Collections.Generic.ICollection`1" />
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Stack (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Stack(int capacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.Stack&lt;'T&gt; : int -&gt; System.Collections.Generic.Stack&lt;'T&gt;" Usage="new System.Collections.Generic.Stack&lt;'T&gt; capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Początkowa liczba elementów który <see cref="T:System.Collections.Generic.Stack`1" /> może zawierać.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Collections.Generic.Stack`1" /> klasy, która jest pusty i określonej pojemności początkowej lub początkowa pojemność domyślny, w zależności od jest większa.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pojemność <xref:System.Collections.Generic.Stack%601> jest liczba elementów który <xref:System.Collections.Generic.Stack%601> może przechowywać. Po dodaniu elementów do <xref:System.Collections.Generic.Stack%601>, automatycznie zostaje zwiększona wydajność zgodnie z żądaniem ponowne przydzielanie tablicy wewnętrznej.  
  
 Jeśli rozmiar kolekcji można oszacować, określając początkowa pojemność eliminuje konieczność wykonania wielu operacji zmiany rozmiaru podczas dodawania elementów do <xref:System.Collections.Generic.Stack%601>.  
  
 Można zmniejszyć pojemność przez wywołanie metody <xref:System.Collections.Generic.Stack%601.TrimExcess%2A>.  
  
 Ten konstruktor jest O (`n`) operację, której `n` jest `capacity`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> jest mniejsza od zera.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="stack.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa wszystkie obiekty z <see cref="T:System.Collections.Generic.Stack`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.Stack%601.Count%2A> jest ustawiany na zero, a ponadto są również zwalniane odwołania do innych obiektów z elementów kolekcji.  
  
 Pojemność pozostaje niezmieniona. Aby zresetować pojemność <xref:System.Collections.Generic.Stack%601>, wywołaj <xref:System.Collections.Generic.Stack%601.TrimExcess%2A>. Przycinanie pustą <xref:System.Collections.Generic.Stack%601> ustawia pojemność <xref:System.Collections.Generic.Stack%601> do wydajności domyślnej.  
  
 Ta metoda jest O (`n`) operację, której `n` jest <xref:System.Collections.Generic.Stack%601.Count%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie kodu pokazano kilka metod <xref:System.Collections.Generic.Stack%601> klasy ogólnej, łącznie z <xref:System.Collections.Generic.Stack%601.Clear%2A> metody.  
  
 Przykład kodu tworzy stosu ciągów o pojemności domyślnej i używa <xref:System.Collections.Generic.Stack%601.Push%2A> metody do dystrybuowania pięć ciągów na stosie. Wyliczane są elementy stosu nie zmienia stanu stosu. <xref:System.Collections.Generic.Stack%601.Pop%2A> Metoda jest używana do pop pierwszy ciąg ze stosu. <xref:System.Collections.Generic.Stack%601.Peek%2A> Metodę spojrzeć na następny element na stosie, a następnie <xref:System.Collections.Generic.Stack%601.Pop%2A> metoda jest używana do Powiększ go.  
  
 <xref:System.Collections.Generic.Stack%601.ToArray%2A> Metoda jest używana do utworzenia tablicy i skopiuj do niego elementów stosu, a następnie tablicy jest przekazywana do <xref:System.Collections.Generic.Stack%601.%23ctor%2A> konstruktora przyjmującego <xref:System.Collections.Generic.IEnumerable%601>, tworząc kopię stosu w kolejności elementów wycofane. Elementy kopii są wyświetlane.  
  
 Tablica dwukrotnie rozmiar stosu jest tworzony i <xref:System.Collections.Generic.Stack%601.CopyTo%2A> metoda służy do kopiowania elementów tablicy, zaczynając od środka tablicy. <xref:System.Collections.Generic.Stack%601.%23ctor%2A> Konstruktor jest używany ponownie, aby utworzyć kopię stosu w kolejności elementów cofnąć; w związku z tym trzy elementy wartości null znajdują się na końcu.  
  
 <xref:System.Collections.Generic.Stack%601.Contains%2A> Metoda jest używana do pokazują, że ciąg "4" jest pierwsza kopia stosu, po którym <xref:System.Collections.Generic.Stack%601.Clear%2A> metoda usuwa kopię i <xref:System.Collections.Generic.Stack%601.Count%2A> właściwość pokazuje, że stos jest pusty.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.Contains(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(T item);" />
      <MemberSignature Language="F#" Value="member this.Contains : 'T -&gt; bool" Usage="stack.Contains item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Obiekt do zlokalizowania w <see cref="T:System.Collections.Generic.Stack`1" />. Wartość może być <see langword="null" /> dla typów odwołań.</param>
        <summary>Określa, czy element jest <see cref="T:System.Collections.Generic.Stack`1" />.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="item" /> znajduje się w <see cref="T:System.Collections.Generic.Stack`1" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda określa równości przy użyciu domyślna funkcja porównująca równości <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> dla `T`, typu wartości na liście.  
  
 Ta metoda wykonuje wyszukiwanie liniowe; w związku z tym ta metoda jest O (`n`) operację, której `n` jest <xref:System.Collections.Generic.Stack%601.Count%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie kodu pokazano kilka metod <xref:System.Collections.Generic.Stack%601> klasy ogólnej, łącznie z <xref:System.Collections.Generic.Stack%601.Contains%2A> metody.  
  
 Przykład kodu tworzy stosu ciągów o pojemności domyślnej i używa <xref:System.Collections.Generic.Stack%601.Push%2A> metody do dystrybuowania pięć ciągów na stosie. Wyliczane są elementy stosu nie zmienia stanu stosu. <xref:System.Collections.Generic.Stack%601.Pop%2A> Metoda jest używana do pop pierwszy ciąg ze stosu. <xref:System.Collections.Generic.Stack%601.Peek%2A> Metodę spojrzeć na następny element na stosie, a następnie <xref:System.Collections.Generic.Stack%601.Pop%2A> metoda jest używana do Powiększ go.  
  
 <xref:System.Collections.Generic.Stack%601.ToArray%2A> Metoda jest używana do utworzenia tablicy i skopiuj do niego elementów stosu, a następnie tablicy jest przekazywana do <xref:System.Collections.Generic.Stack%601.%23ctor%2A> konstruktora przyjmującego <xref:System.Collections.Generic.IEnumerable%601>, tworząc kopię stosu w kolejności elementów wycofane. Elementy kopii są wyświetlane.  
  
 Tablica dwukrotnie rozmiar stosu jest tworzony i <xref:System.Collections.Generic.Stack%601.CopyTo%2A> metoda służy do kopiowania elementów tablicy, zaczynając od środka tablicy. <xref:System.Collections.Generic.Stack%601.%23ctor%2A> Konstruktor jest używany ponownie, aby utworzyć kopię stosu w kolejności elementów cofnąć; w związku z tym trzy elementy wartości null znajdują się na końcu.  
  
 <xref:System.Collections.Generic.Stack%601.Contains%2A> Metoda jest używana do pokazują, że ciąg "4" jest pierwsza kopia stosu, po którym <xref:System.Collections.Generic.Stack%601.Clear%2A> metoda usuwa kopię i <xref:System.Collections.Generic.Stack%601.Count%2A> właściwość pokazuje, że stos jest pusty.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(!T[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.CopyTo(`0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T(), arrayIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;T&gt; ^ array, int arrayIndex);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : 'T[] * int -&gt; unit" Usage="stack.CopyTo (array, arrayIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Jednowymiarowa <see cref="T:System.Array" /> który jest miejscem docelowym elementów kopiowanych z <see cref="T:System.Collections.Generic.Stack`1" />. <see cref="T:System.Array" /> Musi mieć indeksowania liczony od zera.</param>
        <param name="arrayIndex">Liczony od zera indeks w <c>tablicy</c> od rozpoczyna się kopiowanie które.</param>
        <summary>Kopie <see cref="T:System.Collections.Generic.Stack`1" /> do istniejącej jednowymiarowej tablicy <see cref="T:System.Array" />, rozpoczynając od określonego indeksu tablicy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Elementy są kopiowane na tablicy w kolejności (LIFO) ostatnich w pierwszym poza, podobne polecenie elementów zwróconych przez kolejne wywołania <xref:System.Collections.Generic.Stack%601.Pop%2A>.  
  
 Ta metoda jest O (`n`) operację, której `n` jest <xref:System.Collections.Generic.Stack%601.Count%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie kodu pokazano kilka metod <xref:System.Collections.Generic.Stack%601> klasy ogólnej, łącznie z <xref:System.Collections.Generic.Stack%601.CopyTo%2A> metody.  
  
 Przykład kodu tworzy stosu ciągów o pojemności domyślnej i używa <xref:System.Collections.Generic.Stack%601.Push%2A> metody do dystrybuowania pięć ciągów na stosie. Wyliczane są elementy stosu nie zmienia stanu stosu. <xref:System.Collections.Generic.Stack%601.Pop%2A> Metoda jest używana do pop pierwszy ciąg ze stosu. <xref:System.Collections.Generic.Stack%601.Peek%2A> Metodę spojrzeć na następny element na stosie, a następnie <xref:System.Collections.Generic.Stack%601.Pop%2A> metoda jest używana do Powiększ go.  
  
 <xref:System.Collections.Generic.Stack%601.ToArray%2A> Metoda jest używana do utworzenia tablicy i skopiuj do niego elementów stosu, a następnie tablicy jest przekazywana do <xref:System.Collections.Generic.Stack%601.%23ctor%2A> konstruktora przyjmującego <xref:System.Collections.Generic.IEnumerable%601>, tworząc kopię stosu w kolejności elementów wycofane. Elementy kopii są wyświetlane.  
  
 Tablica dwukrotnie rozmiar stosu jest tworzony i <xref:System.Collections.Generic.Stack%601.CopyTo%2A> metoda służy do kopiowania elementów tablicy, zaczynając od środka tablicy. <xref:System.Collections.Generic.Stack%601.%23ctor%2A> Konstruktor jest używany ponownie, aby utworzyć kopię stosu w kolejności elementów cofnąć; w związku z tym trzy elementy wartości null znajdują się na końcu.  
  
 <xref:System.Collections.Generic.Stack%601.Contains%2A> Metoda jest używana do pokazują, że ciąg "4" jest pierwsza kopia stosu, po którym <xref:System.Collections.Generic.Stack%601.Clear%2A> metoda usuwa kopię i <xref:System.Collections.Generic.Stack%601.Count%2A> właściwość pokazuje, że stos jest pusty.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="arrayIndex" /> jest mniejsza od zera.</exception>
        <exception cref="T:System.ArgumentException">Liczba elementów w źródle <see cref="T:System.Collections.Generic.Stack`1" /> jest większa niż dostępne miejsce od <paramref name="arrayIndex" /> do końca tablicy docelowej <paramref name="array" />.</exception>
        <altmember cref="M:System.Collections.Generic.Stack`1.ToArray" />
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Stack`1.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.Generic.Stack&lt;'T&gt;.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyCollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę elementów zawartych w <see cref="T:System.Collections.Generic.Stack`1" />.</summary>
        <value>Liczba elementów zawartych w <see cref="T:System.Collections.Generic.Stack`1" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pojemność <xref:System.Collections.Generic.Stack%601> jest liczba elementów który <xref:System.Collections.Generic.Stack%601> może przechowywać. <xref:System.Collections.Generic.Stack%601.Count%2A> jest to liczba elementów, które są rzeczywiście w <xref:System.Collections.Generic.Stack%601>.  
  
 Pojemność zawsze jest większa niż lub równa <xref:System.Collections.Generic.Stack%601.Count%2A>. Jeśli <xref:System.Collections.Generic.Stack%601.Count%2A> przekracza pojemność podczas dodawania elementów, pojemność zwiększa się o automatyczne ponowne przydzielanie tablicy wewnętrznej przed skopiowaniem starych elementów i dodawanie nowych elementów.  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
   
  
## Examples  
 W poniższym przykładzie kodu pokazano kilka właściwości i metod <xref:System.Collections.Generic.Stack%601> klasy ogólnej, łącznie z <xref:System.Collections.Generic.Stack%601.Count%2A> właściwości.  
  
 Przykład kodu tworzy stosu ciągów o pojemności domyślnej i używa <xref:System.Collections.Generic.Stack%601.Push%2A> metody do dystrybuowania pięć ciągów na stosie. Wyliczane są elementy stosu nie zmienia stanu stosu. <xref:System.Collections.Generic.Stack%601.Pop%2A> Metoda jest używana do pop pierwszy ciąg ze stosu. <xref:System.Collections.Generic.Stack%601.Peek%2A> Metodę spojrzeć na następny element na stosie, a następnie <xref:System.Collections.Generic.Stack%601.Pop%2A> metoda jest używana do Powiększ go.  
  
 <xref:System.Collections.Generic.Stack%601.ToArray%2A> Metoda jest używana do utworzenia tablicy i skopiuj do niego elementów stosu, a następnie tablicy jest przekazywana do <xref:System.Collections.Generic.Stack%601.%23ctor%2A> konstruktora przyjmującego <xref:System.Collections.Generic.IEnumerable%601>, tworząc kopię stosu w kolejności elementów wycofane. Elementy kopii są wyświetlane.  
  
 Tablica dwukrotnie rozmiar stosu jest tworzony i <xref:System.Collections.Generic.Stack%601.CopyTo%2A> metoda służy do kopiowania elementów tablicy, zaczynając od środka tablicy. <xref:System.Collections.Generic.Stack%601.%23ctor%2A> Konstruktor jest używany ponownie, aby utworzyć kopię stosu w kolejności elementów cofnąć; w związku z tym trzy elementy wartości null znajdują się na końcu.  
  
 <xref:System.Collections.Generic.Stack%601.Contains%2A> Metoda jest używana do pokazują, że ciąg "4" jest pierwsza kopia stosu, po którym <xref:System.Collections.Generic.Stack%601.Clear%2A> metoda usuwa kopię i <xref:System.Collections.Generic.Stack%601.Count%2A> właściwość pokazuje, że stos jest pusty.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.Stack&lt;T&gt;.Enumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Collections.Generic.Stack`1/Enumerator&lt;!T&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As Stack(Of T).Enumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::Stack&lt;T&gt;::Enumerator GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; System.Collections.Generic.Stack&lt;'T&gt;.Enumerator" Usage="stack.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Stack&lt;T&gt;+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca moduł wyliczający dla <see cref="T:System.Collections.Generic.Stack`1" />.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.Stack`1.Enumerator" /> Dla <see cref="T:System.Collections.Generic.Stack`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `foreach` Instrukcji języka C# (`for each` w języku C++ `For Each` w języku Visual Basic) ukrywa złożoność wyliczenia. W związku z tym przy użyciu `foreach` jest zalecane, zamiast bezpośrednie manipulowanie modułu wyliczającego.  
  
 Moduły wyliczające mogą służyć do odczytu danych w kolekcji, ale nie można za ich pomocą modyfikować kolekcji źródłowej.  
  
 Początkowo moduł wyliczający jest umieszczony przed pierwszym elementem w kolekcji. W tym miejscu <xref:System.Collections.Generic.Stack%601.Enumerator.Current%2A> jest niezdefiniowana. W związku z tym należy wywołać <xref:System.Collections.Generic.Stack%601.Enumerator.MoveNext%2A> można poprawić modułu wyliczającego pierwszy element do kolekcji przed odczytywania wartości <xref:System.Collections.Generic.Stack%601.Enumerator.Current%2A>.  
  
 <xref:System.Collections.Generic.Stack%601.Enumerator.Current%2A> Zwraca tego samego obiektu, dopóki nie <xref:System.Collections.Generic.Stack%601.Enumerator.MoveNext%2A> jest wywoływana. <xref:System.Collections.Generic.Stack%601.Enumerator.MoveNext%2A> Ustawia <xref:System.Collections.Generic.Stack%601.Enumerator.Current%2A> do następnego elementu.  
  
 Jeśli <xref:System.Collections.Generic.Stack%601.Enumerator.MoveNext%2A> przekazuje końcem kolekcji, moduł wyliczający jest umieszczony za ostatnim elementem w kolekcji i <xref:System.Collections.Generic.Stack%601.Enumerator.MoveNext%2A> zwraca `false`. Gdy moduł wyliczający jest w tym miejscu kolejnych wywołań <xref:System.Collections.Generic.Stack%601.Enumerator.MoveNext%2A> zwracają również `false`. Jeśli przez ostatnie wywołanie <xref:System.Collections.Generic.Stack%601.Enumerator.MoveNext%2A> zwrócił `false`, <xref:System.Collections.Generic.Stack%601.Enumerator.Current%2A> jest niezdefiniowana. Nie można ustawić <xref:System.Collections.Generic.Stack%601.Enumerator.Current%2A> do pierwszego elementu w kolekcji; należy utworzyć nowe wystąpienie modułu wyliczającego zamiast tego.  
  
 Moduł wyliczający zachowuje ważność tak długo, jak długo kolekcja pozostaje niezmieniona. Jeśli zmiany zostały wprowadzone do kolekcji, takie jak dodawanie, modyfikowanie lub usuwanie elementów, moduł wyliczający jest bezpowrotnie unieważniona, a następne wywołanie <xref:System.Collections.Generic.Stack%601.Enumerator.MoveNext%2A> lub <xref:System.Collections.Generic.Stack%601.Enumerator.System%23Collections%23IEnumerator%23Reset%2A> zgłasza <xref:System.InvalidOperationException>.  
  
 Moduł wyliczający nie ma wyłącznego dostępu do kolekcji, w związku z tym wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość. Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania.  Aby zezwolić wielu wątkom na dostęp do kolekcji w celu odczytu i zapisu danych, należy zaimplementować własny mechanizm synchronizacji.  
  
 Domyślne implementacje kolekcji w <xref:System.Collections.Generic?displayProperty=nameWithType> nie są zsynchronizowane.  
  
 Ta metoda jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, że <xref:System.Collections.Generic.Stack%601> enumerable jest klasą ogólną. `foreach` Instrukcji (`For Each` w języku Visual Basic `for each` w języku C++) jest używany do wyliczenia kolejki.  
  
 Przykład kodu tworzy stosu ciągów o pojemności domyślnej i używa <xref:System.Collections.Generic.Stack%601.Push%2A> metody do dystrybuowania pięć ciągów na stosie. Wyliczane są elementy stosu nie zmienia stanu stosu. <xref:System.Collections.Generic.Stack%601.Pop%2A> Metoda jest używana do pop pierwszy ciąg ze stosu. <xref:System.Collections.Generic.Stack%601.Peek%2A> Metodę spojrzeć na następny element na stosie, a następnie <xref:System.Collections.Generic.Stack%601.Pop%2A> metoda jest używana do Powiększ go.  
  
 <xref:System.Collections.Generic.Stack%601.ToArray%2A> Metoda jest używana do utworzenia tablicy i skopiuj do niego elementów stosu, a następnie tablicy jest przekazywana do <xref:System.Collections.Generic.Stack%601.%23ctor%2A> konstruktora przyjmującego <xref:System.Collections.Generic.IEnumerable%601>, tworząc kopię stosu w kolejności elementów wycofane. Elementy kopii są wyświetlane.  
  
 Tablica dwukrotnie rozmiar stosu jest tworzony i <xref:System.Collections.Generic.Stack%601.CopyTo%2A> metoda służy do kopiowania elementów tablicy, zaczynając od środka tablicy. <xref:System.Collections.Generic.Stack%601.%23ctor%2A> Konstruktor jest używany ponownie, aby utworzyć kopię stosu w kolejności elementów cofnąć; w związku z tym trzy elementy wartości null znajdują się na końcu.  
  
 <xref:System.Collections.Generic.Stack%601.Contains%2A> Metoda jest używana do pokazują, że ciąg "4" jest pierwsza kopia stosu, po którym <xref:System.Collections.Generic.Stack%601.Clear%2A> metoda usuwa kopię i <xref:System.Collections.Generic.Stack%601.Count%2A> właściwość pokazuje, że stos jest pusty.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.Stack`1.Enumerator" />
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public T Peek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T Peek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.Peek" />
      <MemberSignature Language="VB.NET" Value="Public Function Peek () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T Peek();" />
      <MemberSignature Language="F#" Value="member this.Peek : unit -&gt; 'T" Usage="stack.Peek " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca obiekt, w górnej części <see cref="T:System.Collections.Generic.Stack`1" /> bez usuwania go.</summary>
        <returns>Obiekt w górnej części <see cref="T:System.Collections.Generic.Stack`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest podobna do <xref:System.Collections.Generic.Stack%601.Pop%2A> metody, ale <xref:System.Collections.Generic.Stack%601.Peek%2A> nie modyfikuje <xref:System.Collections.Generic.Stack%601>.  
  
 Jeśli typ `T` jest typem referencyjnym `null` może zostać umieszczony na <xref:System.Collections.Generic.Stack%601> jako symbolu zastępczego, jeśli to konieczne.  
  
 Ta metoda jest operacją O(1).  
  
   
  
## Examples  
 W poniższym przykładzie kodu pokazano kilka metod <xref:System.Collections.Generic.Stack%601> klasy ogólnej, łącznie z <xref:System.Collections.Generic.Stack%601.Peek%2A> metody.  
  
 Przykład kodu tworzy stosu ciągów o pojemności domyślnej i używa <xref:System.Collections.Generic.Stack%601.Push%2A> metody do dystrybuowania pięć ciągów na stosie. Wyliczane są elementy stosu nie zmienia stanu stosu. <xref:System.Collections.Generic.Stack%601.Pop%2A> Metoda jest używana do pop pierwszy ciąg ze stosu. <xref:System.Collections.Generic.Stack%601.Peek%2A> Metodę spojrzeć na następny element na stosie, a następnie <xref:System.Collections.Generic.Stack%601.Pop%2A> metoda jest używana do Powiększ go.  
  
 <xref:System.Collections.Generic.Stack%601.ToArray%2A> Metoda jest używana do utworzenia tablicy i skopiuj do niego elementów stosu, a następnie tablicy jest przekazywana do <xref:System.Collections.Generic.Stack%601.%23ctor%2A> konstruktora przyjmującego <xref:System.Collections.Generic.IEnumerable%601>, tworząc kopię stosu w kolejności elementów wycofane. Elementy kopii są wyświetlane.  
  
 Tablica dwukrotnie rozmiar stosu jest tworzony i <xref:System.Collections.Generic.Stack%601.CopyTo%2A> metoda służy do kopiowania elementów tablicy, zaczynając od środka tablicy. <xref:System.Collections.Generic.Stack%601.%23ctor%2A> Konstruktor jest używany ponownie, aby utworzyć kopię stosu w kolejności elementów cofnąć; w związku z tym trzy elementy wartości null znajdują się na końcu.  
  
 <xref:System.Collections.Generic.Stack%601.Contains%2A> Metoda jest używana do pokazują, że ciąg "4" jest pierwsza kopia stosu, po którym <xref:System.Collections.Generic.Stack%601.Clear%2A> metoda usuwa kopię i <xref:System.Collections.Generic.Stack%601.Count%2A> właściwość pokazuje, że stos jest pusty.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Collections.Generic.Stack`1" /> Jest pusta.</exception>
        <altmember cref="M:System.Collections.Generic.Stack`1.Pop" />
        <altmember cref="M:System.Collections.Generic.Stack`1.Push(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Pop">
      <MemberSignature Language="C#" Value="public T Pop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T Pop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.Pop" />
      <MemberSignature Language="VB.NET" Value="Public Function Pop () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T Pop();" />
      <MemberSignature Language="F#" Value="member this.Pop : unit -&gt; 'T" Usage="stack.Pop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa i zwraca obiekt, w górnej części <see cref="T:System.Collections.Generic.Stack`1" />.</summary>
        <returns>Usunąć obiektu z góry <see cref="T:System.Collections.Generic.Stack`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest podobna do <xref:System.Collections.Generic.Stack%601.Peek%2A> metody, ale <xref:System.Collections.Generic.Stack%601.Peek%2A> nie modyfikuje <xref:System.Collections.Generic.Stack%601>.  
  
 Jeśli typ `T` jest typem referencyjnym `null` może zostać umieszczony na <xref:System.Collections.Generic.Stack%601> jako symbolu zastępczego, jeśli to konieczne.  
  
 <xref:System.Collections.Generic.Stack%601> jest implementowany jako tablicy. Ta metoda jest operacją O(1).  
  
   
  
## Examples  
 W poniższym przykładzie kodu pokazano kilka metod <xref:System.Collections.Generic.Stack%601> klasy ogólnej, łącznie z <xref:System.Collections.Generic.Stack%601.Pop%2A> metody.  
  
 Przykład kodu tworzy stosu ciągów o pojemności domyślnej i używa <xref:System.Collections.Generic.Stack%601.Push%2A> metody do dystrybuowania pięć ciągów na stosie. Wyliczane są elementy stosu nie zmienia stanu stosu. <xref:System.Collections.Generic.Stack%601.Pop%2A> Metoda jest używana do pop pierwszy ciąg ze stosu. <xref:System.Collections.Generic.Stack%601.Peek%2A> Metodę spojrzeć na następny element na stosie, a następnie <xref:System.Collections.Generic.Stack%601.Pop%2A> metoda jest używana do Powiększ go.  
  
 <xref:System.Collections.Generic.Stack%601.ToArray%2A> Metoda jest używana do utworzenia tablicy i skopiuj do niego elementów stosu, a następnie tablicy jest przekazywana do <xref:System.Collections.Generic.Stack%601.%23ctor%2A> konstruktora przyjmującego <xref:System.Collections.Generic.IEnumerable%601>, tworząc kopię stosu w kolejności elementów wycofane. Elementy kopii są wyświetlane.  
  
 Tablica dwukrotnie rozmiar stosu jest tworzony i <xref:System.Collections.Generic.Stack%601.CopyTo%2A> metoda służy do kopiowania elementów tablicy, zaczynając od środka tablicy. <xref:System.Collections.Generic.Stack%601.%23ctor%2A> Konstruktor jest używany ponownie, aby utworzyć kopię stosu w kolejności elementów cofnąć; w związku z tym trzy elementy wartości null znajdują się na końcu.  
  
 <xref:System.Collections.Generic.Stack%601.Contains%2A> Metoda jest używana do pokazują, że ciąg "4" jest pierwsza kopia stosu, po którym <xref:System.Collections.Generic.Stack%601.Clear%2A> metoda usuwa kopię i <xref:System.Collections.Generic.Stack%601.Count%2A> właściwość pokazuje, że stos jest pusty.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Collections.Generic.Stack`1" /> Jest pusta.</exception>
        <altmember cref="M:System.Collections.Generic.Stack`1.Peek" />
        <altmember cref="M:System.Collections.Generic.Stack`1.Push(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Push">
      <MemberSignature Language="C#" Value="public void Push (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Push(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.Push(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Push (item As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Push(T item);" />
      <MemberSignature Language="F#" Value="member this.Push : 'T -&gt; unit" Usage="stack.Push item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Obiekt do przekazania do <see cref="T:System.Collections.Generic.Stack`1" />. Wartość może być <see langword="null" /> dla typów odwołań.</param>
        <summary>Wstawia obiektu w górnej części <see cref="T:System.Collections.Generic.Stack`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.Stack%601> jest implementowany jako tablicy.  
  
 Jeśli <xref:System.Collections.Generic.Stack%601.Count%2A> jest już równa pojemności pojemność <xref:System.Collections.Generic.Stack%601> zwiększa się o automatyczne ponowne przydzielanie tablicy wewnętrznej, a istniejące elementy są kopiowane do nowej tablicy przed dodaniem nowego elementu.  
  
 Jeśli typ `T` jest typem referencyjnym `null` może zostać umieszczony na <xref:System.Collections.Generic.Stack%601> jako symbolu zastępczego, jeśli to konieczne. Zajmuje miejsca na stosie, a jest traktowany jak inne obiekty.  
  
 Jeśli <xref:System.Collections.Generic.Stack%601.Count%2A> jest mniejsza niż pojemność stosu, <xref:System.Collections.Generic.Stack%601.Push%2A> jest operacją O(1). Jeśli trzeba nowego elementu, można zwiększyć pojemność <xref:System.Collections.Generic.Stack%601.Push%2A> staje się O (`n`) operację, której `n` jest <xref:System.Collections.Generic.Stack%601.Count%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie kodu pokazano kilka metod <xref:System.Collections.Generic.Stack%601> klasy ogólnej, łącznie z <xref:System.Collections.Generic.Stack%601.Push%2A> metody.  
  
 Przykład kodu tworzy stosu ciągów o pojemności domyślnej i używa <xref:System.Collections.Generic.Stack%601.Push%2A> metody do dystrybuowania pięć ciągów na stosie. Wyliczane są elementy stosu nie zmienia stanu stosu. <xref:System.Collections.Generic.Stack%601.Pop%2A> Metoda jest używana do pop pierwszy ciąg ze stosu. <xref:System.Collections.Generic.Stack%601.Peek%2A> Metodę spojrzeć na następny element na stosie, a następnie <xref:System.Collections.Generic.Stack%601.Pop%2A> metoda jest używana do Powiększ go.  
  
 <xref:System.Collections.Generic.Stack%601.ToArray%2A> Metoda jest używana do utworzenia tablicy i skopiuj do niego elementów stosu, a następnie tablicy jest przekazywana do <xref:System.Collections.Generic.Stack%601.%23ctor%2A> konstruktora przyjmującego <xref:System.Collections.Generic.IEnumerable%601>, tworząc kopię stosu w kolejności elementów wycofane. Elementy kopii są wyświetlane.  
  
 Tablica dwukrotnie rozmiar stosu jest tworzony i <xref:System.Collections.Generic.Stack%601.CopyTo%2A> metoda służy do kopiowania elementów tablicy, zaczynając od środka tablicy. <xref:System.Collections.Generic.Stack%601.%23ctor%2A> Konstruktor jest używany ponownie, aby utworzyć kopię stosu w kolejności elementów cofnąć; w związku z tym trzy elementy wartości null znajdują się na końcu.  
  
 <xref:System.Collections.Generic.Stack%601.Contains%2A> Metoda jest używana do pokazują, że ciąg "4" jest pierwsza kopia stosu, po którym <xref:System.Collections.Generic.Stack%601.Clear%2A> metoda usuwa kopię i <xref:System.Collections.Generic.Stack%601.Count%2A> właściwość pokazuje, że stos jest pusty.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.Stack`1.Peek" />
        <altmember cref="M:System.Collections.Generic.Stack`1.Pop" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;!T&gt; System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.System#Collections#Generic#IEnumerable&lt;T&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of T) Implements IEnumerable(Of T).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;T&gt; ^ System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;T&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca moduł wyliczający, który dokonuje iteracji w kolekcji.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerator`1" /> Który może służyć do iterowania po kolekcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `foreach` Instrukcji języka C# (`for each` w języku C++ `For Each` w języku Visual Basic) ukrywa złożoność wyliczenia. W związku z tym przy użyciu `foreach` jest zalecane, zamiast bezpośrednie manipulowanie modułu wyliczającego.  
  
 Moduły wyliczające mogą służyć do odczytu danych w kolekcji, ale nie można za ich pomocą modyfikować kolekcji źródłowej.  
  
 Początkowo moduł wyliczający jest umieszczony przed pierwszym elementem w kolekcji. W tym miejscu <xref:System.Collections.Generic.IEnumerator%601.Current%2A> jest niezdefiniowana. W związku z tym należy wywołać <xref:System.Collections.IEnumerator.MoveNext%2A> można poprawić modułu wyliczającego pierwszy element do kolekcji przed odczytywania wartości <xref:System.Collections.Generic.IEnumerator%601.Current%2A>.  
  
 <xref:System.Collections.Generic.IEnumerator%601.Current%2A> Zwraca tego samego obiektu, dopóki nie <xref:System.Collections.IEnumerator.MoveNext%2A> jest wywoływana. <xref:System.Collections.IEnumerator.MoveNext%2A> Ustawia <xref:System.Collections.Generic.IEnumerator%601.Current%2A> do następnego elementu.  
  
 Jeśli <xref:System.Collections.IEnumerator.MoveNext%2A> przekazuje końcem kolekcji, moduł wyliczający jest umieszczony za ostatnim elementem w kolekcji i <xref:System.Collections.IEnumerator.MoveNext%2A> zwraca `false`. Gdy moduł wyliczający jest w tym miejscu kolejnych wywołań <xref:System.Collections.IEnumerator.MoveNext%2A> zwracają również `false`. Jeśli przez ostatnie wywołanie <xref:System.Collections.IEnumerator.MoveNext%2A> zwrócił `false`, <xref:System.Collections.Generic.IEnumerator%601.Current%2A> jest niezdefiniowana. Nie można ustawić <xref:System.Collections.Generic.IEnumerator%601.Current%2A> do pierwszego elementu w kolekcji; należy utworzyć nowe wystąpienie modułu wyliczającego zamiast tego.  
  
 Moduł wyliczający zachowuje ważność tak długo, jak długo kolekcja pozostaje niezmieniona. Jeśli zmiany zostały wprowadzone do kolekcji, takie jak dodawanie, modyfikowanie lub usuwanie elementów, moduł wyliczający jest bezpowrotnie unieważniona, a następne wywołanie <xref:System.Collections.IEnumerator.MoveNext%2A> lub <xref:System.Collections.IEnumerator.Reset%2A> zgłasza <xref:System.InvalidOperationException>.  
  
 Moduł wyliczający nie ma wyłącznego dostępu do kolekcji, w związku z tym wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość. Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania.  Aby zezwolić wielu wątkom na dostęp do kolekcji w celu odczytu i zapisu danych, należy zaimplementować własny mechanizm synchronizacji.  
  
 Domyślne implementacje kolekcji w <xref:System.Collections.Generic?displayProperty=nameWithType> nie są zsynchronizowane.  
  
 Ta metoda jest operacją O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int arrayIndex) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Jednowymiarowa <see cref="T:System.Array" /> który jest miejscem docelowym elementów kopiowanych z <see cref="T:System.Collections.ICollection" />. <see cref="T:System.Array" /> Musi mieć indeksowania liczony od zera.</param>
        <param name="arrayIndex">Liczony od zera indeks w <c>tablicy</c> od rozpoczyna się kopiowanie które.</param>
        <summary>Kopiuje elementy <see cref="T:System.Collections.ICollection" /> do <see cref="T:System.Array" />, rozpoczynając od określonego <see cref="T:System.Array" /> indeksu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Jeśli typ źródła <xref:System.Collections.ICollection> nie można automatycznie rzutować na typ docelowy `array`, implementacje nieogólnego <xref:System.Collections.ICollection.CopyTo%2A?displayProperty=nameWithType> throw <xref:System.InvalidCastException>, podczas gdy throw ogólnego implementacje <xref:System.ArgumentException>.  
  
 Ta metoda jest O (`n`) operację, której `n` jest <xref:System.Collections.Generic.Stack%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="arrayIndex" /> jest mniejsza od zera.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> jest wielowymiarowy.  - lub - <paramref name="array" /> nie ma indeksowania liczony od zera.  - lub - liczba elementów w źródle <see cref="T:System.Collections.ICollection" /> jest większa niż dostępne miejsce od <paramref name="arrayIndex" /> do końca tablicy docelowej <paramref name="array" />.  - lub - typ źródła <see cref="T:System.Collections.ICollection" /> nie można automatycznie rzutować na typ docelowy <paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Stack`1.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.ICollection.IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.Stack&lt;'T&gt;.System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy uzyskują dostęp do <see cref="T:System.Collections.ICollection" /> jest synchronizowane (wielowątkowość).</summary>
        <value>
          <see langword="true" /> Jeśli dostęp do <see cref="T:System.Collections.ICollection" /> jest synchronizowane (wielowątkowość); w przeciwnym razie <see langword="false" />.  W implementacji domyślnej <see cref="T:System.Collections.Generic.Stack`1" />, ta właściwość zawsze zwraca <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślne implementacje kolekcji w <xref:System.Collections.Generic?displayProperty=nameWithType> nie są zsynchronizowane.  
  
 Wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość.  W rzadkich przypadkach, gdy wyliczenia będą konkurować o dostępów do zapisu należy zablokować kolekcję podczas całej wyliczenia.  Aby zezwolić wielu wątkom na dostęp do kolekcji w celu odczytu i zapisu danych, należy zaimplementować własny mechanizm synchronizacji.  
  
 <xref:System.Collections.ICollection.SyncRoot%2A> Zwraca obiekt, który może służyć do synchronizujący dostęp do <xref:System.Collections.ICollection>. Synchronizacja jest efektywne tylko wtedy, gdy wszystkie wątki zablokować ten obiekt przed uzyskaniem dostępu do kolekcji.  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Stack`1.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.ICollection.SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.Stack&lt;'T&gt;.System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera obiekt, który może służyć do synchronizujący dostęp do <see cref="T:System.Collections.ICollection" />.</summary>
        <value>Obiekt, który może służyć do synchronizujący dostęp do <see cref="T:System.Collections.ICollection" />.  W implementacji domyślnej <see cref="T:System.Collections.Generic.Stack`1" />, ta właściwość zawsze zwraca bieżącego wystąpienia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślne implementacje kolekcji w <xref:System.Collections.Generic?displayProperty=nameWithType> nie są zsynchronizowane.  
  
 Wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość.  Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania.  Aby zezwolić wielu wątkom na dostęp do kolekcji w celu odczytu i zapisu danych, należy zaimplementować własny mechanizm synchronizacji.  
  
 <xref:System.Collections.ICollection.SyncRoot%2A> Zwraca obiekt, który może służyć do synchronizujący dostęp do <xref:System.Collections.ICollection>. Synchronizacja jest efektywne tylko wtedy, gdy wszystkie wątki zablokować ten obiekt przed uzyskaniem dostępu do kolekcji. Poniższy kod przedstawia użycie <xref:System.Collections.ICollection.SyncRoot%2A> właściwości dla C#, C++ i Visual Basic.  
  
```csharp  
ICollection ic = ...;  
lock (ic.SyncRoot) {  
   // Access the collection.  
}  
```  
  
```vb  
Dim ic As ICollection = ...  
SyncLock ic.SyncRoot  
   ' Access the collection.  
End SyncLock  
```  
  
```cpp#  
ICollection^ ic = ...;  
try {  
   Monitor::Enter(ic->SyncRoot);  
   // Access the collection.  
}  
finally {  
   Monitor::Exit(ic->SyncRoot);  
}  
```  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca moduł wyliczający, który dokonuje iteracji w kolekcji.</summary>
        <returns>
          <see cref="T:System.Collections.IEnumerator" /> Który może służyć do iterowania po kolekcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `foreach` Instrukcji języka C# (`for each` w języku C++ `For Each` w języku Visual Basic) ukrywa złożoność wyliczenia. W związku z tym przy użyciu `foreach` jest zalecane, zamiast bezpośrednie manipulowanie modułu wyliczającego.  
  
 Moduły wyliczające mogą służyć do odczytu danych w kolekcji, ale nie można za ich pomocą modyfikować kolekcji źródłowej.  
  
 Początkowo moduł wyliczający jest umieszczony przed pierwszym elementem w kolekcji. <xref:System.Collections.IEnumerator.Reset%2A> również wprowadzono moduł wyliczający wróć do tej pozycji.  W tym miejscu <xref:System.Collections.IEnumerator.Current%2A> jest niezdefiniowana. W związku z tym należy wywołać <xref:System.Collections.IEnumerator.MoveNext%2A> można poprawić modułu wyliczającego pierwszy element do kolekcji przed odczytywania wartości <xref:System.Collections.IEnumerator.Current%2A>.  
  
 <xref:System.Collections.IEnumerator.Current%2A> zwraca ten sam obiekt do momentu <xref:System.Collections.IEnumerator.MoveNext%2A> lub <xref:System.Collections.IEnumerator.Reset%2A> jest wywoływana. <xref:System.Collections.IEnumerator.MoveNext%2A> Ustawia <xref:System.Collections.IEnumerator.Current%2A> do następnego elementu.  
  
 Jeśli <xref:System.Collections.IEnumerator.MoveNext%2A> przekazuje końcem kolekcji, moduł wyliczający jest umieszczony za ostatnim elementem w kolekcji i <xref:System.Collections.IEnumerator.MoveNext%2A> zwraca `false`. Gdy moduł wyliczający jest w tym miejscu kolejnych wywołań <xref:System.Collections.IEnumerator.MoveNext%2A> zwracają również `false`. Jeśli przez ostatnie wywołanie <xref:System.Collections.IEnumerator.MoveNext%2A> zwrócił `false`, <xref:System.Collections.IEnumerator.Current%2A> jest niezdefiniowana. Aby ustawić <xref:System.Collections.IEnumerator.Current%2A> aby pierwszym elementem kolekcji ponownie, należy wywołać <xref:System.Collections.IEnumerator.Reset%2A> następuje <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Moduł wyliczający zachowuje ważność tak długo, jak długo kolekcja pozostaje niezmieniona. Jeśli zmiany zostały wprowadzone do kolekcji, takie jak dodawanie, modyfikowanie lub usuwanie elementów, moduł wyliczający jest bezpowrotnie unieważniona, a następne wywołanie <xref:System.Collections.IEnumerator.MoveNext%2A> lub <xref:System.Collections.IEnumerator.Reset%2A> zgłasza <xref:System.InvalidOperationException>.  
  
 Moduł wyliczający nie ma wyłącznego dostępu do kolekcji, w związku z tym wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość.  Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania.  Aby zezwolić wielu wątkom na dostęp do kolekcji w celu odczytu i zapisu danych, należy zaimplementować własny mechanizm synchronizacji.  
  
 Domyślne implementacje kolekcji w <xref:System.Collections.Generic?displayProperty=nameWithType> nie są zsynchronizowane.  
  
 Ta metoda jest operacją O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.Stack`1.GetEnumerator" />
        <altmember cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" />
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public T[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T[] ToArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.ToArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToArray () As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;T&gt; ^ ToArray();" />
      <MemberSignature Language="F#" Value="member this.ToArray : unit -&gt; 'T[]" Usage="stack.ToArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Kopie <see cref="T:System.Collections.Generic.Stack`1" /> do nowej tablicy.</summary>
        <returns>Nowe tablica zawierająca kopie elementów <see cref="T:System.Collections.Generic.Stack`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Elementy są kopiowane na tablicy w kolejności (LIFO) ostatnich w pierwszym poza, podobne polecenie elementów zwróconych przez kolejne wywołania <xref:System.Collections.Generic.Stack%601.Pop%2A>.  
  
 Ta metoda jest O (`n`) operację, której `n` jest <xref:System.Collections.Generic.Stack%601.Count%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie kodu pokazano kilka metod <xref:System.Collections.Generic.Stack%601> klasy ogólnej, łącznie z <xref:System.Collections.Generic.Stack%601.ToArray%2A> metody.  
  
 Przykład kodu tworzy stosu ciągów o pojemności domyślnej i używa <xref:System.Collections.Generic.Stack%601.Push%2A> metody do dystrybuowania pięć ciągów na stosie. Wyliczane są elementy stosu nie zmienia stanu stosu. <xref:System.Collections.Generic.Stack%601.Pop%2A> Metoda jest używana do pop pierwszy ciąg ze stosu. <xref:System.Collections.Generic.Stack%601.Peek%2A> Metodę spojrzeć na następny element na stosie, a następnie <xref:System.Collections.Generic.Stack%601.Pop%2A> metoda jest używana do Powiększ go.  
  
 <xref:System.Collections.Generic.Stack%601.ToArray%2A> Metoda jest używana do utworzenia tablicy i skopiuj do niego elementów stosu, a następnie tablicy jest przekazywana do <xref:System.Collections.Generic.Stack%601.%23ctor%2A> konstruktora przyjmującego <xref:System.Collections.Generic.IEnumerable%601>, tworząc kopię stosu w kolejności elementów wycofane. Elementy kopii są wyświetlane.  
  
 Tablica dwukrotnie rozmiar stosu jest tworzony i <xref:System.Collections.Generic.Stack%601.CopyTo%2A> metoda służy do kopiowania elementów tablicy, zaczynając od środka tablicy. <xref:System.Collections.Generic.Stack%601.%23ctor%2A> Konstruktor jest używany ponownie, aby utworzyć kopię stosu w kolejności elementów cofnąć; w związku z tym trzy elementy wartości null znajdują się na końcu.  
  
 <xref:System.Collections.Generic.Stack%601.Contains%2A> Metoda jest używana do pokazują, że ciąg "4" jest pierwsza kopia stosu, po którym <xref:System.Collections.Generic.Stack%601.Clear%2A> metoda usuwa kopię i <xref:System.Collections.Generic.Stack%601.Count%2A> właściwość pokazuje, że stos jest pusty.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.Stack`1.CopyTo(`0[],System.Int32)" />
        <altmember cref="M:System.Collections.Generic.Stack`1.Pop" />
      </Docs>
    </Member>
    <Member MemberName="TrimExcess">
      <MemberSignature Language="C#" Value="public void TrimExcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TrimExcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.TrimExcess" />
      <MemberSignature Language="VB.NET" Value="Public Sub TrimExcess ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TrimExcess();" />
      <MemberSignature Language="F#" Value="member this.TrimExcess : unit -&gt; unit" Usage="stack.TrimExcess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ustawia pojemność na rzeczywistą liczbę elementów w <see cref="T:System.Collections.Generic.Stack`1" />, jeśli ten numer jest mniejsza niż 90 procent obecna pojemność.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może służyć do narzut zminimalizować pamięci kolekcji, jeśli żadne nowe elementy, które zostaną dodane do kolekcji. Koszt ponowne przydzielanie i kopiowanie dużej <xref:System.Collections.Generic.Stack%601> mogą być jednak znaczące, więc <xref:System.Collections.Generic.Stack%601.TrimExcess%2A> — metoda nie robi nic, jeśli lista jest więcej niż 90 procent pojemności. Dzięki temu można uniknąć ponoszenia koszt dużych; Ponowna alokacja dla niewielkich korzyści.  
  
 Ta metoda jest O (`n`) operację, której `n` jest <xref:System.Collections.Generic.Stack%601.Count%2A>.  
  
 Aby zresetować <xref:System.Collections.Generic.Stack%601> do stanu początkowego wywołać <xref:System.Collections.Generic.Stack%601.Clear%2A> metoda przed wywołaniem <xref:System.Collections.Generic.Stack%601.TrimExcess%2A> — metoda. Przycinanie pustą <xref:System.Collections.Generic.Stack%601> ustawia pojemność <xref:System.Collections.Generic.Stack%601> do wydajności domyślnej.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.Stack`1.Clear" />
        <altmember cref="P:System.Collections.Generic.Stack`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="TryPeek">
      <MemberSignature Language="C#" Value="public bool TryPeek (out T result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryPeek([out] !T&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.TryPeek(`0@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryPeek (ByRef result As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryPeek([Runtime::InteropServices::Out] T % result);" />
      <MemberSignature Language="F#" Value="member this.TryPeek :  -&gt; bool" Usage="stack.TryPeek result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="T&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryPop">
      <MemberSignature Language="C#" Value="public bool TryPop (out T result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryPop([out] !T&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.TryPop(`0@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryPop (ByRef result As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryPop([Runtime::InteropServices::Out] T % result);" />
      <MemberSignature Language="F#" Value="member this.TryPop :  -&gt; bool" Usage="stack.TryPop result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="T&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="Stack&lt;T&gt;" FullName="System.Collections.Generic.Stack&lt;T&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="782be4bc5b7ad83d0d7a701926b612f9c654f04f" />
    <Meta Name="ms.sourcegitcommit" Value="723b8a6d92667ba86fcda96190bad3b4a03283b3" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="11/09/2018" />
    <Meta Name="ms.locfileid" Value="51307483" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Stack&lt;T&gt; : System.Collections.Generic.IEnumerable&lt;T&gt;, System.Collections.Generic.IReadOnlyCollection&lt;T&gt;, System.Collections.ICollection" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Stack`1&lt;T&gt; extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;!T&gt;, class System.Collections.ICollection, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Generic.Stack`1" />
  <TypeSignature Language="VB.NET" Value="Public Class Stack(Of T)&#xA;Implements ICollection, IEnumerable(Of T), IReadOnlyCollection(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class Stack : System::Collections::Generic::IEnumerable&lt;T&gt;, System::Collections::Generic::IReadOnlyCollection&lt;T&gt;, System::Collections::ICollection" />
  <TypeSignature Language="F#" Value="type Stack&lt;'T&gt; = class&#xA;    interface seq&lt;'T&gt;&#xA;    interface ICollection&#xA;    interface IReadOnlyCollection&lt;'T&gt;&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Collections</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.System_StackDebugView`1))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">Określa typ elementów w stosie.</typeparam>
    <summary>Reprezentuje kolekcję zmiennym rozmiarze ostatni wejściu — pierwszy na wyjściu (LIFO) wystąpień tego samego określonego typu.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.Stack%601> jest implementowana jako tablica.  
  
 Stosów i kolejek są przydatne, gdy będziesz potrzebować informacji; magazynu tymczasowego oznacza to, kiedy warto odrzucić element po jego wartość. Użyj <xref:System.Collections.Generic.Queue%601> muszą uzyskać dostęp do informacji w tej samej kolejności, że jest on przechowywany w kolekcji. Użyj <xref:System.Collections.Generic.Stack%601?displayProperty=nameWithType> Jeśli potrzebujesz dostępu do informacji w odwrotnej kolejności.  
  
 Użyj <xref:System.Collections.Concurrent.ConcurrentStack%601?displayProperty=nameWithType> i <xref:System.Collections.Concurrent.ConcurrentQueue%601?displayProperty=nameWithType> typów, gdy trzeba uzyskać dostęp do kolekcji z wielu wątków jednocześnie.  
  
 Typowym zastosowaniem dla <xref:System.Collections.Generic.Stack%601?displayProperty=nameWithType> ma zachować stany zmiennej podczas wywołania do innych procedur.  
  
 Trzy główne operacje mogą być wykonywane na <xref:System.Collections.Generic.Stack%601?displayProperty=nameWithType> i jego elementy:  
  
-   <xref:System.Collections.Generic.Stack%601.Push%2A> Wstawia element w górnej części <xref:System.Collections.Stack>.  
  
-   <xref:System.Collections.Generic.Stack%601.Pop%2A> Usuwa element z góry <xref:System.Collections.Generic.Stack%601>.  
  
-   <xref:System.Collections.Generic.Stack%601.Peek%2A> Zwraca element, który znajduje się w górnej części <xref:System.Collections.Generic.Stack%601> , ale nie spowoduje usunięcia go z <xref:System.Collections.Generic.Stack%601>.  
  
 Pojemność <xref:System.Collections.Generic.Stack%601> jest liczba elementów, które <xref:System.Collections.Generic.Stack%601> może przechowywać. Gdy elementy są dodawane do <xref:System.Collections.Generic.Stack%601>, pojemność jest automatycznie zwiększana zgodnie z wymaganiami relokacja wewnętrznego tablicy. Można zmniejszyć pojemność przez wywołanie metody <xref:System.Collections.Generic.Stack%601.TrimExcess%2A>.  
  
 Jeśli <xref:System.Collections.Generic.Stack%601.Count%2A> jest mniejsza niż pojemność stosu, <xref:System.Collections.Generic.Stack%601.Push%2A> jest operacją O(1). Jeśli pojemność musi zostać zwiększona, aby pomieścić nowy element <xref:System.Collections.Generic.Stack%601.Push%2A> staje się O (`n`) operacji, gdzie `n` jest <xref:System.Collections.Generic.Stack%601.Count%2A>. <xref:System.Collections.Generic.Stack%601.Pop%2A> jest operacją O(1).  
  
 <xref:System.Collections.Generic.Stack%601> akceptuje `null` prawidłową wartość dla odwołania do typów i pozwala zduplikowane elementy.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje kilka metod <xref:System.Collections.Generic.Stack%601> klasy ogólnej. Przykład kodu tworzy stosu ciągów przy użyciu domyślnej pojemności i używa <xref:System.Collections.Generic.Stack%601.Push%2A> metodę, aby wypchnąć pięć ciągi na stosie. Elementy stosu są wyliczane nie zmienia stanu stosu. <xref:System.Collections.Generic.Stack%601.Pop%2A> Metoda jest używana do pop pierwszy ciąg ze stosu. <xref:System.Collections.Generic.Stack%601.Peek%2A> Metoda jest używana do wzięcia pod następnego elementu w stosie, a następnie <xref:System.Collections.Generic.Stack%601.Pop%2A> metoda jest używana do pop go.  
  
 <xref:System.Collections.Generic.Stack%601.ToArray%2A> Metoda jest używana do utworzenia tablicy, a następnie skopiuj elementy stosu do niego, a następnie tablicy jest przekazywany do <xref:System.Collections.Generic.Stack%601.%23ctor%2A> konstruktora przyjmującego <xref:System.Collections.Generic.IEnumerable%601>, tworząc kopię stosu w kolejności elementów odwrócony. Elementy kopii są wyświetlane.  
  
 Dwa razy rozmiar stosu jest tworzona macierz, a <xref:System.Collections.Generic.Stack%601.CopyTo%2A> metoda jest używana do skopiowania elementów tablicy, zaczynając od środka tablicy. <xref:System.Collections.Generic.Stack%601.%23ctor%2A> Konstruktora jest używany ponownie utworzyć kopię stosu w kolejności elementów odwrócony; w związku z tym, trzy elementy o wartości null znajdują się na końcu.  
  
 <xref:System.Collections.Generic.Stack%601.Contains%2A> Metoda jest używana do pokazują, że ciąg "4" jest pierwsza kopia stosu, po którym <xref:System.Collections.Generic.Stack%601.Clear%2A> metoda czyści kopii i <xref:System.Collections.Generic.Stack%601.Count%2A> właściwość pokazuje, że stos jest pusty.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Publiczne statyczne (<see langword="Shared" /> w języku Visual Basic) elementy członkowskie tego typu są bezpieczne dla wątków. Wystąpienia elementów członkowskich nie dają gwarancji bezpieczeństwa wątków.  
  
Element <see cref="T:System.Collections.Generic.Stack`1" /> może obsługiwać wielu elementów odczytujących współbieżnie, tak długo, jak długo Kolekcja nie jest modyfikowany.  Nawet w takim przypadku wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną.  Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania.  Aby zezwolić wielu wątkom na dostęp do kolekcji w celu odczytu i zapisu danych, należy zaimplementować własny mechanizm synchronizacji.</threadsafe>
    <related type="Article" href="http://msdn.microsoft.com/library/f45331db-d595-46ec-9142-551d3d1eb1a7">Iteratory (C# i Visual Basic)</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Collections.Generic.Stack`1" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Stack ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Stack();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Collections.Generic.Stack`1" /> klasę, która jest pusta i ma pojemność domyślna.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pojemność <xref:System.Collections.Generic.Stack%601> jest liczba elementów, <xref:System.Collections.Generic.Stack%601> może przechowywać. Gdy elementy są dodawane do <xref:System.Collections.Generic.Stack%601>, pojemność jest automatycznie zwiększana zgodnie z wymaganiami relokacja wewnętrznego tablicy.  
  
 Jeśli rozmiar kolekcji można oszacować, określający początkowej pojemności eliminuje konieczność wykonania wielu operacji zmiany rozmiaru podczas dodawania elementów do <xref:System.Collections.Generic.Stack%601>.  
  
 Można zmniejszyć pojemność przez wywołanie metody <xref:System.Collections.Generic.Stack%601.TrimExcess%2A>.  
  
 Ten konstruktor jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje ten konstruktor i kilka metod <xref:System.Collections.Generic.Stack%601> klasy ogólnej.  
  
 Przykład kodu tworzy stosu ciągów przy użyciu domyślnej pojemności i używa <xref:System.Collections.Generic.Stack%601.Push%2A> metodę, aby wypchnąć pięć ciągi na stosie. Elementy stosu są wyliczane nie zmienia stanu stosu. <xref:System.Collections.Generic.Stack%601.Pop%2A> Metoda jest używana do pop pierwszy ciąg ze stosu. <xref:System.Collections.Generic.Stack%601.Peek%2A> Metoda jest używana do wzięcia pod następnego elementu w stosie, a następnie <xref:System.Collections.Generic.Stack%601.Pop%2A> metoda jest używana do pop go.  
  
 <xref:System.Collections.Generic.Stack%601.ToArray%2A> Metoda jest używana do utworzenia tablicy, a następnie skopiuj elementy stosu do niego, a następnie tablicy jest przekazywany do <xref:System.Collections.Generic.Stack%601.%23ctor%2A> konstruktora przyjmującego <xref:System.Collections.Generic.IEnumerable%601>, tworząc kopię stosu w kolejności elementów odwrócony. Elementy kopii są wyświetlane.  
  
 Dwa razy rozmiar stosu jest tworzona macierz, a <xref:System.Collections.Generic.Stack%601.CopyTo%2A> metoda jest używana do skopiowania elementów tablicy, zaczynając od środka tablicy. <xref:System.Collections.Generic.Stack%601.%23ctor%2A> Konstruktora jest używany ponownie utworzyć kopię stosu w kolejności elementów odwrócony; w związku z tym, trzy elementy o wartości null znajdują się na końcu.  
  
 <xref:System.Collections.Generic.Stack%601.Contains%2A> Metoda jest używana do pokazują, że ciąg "4" jest pierwsza kopia stosu, po którym <xref:System.Collections.Generic.Stack%601.Clear%2A> metoda czyści kopii i <xref:System.Collections.Generic.Stack%601.Count%2A> właściwość pokazuje, że stos jest pusty.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Stack (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.#ctor(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Stack(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.Stack&lt;'T&gt; : seq&lt;'T&gt; -&gt; System.Collections.Generic.Stack&lt;'T&gt;" Usage="new System.Collections.Generic.Stack&lt;'T&gt; collection" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">Kolekcja, aby skopiować elementy z.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Collections.Generic.Stack`1" /> skopiowane klasę, która zawiera elementy kopiowane z określonej kolekcji i ma wystarczającej wydajności, aby obsłużyć liczbę elementów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pojemność <xref:System.Collections.Generic.Stack%601> jest liczba elementów, <xref:System.Collections.Generic.Stack%601> może przechowywać. Gdy elementy są dodawane do <xref:System.Collections.Generic.Stack%601>, pojemność jest automatycznie zwiększana zgodnie z wymaganiami relokacja wewnętrznego tablicy.  
  
 Jeśli rozmiar kolekcji można oszacować, określający początkowej pojemności eliminuje konieczność wykonania wielu operacji zmiany rozmiaru podczas dodawania elementów do <xref:System.Collections.Generic.Stack%601>.  
  
 Można zmniejszyć pojemność przez wywołanie metody <xref:System.Collections.Generic.Stack%601.TrimExcess%2A>.  
  
 Elementy są kopiowane na <xref:System.Collections.Generic.Stack%601> w tej samej kolejności, które są odczytywane przez <xref:System.Collections.Generic.IEnumerator%601> kolekcji.  
  
 Ten konstruktor jest O (`n`) operacji, gdzie `n` jest liczba elementów w `collection`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje ten konstruktor i kilka metod <xref:System.Collections.Generic.Stack%601> klasy ogólnej.  
  
 Przykład kodu tworzy stosu ciągów przy użyciu domyślnej pojemności i używa <xref:System.Collections.Generic.Stack%601.Push%2A> metodę, aby wypchnąć pięć ciągi na stosie. Elementy stosu są wyliczane nie zmienia stanu stosu. <xref:System.Collections.Generic.Stack%601.Pop%2A> Metoda jest używana do pop pierwszy ciąg ze stosu. <xref:System.Collections.Generic.Stack%601.Peek%2A> Metoda jest używana do wzięcia pod następnego elementu w stosie, a następnie <xref:System.Collections.Generic.Stack%601.Pop%2A> metoda jest używana do pop go.  
  
 <xref:System.Collections.Generic.Stack%601.ToArray%2A> Metoda jest używana do utworzenia tablicy, a następnie skopiuj elementy stosu do niego, a następnie tablicy jest przekazywany do <xref:System.Collections.Generic.Stack%601.%23ctor%2A> konstruktora przyjmującego <xref:System.Collections.Generic.IEnumerable%601>, tworząc kopię stosu w kolejności elementów odwrócony. Elementy kopii są wyświetlane.  
  
 Dwa razy rozmiar stosu jest tworzona macierz, a <xref:System.Collections.Generic.Stack%601.CopyTo%2A> metoda jest używana do skopiowania elementów tablicy, zaczynając od środka tablicy. <xref:System.Collections.Generic.Stack%601.%23ctor%2A> Konstruktora jest używany ponownie utworzyć kopię stosu w kolejności elementów odwrócony; w związku z tym, trzy elementy o wartości null znajdują się na końcu.  
  
 <xref:System.Collections.Generic.Stack%601.Contains%2A> Metoda jest używana do pokazują, że ciąg "4" jest pierwsza kopia stosu, po którym <xref:System.Collections.Generic.Stack%601.Clear%2A> metoda czyści kopii i <xref:System.Collections.Generic.Stack%601.Count%2A> właściwość pokazuje, że stos jest pusty.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collection" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Collections.Generic.ICollection`1" />
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Stack (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Stack(int capacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.Stack&lt;'T&gt; : int -&gt; System.Collections.Generic.Stack&lt;'T&gt;" Usage="new System.Collections.Generic.Stack&lt;'T&gt; capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Początkowa liczba elementów, <see cref="T:System.Collections.Generic.Stack`1" /> może zawierać.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Collections.Generic.Stack`1" /> klasę, która jest pusta i ma określony pojemność lub pojemność początkową domyślną, która kwota jest większa.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pojemność <xref:System.Collections.Generic.Stack%601> jest liczba elementów, <xref:System.Collections.Generic.Stack%601> może przechowywać. Gdy elementy są dodawane do <xref:System.Collections.Generic.Stack%601>, pojemność jest automatycznie zwiększana zgodnie z wymaganiami relokacja wewnętrznego tablicy.  
  
 Jeśli rozmiar kolekcji można oszacować, określający początkowej pojemności eliminuje konieczność wykonania wielu operacji zmiany rozmiaru podczas dodawania elementów do <xref:System.Collections.Generic.Stack%601>.  
  
 Można zmniejszyć pojemność przez wywołanie metody <xref:System.Collections.Generic.Stack%601.TrimExcess%2A>.  
  
 Ten konstruktor jest O (`n`) operacji, gdzie `n` jest `capacity`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> jest mniejsza niż zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="stack.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa wszystkie obiekty z <see cref="T:System.Collections.Generic.Stack`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.Stack%601.Count%2A> jest równa zero i odwołania do innych obiektów z elementów kolekcji są również zwalniane.  
  
 Pojemność pozostaje bez zmian. Aby zresetować pojemność <xref:System.Collections.Generic.Stack%601>, wywołaj <xref:System.Collections.Generic.Stack%601.TrimExcess%2A>. Przycinanie pustą <xref:System.Collections.Generic.Stack%601> ustawia pojemność <xref:System.Collections.Generic.Stack%601> do pojemności domyślnej.  
  
 Ta metoda jest O (`n`) operacji, gdzie `n` jest <xref:System.Collections.Generic.Stack%601.Count%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje kilka metod <xref:System.Collections.Generic.Stack%601> klasy ogólnej, w tym <xref:System.Collections.Generic.Stack%601.Clear%2A> metody.  
  
 Przykład kodu tworzy stosu ciągów przy użyciu domyślnej pojemności i używa <xref:System.Collections.Generic.Stack%601.Push%2A> metodę, aby wypchnąć pięć ciągi na stosie. Elementy stosu są wyliczane nie zmienia stanu stosu. <xref:System.Collections.Generic.Stack%601.Pop%2A> Metoda jest używana do pop pierwszy ciąg ze stosu. <xref:System.Collections.Generic.Stack%601.Peek%2A> Metoda jest używana do wzięcia pod następnego elementu w stosie, a następnie <xref:System.Collections.Generic.Stack%601.Pop%2A> metoda jest używana do pop go.  
  
 <xref:System.Collections.Generic.Stack%601.ToArray%2A> Metoda jest używana do utworzenia tablicy, a następnie skopiuj elementy stosu do niego, a następnie tablicy jest przekazywany do <xref:System.Collections.Generic.Stack%601.%23ctor%2A> konstruktora przyjmującego <xref:System.Collections.Generic.IEnumerable%601>, tworząc kopię stosu w kolejności elementów odwrócony. Elementy kopii są wyświetlane.  
  
 Dwa razy rozmiar stosu jest tworzona macierz, a <xref:System.Collections.Generic.Stack%601.CopyTo%2A> metoda jest używana do skopiowania elementów tablicy, zaczynając od środka tablicy. <xref:System.Collections.Generic.Stack%601.%23ctor%2A> Konstruktora jest używany ponownie utworzyć kopię stosu w kolejności elementów odwrócony; w związku z tym, trzy elementy o wartości null znajdują się na końcu.  
  
 <xref:System.Collections.Generic.Stack%601.Contains%2A> Metoda jest używana do pokazują, że ciąg "4" jest pierwsza kopia stosu, po którym <xref:System.Collections.Generic.Stack%601.Clear%2A> metoda czyści kopii i <xref:System.Collections.Generic.Stack%601.Count%2A> właściwość pokazuje, że stos jest pusty.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.Contains(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(T item);" />
      <MemberSignature Language="F#" Value="member this.Contains : 'T -&gt; bool" Usage="stack.Contains item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Obiekt do zlokalizowania w <see cref="T:System.Collections.Generic.Stack`1" />. Wartość może być <see langword="null" /> dla typów odwołań.</param>
        <summary>Określa, czy element jest <see cref="T:System.Collections.Generic.Stack`1" />.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="item" /> znajduje się w <see cref="T:System.Collections.Generic.Stack`1" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda określa równość za pomocą domyślny moduł porównujący równość <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> dla `T`, typ wartości na liście.  
  
 Ta metoda przeprowadza wyszukiwanie liniowe; w związku z tym, ta metoda jest O (`n`) operacji, gdzie `n` jest <xref:System.Collections.Generic.Stack%601.Count%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje kilka metod <xref:System.Collections.Generic.Stack%601> klasy ogólnej, w tym <xref:System.Collections.Generic.Stack%601.Contains%2A> metody.  
  
 Przykład kodu tworzy stosu ciągów przy użyciu domyślnej pojemności i używa <xref:System.Collections.Generic.Stack%601.Push%2A> metodę, aby wypchnąć pięć ciągi na stosie. Elementy stosu są wyliczane nie zmienia stanu stosu. <xref:System.Collections.Generic.Stack%601.Pop%2A> Metoda jest używana do pop pierwszy ciąg ze stosu. <xref:System.Collections.Generic.Stack%601.Peek%2A> Metoda jest używana do wzięcia pod następnego elementu w stosie, a następnie <xref:System.Collections.Generic.Stack%601.Pop%2A> metoda jest używana do pop go.  
  
 <xref:System.Collections.Generic.Stack%601.ToArray%2A> Metoda jest używana do utworzenia tablicy, a następnie skopiuj elementy stosu do niego, a następnie tablicy jest przekazywany do <xref:System.Collections.Generic.Stack%601.%23ctor%2A> konstruktora przyjmującego <xref:System.Collections.Generic.IEnumerable%601>, tworząc kopię stosu w kolejności elementów odwrócony. Elementy kopii są wyświetlane.  
  
 Dwa razy rozmiar stosu jest tworzona macierz, a <xref:System.Collections.Generic.Stack%601.CopyTo%2A> metoda jest używana do skopiowania elementów tablicy, zaczynając od środka tablicy. <xref:System.Collections.Generic.Stack%601.%23ctor%2A> Konstruktora jest używany ponownie utworzyć kopię stosu w kolejności elementów odwrócony; w związku z tym, trzy elementy o wartości null znajdują się na końcu.  
  
 <xref:System.Collections.Generic.Stack%601.Contains%2A> Metoda jest używana do pokazują, że ciąg "4" jest pierwsza kopia stosu, po którym <xref:System.Collections.Generic.Stack%601.Clear%2A> metoda czyści kopii i <xref:System.Collections.Generic.Stack%601.Count%2A> właściwość pokazuje, że stos jest pusty.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Wykonywanie niezależnych od kultury operacji na ciągach w kolekcjach</related>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(!T[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.CopyTo(`0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T(), arrayIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;T&gt; ^ array, int arrayIndex);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : 'T[] * int -&gt; unit" Usage="stack.CopyTo (array, arrayIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Jednowymiarowy <see cref="T:System.Array" /> czyli miejscem docelowym elementów kopiowanych z <see cref="T:System.Collections.Generic.Stack`1" />. <see cref="T:System.Array" /> Musi mieć Indeksowanie oparte na zerze.</param>
        <param name="arrayIndex">Liczony od zera indeks w <c>tablicy</c> od rozpoczyna się kopiowanie które.</param>
        <summary>Kopiuje <see cref="T:System.Collections.Generic.Stack`1" /> do istniejącej jednowymiarowej <see cref="T:System.Array" />, rozpoczynając od określonego indeksu tablicy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Elementy są kopiowane na tablicy ostatni wejściu — pierwszy na wyjściu (LIFO) kolejno zbliżona do kolejności elementów zwróconych przez kolejne wywołania <xref:System.Collections.Generic.Stack%601.Pop%2A>.  
  
 Ta metoda jest O (`n`) operacji, gdzie `n` jest <xref:System.Collections.Generic.Stack%601.Count%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje kilka metod <xref:System.Collections.Generic.Stack%601> klasy ogólnej, w tym <xref:System.Collections.Generic.Stack%601.CopyTo%2A> metody.  
  
 Przykład kodu tworzy stosu ciągów przy użyciu domyślnej pojemności i używa <xref:System.Collections.Generic.Stack%601.Push%2A> metodę, aby wypchnąć pięć ciągi na stosie. Elementy stosu są wyliczane nie zmienia stanu stosu. <xref:System.Collections.Generic.Stack%601.Pop%2A> Metoda jest używana do pop pierwszy ciąg ze stosu. <xref:System.Collections.Generic.Stack%601.Peek%2A> Metoda jest używana do wzięcia pod następnego elementu w stosie, a następnie <xref:System.Collections.Generic.Stack%601.Pop%2A> metoda jest używana do pop go.  
  
 <xref:System.Collections.Generic.Stack%601.ToArray%2A> Metoda jest używana do utworzenia tablicy, a następnie skopiuj elementy stosu do niego, a następnie tablicy jest przekazywany do <xref:System.Collections.Generic.Stack%601.%23ctor%2A> konstruktora przyjmującego <xref:System.Collections.Generic.IEnumerable%601>, tworząc kopię stosu w kolejności elementów odwrócony. Elementy kopii są wyświetlane.  
  
 Dwa razy rozmiar stosu jest tworzona macierz, a <xref:System.Collections.Generic.Stack%601.CopyTo%2A> metoda jest używana do skopiowania elementów tablicy, zaczynając od środka tablicy. <xref:System.Collections.Generic.Stack%601.%23ctor%2A> Konstruktora jest używany ponownie utworzyć kopię stosu w kolejności elementów odwrócony; w związku z tym, trzy elementy o wartości null znajdują się na końcu.  
  
 <xref:System.Collections.Generic.Stack%601.Contains%2A> Metoda jest używana do pokazują, że ciąg "4" jest pierwsza kopia stosu, po którym <xref:System.Collections.Generic.Stack%601.Clear%2A> metoda czyści kopii i <xref:System.Collections.Generic.Stack%601.Count%2A> właściwość pokazuje, że stos jest pusty.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="arrayIndex" /> jest mniejsza niż zero.</exception>
        <exception cref="T:System.ArgumentException">Liczba elementów w źródle <see cref="T:System.Collections.Generic.Stack`1" /> jest większa niż dostępna ilość miejsca od <paramref name="arrayIndex" /> do końca tablicy docelowej <paramref name="array" />.</exception>
        <altmember cref="M:System.Collections.Generic.Stack`1.ToArray" />
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Stack`1.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.Generic.Stack&lt;'T&gt;.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyCollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę elementów znajdujących się w <see cref="T:System.Collections.Generic.Stack`1" />.</summary>
        <value>Liczba elementów zawartych w słowniku <see cref="T:System.Collections.Generic.Stack`1" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pojemność <xref:System.Collections.Generic.Stack%601> jest liczba elementów, <xref:System.Collections.Generic.Stack%601> mogą być przechowywane. <xref:System.Collections.Generic.Stack%601.Count%2A> jest to liczba elementów, które są rzeczywiście w <xref:System.Collections.Generic.Stack%601>.  
  
 Pojemność jest zawsze większa lub równa <xref:System.Collections.Generic.Stack%601.Count%2A>. Jeśli <xref:System.Collections.Generic.Stack%601.Count%2A> przekracza pojemność podczas dodawania elementów, pojemność jest zwiększana o automatycznie relokacja tablicy wewnętrznej przed skopiowaniem starymi elementami i dodawanie nowych elementów.  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje kilka właściwości i metod <xref:System.Collections.Generic.Stack%601> klasy ogólnej, w tym <xref:System.Collections.Generic.Stack%601.Count%2A> właściwości.  
  
 Przykład kodu tworzy stosu ciągów przy użyciu domyślnej pojemności i używa <xref:System.Collections.Generic.Stack%601.Push%2A> metodę, aby wypchnąć pięć ciągi na stosie. Elementy stosu są wyliczane nie zmienia stanu stosu. <xref:System.Collections.Generic.Stack%601.Pop%2A> Metoda jest używana do pop pierwszy ciąg ze stosu. <xref:System.Collections.Generic.Stack%601.Peek%2A> Metoda jest używana do wzięcia pod następnego elementu w stosie, a następnie <xref:System.Collections.Generic.Stack%601.Pop%2A> metoda jest używana do pop go.  
  
 <xref:System.Collections.Generic.Stack%601.ToArray%2A> Metoda jest używana do utworzenia tablicy, a następnie skopiuj elementy stosu do niego, a następnie tablicy jest przekazywany do <xref:System.Collections.Generic.Stack%601.%23ctor%2A> konstruktora przyjmującego <xref:System.Collections.Generic.IEnumerable%601>, tworząc kopię stosu w kolejności elementów odwrócony. Elementy kopii są wyświetlane.  
  
 Dwa razy rozmiar stosu jest tworzona macierz, a <xref:System.Collections.Generic.Stack%601.CopyTo%2A> metoda jest używana do skopiowania elementów tablicy, zaczynając od środka tablicy. <xref:System.Collections.Generic.Stack%601.%23ctor%2A> Konstruktora jest używany ponownie utworzyć kopię stosu w kolejności elementów odwrócony; w związku z tym, trzy elementy o wartości null znajdują się na końcu.  
  
 <xref:System.Collections.Generic.Stack%601.Contains%2A> Metoda jest używana do pokazują, że ciąg "4" jest pierwsza kopia stosu, po którym <xref:System.Collections.Generic.Stack%601.Clear%2A> metoda czyści kopii i <xref:System.Collections.Generic.Stack%601.Count%2A> właściwość pokazuje, że stos jest pusty.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.Stack&lt;T&gt;.Enumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Collections.Generic.Stack`1/Enumerator&lt;!T&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As Stack(Of T).Enumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::Stack&lt;T&gt;::Enumerator GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; System.Collections.Generic.Stack&lt;'T&gt;.Enumerator" Usage="stack.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Stack&lt;T&gt;+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca moduł wyliczający dla <see cref="T:System.Collections.Generic.Stack`1" />.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.Stack`1.Enumerator" /> Dla <see cref="T:System.Collections.Generic.Stack`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `foreach` Instrukcja języka C# (`for each` w języku C++, `For Each` w języku Visual Basic) powoduje ukrycie złożoności modułów wyliczających. W związku z tym, za pomocą `foreach` jest to zalecane, zamiast bezpośredniego wykonywania operacji modułu wyliczającego.  
  
 Moduły wyliczające mogą służyć do odczytu danych w kolekcji, ale nie można za ich pomocą modyfikować kolekcji źródłowej.  
  
 Początkowo moduł wyliczający jest umieszczony przed pierwszym elementem w kolekcji. W tym miejscu <xref:System.Collections.Generic.Stack%601.Enumerator.Current%2A> jest niezdefiniowana. W związku z tym, należy wywołać <xref:System.Collections.Generic.Stack%601.Enumerator.MoveNext%2A> do wyprzedzeniem modułu wyliczającego do pierwszego elementu kolekcji przed odczytaniem wartości właściwości <xref:System.Collections.Generic.Stack%601.Enumerator.Current%2A>.  
  
 <xref:System.Collections.Generic.Stack%601.Enumerator.Current%2A> zwraca ten sam obiekt, do momentu <xref:System.Collections.Generic.Stack%601.Enumerator.MoveNext%2A> jest wywoływana. <xref:System.Collections.Generic.Stack%601.Enumerator.MoveNext%2A> Ustawia <xref:System.Collections.Generic.Stack%601.Enumerator.Current%2A> do następnego elementu.  
  
 Jeśli <xref:System.Collections.Generic.Stack%601.Enumerator.MoveNext%2A> przebiegów koniec kolekcji, moduł wyliczający jest umieszczany za ostatnim elementem w kolekcji i <xref:System.Collections.Generic.Stack%601.Enumerator.MoveNext%2A> zwraca `false`. Gdy moduł wyliczający jest w tym miejscu, kolejne wywołania <xref:System.Collections.Generic.Stack%601.Enumerator.MoveNext%2A> również zwracać `false`. Jeśli ostatnie wywołanie <xref:System.Collections.Generic.Stack%601.Enumerator.MoveNext%2A> zwrócił `false`, <xref:System.Collections.Generic.Stack%601.Enumerator.Current%2A> jest niezdefiniowana. Nie można ustawić <xref:System.Collections.Generic.Stack%601.Enumerator.Current%2A> do pierwszego elementu w kolekcji; należy utworzyć nowe wystąpienie modułu wyliczającego zamiast tego.  
  
 Moduł wyliczający zachowuje ważność tak długo, jak długo kolekcja pozostaje niezmieniona. Jeśli zmiany zostały wprowadzone do kolekcji, takie jak dodawanie, modyfikowanie lub usuwanie elementów, moduł wyliczający jest nieodwracalnie unieważnione, a następne wywołanie <xref:System.Collections.Generic.Stack%601.Enumerator.MoveNext%2A> lub <xref:System.Collections.Generic.Stack%601.Enumerator.System%23Collections%23IEnumerator%23Reset%2A> zgłasza <xref:System.InvalidOperationException>.  
  
 Moduł wyliczający nie ma wyłącznego dostępu do kolekcji, w związku z tym wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość. Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania.  Aby zezwolić wielu wątkom na dostęp do kolekcji w celu odczytu i zapisu danych, należy zaimplementować własny mechanizm synchronizacji.  
  
 Domyślne implementacje kolekcji w <xref:System.Collections.Generic?displayProperty=nameWithType> nie są zsynchronizowane.  
  
 Ta metoda jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, że <xref:System.Collections.Generic.Stack%601> klasy generycznej jest wyliczalna. `foreach` — Instrukcja (`For Each` w języku Visual Basic `for each` w języku C++) jest używany do wyliczenia kolejki.  
  
 Przykład kodu tworzy stosu ciągów przy użyciu domyślnej pojemności i używa <xref:System.Collections.Generic.Stack%601.Push%2A> metodę, aby wypchnąć pięć ciągi na stosie. Elementy stosu są wyliczane nie zmienia stanu stosu. <xref:System.Collections.Generic.Stack%601.Pop%2A> Metoda jest używana do pop pierwszy ciąg ze stosu. <xref:System.Collections.Generic.Stack%601.Peek%2A> Metoda jest używana do wzięcia pod następnego elementu w stosie, a następnie <xref:System.Collections.Generic.Stack%601.Pop%2A> metoda jest używana do pop go.  
  
 <xref:System.Collections.Generic.Stack%601.ToArray%2A> Metoda jest używana do utworzenia tablicy, a następnie skopiuj elementy stosu do niego, a następnie tablicy jest przekazywany do <xref:System.Collections.Generic.Stack%601.%23ctor%2A> konstruktora przyjmującego <xref:System.Collections.Generic.IEnumerable%601>, tworząc kopię stosu w kolejności elementów odwrócony. Elementy kopii są wyświetlane.  
  
 Dwa razy rozmiar stosu jest tworzona macierz, a <xref:System.Collections.Generic.Stack%601.CopyTo%2A> metoda jest używana do skopiowania elementów tablicy, zaczynając od środka tablicy. <xref:System.Collections.Generic.Stack%601.%23ctor%2A> Konstruktora jest używany ponownie utworzyć kopię stosu w kolejności elementów odwrócony; w związku z tym, trzy elementy o wartości null znajdują się na końcu.  
  
 <xref:System.Collections.Generic.Stack%601.Contains%2A> Metoda jest używana do pokazują, że ciąg "4" jest pierwsza kopia stosu, po którym <xref:System.Collections.Generic.Stack%601.Clear%2A> metoda czyści kopii i <xref:System.Collections.Generic.Stack%601.Count%2A> właściwość pokazuje, że stos jest pusty.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.Stack`1.Enumerator" />
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public T Peek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T Peek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.Peek" />
      <MemberSignature Language="VB.NET" Value="Public Function Peek () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T Peek();" />
      <MemberSignature Language="F#" Value="member this.Peek : unit -&gt; 'T" Usage="stack.Peek " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca obiekt, w górnej części <see cref="T:System.Collections.Generic.Stack`1" /> bez usuwania go.</summary>
        <returns>Obiekt w górnej części <see cref="T:System.Collections.Generic.Stack`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest podobna do <xref:System.Collections.Generic.Stack%601.Pop%2A> metody, ale <xref:System.Collections.Generic.Stack%601.Peek%2A> nie modyfikuje <xref:System.Collections.Generic.Stack%601>.  
  
 Jeśli typ `T` jest typem referencyjnym `null` zostać wypchnięty na <xref:System.Collections.Generic.Stack%601> jako symbol zastępczy, jeśli to konieczne.  
  
 Ta metoda jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje kilka metod <xref:System.Collections.Generic.Stack%601> klasy ogólnej, w tym <xref:System.Collections.Generic.Stack%601.Peek%2A> metody.  
  
 Przykład kodu tworzy stosu ciągów przy użyciu domyślnej pojemności i używa <xref:System.Collections.Generic.Stack%601.Push%2A> metodę, aby wypchnąć pięć ciągi na stosie. Elementy stosu są wyliczane nie zmienia stanu stosu. <xref:System.Collections.Generic.Stack%601.Pop%2A> Metoda jest używana do pop pierwszy ciąg ze stosu. <xref:System.Collections.Generic.Stack%601.Peek%2A> Metoda jest używana do wzięcia pod następnego elementu w stosie, a następnie <xref:System.Collections.Generic.Stack%601.Pop%2A> metoda jest używana do pop go.  
  
 <xref:System.Collections.Generic.Stack%601.ToArray%2A> Metoda jest używana do utworzenia tablicy, a następnie skopiuj elementy stosu do niego, a następnie tablicy jest przekazywany do <xref:System.Collections.Generic.Stack%601.%23ctor%2A> konstruktora przyjmującego <xref:System.Collections.Generic.IEnumerable%601>, tworząc kopię stosu w kolejności elementów odwrócony. Elementy kopii są wyświetlane.  
  
 Dwa razy rozmiar stosu jest tworzona macierz, a <xref:System.Collections.Generic.Stack%601.CopyTo%2A> metoda jest używana do skopiowania elementów tablicy, zaczynając od środka tablicy. <xref:System.Collections.Generic.Stack%601.%23ctor%2A> Konstruktora jest używany ponownie utworzyć kopię stosu w kolejności elementów odwrócony; w związku z tym, trzy elementy o wartości null znajdują się na końcu.  
  
 <xref:System.Collections.Generic.Stack%601.Contains%2A> Metoda jest używana do pokazują, że ciąg "4" jest pierwsza kopia stosu, po którym <xref:System.Collections.Generic.Stack%601.Clear%2A> metoda czyści kopii i <xref:System.Collections.Generic.Stack%601.Count%2A> właściwość pokazuje, że stos jest pusty.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Collections.Generic.Stack`1" /> Jest pusty.</exception>
        <altmember cref="M:System.Collections.Generic.Stack`1.Pop" />
        <altmember cref="M:System.Collections.Generic.Stack`1.Push(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Pop">
      <MemberSignature Language="C#" Value="public T Pop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T Pop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.Pop" />
      <MemberSignature Language="VB.NET" Value="Public Function Pop () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T Pop();" />
      <MemberSignature Language="F#" Value="member this.Pop : unit -&gt; 'T" Usage="stack.Pop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa i zwraca obiekt, w górnej części <see cref="T:System.Collections.Generic.Stack`1" />.</summary>
        <returns>Obiekt usunięty z góry <see cref="T:System.Collections.Generic.Stack`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest podobna do <xref:System.Collections.Generic.Stack%601.Peek%2A> metody, ale <xref:System.Collections.Generic.Stack%601.Peek%2A> nie modyfikuje <xref:System.Collections.Generic.Stack%601>.  
  
 Jeśli typ `T` jest typem referencyjnym `null` zostać wypchnięty na <xref:System.Collections.Generic.Stack%601> jako symbol zastępczy, jeśli to konieczne.  
  
 <xref:System.Collections.Generic.Stack%601> jest implementowana jako tablica. Ta metoda jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje kilka metod <xref:System.Collections.Generic.Stack%601> klasy ogólnej, w tym <xref:System.Collections.Generic.Stack%601.Pop%2A> metody.  
  
 Przykład kodu tworzy stosu ciągów przy użyciu domyślnej pojemności i używa <xref:System.Collections.Generic.Stack%601.Push%2A> metodę, aby wypchnąć pięć ciągi na stosie. Elementy stosu są wyliczane nie zmienia stanu stosu. <xref:System.Collections.Generic.Stack%601.Pop%2A> Metoda jest używana do pop pierwszy ciąg ze stosu. <xref:System.Collections.Generic.Stack%601.Peek%2A> Metoda jest używana do wzięcia pod następnego elementu w stosie, a następnie <xref:System.Collections.Generic.Stack%601.Pop%2A> metoda jest używana do pop go.  
  
 <xref:System.Collections.Generic.Stack%601.ToArray%2A> Metoda jest używana do utworzenia tablicy, a następnie skopiuj elementy stosu do niego, a następnie tablicy jest przekazywany do <xref:System.Collections.Generic.Stack%601.%23ctor%2A> konstruktora przyjmującego <xref:System.Collections.Generic.IEnumerable%601>, tworząc kopię stosu w kolejności elementów odwrócony. Elementy kopii są wyświetlane.  
  
 Dwa razy rozmiar stosu jest tworzona macierz, a <xref:System.Collections.Generic.Stack%601.CopyTo%2A> metoda jest używana do skopiowania elementów tablicy, zaczynając od środka tablicy. <xref:System.Collections.Generic.Stack%601.%23ctor%2A> Konstruktora jest używany ponownie utworzyć kopię stosu w kolejności elementów odwrócony; w związku z tym, trzy elementy o wartości null znajdują się na końcu.  
  
 <xref:System.Collections.Generic.Stack%601.Contains%2A> Metoda jest używana do pokazują, że ciąg "4" jest pierwsza kopia stosu, po którym <xref:System.Collections.Generic.Stack%601.Clear%2A> metoda czyści kopii i <xref:System.Collections.Generic.Stack%601.Count%2A> właściwość pokazuje, że stos jest pusty.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Collections.Generic.Stack`1" /> Jest pusty.</exception>
        <altmember cref="M:System.Collections.Generic.Stack`1.Peek" />
        <altmember cref="M:System.Collections.Generic.Stack`1.Push(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Push">
      <MemberSignature Language="C#" Value="public void Push (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Push(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.Push(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Push (item As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Push(T item);" />
      <MemberSignature Language="F#" Value="member this.Push : 'T -&gt; unit" Usage="stack.Push item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Obiekt do przekazania <see cref="T:System.Collections.Generic.Stack`1" />. Wartość może być <see langword="null" /> dla typów odwołań.</param>
        <summary>Wstawienie obiektu w górnej części <see cref="T:System.Collections.Generic.Stack`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.Stack%601> jest implementowana jako tablica.  
  
 Jeśli <xref:System.Collections.Generic.Stack%601.Count%2A> jest już równa pojemności pojemność <xref:System.Collections.Generic.Stack%601> jest zwiększana o automatyczne ponowne przydzielanie tablicy wewnętrznej i istniejące elementy są kopiowane do nowej tablicy, przed dodaniem nowego elementu.  
  
 Jeśli typ `T` jest typem referencyjnym `null` zostać wypchnięty na <xref:System.Collections.Generic.Stack%601> jako symbol zastępczy, jeśli to konieczne. On zajmuje miejsce w stosie i jest traktowany jak inne obiekty.  
  
 Jeśli <xref:System.Collections.Generic.Stack%601.Count%2A> jest mniejsza niż pojemność stosu, <xref:System.Collections.Generic.Stack%601.Push%2A> jest operacją O(1). Jeśli pojemność musi zostać zwiększona, aby pomieścić nowy element <xref:System.Collections.Generic.Stack%601.Push%2A> staje się O (`n`) operacji, gdzie `n` jest <xref:System.Collections.Generic.Stack%601.Count%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje kilka metod <xref:System.Collections.Generic.Stack%601> klasy ogólnej, w tym <xref:System.Collections.Generic.Stack%601.Push%2A> metody.  
  
 Przykład kodu tworzy stosu ciągów przy użyciu domyślnej pojemności i używa <xref:System.Collections.Generic.Stack%601.Push%2A> metodę, aby wypchnąć pięć ciągi na stosie. Elementy stosu są wyliczane nie zmienia stanu stosu. <xref:System.Collections.Generic.Stack%601.Pop%2A> Metoda jest używana do pop pierwszy ciąg ze stosu. <xref:System.Collections.Generic.Stack%601.Peek%2A> Metoda jest używana do wzięcia pod następnego elementu w stosie, a następnie <xref:System.Collections.Generic.Stack%601.Pop%2A> metoda jest używana do pop go.  
  
 <xref:System.Collections.Generic.Stack%601.ToArray%2A> Metoda jest używana do utworzenia tablicy, a następnie skopiuj elementy stosu do niego, a następnie tablicy jest przekazywany do <xref:System.Collections.Generic.Stack%601.%23ctor%2A> konstruktora przyjmującego <xref:System.Collections.Generic.IEnumerable%601>, tworząc kopię stosu w kolejności elementów odwrócony. Elementy kopii są wyświetlane.  
  
 Dwa razy rozmiar stosu jest tworzona macierz, a <xref:System.Collections.Generic.Stack%601.CopyTo%2A> metoda jest używana do skopiowania elementów tablicy, zaczynając od środka tablicy. <xref:System.Collections.Generic.Stack%601.%23ctor%2A> Konstruktora jest używany ponownie utworzyć kopię stosu w kolejności elementów odwrócony; w związku z tym, trzy elementy o wartości null znajdują się na końcu.  
  
 <xref:System.Collections.Generic.Stack%601.Contains%2A> Metoda jest używana do pokazują, że ciąg "4" jest pierwsza kopia stosu, po którym <xref:System.Collections.Generic.Stack%601.Clear%2A> metoda czyści kopii i <xref:System.Collections.Generic.Stack%601.Count%2A> właściwość pokazuje, że stos jest pusty.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.Stack`1.Peek" />
        <altmember cref="M:System.Collections.Generic.Stack`1.Pop" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;!T&gt; System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.System#Collections#Generic#IEnumerable&lt;T&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of T) Implements IEnumerable(Of T).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;T&gt; ^ System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;T&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca moduł wyliczający, który dokonuje iteracji w kolekcji.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerator`1" /> Który może służyć do iterowania po kolekcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `foreach` Instrukcja języka C# (`for each` w języku C++, `For Each` w języku Visual Basic) powoduje ukrycie złożoności modułów wyliczających. W związku z tym, za pomocą `foreach` jest to zalecane, zamiast bezpośredniego wykonywania operacji modułu wyliczającego.  
  
 Moduły wyliczające mogą służyć do odczytu danych w kolekcji, ale nie można za ich pomocą modyfikować kolekcji źródłowej.  
  
 Początkowo moduł wyliczający jest umieszczony przed pierwszym elementem w kolekcji. W tym miejscu <xref:System.Collections.Generic.IEnumerator%601.Current%2A> jest niezdefiniowana. W związku z tym, należy wywołać <xref:System.Collections.IEnumerator.MoveNext%2A> do wyprzedzeniem modułu wyliczającego do pierwszego elementu kolekcji przed odczytaniem wartości właściwości <xref:System.Collections.Generic.IEnumerator%601.Current%2A>.  
  
 <xref:System.Collections.Generic.IEnumerator%601.Current%2A> zwraca ten sam obiekt, do momentu <xref:System.Collections.IEnumerator.MoveNext%2A> jest wywoływana. <xref:System.Collections.IEnumerator.MoveNext%2A> Ustawia <xref:System.Collections.Generic.IEnumerator%601.Current%2A> do następnego elementu.  
  
 Jeśli <xref:System.Collections.IEnumerator.MoveNext%2A> przebiegów koniec kolekcji, moduł wyliczający jest umieszczany za ostatnim elementem w kolekcji i <xref:System.Collections.IEnumerator.MoveNext%2A> zwraca `false`. Gdy moduł wyliczający jest w tym miejscu, kolejne wywołania <xref:System.Collections.IEnumerator.MoveNext%2A> również zwracać `false`. Jeśli ostatnie wywołanie <xref:System.Collections.IEnumerator.MoveNext%2A> zwrócił `false`, <xref:System.Collections.Generic.IEnumerator%601.Current%2A> jest niezdefiniowana. Nie można ustawić <xref:System.Collections.Generic.IEnumerator%601.Current%2A> do pierwszego elementu w kolekcji; należy utworzyć nowe wystąpienie modułu wyliczającego zamiast tego.  
  
 Moduł wyliczający zachowuje ważność tak długo, jak długo kolekcja pozostaje niezmieniona. Jeśli zmiany zostały wprowadzone do kolekcji, takie jak dodawanie, modyfikowanie lub usuwanie elementów, moduł wyliczający jest nieodwracalnie unieważnione, a następne wywołanie <xref:System.Collections.IEnumerator.MoveNext%2A> lub <xref:System.Collections.IEnumerator.Reset%2A> zgłasza <xref:System.InvalidOperationException>.  
  
 Moduł wyliczający nie ma wyłącznego dostępu do kolekcji, w związku z tym wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość. Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania.  Aby zezwolić wielu wątkom na dostęp do kolekcji w celu odczytu i zapisu danych, należy zaimplementować własny mechanizm synchronizacji.  
  
 Domyślne implementacje kolekcji w <xref:System.Collections.Generic?displayProperty=nameWithType> nie są zsynchronizowane.  
  
 Ta metoda jest operacją O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int arrayIndex) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Jednowymiarowy <see cref="T:System.Array" /> czyli miejscem docelowym elementów kopiowanych z <see cref="T:System.Collections.ICollection" />. <see cref="T:System.Array" /> Musi mieć Indeksowanie oparte na zerze.</param>
        <param name="arrayIndex">Liczony od zera indeks w <c>tablicy</c> od rozpoczyna się kopiowanie które.</param>
        <summary>Kopiuje elementy ze <see cref="T:System.Collections.ICollection" /> do <see cref="T:System.Array" />, rozpoczynając od określonego <see cref="T:System.Array" /> indeksu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Jeśli typ źródła <xref:System.Collections.ICollection> nie można automatycznie rzutować na typ docelowy `array`, implementacje nieogólnego <xref:System.Collections.ICollection.CopyTo%2A?displayProperty=nameWithType> throw <xref:System.InvalidCastException>, podczas gdy throw ogólnego implementacje <xref:System.ArgumentException>.  
  
 Ta metoda jest O (`n`) operacji, gdzie `n` jest <xref:System.Collections.Generic.Stack%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="arrayIndex" /> jest mniejsza niż zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> ma charakter wielowymiarowy.  
  
—lub— 
 <paramref name="array" /> nie ma indeksowania zaczynającego się od zera.  
  
—lub— 
Liczba elementów w źródle <see cref="T:System.Collections.ICollection" /> jest większa niż dostępna ilość miejsca od <paramref name="arrayIndex" /> do końca tablicy docelowej <paramref name="array" />.  
  
—lub— 
Typ źródła <see cref="T:System.Collections.ICollection" /> nie można automatycznie rzutować na typ docelowy <paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Stack`1.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy dostęp do <see cref="T:System.Collections.ICollection" /> jest synchronizowane (wątkowo).</summary>
        <value>
          <see langword="true" /> Jeśli dostęp do <see cref="T:System.Collections.ICollection" /> jest synchronizowane (wątkowo); w przeciwnym razie <see langword="false" />.  W implementacji domyślnej <see cref="T:System.Collections.Generic.Stack`1" />, właściwość ta zwraca zawsze <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślne implementacje kolekcji w <xref:System.Collections.Generic?displayProperty=nameWithType> nie są zsynchronizowane.  
  
 Wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość.  W rzadkich przypadkach, w którym wyliczenia będą konkurować o uzyskuje dostęp do zapisu można zablokować kolekcję podczas całego procesu wyliczania.  Aby zezwolić wielu wątkom na dostęp do kolekcji w celu odczytu i zapisu danych, należy zaimplementować własny mechanizm synchronizacji.  
  
 <xref:System.Collections.ICollection.SyncRoot%2A> Zwraca obiekt, który może służyć do synchronizowania dostępu do <xref:System.Collections.ICollection>. Synchronizacja jest efektywne tylko wtedy, gdy wszystkie wątki zablokowania obiektu przed uzyskaniem dostępu do kolekcji.  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Stack`1.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera obiekt, który może służyć do synchronizowania dostępu do <see cref="T:System.Collections.ICollection" />.</summary>
        <value>Obiekt, który może służyć do synchronizowania dostępu do <see cref="T:System.Collections.ICollection" />.  W implementacji domyślnej <see cref="T:System.Collections.Generic.Stack`1" />, właściwość ta zwraca zawsze bieżącego wystąpienia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślne implementacje kolekcji w <xref:System.Collections.Generic?displayProperty=nameWithType> nie są zsynchronizowane.  
  
 Wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość.  Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania.  Aby zezwolić wielu wątkom na dostęp do kolekcji w celu odczytu i zapisu danych, należy zaimplementować własny mechanizm synchronizacji.  
  
 <xref:System.Collections.ICollection.SyncRoot%2A> Zwraca obiekt, który może służyć do synchronizowania dostępu do <xref:System.Collections.ICollection>. Synchronizacja jest efektywne tylko wtedy, gdy wszystkie wątki zablokowania obiektu przed uzyskaniem dostępu do kolekcji. Poniższy kod przedstawia użycie <xref:System.Collections.ICollection.SyncRoot%2A> właściwość dla języka C#, C++ i Visual Basic.  
  
```csharp  
ICollection ic = ...;  
lock (ic.SyncRoot) {  
   // Access the collection.  
}  
```  
  
```vb  
Dim ic As ICollection = ...  
SyncLock ic.SyncRoot  
   ' Access the collection.  
End SyncLock  
```  
  
```cpp#  
ICollection^ ic = ...;  
try {  
   Monitor::Enter(ic->SyncRoot);  
   // Access the collection.  
}  
finally {  
   Monitor::Exit(ic->SyncRoot);  
}  
```  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca moduł wyliczający, który dokonuje iteracji w kolekcji.</summary>
        <returns>
          <see cref="T:System.Collections.IEnumerator" /> Który może służyć do iterowania po kolekcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `foreach` Instrukcja języka C# (`for each` w języku C++, `For Each` w języku Visual Basic) powoduje ukrycie złożoności modułów wyliczających. W związku z tym, za pomocą `foreach` jest to zalecane, zamiast bezpośredniego wykonywania operacji modułu wyliczającego.  
  
 Moduły wyliczające mogą służyć do odczytu danych w kolekcji, ale nie można za ich pomocą modyfikować kolekcji źródłowej.  
  
 Początkowo moduł wyliczający jest umieszczony przed pierwszym elementem w kolekcji. <xref:System.Collections.IEnumerator.Reset%2A> Przełącza moduł wyliczający do tej pozycji.  W tym miejscu <xref:System.Collections.IEnumerator.Current%2A> jest niezdefiniowana. W związku z tym, należy wywołać <xref:System.Collections.IEnumerator.MoveNext%2A> do wyprzedzeniem modułu wyliczającego do pierwszego elementu kolekcji przed odczytaniem wartości właściwości <xref:System.Collections.IEnumerator.Current%2A>.  
  
 <xref:System.Collections.IEnumerator.Current%2A> zwraca ten sam obiekt, do momentu <xref:System.Collections.IEnumerator.MoveNext%2A> lub <xref:System.Collections.IEnumerator.Reset%2A> jest wywoływana. <xref:System.Collections.IEnumerator.MoveNext%2A> Ustawia <xref:System.Collections.IEnumerator.Current%2A> do następnego elementu.  
  
 Jeśli <xref:System.Collections.IEnumerator.MoveNext%2A> przebiegów koniec kolekcji, moduł wyliczający jest umieszczany za ostatnim elementem w kolekcji i <xref:System.Collections.IEnumerator.MoveNext%2A> zwraca `false`. Gdy moduł wyliczający jest w tym miejscu, kolejne wywołania <xref:System.Collections.IEnumerator.MoveNext%2A> również zwracać `false`. Jeśli ostatnie wywołanie <xref:System.Collections.IEnumerator.MoveNext%2A> zwrócił `false`, <xref:System.Collections.IEnumerator.Current%2A> jest niezdefiniowana. Aby ustawić <xref:System.Collections.IEnumerator.Current%2A> do pierwszego elementu w kolekcji ponownie wywołaj <xref:System.Collections.IEnumerator.Reset%2A> następuje <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Moduł wyliczający zachowuje ważność tak długo, jak długo kolekcja pozostaje niezmieniona. Jeśli zmiany zostały wprowadzone do kolekcji, takie jak dodawanie, modyfikowanie lub usuwanie elementów, moduł wyliczający jest nieodwracalnie unieważnione, a następne wywołanie <xref:System.Collections.IEnumerator.MoveNext%2A> lub <xref:System.Collections.IEnumerator.Reset%2A> zgłasza <xref:System.InvalidOperationException>.  
  
 Moduł wyliczający nie ma wyłącznego dostępu do kolekcji, w związku z tym wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość.  Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania.  Aby zezwolić wielu wątkom na dostęp do kolekcji w celu odczytu i zapisu danych, należy zaimplementować własny mechanizm synchronizacji.  
  
 Domyślne implementacje kolekcji w <xref:System.Collections.Generic?displayProperty=nameWithType> nie są zsynchronizowane.  
  
 Ta metoda jest operacją O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.Stack`1.GetEnumerator" />
        <altmember cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" />
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public T[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T[] ToArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.ToArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToArray () As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;T&gt; ^ ToArray();" />
      <MemberSignature Language="F#" Value="member this.ToArray : unit -&gt; 'T[]" Usage="stack.ToArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Kopiuje <see cref="T:System.Collections.Generic.Stack`1" /> do nowej tablicy.</summary>
        <returns>Nową tablicę zawierającą kopiuje elementy <see cref="T:System.Collections.Generic.Stack`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Elementy są kopiowane na tablicy ostatni wejściu — pierwszy na wyjściu (LIFO) kolejno zbliżona do kolejności elementów zwróconych przez kolejne wywołania <xref:System.Collections.Generic.Stack%601.Pop%2A>.  
  
 Ta metoda jest O (`n`) operacji, gdzie `n` jest <xref:System.Collections.Generic.Stack%601.Count%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje kilka metod <xref:System.Collections.Generic.Stack%601> klasy ogólnej, w tym <xref:System.Collections.Generic.Stack%601.ToArray%2A> metody.  
  
 Przykład kodu tworzy stosu ciągów przy użyciu domyślnej pojemności i używa <xref:System.Collections.Generic.Stack%601.Push%2A> metodę, aby wypchnąć pięć ciągi na stosie. Elementy stosu są wyliczane nie zmienia stanu stosu. <xref:System.Collections.Generic.Stack%601.Pop%2A> Metoda jest używana do pop pierwszy ciąg ze stosu. <xref:System.Collections.Generic.Stack%601.Peek%2A> Metoda jest używana do wzięcia pod następnego elementu w stosie, a następnie <xref:System.Collections.Generic.Stack%601.Pop%2A> metoda jest używana do pop go.  
  
 <xref:System.Collections.Generic.Stack%601.ToArray%2A> Metoda jest używana do utworzenia tablicy, a następnie skopiuj elementy stosu do niego, a następnie tablicy jest przekazywany do <xref:System.Collections.Generic.Stack%601.%23ctor%2A> konstruktora przyjmującego <xref:System.Collections.Generic.IEnumerable%601>, tworząc kopię stosu w kolejności elementów odwrócony. Elementy kopii są wyświetlane.  
  
 Dwa razy rozmiar stosu jest tworzona macierz, a <xref:System.Collections.Generic.Stack%601.CopyTo%2A> metoda jest używana do skopiowania elementów tablicy, zaczynając od środka tablicy. <xref:System.Collections.Generic.Stack%601.%23ctor%2A> Konstruktora jest używany ponownie utworzyć kopię stosu w kolejności elementów odwrócony; w związku z tym, trzy elementy o wartości null znajdują się na końcu.  
  
 <xref:System.Collections.Generic.Stack%601.Contains%2A> Metoda jest używana do pokazują, że ciąg "4" jest pierwsza kopia stosu, po którym <xref:System.Collections.Generic.Stack%601.Clear%2A> metoda czyści kopii i <xref:System.Collections.Generic.Stack%601.Count%2A> właściwość pokazuje, że stos jest pusty.  
  
 [!code-csharp[Generic.Stack#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Stack/cs/source.cs#1)]
 [!code-vb[Generic.Stack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Stack/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.Stack`1.CopyTo(`0[],System.Int32)" />
        <altmember cref="M:System.Collections.Generic.Stack`1.Pop" />
      </Docs>
    </Member>
    <Member MemberName="TrimExcess">
      <MemberSignature Language="C#" Value="public void TrimExcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TrimExcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.TrimExcess" />
      <MemberSignature Language="VB.NET" Value="Public Sub TrimExcess ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TrimExcess();" />
      <MemberSignature Language="F#" Value="member this.TrimExcess : unit -&gt; unit" Usage="stack.TrimExcess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ustawia pojemność do rzeczywistej liczby elementów w <see cref="T:System.Collections.Generic.Stack`1" />, jeśli ta liczba jest bieżąca pojemność w mniej niż 90 procentach.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może być używana aby zminimalizować obciążenie pamięci kolekcji, jeśli żadne nowe elementy, które zostaną dodane do kolekcji. Koszt ponowne przydzielanie i kopiowania dużych <xref:System.Collections.Generic.Stack%601> mogą być jednak znaczące, więc <xref:System.Collections.Generic.Stack%601.TrimExcess%2A> metody nie robi nic, jeśli lista jest więcej niż 90 procent pojemność. Pozwala to uniknąć ponoszenia koszt dużych ponownej alokacji dla niewielkich korzyści.  
  
 Ta metoda jest O (`n`) operacji, gdzie `n` jest <xref:System.Collections.Generic.Stack%601.Count%2A>.  
  
 Aby zresetować <xref:System.Collections.Generic.Stack%601> do stanu początkowego wywołania <xref:System.Collections.Generic.Stack%601.Clear%2A> metoda przed wywołaniem <xref:System.Collections.Generic.Stack%601.TrimExcess%2A> metody. Przycinanie pustą <xref:System.Collections.Generic.Stack%601> ustawia pojemność <xref:System.Collections.Generic.Stack%601> do pojemności domyślnej.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.Stack`1.Clear" />
        <altmember cref="P:System.Collections.Generic.Stack`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="TryPeek">
      <MemberSignature Language="C#" Value="public bool TryPeek (out T result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryPeek([out] !T&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.TryPeek(`0@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryPeek (ByRef result As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryPeek([Runtime::InteropServices::Out] T % result);" />
      <MemberSignature Language="F#" Value="member this.TryPeek :  -&gt; bool" Usage="stack.TryPeek result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="T" RefType="out" />
      </Parameters>
      <Docs>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryPop">
      <MemberSignature Language="C#" Value="public bool TryPop (out T result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryPop([out] !T&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Stack`1.TryPop(`0@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryPop (ByRef result As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryPop([Runtime::InteropServices::Out] T % result);" />
      <MemberSignature Language="F#" Value="member this.TryPop :  -&gt; bool" Usage="stack.TryPop result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="T" RefType="out" />
      </Parameters>
      <Docs>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
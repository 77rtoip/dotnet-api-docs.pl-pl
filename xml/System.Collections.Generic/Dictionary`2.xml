<Type Name="Dictionary&lt;TKey,TValue&gt;" FullName="System.Collections.Generic.Dictionary&lt;TKey,TValue&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="3eab5e4eb56090f83309db44ae8e39996b4873ce" /><Meta Name="ms.sourcegitcommit" Value="634678f7ccd2928c6b2cf792a301b079b63639af" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="07/26/2019" /><Meta Name="ms.locfileid" Value="68541399" /></Metadata><TypeSignature Language="C#" Value="public class Dictionary&lt;TKey,TValue&gt; : System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;, System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;, System.Collections.Generic.IReadOnlyCollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;, System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;, System.Collections.IDictionary, System.Runtime.Serialization.IDeserializationCallback, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Dictionary`2&lt;TKey, TValue&gt; extends System.Object implements class System.Collections.Generic.ICollection`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt;, class System.Collections.Generic.IDictionary`2&lt;!TKey, !TValue&gt;, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt;, class System.Collections.Generic.IReadOnlyDictionary`2&lt;!TKey, !TValue&gt;, class System.Collections.ICollection, class System.Collections.IDictionary, class System.Collections.IEnumerable, class System.Runtime.Serialization.IDeserializationCallback, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Generic.Dictionary`2" />
  <TypeSignature Language="VB.NET" Value="Public Class Dictionary(Of TKey, TValue)&#xA;Implements ICollection(Of KeyValuePair(Of TKey, TValue)), IDeserializationCallback, IDictionary, IDictionary(Of TKey, TValue), IEnumerable(Of KeyValuePair(Of TKey, TValue)), IReadOnlyCollection(Of KeyValuePair(Of TKey, TValue)), IReadOnlyDictionary(Of TKey, TValue), ISerializable" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TKey, typename TValue&gt;&#xA;public ref class Dictionary : System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;, System::Collections::Generic::IDictionary&lt;TKey, TValue&gt;, System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;, System::Collections::Generic::IReadOnlyCollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;, System::Collections::Generic::IReadOnlyDictionary&lt;TKey, TValue&gt;, System::Collections::IDictionary, System::Runtime::Serialization::IDeserializationCallback, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Dictionary&lt;'Key, 'Value&gt; = class&#xA;    interface IDictionary&lt;'Key, 'Value&gt;&#xA;    interface IDictionary&#xA;    interface IReadOnlyDictionary&lt;'Key, 'Value&gt;&#xA;    interface ISerializable&#xA;    interface IDeserializationCallback&#xA;    interface ICollection&lt;KeyValuePair&lt;'Key, 'Value&gt;&gt;&#xA;    interface seq&lt;KeyValuePair&lt;'Key, 'Value&gt;&gt;&#xA;    interface IEnumerable&#xA;    interface ICollection&#xA;    interface IReadOnlyCollection&lt;KeyValuePair&lt;'Key, 'Value&gt;&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Collections</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TKey" />
    <TypeParameter Name="TValue" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IDictionary</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.IDeserializationCallback</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.Mscorlib_DictionaryDebugView`2))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="TKey">Typ kluczy w słowniku.</typeparam>
    <typeparam name="TValue">Typ wartości w słowniku.</typeparam>
    <summary>Reprezentuje kolekcję kluczy i wartości.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasa <xref:System.Collections.Generic.Dictionary%602> generyczna zapewnia mapowanie z zestawu kluczy do zestawu wartości. Każde dodanie do słownika składa się z wartości i skojarzonego z nim klucza. Pobieranie wartości przy użyciu jej klucza jest bardzo szybkie, blisko o (1), ponieważ <xref:System.Collections.Generic.Dictionary%602> Klasa jest zaimplementowana jako tablica skrótów.  
  
> [!NOTE]
>  Szybkość pobierania zależy od jakości algorytmu wyznaczania wartości skrótu typu określonego dla `TKey`.  
  
 Tak długo <xref:System.Collections.Generic.Dictionary%602>, jak obiekt jest używany jako klucz w, nie może zmieniać się w żaden sposób, który wpływa na jego wartość skrótu. Każdy klucz w a <xref:System.Collections.Generic.Dictionary%602> musi być unikatowy w zależności od porównania równości słownika. Klucz nie może być `null`, ale wartość może być, jeśli jej typem `TValue` jest typ referencyjny.  
  
 <xref:System.Collections.Generic.Dictionary%602>wymaga implementacji równości, aby określić, czy klucze są równe. Można określić implementację <xref:System.Collections.Generic.IEqualityComparer%601> interfejsu generycznego za pomocą konstruktora, który `comparer` akceptuje parametr; Jeśli nie określisz implementacji, zostanie użyta domyślna ogólna funkcja porównująca <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> równość. Jeśli typ `TKey` <xref:System.IEquatable%601?displayProperty=nameWithType> implementuje interfejs ogólny, domyślna funkcja porównująca równość używa tej implementacji.  
  
> [!NOTE]
>  Można na przykład użyć niewrażliwych na wielkość liter porównywania ciągów dostarczonych przez <xref:System.StringComparer> klasę do tworzenia słowników z kluczami ciągów bez uwzględniania wielkości liter.  
  
 Pojemność a to liczba <xref:System.Collections.Generic.Dictionary%602> elementów, które <xref:System.Collections.Generic.Dictionary%602> mogą być przechowywane. Gdy elementy są dodawane do <xref:System.Collections.Generic.Dictionary%602>, pojemność jest automatycznie zwiększana zgodnie z wymaganiami przez ponowną alokację tablicy wewnętrznej.  
  
 **Tylko .NET Framework:** W przypadku bardzo <xref:System.Collections.Generic.Dictionary%602> dużych obiektów można zwiększyć maksymalną pojemność do 2 000 000 000 elementów w systemie 64-bitowym, `enabled` ustawiając atrybut [`<gcAllowVeryLargeObjects>`](~/docs/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element.md) elementu konfiguracji na `true` w środowisku wykonawczym.  
  
 Na potrzeby wyliczenia każdy element w słowniku jest traktowany jako <xref:System.Collections.Generic.KeyValuePair%602> struktura reprezentująca wartość i jej klucz. Kolejność, w której zwracane są elementy, jest niezdefiniowana.  
  
 `foreach` Instrukcja C# języka(`for each` C++w ,`For Each` w Visual Basic) zwraca obiekt typu elementów w kolekcji. <xref:System.Collections.Generic.Dictionary%602> Ponieważ jest kolekcją kluczy i wartości, typ elementu nie jest typem klucza ani typem wartości. Zamiast tego typ elementu jest <xref:System.Collections.Generic.KeyValuePair%602> typem klucza i typem wartości. Przykład:  
  
 [!code-cpp[Generic.Dictionary#11](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.Dictionary/cpp/source2.cpp#11)]
 [!code-csharp[Generic.Dictionary#11](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary/CS/source2.cs#11)]
 [!code-vb[Generic.Dictionary#11](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary/VB/source2.vb#11)]  
  
 `foreach` Instrukcja to otoka wokół modułu wyliczającego, która umożliwia odczytywanie danych z kolekcji, a nie zapisywanie w niej.  
  
> [!NOTE]
>  Ponieważ klucze mogą być dziedziczone i ich zachowanie zostało zmienione, ich absolutna unikatowość nie może być gwarantowana przez <xref:System.Type.Equals%2A> porównania przy użyciu metody.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy puste <xref:System.Collections.Generic.Dictionary%602> ciągi z kluczami ciągu i <xref:System.Collections.Generic.Dictionary%602.Add%2A> używa metody do dodawania niektórych elementów. W przykładzie pokazano, że <xref:System.Collections.Generic.Dictionary%602.Add%2A> Metoda <xref:System.ArgumentException> zgłasza podczas próby dodania zduplikowanego klucza.  
  
 W przykładzie zastosowano <xref:System.Collections.Generic.Dictionary%602.Item%2A> Właściwość (indeksator w C#) do pobierania wartości, <xref:System.Collections.Generic.KeyNotFoundException> pokazując, że jest zgłaszany, gdy żądany klucz nie jest obecny i wskazuje, że wartość skojarzona z kluczem może zostać zastąpiona.  
  
 Przykład pokazuje, jak użyć metody <xref:System.Collections.Generic.Dictionary%602.TryGetValue%2A> jako bardziej efektywnego sposobu pobierania wartości, jeśli program często musi wypróbowywać kluczowe wartości, które nie znajdują się w słowniku, i pokazuje, jak użyć metody <xref:System.Collections.Generic.Dictionary%602.ContainsKey%2A>, aby sprawdzić, czy klucz istnieje przed wywołaniem <xref:System.Collections.Generic.Dictionary%602.Add%2A> metoda.  
  
 W przykładzie pokazano, jak wyliczyć klucze i wartości w słowniku oraz jak wyliczyć klucze i wartości przy użyciu <xref:System.Collections.Generic.Dictionary%602.Keys%2A> właściwości <xref:System.Collections.Generic.Dictionary%602.Values%2A> i właściwości.  
  
 Na koniec przykład ilustruje <xref:System.Collections.Generic.Dictionary%602.Remove%2A> metodę.  
  
 [!code-cpp[Generic.Dictionary#1](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.Dictionary/cpp/source.cpp#1)]
 [!code-csharp[Generic.Dictionary#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary/CS/source.cs#1)]
 [!code-vb[Generic.Dictionary#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe><see cref="T:System.Collections.Generic.Dictionary`2" /> Może obsługiwać wielu czytników współbieżnie, o ile kolekcja nie jest modyfikowana. Nawet w ten sposób Wyliczanie za pomocą kolekcji nie jest w sposób wewnętrzny bezpieczny dla wątków. W rzadkich przypadkach, gdy Wyliczenie jest zgodne z dostępem do zapisu, kolekcja musi być zablokowana w całym wyliczeniu. Aby zezwolić wielu wątkom na dostęp do kolekcji w celu odczytu i zapisu danych, należy zaimplementować własny mechanizm synchronizacji.  
  
W przypadku alternatywnych wątków zapoznaj się z <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2" /> klasą <see cref="T:System.Collections.Immutable.ImmutableDictionary`2" /> lub klasą.  
  
Publiczne statyczne (<see langword="Shared" /> w Visual Basic) członkowie tego typu są bezpieczne wątkowo.</threadsafe>
    <altmember cref="T:System.Collections.Generic.IDictionary`2" />
    <altmember cref="T:System.Collections.Generic.SortedList`2" />
    <altmember cref="T:System.Collections.Generic.KeyValuePair`2" />
    <altmember cref="T:System.Collections.Generic.IEqualityComparer`1" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Collections.Generic.Dictionary`2" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Dictionary ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Dictionary();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Collections.Generic.Dictionary`2" /> klasy, która jest pusta, ma domyślną pojemność początkową i używa domyślnej wartości porównującej równość dla typu klucza.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy klucz w a <xref:System.Collections.Generic.Dictionary%602> musi być unikatowy zgodnie z domyślną wartością porównującą równość.  
  
 <xref:System.Collections.Generic.Dictionary%602>wymaga implementacji równości, aby określić, czy klucze są równe. Ten konstruktor używa domyślnej ogólnej porównującej równości, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType>. Jeśli typ `TKey` <xref:System.IEquatable%601?displayProperty=nameWithType> implementuje interfejs ogólny, domyślna funkcja porównująca równość używa tej implementacji. Alternatywnie można określić implementację <xref:System.Collections.Generic.IEqualityComparer%601> interfejsu generycznego przy użyciu konstruktora, który `comparer` akceptuje parametr.  
  
> [!NOTE]
>  Jeśli można oszacować rozmiar kolekcji, przy użyciu konstruktora, który określa początkową pojemność, eliminuje konieczność wykonywania wielu operacji zmiany rozmiaru podczas dodawania elementów do <xref:System.Collections.Generic.Dictionary%602>.  
  
 Ten konstruktor jest operacją O (1).  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy puste <xref:System.Collections.Generic.Dictionary%602> ciągi z kluczami ciągu i <xref:System.Collections.Generic.Dictionary%602.Add%2A> używa metody do dodawania niektórych elementów. W przykładzie pokazano, że <xref:System.Collections.Generic.Dictionary%602.Add%2A> Metoda <xref:System.ArgumentException> zgłasza podczas próby dodania zduplikowanego klucza.  
  
 Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.Collections.Generic.Dictionary%602> klasy.  
  
 [!code-cpp[Generic.Dictionary#2](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.Dictionary/cpp/source.cpp#2)]
 [!code-csharp[Generic.Dictionary#2](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary/CS/source.cs#2)]
 [!code-vb[Generic.Dictionary#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Immutable.IImmutableDictionary`2" />
        <altmember cref="P:System.Collections.Generic.EqualityComparer`1.Default" />
        <altmember cref="T:System.IEquatable`1" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Dictionary (System.Collections.Generic.IDictionary&lt;TKey,TValue&gt; dictionary);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IDictionary`2&lt;!TKey, !TValue&gt; dictionary) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dictionary As IDictionary(Of TKey, TValue))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Dictionary(System::Collections::Generic::IDictionary&lt;TKey, TValue&gt; ^ dictionary);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt; : System.Collections.Generic.IDictionary&lt;'Key, 'Value&gt; -&gt; System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt;" Usage="new System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt; dictionary" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dictionary" Type="System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;" />
      </Parameters>
      <Docs>
        <param name="dictionary">Elementów <see cref="T:System.Collections.Generic.IDictionary`2" /> , których elementy są kopiowane do nowego <see cref="T:System.Collections.Generic.Dictionary`2" />.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Collections.Generic.Dictionary`2" /> klasy zawierającej elementy skopiowane z określonego <see cref="T:System.Collections.Generic.IDictionary`2" /> i używa domyślnej wartości porównującej równość dla typu klucza.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy klucz w a <xref:System.Collections.Generic.Dictionary%602> musi być unikatowy zgodnie z domyślną wartością porównującą równość; podobnie, każdy klucz w źródle `dictionary` musi również być unikatowy zgodnie z domyślną wartością porównującą równość.  
  
 Początkowa pojemność nowego <xref:System.Collections.Generic.Dictionary%602> elementu jest wystarczająco duża, aby można było zawierać wszystkie elementy w `dictionary`.  
  
 <xref:System.Collections.Generic.Dictionary%602>wymaga implementacji równości, aby określić, czy klucze są równe. Ten konstruktor używa domyślnej ogólnej porównującej równości, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType>. Jeśli typ `TKey` <xref:System.IEquatable%601?displayProperty=nameWithType> implementuje interfejs ogólny, domyślna funkcja porównująca równość używa tej implementacji. Alternatywnie można określić implementację <xref:System.Collections.Generic.IEqualityComparer%601> interfejsu generycznego przy użyciu konstruktora, który `comparer` akceptuje parametr.  
  
 Ten konstruktor jest operacją O (n), gdzie n jest liczbą elementów w `dictionary`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, <xref:System.Collections.Generic.Dictionary%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%29> jak użyć konstruktora, aby <xref:System.Collections.Generic.Dictionary%602> zainicjować z posortowaną zawartością z innego słownika. Przykładowy kod tworzy <xref:System.Collections.Generic.SortedDictionary%602> i wypełnia go danymi w kolejności losowej, a następnie <xref:System.Collections.Generic.SortedDictionary%602> przekazuje do <xref:System.Collections.Generic.Dictionary%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%29> konstruktora, tworząc element <xref:System.Collections.Generic.Dictionary%602> , który jest posortowany. Jest to przydatne, jeśli trzeba skompilować posortowany słownik, który w pewnym momencie stał się statyczny. Kopiowanie danych z programu <xref:System.Collections.Generic.SortedDictionary%602> do programu <xref:System.Collections.Generic.Dictionary%602> zwiększa szybkość pobierania.  
  
 [!code-csharp[Generic.Dictionary.ctor_IDic#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.ctor_IDic/CS/source.cs#1)]
 [!code-vb[Generic.Dictionary.ctor_IDic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.ctor_IDic/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="dictionary" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="dictionary" />zawiera co najmniej jeden zduplikowany klucz.</exception>
        <altmember cref="T:System.Collections.Generic.IDictionary`2" />
        <altmember cref="P:System.Collections.Generic.EqualityComparer`1.Default" />
        <altmember cref="T:System.IEquatable`1" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Dictionary (System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IEnumerable(Of KeyValuePair(Of TKey, TValue)))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Dictionary(System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt; ^ collection);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt; : seq&lt;System.Collections.Generic.KeyValuePair&lt;'Key, 'Value&gt;&gt; -&gt; System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt;" Usage="new System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt; collection" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="collection">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Dictionary (System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEqualityComparer`1&lt;!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (comparer As IEqualityComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Dictionary(System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt; : System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt;" Usage="new System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt; comparer" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <param name="comparer">Implementacja do użycia podczas porównywania kluczy lub <see langword="null" /> użycia wartości domyślnej <see cref="T:System.Collections.Generic.EqualityComparer`1" /> dla typu klucza. <see cref="T:System.Collections.Generic.IEqualityComparer`1" /></param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Collections.Generic.Dictionary`2" /> klasy, która jest pusta, ma domyślną pojemność początkową i używa określonego <see cref="T:System.Collections.Generic.IEqualityComparer`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Za pomocą tego konstruktora można używać nieuwzględniających wielkości liter porównujących ciągów dostarczonych <xref:System.StringComparer> przez klasę do tworzenia słowników z kluczami ciągów bez uwzględniania wielkości liter.  
  
 Każdy klucz w a <xref:System.Collections.Generic.Dictionary%602> musi być unikatowy zgodnie z określoną regułą porównującą.  
  
 <xref:System.Collections.Generic.Dictionary%602>wymaga implementacji równości, aby określić, czy klucze są równe. Jeśli `comparer` <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType>jest `null`, ten konstruktor używa domyślnej ogólnej porównującej równości,. Jeśli typ `TKey` <xref:System.IEquatable%601?displayProperty=nameWithType> implementuje interfejs ogólny, domyślna funkcja porównująca równość używa tej implementacji.  
  
> [!NOTE]
>  Jeśli można oszacować rozmiar kolekcji, przy użyciu konstruktora, który określa początkową pojemność, eliminuje konieczność wykonywania wielu operacji zmiany rozmiaru podczas dodawania elementów do <xref:System.Collections.Generic.Dictionary%602>.  
  
 Ten konstruktor jest operacją O (1).  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy <xref:System.Collections.Generic.Dictionary%602> w przypadku dla bieżącej kultury funkcję porównującą bez uwzględniania wielkości liter. Przykład dodaje cztery elementy, niektóre z kluczami małych liter i niektóre z kluczami wielkich liter. Przykład próbuje dodać element z kluczem, który różni się od istniejącego klucza tylko w przypadku, przechwytuje wyjątek, a następnie wyświetla komunikat o błędzie. Na koniec przykład wyświetla elementy w słowniku.  
  
 [!code-csharp[Generic.Dictionary.ctor_IEqC#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.ctor_IEqC/CS/source.cs#1)]
 [!code-vb[Generic.Dictionary.ctor_IEqC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.ctor_IEqC/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IEqualityComparer`1" />
        <altmember cref="P:System.Collections.Generic.EqualityComparer`1.Default" />
        <altmember cref="T:System.IEquatable`1" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Dictionary (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Dictionary(int capacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt; : int -&gt; System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt;" Usage="new System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt; capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Początkowa liczba elementów, które <see cref="T:System.Collections.Generic.Dictionary`2" /> może zawierać.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Collections.Generic.Dictionary`2" /> klasy, która jest pusta, ma określoną pojemność początkową i używa domyślnej wartości porównującej równość dla typu klucza.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy klucz w a <xref:System.Collections.Generic.Dictionary%602> musi być unikatowy zgodnie z domyślną wartością porównującą równość.  
  
 Pojemność <xref:System.Collections.Generic.Dictionary%602> jest liczbą elementów, które można dodać <xref:System.Collections.Generic.Dictionary%602> do obiektu przed zmianą. Gdy elementy są dodawane do <xref:System.Collections.Generic.Dictionary%602>, pojemność jest automatycznie zwiększana zgodnie z wymaganiami przez ponowną alokację tablicy wewnętrznej.  
  
 Jeśli rozmiar kolekcji można oszacować, określenie początkowej pojemności eliminuje konieczność wykonywania wielu operacji zmiany rozmiaru podczas dodawania elementów do <xref:System.Collections.Generic.Dictionary%602>.  
  
 <xref:System.Collections.Generic.Dictionary%602>wymaga implementacji równości, aby określić, czy klucze są równe. Ten konstruktor używa domyślnej ogólnej porównującej równości, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType>. Jeśli typ `TKey` <xref:System.IEquatable%601?displayProperty=nameWithType> implementuje interfejs ogólny, domyślna funkcja porównująca równość używa tej implementacji. Alternatywnie można określić implementację <xref:System.Collections.Generic.IEqualityComparer%601> interfejsu generycznego przy użyciu konstruktora, który `comparer` akceptuje parametr.  
  
 Ten konstruktor jest operacją O (1).  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy słownik z początkową pojemnością 4 i wypełnia je 4 wpisami.  
  
 [!code-csharp[Generic.Dictionary.ctor_Int32#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.ctor_Int32/CS/source.cs#1)]
 [!code-vb[Generic.Dictionary.ctor_Int32#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.ctor_Int32/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" />jest mniejsza niż 0.</exception>
        <altmember cref="P:System.Collections.Generic.EqualityComparer`1.Default" />
        <altmember cref="T:System.IEquatable`1" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Dictionary (System.Collections.Generic.IDictionary&lt;TKey,TValue&gt; dictionary, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IDictionary`2&lt;!TKey, !TValue&gt; dictionary, class System.Collections.Generic.IEqualityComparer`1&lt;!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1},System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dictionary As IDictionary(Of TKey, TValue), comparer As IEqualityComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Dictionary(System::Collections::Generic::IDictionary&lt;TKey, TValue&gt; ^ dictionary, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt; : System.Collections.Generic.IDictionary&lt;'Key, 'Value&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt;" Usage="new System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt; (dictionary, comparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dictionary" Type="System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <param name="dictionary">Elementów <see cref="T:System.Collections.Generic.IDictionary`2" /> , których elementy są kopiowane do nowego <see cref="T:System.Collections.Generic.Dictionary`2" />.</param>
        <param name="comparer">Implementacja do użycia podczas porównywania kluczy lub <see langword="null" /> użycia wartości domyślnej <see cref="T:System.Collections.Generic.EqualityComparer`1" /> dla typu klucza. <see cref="T:System.Collections.Generic.IEqualityComparer`1" /></param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Collections.Generic.Dictionary`2" /> klasy, która zawiera elementy skopiowane z określonego <see cref="T:System.Collections.Generic.IDictionary`2" /> i używa określonego <see cref="T:System.Collections.Generic.IEqualityComparer`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Za pomocą tego konstruktora można używać nieuwzględniających wielkości liter porównujących ciągów dostarczonych <xref:System.StringComparer> przez klasę do tworzenia słowników z kluczami ciągów bez uwzględniania wielkości liter.  
  
 Każdy klucz w a <xref:System.Collections.Generic.Dictionary%602> musi być unikatowy zgodnie z określoną regułą porównującą; podobnie, każdy klucz w źródle `dictionary` musi również być unikatowy zgodnie z określoną regułą porównującą.  
  
> [!NOTE]
>  Na przykład powtarzające się klucze mogą wystąpić `comparer` , jeśli jest to jeden z niewrażliwych <xref:System.StringComparer> na wielkość liter, z których korzysta `dictionary` Klasa, i nie używa klucza porównania bez uwzględniania wielkości liter.  
  
 Początkowa pojemność nowego <xref:System.Collections.Generic.Dictionary%602> elementu jest wystarczająco duża, aby można było zawierać wszystkie elementy w `dictionary`.  
  
 <xref:System.Collections.Generic.Dictionary%602>wymaga implementacji równości, aby określić, czy klucze są równe. Jeśli `comparer` <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType>jest `null`, ten konstruktor używa domyślnej ogólnej porównującej równości,. Jeśli typ `TKey` <xref:System.IEquatable%601?displayProperty=nameWithType> implementuje interfejs ogólny, domyślna funkcja porównująca równość używa tej implementacji.  
  
 Ten konstruktor jest operacją o`n`(), gdzie `n` jest liczbą elementów w `dictionary`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, <xref:System.Collections.Generic.Dictionary%602.%23ctor%28System.Collections.Generic.IDictionary%7B%600%2C%601%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%600%7D%29> jak użyć konstruktora, aby <xref:System.Collections.Generic.Dictionary%602> zainicjować z nierozróżnianą wielkością liter posortowaną zawartość z innego słownika. Przykładowy <xref:System.Collections.Generic.SortedDictionary%602> kod tworzy plik z niezależną od wielkości liter i wypełnia go danymi w kolejności losowej, następnie <xref:System.Collections.Generic.SortedDictionary%602> przekazuje do <xref:System.Collections.Generic.Dictionary%602.%23ctor%28System.Collections.Generic.IDictionary%7B%600%2C%601%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%600%7D%29> konstruktora, wraz z nieuwzględniającą wielkością liter, tworzenie <xref:System.Collections.Generic.Dictionary%602> jest sortowany. Jest to przydatne, jeśli trzeba skompilować posortowany słownik, który w pewnym momencie stał się statyczny. Kopiowanie danych z programu <xref:System.Collections.Generic.SortedDictionary%602> do programu <xref:System.Collections.Generic.Dictionary%602> zwiększa szybkość pobierania.  
  
> [!NOTE]
>  Podczas tworzenia nowego słownika z użyciem funkcji porównującej bez uwzględniania wielkości liter i wypełniania wpisów ze słownika korzystającego z funkcji porównującej z rozróżnianiem wielkości liter, występuje wyjątek, jeśli słownik wejściowy ma klucze, które różnią się tylko wielkością liter.  
  
 [!code-csharp[Generic.Dictionary.ctor_IDicIEqC#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.ctor_IDicIEqC/CS/source.cs#1)]
 [!code-vb[Generic.Dictionary.ctor_IDicIEqC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.ctor_IDicIEqC/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="dictionary" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="dictionary" />zawiera co najmniej jeden zduplikowany klucz.</exception>
        <altmember cref="T:System.Collections.Generic.IDictionary`2" />
        <altmember cref="T:System.Collections.Generic.IEqualityComparer`1" />
        <altmember cref="P:System.Collections.Generic.EqualityComparer`1.Default" />
        <altmember cref="T:System.IEquatable`1" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Dictionary (System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt; collection, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt; collection, class System.Collections.Generic.IEqualityComparer`1&lt;!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IEnumerable(Of KeyValuePair(Of TKey, TValue)), comparer As IEqualityComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Dictionary(System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt; ^ collection, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt; : seq&lt;System.Collections.Generic.KeyValuePair&lt;'Key, 'Value&gt;&gt; * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt;" Usage="new System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt; (collection, comparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="collection">To be added.</param>
        <param name="comparer">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Dictionary (int capacity, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, class System.Collections.Generic.IEqualityComparer`1&lt;!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, comparer As IEqualityComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Dictionary(int capacity, System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt; : int * System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt;" Usage="new System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt; (capacity, comparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <param name="capacity">Początkowa liczba elementów, które <see cref="T:System.Collections.Generic.Dictionary`2" /> może zawierać.</param>
        <param name="comparer">Implementacja do użycia podczas porównywania kluczy lub <see langword="null" /> użycia wartości domyślnej <see cref="T:System.Collections.Generic.EqualityComparer`1" /> dla typu klucza. <see cref="T:System.Collections.Generic.IEqualityComparer`1" /></param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Collections.Generic.Dictionary`2" /> klasy, która jest pusta, ma określoną pojemność początkową i używa określonego <see cref="T:System.Collections.Generic.IEqualityComparer`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Za pomocą tego konstruktora można używać nieuwzględniających wielkości liter porównujących ciągów dostarczonych <xref:System.StringComparer> przez klasę do tworzenia słowników z kluczami ciągów bez uwzględniania wielkości liter.  
  
 Każdy klucz w a <xref:System.Collections.Generic.Dictionary%602> musi być unikatowy zgodnie z określoną regułą porównującą.  
  
 Pojemność <xref:System.Collections.Generic.Dictionary%602> jest liczbą elementów, które można dodać <xref:System.Collections.Generic.Dictionary%602> do obiektu przed zmianą. Gdy elementy są dodawane do <xref:System.Collections.Generic.Dictionary%602>, pojemność jest automatycznie zwiększana zgodnie z wymaganiami przez ponowną alokację tablicy wewnętrznej.  
  
 Jeśli rozmiar kolekcji można oszacować, określenie początkowej pojemności eliminuje konieczność wykonywania wielu operacji zmiany rozmiaru podczas dodawania elementów do <xref:System.Collections.Generic.Dictionary%602>.  
  
 <xref:System.Collections.Generic.Dictionary%602>wymaga implementacji równości, aby określić, czy klucze są równe. Jeśli `comparer` <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType>jest `null`, ten konstruktor używa domyślnej ogólnej porównującej równości,. Jeśli typ `TKey` <xref:System.IEquatable%601?displayProperty=nameWithType> implementuje interfejs ogólny, domyślna funkcja porównująca równość używa tej implementacji.  
  
 Ten konstruktor jest operacją O (1).  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy <xref:System.Collections.Generic.Dictionary%602> z pojemnością początkową 5 i funkcję porównującą bez uwzględniania wielkości liter dla bieżącej kultury. Przykład dodaje cztery elementy, niektóre z kluczami małych liter i niektóre z kluczami wielkich liter. Przykład próbuje dodać element z kluczem, który różni się od istniejącego klucza tylko w przypadku, przechwytuje wyjątek, a następnie wyświetla komunikat o błędzie. Na koniec przykład wyświetla elementy w słowniku.  
  
 [!code-csharp[Generic.Dictionary.ctor_Int32IEqC#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.ctor_Int32IEqC/CS/source.cs#1)]
 [!code-vb[Generic.Dictionary.ctor_Int32IEqC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.ctor_Int32IEqC/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" />jest mniejsza niż 0.</exception>
        <altmember cref="T:System.Collections.Generic.IEqualityComparer`1" />
        <altmember cref="P:System.Collections.Generic.EqualityComparer`1.Default" />
        <altmember cref="T:System.IEquatable`1" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Dictionary (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Dictionary(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt; : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt;" Usage="new System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt; (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="info">Obiekt zawierający informacje wymagane do <see cref="T:System.Collections.Generic.Dictionary`2" />serializacji. <see cref="T:System.Runtime.Serialization.SerializationInfo" /></param>
        <param name="context">Struktura zawierająca źródło i miejsce docelowe serializowanego strumienia skojarzonego <see cref="T:System.Collections.Generic.Dictionary`2" />z. <see cref="T:System.Runtime.Serialization.StreamingContext" /></param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Collections.Generic.Dictionary`2" /> klasy z serializowanych danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor jest wywoływany podczas deserializacji w celu odtworzenia obiektu przesyłanego za pośrednictwem strumienia. Aby uzyskać więcej informacji, zobacz [XML oraz serializacji protokołu SOAP](~/docs/standard/serialization/xml-and-soap-serialization.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="N:System.Runtime.Serialization" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (TKey key, TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(!TKey key, !TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.Add(`0,`1)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (key As TKey, value As TValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(TKey key, TValue value);" />
      <MemberSignature Language="F#" Value="abstract member Add : 'Key * 'Value -&gt; unit&#xA;override this.Add : 'Key * 'Value -&gt; unit" Usage="dictionary.Add (key, value)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.Add(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="key">Klucz elementu do dodania.</param>
        <param name="value">Wartość elementu do dodania. Wartość może być <see langword="null" /> dla typów referencyjnych.</param>
        <summary>Dodaje określony klucz i wartość do słownika.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można również użyć <xref:System.Collections.Generic.Dictionary%602.Item%2A> właściwości, aby dodać nowe elementy przez ustawienie wartości klucza, który nie istnieje <xref:System.Collections.Generic.Dictionary%602>w, na przykład `myCollection[myKey] = myValue` (w Visual Basic, `myCollection(myKey) = myValue`). Jeśli jednak określony klucz już istnieje w <xref:System.Collections.Generic.Dictionary%602>, <xref:System.Collections.Generic.Dictionary%602.Item%2A> ustawienie właściwości zastępuje starą wartość. Z kolei <xref:System.Collections.Generic.Dictionary%602.Add%2A> Metoda zgłasza wyjątek, jeśli wartość z określonym kluczem już istnieje.  
  
 Jeśli wartość <xref:System.Collections.Generic.Dictionary%602> właściwości jest już równa pojemności, pojemność jest zwiększana przez automatyczne ponowne przydzielanie tablicy wewnętrznej, a istniejące elementy są kopiowane do nowej tablicy przed dodaniem nowego elementu. <xref:System.Collections.Generic.Dictionary%602.Count%2A>  
  
 Klucz nie może być `null`, ale wartość może być, jeśli `TValue` jest typem referencyjnym.  
  
 Jeśli <xref:System.Collections.Generic.Dictionary%602.Count%2A> jest mniejsza niż pojemność, ta metoda zbliża się do operacji O (1). Jeśli pojemność musi być zwiększona w celu uwzględnienia nowego elementu, ta metoda jest operacją o`n`(), gdzie `n` is <xref:System.Collections.Generic.Dictionary%602.Count%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy puste <xref:System.Collections.Generic.Dictionary%602> ciągi z kluczami ciągu i <xref:System.Collections.Generic.Dictionary%602.Add%2A> używa metody do dodawania niektórych elementów. W przykładzie pokazano, że <xref:System.Collections.Generic.Dictionary%602.Add%2A> Metoda <xref:System.ArgumentException> zgłasza podczas próby dodania zduplikowanego klucza.  
  
 Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.Collections.Generic.Dictionary%602> klasy.  
  
 [!code-cpp[Generic.Dictionary#2](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.Dictionary/cpp/source.cpp#2)]
 [!code-csharp[Generic.Dictionary#2](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary/CS/source.cs#2)]
 [!code-vb[Generic.Dictionary#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Element z tym samym kluczem już istnieje w <see cref="T:System.Collections.Generic.Dictionary`2" />.</exception>
        <altmember cref="M:System.Collections.Generic.Dictionary`2.Remove(`0)" />
        <altmember cref="P:System.Collections.Generic.Dictionary`2.Item(`0)" />
        <altmember cref="M:System.Collections.Generic.IDictionary`2.Add(`0,`1)" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="dictionary.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Clear</InterfaceMember>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa wszystkie klucze i wartości z <see cref="T:System.Collections.Generic.Dictionary`2" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.Dictionary%602.Count%2A> Właściwość jest ustawiona na 0, a odwołania do innych obiektów z elementów kolekcji również są wydane. Pojemność pozostaje niezmieniona.  
  
 Ta metoda jest operacją o`n`(), gdzie `n` jest pojemnością słownika.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Comparer">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEqualityComparer&lt;TKey&gt; Comparer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEqualityComparer`1&lt;!TKey&gt; Comparer" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Dictionary`2.Comparer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Comparer As IEqualityComparer(Of TKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ Comparer { System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Comparer : System.Collections.Generic.IEqualityComparer&lt;'Key&gt;" Usage="System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt;.Comparer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEqualityComparer&lt;TKey&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> , która jest używana do określania równości kluczy dla słownika.</summary>
        <value>Ogólna implementacja interfejsu, która jest używana do określania równości kluczy dla bieżącej <see cref="T:System.Collections.Generic.Dictionary`2" /> i zapewniania wartości skrótu dla kluczy. <see cref="T:System.Collections.Generic.IEqualityComparer`1" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.Dictionary%602>wymaga implementacji równości, aby określić, czy klucze są równe. Można określić implementację <xref:System.Collections.Generic.IEqualityComparer%601> interfejsu generycznego za pomocą konstruktora, który `comparer` akceptuje parametr; Jeśli nie zostanie określony, zostanie użyta domyślna ogólna funkcja porównująca <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> równość.  
  
 Pobieranie wartości tej właściwości jest operacją O (1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainsKey">
      <MemberSignature Language="C#" Value="public bool ContainsKey (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ContainsKey(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.ContainsKey(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContainsKey (key As TKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ContainsKey(TKey key);" />
      <MemberSignature Language="F#" Value="abstract member ContainsKey : 'Key -&gt; bool&#xA;override this.ContainsKey : 'Key -&gt; bool" Usage="dictionary.ContainsKey key" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.ContainsKey(`0)</InterfaceMember>
        <InterfaceMember>M:System.Collections.Generic.IReadOnlyDictionary`2.ContainsKey(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Klucz, który ma zostać zlokalizowany w <see cref="T:System.Collections.Generic.Dictionary`2" />.</param>
        <summary>Określa, <see cref="T:System.Collections.Generic.Dictionary`2" /> czy zawiera określony klucz.</summary>
        <returns><see langword="true" />Jeśli zawiera element z określonym kluczem; w przeciwnym razie, <see langword="false" />. <see cref="T:System.Collections.Generic.Dictionary`2" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zbliża się do operacji O (1).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, <xref:System.Collections.Generic.Dictionary%602.ContainsKey%2A> jak używać metody do testowania, czy klucz istnieje przed <xref:System.Collections.Generic.Dictionary%602.Add%2A> wywołaniem metody. Pokazano również, jak używać <xref:System.Collections.Generic.Dictionary%602.TryGetValue%2A> metody do pobierania wartości, co jest wydajnym sposobem pobierania wartości, gdy program często próbuje klucze, które nie znajdują się w słowniku. Na koniec pokazuje najmniej wydajny sposób sprawdzenia, czy klucze istnieją, przy użyciu <xref:System.Collections.Generic.Dictionary%602.Item%2A> właściwości (indeksator w programie C#).  
  
 Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.Collections.Generic.Dictionary%602> klasy (`openWith` jest nazwą słownika użytego w tym przykładzie).  
  
 [!code-cpp[Generic.Dictionary#6](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.Dictionary/cpp/source.cpp#6)]
 [!code-csharp[Generic.Dictionary#6](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary/CS/source.cs#6)]
 [!code-vb[Generic.Dictionary#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary/VB/source.vb#6)]  
[!code-cpp[Generic.Dictionary#5](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.Dictionary/cpp/source.cpp#5)]
[!code-csharp[Generic.Dictionary#5](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary/CS/source.cs#5)]
[!code-vb[Generic.Dictionary#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary/VB/source.vb#5)]  
[!code-cpp[Generic.Dictionary#4](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.Dictionary/cpp/source.cpp#4)]
[!code-csharp[Generic.Dictionary#4](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary/CS/source.cs#4)]
[!code-vb[Generic.Dictionary#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" />jest <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.Dictionary`2.ContainsValue(`1)" />
      </Docs>
    </Member>
    <Member MemberName="ContainsValue">
      <MemberSignature Language="C#" Value="public bool ContainsValue (TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ContainsValue(!TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.ContainsValue(`1)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContainsValue (value As TValue) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ContainsValue(TValue value);" />
      <MemberSignature Language="F#" Value="member this.ContainsValue : 'Value -&gt; bool" Usage="dictionary.ContainsValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="value">Wartość, która ma zostać zlokalizowana w <see cref="T:System.Collections.Generic.Dictionary`2" />. Wartość może być <see langword="null" /> dla typów referencyjnych.</param>
        <summary>Określa, <see cref="T:System.Collections.Generic.Dictionary`2" /> czy zawiera konkretną wartość.</summary>
        <returns><see langword="true" />Jeśli zawiera element z określoną wartością; <see langword="false" />w przeciwnym razie. <see cref="T:System.Collections.Generic.Dictionary`2" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda określa równość przy użyciu domyślnej funkcji <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> porównującej `TValue`równość dla, typu wartości w słowniku.  
  
 Ta metoda przeprowadza wyszukiwanie liniowe; w związku z tym średni czas wykonywania jest proporcjonalny do <xref:System.Collections.Generic.Dictionary%602.Count%2A>. Oznacza to, że ta metoda jest operacją`n`o (), `n` gdzie <xref:System.Collections.Generic.Dictionary%602.Count%2A>is.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.Dictionary`2.ContainsKey(`0)" />
        <altmember cref="P:System.Collections.Generic.EqualityComparer`1.Default" />
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Dictionary`2.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt;.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyCollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę par klucz/wartość zawartych w <see cref="T:System.Collections.Generic.Dictionary`2" />.</summary>
        <value>Liczba par klucz/wartość zawartych w <see cref="T:System.Collections.Generic.Dictionary`2" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pojemność a to liczba <xref:System.Collections.Generic.Dictionary%602> elementów <xref:System.Collections.Generic.Dictionary%602> , które mogą być przechowywane. Właściwość jest liczbą elementów, które faktycznie znajdują się <xref:System.Collections.Generic.Dictionary%602>w. <xref:System.Collections.Generic.Dictionary%602.Count%2A>  
  
 Pojemność jest zawsze większa lub równa <xref:System.Collections.Generic.Dictionary%602.Count%2A>. Jeśli <xref:System.Collections.Generic.Dictionary%602.Count%2A> przekracza pojemność podczas dodawania elementów, wydajność jest zwiększana przez automatyczne ponowne przydzielanie tablicy wewnętrznej przed skopiowaniem starych elementów i dodaniem nowych elementów.  
  
 Pobieranie wartości tej właściwości jest operacją O (1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnsureCapacity">
      <MemberSignature Language="C#" Value="public int EnsureCapacity (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EnsureCapacity(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.EnsureCapacity(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function EnsureCapacity (capacity As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EnsureCapacity(int capacity);" />
      <MemberSignature Language="F#" Value="member this.EnsureCapacity : int -&gt; int" Usage="dictionary.EnsureCapacity capacity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="capacity">Liczba wpisów.</param>
        <summary>Zapewnia, że słownik może przechowywać maksymalnie określoną liczbę wpisów bez dalszej ekspansji magazynu zapasowego.</summary>
        <returns>Bieżąca pojemność <see cref="T:System.Collections.Generic.Dictionary`2" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" />jest mniejsza niż 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.Dictionary&lt;TKey,TValue&gt;.Enumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Collections.Generic.Dictionary`2/Enumerator&lt;!TKey, !TValue&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As Dictionary(Of TKey, TValue).Enumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::Dictionary&lt;TKey, TValue&gt;::Enumerator GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt;.Enumerator" Usage="dictionary.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Dictionary&lt;TKey,TValue&gt;+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca moduł wyliczający, który wykonuje iterację przez <see cref="T:System.Collections.Generic.Dictionary`2" />.</summary>
        <returns><see cref="T:System.Collections.Generic.Dictionary`2.Enumerator" /> Struktura<see cref="T:System.Collections.Generic.Dictionary`2" />dla.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na potrzeby wyliczenia każdy element jest <xref:System.Collections.Generic.KeyValuePair%602> strukturą reprezentującą wartość i jej klucz.  
  
 `foreach` Instrukcja C# języka(`for each` C++w VisualBasic)ukrywazłożonośćmodułówwyliczających.`For Each` W związku z `foreach` tym zaleca się użycie zamiast bezpośredniego manipulowania modułem wyliczającym.  
  
 Moduły wyliczające mogą służyć do odczytu danych w kolekcji, ale nie można za ich pomocą modyfikować kolekcji źródłowej.  
  
 Początkowo moduł wyliczający jest umieszczony przed pierwszym elementem w kolekcji. W tym miejscu <xref:System.Collections.Generic.Dictionary%602.Enumerator.Current%2A> nie jest zdefiniowane. Należy wywołać <xref:System.Collections.Generic.Dictionary%602.Enumerator.MoveNext%2A> metodę, aby wykonać wymuszanie do pierwszego elementu kolekcji przed odczytem <xref:System.Collections.Generic.Dictionary%602.Enumerator.Current%2A>wartości.  
  
 Właściwość zwraca ten sam element <xref:System.Collections.Generic.Dictionary%602.Enumerator.MoveNext%2A> do momentu wywołania metody. <xref:System.Collections.Generic.Dictionary%602.Enumerator.Current%2A> <xref:System.Collections.Generic.Dictionary%602.Enumerator.MoveNext%2A>ustawia <xref:System.Collections.Generic.Dictionary%602.Enumerator.Current%2A> do następnego elementu.  
  
 Jeśli <xref:System.Collections.Generic.Dictionary%602.Enumerator.MoveNext%2A> przekazuje koniec kolekcji, moduł wyliczający jest umieszczony po ostatnim elemencie w kolekcji i <xref:System.Collections.Generic.Dictionary%602.Enumerator.MoveNext%2A> zwraca `false`. Gdy moduł wyliczający znajduje się w tym miejscu, kolejne <xref:System.Collections.Generic.Dictionary%602.Enumerator.MoveNext%2A> wywołania również `false`zwracają. Jeśli ostatnie wywołanie <xref:System.Collections.Generic.Dictionary%602.Enumerator.MoveNext%2A> zwrócone `false`, <xref:System.Collections.Generic.Dictionary%602.Enumerator.Current%2A> nie jest zdefiniowane. Nie można ponownie <xref:System.Collections.Generic.Dictionary%602.Enumerator.Current%2A> ustawić na pierwszy element kolekcji; zamiast tego należy utworzyć nowe wystąpienie modułu wyliczającego.  
  
 Moduł wyliczający zachowuje ważność tak długo, jak długo kolekcja pozostaje niezmieniona. Jeśli w kolekcji zostaną wprowadzone zmiany, takie jak dodanie, zmodyfikowanie lub usunięcie elementów, moduł wyliczający jest nieodwracalnie unieważniony i następne wywołanie <xref:System.Collections.Generic.Dictionary%602.Enumerator.MoveNext%2A> lub <xref:System.Collections.Generic.Dictionary%602.Enumerator.System%23Collections%23IEnumerator%23Reset%2A> wygeneruje <xref:System.InvalidOperationException>.  
  
 Moduł wyliczający nie ma wyłącznego dostępu do kolekcji, w związku z tym wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość. Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania.  Aby zezwolić wielu wątkom na dostęp do kolekcji w celu odczytu i zapisu danych, należy zaimplementować własny mechanizm synchronizacji.  
  
 Domyślne implementacje kolekcji w <xref:System.Collections.Generic?displayProperty=nameWithType> przestrzeni nazw nie są zsynchronizowane.  
  
 Ta metoda jest operacją O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.Dictionary`2.Enumerator" />
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="dictionary.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="info">Obiekt, który zawiera informacje wymagane do <see cref="T:System.Collections.Generic.Dictionary`2" /> serializacji wystąpienia. <see cref="T:System.Runtime.Serialization.SerializationInfo" /></param>
        <param name="context">Struktura, która zawiera źródło i miejsce docelowe serializowanego strumienia skojarzonego <see cref="T:System.Collections.Generic.Dictionary`2" /> z wystąpieniem. <see cref="T:System.Runtime.Serialization.StreamingContext" /></param>
        <summary>Implementuje interfejs i zwraca dane, które są konieczne do <see cref="T:System.Collections.Generic.Dictionary`2" /> serializacji wystąpienia. <see cref="T:System.Runtime.Serialization.ISerializable" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest operacją o`n`(), gdzie `n` is <xref:System.Collections.Generic.Dictionary%602.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="info" />jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">w celu świadczenia usług serializacji. Skojarzone Wyliczenie:   <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" />Akcja zabezpieczeń:<see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
        <altmember cref="M:System.Collections.Generic.Dictionary`2.OnDeserialization(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public TValue this[TKey key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !TValue Item(!TKey)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Dictionary`2.Item(`0)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Item(key As TKey) As TValue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TValue default[TKey] { TValue get(TKey key); void set(TKey key, TValue value); };" />
      <MemberSignature Language="F#" Value="member this.Item('Key) : 'Value with get, set" Usage="System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt;.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IDictionary`2.Item(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Klucz wartości do pobrania lub ustawienia.</param>
        <summary>Pobiera lub ustawia wartość skojarzoną z określonym kluczem.</summary>
        <value>Wartość skojarzona z określonym kluczem. Jeśli określony klucz nie zostanie znaleziony, operacja get zgłasza <see cref="T:System.Collections.Generic.KeyNotFoundException" />, a operacja Set tworzy nowy element z określonym kluczem.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zapewnia możliwość dostępu do określonego elementu w kolekcji przy użyciu następującej C# składni: `myCollection[key]` (`myCollection(key)` w Visual Basic).  
  
 Można również użyć <xref:System.Collections.Generic.Dictionary%602.Item%2A> właściwości, aby dodać nowe elementy przez ustawienie wartości klucza, który nie istnieje <xref:System.Collections.Generic.Dictionary%602>w. Po ustawieniu wartości właściwości, jeśli klucz znajduje się w <xref:System.Collections.Generic.Dictionary%602>, wartość skojarzona z tym kluczem jest zastępowana przez przypisaną wartość. Jeśli klucz nie znajduje się w <xref:System.Collections.Generic.Dictionary%602>, klucz i wartość są dodawane do słownika. Z kolei <xref:System.Collections.Generic.Dictionary%602.Add%2A> Metoda nie modyfikuje istniejących elementów.  
  
 Klucz nie może być `null`, ale wartość może być, jeśli typem `TValue` wartości jest typ referencyjny.  
  
 C# Język używa [`this`](~/docs/csharp/language-reference/keywords/this.md) słowa kluczowego do definiowania indeksatorów <xref:System.Collections.Generic.Dictionary%602.Item%2A> zamiast implementowania właściwości. Visual Basic implementuje <xref:System.Collections.Generic.Dictionary%602.Item%2A> jako właściwość domyślną, która zapewnia te same funkcje indeksowania.  
  
 Pobieranie lub Ustawianie wartości tej właściwości zbliża się do operacji O (1).  
  
   
  
## Examples  
 Poniższy przykład kodu używa <xref:System.Collections.Generic.Dictionary%602.Item%2A> właściwości (indeksator w C#) do pobierania wartości, <xref:System.Collections.Generic.KeyNotFoundException> pokazując, że jest zgłaszane, gdy żądany klucz nie jest obecny i pokazuje, że wartość skojarzona z kluczem może zostać zamieniona.  
  
 W przykładzie pokazano również, jak używać <xref:System.Collections.Generic.Dictionary%602.TryGetValue%2A> metody jako wydajniejszego sposobu pobierania wartości, jeśli program często musi wypróbować wartości klucza, które nie znajdują się w słowniku.  
  
 Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.Collections.Generic.Dictionary%602> klasy. `openWith`jest nazwą słownika użytego w tym przykładzie.  
  
 [!code-cpp[Generic.Dictionary#2](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.Dictionary/cpp/source.cpp#2)]
 [!code-csharp[Generic.Dictionary#2](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary/CS/source.cs#2)]
 [!code-vb[Generic.Dictionary#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary/VB/source.vb#2)]  
[!code-cpp[Generic.Dictionary#3](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.Dictionary/cpp/source.cpp#3)]
[!code-csharp[Generic.Dictionary#3](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary/CS/source.cs#3)]
[!code-vb[Generic.Dictionary#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary/VB/source.vb#3)]  
[!code-cpp[Generic.Dictionary#4](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.Dictionary/cpp/source.cpp#4)]
[!code-csharp[Generic.Dictionary#4](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary/CS/source.cs#4)]
[!code-vb[Generic.Dictionary#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary/VB/source.vb#4)]  
[!code-cpp[Generic.Dictionary#5](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.Dictionary/cpp/source.cpp#5)]
[!code-csharp[Generic.Dictionary#5](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary/CS/source.cs#5)]
[!code-vb[Generic.Dictionary#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Collections.Generic.KeyNotFoundException">Właściwość jest pobierana i <paramref name="key" /> nie istnieje w kolekcji.</exception>
        <altmember cref="M:System.Collections.Generic.Dictionary`2.Add(`0,`1)" />
      </Docs>
    </Member>
    <Member MemberName="Keys">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.Dictionary&lt;TKey,TValue&gt;.KeyCollection Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.Dictionary`2/KeyCollection&lt;!TKey, !TValue&gt; Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Dictionary`2.Keys" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Keys As Dictionary(Of TKey, TValue).KeyCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::Dictionary&lt;TKey, TValue&gt;::KeyCollection ^ Keys { System::Collections::Generic::Dictionary&lt;TKey, TValue&gt;::KeyCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Keys : System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt;.KeyCollection" Usage="System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt;.Keys" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Dictionary&lt;TKey,TValue&gt;+KeyCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję zawierającą klucze z <see cref="T:System.Collections.Generic.Dictionary`2" />.</summary>
        <value><see cref="T:System.Collections.Generic.Dictionary`2.KeyCollection" /> Zawierający klucze <see cref="T:System.Collections.Generic.Dictionary`2" />w.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kolejność kluczy w <xref:System.Collections.Generic.Dictionary%602.KeyCollection> elemencie jest nieokreślona, ale jest to taka sama kolejność, jak skojarzone wartości <xref:System.Collections.Generic.Dictionary%602.ValueCollection> w zwracanym przez <xref:System.Collections.Generic.Dictionary%602.Values%2A> właściwość.  
  
 Zwracana <xref:System.Collections.Generic.Dictionary%602.KeyCollection> wartość nie jest kopią statyczną; zamiast tego <xref:System.Collections.Generic.Dictionary%602.KeyCollection> odwołuje się do kluczy w oryginalnym <xref:System.Collections.Generic.Dictionary%602>. W związku z tym zmiany <xref:System.Collections.Generic.Dictionary%602> w dalszym ciągu zostaną odzwierciedlone w. <xref:System.Collections.Generic.Dictionary%602.KeyCollection>  
  
 Pobieranie wartości tej właściwości jest operacją O (1).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak wyliczyć klucze w słowniku przy użyciu <xref:System.Collections.Generic.Dictionary%602.Keys%2A> właściwości oraz jak wyliczyć klucze i wartości w słowniku.  
  
 Ten kod jest częścią większego przykładu, który można skompilować i wykonać (`openWith` jest nazwą słownika użytego w tym przykładzie). Zobacz <xref:System.Collections.Generic.Dictionary%602>.  
  
 [!code-cpp[Generic.Dictionary#9](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.Dictionary/cpp/source.cpp#9)]
 [!code-csharp[Generic.Dictionary#9](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary/CS/source.cs#9)]
 [!code-vb[Generic.Dictionary#9](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary/VB/source.vb#9)]  
[!code-cpp[Generic.Dictionary#7](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.Dictionary/cpp/source.cpp#7)]
[!code-csharp[Generic.Dictionary#7](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary/CS/source.cs#7)]
[!code-vb[Generic.Dictionary#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.Dictionary`2.KeyCollection" />
        <altmember cref="P:System.Collections.Generic.Dictionary`2.Values" />
      </Docs>
    </Member>
    <Member MemberName="OnDeserialization">
      <MemberSignature Language="C#" Value="public virtual void OnDeserialization (object sender);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnDeserialization(object sender) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.OnDeserialization(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub OnDeserialization (sender As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void OnDeserialization(System::Object ^ sender);" />
      <MemberSignature Language="F#" Value="abstract member OnDeserialization : obj -&gt; unit&#xA;override this.OnDeserialization : obj -&gt; unit" Usage="dictionary.OnDeserialization sender" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="sender">Źródło zdarzenia deserializacji.</param>
        <summary><see cref="T:System.Runtime.Serialization.ISerializable" /> Implementuje interfejs i wywołuje zdarzenie deserializacji po zakończeniu deserializacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest operacją o`n`(), gdzie `n` is <xref:System.Collections.Generic.Dictionary%602.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Serialization.SerializationException">Obiekt skojarzony z bieżącym <see cref="T:System.Collections.Generic.Dictionary`2" /> wystąpieniem jest nieprawidłowy. <see cref="T:System.Runtime.Serialization.SerializationInfo" /></exception>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
        <altmember cref="M:System.Collections.Generic.Dictionary`2.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (key As TKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Remove(TKey key);" />
      <MemberSignature Language="F#" Value="abstract member Remove : 'Key -&gt; bool&#xA;override this.Remove : 'Key -&gt; bool" Usage="dictionary.Remove key" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Klucz elementu do usunięcia.</param>
        <summary>Usuwa wartość z określonym kluczem z <see cref="T:System.Collections.Generic.Dictionary`2" />.</summary>
        <returns><see langword="true" />Jeśli element zostanie pomyślnie znaleziony i usunięty; w przeciwnym razie. <see langword="false" />  Ta metoda zwraca <see langword="false" /> wartość <paramref name="key" /> , <see cref="T:System.Collections.Generic.Dictionary`2" />Jeśli nie została znaleziona w.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nie zawiera elementu z określonym kluczem <xref:System.Collections.Generic.Dictionary%602> , pozostaje niezmieniona. <xref:System.Collections.Generic.Dictionary%602> Nie zgłoszono żadnego wyjątku.  
  
 Ta metoda zbliża się do operacji O (1).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak usunąć parę klucz/wartość ze słownika przy użyciu <xref:System.Collections.Generic.Dictionary%602.Remove%2A> metody.  
  
 Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.Collections.Generic.Dictionary%602> klasy (`openWith` jest nazwą słownika użytego w tym przykładzie).  
  
 [!code-cpp[Generic.Dictionary#10](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.Dictionary/cpp/source.cpp#10)]
 [!code-csharp[Generic.Dictionary#10](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary/CS/source.cs#10)]
 [!code-vb[Generic.Dictionary#10](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" />jest <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.Dictionary`2.Add(`0,`1)" />
        <altmember cref="M:System.Collections.Generic.IDictionary`2.Remove(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (TKey key, out TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Remove(!TKey key, [out] !TValue&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.Remove(`0,`1@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (key As TKey, ByRef value As TValue) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Remove(TKey key, [Runtime::InteropServices::Out] TValue % value);" />
      <MemberSignature Language="F#" Value="member this.Remove : 'Key *  -&gt; bool" Usage="dictionary.Remove (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="TValue" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Add">
      <MemberSignature Language="C#" Value="void ICollection&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.Add (System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt; keyValuePair);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Add(valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt; keyValuePair) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#Add(System.Collections.Generic.KeyValuePair{`0,`1})" />
      <MemberSignature Language="VB.NET" Value="Sub Add (keyValuePair As KeyValuePair(Of TKey, TValue)) Implements ICollection(Of KeyValuePair(Of TKey, TValue)).Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Add(System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt; keyValuePair) = System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyValuePair" Type="System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;" />
      </Parameters>
      <Docs>
        <param name="keyValuePair">Struktura reprezentująca klucz i wartość, które mają zostać dodane <see cref="T:System.Collections.Generic.Dictionary`2" />do. <see cref="T:System.Collections.Generic.KeyValuePair`2" /></param>
        <summary>Dodaje określoną wartość do <see cref="T:System.Collections.Generic.ICollection`1" /> podanego klucza.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Klucz <paramref name="keyValuePair" /> ma wartość <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Element z tym samym kluczem już istnieje w <see cref="T:System.Collections.Generic.Dictionary`2" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Contains">
      <MemberSignature Language="C#" Value="bool ICollection&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.Contains (System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt; keyValuePair);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Contains(valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt; keyValuePair) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#Contains(System.Collections.Generic.KeyValuePair{`0,`1})" />
      <MemberSignature Language="VB.NET" Value="Function Contains (keyValuePair As KeyValuePair(Of TKey, TValue)) As Boolean Implements ICollection(Of KeyValuePair(Of TKey, TValue)).Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Contains(System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt; keyValuePair) = System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyValuePair" Type="System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;" />
      </Parameters>
      <Docs>
        <param name="keyValuePair">Struktura, która ma zostać zlokalizowana <see cref="T:System.Collections.Generic.ICollection`1" />w. <see cref="T:System.Collections.Generic.KeyValuePair`2" /></param>
        <summary>Określa, <see cref="T:System.Collections.Generic.ICollection`1" /> czy zawiera określony klucz i wartość.</summary>
        <returns><see langword="true" />Jeśli <paramref name="keyValuePair" /> znajduje się <see cref="T:System.Collections.Generic.ICollection`1" />w; w przeciwnym razie <see langword="false" />,.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.CopyTo (System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;[] array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.CopyTo(valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;[] array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Sub CopyTo (array As KeyValuePair(Of TKey, TValue)(), index As Integer) Implements ICollection(Of KeyValuePair(Of TKey, TValue)).CopyTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.CopyTo(cli::array &lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt; ^ array, int index) = System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;::CopyTo;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;[]" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Tablica Jednowymiarowa typu <see cref="T:System.Collections.Generic.KeyValuePair`2" /> , który jest miejscem docelowym <see cref="T:System.Collections.Generic.KeyValuePair`2" /> elementów skopiowanych z <see cref="T:System.Collections.Generic.ICollection`1" />. Tablica musi mieć indeksowane zaczynające od zera.</param>
        <param name="index">Indeks (liczony od zera) <paramref name="array" /> , w którym rozpoczyna się kopiowanie.</param>
        <summary>Kopiuje elementy <see cref="T:System.Collections.Generic.ICollection`1" /> do tablicy typu <see cref="T:System.Collections.Generic.KeyValuePair`2" />, rozpoczynając od określonego indeksu tablicy.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />jest mniejsza niż 0.</exception>
        <exception cref="T:System.ArgumentException">Liczba elementów w źródle <see cref="T:System.Collections.Generic.ICollection`1" /> jest większa niż dostępne miejsce od <paramref name="index" /> do końca miejsca docelowego <paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Dictionary`2.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements ICollection(Of KeyValuePair(Of TKey, TValue)).IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey,TValue&gt;&gt;::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy słownik jest tylko do odczytu.</summary>
        <value><see langword="true" />Jeśli jest <see cref="T:System.Collections.Generic.ICollection`1" /> tylko do odczytu; <see langword="false" />w przeciwnym razie. W domyślnej implementacji programu <see cref="T:System.Collections.Generic.Dictionary`2" />ta właściwość zawsze zwraca wartość. <see langword="false" /></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Remove">
      <MemberSignature Language="C#" Value="bool ICollection&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.Remove (System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt; keyValuePair);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Remove(valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt; keyValuePair) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.System#Collections#Generic#ICollection&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#Remove(System.Collections.Generic.KeyValuePair{`0,`1})" />
      <MemberSignature Language="VB.NET" Value="Function Remove (keyValuePair As KeyValuePair(Of TKey, TValue)) As Boolean Implements ICollection(Of KeyValuePair(Of TKey, TValue)).Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.Remove(System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt; keyValuePair) = System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyValuePair" Type="System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;" />
      </Parameters>
      <Docs>
        <param name="keyValuePair">Struktura reprezentująca klucz i wartość, które mają zostać usunięte <see cref="T:System.Collections.Generic.Dictionary`2" />z. <see cref="T:System.Collections.Generic.KeyValuePair`2" /></param>
        <summary>Usuwa klucz i wartość ze słownika.</summary>
        <returns><see langword="true" />Jeśli klucz i wartość reprezentowane przez <paramref name="keyValuePair" /> programu zostały pomyślnie znalezione i usunięte; w przeciwnym razie,. <see langword="false" /> Ta metoda zwraca <see langword="false" /> wartość <paramref name="keyValuePair" /> , <see cref="T:System.Collections.Generic.ICollection`1" />Jeśli nie została znaleziona w.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Keys">
      <MemberSignature Language="C#" Value="System.Collections.Generic.ICollection&lt;TKey&gt; System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;!TKey&gt; System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Dictionary`2.System#Collections#Generic#IDictionary&lt;TKey,TValue&gt;#Keys" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Keys As ICollection(Of TKey) Implements IDictionary(Of TKey, TValue).Keys" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::Generic::ICollection&lt;TKey&gt; ^ System::Collections::Generic::IDictionary&lt;TKey,TValue&gt;::Keys { System::Collections::Generic::ICollection&lt;TKey&gt; ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Keys" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IDictionary`2.Keys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;TKey&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera zawierający klucze <see cref="T:System.Collections.Generic.IDictionary`2" />. <see cref="T:System.Collections.Generic.ICollection`1" /></summary>
        <value><see cref="T:System.Collections.Generic.ICollection`1" /> Typ<paramref name="TKey" />zawierającyklucze elementu .<see cref="T:System.Collections.Generic.IDictionary`2" /></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Values">
      <MemberSignature Language="C#" Value="System.Collections.Generic.ICollection&lt;TValue&gt; System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;!TValue&gt; System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Dictionary`2.System#Collections#Generic#IDictionary&lt;TKey,TValue&gt;#Values" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Values As ICollection(Of TValue) Implements IDictionary(Of TKey, TValue).Values" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::Generic::ICollection&lt;TValue&gt; ^ System::Collections::Generic::IDictionary&lt;TKey,TValue&gt;::Values { System::Collections::Generic::ICollection&lt;TValue&gt; ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;.Values" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IDictionary`2.Values</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;TValue&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera zawierający wartości z <see cref="T:System.Collections.Generic.IDictionary`2" />. <see cref="T:System.Collections.Generic.ICollection`1" /></summary>
        <value><see cref="T:System.Collections.Generic.ICollection`1" /> Typu<paramref name="TValue" />zawierającegowartości w .<see cref="T:System.Collections.Generic.IDictionary`2" /></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt; IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt; System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.System#Collections#Generic#IEnumerable&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of KeyValuePair(Of TKey, TValue)) Implements IEnumerable(Of KeyValuePair(Of TKey, TValue)).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt; ^ System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca moduł wyliczający, który dokonuje iteracji w kolekcji.</summary>
        <returns>Moduł wyliczający, który może być używany do iteracji kolekcji.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Keys">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;TKey&gt; System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;!TKey&gt; System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Dictionary`2.System#Collections#Generic#IReadOnlyDictionary&lt;TKey,TValue&gt;#Keys" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Keys As IEnumerable(Of TKey) Implements IReadOnlyDictionary(Of TKey, TValue).Keys" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::Generic::IEnumerable&lt;TKey&gt; ^ System::Collections::Generic::IReadOnlyDictionary&lt;TKey,TValue&gt;::Keys { System::Collections::Generic::IEnumerable&lt;TKey&gt; ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Keys" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyDictionary`2.Keys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TKey&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję zawierającą klucze <see cref="T:System.Collections.Generic.IReadOnlyDictionary`2" />.</summary>
        <value>Kolekcja zawierająca klucze <see cref="T:System.Collections.Generic.IReadOnlyDictionary`2" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Values">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerable&lt;TValue&gt; System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;!TValue&gt; System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Dictionary`2.System#Collections#Generic#IReadOnlyDictionary&lt;TKey,TValue&gt;#Values" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Values As IEnumerable(Of TValue) Implements IReadOnlyDictionary(Of TKey, TValue).Values" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::Generic::IEnumerable&lt;TValue&gt; ^ System::Collections::Generic::IReadOnlyDictionary&lt;TKey,TValue&gt;::Values { System::Collections::Generic::IEnumerable&lt;TValue&gt; ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;.Values" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyDictionary`2.Values</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TValue&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję zawierającą wartości <see cref="T:System.Collections.Generic.IReadOnlyDictionary`2" />.</summary>
        <value>Kolekcja zawierająca wartości <see cref="T:System.Collections.Generic.IReadOnlyDictionary`2" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int index) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Jednowymiarowa tablica, która jest miejscem docelowym elementów skopiowanych z <see cref="T:System.Collections.Generic.ICollection`1" />. Tablica musi mieć indeksowane zaczynające od zera.</param>
        <param name="index">Indeks (liczony od zera) <paramref name="array" /> , w którym rozpoczyna się kopiowanie.</param>
        <summary>Kopiuje elementy <see cref="T:System.Collections.Generic.ICollection`1" /> do tablicy, rozpoczynając od określonego indeksu tablicy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy element skopiowany z programu <xref:System.Collections.Generic.Dictionary%602> <xref:System.Collections.Generic.KeyValuePair%602> jest strukturą reprezentującą wartość i jej klucz.  
  
> [!NOTE]
>  Jeśli nie można automatycznie rzutować <xref:System.Collections.ICollection> typu źródła na typ docelowy `array`, <xref:System.InvalidCastException>nieogólne implementacje <xref:System.Collections.ICollection.CopyTo%2A?displayProperty=nameWithType> throw a, podczas gdy implementacje ogólne generują <xref:System.ArgumentException>.  
  
 Ta metoda jest operacją o`n`(), gdzie `n` is <xref:System.Collections.Generic.Dictionary%602.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />jest mniejsza niż 0.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="array" />jest wielowymiarowych.  
  
—lub— 
 <paramref name="array" />nie ma indeksowania opartego na zero.  
  
—lub— 
Liczba elementów w źródle <see cref="T:System.Collections.Generic.ICollection`1" /> jest większa niż dostępne miejsce od <paramref name="index" /> do końca miejsca docelowego <paramref name="array" />.  
  
—lub— 
Nie można automatycznie rzutować <see cref="T:System.Collections.Generic.ICollection`1" /> typu źródła na typ docelowy. <paramref name="array" /></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Dictionary`2.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy dostęp do <see cref="T:System.Collections.ICollection" /> elementu jest synchronizowany (bezpieczny wątkowo).</summary>
        <value><see langword="true" />Jeśli dostęp do programu <see cref="T:System.Collections.ICollection" /> jest synchronizowany (wątek bezpieczny); <see langword="false" />w przeciwnym razie.  W domyślnej implementacji programu <see cref="T:System.Collections.Generic.Dictionary`2" />ta właściwość zawsze zwraca wartość. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślne implementacje kolekcji w <xref:System.Collections.Generic?displayProperty=nameWithType> przestrzeni nazw nie są zsynchronizowane.  
  
 Wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość. Nawet w przypadku synchronizacji kolekcji inne wątki mogą nadal modyfikować kolekcję, co może spowodować zgłoszenie wyjątku przez moduł wyliczający. Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania albo rejestrować wyjątki wynikłe ze zmian wprowadzanych przez inne wątków.  
  
 Właściwość zwraca obiekt, którego można użyć do synchronizowania dostępu <xref:System.Collections.ICollection>do. <xref:System.Collections.ICollection.SyncRoot%2A> Synchronizacja jest skuteczna tylko wtedy, gdy wszystkie wątki blokują obiekt przed uzyskaniem dostępu do kolekcji.  
  
 Pobieranie wartości tej właściwości jest operacją O (1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Dictionary`2.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera obiekt, który może służyć do synchronizowania dostępu do <see cref="T:System.Collections.ICollection" />.</summary>
        <value>Obiekt, który może służyć do synchronizowania dostępu do <see cref="T:System.Collections.ICollection" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślne implementacje kolekcji w <xref:System.Collections.Generic?displayProperty=nameWithType> przestrzeni nazw nie są zsynchronizowane.  
  
 Wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość.  Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania.  Aby zezwolić wielu wątkom na dostęp do kolekcji w celu odczytu i zapisu danych, należy zaimplementować własny mechanizm synchronizacji.  
  
 Właściwość zwraca obiekt, którego można użyć do synchronizowania dostępu <xref:System.Collections.ICollection>do. <xref:System.Collections.ICollection.SyncRoot%2A> Synchronizacja jest skuteczna tylko wtedy, gdy wszystkie wątki blokują obiekt przed uzyskaniem dostępu do kolekcji. Poniższy kod przedstawia użycie <xref:System.Collections.ICollection.SyncRoot%2A> właściwości dla C#, C++i Visual Basic.  
  
```csharp  
ICollection ic = ...;  
lock (ic.SyncRoot) {  
   // Access the collection.  
}  
```  
  
```vb  
Dim ic As ICollection = ...  
SyncLock ic.SyncRoot  
   ' Access the collection.  
End SyncLock  
```  
  
```cpp#  
ICollection^ ic = ...;  
try {  
   Monitor::Enter(ic->SyncRoot);  
   // Access the collection.  
}  
finally {  
   Monitor::Exit(ic->SyncRoot);  
}  
```  
  
 Pobieranie wartości tej właściwości jest operacją O (1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ICollection.IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Add">
      <MemberSignature Language="C#" Value="void IDictionary.Add (object key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IDictionary.Add(object key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.System#Collections#IDictionary#Add(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Add (key As Object, value As Object) Implements IDictionary.Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IDictionary.Add(System::Object ^ key, System::Object ^ value) = System::Collections::IDictionary::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Add(System.Object,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Obiekt, który ma być używany jako klucz.</param>
        <param name="value">Obiekt, który ma być używany jako wartość.</param>
        <summary>Dodaje określony klucz i wartość do słownika.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można również użyć <xref:System.Collections.IDictionary.Item%2A> właściwości, aby dodać nowe elementy przez ustawienie wartości klucza, który nie istnieje w słowniku, na `myCollection["myNonexistentKey"] = myValue`przykład. Jeśli jednak określony klucz już istnieje w słowniku, ustawienie <xref:System.Collections.IDictionary.Item%2A> właściwości zastępuje starą wartość. Z kolei <xref:System.Collections.IDictionary.Add%2A> Metoda zgłasza wyjątek, jeśli określony klucz już istnieje.  
  
 Jeśli <xref:System.Collections.Generic.Dictionary%602.Count%2A> jest mniejsza niż pojemność, ta metoda zbliża się do operacji O (1). Jeśli pojemność musi zostać zwiększona w celu uwzględnienia nowego elementu, ta metoda będzie operacją o (`n`), gdzie `n` is <xref:System.Collections.Generic.Dictionary%602.Count%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, <xref:System.Collections.Generic.Dictionary%602> jak uzyskać dostęp do klasy <xref:System.Collections.IDictionary?displayProperty=nameWithType> za pomocą interfejsu. Przykładowy kod tworzy puste <xref:System.Collections.Generic.Dictionary%602> ciągi z kluczami ciągu i <xref:System.Collections.Generic.Dictionary%602.System%23Collections%23IDictionary%23Add%2A> używa metody do dodawania niektórych elementów. W przykładzie pokazano, że <xref:System.Collections.Generic.Dictionary%602.System%23Collections%23IDictionary%23Add%2A> Metoda <xref:System.ArgumentException> zgłasza podczas próby dodania zduplikowanego klucza lub gdy podano klucz lub wartość błędnego typu danych.  
  
 Przykład kodu demonstruje użycie kilku innych elementów członkowskich <xref:System.Collections.IDictionary?displayProperty=nameWithType> interfejsu.  
  
 [!code-csharp[Generic.Dictionary.IDictionary#1](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.IDictionary/CS/source.cs#1)]
 [!code-vb[Generic.Dictionary.IDictionary#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.IDictionary/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="key" />jest typu, którego nie można przypisać do typu <paramref name="TKey" /> <see cref="T:System.Collections.Generic.Dictionary`2" />klucza.  
  
—lub— 
 <paramref name="value" />jest typu, którego nie można przypisać do <paramref name="TValue" />, typu wartości <see cref="T:System.Collections.Generic.Dictionary`2" />w.  
  
—lub— 
Wartość z tym samym kluczem już istnieje w <see cref="T:System.Collections.Generic.Dictionary`2" />.</exception>
        <altmember cref="P:System.Collections.IDictionary.Item(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Contains">
      <MemberSignature Language="C#" Value="bool IDictionary.Contains (object key);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IDictionary.Contains(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.System#Collections#IDictionary#Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Contains (key As Object) As Boolean Implements IDictionary.Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IDictionary.Contains(System::Object ^ key) = System::Collections::IDictionary::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Klucz, który ma zostać zlokalizowany w <see cref="T:System.Collections.IDictionary" />.</param>
        <summary>Określa, <see cref="T:System.Collections.IDictionary" /> czy zawiera element z określonym kluczem.</summary>
        <returns><see langword="true" />Jeśli zawiera element z określonym kluczem; w przeciwnym razie, <see langword="false" />. <see cref="T:System.Collections.IDictionary" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca `false` wartość `key` , jeśli jest typu, którego nie można przypisać do typu `TKey` <xref:System.Collections.Generic.Dictionary%602>klucza.  
  
 Ta metoda zbliża się do operacji O (1).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, <xref:System.Collections.Generic.Dictionary%602.System%23Collections%23IDictionary%23Contains%2A> jak używać metody <xref:System.Collections.IDictionary?displayProperty=nameWithType> interfejsu z <xref:System.Collections.Generic.Dictionary%602>. Przykład pokazuje, że metoda zwraca `false` , jeśli podano klucz nieprawidłowego typu danych.  
  
 Przykład kodu jest częścią większego przykładu, łącznie z danymi wyjściowymi dostarczonymi <xref:System.Collections.Generic.Dictionary%602.System%23Collections%23IDictionary%23Add%2A> dla metody.  
  
 [!code-csharp[Generic.Dictionary.IDictionary#31](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.IDictionary/CS/source.cs#31)]
 [!code-vb[Generic.Dictionary.IDictionary#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.IDictionary/VB/source.vb#31)]  
[!code-csharp[Generic.Dictionary.IDictionary#6](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.IDictionary/CS/source.cs#6)]
[!code-vb[Generic.Dictionary.IDictionary#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.IDictionary/VB/source.vb#6)]  
[!code-csharp[Generic.Dictionary.IDictionary#32](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.IDictionary/CS/source.cs#32)]
[!code-vb[Generic.Dictionary.IDictionary#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.IDictionary/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IDictionaryEnumerator IDictionary.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.System#Collections#IDictionary#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IDictionaryEnumerator Implements IDictionary.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IDictionaryEnumerator ^ System.Collections.IDictionary.GetEnumerator() = System::Collections::IDictionary::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionaryEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Collections.IDictionaryEnumerator" /> Zwraca wartość<see cref="T:System.Collections.IDictionary" />dla.</summary>
        <returns><see cref="T:System.Collections.IDictionaryEnumerator" /> Dla .<see cref="T:System.Collections.IDictionary" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na potrzeby wyliczenia każdy element jest <xref:System.Collections.DictionaryEntry> strukturą.  
  
 `foreach` Instrukcja C# języka(`for each` C++w VisualBasic)ukrywazłożonośćmodułówwyliczających.`For Each` W związku z `foreach` tym zaleca się użycie zamiast bezpośredniego manipulowania modułem wyliczającym.  
  
 Moduły wyliczające mogą służyć do odczytu danych w kolekcji, ale nie można za ich pomocą modyfikować kolekcji źródłowej.  
  
 Początkowo moduł wyliczający jest umieszczony przed pierwszym elementem w kolekcji. <xref:System.Collections.IEnumerator.Reset%2A> Metoda również przywraca moduł wyliczający z powrotem do tego położenia.  W tym miejscu <xref:System.Collections.IDictionaryEnumerator.Entry%2A> nie jest zdefiniowane. W związku z tym, należy <xref:System.Collections.IEnumerator.MoveNext%2A> wywołać metodę, aby wykonać przechodzenie modułu wyliczającego do pierwszego elementu kolekcji przed odczytem <xref:System.Collections.IDictionaryEnumerator.Entry%2A>wartości.  
  
 Właściwość zwraca ten sam element do momentu <xref:System.Collections.IEnumerator.MoveNext%2A> wywołania metody <xref:System.Collections.IEnumerator.Reset%2A>lub. <xref:System.Collections.IDictionaryEnumerator.Entry%2A> <xref:System.Collections.IEnumerator.MoveNext%2A>ustawia <xref:System.Collections.IDictionaryEnumerator.Entry%2A> do następnego elementu.  
  
 Jeśli <xref:System.Collections.IEnumerator.MoveNext%2A> przekazuje koniec kolekcji, moduł wyliczający jest umieszczony po ostatnim elemencie w kolekcji i <xref:System.Collections.IEnumerator.MoveNext%2A> zwraca `false`. Gdy moduł wyliczający znajduje się w tym miejscu, kolejne <xref:System.Collections.IEnumerator.MoveNext%2A> wywołania również `false`zwracają. Jeśli ostatnie wywołanie <xref:System.Collections.IEnumerator.MoveNext%2A> zwrócone `false`, <xref:System.Collections.IDictionaryEnumerator.Entry%2A> nie jest zdefiniowane. Aby ponownie <xref:System.Collections.IDictionaryEnumerator.Entry%2A> ustawić na pierwszy element kolekcji, możesz wywołać metodę <xref:System.Collections.IEnumerator.Reset%2A> i <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Moduł wyliczający zachowuje ważność tak długo, jak długo kolekcja pozostaje niezmieniona. Jeśli w kolekcji zostaną wprowadzone zmiany, takie jak dodanie, zmodyfikowanie lub usunięcie elementów, moduł wyliczający jest nieodwracalnie unieważniony i następne wywołanie <xref:System.Collections.IEnumerator.MoveNext%2A> lub <xref:System.Collections.IEnumerator.Reset%2A> wygeneruje <xref:System.InvalidOperationException>.  
  
 Moduł wyliczający nie ma wyłącznego dostępu do kolekcji, w związku z tym wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość.  Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania.  Aby zezwolić wielu wątkom na dostęp do kolekcji w celu odczytu i zapisu danych, należy zaimplementować własny mechanizm synchronizacji.  
  
 Domyślne implementacje kolekcji w <xref:System.Collections.Generic?displayProperty=nameWithType> przestrzeni nazw nie są zsynchronizowane.  
  
 Ta metoda jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, `foreach` jak wyliczyć pary klucz/wartość w słowniku przy użyciu instrukcji (`For Each` w Visual Basic, `for each` in C++), która ukrywa użycie modułu wyliczającego. W szczególności należy zauważyć, że moduł wyliczający <xref:System.Collections.IDictionary?displayProperty=nameWithType> dla interfejsu <xref:System.Collections.DictionaryEntry> zwraca obiekty, <xref:System.Collections.Generic.KeyValuePair%602> a nie obiekty.  
  
 Przykład kodu jest częścią większego przykładu, łącznie z danymi wyjściowymi dostarczonymi <xref:System.Collections.Generic.Dictionary%602.System%23Collections%23IDictionary%23Add%2A> dla metody.  
  
 [!code-csharp[Generic.Dictionary.IDictionary#31](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.IDictionary/CS/source.cs#31)]
 [!code-vb[Generic.Dictionary.IDictionary#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.IDictionary/VB/source.vb#31)]  
[!code-csharp[Generic.Dictionary.IDictionary#7](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.IDictionary/CS/source.cs#7)]
[!code-vb[Generic.Dictionary.IDictionary#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.IDictionary/VB/source.vb#7)]  
[!code-csharp[Generic.Dictionary.IDictionary#32](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.IDictionary/CS/source.cs#32)]
[!code-vb[Generic.Dictionary.IDictionary#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.IDictionary/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IDictionaryEnumerator" />
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IDictionary.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IDictionary.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Dictionary`2.System#Collections#IDictionary#IsFixedSize" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFixedSize As Boolean Implements IDictionary.IsFixedSize" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IDictionary::IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IDictionary.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Collections.IDictionary" /> ma stały rozmiar.</summary>
        <value><see langword="true" />Jeśli ma stały rozmiar; <see langword="false" />w przeciwnym razie. <see cref="T:System.Collections.IDictionary" />  W domyślnej implementacji programu <see cref="T:System.Collections.Generic.Dictionary`2" />ta właściwość zawsze zwraca wartość. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W kolekcji o stałym rozmiarze po jej utworzeniu nie można dodawać ani usuwać elementów, jednak można modyfikować istniejące elementy.  
  
 Kolekcja o stałym rozmiarze jest po prostu kolekcją z otoką, która zapobiega dodawaniu i usuwaniu elementów; w związku z tym, jeśli wprowadzono zmiany do źródłowej kolekcji, w tym dodawanie lub usuwanie elementów, kolekcja o stałym rozmiarze odzwierciedla te zmiany.  
  
 Pobieranie wartości tej właściwości jest operacją O (1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IDictionary.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IDictionary.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Dictionary`2.System#Collections#IDictionary#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements IDictionary.IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IDictionary::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IDictionary.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy jest tylko <see cref="T:System.Collections.IDictionary" /> do odczytu.</summary>
        <value><see langword="true" />Jeśli jest <see cref="T:System.Collections.IDictionary" /> tylko do odczytu; <see langword="false" />w przeciwnym razie.  W domyślnej implementacji programu <see cref="T:System.Collections.Generic.Dictionary`2" />ta właściwość zawsze zwraca wartość. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W kolekcji tylko do odczytu po jej utworzeniu nie można dodawać, usuwać ani modyfikować elementów.  
  
 Kolekcja, która jest tylko do odczytu, jest po prostu zbiorem z otoką uniemożliwiającą zmianę kolekcji; w związku z tym, jeśli zmiany zostaną wprowadzone do podstawowej kolekcji, kolekcja tylko do odczytu uwzględni te zmiany.  
  
 Pobieranie wartości tej właściwości jest operacją O (1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IDictionary.Item[object key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IDictionary.Item(object)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Dictionary`2.System#Collections#IDictionary#Item(System.Object)" />
      <MemberSignature Language="VB.NET" Value=" Property Item(key As Object) As Object Implements IDictionary.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::IDictionary::Item[System::Object ^] { System::Object ^ get(System::Object ^ key); void set(System::Object ^ key, System::Object ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IDictionary.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Item(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Klucz wartości do pobrania.</param>
        <summary>Pobiera lub ustawia wartość z określonym kluczem.</summary>
        <value><see langword="null" /> Wartość skojarzona z określonym kluczem lub jeśli <paramref name="key" /> nie znajduje się w słowniku lub <paramref name="key" /> jest typu, którego nie można <see cref="T:System.Collections.Generic.Dictionary`2" />przypisać do typu <paramref name="TKey" /> klucza.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość umożliwia dostęp do określonej wartości w kolekcji przy użyciu następującej C# składni: `myCollection[key]` (`myCollection(key)` w Visual Basic).  
  
 Można również użyć <xref:System.Collections.IDictionary.Item%2A> właściwości, aby dodać nowe elementy przez ustawienie wartości klucza, który nie istnieje w słowniku, na `myCollection["myNonexistentKey"] = myValue`przykład. Jeśli jednak określony klucz już istnieje w słowniku, ustawienie <xref:System.Collections.IDictionary.Item%2A> właściwości zastępuje starą wartość. Z kolei <xref:System.Collections.IDictionary.Add%2A> Metoda nie modyfikuje istniejących elementów.  
  
 Język używa [tego](~/docs/csharp/language-reference/keywords/this.md) słowa kluczowego, aby zdefiniować indeksatory zamiast implementowania <xref:System.Collections.Generic.Dictionary%602.System%23Collections%23IDictionary%23Item%2A> właściwości. C# Visual Basic implementuje <xref:System.Collections.Generic.Dictionary%602.System%23Collections%23IDictionary%23Item%2A> jako właściwość domyślną, która zapewnia te same funkcje indeksowania.  
  
 Pobieranie lub Ustawianie wartości tej właściwości zbliża się do operacji O (1).  
  
   
  
## Examples  
 Poniższy przykład kodu <xref:System.Collections.Generic.Dictionary%602.System%23Collections%23IDictionary%23Item%2A> pokazuje <xref:System.Collections.Generic.Dictionary%602>, jak używać właściwości (indeksator w C#języku) <xref:System.Collections.IDictionary?displayProperty=nameWithType> interfejsu z, i sposoby, aby właściwość była inna od <xref:System.Collections.Generic.Dictionary%602.Item%2A?displayProperty=nameWithType> właściwości.  
  
 W przykładzie pokazano, <xref:System.Collections.Generic.Dictionary%602.Item%2A?displayProperty=nameWithType> <xref:System.Collections.Generic.Dictionary%602.System%23Collections%23IDictionary%23Item%2A?displayProperty=nameWithType> że właściwość może zmienić wartość skojarzoną z istniejącym kluczem i może być użyta do dodania nowej pary klucz/wartość, jeśli określony klucz nie znajduje się w słowniku. Przykład pokazuje również, że w przeciwieństwie <xref:System.Collections.Generic.Dictionary%602.Item%2A?displayProperty=nameWithType> do właściwości <xref:System.Collections.Generic.Dictionary%602.System%23Collections%23IDictionary%23Item%2A?displayProperty=nameWithType> właściwość nie zgłasza wyjątku, jeśli `key` nie znajduje się w słowniku, zwracając odwołanie o wartości null. Na koniec przykład pokazuje, że pobranie <xref:System.Collections.Generic.Dictionary%602.System%23Collections%23IDictionary%23Item%2A?displayProperty=nameWithType> właściwości zwraca odwołanie o wartości null, jeśli `key` nie jest poprawnym typem danych i że ustawienie właściwości zgłasza wyjątek, jeśli `key` nie jest poprawnym typem danych.  
  
 Przykład kodu jest częścią większego przykładu, łącznie z danymi wyjściowymi dostarczonymi <xref:System.Collections.Generic.Dictionary%602.System%23Collections%23IDictionary%23Add%2A> dla metody.  
  
 [!code-csharp[Generic.Dictionary.IDictionary#31](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.IDictionary/CS/source.cs#31)]
 [!code-vb[Generic.Dictionary.IDictionary#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.IDictionary/VB/source.vb#31)]  
[!code-csharp[Generic.Dictionary.IDictionary#3](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.IDictionary/CS/source.cs#3)]
[!code-vb[Generic.Dictionary.IDictionary#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.IDictionary/VB/source.vb#3)]  
[!code-csharp[Generic.Dictionary.IDictionary#4](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.IDictionary/CS/source.cs#4)]
[!code-vb[Generic.Dictionary.IDictionary#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.IDictionary/VB/source.vb#4)]  
[!code-csharp[Generic.Dictionary.IDictionary#32](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.IDictionary/CS/source.cs#32)]
[!code-vb[Generic.Dictionary.IDictionary#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.IDictionary/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Przypisuje się wartość i <paramref name="key" /> jest typu, którego nie można przypisać do typu <paramref name="TKey" /> <see cref="T:System.Collections.Generic.Dictionary`2" />klucza.  
  
—lub— 
Przypisuje się wartość i <paramref name="value" /> jest typu, którego nie można przypisać do typu <paramref name="TValue" /> <see cref="T:System.Collections.Generic.Dictionary`2" />wartości.</exception>
        <altmember cref="M:System.Collections.IDictionary.Add(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Keys">
      <MemberSignature Language="C#" Value="System.Collections.ICollection System.Collections.IDictionary.Keys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection System.Collections.IDictionary.Keys" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Dictionary`2.System#Collections#IDictionary#Keys" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Keys As ICollection Implements IDictionary.Keys" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::ICollection ^ System::Collections::IDictionary::Keys { System::Collections::ICollection ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IDictionary.Keys" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Keys</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera zawierający klucze <see cref="T:System.Collections.IDictionary" />. <see cref="T:System.Collections.ICollection" /></summary>
        <value><see cref="T:System.Collections.ICollection" /> Zawierający klucze<see cref="T:System.Collections.IDictionary" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kolejność kluczy w zwracanej <xref:System.Collections.ICollection> wartości jest nieokreślona, ale zagwarantowane jest to samo zamówienie, co odpowiadające wartości <xref:System.Collections.ICollection> w zwracanym przez <xref:System.Collections.IDictionary.Values%2A> właściwość.  
  
 Pobieranie wartości tej właściwości jest operacją O (1).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje <xref:System.Collections.Generic.Dictionary%602.System%23Collections%23IDictionary%23Keys%2A> <xref:System.Collections.Generic.Dictionary%602>, jak używać właściwości <xref:System.Collections.IDictionary?displayProperty=nameWithType> interfejsu z, aby wyświetlić listę kluczy w słowniku. W przykładzie pokazano również, jak wyliczyć pary klucz/wartość w słowniku; Należy zauważyć, że moduł wyliczający <xref:System.Collections.IDictionary?displayProperty=nameWithType> dla <xref:System.Collections.DictionaryEntry> interfejsu zwraca obiekty <xref:System.Collections.Generic.KeyValuePair%602> , a nie obiekty.  
  
 Przykład kodu jest częścią większego przykładu, łącznie z danymi wyjściowymi dostarczonymi <xref:System.Collections.Generic.Dictionary%602.System%23Collections%23IDictionary%23Add%2A> dla metody.  
  
 [!code-csharp[Generic.Dictionary.IDictionary#31](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.IDictionary/CS/source.cs#31)]
 [!code-vb[Generic.Dictionary.IDictionary#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.IDictionary/VB/source.vb#31)]  
[!code-csharp[Generic.Dictionary.IDictionary#9](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.IDictionary/CS/source.cs#9)]
[!code-vb[Generic.Dictionary.IDictionary#9](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.IDictionary/VB/source.vb#9)]  
[!code-csharp[Generic.Dictionary.IDictionary#7](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.IDictionary/CS/source.cs#7)]
[!code-vb[Generic.Dictionary.IDictionary#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.IDictionary/VB/source.vb#7)]  
[!code-csharp[Generic.Dictionary.IDictionary#32](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.IDictionary/CS/source.cs#32)]
[!code-vb[Generic.Dictionary.IDictionary#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.IDictionary/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.ICollection" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Remove">
      <MemberSignature Language="C#" Value="void IDictionary.Remove (object key);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IDictionary.Remove(object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.System#Collections#IDictionary#Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Remove (key As Object) Implements IDictionary.Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IDictionary.Remove(System::Object ^ key) = System::Collections::IDictionary::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IDictionary.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Klucz elementu do usunięcia.</param>
        <summary>Usuwa element z określonym kluczem z <see cref="T:System.Collections.IDictionary" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zbliża się do operacji O (1).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, <xref:System.Collections.Generic.Dictionary%602.System%23Collections%23IDictionary%23Remove%2A> <xref:System.Collections.IDictionary?displayProperty=nameWithType> jak używać interfejsu z <xref:System.Collections.Generic.Dictionary%602>.  
  
 Przykład kodu jest częścią większego przykładu, łącznie z danymi wyjściowymi dostarczonymi <xref:System.Collections.Generic.Dictionary%602.System%23Collections%23IDictionary%23Add%2A> dla metody.  
  
 [!code-csharp[Generic.Dictionary.IDictionary#31](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.IDictionary/CS/source.cs#31)]
 [!code-vb[Generic.Dictionary.IDictionary#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.IDictionary/VB/source.vb#31)]  
[!code-csharp[Generic.Dictionary.IDictionary#10](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.IDictionary/CS/source.cs#10)]
[!code-vb[Generic.Dictionary.IDictionary#10](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.IDictionary/VB/source.vb#10)]  
[!code-csharp[Generic.Dictionary.IDictionary#32](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.IDictionary/CS/source.cs#32)]
[!code-vb[Generic.Dictionary.IDictionary#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.IDictionary/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IDictionary.Values">
      <MemberSignature Language="C#" Value="System.Collections.ICollection System.Collections.IDictionary.Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection System.Collections.IDictionary.Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Dictionary`2.System#Collections#IDictionary#Values" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Values As ICollection Implements IDictionary.Values" />
      <MemberSignature Language="C++ CLI" Value="property System::Collections::ICollection ^ System::Collections::IDictionary::Values { System::Collections::ICollection ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IDictionary.Values" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IDictionary.Values</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera zawierający wartości z <see cref="T:System.Collections.IDictionary" />. <see cref="T:System.Collections.ICollection" /></summary>
        <value><see cref="T:System.Collections.ICollection" /> Zawierający wartości <see cref="T:System.Collections.IDictionary" />z.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kolejność wartości w zwracanym <xref:System.Collections.ICollection> elemencie jest nieokreślona, ale gwarantowane jest takie samo zamówienie, jak odpowiednie klucze <xref:System.Collections.ICollection> w zwracanym przez <xref:System.Collections.IDictionary.Keys%2A> właściwość.  
  
 Pobieranie wartości tej właściwości jest operacją O (1).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje <xref:System.Collections.Generic.Dictionary%602.System%23Collections%23IDictionary%23Values%2A> <xref:System.Collections.Generic.Dictionary%602>, jak używać właściwości <xref:System.Collections.IDictionary?displayProperty=nameWithType> interfejsu z, aby wyświetlić listę wartości w słowniku. W przykładzie pokazano również, jak wyliczyć pary klucz/wartość w słowniku; Należy zauważyć, że moduł wyliczający <xref:System.Collections.IDictionary?displayProperty=nameWithType> dla <xref:System.Collections.DictionaryEntry> interfejsu zwraca obiekty <xref:System.Collections.Generic.KeyValuePair%602> , a nie obiekty.  
  
 Przykład kodu jest częścią większego przykładu, łącznie z danymi wyjściowymi dostarczonymi <xref:System.Collections.Generic.Dictionary%602.System%23Collections%23IDictionary%23Add%2A> dla metody.  
  
 [!code-csharp[Generic.Dictionary.IDictionary#31](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.IDictionary/CS/source.cs#31)]
 [!code-vb[Generic.Dictionary.IDictionary#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.IDictionary/VB/source.vb#31)]  
[!code-csharp[Generic.Dictionary.IDictionary#8](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.IDictionary/CS/source.cs#8)]
[!code-vb[Generic.Dictionary.IDictionary#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.IDictionary/VB/source.vb#8)]  
[!code-csharp[Generic.Dictionary.IDictionary#7](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.IDictionary/CS/source.cs#7)]
[!code-vb[Generic.Dictionary.IDictionary#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.IDictionary/VB/source.vb#7)]  
[!code-csharp[Generic.Dictionary.IDictionary#32](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary.IDictionary/CS/source.cs#32)]
[!code-vb[Generic.Dictionary.IDictionary#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary.IDictionary/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.ICollection" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca moduł wyliczający, który dokonuje iteracji w kolekcji.</summary>
        <returns><see cref="T:System.Collections.IEnumerator" /> , Który może być używany do iteracji kolekcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 `foreach` Instrukcja C# języka(`for each` C++w VisualBasic)ukrywazłożonośćmodułówwyliczających.`For Each` W związku z `foreach` tym zaleca się użycie zamiast bezpośredniego manipulowania modułem wyliczającym.  
  
 Moduły wyliczające mogą służyć do odczytu danych w kolekcji, ale nie można za ich pomocą modyfikować kolekcji źródłowej.  
  
 Początkowo moduł wyliczający jest umieszczony przed pierwszym elementem w kolekcji. <xref:System.Collections.IEnumerator.Reset%2A> Metoda również przywraca moduł wyliczający z powrotem do tego położenia.  W tym miejscu <xref:System.Collections.IEnumerator.Current%2A> właściwość jest niezdefiniowana. W związku z tym, należy <xref:System.Collections.IEnumerator.MoveNext%2A> wywołać metodę, aby wykonać przechodzenie modułu wyliczającego do pierwszego elementu kolekcji przed odczytem <xref:System.Collections.IEnumerator.Current%2A>wartości.  
  
 Właściwość zwraca ten sam element do momentu <xref:System.Collections.IEnumerator.MoveNext%2A> wywołania metody <xref:System.Collections.IEnumerator.Reset%2A>lub. <xref:System.Collections.IEnumerator.Current%2A> <xref:System.Collections.IEnumerator.MoveNext%2A>ustawia <xref:System.Collections.IEnumerator.Current%2A> do następnego elementu.  
  
 Jeśli <xref:System.Collections.IEnumerator.MoveNext%2A> przekazuje koniec kolekcji, moduł wyliczający jest umieszczony po ostatnim elemencie w kolekcji i <xref:System.Collections.IEnumerator.MoveNext%2A> zwraca `false`. Gdy moduł wyliczający znajduje się w tym miejscu, kolejne <xref:System.Collections.IEnumerator.MoveNext%2A> wywołania również `false`zwracają. Jeśli ostatnie wywołanie <xref:System.Collections.IEnumerator.MoveNext%2A> zwrócone `false`, <xref:System.Collections.IEnumerator.Current%2A> nie jest zdefiniowane. Aby ponownie <xref:System.Collections.IEnumerator.Current%2A> ustawić na pierwszy element kolekcji, możesz wywołać metodę <xref:System.Collections.IEnumerator.Reset%2A> i <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Moduł wyliczający zachowuje ważność tak długo, jak długo kolekcja pozostaje niezmieniona. Jeśli w kolekcji zostaną wprowadzone zmiany, takie jak dodanie, zmodyfikowanie lub usunięcie elementów, moduł wyliczający jest nieodwracalnie unieważniony i następne wywołanie <xref:System.Collections.IEnumerator.MoveNext%2A> lub <xref:System.Collections.IEnumerator.Reset%2A> wygeneruje <xref:System.InvalidOperationException>.  
  
 Moduł wyliczający nie ma wyłącznego dostępu do kolekcji; w związku z tym Wyliczanie za pomocą kolekcji nie jest w sposób bezpieczny dla wątków.  Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania.  Aby zezwolić wielu wątkom na dostęp do kolekcji w celu odczytu i zapisu danych, należy zaimplementować własny mechanizm synchronizacji.  
  
 Domyślne implementacje kolekcji w <xref:System.Collections.Generic?displayProperty=nameWithType> przestrzeni nazw nie są zsynchronizowane.  
  
 Ta metoda jest operacją O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="TrimExcess">
      <MemberSignature Language="C#" Value="public void TrimExcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TrimExcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.TrimExcess" />
      <MemberSignature Language="VB.NET" Value="Public Sub TrimExcess ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TrimExcess();" />
      <MemberSignature Language="F#" Value="member this.TrimExcess : unit -&gt; unit" Usage="dictionary.TrimExcess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ustawia pojemność tego słownika, tak jakby był pierwotnie zainicjowany przy użyciu wszystkich jego wpisów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

Tej metody można użyć do zminimalizowania obciążenia pamięci, gdy wiadomo, że żadne nowe elementy nie zostaną dodane do słownika. Aby alokować tablicę magazynu o minimalnym rozmiarze, wykonaj następujące instrukcje:

```csharp
dictionary.Clear();
dictionary.TrimExcess();
```

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimExcess">
      <MemberSignature Language="C#" Value="public void TrimExcess (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TrimExcess(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.TrimExcess(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TrimExcess (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TrimExcess(int capacity);" />
      <MemberSignature Language="F#" Value="member this.TrimExcess : int -&gt; unit" Usage="dictionary.TrimExcess capacity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="capacity">Nowa pojemność.</param>
        <summary>Ustawia pojemność tego słownika, aby pomieścić określoną liczbę wpisów bez dalszej ekspansji magazynu zapasowego.</summary>
        <remarks>Tej metody można użyć do zminimalizowania obciążenia pamięci, gdy wiadomo, że nie zostaną dodane żadne nowe elementy.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" />jest mniejsze niż <see cref="T:System.Collections.Generic.Dictionary`2" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryAdd">
      <MemberSignature Language="C#" Value="public bool TryAdd (TKey key, TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryAdd(!TKey key, !TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.TryAdd(`0,`1)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryAdd (key As TKey, value As TValue) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryAdd(TKey key, TValue value);" />
      <MemberSignature Language="F#" Value="member this.TryAdd : 'Key * 'Value -&gt; bool" Usage="dictionary.TryAdd (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="TValue" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="key">Klucz elementu do dodania.</param>
        <param name="value">Wartość elementu do dodania. Może to być <see langword="null" />.</param>
        <summary>Próbuje dodać określony klucz i wartość do słownika.</summary>
        <returns><see langword="true" />Jeśli para klucz/wartość została pomyślnie dodana do słownika; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

W przeciwieństwie <xref:System.Collections.Generic.Dictionary%602.Add%2A> do metody, ta metoda nie zgłasza wyjątku, jeśli element z danym kluczem istnieje w słowniku. W przeciwieństwie do indeksatora słownika `TryAdd` , nie przesłania elementu, jeśli element z danym kluczem istnieje w słowniku. Jeśli klucz już istnieje, `TryAdd` nie robi niczego i zwraca wartość. `false`

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryGetValue">
      <MemberSignature Language="C#" Value="public bool TryGetValue (TKey key, out TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryGetValue(!TKey key, [out] !TValue&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.Dictionary`2.TryGetValue(`0,`1@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetValue (key As TKey, ByRef value As TValue) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryGetValue(TKey key, [Runtime::InteropServices::Out] TValue % value);" />
      <MemberSignature Language="F#" Value="abstract member TryGetValue : 'Key *  -&gt; bool&#xA;override this.TryGetValue : 'Key *  -&gt; bool" Usage="dictionary.TryGetValue (key, value)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IDictionary`2.TryGetValue(`0,`1@)</InterfaceMember>
        <InterfaceMember>M:System.Collections.Generic.IReadOnlyDictionary`2.TryGetValue(`0,`1@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" RefType="out" />
      </Parameters>
      <Docs>
        <param name="key">Klucz wartości do pobrania.</param>
        <param name="value">Gdy ta metoda zwraca, zawiera wartość skojarzoną z określonym kluczem, jeśli klucz zostanie znaleziony. w przeciwnym razie wartość domyślna dla typu <paramref name="value" /> parametru. Ten parametr jest przekazywany niezainicjowany.</param>
        <summary>Pobiera wartość skojarzoną z określonym kluczem.</summary>
        <returns><see langword="true" />Jeśli zawiera element z określonym kluczem; w przeciwnym razie, <see langword="false" />. <see cref="T:System.Collections.Generic.Dictionary`2" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda łączy funkcjonalność <xref:System.Collections.Generic.Dictionary%602.ContainsKey%2A> metody <xref:System.Collections.Generic.Dictionary%602.Item%2A> i właściwości.  
  
 Jeśli klucz nie zostanie znaleziony `value` , parametr pobiera odpowiednią wartość domyślną dla typu `TValue`, na przykład 0 (zero) dla typów całkowitych, `false` dla typów logicznych i `null` dla typów referencyjnych.  
  
 Użyj metody <xref:System.Collections.Generic.Dictionary%602.TryGetValue%2A> , jeśli kod często próbuje uzyskać dostęp do kluczy, które nie znajdują się w słowniku. Użycie tej metody jest wydajniejsze niż Przechwytywanie <xref:System.Collections.Generic.KeyNotFoundException> zgłoszone <xref:System.Collections.Generic.Dictionary%602.Item%2A> przez właściwość.  
  
 Ta metoda zbliża się do operacji O (1).  
  
   
  
## Examples  
 W przykładzie pokazano, jak używać <xref:System.Collections.Generic.Dictionary%602.TryGetValue%2A> metody jako wydajniejszego sposobu pobierania wartości w programie, który często próbuje klucze, które nie znajdują się w słowniku. Z kolei przykład pokazuje również, jak <xref:System.Collections.Generic.Dictionary%602.Item%2A> Właściwość (indeksator w C#) zgłasza wyjątki podczas próby pobrania nieistniejących kluczy.  
  
 Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.Collections.Generic.Dictionary%602> klasy (`openWith` jest nazwą słownika użytego w tym przykładzie).  
  
 [!code-cpp[Generic.Dictionary#5](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.Dictionary/cpp/source.cpp#5)]
 [!code-csharp[Generic.Dictionary#5](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary/CS/source.cs#5)]
 [!code-vb[Generic.Dictionary#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary/VB/source.vb#5)]  
[!code-cpp[Generic.Dictionary#4](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.Dictionary/cpp/source.cpp#4)]
[!code-csharp[Generic.Dictionary#4](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary/CS/source.cs#4)]
[!code-vb[Generic.Dictionary#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" />jest <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.Dictionary`2.ContainsKey(`0)" />
        <altmember cref="P:System.Collections.Generic.Dictionary`2.Item(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Values">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.Dictionary&lt;TKey,TValue&gt;.ValueCollection Values { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.Dictionary`2/ValueCollection&lt;!TKey, !TValue&gt; Values" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.Dictionary`2.Values" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Values As Dictionary(Of TKey, TValue).ValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::Dictionary&lt;TKey, TValue&gt;::ValueCollection ^ Values { System::Collections::Generic::Dictionary&lt;TKey, TValue&gt;::ValueCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Values : System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt;.ValueCollection" Usage="System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt;.Values" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Dictionary&lt;TKey,TValue&gt;+ValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję zawierającą wartości <see cref="T:System.Collections.Generic.Dictionary`2" />z.</summary>
        <value>A <see cref="T:System.Collections.Generic.Dictionary`2.ValueCollection" /> zawierający wartości <see cref="T:System.Collections.Generic.Dictionary`2" />z.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kolejność wartości w <xref:System.Collections.Generic.Dictionary%602.ValueCollection> elemencie jest nieokreślona, ale jest to taka sama kolejność, jak skojarzone klucze <xref:System.Collections.Generic.Dictionary%602.KeyCollection> w zwracanym przez <xref:System.Collections.Generic.Dictionary%602.Keys%2A> właściwość.  
  
 Zwracana <xref:System.Collections.Generic.Dictionary%602.ValueCollection> wartość nie jest kopią statyczną; zamiast tego <xref:System.Collections.Generic.Dictionary%602.ValueCollection> odwołuje się do wartości w oryginale <xref:System.Collections.Generic.Dictionary%602>. W związku z tym zmiany <xref:System.Collections.Generic.Dictionary%602> w dalszym ciągu zostaną odzwierciedlone w. <xref:System.Collections.Generic.Dictionary%602.ValueCollection>  
  
 Pobieranie wartości tej właściwości jest operacją O (1).  
  
   
  
## Examples  
 Ten przykład kodu pokazuje, jak wyliczyć wartości ze słownika przy użyciu <xref:System.Collections.Generic.Dictionary%602.Values%2A> właściwości oraz jak wyliczyć klucze i wartości w słowniku.  
  
 Ten przykład kodu jest częścią większego przykładu dostarczonego dla <xref:System.Collections.Generic.Dictionary%602> klasy (`openWith` jest nazwą słownika użytego w tym przykładzie).  
  
 [!code-cpp[Generic.Dictionary#8](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.Dictionary/cpp/source.cpp#8)]
 [!code-csharp[Generic.Dictionary#8](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary/CS/source.cs#8)]
 [!code-vb[Generic.Dictionary#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary/VB/source.vb#8)]  
[!code-cpp[Generic.Dictionary#7](~/samples/snippets/cpp/VS_Snippets_CLR/Generic.Dictionary/cpp/source.cpp#7)]
[!code-csharp[Generic.Dictionary#7](~/samples/snippets/csharp/VS_Snippets_CLR/Generic.Dictionary/CS/source.cs#7)]
[!code-vb[Generic.Dictionary#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/Generic.Dictionary/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.Dictionary`2.ValueCollection" />
        <altmember cref="P:System.Collections.Generic.Dictionary`2.Keys" />
      </Docs>
    </Member>
  </Members>
</Type>
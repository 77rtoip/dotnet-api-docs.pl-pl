<Type Name="List&lt;T&gt;" FullName="System.Collections.Generic.List&lt;T&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="05dd2d33958afd2ac9deacf41e0ba2b74bfdcd7b" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36646274" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class List&lt;T&gt; : System.Collections.Generic.ICollection&lt;T&gt;, System.Collections.Generic.IEnumerable&lt;T&gt;, System.Collections.Generic.IList&lt;T&gt;, System.Collections.Generic.IReadOnlyCollection&lt;T&gt;, System.Collections.Generic.IReadOnlyList&lt;T&gt;, System.Collections.IList" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit List`1&lt;T&gt; extends System.Object implements class System.Collections.Generic.ICollection`1&lt;!T&gt;, class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.Generic.IList`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyList`1&lt;!T&gt;, class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Generic.List`1" />
  <TypeSignature Language="VB.NET" Value="Public Class List(Of T)&#xA;Implements ICollection(Of T), IEnumerable(Of T), IList, IList(Of T), IReadOnlyCollection(Of T), IReadOnlyList(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class List : System::Collections::Generic::ICollection&lt;T&gt;, System::Collections::Generic::IEnumerable&lt;T&gt;, System::Collections::Generic::IList&lt;T&gt;, System::Collections::Generic::IReadOnlyCollection&lt;T&gt;, System::Collections::Generic::IReadOnlyList&lt;T&gt;, System::Collections::IList" />
  <TypeSignature Language="F#" Value="type List&lt;'T&gt; = class&#xA;    interface IList&lt;'T&gt;&#xA;    interface IList&#xA;    interface IReadOnlyList&lt;'T&gt;&#xA;    interface ICollection&lt;'T&gt;&#xA;    interface seq&lt;'T&gt;&#xA;    interface IEnumerable&#xA;    interface ICollection&#xA;    interface IReadOnlyCollection&lt;'T&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Collections</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IList&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyList&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.Mscorlib_CollectionDebugView`1))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">Typ elementów na liście.</typeparam>
    <summary>Reprezentuje silnie typizowaną listę obiektów, które mogą być udostępniane przez indeks. Udostępnia metody do wyszukiwania, sortowania i manipulowania list.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> Klasy jest ogólny odpowiednik <xref:System.Collections.ArrayList> klasy. Implementuje <xref:System.Collections.Generic.IList%601> ogólny interfejs przy użyciu tablicy, której rozmiar jest dynamicznie zwiększony jako wymagane.  
  
 Można dodać elementy do <xref:System.Collections.Generic.List%601> za pomocą <xref:System.Collections.Generic.List%601.Add%2A> lub <xref:System.Collections.Generic.List%601.AddRange%2A> metody.  
  
 <xref:System.Collections.Generic.List%601> Klasy używa zarówno porównania równości i porównania porządkowania.  
  
-   Metody, takie jak <xref:System.Collections.Generic.List%601.Contains%2A>, <xref:System.Collections.Generic.List%601.IndexOf%2A>, <xref:System.Collections.Generic.List%601.LastIndexOf%2A>, i <xref:System.Collections.Generic.Dictionary%602.Remove%2A> Użyj porównania równości dla elementów listy. Domyślna funkcja porównująca równości dla typu `T` jest określane w następujący sposób. Jeśli typ `T` implementuje <xref:System.IEquatable%601> jest ogólny interfejs, a następnie porównania równości <xref:System.IEquatable%601.Equals%28%600%29> metody tego interfejsu; w przeciwnym razie jest domyślna funkcja porównująca równości <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>.  
  
-   Metody, takie jak <xref:System.Collections.Generic.List%601.BinarySearch%2A> i <xref:System.Collections.Generic.List%601.Sort%2A> Użyj porównania porządkowania elementów listy. Domyślna funkcja porównująca dla typu `T` jest określane w następujący sposób.  Jeśli typ `T` implementuje <xref:System.IComparable%601> jest ogólny interfejs, a następnie domyślna funkcja porównująca <xref:System.IComparable%601.CompareTo%28%600%29> metody tego interfejsu; w przeciwnym razie, jeśli typ `T` implementuje nongeneric <xref:System.IComparable> interfejs, a następnie wartość domyślna Moduł porównujący jest <xref:System.IComparable.CompareTo%28System.Object%29> metody tego interfejsu. Jeśli typ `T` implementuje ani interfejsu nie domyślna funkcja porównująca nie istnieje, a więc jawnie podać delegata porównania lub porównania.  
  
 <xref:System.Collections.Generic.List%601> Nie jest gwarantowana ma zostać posortowana.  Należy sortować <xref:System.Collections.Generic.List%601> przed wykonaniem operacji (takich jak <xref:System.Collections.Generic.List%601.BinarySearch%2A>), które wymagają <xref:System.Collections.Generic.List%601> ma zostać posortowana.  
  
 Elementy w tej kolekcji jest możliwy przy użyciu indeksu liczby całkowitej.  Indeksy w tej kolekcji jest liczony od zera.  
  
 Dla bardzo dużych <xref:System.Collections.Generic.List%601> obiekty, można zwiększyć maksymalną pojemność do 2 miliardów elementów w 64-bitowym systemie ustawiając `enabled` atrybutu elementu konfiguracji, aby `true` w środowisku czasu wykonywania.  
  
 <xref:System.Collections.Generic.List%601> akceptuje `null` jako prawidłowa wartość dla odwołania do typów i umożliwia zduplikowane elementy.  
  
 Niezmienne wersję <xref:System.Collections.Generic.List%601> , zobacz <xref:System.Collections.Immutable.ImmutableList%601>.  
  
## <a name="performance-considerations"></a>Zagadnienia dotyczące wydajności  
 W podjęcie decyzji o użyciu <xref:System.Collections.Generic.List%601> lub <xref:System.Collections.ArrayList> klasy, które mają podobne funkcje, należy pamiętać, że <xref:System.Collections.Generic.List%601> klasa działa lepiej, w większości przypadków i jest typu bezpieczne. Jeśli typ referencyjny jest używany dla typu `T` z <xref:System.Collections.Generic.List%601> klasy, zachowaniem dwóch klas jest identyczny. Jednak w przypadku używania typu wartości dla typu `T`, należy wziąć pod uwagę implementacji i opakowanie problemy.  
  
 W przypadku używania typu wartości dla typu `T`, kompilator generuje implementacja <xref:System.Collections.Generic.List%601> klasy specjalnie dla tego typu wartości. Oznacza to, że element listy <xref:System.Collections.Generic.List%601> obiekt nie ma zostać opakowany przed element może być użyty, a po utworzeniu około 500 elementów listy pamięci nie konwersja boxing listy elementów jest większa niż pamięć używana do generowania implementacji klasy.  
  
 Należy upewnić się na wartość typu używany dla typu `T` implementuje <xref:System.IEquatable%601> interfejs generyczny. Jeśli nie, metod, takich jak <xref:System.Collections.Generic.List%601.Contains%2A> należy wywołać <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> metodę, która pola elementu odpowiednich list. Jeśli implementuje typ wartości <xref:System.IComparable> interfejs, a właścicielem kodu źródłowego, również wdrożenie <xref:System.IComparable%601> interfejs ogólny, aby zapobiec <xref:System.Collections.Generic.List%601.BinarySearch%2A> i <xref:System.Collections.Generic.List%601.Sort%2A> metody konwersja boxing elementów listy. Jeśli nie ma kodu źródłowego, Przekaż <xref:System.Collections.Generic.IComparer%601> do obiektu <xref:System.Collections.Generic.List%601.BinarySearch%2A> i <xref:System.Collections.Generic.List%601.Sort%2A> metody  
  
 Jest się korzysta z określonego typu wdrożenia <xref:System.Collections.Generic.List%601> klasy zamiast <xref:System.Collections.ArrayList> klasy lub napisanie kolekcję silnie typizowaną otoki. Dzieje się tak implementacji należy wykonać, jaki programu .NET Framework jest dla Ciebie już i kod języka pośredniego firmy Microsoft i metadanych, które implementacji nie można udostępniać środowisko uruchomieniowe języka wspólnego.  
  
## <a name="f-considerations"></a>Zagadnienia dotyczące F #  
 <xref:System.Collections.Generic.List%601> Klasa jest rzadko używana w kodzie języka F #.  Zamiast tego [wymieniono](http://msdn.microsoft.com/library/83102799-f251-42e1-93ef-64232e8c5b1d), które są niezmienne, pojedynczo połączone list, są zazwyczaj preferowane. F # lista zawiera uporządkowany i modyfikować serii wartości i jest obsługiwana w przypadku użycia w programowanie funkcjonalne stylu. W przypadku używania z F # <xref:System.Collections.Generic.List%601> klasy jest zwykle przywoływany przez [resizearray —\<'T >](https://msdn.microsoft.com/library/ee353447.aspx) wpisz skrót, aby uniknąć konfliktu nazw z listy F #  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób dodawania, usuwania i Wstaw obiekt biznesowy proste w <xref:System.Collections.Generic.List%601>.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 W poniższym przykładzie pokazano kilka właściwości i metody <xref:System.Collections.Generic.List%601> klasy generycznej typu String. (Na przykład <xref:System.Collections.Generic.List%601> typów złożonych, zobacz <xref:System.Collections.Generic.List%601.Contains%2A> metody.)  
  
 Aby utworzyć listę ciągów o pojemności domyślnej jest użyć domyślnego konstruktora. <xref:System.Collections.Generic.List%601.Capacity%2A> Wyświetlane właściwości, a następnie <xref:System.Collections.Generic.List%601.Add%2A> metoda jest używana do dodawania wielu elementów. Elementy podrzędne są wyświetlane oraz <xref:System.Collections.Generic.List%601.Capacity%2A> właściwości zostanie wyświetlony ponownie, wraz z <xref:System.Collections.Generic.List%601.Count%2A> właściwości, aby pokazać, że pojemność została zwiększona, zgodnie z potrzebami.  
  
 <xref:System.Collections.Generic.List%601.Contains%2A> Metoda służy do sprawdzenia obecności elementu na liście <xref:System.Collections.Generic.List%601.Insert%2A> metoda jest używana do Wstaw nowy element środku listy i ponownie wyświetlona zawartość listy.  
  
 Wartość domyślna <xref:System.Collections.Generic.List%601.Item%2A> właściwości (indeksator w języku C#) służy do pobierania elementu <xref:System.Collections.Generic.List%601.Remove%2A> metoda jest używana do usuwania pierwsze wystąpienie zduplikowany element dodany wcześniej, a zawartość jest ponownie wyświetlana. <xref:System.Collections.Generic.List%601.Remove%2A> Metoda zawsze usuwa pierwsze wystąpienie wystąpienia.  
  
 <xref:System.Collections.Generic.List%601.TrimExcess%2A> Metoda jest używana do zmniejszenia wydajności, aby być zgodna z liczbą i <xref:System.Collections.Generic.List%601.Capacity%2A> i <xref:System.Collections.Generic.List%601.Count%2A> właściwości są wyświetlane. Jeśli niewykorzystana zdolność była mniejsza niż 10 procent całkowitej wydajności, listy czy nie został zmieniony.  
  
 Na koniec <xref:System.Collections.Generic.List%601.Clear%2A> — metoda jest używana do usuwania wszystkich elementów na liście i <xref:System.Collections.Generic.List%601.Capacity%2A> i <xref:System.Collections.Generic.List%601.Count%2A> właściwości są wyświetlane.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
    </remarks>
    <threadsafe>Publiczne statyczne (<see langword="Shared" /> w języku Visual Basic) elementy członkowskie tego typu są bezpieczne dla wątków. Wystąpienia elementów członkowskich nie dają gwarancji bezpieczeństwa wątków.  Jest to bezpieczne do wykonywania wielu operacji odczytu na <see cref="T:System.Collections.Generic.List`1" />, ale problemy mogą wystąpić, jeśli kolekcja jest modyfikowany podczas jej odczytywania. Aby zapewnić bezpieczeństwo wątków, blokowanie kolekcji podczas odczytu lub zapisu operacji. Aby włączyć dostęp przez wiele wątków do odczytu i zapisu do kolekcji, musi implementować własne synchronizacji. Kolekcje wbudowane synchronizacji, zawiera opis klas w <see cref="N:System.Collections.Concurrent" /> przestrzeni nazw. Aby zamiast z założenia — wielowątkowość, zobacz <see cref="T:System.Collections.Immutable.ImmutableList`1" /> klasy.</threadsafe>
    <altmember cref="T:System.Collections.IList" />
    <altmember cref="T:System.Collections.Immutable.ImmutableList`1" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Collections.Generic.List`1" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public List ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; List();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Collections.Generic.List`1" /> klasy, która jest pusty i ma początkowej wydajności domyślnej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pojemność <xref:System.Collections.Generic.List%601> jest liczba elementów który <xref:System.Collections.Generic.List%601> może przechowywać. Po dodaniu elementów do <xref:System.Collections.Generic.List%601>, automatycznie zostaje zwiększona wydajność zgodnie z żądaniem ponowne przydzielanie tablicy wewnętrznej.  
  
 Jeśli rozmiar kolekcji można oszacować, za pomocą <xref:System.Collections.Generic.List%601.%23ctor%28System.Int32%29> Konstruktor i Określanie początkowej pojemności eliminuje konieczność wykonania wielu operacji zmiany rozmiaru podczas dodawania elementów do <xref:System.Collections.Generic.List%601>.  
  
 Można zmniejszyć pojemność przez wywołanie metody <xref:System.Collections.Generic.List%601.TrimExcess%2A> metody lub przez ustawienie <xref:System.Collections.Generic.List%601.Capacity%2A> właściwości jawnie. Zmniejszania pojemności przydziela ponownie pamięci i kopiuje wszystkie elementy w <xref:System.Collections.Generic.List%601>.  
  
 Ten konstruktor jest operacją O(1).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano domyślny konstruktor obiektu <xref:System.Collections.Generic.List%601> klasy ogólnej. Domyślny konstruktor tworzy listę o pojemności domyślnej opisanym przy wyświetlaniu <xref:System.Collections.Generic.List%601.Capacity%2A> właściwości.  
  
 Przykład dodaje wstawia i usuwa elementy przedstawiający sposób pojemność zmiany te metody są używane.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public List (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.#ctor(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; List(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.List&lt;'T&gt; : seq&lt;'T&gt; -&gt; System.Collections.Generic.List&lt;'T&gt;" Usage="new System.Collections.Generic.List&lt;'T&gt; collection" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">Kolekcja, której elementy są kopiowane do nowej listy.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Collections.Generic.List`1" /> skopiowane klasy, która zawiera elementów kopiowanych z określonej kolekcji i ma wystarczającej wydajności, aby pomieścić liczby elementów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Elementy są kopiowane na <xref:System.Collections.Generic.List%601> w tej samej kolejności odczytywania ich przez moduł wyliczający kolekcji.  
  
 Ten konstruktor jest O (*n*) operację, której *n* jest liczba elementów w `collection`.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Collections.Generic.List%601.%23ctor%2A> Konstruktor i różnych metod <xref:System.Collections.Generic.List%601> klasy, która działa w wypadku zakresów. Tablica ciągów jest tworzony i przekazany do konstruktora wypełniania listy elementów tablicy. <xref:System.Collections.Generic.List%601.Capacity%2A> Właściwości zebrane informacje, aby wskazać, że początkowa pojemność jest dokładnie co to jest wymagana do przechowywania elementów wejściowych.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collection" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Collections.Generic.IEnumerable`1" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public List (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; List(int capacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.List&lt;'T&gt; : int -&gt; System.Collections.Generic.List&lt;'T&gt;" Usage="new System.Collections.Generic.List&lt;'T&gt; capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Liczba elementów, które początkowo mogą przechowywać nową listę.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Collections.Generic.List`1" /> klasy, która jest pusty i ma określony początkowej pojemności.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pojemność <xref:System.Collections.Generic.List%601> jest liczba elementów który <xref:System.Collections.Generic.List%601> może przechowywać. Po dodaniu elementów do <xref:System.Collections.Generic.List%601>, automatycznie zostaje zwiększona wydajność zgodnie z żądaniem ponowne przydzielanie tablicy wewnętrznej.  
  
 Jeśli rozmiar kolekcji można oszacować, określając początkowa pojemność eliminuje konieczność wykonania wielu operacji zmiany rozmiaru podczas dodawania elementów do <xref:System.Collections.Generic.List%601>.  
  
 Można zmniejszyć pojemność przez wywołanie metody <xref:System.Collections.Generic.List%601.TrimExcess%2A> metody lub przez ustawienie <xref:System.Collections.Generic.List%601.Capacity%2A> właściwości jawnie. Zmniejszania pojemności przydziela ponownie pamięci i kopiuje wszystkie elementy w <xref:System.Collections.Generic.List%601>.  
  
 Ten konstruktor jest O (*n*) operację, której *n* jest `capacity`.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Collections.Generic.List%601.%23ctor%28System.Int32%29> konstruktora. A <xref:System.Collections.Generic.List%601> ciągów o pojemności 4 został utworzony, ponieważ rozmiar ultimate listy jest znany jako dokładnie 4. Lista jest wypełniana cztery parametry i zostanie utworzona kopia tylko do odczytu za pomocą <xref:System.Collections.Generic.List%601.AsReadOnly%2A> metody.  
  
 [!code-cpp[List\`1_AsReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_AsReadOnly/cpp/source.cpp#1)]
 [!code-csharp[List\`1_AsReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_AsReadOnly/cs/source.cs#1)]
 [!code-vb[List\`1_AsReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_AsReadOnly/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> jest mniejsza niż 0.</exception>
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Add(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (item As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(T item);" />
      <MemberSignature Language="F#" Value="abstract member Add : 'T -&gt; unit&#xA;override this.Add : 'T -&gt; unit" Usage="list.Add item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Obiekt do dodania na koniec <see cref="T:System.Collections.Generic.List`1" />. Wartość może być <see langword="null" /> dla typów odwołań.</param>
        <summary>Dodaje obiekt na koniec <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> akceptuje `null` jako prawidłowa wartość dla odwołania do typów i umożliwia zduplikowane elementy.  
  
 Jeśli <xref:System.Collections.Generic.List%601.Count%2A> jest już równa <xref:System.Collections.Generic.List%601.Capacity%2A>, pojemność <xref:System.Collections.Generic.List%601> zwiększa się o automatyczne ponowne przydzielanie tablicy wewnętrznej, a istniejące elementy są kopiowane do nowej tablicy przed dodaniem nowego elementu.  
  
 Jeśli <xref:System.Collections.Generic.List%601.Count%2A> jest mniejsza niż <xref:System.Collections.Generic.List%601.Capacity%2A>, ta metoda jest operacją O(1). Jeśli pojemność wymaga zwiększenia w celu uwzględnienia nowego elementu, ta metoda staje się O (*n*) operację, której *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób dodawania, usuwania i Wstaw obiekt biznesowy proste w <xref:System.Collections.Generic.List%601>.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 W poniższym przykładzie pokazano kilka właściwości i metod <xref:System.Collections.Generic.List%601> klasy ogólnej, łącznie z <xref:System.Collections.Generic.List%601.Add%2A> metody. Aby utworzyć listę ciągów o pojemności 0 jest użyć domyślnego konstruktora. <xref:System.Collections.Generic.List%601.Capacity%2A> Właściwość jest wyświetlana, a następnie <xref:System.Collections.Generic.List%601.Add%2A> metoda jest używana do dodawania wielu elementów. Elementy podrzędne są wyświetlane oraz <xref:System.Collections.Generic.List%601.Capacity%2A> właściwości zostanie wyświetlony ponownie, wraz z <xref:System.Collections.Generic.List%601.Count%2A> właściwości, aby pokazać, że pojemność została zwiększona, zgodnie z potrzebami.  
  
 Inne właściwości i metody, które są używane do wyszukania, wstawianie i usuwanie elementów z listy, a na końcu aby wyczyścić listę.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberSignature Language="F#" Value="member this.AddRange : seq&lt;'T&gt; -&gt; unit" Usage="list.AddRange collection" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">Kolekcja, której elementy powinny zostać dodane do końca <see cref="T:System.Collections.Generic.List`1" />. Sama kolekcja nie może być <see langword="null" />, ale może zawierać elementy, które są <see langword="null" />, jeśli typ <c>T</c> jest typem referencyjnym.</param>
        <summary>Dodaje elementy określonej kolekcji na końcu <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kolejność elementów w kolekcji jest zachowywana w <xref:System.Collections.Generic.List%601>.  
  
 Jeśli nowy <xref:System.Collections.Generic.List%601.Count%2A> (bieżące <xref:System.Collections.Generic.List%601.Count%2A> plus rozmiar kolekcji) będą większe niż <xref:System.Collections.Generic.List%601.Capacity%2A>, pojemność <xref:System.Collections.Generic.List%601> zwiększa się o automatyczne ponowne przydzielanie tablicy wewnętrznej w celu uwzględnienia nowych elementów i istniejące elementy są kopiowane do nowej tablicy przed są dodawane nowe elementy.  
  
 Jeśli <xref:System.Collections.Generic.List%601> może obsłużyć nowych elementów bez zwiększania <xref:System.Collections.Generic.List%601.Capacity%2A>, ta metoda jest O (*n*) operację, której *n* jest liczba elementów do dodania. Jeśli pojemność wymaga zwiększenia w celu uwzględnienia nowych elementów, ta metoda staje się O (*n* + *m*) operację, której *n* jest liczba elementów można dodawać i *m* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Collections.Generic.List%601.AddRange%2A> — metoda i różnych innych metod <xref:System.Collections.Generic.List%601> klasy, która działa w wypadku zakresów. Tablica ciągów jest tworzony i przekazany do konstruktora wypełniania listy elementów tablicy. <xref:System.Collections.Generic.List%601.AddRange%2A> Metoda jest wywoływana z listą jako jej argument. Wynik jest, że bieżące elementy listy są dodawane na końcu listy duplikowania wszystkie elementy.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collection" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Collections.Generic.IEnumerable`1" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="AsReadOnly">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt; AsReadOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;!T&gt; AsReadOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.AsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Function AsReadOnly () As ReadOnlyCollection(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;T&gt; ^ AsReadOnly();" />
      <MemberSignature Language="F#" Value="member this.AsReadOnly : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;'T&gt;" Usage="list.AsReadOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca tylko do odczytu <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> otoki dla bieżącej kolekcji.</summary>
        <returns>Obiekt, który działa jako tylko do odczytu otokę bieżącego <see cref="T:System.Collections.Generic.List`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby zapobiec wszelkie modyfikacje <xref:System.Collections.Generic.List%601> obiektów, udostępnić go tylko za pośrednictwem tej otoki. A <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> obiekt nie ujawnia metody, które modyfikują kolekcji. Jednak jeśli zmiany zostały wprowadzone w podstawowych <xref:System.Collections.Generic.List%601> obiektów i kolekcji tylko do odczytu odzwierciedla te zmiany.  
  
 Ta metoda jest operacją O(1).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Collections.Generic.List%601.AsReadOnly%2A> metody. A <xref:System.Collections.Generic.List%601> ciągów o pojemności 4 został utworzony, ponieważ rozmiar ultimate listy jest znany jako dokładnie 4. Listy jest wypełniane przy użyciu czterech ciągów i <xref:System.Collections.Generic.List%601.AsReadOnly%2A> metody jest używany do pobierania tylko do odczytu <xref:System.Collections.Generic.IList%601> implementacji interfejsu ogólnego, który opakowuje oryginalnej listy.  
  
 Element oryginalnej listy jest ustawiony na "Coelophysis" przy użyciu <xref:System.Collections.Generic.List%601.Item%2A> właściwości (indeksator w języku C#) i pozycje na liście tylko do odczytu są wyświetlane ponownie aby wykazać, że jest on tylko otoki dla oryginalnej listy.  
  
 [!code-cpp[List\`1_AsReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_AsReadOnly/cpp/source.cpp#1)]
 [!code-csharp[List\`1_AsReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_AsReadOnly/cs/source.cs#1)]
 [!code-vb[List\`1_AsReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_AsReadOnly/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BinarySearch">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Używa algorytmu wyszukiwanie binarne można znaleźć określonego elementu w sortowanych <see cref="T:System.Collections.Generic.List`1" /> lub jego część.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public int BinarySearch (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 BinarySearch(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.BinarySearch(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function BinarySearch (item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int BinarySearch(T item);" />
      <MemberSignature Language="F#" Value="member this.BinarySearch : 'T -&gt; int" Usage="list.BinarySearch item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Obiekt do zlokalizowania. Wartość może być <see langword="null" /> dla typów odwołań.</param>
        <summary>Wyszukuje całą sortowane <see cref="T:System.Collections.Generic.List`1" /> dla elementu przy użyciu domyślna funkcja porównująca i zwraca liczony od zera indeks elementu.</summary>
        <returns>Liczony od zera indeks <paramref name="item" /> w sortowanych <see cref="T:System.Collections.Generic.List`1" />, jeśli <paramref name="item" /> zostanie odnaleziony; w przeciwnym razie wartość ujemna oznacza to numer dopełnienia bitowego indeksu elementu, który jest większy niż <paramref name="item" /> lub, jeśli jest nie większy element dopełnienia bitowego z <see cref="P:System.Collections.Generic.List`1.Count" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa domyślna funkcja porównująca <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> dla typu `T` do określania kolejności elementów listy. <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> Określa, czy typ sprawdzenia właściwości `T` implementuje <xref:System.IComparable%601> ogólny interfejs i wykorzystuje tę implementację, jeśli jest dostępna.  Jeśli nie, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> kontroli określa, czy typ `T` implementuje <xref:System.IComparable> interfejsu.  Jeśli typ `T` nie implementuje albo interfejsu <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> zgłasza <xref:System.InvalidOperationException>.  
  
 <xref:System.Collections.Generic.List%601> Już muszą być posortowane według wykonania porównania; w przeciwnym razie wynikiem jest niepoprawny.  
  
 Porównywanie `null` z odwołaniem do dowolnego typu jest dozwolone i nie generuje wyjątku, korzystając z <xref:System.IComparable%601> interfejs generyczny. Podczas sortowania, `null` jest uznawane za mniej niż jakiegokolwiek innego obiektu.  
  
 Jeśli <xref:System.Collections.Generic.List%601> zawiera więcej niż jeden element o tej samej wartości, metoda zwraca tylko jedno z wystąpień, a może zwrócić jeden wystąpień, niekoniecznie pierwsza z nich.  
  
 Jeśli <xref:System.Collections.Generic.List%601> nie zawiera określonej wartości, metoda zwraca całkowitą liczbą ujemną. Operacja dopełnienia bitowego (~) można zastosować do tego ujemnej liczby całkowitej. Aby uzyskać wartość indeksu pierwszego elementu, który jest większy niż wartość wyszukiwania. Podczas wstawiania wartości do <xref:System.Collections.Generic.List%601>, ten indeks powinien być używany jako punkt wstawiania do obsługi porządek sortowania.  
  
 Ta metoda jest O (dziennika *n*) operację, której *n* jest liczba elementów w zakresie.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Collections.Generic.List%601.Sort> przeciążenie metody i <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> przeciążenie metody. A <xref:System.Collections.Generic.List%601> ciągów jest tworzone i wypełniane przy użyciu czterech ciągów, w określonej kolejności. Listy jest wyświetlane, sortowania i ponownie wyświetlone.  
  
 <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> Przeciążenie metody jest następnie używany do wyszukiwania dwa ciągi, które nie są na liście i <xref:System.Collections.Generic.List%601.Insert%2A> metodę wstawić je. Wartość zwracana <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> metoda jest ujemna w każdym przypadku, ponieważ ciągi nie są na liście. Biorąc dopełnienia bitowego (~ operatora w języku C# i Visual C++ `Xor` -1 w języku Visual Basic) z tego ujemna tworzy numer indeksu pierwszego elementu listy, które jest większe niż ciąg wyszukiwania i wstawianie w tej lokalizacji zachowuje sortowania kolejność. Drugi ciąg wyszukiwania jest większy niż dowolny element na liście, tak aby pozycja wstawiania na końcu listy.  
  
 [!code-cpp[List\`1_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearch/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Domyślna funkcja porównująca <see cref="P:System.Collections.Generic.Comparer`1.Default" /> nie można znaleźć implementacji <see cref="T:System.IComparable`1" /> ogólny interfejs lub <see cref="T:System.IComparable" /> interfejs dla typu <paramref name="T" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public int BinarySearch (T item, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 BinarySearch(!T item, class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function BinarySearch (item As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int BinarySearch(T item, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="member this.BinarySearch : 'T * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; int" Usage="list.BinarySearch (item, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="item">Obiekt do zlokalizowania. Wartość może być <see langword="null" /> dla typów odwołań.</param>
        <param name="comparer">
          <see cref="T:System.Collections.Generic.IComparer`1" /> Wdrożenia do użycia podczas porównywania elementów.  - lub - <see langword="null" /> do używania domyślna funkcja porównująca <see cref="P:System.Collections.Generic.Comparer`1.Default" />.</param>
        <summary>Wyszukuje całą sortowane <see cref="T:System.Collections.Generic.List`1" /> dla elementu przy użyciu określona funkcja porównująca i zwraca liczony od zera indeks elementu.</summary>
        <returns>Liczony od zera indeks <paramref name="item" /> w sortowanych <see cref="T:System.Collections.Generic.List`1" />, jeśli <paramref name="item" /> zostanie odnaleziony; w przeciwnym razie wartość ujemna oznacza to numer dopełnienia bitowego indeksu elementu, który jest większy niż <paramref name="item" /> lub, jeśli jest nie większy element dopełnienia bitowego z <see cref="P:System.Collections.Generic.List`1.Count" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Moduł porównujący dostosowuje sposób porównywania elementów. Na przykład można użyć <xref:System.Collections.CaseInsensitiveComparer> wystąpienia jako modułu porównującego do wyszukiwania ciągów bez uwzględniania wielkości liter.  
  
 Jeśli `comparer` podano elementy <xref:System.Collections.Generic.List%601> są porównywane z podaną wartością przy użyciu określonego <xref:System.Collections.Generic.IComparer%601> implementacji.  
  
 Jeśli `comparer` jest `null`, domyślna funkcja porównująca <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> kontroli określa, czy typ `T` implementuje <xref:System.IComparable%601> ogólny interfejs i wykorzystuje tę implementację, jeśli jest dostępna.  Jeśli nie, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> kontroli określa, czy typ `T` implementuje <xref:System.IComparable> interfejsu.  Jeśli typ `T` nie implementuje albo interfejsu <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> zgłasza <xref:System.InvalidOperationException>.  
  
 <xref:System.Collections.Generic.List%601> Już muszą być posortowane według wykonania porównania; w przeciwnym razie wynikiem jest niepoprawny.  
  
 Porównywanie `null` z odwołaniem do dowolnego typu jest dozwolone i nie generuje wyjątku, korzystając z <xref:System.IComparable%601> interfejs generyczny. Podczas sortowania, `null` jest uznawane za mniej niż jakiegokolwiek innego obiektu.  
  
 Jeśli <xref:System.Collections.Generic.List%601> zawiera więcej niż jeden element o tej samej wartości, metoda zwraca tylko jedno z wystąpień, a może zwrócić jeden wystąpień, niekoniecznie pierwsza z nich.  
  
 Jeśli <xref:System.Collections.Generic.List%601> nie zawiera określonej wartości, metoda zwraca całkowitą liczbą ujemną. Operacja dopełnienia bitowego (~) można zastosować do tego ujemnej liczby całkowitej. Aby uzyskać wartość indeksu pierwszego elementu, który jest większy niż wartość wyszukiwania. Podczas wstawiania wartości do <xref:System.Collections.Generic.List%601>, ten indeks powinien być używany jako punkt wstawiania do obsługi porządek sortowania.  
  
 Ta metoda jest O (dziennika *n*) operację, której *n* jest liczba elementów w zakresie.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Collections.Generic.List%601.Sort%28System.Collections.Generic.IComparer%7B%600%7D%29> przeciążenie metody i <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> przeciążenie metody.  
  
 W przykładzie zdefiniowano alternatywnego porównania ciągów o nazwie DinoCompare, która implementuje `IComparer<string>` (`IComparer(Of String)` w języku Visual Basic `IComparer<String^>` w programie Visual C++) interfejs generyczny. Moduł porównujący działa w następujący sposób: najpierw comparands są sprawdzane pod kątem `null`, odwołanie o wartości null jest traktowany jako mniejsza niż inne niż null. Po drugie długości ciągu zostaną porównane, a ciąg dłuższy jest uważany większa. Trzecie Jeśli długości są takie same, porównania ciągów zwykłej jest używany.  
  
 A <xref:System.Collections.Generic.List%601> ciągów jest tworzone i wypełniane przy użyciu czterech ciągów, w określonej kolejności. Zostanie wyświetlona lista, posortowana przy użyciu alternatywnych porównania i wyświetlane ponownie.  
  
 <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> Przeciążenie metody jest następnie używany do wyszukiwania kilku ciągów, które są nie na liście wykorzystujących alternatywny porównania. <xref:System.Collections.Generic.List%601.Insert%2A> Metoda służy do wstawiania ciągi. Te dwie metody znajdują się w funkcji o nazwie `SearchAndInsert`, wraz z kodem podjęcie dopełnienia bitowego (~ operatora w języku C# i Visual C++ `Xor` -1 w języku Visual Basic) liczby ujemne zwracane przez <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> i używać go jako indeks Wstawianie nowych parametrów.  
  
 [!code-cpp[List\`1_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> jest <see langword="null" />, a domyślna funkcja porównująca <see cref="P:System.Collections.Generic.Comparer`1.Default" /> nie można znaleźć implementacji <see cref="T:System.IComparable`1" /> ogólny interfejs lub <see cref="T:System.IComparable" /> interfejs dla typu <paramref name="T" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public int BinarySearch (int index, int count, T item, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 BinarySearch(int32 index, int32 count, !T item, class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function BinarySearch (index As Integer, count As Integer, item As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int BinarySearch(int index, int count, T item, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="member this.BinarySearch : int * int * 'T * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; int" Usage="list.BinarySearch (index, count, item, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="item" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="index">Liczony od zera indeks początkowy zakresu wyszukiwania.</param>
        <param name="count">Długość zakresu wyszukiwania.</param>
        <param name="item">Obiekt do zlokalizowania. Wartość może być <see langword="null" /> dla typów odwołań.</param>
        <param name="comparer">
          <see cref="T:System.Collections.Generic.IComparer`1" /> Implementacji do używania przy porównywaniu elementy, lub <see langword="null" /> do używania domyślna funkcja porównująca <see cref="P:System.Collections.Generic.Comparer`1.Default" />.</param>
        <summary>Przeszukuje zakresu elementów sortowanych <see cref="T:System.Collections.Generic.List`1" /> dla elementu przy użyciu określona funkcja porównująca i zwraca liczony od zera indeks elementu.</summary>
        <returns>Liczony od zera indeks <paramref name="item" /> w sortowanych <see cref="T:System.Collections.Generic.List`1" />, jeśli <paramref name="item" /> zostanie odnaleziony; w przeciwnym razie wartość ujemna oznacza to numer dopełnienia bitowego indeksu elementu, który jest większy niż <paramref name="item" /> lub, jeśli jest nie większy element dopełnienia bitowego z <see cref="P:System.Collections.Generic.List`1.Count" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Moduł porównujący dostosowuje sposób porównywania elementów. Na przykład można użyć <xref:System.Collections.CaseInsensitiveComparer> wystąpienia jako modułu porównującego do wyszukiwania ciągów bez uwzględniania wielkości liter.  
  
 Jeśli `comparer` podano elementy <xref:System.Collections.Generic.List%601> są porównywane z podaną wartością przy użyciu określonego <xref:System.Collections.Generic.IComparer%601> implementacji.  
  
 Jeśli `comparer` jest `null`, domyślna funkcja porównująca <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> kontroli określa, czy typ `T` implementuje <xref:System.IComparable%601> ogólny interfejs i wykorzystuje tę implementację, jeśli jest dostępna.  Jeśli nie, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> kontroli określa, czy typ `T` implementuje <xref:System.IComparable> interfejsu.  Jeśli typ `T` nie implementuje albo interfejsu <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> zgłasza <xref:System.InvalidOperationException>.  
  
 <xref:System.Collections.Generic.List%601> Już muszą być posortowane według wykonania porównania; w przeciwnym razie wynikiem jest niepoprawny.  
  
 Porównywanie `null` z odwołaniem do dowolnego typu jest dozwolone i nie generuje wyjątku, korzystając z <xref:System.IComparable%601> interfejs generyczny. Podczas sortowania, `null` jest uznawane za mniej niż jakiegokolwiek innego obiektu.  
  
 Jeśli <xref:System.Collections.Generic.List%601> zawiera więcej niż jeden element o tej samej wartości, metoda zwraca tylko jedno z wystąpień, a może zwrócić jeden wystąpień, niekoniecznie pierwsza z nich.  
  
 Jeśli <xref:System.Collections.Generic.List%601> nie zawiera określonej wartości, metoda zwraca całkowitą liczbą ujemną. Operacja dopełnienia bitowego (~) można zastosować do tego ujemnej liczby całkowitej. Aby uzyskać wartość indeksu pierwszego elementu, który jest większy niż wartość wyszukiwania. Podczas wstawiania wartości do <xref:System.Collections.Generic.List%601>, ten indeks powinien być używany jako punkt wstawiania do obsługi porządek sortowania.  
  
 Ta metoda jest O (dziennika *n*) operację, której *n* jest liczba elementów w zakresie.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Collections.Generic.List%601.Sort%28System.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> przeciążenie metody i <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> przeciążenie metody.  
  
 W przykładzie zdefiniowano alternatywnego porównania ciągów o nazwie DinoCompare, która implementuje `IComparer<string>` (`IComparer(Of String)` w języku Visual Basic `IComparer<String^>` w programie Visual C++) interfejs generyczny. Moduł porównujący działa w następujący sposób: najpierw comparands są sprawdzane pod kątem `null`, odwołanie o wartości null jest traktowany jako mniejsza niż inne niż null. Po drugie długości ciągu zostaną porównane, a ciąg dłuższy jest uważany większa. Trzecie Jeśli długości są takie same, porównania ciągów zwykłej jest używany.  
  
 A <xref:System.Collections.Generic.List%601> ciągów jest tworzone i wypełniane przy użyciu nazwy pięć dinozaurów herbivorous i trzy dinozaurów mięsożernych zwierząt. W ramach każdej z tych dwóch grup nazwy nie są w dowolnej kolejności określonego sortowania. Zostanie wyświetlona lista, zakres zwierząt roślinożernych są sortowane przy użyciu alternatywnych porównania i ponownie zostanie wyświetlona lista.  
  
 <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> Przeciążenie metody jest następnie używany do wyszukiwania tylko zakres zwierząt roślinożernych "Brachiosaurus". Ciąg nie zostanie znaleziony i dopełnienia bitowego (~ operatora w języku C# i Visual C++ `Xor` -1 w języku Visual Basic) liczby ujemne zwracane przez <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> metoda jest używana jako indeks wstawiania nowych parametrów.  
  
 [!code-cpp[List\`1_SortSearchComparerRange#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparerRange#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparerRange#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparerRange/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza niż 0.  - lub - <paramref name="count" /> jest mniejszy niż 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> i <paramref name="count" /> określa nieprawidłowy zakres w <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> jest <see langword="null" />, a domyślna funkcja porównująca <see cref="P:System.Collections.Generic.Comparer`1.Default" /> nie można znaleźć implementacji <see cref="T:System.IComparable`1" /> ogólny interfejs lub <see cref="T:System.IComparable" /> interfejs dla typu <paramref name="T" />.</exception>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.Capacity" />
      <MemberSignature Language="VB.NET" Value="Public Property Capacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Capacity { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Capacity : int with get, set" Usage="System.Collections.Generic.List&lt;'T&gt;.Capacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia całkowitą liczbę elementów, które może przechowywać struktury danych wewnętrznych, bez zmiany rozmiaru.</summary>
        <value>Liczba elementów który <see cref="T:System.Collections.Generic.List`1" /> może zawierać przed rozmiaru jest wymagana.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601.Capacity%2A> Liczba elementów jest który <xref:System.Collections.Generic.List%601> może przechowywać przed rozmiaru jest wymagany, podczas gdy <xref:System.Collections.Generic.List%601.Count%2A> jest liczba elementów, które są rzeczywiście w <xref:System.Collections.Generic.List%601>.  
  
 <xref:System.Collections.Generic.List%601.Capacity%2A> zawsze jest większa niż lub równa <xref:System.Collections.Generic.List%601.Count%2A>. Jeśli <xref:System.Collections.Generic.List%601.Count%2A> przekracza <xref:System.Collections.Generic.List%601.Capacity%2A> podczas dodawania elementów, pojemność zwiększa się o automatyczne ponowne przydzielanie tablicy wewnętrznej przed skopiowaniem starych elementów i dodawanie nowych elementów.  
  
 Jeśli pojemność jest znacznie większa niż liczba i chcesz zmniejszyć pamięci używanej przez <xref:System.Collections.Generic.List%601>, można zmniejszyć pojemność przez wywołanie metody <xref:System.Collections.Generic.List%601.TrimExcess%2A> — metoda lub przez ustawienie <xref:System.Collections.Generic.List%601.Capacity%2A> właściwości jawnie na niższą wartość. Jeśli wartość <xref:System.Collections.Generic.List%601.Capacity%2A> jest ustawiona, jawnie, aby zmieścił się w określonej pojemności także alokowaniu tablicy wewnętrznej, a wszystkie elementy są kopiowane.  
  
 Pobieranie wartości tej właściwości jest operacją O(1); Ustawienie właściwości jest O (*n*) operację, której *n* jest nowego miejsca.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób sprawdzania zdolności produkcyjnych i liczba <xref:System.Collections.Generic.List%601> zawiera obiekt biznesowy proste i przedstawia przy użyciu <xref:System.Collections.Generic.List%601.TrimExcess%2A> metodę, aby usunąć dodatkowej pojemności.  
  
 [!code-csharp[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/vb/module1.vb#1)]  
  
 W poniższym przykładzie przedstawiono <xref:System.Collections.Generic.List%601.Capacity%2A> właściwości w kilku miejscach życia listy. Domyślny konstruktor jest używany do tworzenia listy ciągów o pojemności 0 i <xref:System.Collections.Generic.List%601.Capacity%2A> właściwość jest wyświetlana, aby pokazać to. Po <xref:System.Collections.Generic.List%601.Add%2A> metoda została już użyta do dodawania elementów kilka, elementy podrzędne są wyświetlane, a następnie <xref:System.Collections.Generic.List%601.Capacity%2A> właściwości zostanie wyświetlony ponownie, wraz z <xref:System.Collections.Generic.List%601.Count%2A> właściwości, aby pokazać, że pojemność została zwiększona, zgodnie z potrzebami.  
  
 <xref:System.Collections.Generic.List%601.Capacity%2A> Właściwości jest wyświetlany ponownie po <xref:System.Collections.Generic.List%601.TrimExcess%2A> metoda jest używana do zmniejszenia wydajności, aby być zgodna z liczbą. Na koniec <xref:System.Collections.Generic.List%601.Clear%2A> — metoda jest używana do usuwania wszystkich elementów na liście i <xref:System.Collections.Generic.List%601.Capacity%2A> i <xref:System.Collections.Generic.List%601.Count%2A> ponownie wyświetlić właściwości.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <see cref="P:System.Collections.Generic.List`1.Capacity" /> ma ustawioną wartość, która jest mniejsza niż <see cref="P:System.Collections.Generic.List`1.Count" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Nie istnieje wystarczająca ilość pamięci dostępna w systemie.</exception>
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="list.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Clear</InterfaceMember>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa wszystkie elementy z <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601.Count%2A> ma wartość 0, a ponadto są również zwalniane odwołania do innych obiektów z elementów kolekcji.  
  
 <xref:System.Collections.Generic.List%601.Capacity%2A> pozostaje niezmieniona. Aby zresetować pojemność <xref:System.Collections.Generic.List%601>, wywołaj <xref:System.Collections.Generic.List%601.TrimExcess%2A> metody lub zestawu <xref:System.Collections.Generic.List%601.Capacity%2A> właściwości bezpośrednio. Zmniejszania pojemności przydziela ponownie pamięci i kopiuje wszystkie elementy w <xref:System.Collections.Generic.List%601>. Przycinanie pustą <xref:System.Collections.Generic.List%601> ustawia pojemność <xref:System.Collections.Generic.List%601> do wydajności domyślnej.  
  
 Ta metoda jest O (*n*) operację, której *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Collections.Generic.List%601.Clear%2A> — metoda i różnych innych właściwości i metody <xref:System.Collections.Generic.List%601> klasy ogólnej. <xref:System.Collections.Generic.List%601.Clear%2A> Metoda jest używana w końcu program, aby usunąć wszystkie elementy z listy i <xref:System.Collections.Generic.List%601.Capacity%2A> i <xref:System.Collections.Generic.List%601.Count%2A> są następnie wyświetlić właściwości.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.TrimExcess" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Contains(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(T item);" />
      <MemberSignature Language="F#" Value="abstract member Contains : 'T -&gt; bool&#xA;override this.Contains : 'T -&gt; bool" Usage="list.Contains item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Obiekt do zlokalizowania w <see cref="T:System.Collections.Generic.List`1" />. Wartość może być <see langword="null" /> dla typów odwołań.</param>
        <summary>Określa, czy element jest <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="item" /> znajduje się w <see cref="T:System.Collections.Generic.List`1" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda określa równości przy użyciu domyślna funkcja porównująca równości, zgodnie z definicją w implementacji obiektu <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> metodę `T` (typ wartości na liście).  
  
 Ta metoda wykonuje wyszukiwanie liniowe; w związku z tym ta metoda jest O (*n*) operację, której *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Collections.Generic.List%601.Contains%2A> i <xref:System.Collections.Generic.List%601.Exists%2A> metod <xref:System.Collections.Generic.List%601> zawiera obiekt proste biznesowych, który implementuje <xref:System.IEquatable%601.Equals%2A>.  
  
 [!code-csharp[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/vb/module1.vb#1)]  
  
 Poniżej przedstawiono przykład zawierający listę obiektu złożonego typu `Cube`. `Cube` Klasa implementuje <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> metody, aby dwa moduły są traktowane jako równe, jeśli ich wymiary są takie same. W tym przykładzie <xref:System.Collections.Generic.List%601.Contains%2A> metoda zwraca `true`, ponieważ moduł, który ma określony wymiarów znajduje się już w kolekcji.  
  
 [!code-csharp[System.Collections.Generic.List.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.contains/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.contains/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
      </Docs>
    </Member>
    <Member MemberName="ConvertAll&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;TOutput&gt; ConvertAll&lt;TOutput&gt; (Converter&lt;T,TOutput&gt; converter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;!!TOutput&gt; ConvertAll&lt;TOutput&gt;(class System.Converter`2&lt;!T, !!TOutput&gt; converter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.ConvertAll``1(System.Converter{`0,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function ConvertAll(Of TOutput) (converter As Converter(Of T, TOutput)) As List(Of TOutput)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA; System::Collections::Generic::List&lt;TOutput&gt; ^ ConvertAll(Converter&lt;T, TOutput&gt; ^ converter);" />
      <MemberSignature Language="F#" Value="member this.ConvertAll : Converter&lt;'T, 'Output&gt; -&gt; System.Collections.Generic.List&lt;'Output&gt;" Usage="list.ConvertAll converter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;TOutput&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="converter" Type="System.Converter&lt;T,TOutput&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">Typ elementów tablicy docelowej.</typeparam>
        <param name="converter">A <see cref="T:System.Converter`2" /> delegata, który konwertuje każdy element z jednego typu do innego typu.</param>
        <summary>Konwertuje elementów w bieżącym <see cref="T:System.Collections.Generic.List`1" /> do innego typu i zwraca listę zawierającą elementy przekonwertowany.</summary>
        <returns>A <see cref="T:System.Collections.Generic.List`1" /> typu docelowego zawierających elementy przekonwertowany z bieżącego <see cref="T:System.Collections.Generic.List`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Converter%602> Jest delegowany do metody, która konwertuje obiektu na typ docelowy.  Elementy bieżącego <xref:System.Collections.Generic.List%601> indywidualnie są przekazywane do <xref:System.Converter%602> delegata i przekonwertowane elementy są zapisywane w nowym <xref:System.Collections.Generic.List%601>.  
  
 Bieżący <xref:System.Collections.Generic.List%601> pozostaje niezmieniona.  
  
 Ta metoda jest O (*n*) operację, której *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano metodę o nazwie `PointFToPoint` konwertująca <xref:System.Drawing.PointF> struktury do <xref:System.Drawing.Point> struktury. Następnie tworzony <xref:System.Collections.Generic.List%601> z <xref:System.Drawing.PointF> struktury, tworzy `Converter\<PointF, Point>` delegować (`Converter(Of PointF, Point)` w języku Visual Basic) do reprezentowania `PointFToPoint` metody i przekazuje pełnomocnika, aby <xref:System.Collections.Generic.List%601.ConvertAll%2A> metody. <xref:System.Collections.Generic.List%601.ConvertAll%2A> Metoda przekazuje każdy element na liście wejściowej, aby `PointFToPoint` — metoda i umieszcza przekonwertowanego elementy do nowej listy <xref:System.Drawing.Point> struktury. Zarówno listy są wyświetlane.  
  
 [!code-cpp[List\`1_ConvertAll#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_ConvertAll/cpp/source.cpp#1)]
 [!code-csharp[List\`1_ConvertAll#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_ConvertAll/cs/source.cs#1)]
 [!code-vb[List\`1_ConvertAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_ConvertAll/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="converter" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Converter`2" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kopie <see cref="T:System.Collections.Generic.List`1" /> lub jego części bez upoważnienia do tablicy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.CopyTo(`0[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : 'T[] -&gt; unit" Usage="list.CopyTo array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <param name="array">Jednowymiarowa <see cref="T:System.Array" /> który jest miejscem docelowym elementów kopiowanych z <see cref="T:System.Collections.Generic.List`1" />. <see cref="T:System.Array" /> Musi mieć indeksowania liczony od zera.</param>
        <summary>Kopiuje całą <see cref="T:System.Collections.Generic.List`1" /> do zgodne jednowymiarowej tablicy, zaczynając od początku tablicy docelowej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa <xref:System.Array.Copy%2A?displayProperty=nameWithType> można skopiować elementów.  
  
 Elementy są kopiowane do <xref:System.Array> w tej samej kolejności, w której moduł wyliczający iteruje <xref:System.Collections.Generic.List%601>.  
  
 Ta metoda jest O (*n*) operację, której *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano wszystkich trzech przeciążeń <xref:System.Collections.Generic.List%601.CopyTo%2A> metody. A <xref:System.Collections.Generic.List%601> ciągów jest tworzone i wypełniane przy użyciu ciągów 5. Tablica elementów 15 pusty ciąg jest tworzony i <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%29> przeciążenie metody jest używany do skopiowania wszystkich elementów listy do tablicy, począwszy od pierwszego elementu tablicy. <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%2CSystem.Int32%29> Przeciążenie metody służy do skopiować wszystkie elementy listy do tablicy, począwszy od indeksu tablicy 6 (zostawianie pusty indeksu 5). Na koniec <xref:System.Collections.Generic.List%601.CopyTo%28System.Int32%2C%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> przeciążenie metody są używane do skopiowania 3 elementy z listy, począwszy od indeksu 2, na początek tablicy w tablicy indeksu 12 (zostawianie indeksu 11 pusta). Następnie jest wyświetlana zawartość tablicy.  
  
 [!code-cpp[List\`1_CopyTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_CopyTo/cpp/source.cpp#1)]
 [!code-csharp[List\`1_CopyTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_CopyTo/cs/source.cs#1)]
 [!code-vb[List\`1_CopyTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_CopyTo/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Liczba elementów w źródle <see cref="T:System.Collections.Generic.List`1" /> jest większa niż liczba elementów który docelowego <paramref name="array" /> może zawierać.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(!T[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.CopyTo(`0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T(), arrayIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(cli::array &lt;T&gt; ^ array, int arrayIndex);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : 'T[] * int -&gt; unit&#xA;override this.CopyTo : 'T[] * int -&gt; unit" Usage="list.CopyTo (array, arrayIndex)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Jednowymiarowa <see cref="T:System.Array" /> który jest miejscem docelowym elementów kopiowanych z <see cref="T:System.Collections.Generic.List`1" />. <see cref="T:System.Array" /> Musi mieć indeksowania liczony od zera.</param>
        <param name="arrayIndex">Liczony od zera indeks w <c>tablicy</c> od rozpoczyna się kopiowanie które.</param>
        <summary>Kopiuje całą <see cref="T:System.Collections.Generic.List`1" /> do zgodne jednowymiarowej tablicy, zaczynając od określonego indeksu tablicy docelowej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa <xref:System.Array.Copy%2A?displayProperty=nameWithType> można skopiować elementów.  
  
 Elementy są kopiowane do <xref:System.Array> w tej samej kolejności, w której moduł wyliczający iteruje <xref:System.Collections.Generic.List%601>.  
  
 Ta metoda jest O (*n*) operację, której *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano wszystkich trzech przeciążeń <xref:System.Collections.Generic.List%601.CopyTo%2A> metody. A <xref:System.Collections.Generic.List%601> ciągów jest tworzone i wypełniane przy użyciu ciągów 5. Tablica elementów 15 pusty ciąg jest tworzony i <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%29> przeciążenie metody jest używany do skopiowania wszystkich elementów listy do tablicy, począwszy od pierwszego elementu tablicy. <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%2CSystem.Int32%29> Przeciążenie metody służy do skopiować wszystkie elementy listy do tablicy, począwszy od indeksu tablicy 6 (zostawianie pusty indeksu 5). Na koniec <xref:System.Collections.Generic.List%601.CopyTo%28System.Int32%2C%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> przeciążenie metody są używane do skopiowania 3 elementy z listy, począwszy od indeksu 2, na początek tablicy w tablicy indeksu 12 (zostawianie indeksu 11 pusta). Następnie jest wyświetlana zawartość tablicy.  
  
 [!code-cpp[List\`1_CopyTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_CopyTo/cpp/source.cpp#1)]
 [!code-csharp[List\`1_CopyTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_CopyTo/cs/source.cs#1)]
 [!code-vb[List\`1_CopyTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_CopyTo/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="arrayIndex" /> jest mniejsza niż 0.</exception>
        <exception cref="T:System.ArgumentException">Liczba elementów w źródle <see cref="T:System.Collections.Generic.List`1" /> jest większa niż dostępne miejsce od <paramref name="arrayIndex" /> do końca tablicy docelowej <paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int index, T[] array, int arrayIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 index, !T[] array, int32 arrayIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (index As Integer, array As T(), arrayIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int index, cli::array &lt;T&gt; ^ array, int arrayIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * 'T[] * int * int -&gt; unit" Usage="list.CopyTo (index, array, arrayIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Liczony od zera indeks w źródle <see cref="T:System.Collections.Generic.List`1" /> od rozpoczyna się kopiowanie które.</param>
        <param name="array">Jednowymiarowa <see cref="T:System.Array" /> który jest miejscem docelowym elementów kopiowanych z <see cref="T:System.Collections.Generic.List`1" />. <see cref="T:System.Array" /> Musi mieć indeksowania liczony od zera.</param>
        <param name="arrayIndex">Liczony od zera indeks w <c>tablicy</c> od rozpoczyna się kopiowanie które.</param>
        <param name="count">Liczba elementów do skopiowania.</param>
        <summary>Kopiuje elementy z zakresu <see cref="T:System.Collections.Generic.List`1" /> do zgodne jednowymiarowej tablicy, zaczynając od określonego indeksu tablicy docelowej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa <xref:System.Array.Copy%2A?displayProperty=nameWithType> można skopiować elementów.  
  
 Elementy są kopiowane do <xref:System.Array> w tej samej kolejności, w której moduł wyliczający iteruje <xref:System.Collections.Generic.List%601>.  
  
 Ta metoda jest O (*n*) operację, której *n* jest `count`.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano wszystkich trzech przeciążeń <xref:System.Collections.Generic.List%601.CopyTo%2A> metody. A <xref:System.Collections.Generic.List%601> ciągów jest tworzone i wypełniane przy użyciu ciągów 5. Tablica elementów 15 pusty ciąg jest tworzony i <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%29> przeciążenie metody jest używany do skopiowania wszystkich elementów listy do tablicy, począwszy od pierwszego elementu tablicy. <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%2CSystem.Int32%29> Przeciążenie metody służy do skopiować wszystkie elementy listy do tablicy, począwszy od indeksu tablicy 6 (zostawianie pusty indeksu 5). Na koniec <xref:System.Collections.Generic.List%601.CopyTo%28System.Int32%2C%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> przeciążenie metody są używane do skopiowania 3 elementy z listy, począwszy od indeksu 2, na początek tablicy w tablicy indeksu 12 (zostawianie indeksu 11 pusta). Następnie jest wyświetlana zawartość tablicy.  
  
 [!code-cpp[List\`1_CopyTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_CopyTo/cpp/source.cpp#1)]
 [!code-csharp[List\`1_CopyTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_CopyTo/cs/source.cs#1)]
 [!code-vb[List\`1_CopyTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_CopyTo/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza niż 0.  - lub - <paramref name="arrayIndex" /> jest mniejszy niż 0.  - lub - <paramref name="count" /> jest mniejszy niż 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> jest równa lub większa niż <see cref="P:System.Collections.Generic.List`1.Count" /> źródła <see cref="T:System.Collections.Generic.List`1" />.  - lub - liczba elementów od <paramref name="index" /> koniec źródło <see cref="T:System.Collections.Generic.List`1" /> jest większa niż dostępne miejsce od <paramref name="arrayIndex" /> do końca tablicy docelowej <paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.Generic.List&lt;'T&gt;.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyCollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę elementów zawartych w <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <value>Liczba elementów zawartych w <see cref="T:System.Collections.Generic.List`1" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601.Capacity%2A> Liczba elementów jest który <xref:System.Collections.Generic.List%601> może przechowywać przed rozmiaru jest wymagana. <xref:System.Collections.Generic.List%601.Count%2A> jest to liczba elementów, które są rzeczywiście w <xref:System.Collections.Generic.List%601>.  
  
 <xref:System.Collections.Generic.List%601.Capacity%2A> zawsze jest większa niż lub równa <xref:System.Collections.Generic.List%601.Count%2A>. Jeśli <xref:System.Collections.Generic.List%601.Count%2A> przekracza <xref:System.Collections.Generic.List%601.Capacity%2A> podczas dodawania elementów, pojemność zwiększa się o automatyczne ponowne przydzielanie tablicy wewnętrznej przed skopiowaniem starych elementów i dodawanie nowych elementów.  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób sprawdzania zdolności produkcyjnych i liczba <xref:System.Collections.Generic.List%601> zawiera obiekt biznesowy proste i przedstawia przy użyciu <xref:System.Collections.Generic.List%601.TrimExcess%2A> metodę, aby usunąć dodatkowej pojemności.  
  
 [!code-csharp[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/vb/module1.vb#1)]  
  
 W poniższym przykładzie przedstawiono wartości <xref:System.Collections.Generic.List%601.Count%2A> właściwości na różnych etapach życia listy. Po liście został utworzony i wypełnione i jego elementy wyświetlane, <xref:System.Collections.Generic.List%601.Capacity%2A> i <xref:System.Collections.Generic.List%601.Count%2A> właściwości są wyświetlane. Te właściwości są wyświetlane ponownie po <xref:System.Collections.Generic.List%601.TrimExcess%2A> metoda została wywołana i ponownie po zawartości listy są usuwane.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public bool Exists (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Exists(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Exists (match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Exists(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.Exists : Predicate&lt;'T&gt; -&gt; bool" Usage="list.Exists match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">
          <see cref="T:System.Predicate`1" /> Delegat definiujący warunki elementu do wyszukania.</param>
        <summary>Określa, czy <see cref="T:System.Collections.Generic.List`1" /> zawiera elementy odpowiadające warunkom zdefiniowanym przez określony predykat.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="T:System.Collections.Generic.List`1" /> zawiera jeden lub więcej elementów, które pasują do warunków zdefiniowanych przez określony predykat; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601> Jest delegowany do metody, która zwraca `true` obiekt przekazywany do jest zgodne z warunkami określonymi w delegacie.  Elementy bieżącego <xref:System.Collections.Generic.List%601> indywidualnie są przekazywane do <xref:System.Predicate%601> delegata i przetwarzania jest zatrzymana po znalezieniu dopasowania.  
  
 Ta metoda wykonuje wyszukiwanie liniowe; w związku z tym ta metoda jest O (*n*) operację, której *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Collections.Generic.List%601.Contains%2A> i <xref:System.Collections.Generic.List%601.Exists%2A> metod <xref:System.Collections.Generic.List%601> zawiera obiekt proste biznesowych, który implementuje <xref:System.IEquatable%601.Equals%2A>.  
  
 [!code-csharp[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/vb/module1.vb#1)]  
  
 W poniższym przykładzie pokazano <xref:System.Collections.Generic.List%601.Exists%2A> — metoda i kilka innych metod, które używają <xref:System.Predicate%601> Delegat ogólny.  
  
 A <xref:System.Collections.Generic.List%601> ciągów jest tworzony, zawierający 8 nazwy kolorowanka, z których (na pozycji 1 do 5) dwa kończyć się "saurus". W przykładzie zdefiniowano również metody predykatu wyszukiwania o nazwie `EndsWithSaurus`, który akceptuje parametr typu string i zwraca wartość typu Boolean wartość wskazującą, czy ciąg wejściowy kończy się na "saurus".  
  
 <xref:System.Collections.Generic.List%601.Find%2A>, <xref:System.Collections.Generic.List%601.FindLast%2A>, I <xref:System.Collections.Generic.List%601.FindAll%2A> metody są używane do wyszukiwania na liście przy użyciu metody predykatu wyszukiwania, a następnie <xref:System.Collections.Generic.List%601.RemoveAll%2A> metoda jest używana do usuwania wszystkich wpisów, które kończą się ciągiem "saurus".  
  
 Na koniec <xref:System.Collections.Generic.List%601.Exists%2A> metoda jest wywoływana. Wzdłuż od początku, przekazywanie kolejno do każdego elementu listy `EndsWithSaurus` metody. Zatrzymuje wyszukiwania i zwraca metoda `true` Jeśli `EndsWithSaurus` metoda zwraca `true` dla każdego elementu. <xref:System.Collections.Generic.List%601.Exists%2A> Metoda zwraca `false` ponieważ wszystkie elementy zostały usunięte.  
  
> [!NOTE]
>  W języku C# i Visual Basic, nie jest konieczne tworzenie `Predicate<string>` delegować (`Predicate(Of String)` w języku Visual Basic) jawnie. Te języki wnioskują o poprawnym delegacie z kontekstu, a następnie są tworzone automatycznie.  
  
 [!code-cpp[List\`1_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[List\`1_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_FindEtAl/cs/source.cs#1)]
 [!code-vb[List\`1_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public T Find (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T Find(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T Find(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.Find : Predicate&lt;'T&gt; -&gt; 'T" Usage="list.Find match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">
          <see cref="T:System.Predicate`1" /> Delegat definiujący warunki elementu do wyszukania.</param>
        <summary>Wyszukuje element, który pasuje do warunków zdefiniowanych przez określony predykat i zwraca pierwsze wystąpienie w ramach całego <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>Pierwszy element, który pasuje do warunków zdefiniowanych przez określony predykat, gdy znaleziono; w przeciwnym razie wartość domyślna dla typu <paramref name="T" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601> Jest delegowany do metody, która zwraca `true` obiekt przekazywany do jest zgodne z warunkami określonymi w delegacie.  Elementy bieżącego <xref:System.Collections.Generic.List%601> indywidualnie są przekazywane do <xref:System.Predicate%601> delegata, przenoszenie do przodu w <xref:System.Collections.Generic.List%601>, rozpoczynając od pierwszego elementu i kończąc ostatnim elemencie.  Przetwarzanie zostało zatrzymane po znalezieniu dopasowania.  
  
> [!IMPORTANT]
>  Podczas wyszukiwania lista zawierająca typy wartości, upewnij się, że wartość domyślna dla typu nie spełnia predykatu wyszukiwania. W przeciwnym razie nie istnieje sposób odróżnić domyślną wartość wskazującą, że nie znaleziono dopasowania elementu listy, która ma wartości domyślnej dla typu. Jeśli wartość domyślna spełnia predykatu wyszukiwania, użyj <xref:System.Collections.Generic.List%601.FindIndex%2A> metody zamiast tego.  
  
 Ta metoda wykonuje wyszukiwanie liniowe; w związku z tym ta metoda jest O (*n*) operację, której *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Collections.Generic.List%601.Find%2A> metoda <xref:System.Collections.Generic.List%601> zawierający prosty obiekt złożony.  
  
 [!code-csharp[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/vb/module1.vb#1)]  
  
 W poniższym przykładzie pokazano metody Znajdź <xref:System.Collections.Generic.List%601> klasy. Przykład <xref:System.Collections.Generic.List%601> klasa zawiera `book` obiektów klasy `Book`, przy użyciu danych z [przykładowego pliku XML: książek (LINQ do XML)](http://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). `FillList` Używa metody w tym przykładzie [LINQ do XML](http://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) można przeanalizować wartości z pliku XML do wartości właściwości `book` obiektów.  
  
 W poniższej tabeli opisano przykłady podane dla metody find.  
  
|Metoda|Przykład|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Wyszukuje książki za pomocą Identyfikatora `IDToFind` predykatu delegata.<br /><br /> C# przykładzie użyto anonimowego obiektu delegowanego.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Znajdź wszystkie tego którego książki `Genre` właściwość jest "Komputer" przy użyciu `FindComputer` predykatu delegata.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Znajduje ostatni książki w kolekcji zawierającej daty publikowania przed 2001 przy użyciu `PubBefore2001` predykatu delegata.<br /><br /> C# przykładzie użyto anonimowego obiektu delegowanego.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Znajduje indeks pierwszego książki komputera przy użyciu `FindComputer` predykatu delegata.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Znajduje indeks ostatni komputer książki przy użyciu `FindComputer` predykatu delegata.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Znajduje indeks pierwszego książki komputera w ciągu sekundy połowy kolekcji, przy użyciu `FindComputer` predykatu delegata.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Znajduje indeks ostatniego książki komputera w ciągu sekundy połowy kolekcji, przy użyciu `FindComputer` predykatu delegata.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindAll">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;T&gt; FindAll (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;!T&gt; FindAll(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindAll (match As Predicate(Of T)) As List(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;T&gt; ^ FindAll(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindAll : Predicate&lt;'T&gt; -&gt; System.Collections.Generic.List&lt;'T&gt;" Usage="list.FindAll match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">
          <see cref="T:System.Predicate`1" /> Delegat definiujący warunki elementu do wyszukania.</param>
        <summary>Pobiera wszystkie elementy odpowiadające warunkom zdefiniowanym przez określony predykat.</summary>
        <returns>A <see cref="T:System.Collections.Generic.List`1" /> zawierający wszystkie elementy zgodnych warunki zdefiniowane przez określony predykat, jeśli je znaleziono; w przeciwnym razie, pustą <see cref="T:System.Collections.Generic.List`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601> Jest delegowany do metody, która zwraca `true` obiekt przekazywany do jest zgodne z warunkami określonymi w delegacie.  Elementy bieżącego <xref:System.Collections.Generic.List%601> indywidualnie są przekazywane do <xref:System.Predicate%601> delegata i elementy, które spełniają podane są zapisywane w zwróconym <xref:System.Collections.Generic.List%601>.  
  
 Ta metoda wykonuje wyszukiwanie liniowe; w związku z tym ta metoda jest O (*n*) operację, której *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano metody Znajdź <xref:System.Collections.Generic.List%601> klasy. Przykład <xref:System.Collections.Generic.List%601> klasa zawiera `book` obiektów klasy `Book`, przy użyciu danych z [przykładowego pliku XML: książek (LINQ do XML)](http://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). `FillList` Używa metody w tym przykładzie [LINQ do XML](http://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) można przeanalizować wartości z pliku XML do wartości właściwości `book` obiektów.  
  
 W poniższej tabeli opisano przykłady podane dla metody find.  
  
|Metoda|Przykład|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Wyszukuje książki za pomocą Identyfikatora `IDToFind` predykatu delegata.<br /><br /> C# przykładzie użyto anonimowego obiektu delegowanego.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Znajdź wszystkie tego którego książki `Genre` właściwość jest "Komputer" przy użyciu `FindComputer` predykatu delegata.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Znajduje ostatni książki w kolekcji zawierającej daty publikowania przed 2001 przy użyciu `PubBefore2001` predykatu delegata.<br /><br /> C# przykładzie użyto anonimowego obiektu delegowanego.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Znajduje indeks pierwszego książki komputera przy użyciu `FindComputer` predykatu delegata.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Znajduje indeks ostatni komputer książki przy użyciu `FindComputer` predykatu delegata.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Znajduje indeks pierwszego książki komputera w ciągu sekundy połowy kolekcji, przy użyciu `FindComputer` predykatu delegata.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Znajduje indeks ostatniego książki komputera w ciągu sekundy połowy kolekcji, przy użyciu `FindComputer` predykatu delegata.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindIndex">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wyszukuje element, który pasuje do warunków zdefiniowanych przez określony predykat i zwraca liczony od zera indeks pierwszego wystąpienia w <see cref="T:System.Collections.Generic.List`1" /> lub jego część. Ta metoda zwraca wartość -1, jeśli nie zostanie znaleziony element, który spełnia warunki.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindIndex">
      <MemberSignature Language="C#" Value="public int FindIndex (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindIndex(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindIndex(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindIndex (match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindIndex(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindIndex : Predicate&lt;'T&gt; -&gt; int" Usage="list.FindIndex match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">
          <see cref="T:System.Predicate`1" /> Delegat definiujący warunki elementu do wyszukania.</param>
        <summary>Wyszukuje element, który pasuje do warunków zdefiniowanych przez określony predykat i zwraca liczony od zera indeks pierwszego wystąpienia w obrębie całej <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>Liczony od zera indeks pierwszego wystąpienia elementu, który pasuje do warunków zdefiniowanych przez <paramref name="match" />, jeśli je znaleziono; w przeciwnym razie wartość -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> Przeszukiwany jest do przodu zaczynając od pierwszego elementu i końcowy z ostatniego elementu.  
  
 <xref:System.Predicate%601> Jest delegowany do metody, która zwraca `true` obiekt przekazywany do jest zgodne z warunkami określonymi w delegacie.  Elementy bieżącego <xref:System.Collections.Generic.List%601> indywidualnie są przekazywane do <xref:System.Predicate%601> delegowanie. Delegat ma podpis:  
  
```csharp  
public bool methodName(T obj)  
```  
  
```vb  
Public Function methodName(obj As T) As Boolean  
```  
  
 Ta metoda wykonuje wyszukiwanie liniowe; w związku z tym ta metoda jest O (*n*) operację, której *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano `Employee` klasy z polami dwóch `Name` i `Id`. Definiuje także `EmployeeSearch` klasy z jedną metodę `StartsWith`, który wskazuje, czy `Employee.Name` pola rozpoczyna się od określonego podciągu, który został dostarczony do `EmployeeSearch` konstruktora klasy. Uwaga sygnatury tej metody  
  
```csharp  
public bool StartsWith(Employee e)  
```  
  
```vb  
Public Function StartsWith(e As Employee) As Boolean  
```  
  
 odpowiada podpisu delegata, który może zostać przekazany do <xref:System.Collections.Generic.List%601.FindIndex%2A> metody. Przykład tworzy `List<Employee>` obiektów, dodaje szereg `Employee` objets go, a następnie wywołania <xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29> metody dwa razy, aby przeszukać całą kolekcję po raz pierwszy w pierwszym `Employee` którego `Name` pola rozpoczyna się "J" i drugim w pierwszym `Employee` którego `Name` pola rozpoczyna się od "Ju".  
  
 [!code-csharp[System.Collections.Generic.List.FindIndex#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/cs/FindIndex2.cs#2)]
 [!code-vb[System.Collections.Generic.List.FindIndex#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/vb/FindIndex2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex">
      <MemberSignature Language="C#" Value="public int FindIndex (int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindIndex(int32 startIndex, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindIndex (startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindIndex(int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindIndex : int * Predicate&lt;'T&gt; -&gt; int" Usage="list.FindIndex (startIndex, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">Wartość początkowa indeksu zaczynającego się od zera dla wyszukiwania.</param>
        <param name="match">
          <see cref="T:System.Predicate`1" /> Delegat definiujący warunki elementu do wyszukania.</param>
        <summary>Wyszukuje element, który pasuje do warunków zdefiniowanych przez określony predykat i zwraca liczony od zera indeks pierwszego wystąpienia w zakresie elementów w <see cref="T:System.Collections.Generic.List`1" /> który rozciąga się od określonego indeksu do ostatniego elementu.</summary>
        <returns>Liczony od zera indeks pierwszego wystąpienia elementu, który pasuje do warunków zdefiniowanych przez <paramref name="match" />, jeśli je znaleziono; w przeciwnym razie wartość -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> Przeszukiwany jest do przodu zaczynając od `startIndex` i kończąc na ostatnim elemencie.  
  
 <xref:System.Predicate%601> Jest delegowany do metody, która zwraca `true` obiekt przekazywany do jest zgodne z warunkami określonymi w delegacie.  Elementy bieżącego <xref:System.Collections.Generic.List%601> indywidualnie są przekazywane do <xref:System.Predicate%601> delegowanie. Delegat ma podpis:  
  
```csharp  
public bool methodName(T obj)  
```  
  
```vb  
Public Function methodName(obj As T) As Boolean  
```  
  
 Ta metoda wykonuje wyszukiwanie liniowe; w związku z tym ta metoda jest O (*n*) operację, której *n* jest liczba elementów od `startIndex` na końcu <xref:System.Collections.Generic.List%601>.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano `Employee` klasy z polami dwóch `Name` i `Id`. Definiuje także `EmployeeSearch` klasy z jedną metodę `StartsWith`, który wskazuje, czy `Employee.Name` pola rozpoczyna się od określonego podciągu, który został dostarczony do `EmployeeSearch` konstruktora klasy. Uwaga sygnatury tej metody  
  
```csharp  
public bool StartsWith(Employee e)  
```  
  
```vb  
Public Function StartsWith(e As Employee) As Boolean  
```  
  
 odpowiada podpisu delegata, który może zostać przekazany do <xref:System.Collections.Generic.List%601.FindIndex%2A> metody. Przykład tworzy `List<Employee>` obiektów, dodaje szereg `Employee` objets go, a następnie wywołania <xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29> metody dwa razy, aby wyszukać kolekcji, rozpoczynając od jego piątej elementu członkowskiego (to znaczy, że element członkowski od indeksu 4). Po raz pierwszy, wyszukiwania dla pierwszego `Employee` którego `Name` pola rozpoczyna się od "J"; drugi czas wyszukiwania przez nią pierwszy `Employee` którego `Name` pola rozpoczyna się od "Ju".  
  
 [!code-csharp[System.Collections.Generic.List.FindIndex#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/cs/FindIndex3.cs#3)]
 [!code-vb[System.Collections.Generic.List.FindIndex#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/vb/FindIndex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> znajduje się poza zakresem indeksów prawidłowy dla <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex">
      <MemberSignature Language="C#" Value="public int FindIndex (int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindIndex(int32 startIndex, int32 count, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindIndex (startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindIndex(int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindIndex : int * int * Predicate&lt;'T&gt; -&gt; int" Usage="list.FindIndex (startIndex, count, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">Wartość początkowa indeksu zaczynającego się od zera dla wyszukiwania.</param>
        <param name="count">Liczba elementów w sekcji do wyszukania.</param>
        <param name="match">
          <see cref="T:System.Predicate`1" /> Delegat definiujący warunki elementu do wyszukania.</param>
        <summary>Wyszukuje element, który pasuje do warunków zdefiniowanych przez określony predykat i zwraca liczony od zera indeks pierwszego wystąpienia w zakresie elementów w <see cref="T:System.Collections.Generic.List`1" /> rozpoczyna się od określonego indeksu i zawiera określonej liczby elementów.</summary>
        <returns>Liczony od zera indeks pierwszego wystąpienia elementu, który pasuje do warunków zdefiniowanych przez <paramref name="match" />, jeśli je znaleziono; w przeciwnym razie wartość -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> Przeszukiwany jest do przodu zaczynając od `startIndex` i kończący się na `startIndex` plus `count` pomniejszonej o 1, jeśli `count` jest większa niż 0.  
  
 <xref:System.Predicate%601> Jest delegowany do metody, która zwraca `true` obiekt przekazywany do jest zgodne z warunkami określonymi w delegacie.  Elementy bieżącego <xref:System.Collections.Generic.List%601> indywidualnie są przekazywane do <xref:System.Predicate%601> delegowanie. Delegat ma podpis:  
  
```csharp  
public bool methodName(T obj)  
```  
  
```vb  
Public Function methodName(obj As T) As Boolean  
```  
  
 Ta metoda wykonuje wyszukiwanie liniowe; w związku z tym ta metoda jest O (*n*) operację, której *n* jest `count`.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano `Employee` klasy z polami dwóch `Name` i `Id`. Definiuje także `EmployeeSearch` klasy z jedną metodę `StartsWith`, który wskazuje, czy `Employee.Name` pola rozpoczyna się od określonego podciągu, który został dostarczony do `EmployeeSearch` konstruktora klasy. Uwaga sygnatury tej metody  
  
```csharp  
public bool StartsWith(Employee e)  
```  
  
```vb  
Public Function StartsWith(e As Employee) As Boolean  
```  
  
 odpowiada podpisu delegata, który może zostać przekazany do <xref:System.Collections.Generic.List%601.FindIndex%2A> metody. Przykład tworzy `List<Employee>` obiektów, dodaje szereg `Employee` objets go, a następnie wywołania <xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29> metody dwa razy, aby przeszukać całą kolekcję (to znaczy elementy członkowskie z indeksem 0 indeksu <xref:System.Collections.Generic.List%601.Count%2A> - 1). Po raz pierwszy, wyszukiwania dla pierwszego `Employee` którego `Name` pola rozpoczyna się od "J"; drugi czas wyszukiwania przez nią pierwszy `Employee` którego `Name` pola rozpoczyna się od "Ju".  
  
 [!code-csharp[System.Collections.Generic.List.FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/cs/FindIndex1.cs#1)]
 [!code-vb[System.Collections.Generic.List.FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/vb/FindIndex1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> znajduje się poza zakresem indeksów prawidłowy dla <see cref="T:System.Collections.Generic.List`1" />.  - lub - <paramref name="count" /> jest mniejszy niż 0.  - lub - <paramref name="startIndex" /> i <paramref name="count" /> nie zostanie określony prawidłowy części <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLast">
      <MemberSignature Language="C#" Value="public T FindLast (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T FindLast(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLast (match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T FindLast(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindLast : Predicate&lt;'T&gt; -&gt; 'T" Usage="list.FindLast match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">
          <see cref="T:System.Predicate`1" /> Delegat definiujący warunki elementu do wyszukania.</param>
        <summary>Wyszukuje element, który pasuje do warunków zdefiniowanych przez określony predykat i zwraca ostatnie wystąpienie w ramach całego <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>Ostatni element, który pasuje do warunków zdefiniowanych przez określony predykat, gdy znaleziono; w przeciwnym razie wartość domyślna dla typu <paramref name="T" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601> Jest delegowany do metody, która zwraca `true` obiekt przekazywany do jest zgodne z warunkami określonymi w delegacie.  Elementy bieżącego <xref:System.Collections.Generic.List%601> indywidualnie są przekazywane do <xref:System.Predicate%601> delegata przechodzenia wstecz <xref:System.Collections.Generic.List%601>, zaczynając od ostatniego elementu i kończąc pierwszego elementu.  Przetwarzanie zostało zatrzymane po znalezieniu dopasowania.  
  
> [!IMPORTANT]
>  Podczas wyszukiwania lista zawierająca typy wartości, upewnij się, że wartość domyślna dla typu nie spełnia predykatu wyszukiwania. W przeciwnym razie nie istnieje sposób odróżnić domyślną wartość wskazującą, że nie znaleziono dopasowania elementu listy, która ma wartości domyślnej dla typu. Jeśli wartość domyślna spełnia predykatu wyszukiwania, użyj <xref:System.Collections.Generic.List%601.FindLastIndex%2A> metody zamiast tego.  
  
 Ta metoda wykonuje wyszukiwanie liniowe; w związku z tym ta metoda jest O (*n*) operację, której *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano metody Znajdź <xref:System.Collections.Generic.List%601> klasy. Przykład <xref:System.Collections.Generic.List%601> klasa zawiera `book` obiektów klasy `Book`, przy użyciu danych z [przykładowego pliku XML: książek (LINQ do XML)](http://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). `FillList` Używa metody w tym przykładzie [LINQ do XML](http://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) można przeanalizować wartości z pliku XML do wartości właściwości `book` obiektów.  
  
 W poniższej tabeli opisano przykłady podane dla metody find.  
  
|Metoda|Przykład|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Wyszukuje książki za pomocą Identyfikatora `IDToFind` predykatu delegata.<br /><br /> C# przykładzie użyto anonimowego obiektu delegowanego.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Znajdź wszystkie tego którego książki `Genre` właściwość jest "Komputer" przy użyciu `FindComputer` predykatu delegata.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Znajduje ostatni książki w kolekcji zawierającej daty publikowania przed 2001 przy użyciu `PubBefore2001` predykatu delegata.<br /><br /> C# przykładzie użyto anonimowego obiektu delegowanego.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Znajduje indeks pierwszego książki komputera przy użyciu `FindComputer` predykatu delegata.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Znajduje indeks ostatni komputer książki przy użyciu `FindComputer` predykatu delegata.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Znajduje indeks pierwszego książki komputera w ciągu sekundy połowy kolekcji, przy użyciu `FindComputer` predykatu delegata.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Znajduje indeks ostatniego książki komputera w ciągu sekundy połowy kolekcji, przy użyciu `FindComputer` predykatu delegata.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindLastIndex">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wyszukuje element, który pasuje do warunków zdefiniowanych przez określony predykat i zwraca liczony od zera indeks w ciągu ostatniego wystąpienia <see cref="T:System.Collections.Generic.List`1" /> lub jego część.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindLastIndex">
      <MemberSignature Language="C#" Value="public int FindLastIndex (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindLastIndex(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLastIndex(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLastIndex (match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindLastIndex(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindLastIndex : Predicate&lt;'T&gt; -&gt; int" Usage="list.FindLastIndex match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">
          <see cref="T:System.Predicate`1" /> Delegat definiujący warunki elementu do wyszukania.</param>
        <summary>Wyszukuje element, który pasuje do warunków zdefiniowanych przez określony predykat i zwraca liczony od zera indeks ostatniego wystąpienia w obrębie całej <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>Liczony od zera indeks ostatniego wystąpienia elementu, który pasuje do warunków zdefiniowanych przez <paramref name="match" />, jeśli je znaleziono; w przeciwnym razie wartość -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> Przeszukiwany jest wstecz od ostatniego elementu i kończącego się na pierwszym elementem.  
  
 <xref:System.Predicate%601> Jest delegowany do metody, która zwraca `true` obiekt przekazywany do jest zgodne z warunkami określonymi w delegacie.  Elementy bieżącego <xref:System.Collections.Generic.List%601> indywidualnie są przekazywane do <xref:System.Predicate%601> delegowanie.  
  
 Ta metoda wykonuje wyszukiwanie liniowe; w związku z tym ta metoda jest O (*n*) operację, której *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano metody Znajdź <xref:System.Collections.Generic.List%601> klasy. Przykład <xref:System.Collections.Generic.List%601> klasa zawiera `book` obiektów klasy `Book`, przy użyciu danych z [przykładowego pliku XML: książek (LINQ do XML)](http://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). `FillList` Używa metody w tym przykładzie [LINQ do XML](http://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) można przeanalizować wartości z pliku XML do wartości właściwości `book` obiektów.  
  
 W poniższej tabeli opisano przykłady podane dla metody find.  
  
|Metoda|Przykład|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Wyszukuje książki za pomocą Identyfikatora `IDToFind` predykatu delegata.<br /><br /> C# przykładzie użyto anonimowego obiektu delegowanego.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Znajdź wszystkie tego którego książki `Genre` właściwość jest "Komputer" przy użyciu `FindComputer` predykatu delegata.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Znajduje ostatni książki w kolekcji zawierającej daty publikowania przed 2001 przy użyciu `PubBefore2001` predykatu delegata.<br /><br /> C# przykładzie użyto anonimowego obiektu delegowanego.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Znajduje indeks pierwszego książki komputera przy użyciu `FindComputer` predykatu delegata.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Znajduje indeks ostatni komputer książki przy użyciu `FindComputer` predykatu delegata.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Znajduje indeks pierwszego książki komputera w ciągu sekundy połowy kolekcji, przy użyciu `FindComputer` predykatu delegata.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Znajduje indeks ostatniego książki komputera w ciągu sekundy połowy kolekcji, przy użyciu `FindComputer` predykatu delegata.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex">
      <MemberSignature Language="C#" Value="public int FindLastIndex (int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindLastIndex(int32 startIndex, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLastIndex (startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindLastIndex(int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindLastIndex : int * Predicate&lt;'T&gt; -&gt; int" Usage="list.FindLastIndex (startIndex, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">Wartość początkowa indeksu zaczynającego się od zera dla wyszukiwania wstecznego.</param>
        <param name="match">
          <see cref="T:System.Predicate`1" /> Delegat definiujący warunki elementu do wyszukania.</param>
        <summary>Wyszukuje element, który pasuje do warunków zdefiniowanych przez określony predykat i zwraca liczony od zera indeks ostatniego wystąpienia w zakresie elementów w <see cref="T:System.Collections.Generic.List`1" /> który rozciąga się od pierwszego elementu zgodnie z określonym indeksem.</summary>
        <returns>Liczony od zera indeks ostatniego wystąpienia elementu, który pasuje do warunków zdefiniowanych przez <paramref name="match" />, jeśli je znaleziono; w przeciwnym razie wartość -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> Jest przeszukane z poprzednimi wersjami zaczynając od `startIndex` i kończącego się na pierwszym elementem.  
  
 <xref:System.Predicate%601> Jest delegowany do metody, która zwraca `true` obiekt przekazywany do jest zgodne z warunkami określonymi w delegacie.  Elementy bieżącego <xref:System.Collections.Generic.List%601> indywidualnie są przekazywane do <xref:System.Predicate%601> delegowanie.  
  
 Ta metoda wykonuje wyszukiwanie liniowe; w związku z tym ta metoda jest O (*n*) operację, której *n* jest liczba elementów od początku <xref:System.Collections.Generic.List%601> do `startIndex`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> znajduje się poza zakresem indeksów prawidłowy dla <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex">
      <MemberSignature Language="C#" Value="public int FindLastIndex (int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindLastIndex(int32 startIndex, int32 count, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLastIndex (startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindLastIndex(int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindLastIndex : int * int * Predicate&lt;'T&gt; -&gt; int" Usage="list.FindLastIndex (startIndex, count, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">Wartość początkowa indeksu zaczynającego się od zera dla wyszukiwania wstecznego.</param>
        <param name="count">Liczba elementów w sekcji do wyszukania.</param>
        <param name="match">
          <see cref="T:System.Predicate`1" /> Delegat definiujący warunki elementu do wyszukania.</param>
        <summary>Wyszukuje element, który pasuje do warunków zdefiniowanych przez określony predykat i zwraca liczony od zera indeks ostatniego wystąpienia w zakresie elementów w <see cref="T:System.Collections.Generic.List`1" /> czy zawiera określoną liczbę elementów i kończy się na określony indeks.</summary>
        <returns>Liczony od zera indeks ostatniego wystąpienia elementu, który pasuje do warunków zdefiniowanych przez <paramref name="match" />, jeśli je znaleziono; w przeciwnym razie wartość -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> Jest przeszukane z poprzednimi wersjami zaczynając od `startIndex` i kończący się na `startIndex` minus `count` plus 1, jeśli `count` jest większa niż 0.  
  
 <xref:System.Predicate%601> Jest delegowany do metody, która zwraca `true` obiekt przekazywany do jest zgodne z warunkami określonymi w delegacie.  Elementy bieżącego <xref:System.Collections.Generic.List%601> indywidualnie są przekazywane do <xref:System.Predicate%601> delegowanie.  
  
 Ta metoda wykonuje wyszukiwanie liniowe; w związku z tym ta metoda jest O (*n*) operację, której *n* jest `count`.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano metody Znajdź <xref:System.Collections.Generic.List%601> klasy. Przykład <xref:System.Collections.Generic.List%601> klasa zawiera `book` obiektów klasy `Book`, przy użyciu danych z [przykładowego pliku XML: książek (LINQ do XML)](http://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). `FillList` Używa metody w tym przykładzie [LINQ do XML](http://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) można przeanalizować wartości z pliku XML do wartości właściwości `book` obiektów.  
  
 W poniższej tabeli opisano przykłady podane dla metody find.  
  
|Metoda|Przykład|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Wyszukuje książki za pomocą Identyfikatora `IDToFind` predykatu delegata.<br /><br /> C# przykładzie użyto anonimowego obiektu delegowanego.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Znajdź wszystkie tego którego książki `Genre` właściwość jest "Komputer" przy użyciu `FindComputer` predykatu delegata.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Znajduje ostatni książki w kolekcji zawierającej daty publikowania przed 2001 przy użyciu `PubBefore2001` predykatu delegata.<br /><br /> C# przykładzie użyto anonimowego obiektu delegowanego.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Znajduje indeks pierwszego książki komputera przy użyciu `FindComputer` predykatu delegata.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Znajduje indeks ostatni komputer książki przy użyciu `FindComputer` predykatu delegata.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Znajduje indeks pierwszego książki komputera w ciągu sekundy połowy kolekcji, przy użyciu `FindComputer` predykatu delegata.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Znajduje indeks ostatniego książki komputera w ciągu sekundy połowy kolekcji, przy użyciu `FindComputer` predykatu delegata.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> znajduje się poza zakresem indeksów prawidłowy dla <see cref="T:System.Collections.Generic.List`1" />.  - lub - <paramref name="count" /> jest mniejszy niż 0.  - lub - <paramref name="startIndex" /> i <paramref name="count" /> nie zostanie określony prawidłowy części <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="ForEach">
      <MemberSignature Language="C#" Value="public void ForEach (Action&lt;T&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ForEach(class System.Action`1&lt;!T&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.ForEach(System.Action{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub ForEach (action As Action(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ForEach(Action&lt;T&gt; ^ action);" />
      <MemberSignature Language="F#" Value="member this.ForEach : Action&lt;'T&gt; -&gt; unit" Usage="list.ForEach action" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="action">
          <see cref="T:System.Action`1" /> Pełnomocnika, aby wykonać na każdym elemencie <see cref="T:System.Collections.Generic.List`1" />.</param>
        <summary>Wykonuje określoną akcję na każdym elemencie <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Action%601> Delegowany do metody, która wykonuje akcję na obiekcie przekazywanych do niej.  Elementy bieżącego <xref:System.Collections.Generic.List%601> indywidualnie są przekazywane do <xref:System.Action%601> delegowanie.  
  
 Ta metoda jest O (*n*) operację, której *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 Modyfikowanie kolekcji źródłowej w treści <xref:System.Action%601> delegata nie jest obsługiwane i powoduje, że niezdefiniowane zachowanie.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie <xref:System.Action%601> delegata do drukowania zawartości <xref:System.Collections.Generic.List%601> obiektu. W tym przykładzie `Print` metoda jest używana do wyświetlania zawartości listy do konsoli.  
  
> [!NOTE]
>  Oprócz wyświetlania zawartości przy użyciu `Print` metody, C# przykładzie pokazano użycie do wyświetlenia wyników konsoli.  
  
 [!code-csharp[System.Action_PrintExample#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Action_PrintExample/cs/action.cs#01)]
 [!code-vb[System.Action_PrintExample#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Action_PrintExample/vb/action.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="action" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Element kolekcji został zmodyfikowany.</exception>
        <altmember cref="T:System.Action`1" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;T&gt;.Enumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Collections.Generic.List`1/Enumerator&lt;!T&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As List(Of T).Enumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;T&gt;::Enumerator GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; System.Collections.Generic.List&lt;'T&gt;.Enumerator" Usage="list.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;T&gt;+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca moduł wyliczający, który iteruje po <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>A <see cref="T:System.Collections.Generic.List`1.Enumerator" /> dla <see cref="T:System.Collections.Generic.List`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `foreach` Instrukcji języka C# (`for each` w języku C++ `For Each` w języku Visual Basic) ukrywa złożoność wyliczenia. W związku z tym przy użyciu `foreach` jest zalecane, zamiast bezpośrednie manipulowanie modułu wyliczającego.  
  
 Moduły wyliczające mogą służyć do odczytu danych w kolekcji, ale nie można za ich pomocą modyfikować kolekcji źródłowej.  
  
 Początkowo moduł wyliczający jest umieszczony przed pierwszym elementem w kolekcji. W tym miejscu <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> właściwość jest niezdefiniowana. W związku z tym należy wywołać <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> metodę modułu wyliczającego pierwszy element do kolekcji przed odczytywania wartości <xref:System.Collections.Generic.List%601.Enumerator.Current%2A>.  
  
 <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> Właściwość zwraca tego samego obiektu, dopóki nie <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> jest wywoływana. <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> Ustawia <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> do następnego elementu.  
  
 Jeśli <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> przekazuje końcem kolekcji, moduł wyliczający jest umieszczony za ostatnim elementem w kolekcji i <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> zwraca `false`. Gdy moduł wyliczający jest w tym miejscu kolejnych wywołań <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> zwracają również `false`. Jeśli przez ostatnie wywołanie <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> zwrócił `false`, <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> jest niezdefiniowana. Nie można ustawić <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> do pierwszego elementu w kolekcji; należy utworzyć nowe wystąpienie modułu wyliczającego zamiast tego.  
  
 Moduł wyliczający zachowuje ważność tak długo, jak długo kolekcja pozostaje niezmieniona. Jeśli zmiany zostały wprowadzone do kolekcji, takie jak dodawanie, modyfikowanie lub usuwanie elementów, moduł wyliczający jest bezpowrotnie unieważniona, a następne wywołanie <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> lub <xref:System.Collections.Generic.List%601.Enumerator.System%23Collections%23IEnumerator%23Reset%2A> zgłasza <xref:System.InvalidOperationException>.  
  
 Moduł wyliczający nie ma wyłącznego dostępu do kolekcji, w związku z tym wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość. Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania.  Aby zezwolić wielu wątkom na dostęp do kolekcji w celu odczytu i zapisu danych, należy zaimplementować własny mechanizm synchronizacji.  
  
 Domyślne implementacje kolekcji w <xref:System.Collections.Generic?displayProperty=nameWithType> przestrzeni nazw nie są zsynchronizowane.  
  
 Ta metoda jest operacją O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.List`1.Enumerator" />
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="GetRange">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;T&gt; GetRange (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;!T&gt; GetRange(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRange (index As Integer, count As Integer) As List(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;T&gt; ^ GetRange(int index, int count);" />
      <MemberSignature Language="F#" Value="member this.GetRange : int * int -&gt; System.Collections.Generic.List&lt;'T&gt;" Usage="list.GetRange (index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Liczony od zera <see cref="T:System.Collections.Generic.List`1" /> indeksu, w którym rozpoczyna się zakres.</param>
        <param name="count">Liczba elementów w zakresie.</param>
        <summary>Tworzy kopię pobieżną zakresu elementów w źródle <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>Kopia pobieżna szereg elementów w źródłowej <see cref="T:System.Collections.Generic.List`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kopia pobieżna kolekcję typów referencyjnych lub podzestaw kolekcji, zawiera tylko odwołania do elementów kolekcji. Same obiekty nie są kopiowane. Odwołania do nowej listy wskaż te same obiekty jako odwołania w oryginalnej listy.  
  
 Kopia pobieżna kolekcję typów wartości lub podzestaw kolekcji, zawiera elementy kolekcji. Jednak jeśli elementy kolekcji zawierają odwołania do innych obiektów, te obiekty nie są kopiowane. Odniesienia w elementach Nowa kolekcja wskaż te same obiekty jako odwołania w elementach oryginalnej kolekcji.  
  
 Z kolei głęboką kopię kolekcji kopiuje elementy i wszystkich bezpośrednio lub pośrednio odwołuje się elementów.  
  
 Ta metoda jest O (*n*) operację, której *n* jest `count`.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Collections.Generic.List%601.GetRange%2A> — metoda i inne metody <xref:System.Collections.Generic.List%601> klasy, która działa w wypadku zakresów. Na koniec przykładzie <xref:System.Collections.Generic.List%601.GetRange%2A> metody jest używany do pobierania trzy elementy z listy, począwszy od indeksu lokalizacji 2. <xref:System.Collections.Generic.List%601.ToArray%2A> Wywoływana jest metoda powstałe w ten sposób <xref:System.Collections.Generic.List%601>, tworzenie tablicy trzy elementy. Elementy tablicy są wyświetlane.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza niż 0.  - lub - <paramref name="count" /> jest mniejszy niż 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> i <paramref name="count" /> nie określa prawidłowego zakresu elementów w <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca liczony od zera indeks pierwszego wystąpienia wartości w <see cref="T:System.Collections.Generic.List`1" /> lub w części.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.IndexOf(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOf(T item);" />
      <MemberSignature Language="F#" Value="abstract member IndexOf : 'T -&gt; int&#xA;override this.IndexOf : 'T -&gt; int" Usage="list.IndexOf item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.IndexOf(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Obiekt do zlokalizowania w <see cref="T:System.Collections.Generic.List`1" />. Wartość może być <see langword="null" /> dla typów odwołań.</param>
        <summary>Wyszukuje określony obiekt i zwraca liczony od zera indeks pierwszego wystąpienia w obrębie całej <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>Liczony od zera indeks pierwszego wystąpienia <paramref name="item" /> w obrębie całej <see cref="T:System.Collections.Generic.List`1" />, jeśli je znaleziono; w przeciwnym razie wartość -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> Przeszukiwany jest do przodu zaczynając od pierwszego elementu i końcowy z ostatniego elementu.  
  
 Ta metoda określa równości przy użyciu domyślna funkcja porównująca równości <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> dla `T`, typu wartości na liście.  
  
 Ta metoda wykonuje wyszukiwanie liniowe; w związku z tym ta metoda jest O (*n*) operację, której *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano wszystkich trzech przeciążeń <xref:System.Collections.Generic.List%601.IndexOf%2A> metody. A <xref:System.Collections.Generic.List%601> ciągów jest tworzony, z jednego wpisu, który pojawi się dwukrotnie w lokalizacji indeksu 0 i lokalizacji indeksu 5. <xref:System.Collections.Generic.List%601.IndexOf%28%600%29> Przeciążenie metody wyszukiwanie od początku listy, a znajduje pierwsze wystąpienie ciągu. <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%29> Przeciążenie metody używane do przeszukiwania listy rozpoczynający się z lokalizacji indeksu 3 i dalej na końcu listy i wyszukuje drugie wystąpienie ciągu. Na koniec <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> przeciążenie metody używane do przeszukiwania zakres dwóch wpisów, rozpoczynając od lokalizacji indeksu dwa; zwraca -1, ponieważ nie bez wystąpień ciągu wyszukiwania w tym zakresie.  
  
 [!code-cpp[List\`1_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_IndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (T item, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(!T item, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (item As T, index As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(T item, int index);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : 'T * int -&gt; int" Usage="list.IndexOf (item, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">Obiekt do zlokalizowania w <see cref="T:System.Collections.Generic.List`1" />. Wartość może być <see langword="null" /> dla typów odwołań.</param>
        <param name="index">Wartość początkowa indeksu zaczynającego się od zera dla wyszukiwania. 0 (zero) jest prawidłowa w pustej listy.</param>
        <summary>Wyszukuje określony obiekt i zwraca liczony od zera indeks pierwszego wystąpienia w zakresie elementów w <see cref="T:System.Collections.Generic.List`1" /> który rozciąga się od określonego indeksu do ostatniego elementu.</summary>
        <returns>Liczony od zera indeks pierwszego wystąpienia <paramref name="item" /> w zakresie elementów w <see cref="T:System.Collections.Generic.List`1" /> rozciąga się od <paramref name="index" /> do ostatniego elementu, jeśli je znaleziono; w przeciwnym razie wartość -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> Przeszukiwany jest do przodu zaczynając od `index` i kończąc na ostatnim elemencie.  
  
 Ta metoda określa równości przy użyciu domyślna funkcja porównująca równości <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> dla `T`, typu wartości na liście.  
  
 Ta metoda wykonuje wyszukiwanie liniowe; w związku z tym ta metoda jest O (*n*) operację, której *n* jest liczba elementów od `index` na końcu <xref:System.Collections.Generic.List%601>.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano wszystkich trzech przeciążeń <xref:System.Collections.Generic.List%601.IndexOf%2A> metody. A <xref:System.Collections.Generic.List%601> ciągów jest tworzony, z jednego wpisu, który pojawi się dwukrotnie w lokalizacji indeksu 0 i lokalizacji indeksu 5. <xref:System.Collections.Generic.List%601.IndexOf%28%600%29> Przeciążenie metody wyszukiwanie od początku listy, a znajduje pierwsze wystąpienie ciągu. <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%29> Przeciążenie metody używane do przeszukiwania listy rozpoczynający się z lokalizacji indeksu 3 i dalej na końcu listy i wyszukuje drugie wystąpienie ciągu. Na koniec <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> przeciążenie metody używane do przeszukiwania zakres dwóch wpisów, rozpoczynając od lokalizacji indeksu dwa; zwraca -1, ponieważ nie bez wystąpień ciągu wyszukiwania w tym zakresie.  
  
 [!code-cpp[List\`1_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_IndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> znajduje się poza zakresem indeksów prawidłowy dla <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (T item, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(!T item, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (item As T, index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(T item, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : 'T * int * int -&gt; int" Usage="list.IndexOf (item, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">Obiekt do zlokalizowania w <see cref="T:System.Collections.Generic.List`1" />. Wartość może być <see langword="null" /> dla typów odwołań.</param>
        <param name="index">Wartość początkowa indeksu zaczynającego się od zera dla wyszukiwania. 0 (zero) jest prawidłowa w pustej listy.</param>
        <param name="count">Liczba elementów w sekcji do wyszukania.</param>
        <summary>Wyszukuje określony obiekt i zwraca liczony od zera indeks pierwszego wystąpienia w zakresie elementów w <see cref="T:System.Collections.Generic.List`1" /> rozpoczyna się od określonego indeksu i zawiera określoną liczbę elementów.</summary>
        <returns>Liczony od zera indeks pierwszego wystąpienia <paramref name="item" /> w zakresie elementów w <see cref="T:System.Collections.Generic.List`1" /> który rozpoczyna się od <paramref name="index" /> i zawiera <paramref name="count" /> liczba elementów, jeśli je znaleziono; w przeciwnym razie wartość -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> Przeszukiwany jest do przodu zaczynając od `index` i kończący się na `index` plus `count` pomniejszonej o 1, jeśli `count` jest większa niż 0.  
  
 Ta metoda określa równości przy użyciu domyślna funkcja porównująca równości <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> dla `T`, typu wartości na liście.  
  
 Ta metoda wykonuje wyszukiwanie liniowe; w związku z tym ta metoda jest O (*n*) operację, której *n* jest `count`.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano wszystkich trzech przeciążeń <xref:System.Collections.Generic.List%601.IndexOf%2A> metody. A <xref:System.Collections.Generic.List%601> ciągów jest tworzony, z jednego wpisu, który pojawi się dwukrotnie w lokalizacji indeksu 0 i lokalizacji indeksu 5. <xref:System.Collections.Generic.List%601.IndexOf%28%600%29> Przeciążenie metody wyszukiwanie od początku listy, a znajduje pierwsze wystąpienie ciągu. <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%29> Przeciążenie metody używane do przeszukiwania listy rozpoczynający się z lokalizacji indeksu 3 i dalej na końcu listy i wyszukuje drugie wystąpienie ciągu. Na koniec <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> przeciążenie metody używane do przeszukiwania zakres dwóch wpisów, rozpoczynając od lokalizacji indeksu dwa; zwraca -1, ponieważ nie bez wystąpień ciągu wyszukiwania w tym zakresie.  
  
 [!code-cpp[List\`1_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_IndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> znajduje się poza zakresem indeksów prawidłowy dla <see cref="T:System.Collections.Generic.List`1" />.  - lub - <paramref name="count" /> jest mniejszy niż 0.  - lub - <paramref name="index" /> i <paramref name="count" /> nie zostanie określony prawidłowy części <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public void Insert (int index, T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Insert(int32 index, !T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Insert (index As Integer, item As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Insert(int index, T item);" />
      <MemberSignature Language="F#" Value="abstract member Insert : int * 'T -&gt; unit&#xA;override this.Insert : int * 'T -&gt; unit" Usage="list.Insert (index, item)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="index">Liczony od zera indeks, w którym <c>elementu</c> powinien zostać wstawiony.</param>
        <param name="item">Obiekt do wstawienia. Wartość może być <see langword="null" /> dla typów odwołań.</param>
        <summary>Wstawia element do <see cref="T:System.Collections.Generic.List`1" /> pod określonym indeksem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> akceptuje `null` jako prawidłowa wartość dla odwołania do typów i umożliwia zduplikowane elementy.  
  
 Jeśli <xref:System.Collections.Generic.List%601.Count%2A> jest już równa <xref:System.Collections.Generic.List%601.Capacity%2A>, pojemność <xref:System.Collections.Generic.List%601> zwiększa się o automatyczne ponowne przydzielanie tablicy wewnętrznej, a istniejące elementy są kopiowane do nowej tablicy przed dodaniem nowego elementu.  
  
 Jeśli `index` jest równa <xref:System.Collections.Generic.List%601.Count%2A>, `item` zostanie dodany na końcu <xref:System.Collections.Generic.List%601>.  
  
 Ta metoda jest O (*n*) operację, której *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób dodawania, usuwania i Wstaw obiekt biznesowy proste w <xref:System.Collections.Generic.List%601>.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 W poniższym przykładzie pokazano <xref:System.Collections.Generic.List%601.Insert%2A> metody wraz z różnych właściwości i metody <xref:System.Collections.Generic.List%601> klasy ogólnej. Po utworzeniu listy są dodawane elementy. <xref:System.Collections.Generic.List%601.Insert%2A> Metoda jest używana do wstawienia elementu do środka listy. Element wstawiony jest duplikatem, który jest później usunięte za pomocą <xref:System.Collections.Generic.List%601.Remove%2A> metody.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza niż 0.  - lub - <paramref name="index" /> jest większa niż <see cref="P:System.Collections.Generic.List`1.Count" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
      </Docs>
    </Member>
    <Member MemberName="InsertRange">
      <MemberSignature Language="C#" Value="public void InsertRange (int index, System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertRange(int32 index, class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub InsertRange (index As Integer, collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InsertRange(int index, System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberSignature Language="F#" Value="member this.InsertRange : int * seq&lt;'T&gt; -&gt; unit" Usage="list.InsertRange (index, collection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="index">Liczony od zera indeks, pod którym powinny zostać wstawione nowe elementy.</param>
        <param name="collection">Kolekcja, której elementy powinny zostać wstawione do <see cref="T:System.Collections.Generic.List`1" />. Sama kolekcja nie może być <see langword="null" />, ale może zawierać elementy, które są <see langword="null" />, jeśli typ <c>T</c> jest typem referencyjnym.</param>
        <summary>Wstawia elementy kolekcji do <see cref="T:System.Collections.Generic.List`1" /> pod określonym indeksem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> akceptuje `null` jako prawidłowa wartość dla odwołania do typów i umożliwia zduplikowane elementy.  
  
 Jeśli nowy <xref:System.Collections.Generic.List%601.Count%2A> (bieżące <xref:System.Collections.Generic.List%601.Count%2A> plus rozmiar kolekcji) będą większe niż <xref:System.Collections.Generic.List%601.Capacity%2A>, pojemność <xref:System.Collections.Generic.List%601> zwiększa się o automatyczne ponowne przydzielanie tablicy wewnętrznej w celu uwzględnienia nowych elementów i istniejące elementy są kopiowane do nowej tablicy przed są dodawane nowe elementy.  
  
 Jeśli `index` jest równa <xref:System.Collections.Generic.List%601.Count%2A>, elementy są dodawane na końcu <xref:System.Collections.Generic.List%601>.  
  
 Kolejność elementów w kolekcji jest zachowywana w <xref:System.Collections.Generic.List%601>.  
  
 Ta metoda jest O (*n* * *m*) operację, której *n* jest liczba elementów do dodania i *m* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Collections.Generic.List%601.InsertRange%2A> — metoda i różnych innych metod <xref:System.Collections.Generic.List%601> klasy, która działa w wypadku zakresów. Po utworzeniu listy i wypełniane przy użyciu nazwy kilka pokojowego jedzenia roślin dinozaurów <xref:System.Collections.Generic.List%601.InsertRange%2A> metoda służy do wstawiania tablicę trzy zajadłymi dinozaurów jedzenia mięsa na liście, rozpoczynając od lokalizacji indeksu 3.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collection" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza niż 0.  - lub - <paramref name="index" /> jest większa niż <see cref="P:System.Collections.Generic.List`1.Count" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public T this[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Item(index As Integer) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T default[int] { T get(int index); void set(int index, T value); };" />
      <MemberSignature Language="F#" Value="member this.Item(int) : 'T with get, set" Usage="System.Collections.Generic.List&lt;'T&gt;.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IList`1.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Liczony od zera indeks elementu, który ma zostać pobrany lub skonfigurowany.</param>
        <summary>Pobieranie lub konfigurowanie elementów pod określonym indeksem.</summary>
        <value>Element pod określonym indeksem.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> akceptuje `null` jako prawidłowa wartość dla odwołania do typów i umożliwia zduplikowane elementy.  
  
 Ta właściwość umożliwia dostęp do określonego elementu w kolekcji przy użyciu następującej składni: `myCollection[index]`.  
  
 Pobieranie wartości tej właściwości jest operacją O(1); Ustawienie właściwości jest również O(1) operacji.  
  
   
  
## Examples  
 W przykładzie w tej sekcji pokazano <xref:System.Collections.Generic.List%601.Item%2A> właściwości (indeksator w języku C#) i różnych innych właściwości i metody <xref:System.Collections.Generic.List%601> klasy ogólnej. Po liście tworzone i wypełniane przy użyciu <xref:System.Collections.Generic.List%601.Add%2A> , element są pobierane i wyświetlane przy użyciu <xref:System.Collections.Generic.List%601.Item%2A> właściwości. (Na przykład, który używa <xref:System.Collections.Generic.List%601.Item%2A> właściwości można ustawić wartości elementu listy, zobacz <xref:System.Collections.Generic.List%601.AsReadOnly%2A>.)  
  
> [!NOTE]
>  Visual Basic, C# i C++ wszystkie mają składni do uzyskiwania dostępu do <xref:System.Collections.Generic.List%601.Item%2A> właściwości bez za pomocą jego nazwy. Zamiast tego zmienną zawierającą <xref:System.Collections.Generic.List%601> jest używana, tak jakby był on tablicą.  
  
 Używa języka C# do definiowania indeksatory zamiast implementacja słowa kluczowego <xref:System.Collections.Generic.List%601.Item%2A> właściwości. Implementuje Visual Basic <xref:System.Collections.Generic.List%601.Item%2A> jako domyślna właściwość, która zapewnia te same funkcje indeksowania.  
  
 [!code-csharp[List`1_Class#2](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#2)]
 [!code-vb[List`1_Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#2)]  
[!code-csharp[List`1_Class#3](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#3)]
[!code-vb[List`1_Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza niż 0.  - lub - <paramref name="index" /> jest równa lub większa niż <see cref="P:System.Collections.Generic.List`1.Count" />.</exception>
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca liczony od zera indeks ostatniego wystąpienia wartości w <see cref="T:System.Collections.Generic.List`1" /> lub w części.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(T item);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : 'T -&gt; int" Usage="list.LastIndexOf item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Obiekt do zlokalizowania w <see cref="T:System.Collections.Generic.List`1" />. Wartość może być <see langword="null" /> dla typów odwołań.</param>
        <summary>Wyszukuje określony obiekt i zwraca liczony od zera indeks ostatniego wystąpienia w obrębie całej <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>Liczony od zera indeks ostatniego wystąpienia <paramref name="item" /> w obrębie całej <see cref="T:System.Collections.Generic.List`1" />, jeśli je znaleziono; w przeciwnym razie wartość -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> Przeszukiwany jest wstecz od ostatniego elementu i kończącego się na pierwszym elementem.  
  
 Ta metoda określa równości przy użyciu domyślna funkcja porównująca równości <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> dla `T`, typu wartości na liście.  
  
 Ta metoda wykonuje wyszukiwanie liniowe; w związku z tym ta metoda jest O (*n*) operację, której *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano wszystkich trzech przeciążeń <xref:System.Collections.Generic.List%601.LastIndexOf%2A> metody. A <xref:System.Collections.Generic.List%601> ciągów jest tworzony, z jednego wpisu, który pojawi się dwukrotnie w lokalizacji indeksu 0 i lokalizacji indeksu 5. <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%29> Przeciążenie metody wyszukuje całą listę od jej końca i wyszukuje drugie wystąpienie ciągu. <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%29> Przeciążenie metody używane do przeszukiwania listy z poprzednimi wersjami, począwszy od lokalizacji indeksu 3 i dalej na początku listy, więc znajdzie pierwsze wystąpienie ciągu na liście. Na koniec <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> przeciążenie metody używane do przeszukiwania zakres cztery wpisy, zaczynając od lokalizacji indeksu 4 i rozszerzanie Wstecz (to znaczy przeszukuje elementy w lokalizacjach, 4, 3, 2 i 1); to wyszukiwanie zwraca -1, ponieważ nie żadnych wystąpień wyszukiwania ciąg w tym zakresie.  
  
 [!code-cpp[List\`1_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_LastIndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (T item, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(!T item, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (item As T, index As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(T item, int index);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : 'T * int -&gt; int" Usage="list.LastIndexOf (item, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">Obiekt do zlokalizowania w <see cref="T:System.Collections.Generic.List`1" />. Wartość może być <see langword="null" /> dla typów odwołań.</param>
        <param name="index">Wartość początkowa indeksu zaczynającego się od zera dla wyszukiwania wstecznego.</param>
        <summary>Wyszukuje określony obiekt i zwraca liczony od zera indeks ostatniego wystąpienia w zakresie elementów w <see cref="T:System.Collections.Generic.List`1" /> który rozciąga się od pierwszego elementu zgodnie z określonym indeksem.</summary>
        <returns>Liczony od zera indeks ostatniego wystąpienia <paramref name="item" /> w zakresie elementów w <see cref="T:System.Collections.Generic.List`1" /> który rozciąga się od pierwszego elementu <paramref name="index" />, jeśli je znaleziono; w przeciwnym razie wartość -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> Jest przeszukane z poprzednimi wersjami zaczynając od `index` i kończącego się na pierwszym elementem.  
  
 Ta metoda określa równości przy użyciu domyślna funkcja porównująca równości <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> dla `T`, typu wartości na liście.  
  
 Ta metoda wykonuje wyszukiwanie liniowe; w związku z tym ta metoda jest O (*n*) operację, której *n* jest liczba elementów od początku <xref:System.Collections.Generic.List%601> do `index`.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano wszystkich trzech przeciążeń <xref:System.Collections.Generic.List%601.LastIndexOf%2A> metody. A <xref:System.Collections.Generic.List%601> ciągów jest tworzony, z jednego wpisu, który pojawi się dwukrotnie w lokalizacji indeksu 0 i lokalizacji indeksu 5. <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%29> Przeciążenie metody wyszukuje całą listę od jej końca i wyszukuje drugie wystąpienie ciągu. <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%29> Przeciążenie metody używane do przeszukiwania listy z poprzednimi wersjami, począwszy od lokalizacji indeksu 3 i dalej na początku listy, więc znajdzie pierwsze wystąpienie ciągu na liście. Na koniec <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> przeciążenie metody używane do przeszukiwania zakres cztery wpisy, zaczynając od lokalizacji indeksu 4 i rozszerzanie Wstecz (to znaczy przeszukuje elementy w lokalizacjach, 4, 3, 2 i 1); to wyszukiwanie zwraca -1, ponieważ nie żadnych wystąpień wyszukiwania ciąg w tym zakresie.  
  
 [!code-cpp[List\`1_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_LastIndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> znajduje się poza zakresem indeksów prawidłowy dla <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (T item, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(!T item, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (item As T, index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(T item, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : 'T * int * int -&gt; int" Usage="list.LastIndexOf (item, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">Obiekt do zlokalizowania w <see cref="T:System.Collections.Generic.List`1" />. Wartość może być <see langword="null" /> dla typów odwołań.</param>
        <param name="index">Wartość początkowa indeksu zaczynającego się od zera dla wyszukiwania wstecznego.</param>
        <param name="count">Liczba elementów w sekcji do wyszukania.</param>
        <summary>Wyszukuje określony obiekt i zwraca liczony od zera indeks ostatniego wystąpienia w zakresie elementów w <see cref="T:System.Collections.Generic.List`1" /> zawierający określoną liczbę elementów i kończy się w określonym indeksie.</summary>
        <returns>Liczony od zera indeks ostatniego wystąpienia <paramref name="item" /> w zakresie elementów w <see cref="T:System.Collections.Generic.List`1" /> zawierający <paramref name="count" /> liczba elementów i kończy się <paramref name="index" />, jeśli je znaleziono; w przeciwnym razie wartość -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> Jest przeszukane z poprzednimi wersjami zaczynając od `index` i kończący się na `index` minus `count` plus 1, jeśli `count` jest większa niż 0.  
  
 Ta metoda określa równości przy użyciu domyślna funkcja porównująca równości <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> dla `T`, typu wartości na liście.  
  
 Ta metoda wykonuje wyszukiwanie liniowe; w związku z tym ta metoda jest O (*n*) operację, której *n* jest `count`.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano wszystkich trzech przeciążeń <xref:System.Collections.Generic.List%601.LastIndexOf%2A> metody. A <xref:System.Collections.Generic.List%601> ciągów jest tworzony, z jednego wpisu, który pojawi się dwukrotnie w lokalizacji indeksu 0 i lokalizacji indeksu 5. <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%29> Przeciążenie metody wyszukuje całą listę od jej końca i wyszukuje drugie wystąpienie ciągu. <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%29> Przeciążenie metody używane do przeszukiwania listy z poprzednimi wersjami, począwszy od lokalizacji indeksu 3 i dalej na początku listy, więc znajdzie pierwsze wystąpienie ciągu na liście. Na koniec <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> przeciążenie metody używane do przeszukiwania zakres 4 pozycje, zaczynając od lokalizacji indeksu 4 i rozszerzanie Wstecz (to znaczy przeszukuje elementy w lokalizacjach, 4, 3, 2 i 1); to wyszukiwanie zwraca -1, ponieważ nie żadnych wystąpień wyszukiwania ciąg w tym zakresie.  
  
 [!code-cpp[List\`1_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_LastIndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> znajduje się poza zakresem indeksów prawidłowy dla <see cref="T:System.Collections.Generic.List`1" />.  - lub - <paramref name="count" /> jest mniejszy niż 0.  - lub - <paramref name="index" /> i <paramref name="count" /> nie zostanie określony prawidłowy części <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Remove(T item);" />
      <MemberSignature Language="F#" Value="abstract member Remove : 'T -&gt; bool&#xA;override this.Remove : 'T -&gt; bool" Usage="list.Remove item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Obiekt do usunięcia z <see cref="T:System.Collections.Generic.List`1" />. Wartość może być <see langword="null" /> dla typów odwołań.</param>
        <summary>Usuwa pierwsze wystąpienie określonego obiektu z <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="item" /> zostanie pomyślnie usunięty; w przeciwnym razie <see langword="false" />.  Ta metoda zwraca również wartość <see langword="false" /> Jeśli <paramref name="item" /> nie został znaleziony w <see cref="T:System.Collections.Generic.List`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli typ `T` implementuje <xref:System.IEquatable%601> jest porównania równości ogólny interfejs <xref:System.IEquatable%601.Equals%2A> metody tego interfejsu; w przeciwnym razie jest domyślna funkcja porównująca równości <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Ta metoda wykonuje wyszukiwanie liniowe; w związku z tym ta metoda jest O (*n*) operację, której *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób dodawania, usuwania i Wstaw obiekt biznesowy proste w <xref:System.Collections.Generic.List%601>.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 W poniższym przykładzie pokazano <xref:System.Collections.Generic.List%601.Remove%2A> metody. Kilka właściwości i metod <xref:System.Collections.Generic.List%601> ogólnej klasy służą do dodawania, wstawić i listę można przeszukiwać. Po te operacje lista zawiera duplikat. <xref:System.Collections.Generic.List%601.Remove%2A> Metoda jest używana do usuwania pierwsze wystąpienie zduplikowany element i jest wyświetlana zawartość. <xref:System.Collections.Generic.List%601.Remove%2A> Metoda zawsze usuwa pierwsze wystąpienie wystąpienia.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAll">
      <MemberSignature Language="C#" Value="public int RemoveAll (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 RemoveAll(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.RemoveAll(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAll (match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int RemoveAll(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.RemoveAll : Predicate&lt;'T&gt; -&gt; int" Usage="list.RemoveAll match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">
          <see cref="T:System.Predicate`1" /> Delegat definiujący warunki elementu do usunięcia.</param>
        <summary>Usuwa wszystkie elementy odpowiadające warunkom zdefiniowanym przez określony predykat.</summary>
        <returns>Liczba elementów usuniętych z <see cref="T:System.Collections.Generic.List`1" /> .</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601> Jest delegowany do metody, która zwraca `true` obiekt przekazywany do jest zgodne z warunkami określonymi w delegacie.  Elementy bieżącego <xref:System.Collections.Generic.List%601> indywidualnie są przekazywane do <xref:System.Predicate%601> delegata i elementy, które spełniają podane są usuwane z <xref:System.Collections.Generic.List%601>.  
  
 Ta metoda wykonuje wyszukiwanie liniowe; w związku z tym ta metoda jest O (*n*) operację, której *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Collections.Generic.List%601.RemoveAll%2A> — metoda i kilka innych metod, które używają <xref:System.Predicate%601> Delegat ogólny.  
  
 A <xref:System.Collections.Generic.List%601> ciągów jest tworzony, zawierający 8 nazwy kolorowanka, z których (na pozycji 1 do 5) dwa kończyć się "saurus". W przykładzie zdefiniowano również metody predykatu wyszukiwania o nazwie `EndsWithSaurus`, który akceptuje parametr typu string i zwraca wartość typu Boolean wartość wskazującą, czy ciąg wejściowy kończy się na "saurus".  
  
 <xref:System.Collections.Generic.List%601.Find%2A>, <xref:System.Collections.Generic.List%601.FindLast%2A>, I <xref:System.Collections.Generic.List%601.FindAll%2A> metody są używane do wyszukiwania na liście przy użyciu metody predykatu wyszukiwania.  
  
 <xref:System.Collections.Generic.List%601.RemoveAll%2A> Metoda jest używana do usuwania wszystkich wpisów, które kończą się ciągiem "saurus". Wzdłuż od początku, przekazywanie kolejno do każdego elementu listy `EndsWithSaurus` metody. Element zostanie usunięty, jeśli `EndsWithSaurus` metoda zwraca `true`.  
  
> [!NOTE]
>  W języku C# i Visual Basic, nie jest konieczne tworzenie `Predicate<string>` delegować (`Predicate(Of String)` w języku Visual Basic) jawnie. Te języki wnioskować poprawne delegata z kontekstu i automatycznie.  
  
 Na koniec <xref:System.Collections.Generic.List%601.Exists%2A> metoda sprawdza, czy nie występują żadne ciągów na liście, które kończyć się "saurus".  
  
 [!code-cpp[List\`1_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[List\`1_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_FindEtAl/cs/source.cs#1)]
 [!code-vb[List\`1_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="T:System.Predicate`1" />
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public void RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAt (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveAt(int index);" />
      <MemberSignature Language="F#" Value="abstract member RemoveAt : int -&gt; unit&#xA;override this.RemoveAt : int -&gt; unit" Usage="list.RemoveAt index" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)</InterfaceMember>
        <InterfaceMember>M:System.Collections.IList.RemoveAt(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Liczony od zera indeks elementu do usunięcia.</param>
        <summary>Usuwa element o określonym indeksie <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas wywoływania <xref:System.Collections.Generic.List%601.RemoveAt%2A> Aby usunąć element, pozostałe elementy na liście są numerowane zastąpić usunięty element. Na przykład jeśli usuniesz element pod indeksem 3 element pod indeksem 4 jest przenoszony do 3 pozycji. Ponadto liczba elementów na liście (reprezentowany przez <xref:System.Collections.Generic.List%601.Count%2A> właściwości), zostanie zmniejszona 1.  
  
 Ta metoda jest O (*n*) operację, której *n* jest (<xref:System.Collections.Generic.List%601.Count%2A> - `index`).  
  
   
  
## Examples  
 Poniższy przykład przedstawia sposób dodawania, usuwania i Wstaw obiekt biznesowy proste w <xref:System.Collections.Generic.List%601>.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza niż 0.  - lub - <paramref name="index" /> jest równa lub większa niż <see cref="P:System.Collections.Generic.List`1.Count" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveRange">
      <MemberSignature Language="C#" Value="public void RemoveRange (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveRange(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveRange (index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveRange(int index, int count);" />
      <MemberSignature Language="F#" Value="member this.RemoveRange : int * int -&gt; unit" Usage="list.RemoveRange (index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Liczony od zera indeks początkowy zakresu elementów do usunięcia.</param>
        <param name="count">Liczba elementów do usunięcia.</param>
        <summary>Usuwa zakres elementów z <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Elementy zostaną usunięte i wszystkie elementy po ich w <xref:System.Collections.Generic.List%601> mają ich indeksy zmniejszona `count`.  
  
 Ta metoda jest O (*n*) operację, której *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Collections.Generic.List%601.RemoveRange%2A> — metoda i różnych innych metod <xref:System.Collections.Generic.List%601> klasy, która działa w wypadku zakresów. Po utworzeniu i modyfikacji listy <xref:System.Collections.Generic.List%601.RemoveRange%2A> metoda jest używana do usuwania dwa elementy z listy, zaczynając od indeksu lokalizacji 2.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza niż 0.  - lub - <paramref name="count" /> jest mniejszy niż 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> i <paramref name="count" /> nie określa prawidłowego zakresu elementów w <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Reverse">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Odwraca kolejność elementów w <see cref="T:System.Collections.Generic.List`1" /> lub jego część.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public void Reverse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reverse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Reverse" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reverse ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Reverse();" />
      <MemberSignature Language="F#" Value="member this.Reverse : unit -&gt; unit" Usage="list.Reverse " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odwraca kolejność elementów w całej <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa <xref:System.Array.Reverse%2A?displayProperty=nameWithType> do odwracania kolejności elementów.  
  
 Ta metoda jest O (*n*) operację, której *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano zarówno przeciążeń <xref:System.Collections.Generic.List%601.Reverse%2A> metody. W przykładzie jest tworzony <xref:System.Collections.Generic.List%601> z ciągów i dodaje sześć ciągów. <xref:System.Collections.Generic.List%601.Reverse> Przeciążenie metody służy do wstecznego na liście, a następnie <xref:System.Collections.Generic.List%601.Reverse%28System.Int32%2CSystem.Int32%29> przeciążenie metody służy do odwracania środka z listy, począwszy od elementu 1 a obejmującej cztery elementy.  
  
 [!code-cpp[List\`1_Reverse#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Reverse/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Reverse#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Reverse/cs/source.cs#1)]
 [!code-vb[List\`1_Reverse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Reverse/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public void Reverse (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reverse(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Reverse(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reverse (index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Reverse(int index, int count);" />
      <MemberSignature Language="F#" Value="member this.Reverse : int * int -&gt; unit" Usage="list.Reverse (index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Liczony od zera indeks początkowy zakresu, aby odwrócić.</param>
        <param name="count">Liczba elementów w zakresie, aby odwrócić.</param>
        <summary>Odwraca kolejność elementów w określonym zakresie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa <xref:System.Array.Reverse%2A?displayProperty=nameWithType> do odwracania kolejności elementów.  
  
 Ta metoda jest O (*n*) operację, której *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano zarówno przeciążeń <xref:System.Collections.Generic.List%601.Reverse%2A> metody. W przykładzie jest tworzony <xref:System.Collections.Generic.List%601> z ciągów i dodaje sześć ciągów. <xref:System.Collections.Generic.List%601.Reverse> Przeciążenie metody służy do wstecznego na liście, a następnie <xref:System.Collections.Generic.List%601.Reverse%28System.Int32%2CSystem.Int32%29> przeciążenie metody służy do odwracania środka z listy, począwszy od elementu 1 a obejmującej cztery elementy.  
  
 [!code-cpp[List\`1_Reverse#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Reverse/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Reverse#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Reverse/cs/source.cs#1)]
 [!code-vb[List\`1_Reverse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Reverse/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza niż 0.  - lub - <paramref name="count" /> jest mniejszy niż 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> i <paramref name="count" /> nie określa prawidłowego zakresu elementów w <see cref="T:System.Collections.Generic.List`1" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Sort">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sortuje elementów w <see cref="T:System.Collections.Generic.List`1" /> lub jego część.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="overloaded-method-syntax"></a>Przeciążona metoda składni  
 <xref:System.Collections.Generic.List%601.Sort%2A> Metody umożliwiają sortowania z domyślna funkcja porównująca dla typu obiektu na liście lub określić metodę sortowania klienta.  
  
 [Lista\<T >. Sort()](xref:System.Collections.Generic.List`1.Sort*) Sortuje elementy na liście całego przy użyciu domyślna funkcja porównująca typu obiektu przechowywana na liście.  
  
 [Lista\<T >. Sortuj M (porównanie\<T > Porównanie)](xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29) Sortuje elementy na liście całego przy użyciu określona funkcja porównująca.  
  
 [Lista\<T >. Sortowanie (IComparer\<T > Moduł porównujący)](xref:System.Collections.Generic.List%601.Sort%28System.Collections.Generic.IComparer%7B%600%7D%29) Sortuje elementy na liście całego przy użyciu określonego <xref:System.Comparison%601?displayProperty=nameWithType>.  
  
 [Lista\<T >. Sortowanie (Int32 indeksu, liczba typów Int32 IComparer\<T > Moduł porównujący)](xref:System.Collections.Generic.List%601.Sort%28System.Int32,System.Int32,System.Collections.Generic.IComparer%7B%600%7D%29) Sortuje elementy w zakresie elementów na liście przy użyciu określona funkcja porównująca.  
  
## <a name="parameters"></a>Parametry  
  
|Parametr|Typ|Opis|  
|---------------|----------|-----------------|  
|`comparison`|<xref:System.Comparison%601>|Metody obiektu delegowanego do używania przy porównywaniu elementów|  
|Moduł porównujący|<xref:System.Collections.Generic.IComparer%601>|<xref:System.Collections.Generic.IComparer%601> Implementacji do używania przy porównywaniu elementy lub wartość null, aby użyć domyślna funkcja porównująca <xref:System.Collections.Generic.Comparer%601.Default>.|  
|`index`|<xref:System.Int32>|Liczony od zera indeks początkowy zakresu do sortowania.|  
|`count`|<xref:System.Int32>|Długość zakresu do sortowania.|  
  
## <a name="exceptions"></a>Wyjątki  
  
|Wyjątek|Warunek|  
|---------------|---------------|  
|<xref:System.InvalidOperationException>|`comparer` nie określono lub `null`, a domyślna funkcja porównująca <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> nie można odnaleźć implementacji <xref:System.IComparable%601?displayProperty=nameWithType> ogólny interfejs lub <xref:System.IComparable?displayProperty=nameWithType> interfejs dla typu T.|  
|<xref:System.ArgumentNullException>|`comparison` jest `null`.|  
|<xref:System.ArgumentException>|Implementacja `comparison` lub `comparer` spowodował błąd podczas sortowania. Na przykład `comparison` nie mogą zwracać 0, podczas porównywania elementu z samym sobą.<br /><br /> —lub—<br /><br /> `index` i `count` nie zostanie określony prawidłowy zakres w <xref:System.Collections.Generic.List%601>.|  
|<xref:System.ArgumentOutOfRangeException>|`index` jest mniejsza niż 0 lub `count` jest mniejszy niż 0.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort();" />
      <MemberSignature Language="F#" Value="member this.Sort : unit -&gt; unit" Usage="list.Sort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sortuje elementów w całej <see cref="T:System.Collections.Generic.List`1" /> przy użyciu domyślna funkcja porównująca.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa domyślna funkcja porównująca <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> dla typu `T` do określania kolejności elementów listy. <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> Określa, czy typ sprawdzenia właściwości `T` implementuje <xref:System.IComparable%601> ogólny interfejs i wykorzystuje tę implementację, jeśli jest dostępna.  Jeśli nie, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> kontroli określa, czy typ `T` implementuje <xref:System.IComparable> interfejsu.  Jeśli typ `T` nie implementuje albo interfejsu <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> zgłasza <xref:System.InvalidOperationException>.  
  
 Ta metoda używa <xref:System.Array.Sort%2A?displayProperty=nameWithType> metodę, która ma zastosowanie introspective sortowania w następujący sposób:  
  
-   Jeśli rozmiar partycji jest mniej niż 16 elementów, używa algorytmu sortowania wstawiania.  
  
-   Jeśli liczba partycji przekracza 2 dziennika *n*, gdzie *n* jest zakresu wartości tablicy wejściowej, używa algorytmu Heapsort.  
  
-   W przeciwnym razie używa algorytmu Quicksort.  
  
 Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana. Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.  
  
 Średnia, ta metoda jest O (*n* dziennika *n*) operację, której *n* jest <xref:System.Collections.Generic.List%601.Count%2A>; w najgorszym przypadku jest O (*n* <sup>2</sup>) operacji.  
  
   
  
## Examples  
 W poniższym przykładzie dodano niektóre nazwy do `List<String>` obiektów, wyświetla na liście w kolejności nieposortowane wywołuje <xref:System.Collections.Generic.List%601.Sort%2A> metody, a następnie wyświetla posortowaną listę.  
  
 [!code-csharp[System.Collections.Generic.List.Sort#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.sort/cs/Sort1.cs#2)]
 [!code-vb[System.Collections.Generic.List.Sort#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.sort/vb/Sort1.vb#2)]  
  
 Poniższy kod przedstawia <xref:System.Collections.Generic.List%601.Sort> i <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> przeciążenia metody na obiekt biznesowy proste. Wywoływanie <xref:System.Collections.Generic.List%601.Sort> metoda powoduje użycie domyślna funkcja porównująca dla typu części i <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> metoda jest implementowana przy użyciu metody anonimowej.  
  
 [!code-csharp[System.Collections.Generic.List.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.sort/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.sort/vb/module1.vb#1)]  
  
 W poniższym przykładzie pokazano <xref:System.Collections.Generic.List%601.Sort> przeciążenie metody i <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> przeciążenie metody. A <xref:System.Collections.Generic.List%601> ciągów jest tworzone i wypełniane przy użyciu czterech ciągów, w określonej kolejności. Listy jest wyświetlane, sortowania i ponownie wyświetlone.  
  
 <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> Przeciążenie metody jest następnie używany do wyszukiwania dwa ciągi, które nie są na liście i <xref:System.Collections.Generic.List%601.Insert%2A> metodę wstawić je. Wartość zwracana <xref:System.Collections.Generic.List%601.BinarySearch%2A> metoda jest ujemna w każdym przypadku, ponieważ ciągi nie są na liście. Biorąc dopełnienia bitowego (~ operatora w języku C# i Visual C++ `Xor` -1 w języku Visual Basic) z tego ujemna tworzy numer indeksu pierwszego elementu listy, które jest większe niż ciąg wyszukiwania i wstawianie w tej lokalizacji zachowuje sortowania kolejność. Drugi ciąg wyszukiwania jest większy niż dowolny element na liście, tak aby pozycja wstawiania na końcu listy.  
  
 [!code-cpp[List\`1_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearch/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Domyślna funkcja porównująca <see cref="P:System.Collections.Generic.Comparer`1.Default" /> nie można znaleźć implementacji <see cref="T:System.IComparable`1" /> ogólny interfejs lub <see cref="T:System.IComparable" /> interfejs dla typu <paramref name="T" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort (System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort(class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort(System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort (comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort(System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="member this.Sort : System.Collections.Generic.IComparer&lt;'T&gt; -&gt; unit" Usage="list.Sort comparer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="comparer">
          <see cref="T:System.Collections.Generic.IComparer`1" /> Implementacji do używania przy porównywaniu elementy, lub <see langword="null" /> do używania domyślna funkcja porównująca <see cref="P:System.Collections.Generic.Comparer`1.Default" />.</param>
        <summary>Sortuje elementów w całej <see cref="T:System.Collections.Generic.List`1" /> przy użyciu określona funkcja porównująca.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `comparer` podano elementy <xref:System.Collections.Generic.List%601> są sortowane przy użyciu określonego <xref:System.Collections.Generic.IComparer%601> implementacji.  
  
 Jeśli `comparer` jest `null`, domyślna funkcja porównująca <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> kontroli określa, czy typ `T` implementuje <xref:System.IComparable%601> ogólny interfejs i wykorzystuje tę implementację, jeśli jest dostępna.  Jeśli nie, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> kontroli określa, czy typ `T` implementuje <xref:System.IComparable> interfejsu.  Jeśli typ `T` nie implementuje albo interfejsu <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> zgłasza <xref:System.InvalidOperationException>.  
  
 Ta metoda używa <xref:System.Array.Sort%2A?displayProperty=nameWithType> metodę, która ma zastosowanie introspective sortowania w następujący sposób:  
  
-   Jeśli rozmiar partycji jest mniej niż 16 elementów, używa algorytmu sortowania wstawiania.  
  
-   Jeśli liczba partycji przekracza 2 dziennika *n*, gdzie *n* jest zakresu wartości tablicy wejściowej, używa algorytmu Heapsort.  
  
-   W przeciwnym razie używa algorytmu Quicksort.  
  
 Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana. Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.  
  
 Średnia, ta metoda jest O (*n* dziennika *n*) operację, której *n* jest <xref:System.Collections.Generic.List%601.Count%2A>; w najgorszym przypadku jest O (*n* <sup>2</sup>) operacji.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Collections.Generic.List%601.Sort%28System.Collections.Generic.IComparer%7B%600%7D%29> przeciążenie metody i <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> przeciążenie metody.  
  
 W przykładzie zdefiniowano alternatywnego porównania ciągów o nazwie DinoCompare, która implementuje `IComparer<string>` (`IComparer(Of String)` w języku Visual Basic `IComparer<String^>` w programie Visual C++) interfejs generyczny. Moduł porównujący działa w następujący sposób: najpierw comparands są sprawdzane pod kątem `null`, odwołanie o wartości null jest traktowany jako mniejsza niż inne niż null. Po drugie długości ciągu zostaną porównane, a ciąg dłuższy jest uważany większa. Trzecie Jeśli długości są takie same, porównania ciągów zwykłej jest używany.  
  
 A <xref:System.Collections.Generic.List%601> ciągów jest tworzone i wypełniane przy użyciu czterech ciągów, w określonej kolejności. Zostanie wyświetlona lista, posortowana przy użyciu alternatywnych porównania i wyświetlane ponownie.  
  
 <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> Przeciążenie metody jest następnie używany do wyszukiwania kilku ciągów, które są nie na liście wykorzystujących alternatywny porównania. <xref:System.Collections.Generic.List%601.Insert%2A> Metoda służy do wstawiania ciągi. Te dwie metody znajdują się w funkcji o nazwie `SearchAndInsert`, wraz z kodem podjęcie dopełnienia bitowego (~ operatora w języku C# i Visual C++ `Xor` -1 w języku Visual Basic) liczby ujemne zwracane przez <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> i używać go jako indeks Wstawianie nowych parametrów.  
  
 [!code-cpp[List\`1_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> jest <see langword="null" />, a domyślna funkcja porównująca <see cref="P:System.Collections.Generic.Comparer`1.Default" /> nie można odnaleźć implementacji <see cref="T:System.IComparable`1" /> ogólny interfejs lub <see cref="T:System.IComparable" /> interfejs dla typu <paramref name="T" />.</exception>
        <exception cref="T:System.ArgumentException">Implementacja <paramref name="comparer" /> spowodował błąd podczas sortowania. Na przykład <paramref name="comparer" /> nie mogą zwracać 0, podczas porównywania elementu z samym sobą.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort (Comparison&lt;T&gt; comparison);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort(class System.Comparison`1&lt;!T&gt; comparison) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort(System.Comparison{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort (comparison As Comparison(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort(Comparison&lt;T&gt; ^ comparison);" />
      <MemberSignature Language="F#" Value="member this.Sort : Comparison&lt;'T&gt; -&gt; unit" Usage="list.Sort comparison" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparison" Type="System.Comparison&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="comparison">
          <see cref="T:System.Comparison`1" /> Do użycia podczas porównywania elementów.</param>
        <summary>Sortuje elementów w całej <see cref="T:System.Collections.Generic.List`1" /> przy użyciu określonego <see cref="T:System.Comparison`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `comparison` podano elementy <xref:System.Collections.Generic.List%601> są sortowane przy użyciu metody reprezentowany przez delegata.  
  
 Jeśli `comparison` jest `null`, <xref:System.ArgumentNullException> jest generowany.  
  
 Ta metoda używa <xref:System.Array.Sort%2A?displayProperty=nameWithType>, którego dotyczy introspective sortowania w następujący sposób:  
  
-   Jeśli rozmiar partycji jest mniej niż 16 elementów, używa algorytmu sortowania wstawiania  
  
-   Jeśli liczba partycji przekracza 2 dziennika *n*, gdzie *n* jest zakresu wartości tablicy wejściowej używa [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algorytmu.  
  
-   W przeciwnym razie używa algorytmu Quicksort.  
  
 Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana. Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.  
  
 Średnia, ta metoda jest O (*n* dziennika *n*) operację, której *n* jest <xref:System.Collections.Generic.List%601.Count%2A>; w najgorszym przypadku jest O (*n* <sup>2</sup>) operacji.  
  
   
  
## Examples  
 Poniższy kod przedstawia <xref:System.Collections.Generic.List%601.Sort%2A> i <xref:System.Collections.Generic.List%601.Sort%2A> przeciążenia metody na obiekt biznesowy proste. Wywoływanie <xref:System.Collections.Generic.List%601.Sort%2A> metoda powoduje użycie domyślna funkcja porównująca dla typu części i <xref:System.Collections.Generic.List%601.Sort%2A> metody jest implementowane za pomocą metody anonimowej.  
  
 [!code-csharp[System.Collections.Generic.List.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.sort/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.sort/vb/module1.vb#1)]  
  
 W poniższym przykładzie pokazano <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> przeciążenie metody.  
  
 W przykładzie zdefiniowano alternatywną metodą porównywania ciągów o nazwie `CompareDinosByLength`. Ta metoda działa w następujący sposób: najpierw comparands są sprawdzane pod kątem `null`, odwołanie o wartości null jest traktowany jako mniejsza niż inne niż null. Po drugie długości ciągu zostaną porównane, a ciąg dłuższy jest uważany większa. Trzecie Jeśli długości są takie same, porównania ciągów zwykłej jest używany.  
  
 A <xref:System.Collections.Generic.List%601> ciągów jest tworzone i wypełniane przy użyciu czterech ciągów, w określonej kolejności. Lista zawiera także pustego ciągu i odwołanie o wartości null. Zostanie wyświetlona lista sortowane przy użyciu <xref:System.Comparison%601> Delegat ogólny reprezentujący `CompareDinosByLength` metody i ponownie wyświetlone.  
  
 [!code-cpp[List\`1_SortComparison#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortComparison/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortComparison#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortComparison/cs/source.cs#1)]
 [!code-vb[List\`1_SortComparison#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortComparison/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="comparison" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Implementacja <paramref name="comparison" /> spowodował błąd podczas sortowania. Na przykład <paramref name="comparison" /> nie mogą zwracać 0, podczas porównywania elementu z samym sobą.</exception>
        <altmember cref="T:System.Comparison`1" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort (int index, int count, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort(int32 index, int32 count, class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort (index As Integer, count As Integer, comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort(int index, int count, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="member this.Sort : int * int * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; unit" Usage="list.Sort (index, count, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="index">Liczony od zera indeks początkowy zakresu do sortowania.</param>
        <param name="count">Długość zakresu do sortowania.</param>
        <param name="comparer">
          <see cref="T:System.Collections.Generic.IComparer`1" /> Implementacji do używania przy porównywaniu elementy, lub <see langword="null" /> do używania domyślna funkcja porównująca <see cref="P:System.Collections.Generic.Comparer`1.Default" />.</param>
        <summary>Sortuje elementy w zakresie elementów w <see cref="T:System.Collections.Generic.List`1" /> przy użyciu określona funkcja porównująca.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `comparer` podano elementy <xref:System.Collections.Generic.List%601> są sortowane przy użyciu określonego <xref:System.Collections.Generic.IComparer%601> implementacji.  
  
 Jeśli `comparer` jest `null`, domyślna funkcja porównująca <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> kontroli określa, czy typ `T` implementuje <xref:System.IComparable%601> ogólny interfejs i wykorzystuje tę implementację, jeśli jest dostępna.  Jeśli nie, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> kontroli określa, czy typ `T` implementuje <xref:System.IComparable> interfejsu.  Jeśli typ `T` nie implementuje albo interfejsu <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> zgłasza <xref:System.InvalidOperationException>.  
  
 Ta metoda używa <xref:System.Array.Sort%2A?displayProperty=nameWithType>, którego dotyczy introspective sortowania w następujący sposób:  
  
-   Jeśli rozmiar partycji jest mniej niż 16 elementów, używa algorytmu sortowania wstawiania  
  
-   Jeśli liczba partycji przekracza 2 dziennika *n*, gdzie *n* jest zakresu wartości tablicy wejściowej używa [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algorytmu.  
  
-   W przeciwnym razie używa algorytmu Quicksort.  
  
 Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana. Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.  
  
 Średnia, ta metoda jest O (*n* dziennika *n*) operację, której *n* jest <xref:System.Collections.Generic.List%601.Count%2A>; w najgorszym przypadku jest O (*n* <sup>2</sup>) operacji.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Collections.Generic.List%601.Sort%28System.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> przeciążenie metody i <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> przeciążenie metody.  
  
 W przykładzie zdefiniowano alternatywnego porównania ciągów o nazwie DinoCompare, która implementuje `IComparer<string>` (`IComparer(Of String)` w języku Visual Basic `IComparer<String^>` w programie Visual C++) interfejs generyczny. Moduł porównujący działa w następujący sposób: najpierw comparands są sprawdzane pod kątem `null`, odwołanie o wartości null jest traktowany jako mniejsza niż inne niż null. Po drugie długości ciągu zostaną porównane, a ciąg dłuższy jest uważany większa. Trzecie Jeśli długości są takie same, porównania ciągów zwykłej jest używany.  
  
 A <xref:System.Collections.Generic.List%601> ciągów jest tworzone i wypełniane przy użyciu nazwy pięć dinozaurów herbivorous i trzy dinozaurów mięsożernych zwierząt. W ramach każdej z tych dwóch grup nazwy nie są w dowolnej kolejności określonego sortowania. Zostanie wyświetlona lista, zakres zwierząt roślinożernych są sortowane przy użyciu alternatywnych porównania i ponownie zostanie wyświetlona lista.  
  
 <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> Przeciążenie metody jest następnie używany do wyszukiwania tylko zakres zwierząt roślinożernych "Brachiosaurus". Ciąg nie zostanie znaleziony i dopełnienia bitowego (~ operatora w języku C# i Visual C++ `Xor` -1 w języku Visual Basic) liczby ujemne zwracane przez <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> metoda jest używana jako indeks wstawiania nowych parametrów.  
  
 [!code-cpp[List\`1_SortSearchComparerRange#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparerRange#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparerRange#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparerRange/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza niż 0.  - lub - <paramref name="count" /> jest mniejszy niż 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> i <paramref name="count" /> nie zostanie określony prawidłowy zakres w <see cref="T:System.Collections.Generic.List`1" />.  - lub - wykonania <paramref name="comparer" /> spowodował błąd podczas sortowania. Na przykład <paramref name="comparer" /> nie mogą zwracać 0, podczas porównywania elementu z samym sobą.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> jest <see langword="null" />, a domyślna funkcja porównująca <see cref="P:System.Collections.Generic.Comparer`1.Default" /> nie można odnaleźć implementacji <see cref="T:System.IComparable`1" /> ogólny interfejs lub <see cref="T:System.IComparable" /> interfejs dla typu <paramref name="T" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#Generic#ICollection&lt;T&gt;#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements ICollection(Of T).IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.List&lt;'T&gt;.System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Collections.Generic.ICollection`1" /> jest tylko do odczytu.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Collections.Generic.ICollection`1" /> jest tylko do odczytu; w przeciwnym razie <see langword="false" />.  W implementacji domyślnej <see cref="T:System.Collections.Generic.List`1" />, ta właściwość zawsze zwraca <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W kolekcji tylko do odczytu po jej utworzeniu nie można dodawać, usuwać ani modyfikować elementów.  
  
 Kolekcja, która jest tylko do odczytu, jest po prostu zbiorem z otoką uniemożliwiającą zmianę kolekcji; w związku z tym, jeśli zmiany zostaną wprowadzone do podstawowej kolekcji, kolekcja tylko do odczytu uwzględni te zmiany.  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;!T&gt; System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#Generic#IEnumerable&lt;T&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of T) Implements IEnumerable(Of T).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;T&gt; ^ System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;T&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca moduł wyliczający, który dokonuje iteracji w kolekcji.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerator`1" /> Który może służyć do iterowania po kolekcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `foreach` Instrukcji języka C# (`for each` w języku C++ `For Each` w języku Visual Basic) ukrywa złożoność wyliczenia. W związku z tym przy użyciu `foreach` jest zalecane, zamiast bezpośrednie manipulowanie modułu wyliczającego.  
  
 Moduły wyliczające mogą służyć do odczytu danych w kolekcji, ale nie można za ich pomocą modyfikować kolekcji źródłowej.  
  
 Początkowo moduł wyliczający jest umieszczony przed pierwszym elementem w kolekcji. W tym miejscu <xref:System.Collections.Generic.IEnumerator%601.Current%2A> właściwość jest niezdefiniowana. W związku z tym należy wywołać <xref:System.Collections.IEnumerator.MoveNext%2A> metodę modułu wyliczającego pierwszy element do kolekcji przed odczytywania wartości <xref:System.Collections.Generic.IEnumerator%601.Current%2A>.  
  
 <xref:System.Collections.Generic.IEnumerator%601.Current%2A> Właściwość zwraca tego samego obiektu, dopóki nie <xref:System.Collections.IEnumerator.MoveNext%2A> jest wywoływana. <xref:System.Collections.IEnumerator.MoveNext%2A> Ustawia <xref:System.Collections.Generic.IEnumerator%601.Current%2A> do następnego elementu.  
  
 Jeśli <xref:System.Collections.IEnumerator.MoveNext%2A> przekazuje końcem kolekcji, moduł wyliczający jest umieszczony za ostatnim elementem w kolekcji i <xref:System.Collections.IEnumerator.MoveNext%2A> zwraca `false`. Gdy moduł wyliczający jest w tym miejscu kolejnych wywołań <xref:System.Collections.IEnumerator.MoveNext%2A> zwracają również `false`. Jeśli przez ostatnie wywołanie <xref:System.Collections.IEnumerator.MoveNext%2A> zwrócił `false`, <xref:System.Collections.Generic.IEnumerator%601.Current%2A> jest niezdefiniowana. Nie można ustawić <xref:System.Collections.Generic.IEnumerator%601.Current%2A> do pierwszego elementu w kolekcji; należy utworzyć nowe wystąpienie modułu wyliczającego zamiast tego.  
  
 Moduł wyliczający zachowuje ważność tak długo, jak długo kolekcja pozostaje niezmieniona. Jeśli zmiany zostały wprowadzone do kolekcji, takie jak dodawanie, modyfikowanie lub usuwanie elementów, moduł wyliczający jest bezpowrotnie unieważniona, a następne wywołanie <xref:System.Collections.IEnumerator.MoveNext%2A> lub <xref:System.Collections.IEnumerator.Reset%2A> zgłasza <xref:System.InvalidOperationException>.  
  
 Moduł wyliczający nie ma wyłącznego dostępu do kolekcji, w związku z tym wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość. Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania.  Aby zezwolić wielu wątkom na dostęp do kolekcji w celu odczytu i zapisu danych, należy zaimplementować własny mechanizm synchronizacji.  
  
 Domyślne implementacje kolekcji w <xref:System.Collections.Generic?displayProperty=nameWithType> przestrzeni nazw nie są zsynchronizowane.  
  
 Ta metoda jest operacją O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int arrayIndex) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Jednowymiarowa <see cref="T:System.Array" /> który jest miejscem docelowym elementów kopiowanych z <see cref="T:System.Collections.ICollection" />. <see cref="T:System.Array" /> Musi mieć indeksowania liczony od zera.</param>
        <param name="arrayIndex">Liczony od zera indeks w <c>tablicy</c> od rozpoczyna się kopiowanie które.</param>
        <summary>Kopiuje elementy <see cref="T:System.Collections.ICollection" /> do <see cref="T:System.Array" />, rozpoczynając od określonego <see cref="T:System.Array" /> indeksu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Jeśli typ źródła <xref:System.Collections.ICollection> nie można automatycznie rzutować na typ docelowy `array`, nierodzajowe implementacje <xref:System.Collections.ICollection.CopyTo%2A?displayProperty=nameWithType> throw <xref:System.InvalidCastException>, podczas gdy throw ogólnego implementacje <xref:System.ArgumentException>.  
  
 Ta metoda jest O (*n*) operację, której *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="arrayIndex" /> jest mniejsza niż 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> jest wielowymiarowy.  - lub - <paramref name="array" /> nie ma indeksowania liczony od zera.  - lub - liczba elementów w źródle <see cref="T:System.Collections.ICollection" /> jest większa niż dostępne miejsce od <paramref name="arrayIndex" /> do końca tablicy docelowej <paramref name="array" />.  - lub - typ źródła <see cref="T:System.Collections.ICollection" /> nie można automatycznie rzutować na typ docelowy <paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.ICollection.IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.List&lt;'T&gt;.System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy uzyskują dostęp do <see cref="T:System.Collections.ICollection" /> jest synchronizowane (wielowątkowość).</summary>
        <value>
          <see langword="true" /> Jeśli dostęp do <see cref="T:System.Collections.ICollection" /> jest synchronizowane (wielowątkowość); w przeciwnym razie <see langword="false" />.  W implementacji domyślnej <see cref="T:System.Collections.Generic.List`1" />, ta właściwość zawsze zwraca <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślne implementacje kolekcji w <xref:System.Collections.Generic?displayProperty=nameWithType> przestrzeni nazw nie są zsynchronizowane.  
  
 Wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość.  W rzadkich przypadkach, gdy wyliczenie twierdzi z dostępów do zapisu można zablokować kolekcję podczas całej wyliczenia.  Aby zezwolić wielu wątkom na dostęp do kolekcji w celu odczytu i zapisu danych, należy zaimplementować własny mechanizm synchronizacji.  
  
 <xref:System.Collections.ICollection.SyncRoot%2A> Zwraca obiekt, który może służyć do synchronizujący dostęp do <xref:System.Collections.ICollection>. Synchronizacja jest efektywne tylko wtedy, gdy wszystkie wątki zablokować ten obiekt przed uzyskaniem dostępu do kolekcji.  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Generic.List`1.System#Collections#ICollection#SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.ICollection.SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.List&lt;'T&gt;.System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera obiekt, który może służyć do synchronizujący dostęp do <see cref="T:System.Collections.ICollection" />.</summary>
        <value>Obiekt, który może służyć do synchronizujący dostęp do <see cref="T:System.Collections.ICollection" />.  W implementacji domyślnej <see cref="T:System.Collections.Generic.List`1" />, ta właściwość zawsze zwraca bieżącego wystąpienia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślne implementacje kolekcji w <xref:System.Collections.Generic?displayProperty=nameWithType> przestrzeni nazw nie są zsynchronizowane.  
  
 Wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość.  Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania.  Aby zezwolić wielu wątkom na dostęp do kolekcji w celu odczytu i zapisu danych, należy zaimplementować własny mechanizm synchronizacji.  
  
 <xref:System.Collections.ICollection.SyncRoot%2A> Zwraca obiekt, który może służyć do synchronizujący dostęp do <xref:System.Collections.ICollection>. Synchronizacja jest efektywne tylko wtedy, gdy wszystkie wątki zablokować ten obiekt przed uzyskaniem dostępu do kolekcji. Poniższy kod przedstawia użycie <xref:System.Collections.ICollection.SyncRoot%2A> właściwości dla C#, C++ i Visual Basic.  
  
```csharp  
ICollection ic = ...;  
lock (ic.SyncRoot)   
{  
    // Access the collection.  
}  
```  
  
```vb  
Dim ic As ICollection = ...  
SyncLock ic.SyncRoot  
    ' Access the collection.  
End SyncLock  
```  
  
```cpp#  
ICollection^ ic = ...;  
try   
{  
    Monitor::Enter(ic->SyncRoot);  
    // Access the collection.  
}  
finally   
{  
    Monitor::Exit(ic->SyncRoot);  
}  
```  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Generic.List`1.System#Collections#ICollection#IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca moduł wyliczający, który dokonuje iteracji w kolekcji.</summary>
        <returns>
          <see cref="T:System.Collections.IEnumerator" /> Który może służyć do iterowania po kolekcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `foreach` Instrukcji języka C# (`for each` w języku C++ `For Each` w języku Visual Basic) ukrywa złożoność wyliczenia. W związku z tym przy użyciu `foreach` jest zalecane, zamiast bezpośrednie manipulowanie modułu wyliczającego.  
  
 Moduły wyliczające mogą służyć do odczytu danych w kolekcji, ale nie można za ich pomocą modyfikować kolekcji źródłowej.  
  
 Początkowo moduł wyliczający jest umieszczony przed pierwszym elementem w kolekcji. <xref:System.Collections.IEnumerator.Reset%2A> również wprowadzono moduł wyliczający wróć do tej pozycji.  W tym miejscu <xref:System.Collections.IEnumerator.Current%2A> właściwość jest niezdefiniowana. W związku z tym należy wywołać <xref:System.Collections.IEnumerator.MoveNext%2A> metodę modułu wyliczającego pierwszy element do kolekcji przed odczytywania wartości <xref:System.Collections.IEnumerator.Current%2A>.  
  
 <xref:System.Collections.IEnumerator.Current%2A> Właściwość zwraca ten sam obiekt do momentu <xref:System.Collections.IEnumerator.MoveNext%2A> lub <xref:System.Collections.IEnumerator.Reset%2A> jest wywoływana. <xref:System.Collections.IEnumerator.MoveNext%2A> Ustawia <xref:System.Collections.IEnumerator.Current%2A> do następnego elementu.  
  
 Jeśli <xref:System.Collections.IEnumerator.MoveNext%2A> przekazuje końcem kolekcji, moduł wyliczający jest umieszczony za ostatnim elementem w kolekcji i <xref:System.Collections.IEnumerator.MoveNext%2A> zwraca `false`. Gdy moduł wyliczający jest w tym miejscu kolejnych wywołań <xref:System.Collections.IEnumerator.MoveNext%2A> zwracają również `false`. Jeśli przez ostatnie wywołanie <xref:System.Collections.IEnumerator.MoveNext%2A> zwrócił `false`, <xref:System.Collections.IEnumerator.Current%2A> jest niezdefiniowana. Aby ustawić <xref:System.Collections.IEnumerator.Current%2A> aby pierwszym elementem kolekcji ponownie, należy wywołać <xref:System.Collections.IEnumerator.Reset%2A> następuje <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Moduł wyliczający zachowuje ważność tak długo, jak długo kolekcja pozostaje niezmieniona. Jeśli zmiany zostały wprowadzone do kolekcji, takie jak dodawanie, modyfikowanie lub usuwanie elementów, moduł wyliczający jest bezpowrotnie unieważniona, a następne wywołanie <xref:System.Collections.IEnumerator.MoveNext%2A> lub <xref:System.Collections.IEnumerator.Reset%2A> zgłasza <xref:System.InvalidOperationException>.  
  
 Moduł wyliczający nie ma wyłącznego dostępu do kolekcji, w związku z tym wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość.  Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania.  Aby zezwolić wielu wątkom na dostęp do kolekcji w celu odczytu i zapisu danych, należy zaimplementować własny mechanizm synchronizacji.  
  
 Domyślne implementacje kolekcji w <xref:System.Collections.Generic?displayProperty=nameWithType> przestrzeni nazw nie są zsynchronizowane.  
  
 Ta metoda jest operacją O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Add">
      <MemberSignature Language="C#" Value="int IList.Add (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.Add(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Add (item As Object) As Integer Implements IList.Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.Add(System::Object ^ item) = System::Collections::IList::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Add(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">
          <see cref="T:System.Object" /> Do dodania do <see cref="T:System.Collections.IList" />.</param>
        <summary>Dodaje element do <see cref="T:System.Collections.IList" />.</summary>
        <returns>Pozycja, do której dodano nowy element.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Collections.Generic.List%601.Count%2A> jest mniejsza niż <xref:System.Collections.Generic.List%601.Capacity%2A>, ta metoda jest operacją O(1). Jeśli pojemność wymaga zwiększenia w celu uwzględnienia nowego elementu, ta metoda staje się O (*n*) operację, której *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="item" /> jest typu, który nie jest możliwa do przypisania do <see cref="T:System.Collections.IList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Contains">
      <MemberSignature Language="C#" Value="bool IList.Contains (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IList.Contains(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Contains (item As Object) As Boolean Implements IList.Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IList.Contains(System::Object ^ item) = System::Collections::IList::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">
          <see cref="T:System.Object" /> Do zlokalizowania w <see cref="T:System.Collections.IList" />.</param>
        <summary>Określa, czy <see cref="T:System.Collections.IList" /> zawiera określoną wartość.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="item" /> znajduje się w <see cref="T:System.Collections.IList" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda określa równości przy użyciu domyślna funkcja porównująca równości <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> dla `T`, typu wartości na liście.  
  
 Ta metoda wykonuje wyszukiwanie liniowe; w związku z tym ta metoda jest O (*n*) operację, której *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IndexOf">
      <MemberSignature Language="C#" Value="int IList.IndexOf (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.IndexOf(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#IndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function IndexOf (item As Object) As Integer Implements IList.IndexOf" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.IndexOf(System::Object ^ item) = System::Collections::IList::IndexOf;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.IndexOf(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">Obiekt do zlokalizowania w <see cref="T:System.Collections.IList" />.</param>
        <summary>Określa indeks konkretny element w <see cref="T:System.Collections.IList" />.</summary>
        <returns>Indeks <paramref name="item" /> jeśli je znaleziono na liście; w przeciwnym razie wartość -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda określa równości przy użyciu domyślna funkcja porównująca równości <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> dla `T`, typu wartości na liście.  
  
 Ta metoda wykonuje wyszukiwanie liniowe; w związku z tym ta metoda jest O (*n*) operację, której *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="item" /> jest typu, który nie jest możliwa do przypisania do <see cref="T:System.Collections.IList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Insert">
      <MemberSignature Language="C#" Value="void IList.Insert (int index, object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Insert(int32 index, object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Insert (index As Integer, item As Object) Implements IList.Insert" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Insert(int index, System::Object ^ item) = System::Collections::IList::Insert;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Insert(System.Int32,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">Liczony od zera indeks, w którym <c>elementu</c> powinien zostać wstawiony.</param>
        <param name="item">Obiekt do wstawienia do <see cref="T:System.Collections.IList" />.</param>
        <summary>Wstawia element do <see cref="T:System.Collections.IList" /> pod określonym indeksem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `index` jest równa liczbie elementów w <xref:System.Collections.IList>, następnie `item` jest dołączany na końcu.  
  
 Ta metoda jest O (*n*) operację, której *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> nie jest prawidłowym indeksem w <see cref="T:System.Collections.IList" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="item" /> jest typu, który nie jest możliwa do przypisania do <see cref="T:System.Collections.IList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#IList#IsFixedSize" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFixedSize As Boolean Implements IList.IsFixedSize" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.IList.IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.List&lt;'T&gt;.System.Collections.IList.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Collections.IList" /> ma stały rozmiar.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Collections.IList" /> ma ustalony rozmiar; w przeciwnym razie <see langword="false" />.  W implementacji domyślnej <see cref="T:System.Collections.Generic.List`1" />, ta właściwość zawsze zwraca <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W kolekcji o stałym rozmiarze po jej utworzeniu nie można dodawać ani usuwać elementów, jednak można modyfikować istniejące elementy.  
  
 Kolekcja o stałym rozmiarze jest po prostu kolekcji z otoką, który uniemożliwia Dodawanie i usuwanie elementów; w związku z tym zmian w źródłowej kolekcji, włączając Dodawanie lub usuwanie elementów z kolekcji o stałym rozmiarze odzwierciedla te zmiany.  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#IList#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements IList.IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.IList.IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.List&lt;'T&gt;.System.Collections.IList.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Collections.IList" /> jest tylko do odczytu.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Collections.IList" /> jest tylko do odczytu; w przeciwnym razie <see langword="false" />.  W implementacji domyślnej <see cref="T:System.Collections.Generic.List`1" />, ta właściwość zawsze zwraca <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W kolekcji tylko do odczytu po jej utworzeniu nie można dodawać, usuwać ani modyfikować elementów.  
  
 Kolekcja, która jest tylko do odczytu, jest po prostu zbiorem z otoką uniemożliwiającą zmianę kolekcji; w związku z tym, jeśli zmiany zostaną wprowadzone do podstawowej kolekcji, kolekcja tylko do odczytu uwzględni te zmiany.  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IList.Item[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IList.Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#IList#Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" Property Item(index As Integer) As Object Implements IList.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.IList.Item[int] { System::Object ^ get(int index); void set(int index, System::Object ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.List&lt;'T&gt;.System.Collections.IList.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Liczony od zera indeks elementu, który ma zostać pobrany lub skonfigurowany.</param>
        <summary>Pobieranie lub konfigurowanie elementów pod określonym indeksem.</summary>
        <value>Element pod określonym indeksem.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Używa języka C# [to](~/docs/csharp/language-reference/keywords/this.md) — słowo kluczowe, aby zdefiniować indeksatory zamiast wykonania <xref:System.Collections.Generic.List%601.System%23Collections%23IList%23Item%2A> właściwości. Implementuje Visual Basic <xref:System.Collections.Generic.List%601.System%23Collections%23IList%23Item%2A> jako domyślna właściwość, która zapewnia te same funkcje indeksowania.  
  
 Pobieranie wartości tej właściwości jest operacją O(1); Ustawienie właściwości jest również O(1) operacji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> nie jest prawidłowym indeksem w <see cref="T:System.Collections.IList" />.</exception>
        <exception cref="T:System.ArgumentException">Właściwość jest ustawiona i <paramref name="value" /> jest typu, który nie jest możliwa do przypisania do <see cref="T:System.Collections.IList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Remove">
      <MemberSignature Language="C#" Value="void IList.Remove (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Remove(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Remove (item As Object) Implements IList.Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Remove(System::Object ^ item) = System::Collections::IList::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">Obiekt do usunięcia z <see cref="T:System.Collections.IList" />.</param>
        <summary>Usuwa pierwsze wystąpienie określonego obiektu z <see cref="T:System.Collections.IList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda określa równości przy użyciu domyślna funkcja porównująca równości <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> dla `T`, typu wartości na liście.  
  
 Ta metoda wykonuje wyszukiwanie liniowe; w związku z tym ta metoda jest O (*n*) operację, której *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="item" /> jest typu, który nie jest możliwa do przypisania do <see cref="T:System.Collections.IList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public T[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T[] ToArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.ToArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToArray () As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;T&gt; ^ ToArray();" />
      <MemberSignature Language="F#" Value="member this.ToArray : unit -&gt; 'T[]" Usage="list.ToArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Kopiuje elementy <see cref="T:System.Collections.Generic.List`1" /> do nowej tablicy.</summary>
        <returns>Tablica zawierająca kopie elementów <see cref="T:System.Collections.Generic.List`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Skopiowane elementy przy użyciu <xref:System.Array.Copy%2A?displayProperty=nameWithType>, czyli O (*n*) operację, której *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 Ta metoda jest O (*n*) operację, której *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Collections.Generic.List%601.ToArray%2A> — metoda i inne metody <xref:System.Collections.Generic.List%601> klasy, która działa w wypadku zakresów. Na koniec przykładzie <xref:System.Collections.Generic.List%601.GetRange%2A> metody jest używany do pobierania trzy elementy z listy, począwszy od indeksu lokalizacji 2. <xref:System.Collections.Generic.List%601.ToArray%2A> Wywoływana jest metoda powstałe w ten sposób <xref:System.Collections.Generic.List%601>, tworzenie tablicy trzy elementy. Elementy tablicy są wyświetlane.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimExcess">
      <MemberSignature Language="C#" Value="public void TrimExcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TrimExcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.TrimExcess" />
      <MemberSignature Language="VB.NET" Value="Public Sub TrimExcess ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TrimExcess();" />
      <MemberSignature Language="F#" Value="member this.TrimExcess : unit -&gt; unit" Usage="list.TrimExcess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ustawia pojemność na rzeczywistą liczbę elementów w <see cref="T:System.Collections.Generic.List`1" />, jeśli ten numer jest mniejsza niż wartość progowa.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może służyć do narzut zminimalizować pamięci kolekcji, jeśli żadne nowe elementy, które zostaną dodane do kolekcji. Koszt ponowne przydzielanie i kopiowanie dużej <xref:System.Collections.Generic.List%601> mogą być jednak znaczące, więc <xref:System.Collections.Generic.List%601.TrimExcess%2A> — metoda nie robi nic, jeśli lista jest więcej niż 90 procent pojemności. Dzięki temu można uniknąć ponoszenia koszt dużych; Ponowna alokacja dla niewielkich korzyści.  
  
> [!NOTE]
>  Bieżący próg 90 procent mogą ulec zmianie w przyszłych wersjach.  
  
 Ta metoda jest O (*n*) operację, której *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 Aby zresetować <xref:System.Collections.Generic.List%601> do stanu początkowego wywołać <xref:System.Collections.Generic.List%601.Clear%2A> metoda przed wywołaniem <xref:System.Collections.Generic.List%601.TrimExcess%2A> — metoda. Przycinanie pustą <xref:System.Collections.Generic.List%601> ustawia pojemność <xref:System.Collections.Generic.List%601> do wydajności domyślnej.  
  
 Wydajność można również ustawić za pomocą <xref:System.Collections.Generic.List%601.Capacity%2A> właściwości.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano sposób sprawdzania zdolności produkcyjnych i liczba <xref:System.Collections.Generic.List%601> zawiera obiekt biznesowy proste i przedstawia przy użyciu <xref:System.Collections.Generic.List%601.TrimExcess%2A> metodę, aby usunąć dodatkowej pojemności.  
  
 [!code-csharp[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/vb/module1.vb#1)]  
  
 W poniższym przykładzie pokazano <xref:System.Collections.Generic.List%601.TrimExcess%2A> metody. Kilka właściwości i metody <xref:System.Collections.Generic.List%601> klasy służą do dodawania, wstawianie i usuwanie elementów z listy ciągów. Następnie przy użyciu <xref:System.Collections.Generic.List%601.TrimExcess%2A> metoda jest używana do zmniejszenia wydajności, aby być zgodna z liczbą i <xref:System.Collections.Generic.List%601.Capacity%2A> i <xref:System.Collections.Generic.List%601.Count%2A> właściwości są wyświetlane. Jeśli niewykorzystana zdolność była mniejsza niż 10 procent całkowitej wydajności, listy czy nie został zmieniony. Na koniec zawartości listy zostały wyczyszczone.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.Clear" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="TrueForAll">
      <MemberSignature Language="C#" Value="public bool TrueForAll (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TrueForAll(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function TrueForAll (match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TrueForAll(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.TrueForAll : Predicate&lt;'T&gt; -&gt; bool" Usage="list.TrueForAll match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">
          <see cref="T:System.Predicate`1" /> Delegat definiujący warunki sprawdzania zgodności elementy.</param>
        <summary>Określa, czy każdy element w <see cref="T:System.Collections.Generic.List`1" /> pasuje do warunków zdefiniowanych przez określony predykat.</summary>
        <returns>
          <see langword="true" /> Jeśli wartość każdego elementu w <see cref="T:System.Collections.Generic.List`1" /> pasuje do warunków zdefiniowanych przez określony predykat; w przeciwnym razie <see langword="false" />. Jeśli na liście nie ma żadnych elementów, jest zwracana wartość <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601> Jest delegowany do metody, która zwraca `true` obiekt przekazywany do jest zgodne z warunkami określonymi w delegacie.  Elementy bieżącego <xref:System.Collections.Generic.List%601> indywidualnie są przekazywane do <xref:System.Predicate%601> delegata i przetwarzania jest zatrzymana, gdy zwraca delegata `false` dla każdego elementu. Elementy są przetwarzane w kolejności, i wszystkich wywołań w jednym wątku.  
  
 Ta metoda jest O (*n*) operację, której *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Collections.Generic.List%601.TrueForAll%2A> — metoda i kilka innych metod, które używają <xref:System.Predicate%601> Delegat ogólny.  
  
 A <xref:System.Collections.Generic.List%601> ciągów jest tworzony, zawierający 8 nazwy kolorowanka, z których (na pozycji 1 do 5) dwa kończyć się "saurus". W przykładzie zdefiniowano również metody predykatu wyszukiwania o nazwie `EndsWithSaurus`, który akceptuje parametr typu string i zwraca wartość typu Boolean wartość wskazującą, czy ciąg wejściowy kończy się na "saurus".  
  
 <xref:System.Collections.Generic.List%601.TrueForAll%2A> Metody są przesyłane za pośrednictwem listy od początku, przekazywanie kolejno do każdego elementu `EndsWithSaurus` metody. Zatrzymuje wyszukiwania, kiedy `EndsWithSaurus` metoda zwraca `false`.  
  
> [!NOTE]
>  W języku C# i Visual Basic, nie jest konieczne tworzenie `Predicate<string>` delegować (`Predicate(Of String)` w języku Visual Basic) jawnie. Te języki wnioskują o poprawnym delegacie z kontekstu, a następnie są tworzone automatycznie.  
  
 [!code-cpp[List\`1_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[List\`1_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_FindEtAl/cs/source.cs#1)]
 [!code-vb[List\`1_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="List&lt;T&gt;" FullName="System.Collections.Generic.List&lt;T&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a7f0f273a278f342094cd7219e6187d9518950fb" /><Meta Name="ms.sourcegitcommit" Value="37f75368be2e569ad59341f3fc6261b76b89db9d" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/07/2019" /><Meta Name="ms.locfileid" Value="68819133" /></Metadata><TypeSignature Language="C#" Value="public class List&lt;T&gt; : System.Collections.Generic.ICollection&lt;T&gt;, System.Collections.Generic.IEnumerable&lt;T&gt;, System.Collections.Generic.IList&lt;T&gt;, System.Collections.Generic.IReadOnlyCollection&lt;T&gt;, System.Collections.Generic.IReadOnlyList&lt;T&gt;, System.Collections.IList" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit List`1&lt;T&gt; extends System.Object implements class System.Collections.Generic.ICollection`1&lt;!T&gt;, class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.Generic.IList`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyList`1&lt;!T&gt;, class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Generic.List`1" />
  <TypeSignature Language="VB.NET" Value="Public Class List(Of T)&#xA;Implements ICollection(Of T), IEnumerable(Of T), IList, IList(Of T), IReadOnlyCollection(Of T), IReadOnlyList(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class List : System::Collections::Generic::ICollection&lt;T&gt;, System::Collections::Generic::IEnumerable&lt;T&gt;, System::Collections::Generic::IList&lt;T&gt;, System::Collections::Generic::IReadOnlyCollection&lt;T&gt;, System::Collections::Generic::IReadOnlyList&lt;T&gt;, System::Collections::IList" />
  <TypeSignature Language="F#" Value="type List&lt;'T&gt; = class&#xA;    interface IList&lt;'T&gt;&#xA;    interface IList&#xA;    interface IReadOnlyList&lt;'T&gt;&#xA;    interface ICollection&lt;'T&gt;&#xA;    interface seq&lt;'T&gt;&#xA;    interface IEnumerable&#xA;    interface ICollection&#xA;    interface IReadOnlyCollection&lt;'T&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Collections</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IList&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyList&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.Mscorlib_CollectionDebugView`1))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">Typ elementów na liście.</typeparam>
    <summary>Reprezentuje silnie wpisaną listę obiektów, do których można uzyskać dostęp za pomocą indeksu. Dostarcza metody do wyszukiwania, sortowania i manipulowania listami.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasa jest ogólnym odpowiednikiem <xref:System.Collections.ArrayList>klasy. <xref:System.Collections.Generic.List%601> Implementuje <xref:System.Collections.Generic.IList%601> interfejs ogólny przy użyciu tablicy, której rozmiar jest dynamicznie zwiększany w miarę potrzeb.  
  
 Możesz dodać elementy do a <xref:System.Collections.Generic.List%601> za <xref:System.Collections.Generic.List%601.Add%2A> pomocą metod lub <xref:System.Collections.Generic.List%601.AddRange%2A> .  
  
 <xref:System.Collections.Generic.List%601> Klasa używa metody porównującej równość i porównującej kolejności.  
  
-   Metody takie jak <xref:System.Collections.Generic.List%601.Contains%2A> <xref:System.Collections.Generic.List%601.IndexOf%2A> ,<xref:System.Collections.Generic.List%601.LastIndexOf%2A>, i<xref:System.Collections.Generic.Dictionary%602.Remove%2A> wykorzystują funkcję porównującą równość dla elementów listy. Domyślna funkcja porównująca równość dla `T` typu jest określana w następujący sposób. Jeśli typ `T` <xref:System.IEquatable%601.Equals%28%600%29> implementuje interfejs <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>generyczny, wówczas funkcja porównująca równość jest metodą tego interfejsu; w przeciwnym razie domyślna funkcja porównująca równość to. <xref:System.IEquatable%601>  
  
-   Metody takie jak <xref:System.Collections.Generic.List%601.BinarySearch%2A> i <xref:System.Collections.Generic.List%601.Sort%2A> wykorzystują funkcję porównującą porządkowanie dla elementów listy. Domyślna funkcja porównująca dla `T` typu jest określana w następujący sposób.  Jeśli typ `T` <xref:System.IComparable%601.CompareTo%28%600%29> `T` implementuje interfejs <xref:System.IComparable> generyczny, domyślną metodą porównującą jest metoda tego interfejsu; w przeciwnym razie, jeśli typ implementuje interfejs nieogólny, wówczas domyślnym <xref:System.IComparable%601> funkcja porównująca <xref:System.IComparable.CompareTo%28System.Object%29> jest metodą tego interfejsu. Jeśli typ `T` nie implementuje interfejsu, wówczas nie ma domyślnego modułu porównującego, a obiekt porównujący lub porównywania musi być jawnie podany.  
  
 Sortowanie <xref:System.Collections.Generic.List%601> nie jest gwarantowane.  Należy posortować <xref:System.Collections.Generic.List%601> przed wykonaniem operacji (takich jak <xref:System.Collections.Generic.List%601.BinarySearch%2A>), które wymagają <xref:System.Collections.Generic.List%601> posortowania.  
  
 Dostęp do elementów w tej kolekcji można uzyskać przy użyciu indeksu liczb całkowitych.  Indeksy w tej kolekcji są oparte na zero.  
  
 **Tylko .NET Framework:** W przypadku bardzo <xref:System.Collections.Generic.List%601> dużych obiektów można zwiększyć maksymalną pojemność do 2 000 000 000 elementów w systemie 64-bitowym, `enabled` ustawiając atrybut [`<gcAllowVeryLargeObjects>`](~/docs/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element.md) elementu konfiguracji na `true` w środowisku wykonawczym.  
  
 <xref:System.Collections.Generic.List%601>akceptuje `null` jako prawidłową wartość dla typów odwołań i umożliwia duplikowanie elementów.  
  
 W przypadku niezmiennej wersji <xref:System.Collections.Generic.List%601> klasy, zobacz <xref:System.Collections.Immutable.ImmutableList%601>.  
  
## <a name="performance-considerations"></a>Zagadnienia dotyczące wydajności  
 Przy podejmowaniu decyzji o tym, <xref:System.Collections.Generic.List%601> czy <xref:System.Collections.ArrayList> użyć klasy lub, obie <xref:System.Collections.Generic.List%601> funkcje mają podobną funkcjonalność, pamiętaj, że Klasa jest w większości przypadków lepsza i jest bezpieczna. Jeśli typ odwołania jest używany dla typu `T` <xref:System.Collections.Generic.List%601> klasy, zachowanie obu klas jest identyczne. Jeśli jednak typ wartości jest używany dla typu `T`, należy wziąć pod uwagę problemy z implementacją i opakowaniem.  
  
 Jeśli typ wartości jest używany dla typu `T`, kompilator generuje implementację <xref:System.Collections.Generic.List%601> klasy przeznaczonej dla tego typu wartości. Oznacza to, że element <xref:System.Collections.Generic.List%601> listy obiektu nie musi być opakowany, zanim będzie można użyć elementu i po około 500 elementach listy zostaną utworzone zapisane elementy listy bez opakowania, są większe niż pamięć użyta do wygenerowania implementacji klasy.  
  
 Upewnij się, że określony typ wartości używany `T` dla typu <xref:System.IEquatable%601> implementuje interfejs generyczny. Jeśli nie, metody takie jak <xref:System.Collections.Generic.List%601.Contains%2A> muszą <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> wywoływać metodę, która powoduje, że element listy, którego to dotyczy. Jeśli <xref:System.IComparable> typ wartości implementuje interfejs i posiadasz kod źródłowy, należy również <xref:System.IComparable%601> zaimplementować <xref:System.Collections.Generic.List%601.BinarySearch%2A> ogólny interfejs, aby zapobiec metodom i <xref:System.Collections.Generic.List%601.Sort%2A> z listy zapakowywanie. Jeśli nie jesteś własnym kodem źródłowym, Przekaż <xref:System.Collections.Generic.IComparer%601> obiekt <xref:System.Collections.Generic.List%601.BinarySearch%2A> do metody i <xref:System.Collections.Generic.List%601.Sort%2A>  
  
 Zaletą jest użycie implementacji <xref:System.Collections.Generic.List%601> klasy specyficznej dla typu zamiast <xref:System.Collections.ArrayList> używania klasy lub pisania silnie jednoznacznie określonej kolekcji otoki. Przyczyną jest to, że Twoja implementacja musi wykonać już działania .NET Framework, a środowisko uruchomieniowe języka wspólnego może współdzielić kod i metadane języka pośredniego firmy Microsoft, których implementacja nie może.  
  
## <a name="f-considerations"></a>F#Zagadnienia dotyczące  
 Klasa jest często używana w F# kodzie. <xref:System.Collections.Generic.List%601> Zamiast tego [listy](https://msdn.microsoft.com/library/83102799-f251-42e1-93ef-64232e8c5b1d), które są niezmienne, pojedynczo połączone listy, są zwykle preferowane. F# Lista zawiera uporządkowaną, niemodyfikowalną serię wartości i jest obsługiwana do programowania w stylu funkcjonalnym. Gdy jest używany F#z, <xref:System.Collections.Generic.List%601> Klasa jest zwykle określana przez [> ResizeArray —\<](https://msdn.microsoft.com/library/ee353447.aspx) typu skrótu, aby uniknąć konfliktów nazw z F# listami  
  
   
  
## Examples  

 [!INCLUDE[interactive-note](~/includes/csharp-interactive-note-some.md)]

 Poniższy przykład pokazuje, jak dodawać, usuwać i wstawiać prosty obiekt biznesowy w programie <xref:System.Collections.Generic.List%601>.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 Poniższy przykład ilustruje kilka właściwości i metod <xref:System.Collections.Generic.List%601> klasy generycznej typu String. (Na przykład <xref:System.Collections.Generic.List%601> typu złożonego, <xref:System.Collections.Generic.List%601.Contains%2A> Zobacz metodę).  
  
 Konstruktor bez parametrów służy do tworzenia listy ciągów z pojemnością domyślną. Właściwość jest wyświetlana, a <xref:System.Collections.Generic.List%601.Add%2A> następnie metoda jest używana do dodawania kilku elementów. <xref:System.Collections.Generic.List%601.Capacity%2A> Elementy są wyświetlane, a <xref:System.Collections.Generic.List%601.Capacity%2A> właściwość jest wyświetlana ponownie wraz <xref:System.Collections.Generic.List%601.Count%2A> z właściwością, aby pokazać, że pojemność została zwiększona w miarę potrzeby.  
  
 Metoda jest używana do testowania obecności elementu na liście <xref:System.Collections.Generic.List%601.Insert%2A> , metoda jest używana do wstawienia nowego elementu w środku listy, a zawartość listy zostanie ponownie wyświetlona. <xref:System.Collections.Generic.List%601.Contains%2A>  
  
 Właściwość Default <xref:System.Collections.Generic.List%601.Item%2A> (indeksator in C#) służy do pobierania elementu, <xref:System.Collections.Generic.List%601.Remove%2A> Metoda jest używana do usuwania pierwszego wystąpienia zduplikowanego elementu, który został dodany wcześniej, a zawartość jest ponownie wyświetlana. <xref:System.Collections.Generic.List%601.Remove%2A> Metoda zawsze usuwa pierwsze wystąpienie, które napotka.  
  
 Metoda jest używana w celu zredukowania pojemności do liczby, <xref:System.Collections.Generic.List%601.Capacity%2A> a są wyświetlane właściwości i <xref:System.Collections.Generic.List%601.Count%2A>. <xref:System.Collections.Generic.List%601.TrimExcess%2A> Jeśli niewykorzystana pojemność była mniejsza niż 10 procent całkowitej pojemności, nie można zmienić rozmiaru listy.  
  
 Na koniec <xref:System.Collections.Generic.List%601.Capacity%2A> <xref:System.Collections.Generic.List%601.Count%2A> Metoda służy do usuwania wszystkich elementów z listy, a są wyświetlane właściwości i. <xref:System.Collections.Generic.List%601.Clear%2A>  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp-interactive[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
    </remarks>
    <threadsafe>Publiczne statyczne (<see langword="Shared" /> w Visual Basic) członkowie tego typu są bezpieczne wątkowo. Wystąpienia elementów członkowskich nie dają gwarancji bezpieczeństwa wątków.  
  
Istnieje możliwość bezpiecznego wykonywania wielu operacji odczytu na <see cref="T:System.Collections.Generic.List`1" />, ale mogą wystąpić problemy, jeśli kolekcja jest modyfikowana podczas odczytywania. Aby zapewnić bezpieczeństwo wątku, Zablokuj kolekcję podczas operacji odczytu lub zapisu. Aby umożliwić dostęp do kolekcji wielu wątkom do odczytu i zapisu, musisz zaimplementować własną synchronizację. W przypadku kolekcji z wbudowaną synchronizacją Zobacz klasy w <see cref="N:System.Collections.Concurrent" /> przestrzeni nazw. Aby zapoznać się z wewnętrzną wielowątkową alternatywą, <see cref="T:System.Collections.Immutable.ImmutableList`1" /> zapoznaj się z klasą.</threadsafe>
    <altmember cref="T:System.Collections.IList" />
    <altmember cref="T:System.Collections.Immutable.ImmutableList`1" />
    <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Wykonywanie niezależnych od kultury operacji na ciągach w kolekcjach</related>
    <related type="Article" href="https://msdn.microsoft.com/library/f45331db-d595-46ec-9142-551d3d1eb1a7">Iteratory (C# i Visual Basic)</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Collections.Generic.List`1" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public List ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; List();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Collections.Generic.List`1" /> klasy, która jest pusta i ma domyślną pojemność początkową.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pojemność programu to liczba <xref:System.Collections.Generic.List%601> elementów <xref:System.Collections.Generic.List%601> , które mogą być przechowywane. Gdy elementy są dodawane do <xref:System.Collections.Generic.List%601>, pojemność jest automatycznie zwiększana zgodnie z wymaganiami przez ponowną alokację tablicy wewnętrznej.  
  
 Jeśli rozmiar kolekcji można oszacować przy użyciu <xref:System.Collections.Generic.List%601.%23ctor%28System.Int32%29> konstruktora i określenie początkowej pojemności eliminuje konieczność wykonywania wielu operacji zmiany rozmiaru podczas dodawania elementów <xref:System.Collections.Generic.List%601>do.  
  
 Wydajność można zmniejszyć przez wywołanie <xref:System.Collections.Generic.List%601.TrimExcess%2A> metody lub przez <xref:System.Collections.Generic.List%601.Capacity%2A> ustawienie właściwości jawnie. Zmniejszenie pojemności powoduje ponowną alokację pamięci i skopiowanie wszystkich elementów w <xref:System.Collections.Generic.List%601>.  
  
 Ten konstruktor jest operacją O (1).  
  
   
  
## Examples  

 [!INCLUDE[interactive-note](~/includes/csharp-interactive-note-some.md)]

 Poniższy przykład demonstruje Konstruktor <xref:System.Collections.Generic.List%601> bez parametrów klasy generycznej. Konstruktor bez parametrów tworzy listę z pojemnością domyślną, jak pokazano przez wyświetlanie <xref:System.Collections.Generic.List%601.Capacity%2A> właściwości.  
  
 Przykład dodaje, wstawia i usuwa elementy, pokazując, jak zmiany pojemności są używane w ramach tych metod.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp-interactive[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public List (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.#ctor(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; List(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.List&lt;'T&gt; : seq&lt;'T&gt; -&gt; System.Collections.Generic.List&lt;'T&gt;" Usage="new System.Collections.Generic.List&lt;'T&gt; collection" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">Kolekcja, której elementy są kopiowane do nowej listy.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Collections.Generic.List`1" /> klasy zawierające elementy skopiowane z określonej kolekcji i ma wystarczającą pojemność, aby pomieścić liczbę skopiowanych elementów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Elementy są kopiowane <xref:System.Collections.Generic.List%601> do tabeli w tej samej kolejności, w jakiej są odczytywane przez moduł wyliczający kolekcji.  
  
 Ten konstruktor jest operacją O (*n*), gdzie *n* jest liczbą elementów w `collection`.  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.Collections.Generic.List%601.%23ctor%2A> konstruktora i różne metody <xref:System.Collections.Generic.List%601> klasy, które działają na zakresach. Tablica ciągów jest tworzona i przenoszona do konstruktora, wypełniając listę elementami tablicy. Zostanie <xref:System.Collections.Generic.List%601.Capacity%2A> wyświetlona właściwość, aby pokazać, że początkowa pojemność jest dokładnie to, co jest wymagane do przechowywania elementów wejściowych.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="collection" />jest <see langword="null" />.</exception>
        <altmember cref="T:System.Collections.Generic.IEnumerable`1" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public List (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; List(int capacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.List&lt;'T&gt; : int -&gt; System.Collections.Generic.List&lt;'T&gt;" Usage="new System.Collections.Generic.List&lt;'T&gt; capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Liczba elementów, które mogą być początkowo przechowywane przez nową listę.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Collections.Generic.List`1" /> klasy, która jest pusta i ma określoną pojemność początkową.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pojemność programu to liczba <xref:System.Collections.Generic.List%601> elementów <xref:System.Collections.Generic.List%601> , które mogą być przechowywane. Gdy elementy są dodawane do <xref:System.Collections.Generic.List%601>, pojemność jest automatycznie zwiększana zgodnie z wymaganiami przez ponowną alokację tablicy wewnętrznej.  
  
 Jeśli rozmiar kolekcji można oszacować, określenie początkowej pojemności eliminuje konieczność wykonywania wielu operacji zmiany rozmiaru podczas dodawania elementów do <xref:System.Collections.Generic.List%601>.  
  
 Wydajność można zmniejszyć przez wywołanie <xref:System.Collections.Generic.List%601.TrimExcess%2A> metody lub przez <xref:System.Collections.Generic.List%601.Capacity%2A> ustawienie właściwości jawnie. Zmniejszenie pojemności powoduje ponowną alokację pamięci i skopiowanie wszystkich elementów w <xref:System.Collections.Generic.List%601>.  
  
 Ten konstruktor jest operacją O (*n*), gdzie *n* jest `capacity`.  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.Collections.Generic.List%601.%23ctor%28System.Int32%29> konstruktora. <xref:System.Collections.Generic.List%601> Tworzony jest ciąg o pojemności 4, ponieważ końcowy rozmiar listy jest znany jako dokładnie 4. Lista jest wypełniana czterema ciągami, a kopia tylko do odczytu jest tworzona przy użyciu <xref:System.Collections.Generic.List%601.AsReadOnly%2A> metody.  
  
 [!code-cpp[List\`1_AsReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_AsReadOnly/cpp/source.cpp#1)]
 [!code-csharp[List\`1_AsReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_AsReadOnly/cs/source.cs#1)]
 [!code-vb[List\`1_AsReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_AsReadOnly/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" />jest mniejsza niż 0.</exception>
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Add(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (item As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(T item);" />
      <MemberSignature Language="F#" Value="abstract member Add : 'T -&gt; unit&#xA;override this.Add : 'T -&gt; unit" Usage="list.Add item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Obiekt, który ma zostać dodany na końcu <see cref="T:System.Collections.Generic.List`1" />. Wartość może być <see langword="null" /> dla typów referencyjnych.</param>
        <summary>Dodaje obiekt na końcu <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601>akceptuje `null` jako prawidłową wartość dla typów odwołań i umożliwia duplikowanie elementów.  
  
 Jeśli <xref:System.Collections.Generic.List%601.Count%2A> już jest <xref:System.Collections.Generic.List%601.Capacity%2A>równa <xref:System.Collections.Generic.List%601> , Pojemność programu jest zwiększana przez automatyczne ponowne przydzielanie tablicy wewnętrznej, a istniejące elementy są kopiowane do nowej tablicy przed dodaniem nowego elementu.  
  
 Jeśli <xref:System.Collections.Generic.List%601.Count%2A> jest mniejsza niż <xref:System.Collections.Generic.List%601.Capacity%2A>, ta metoda jest operacją o (1). Jeśli pojemność musi zostać zwiększona w celu uwzględnienia nowego elementu, ta metoda będzie operacją O (*n*), gdzie *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  

 [!INCLUDE[interactive-note](~/includes/csharp-interactive-note-some.md)]

 Poniższy przykład pokazuje, jak dodawać, usuwać i wstawiać prosty obiekt biznesowy w programie <xref:System.Collections.Generic.List%601>.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 Poniższy przykład ilustruje kilka właściwości i metod <xref:System.Collections.Generic.List%601> klasy generycznej, w <xref:System.Collections.Generic.List%601.Add%2A> tym metodę. Konstruktor bez parametrów służy do tworzenia listy ciągów z pojemnością 0. Właściwość jest wyświetlana, a <xref:System.Collections.Generic.List%601.Add%2A> następnie metoda jest używana do dodawania kilku elementów. <xref:System.Collections.Generic.List%601.Capacity%2A> Elementy są wyświetlane, a <xref:System.Collections.Generic.List%601.Capacity%2A> właściwość jest wyświetlana ponownie wraz <xref:System.Collections.Generic.List%601.Count%2A> z właściwością, aby pokazać, że pojemność została zwiększona w miarę potrzeby.  
  
 Inne właściwości i metody są używane do wyszukiwania, wstawiania i usuwania elementów z listy, a wreszcie Wyczyść listę.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp-interactive[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberSignature Language="F#" Value="member this.AddRange : seq&lt;'T&gt; -&gt; unit" Usage="list.AddRange collection" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">Kolekcja, której elementy należy dodać na końcu <see cref="T:System.Collections.Generic.List`1" />. Sama kolekcja nie może być <see langword="null" />, ale może zawierać elementy, które są <see langword="null" />, jeśli typ <paramref name="T" /> jest typem referencyjnym.</param>
        <summary>Dodaje elementy określonej kolekcji na końcu <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kolejność elementów w kolekcji jest zachowywana w <xref:System.Collections.Generic.List%601>.  
  
 Jeśli nowy <xref:System.Collections.Generic.List%601.Count%2A> (bieżący <xref:System.Collections.Generic.List%601.Count%2A> i rozmiar kolekcji) będzie większy niż <xref:System.Collections.Generic.List%601.Capacity%2A>, pojemność <xref:System.Collections.Generic.List%601> jest zwiększana przez automatyczne ponowne przydzielanie tablicy wewnętrznej w celu uwzględnienia nowych elementów, a istniejące elementy są kopiowane do nowej tablicy przed dodaniem nowych elementów.  
  
 Jeśli może obsłużyć nowe <xref:System.Collections.Generic.List%601.Capacity%2A>elementy bez zwiększania, ta metoda jest operacją o (*n*), gdzie *n* to liczba elementów do dodania. <xref:System.Collections.Generic.List%601> Jeśli pojemność musi zostać zwiększona w celu uwzględnienia nowych elementów, ta metoda jest operacją o (*n* + *m*), gdzie *n* jest liczbą elementów do dodania, a *m* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Poniższy przykład ilustruje <xref:System.Collections.Generic.List%601.AddRange%2A> metodę i różne inne metody <xref:System.Collections.Generic.List%601> klasy, które działają na zakresach. Tablica ciągów jest tworzona i przenoszona do konstruktora, wypełniając listę elementami tablicy. <xref:System.Collections.Generic.List%601.AddRange%2A> Metoda jest wywoływana, z listą jako argumentem. Wynika to z tego, że bieżące elementy listy są dodawane na końcu listy, duplikując wszystkie elementy.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="collection" />jest <see langword="null" />.</exception>
        <altmember cref="T:System.Collections.Generic.IEnumerable`1" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="AsReadOnly">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt; AsReadOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;!T&gt; AsReadOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.AsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Function AsReadOnly () As ReadOnlyCollection(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;T&gt; ^ AsReadOnly();" />
      <MemberSignature Language="F#" Value="member this.AsReadOnly : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;'T&gt;" Usage="list.AsReadOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca otokę tylko <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> do odczytu dla bieżącej kolekcji.</summary>
        <returns>Obiekt, który działa jako otoka tylko do odczytu dla bieżącego <see cref="T:System.Collections.Generic.List`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby zapobiec wszelkim modyfikacjom <xref:System.Collections.Generic.List%601> obiektu, Uwidocznij go tylko za pomocą tej otoki. <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> Obiekt nie ujawnia metod, które modyfikują kolekcję. Jeśli jednak zmiany są wprowadzane do obiektu bazowego <xref:System.Collections.Generic.List%601> , Kolekcja tylko do odczytu odzwierciedla te zmiany.  
  
 Ta metoda jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.Collections.Generic.List%601.AsReadOnly%2A> metodę. <xref:System.Collections.Generic.List%601> Tworzony jest ciąg o pojemności 4, ponieważ końcowy rozmiar listy jest znany jako dokładnie 4. Lista jest wypełniana czterema ciągami, a <xref:System.Collections.Generic.List%601.AsReadOnly%2A> Metoda jest używana do uzyskiwania ogólnej implementacji interfejsu w <xref:System.Collections.Generic.IList%601> trybie tylko do odczytu, która otacza oryginalną listę.  
  
 Element oryginalnej listy jest ustawiony na wartość "Coelophysis" przy użyciu <xref:System.Collections.Generic.List%601.Item%2A> właściwości (indeksator w programie C#), a zawartość listy tylko do odczytu jest ponownie wyświetlana, aby pokazać, że jest tylko otoką dla oryginalnej listy.  
  
 [!code-cpp[List\`1_AsReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_AsReadOnly/cpp/source.cpp#1)]
 [!code-csharp[List\`1_AsReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_AsReadOnly/cs/source.cs#1)]
 [!code-vb[List\`1_AsReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_AsReadOnly/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BinarySearch">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Używa algorytmu wyszukiwania binarnego do lokalizowania określonego elementu w posortowanym <see cref="T:System.Collections.Generic.List`1" /> lub części.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public int BinarySearch (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 BinarySearch(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.BinarySearch(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function BinarySearch (item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int BinarySearch(T item);" />
      <MemberSignature Language="F#" Value="member this.BinarySearch : 'T -&gt; int" Usage="list.BinarySearch item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Obiekt, który ma zostać zlokalizowany. Wartość może być <see langword="null" /> dla typów referencyjnych.</param>
        <summary>Przeszukuje całe posortowane <see cref="T:System.Collections.Generic.List`1" /> dla elementu przy użyciu domyślnej funkcji porównującej i zwraca indeks (liczony od zera) elementu.</summary>
        <returns>Indeks <paramref name="item" /> (liczony od zera) w sortowaniu <see cref="T:System.Collections.Generic.List`1" />, jeśli <paramref name="item" /> został znaleziony; w przeciwnym razie liczba ujemna, która jest odwrotnym uzupełnieniem indeksu następnego elementu, który jest większy niż <paramref name="item" /> lub, jeśli nie ma większego elementu, to uzupełnienie <see cref="P:System.Collections.Generic.List`1.Count" />bitowe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa domyślnej wartości porównującej <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> dla typu `T` w celu określenia kolejności elementów listy. Właściwość sprawdza, czy typ `T` implementuje <xref:System.IComparable%601> interfejs generyczny i używa tej implementacji, jeśli jest dostępny. <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>  Jeśli nie, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> Sprawdź, czy `T` typ implementuje <xref:System.IComparable> interfejs.  Jeśli typ `T` nie implementuje żadnego interfejsu, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> zgłasza <xref:System.InvalidOperationException>.  
  
 Obiekt <xref:System.Collections.Generic.List%601> musi być już posortowany zgodnie z implementacją programu porównującego; w przeciwnym razie wynik jest nieprawidłowy.  
  
 Porównywanie `null` z dowolnym typem referencyjnym jest dozwolone i nie generuje wyjątku podczas korzystania z <xref:System.IComparable%601> interfejsu ogólnego. Podczas sortowania `null` jest uznawana za mniej niż każdy inny obiekt.  
  
 <xref:System.Collections.Generic.List%601> Jeśli zawiera więcej niż jeden element o tej samej wartości, metoda zwraca tylko jeden z wystąpień i może zwrócić dowolne wystąpienie, niekoniecznie pierwsze.  
  
 <xref:System.Collections.Generic.List%601> Jeśli nie zawiera określonej wartości, metoda zwraca ujemną liczbę całkowitą. Można zastosować operację dopełnienia bitowego (~) do tej ujemnej liczby całkowitej, aby uzyskać indeks pierwszego elementu, który jest większy niż wartość wyszukiwania. Podczas wstawiania wartości do <xref:System.Collections.Generic.List%601>, ten indeks powinien być używany jako punkt wstawiania, aby zachować porządek sortowania.  
  
 Ta metoda jest operacją O (log *n*), gdzie *n* jest liczbą elementów w zakresie.  
  
   
  
## Examples  
 Poniższy przykład ilustruje <xref:System.Collections.Generic.List%601.Sort> Przeciążenie metody <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> i Przeciążenie metody. <xref:System.Collections.Generic.List%601> Ciąg jest tworzony i wypełniany czterema ciągami, w określonej kolejności. Lista zostanie wyświetlona, posortowana i wyświetlona ponownie.  
  
 Przeciążenie metody jest następnie używane do wyszukiwania dwóch ciągów, które nie znajdują się na liście, <xref:System.Collections.Generic.List%601.Insert%2A> a metoda jest używana do ich wstawiania. <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> Wartość <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> zwracana metody jest ujemna w każdym przypadku, ponieważ ciągi nie znajdują się na liście. Przejęcie bitowego uzupełniania (operator ~ w C# i C++Wizualizacja `Xor` ,-1 w Visual Basic) tej liczby ujemnej daje indeks pierwszego elementu na liście, który jest większy niż ciąg wyszukiwania i wstawiania w tej lokalizacji zachowuje porządek sortowania. Drugi ciąg wyszukiwania jest większy niż dowolny element na liście, więc pozycja wstawiania znajduje się na końcu listy.  
  
 [!code-cpp[List\`1_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearch/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Domyślna funkcja porównująca <see cref="P:System.Collections.Generic.Comparer`1.Default" /> nie może znaleźć implementacji <see cref="T:System.IComparable`1" /> interfejsu generycznego lub <see cref="T:System.IComparable" /> interfejsu dla typu <paramref name="T" />.</exception>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Wykonywanie niezależnych od kultury operacji na ciągach w kolekcjach</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public int BinarySearch (T item, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 BinarySearch(!T item, class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function BinarySearch (item As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int BinarySearch(T item, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="member this.BinarySearch : 'T * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; int" Usage="list.BinarySearch (item, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="item">Obiekt, który ma zostać zlokalizowany. Wartość może być <see langword="null" /> dla typów referencyjnych.</param>
        <param name="comparer"><see cref="T:System.Collections.Generic.IComparer`1" /> Implementacja do użycia podczas porównywania elementów.  
  
—lub— 
 <see langword="null" />Aby użyć domyślnej programu porównującego <see cref="P:System.Collections.Generic.Comparer`1.Default" />.</param>
        <summary>Przeszukuje całe posortowane <see cref="T:System.Collections.Generic.List`1" /> dla elementu przy użyciu określonej funkcji porównującej i zwraca indeks (liczony od zera) elementu.</summary>
        <returns>Indeks <paramref name="item" /> (liczony od zera) w sortowaniu <see cref="T:System.Collections.Generic.List`1" />, jeśli <paramref name="item" /> został znaleziony; w przeciwnym razie liczba ujemna, która jest odwrotnym uzupełnieniem indeksu następnego elementu, który jest większy niż <paramref name="item" /> lub, jeśli nie ma większego elementu, to uzupełnienie <see cref="P:System.Collections.Generic.List`1.Count" />bitowe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Moduł porównujący dostosowuje sposób porównywania elementów. Można na przykład użyć <xref:System.Collections.CaseInsensitiveComparer> wystąpienia jako modułu porównującego do wykonywania wyszukiwania ciągów bez uwzględniania wielkości liter.  
  
 Jeśli `comparer` jest podany, elementy <xref:System.Collections.Generic.List%601> są porównywane z określoną wartością przy użyciu określonej <xref:System.Collections.Generic.IComparer%601> implementacji.  
  
 Jeśli `comparer` jest `null`, domyślna funkcja porównująca <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> sprawdza, `T` czy typ <xref:System.IComparable%601> implementuje interfejs generyczny i używa tej implementacji, jeśli jest dostępny.  Jeśli nie, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> Sprawdź, czy `T` typ implementuje <xref:System.IComparable> interfejs.  Jeśli typ `T` nie implementuje żadnego interfejsu, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> zgłasza <xref:System.InvalidOperationException>.  
  
 Obiekt <xref:System.Collections.Generic.List%601> musi być już posortowany zgodnie z implementacją programu porównującego; w przeciwnym razie wynik jest nieprawidłowy.  
  
 Porównywanie `null` z dowolnym typem referencyjnym jest dozwolone i nie generuje wyjątku podczas korzystania z <xref:System.IComparable%601> interfejsu ogólnego. Podczas sortowania `null` jest uznawana za mniej niż każdy inny obiekt.  
  
 <xref:System.Collections.Generic.List%601> Jeśli zawiera więcej niż jeden element o tej samej wartości, metoda zwraca tylko jeden z wystąpień i może zwrócić dowolne wystąpienie, niekoniecznie pierwsze.  
  
 <xref:System.Collections.Generic.List%601> Jeśli nie zawiera określonej wartości, metoda zwraca ujemną liczbę całkowitą. Można zastosować operację dopełnienia bitowego (~) do tej ujemnej liczby całkowitej, aby uzyskać indeks pierwszego elementu, który jest większy niż wartość wyszukiwania. Podczas wstawiania wartości do <xref:System.Collections.Generic.List%601>, ten indeks powinien być używany jako punkt wstawiania, aby zachować porządek sortowania.  
  
 Ta metoda jest operacją O (log *n*), gdzie *n* jest liczbą elementów w zakresie.  
  
   
  
## Examples  
 Poniższy przykład ilustruje <xref:System.Collections.Generic.List%601.Sort%28System.Collections.Generic.IComparer%7B%600%7D%29> Przeciążenie metody <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> i Przeciążenie metody.  
  
 W przykładzie zdefiniowano alternatywną funkcję porównującą dla ciągów o nazwie DinoCompare `IComparer<string>` ,`IComparer(Of String)` która implementuje interfejs `IComparer<String^>` ogólny ( C++w Visual Basic w języku Visual). Moduł porównujący działa w następujący sposób: Najpierw comparands są testowane dla `null`, a odwołanie o wartości null jest traktowane jako mniejsze niż wartość null. W drugim, długości ciągu są porównywane, a dłuższy ciąg jest uznawany za większy. Trzecia, jeśli długości są równe, używane jest zwykłe Porównywanie ciągów.  
  
 <xref:System.Collections.Generic.List%601> Ciąg jest tworzony i wypełniany czterema ciągami, w określonej kolejności. Zostanie wyświetlona lista, posortowana przy użyciu alternatywnej funkcji porównującej i ponownie wyświetlana.  
  
 Przeciążenie <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> metody jest następnie używane do wyszukiwania kilku ciągów, które nie znajdują się na liście, przy użyciu alternatywnego porównania. <xref:System.Collections.Generic.List%601.Insert%2A> Metoda jest używana do wstawiania ciągów. Te dwie metody znajdują się w funkcji o `SearchAndInsert`nazwie, wraz z kodem, aby przyjmować użycie bitowe (operator ~ w C# i C++Wizualizacja `Xor` ,-1 w Visual Basic) liczb ujemnych zwracanych <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> przez i używać go jako indeks służący do wstawiania nowego ciągu.  
  
 [!code-cpp[List\`1_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" />jest <see langword="null" />, a domyślna funkcja porównująca <see cref="P:System.Collections.Generic.Comparer`1.Default" /> nie może <see cref="T:System.IComparable`1" /> znaleźć implementacji interfejsu generycznego lub <see cref="T:System.IComparable" /> interfejsu dla typu <paramref name="T" />.</exception>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Wykonywanie niezależnych od kultury operacji na ciągach w kolekcjach</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public int BinarySearch (int index, int count, T item, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 BinarySearch(int32 index, int32 count, !T item, class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function BinarySearch (index As Integer, count As Integer, item As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int BinarySearch(int index, int count, T item, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="member this.BinarySearch : int * int * 'T * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; int" Usage="list.BinarySearch (index, count, item, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="item" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="index">Początkowy indeks (liczony od zera) zakresu do przeszukania.</param>
        <param name="count">Długość zakresu wyszukiwania.</param>
        <param name="item">Obiekt, który ma zostać zlokalizowany. Wartość może być <see langword="null" /> dla typów referencyjnych.</param>
        <param name="comparer">Implementacja do użycia podczas porównywania elementów lub <see langword="null" /> używania domyślnego programu porównującego <see cref="P:System.Collections.Generic.Comparer`1.Default" />. <see cref="T:System.Collections.Generic.IComparer`1" /></param>
        <summary>Przeszukuje zakres elementów w posortowaniu <see cref="T:System.Collections.Generic.List`1" /> dla elementu przy użyciu określonej funkcji porównującej i zwraca indeks (liczony od zera) elementu.</summary>
        <returns>Indeks <paramref name="item" /> (liczony od zera) w sortowaniu <see cref="T:System.Collections.Generic.List`1" />, jeśli <paramref name="item" /> został znaleziony; w przeciwnym razie liczba ujemna, która jest odwrotnym uzupełnieniem indeksu następnego elementu, który jest większy niż <paramref name="item" /> lub, jeśli nie ma większego elementu, to uzupełnienie <see cref="P:System.Collections.Generic.List`1.Count" />bitowe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Moduł porównujący dostosowuje sposób porównywania elementów. Można na przykład użyć <xref:System.Collections.CaseInsensitiveComparer> wystąpienia jako modułu porównującego do wykonywania wyszukiwania ciągów bez uwzględniania wielkości liter.  
  
 Jeśli `comparer` jest podany, elementy <xref:System.Collections.Generic.List%601> są porównywane z określoną wartością przy użyciu określonej <xref:System.Collections.Generic.IComparer%601> implementacji.  
  
 Jeśli `comparer` jest `null`, domyślna funkcja porównująca <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> sprawdza, `T` czy typ <xref:System.IComparable%601> implementuje interfejs generyczny i używa tej implementacji, jeśli jest dostępny.  Jeśli nie, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> Sprawdź, czy `T` typ implementuje <xref:System.IComparable> interfejs.  Jeśli typ `T` nie implementuje żadnego interfejsu, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> zgłasza <xref:System.InvalidOperationException>.  
  
 Obiekt <xref:System.Collections.Generic.List%601> musi być już posortowany zgodnie z implementacją programu porównującego; w przeciwnym razie wynik jest nieprawidłowy.  
  
 Porównywanie `null` z dowolnym typem referencyjnym jest dozwolone i nie generuje wyjątku podczas korzystania z <xref:System.IComparable%601> interfejsu ogólnego. Podczas sortowania `null` jest uznawana za mniej niż każdy inny obiekt.  
  
 <xref:System.Collections.Generic.List%601> Jeśli zawiera więcej niż jeden element o tej samej wartości, metoda zwraca tylko jeden z wystąpień i może zwrócić dowolne wystąpienie, niekoniecznie pierwsze.  
  
 <xref:System.Collections.Generic.List%601> Jeśli nie zawiera określonej wartości, metoda zwraca ujemną liczbę całkowitą. Można zastosować operację dopełnienia bitowego (~) do tej ujemnej liczby całkowitej, aby uzyskać indeks pierwszego elementu, który jest większy niż wartość wyszukiwania. Podczas wstawiania wartości do <xref:System.Collections.Generic.List%601>, ten indeks powinien być używany jako punkt wstawiania, aby zachować porządek sortowania.  
  
 Ta metoda jest operacją O (log *n*), gdzie *n* jest liczbą elementów w zakresie.  
  
   
  
## Examples  
 Poniższy przykład ilustruje <xref:System.Collections.Generic.List%601.Sort%28System.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> Przeciążenie metody <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> i Przeciążenie metody.  
  
 W przykładzie zdefiniowano alternatywną funkcję porównującą dla ciągów o nazwie DinoCompare `IComparer<string>` ,`IComparer(Of String)` która implementuje interfejs `IComparer<String^>` ogólny ( C++w Visual Basic w języku Visual). Moduł porównujący działa w następujący sposób: Najpierw comparands są testowane dla `null`, a odwołanie o wartości null jest traktowane jako mniejsze niż wartość null. W drugim, długości ciągu są porównywane, a dłuższy ciąg jest uznawany za większy. Trzecia, jeśli długości są równe, używane jest zwykłe Porównywanie ciągów.  
  
 <xref:System.Collections.Generic.List%601> Jest tworzony i wypełniany przy użyciu nazw pięciu herbivorous dinozaurów i trzech dinozaurów carnivorous. W ramach każdej z tych dwóch grup nazwy nie są w żadnym konkretnym porządku sortowania. Zostanie wyświetlona lista, zakres herbivores jest sortowany przy użyciu alternatywnej funkcji porównującej, a lista zostanie ponownie wyświetlona.  
  
 Przeciążenie <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> metody jest następnie używane do przeszukiwania tylko zakresu herbivores dla "Brachiosaurus". Nie odnaleziono C# ciągu, a dopełnienie bitowe (operator ~ w i wizualizacja C++, `Xor` -1 w Visual Basic) liczby ujemnej zwracanej przez <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> metodę jest używany jako indeks do wstawiania nowego ciągu.  
  
 [!code-cpp[List\`1_SortSearchComparerRange#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparerRange#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparerRange#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparerRange/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />jest mniejsza niż 0.  
  
—lub— 
 <paramref name="count" />jest mniejsza niż 0.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" />i <paramref name="count" /> nie należy zauważyć prawidłowego zakresu <see cref="T:System.Collections.Generic.List`1" />w.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" />jest <see langword="null" />, a domyślna funkcja porównująca <see cref="P:System.Collections.Generic.Comparer`1.Default" /> nie może <see cref="T:System.IComparable`1" /> znaleźć implementacji interfejsu generycznego lub <see cref="T:System.IComparable" /> interfejsu dla typu <paramref name="T" />.</exception>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Wykonywanie niezależnych od kultury operacji na ciągach w kolekcjach</related>
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.Capacity" />
      <MemberSignature Language="VB.NET" Value="Public Property Capacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Capacity { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Capacity : int with get, set" Usage="System.Collections.Generic.List&lt;'T&gt;.Capacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia łączną liczbę elementów, które może zawierać wewnętrzna struktura danych bez zmiany rozmiarów.</summary>
        <value>Jest wymagana liczba elementów, które <see cref="T:System.Collections.Generic.List`1" /> mogą znajdować się przed zmianą rozmiarów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601.Capacity%2A>to liczba elementów, które <xref:System.Collections.Generic.List%601> mogą być przechowywane przed zmianą rozmiarów, a <xref:System.Collections.Generic.List%601.Count%2A> to liczba elementów <xref:System.Collections.Generic.List%601>, które faktycznie znajdują się w.  
  
 <xref:System.Collections.Generic.List%601.Capacity%2A>jest zawsze większa lub równa <xref:System.Collections.Generic.List%601.Count%2A>. Jeśli <xref:System.Collections.Generic.List%601.Count%2A> program <xref:System.Collections.Generic.List%601.Capacity%2A> przekracza podczas dodawania elementów, wydajność jest zwiększana przez automatyczne ponowne przydzielanie tablicy wewnętrznej przed skopiowaniem starych elementów i dodaniem nowych elementów.  
  
 Jeśli pojemność jest znacznie większa niż liczba i chcesz zmniejszyć ilość pamięci używanej przez <xref:System.Collections.Generic.List%601>program, można zmniejszyć pojemność przez <xref:System.Collections.Generic.List%601.TrimExcess%2A> wywołanie <xref:System.Collections.Generic.List%601.Capacity%2A> metody lub przez ustawienie właściwości jawnie na niższą wartość. Gdy wartość <xref:System.Collections.Generic.List%601.Capacity%2A> jest ustawiona jawnie, tablica wewnętrzna również jest przyalokowana ponownie w celu uwzględnienia określonej pojemności, a wszystkie elementy są kopiowane.  
  
 Pobieranie wartości tej właściwości jest operacją O (1); ustawienie właściwości jest operacją O (*n*), gdzie *n* to nowa pojemność.  
  
   
   
## Examples  
 
 [!INCLUDE[interactive-note](~/includes/csharp-interactive-note-some.md)]

 Poniższy przykład ilustruje sposób sprawdzania pojemności i liczby <xref:System.Collections.Generic.List%601> , która zawiera prosty obiekt biznesowy, i ilustruje <xref:System.Collections.Generic.List%601.TrimExcess%2A> użycie metody w celu usunięcia dodatkowej pojemności.  
  
 [!code-csharp[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/vb/module1.vb#1)]  
  
 Poniższy przykład przedstawia <xref:System.Collections.Generic.List%601.Capacity%2A> właściwość w kilku punktach w okresie istnienia listy. Konstruktor bez parametrów jest używany do tworzenia listy ciągów o pojemności 0, a <xref:System.Collections.Generic.List%601.Capacity%2A> właściwość jest wyświetlana, aby to zademonstrować. Po zastosowaniu <xref:System.Collections.Generic.List%601.Capacity%2A>metodydo dodania kilku elementów elementy są wyświetlane, a następnie właściwość jest wyświetlana <xref:System.Collections.Generic.List%601.Count%2A> ponownie wraz z właściwością, aby pokazać, że pojemność została zwiększona w miarę potrzeby. <xref:System.Collections.Generic.List%601.Add%2A>  
  
 Właściwość zostanie wyświetlona ponownie <xref:System.Collections.Generic.List%601.TrimExcess%2A> po użyciu metody w celu zmniejszenia wydajności w celu dopasowania jej do liczby. <xref:System.Collections.Generic.List%601.Capacity%2A> Na koniec <xref:System.Collections.Generic.List%601.Capacity%2A> <xref:System.Collections.Generic.List%601.Count%2A> Metoda służy do usuwania wszystkich elementów z listy, a właściwości i są wyświetlane ponownie. <xref:System.Collections.Generic.List%601.Clear%2A>  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp-interactive[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><see cref="P:System.Collections.Generic.List`1.Capacity" />jest ustawiona na wartość, która jest mniejsza niż <see cref="P:System.Collections.Generic.List`1.Count" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Za mało dostępnej pamięci w systemie.</exception>
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="list.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Clear</InterfaceMember>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa wszystkie elementy z <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601.Count%2A>jest ustawiona na 0, a odwołania do innych obiektów z elementów kolekcji również są wydane.  
  
 <xref:System.Collections.Generic.List%601.Capacity%2A>pozostaje niezmieniony. Aby zresetować pojemność <xref:System.Collections.Generic.List%601>, <xref:System.Collections.Generic.List%601.TrimExcess%2A> Wywołaj metodę lub ustaw <xref:System.Collections.Generic.List%601.Capacity%2A> właściwość bezpośrednio. Zmniejszenie pojemności powoduje ponowną alokację pamięci i skopiowanie wszystkich elementów w <xref:System.Collections.Generic.List%601>. Przycinanie pustego <xref:System.Collections.Generic.List%601> zestawu ustawia pojemność <xref:System.Collections.Generic.List%601> do pojemności domyślnej.  
  
 Ta metoda jest operacją O (*n*), gdzie *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  

 [!INCLUDE[interactive-note](~/includes/csharp-interactive-note.md)]

 Poniższy przykład demonstruje <xref:System.Collections.Generic.List%601.Clear%2A> metodę i różne inne właściwości i metody <xref:System.Collections.Generic.List%601> klasy generycznej. Metoda jest używana na końcu programu, aby usunąć wszystkie elementy z listy, <xref:System.Collections.Generic.List%601.Capacity%2A> a następnie wyświetlić właściwości i <xref:System.Collections.Generic.List%601.Count%2A>. <xref:System.Collections.Generic.List%601.Clear%2A>  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp-interactive[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.TrimExcess" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Contains(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(T item);" />
      <MemberSignature Language="F#" Value="abstract member Contains : 'T -&gt; bool&#xA;override this.Contains : 'T -&gt; bool" Usage="list.Contains item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Obiekt, który ma zostać zlokalizowany w <see cref="T:System.Collections.Generic.List`1" />. Wartość może być <see langword="null" /> dla typów referencyjnych.</param>
        <summary>Określa, <see cref="T:System.Collections.Generic.List`1" />czy element znajduje się w.</summary>
        <returns><see langword="true" />Jeśli <paramref name="item" /> znajduje się <see cref="T:System.Collections.Generic.List`1" />w; w przeciwnym razie <see langword="false" />,.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda określa równość przy użyciu domyślnej funkcji porównującej równość, jak zdefiniowano w implementacji <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> obiektu metody dla `T` (typ wartości na liście).  
  
 Ta metoda przeprowadza wyszukiwanie liniowe; w związku z tym ta metoda jest operacją O (*n*) ** , gdzie <xref:System.Collections.Generic.List%601.Count%2A>n jest.  
  
   
  
## Examples  
 W poniższym <xref:System.Collections.Generic.List%601.Contains%2A> przykładzie pokazano metody <xref:System.Collections.Generic.List%601> i <xref:System.Collections.Generic.List%601.Exists%2A> , które zawierają prosty obiekt biznesowy, który implementuje <xref:System.IEquatable%601.Equals%2A>.  
  
 [!code-csharp[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/vb/module1.vb#1)]  
  
 Poniższy przykład zawiera listę obiektów złożonych typu `Cube`. `Cube` Klasa<xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> implementuje metodę, aby dwa moduły były uważane za równe, jeśli ich wymiary są takie same. W tym przykładzie <xref:System.Collections.Generic.List%601.Contains%2A> Metoda zwraca `true`, ponieważ moduł, który ma określone wymiary, znajduje się już w kolekcji.  
  
 [!code-csharp[System.Collections.Generic.List.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.contains/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.contains/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Wykonywanie niezależnych od kultury operacji na ciągach w kolekcjach</related>
      </Docs>
    </Member>
    <Member MemberName="ConvertAll&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;TOutput&gt; ConvertAll&lt;TOutput&gt; (Converter&lt;T,TOutput&gt; converter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;!!TOutput&gt; ConvertAll&lt;TOutput&gt;(class System.Converter`2&lt;!T, !!TOutput&gt; converter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.ConvertAll``1(System.Converter{`0,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function ConvertAll(Of TOutput) (converter As Converter(Of T, TOutput)) As List(Of TOutput)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA; System::Collections::Generic::List&lt;TOutput&gt; ^ ConvertAll(Converter&lt;T, TOutput&gt; ^ converter);" />
      <MemberSignature Language="F#" Value="member this.ConvertAll : Converter&lt;'T, 'Output&gt; -&gt; System.Collections.Generic.List&lt;'Output&gt;" Usage="list.ConvertAll converter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;TOutput&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="converter" Type="System.Converter&lt;T,TOutput&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">Typ elementów tablicy docelowej.</typeparam>
        <param name="converter"><see cref="T:System.Converter`2" /> Delegat, który konwertuje każdy element z jednego typu na inny typ.</param>
        <summary>Konwertuje elementy w bieżącym <see cref="T:System.Collections.Generic.List`1" /> na inny typ i zwraca listę zawierającą przekonwertowane elementy.</summary>
        <returns>A <see cref="T:System.Collections.Generic.List`1" /> typu docelowego zawierającego przekonwertowane elementy z bieżącego <see cref="T:System.Collections.Generic.List`1" />elementu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Converter%602> Jest delegatem do metody, która konwertuje obiekt na typ docelowy.  Elementy bieżącego <xref:System.Collections.Generic.List%601> są indywidualnie przesyłane <xref:System.Converter%602> do delegata, a konwertowane elementy są zapisywane w nowym <xref:System.Collections.Generic.List%601>.  
  
 Bieżąca <xref:System.Collections.Generic.List%601> wartość pozostaje niezmieniona.  
  
 Ta metoda jest operacją O (*n*), gdzie *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano metodę o `PointFToPoint` nazwie, która <xref:System.Drawing.PointF> konwertuje strukturę na <xref:System.Drawing.Point> strukturę. <xref:System.Collections.Generic.List%601> Następnie przykład tworzy <xref:System.Drawing.PointF> struktury, tworzy `Converter\<PointF, Point>` delegata`Converter(Of PointF, Point)` (w Visual Basic) <xref:System.Collections.Generic.List%601.ConvertAll%2A> do reprezentowania metodyiprzekazujedelegatadometody.`PointFToPoint` Metoda przekazuje każdy element listy wejściowej `PointFToPoint` do metody i umieszcza przekonwertowane elementy <xref:System.Drawing.Point> do nowej listy struktur. <xref:System.Collections.Generic.List%601.ConvertAll%2A> Wyświetlane są obie listy.  
  
 [!code-cpp[List\`1_ConvertAll#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_ConvertAll/cpp/source.cpp#1)]
 [!code-csharp[List\`1_ConvertAll#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_ConvertAll/cs/source.cs#1)]
 [!code-vb[List\`1_ConvertAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_ConvertAll/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="converter" />jest <see langword="null" />.</exception>
        <altmember cref="T:System.Converter`2" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Collections.Generic.List`1" /> Kopiuje lub część tego elementu do tablicy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.CopyTo(`0[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : 'T[] -&gt; unit" Usage="list.CopyTo array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <param name="array">Jednowymiarowy <see cref="T:System.Array" /> , który jest miejscem docelowym elementów skopiowanych z <see cref="T:System.Collections.Generic.List`1" />. <see cref="T:System.Array" /> Musi mieć indeksowanie oparte na zero.</param>
        <summary>Kopiuje cały <see cref="T:System.Collections.Generic.List`1" /> do zgodnej jednowymiarowej tablicy, rozpoczynając od początku tablicy docelowej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa <xref:System.Array.Copy%2A?displayProperty=nameWithType> do kopiowania elementów.  
  
 Elementy są kopiowane do <xref:System.Array> tabeli w tej samej kolejności, w której moduł wyliczający iteruje <xref:System.Collections.Generic.List%601>przez.  
  
 Ta metoda jest operacją O (*n*), gdzie *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Poniższy przykład ilustruje wszystkie trzy przeciążenia <xref:System.Collections.Generic.List%601.CopyTo%2A> metody. <xref:System.Collections.Generic.List%601> Jest tworzony i wypełniany przy użyciu 5 ciągów. Zostanie utworzona pusta tablica ciągów o wartości 15 elementów, a <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%29> Przeciążenie metody jest używany do kopiowania wszystkich elementów listy do tablicy rozpoczynającej się od pierwszego elementu tablicy. Przeciążenie <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%2CSystem.Int32%29> metody służy do kopiowania wszystkich elementów listy do tablicy, zaczynając od indeksu tablicy 6 (pustego indeksu 5). Na koniec Przeciążenie metody jest używane do kopiowania 3 elementów z listy, zaczynając od indeksu 2, do tablicy rozpoczynającej się od indeksu tablicy 12 (pustego indeksu 11). <xref:System.Collections.Generic.List%601.CopyTo%28System.Int32%2C%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> Zostanie wyświetlona zawartość tablicy.  
  
 [!code-cpp[List\`1_CopyTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_CopyTo/cpp/source.cpp#1)]
 [!code-csharp[List\`1_CopyTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_CopyTo/cs/source.cs#1)]
 [!code-vb[List\`1_CopyTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_CopyTo/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Liczba elementów w źródle <see cref="T:System.Collections.Generic.List`1" /> jest większa niż liczba elementów, które może zawierać lokalizacja docelowa. <paramref name="array" /></exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(!T[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.CopyTo(`0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T(), arrayIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(cli::array &lt;T&gt; ^ array, int arrayIndex);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : 'T[] * int -&gt; unit&#xA;override this.CopyTo : 'T[] * int -&gt; unit" Usage="list.CopyTo (array, arrayIndex)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Jednowymiarowy <see cref="T:System.Array" /> , który jest miejscem docelowym elementów skopiowanych z <see cref="T:System.Collections.Generic.List`1" />. <see cref="T:System.Array" /> Musi mieć indeksowanie oparte na zero.</param>
        <param name="arrayIndex">Indeks (liczony od zera) <paramref name="array" /> , w którym rozpoczyna się kopiowanie.</param>
        <summary>Kopiuje cały <see cref="T:System.Collections.Generic.List`1" /> do zgodnej jednowymiarowej tablicy, rozpoczynając od określonego indeksu tablicy docelowej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa <xref:System.Array.Copy%2A?displayProperty=nameWithType> do kopiowania elementów.  
  
 Elementy są kopiowane do <xref:System.Array> tabeli w tej samej kolejności, w której moduł wyliczający iteruje <xref:System.Collections.Generic.List%601>przez.  
  
 Ta metoda jest operacją O (*n*), gdzie *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Poniższy przykład ilustruje wszystkie trzy przeciążenia <xref:System.Collections.Generic.List%601.CopyTo%2A> metody. <xref:System.Collections.Generic.List%601> Jest tworzony i wypełniany przy użyciu 5 ciągów. Zostanie utworzona pusta tablica ciągów o wartości 15 elementów, a <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%29> Przeciążenie metody jest używany do kopiowania wszystkich elementów listy do tablicy rozpoczynającej się od pierwszego elementu tablicy. Przeciążenie <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%2CSystem.Int32%29> metody służy do kopiowania wszystkich elementów listy do tablicy, zaczynając od indeksu tablicy 6 (pustego indeksu 5). Na koniec Przeciążenie metody jest używane do kopiowania 3 elementów z listy, zaczynając od indeksu 2, do tablicy rozpoczynającej się od indeksu tablicy 12 (pustego indeksu 11). <xref:System.Collections.Generic.List%601.CopyTo%28System.Int32%2C%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> Zostanie wyświetlona zawartość tablicy.  
  
 [!code-cpp[List\`1_CopyTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_CopyTo/cpp/source.cpp#1)]
 [!code-csharp[List\`1_CopyTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_CopyTo/cs/source.cs#1)]
 [!code-vb[List\`1_CopyTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_CopyTo/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="arrayIndex" />jest mniejsza niż 0.</exception>
        <exception cref="T:System.ArgumentException">Liczba elementów w źródle <see cref="T:System.Collections.Generic.List`1" /> jest większa niż dostępne miejsce od <paramref name="arrayIndex" /> do końca miejsca docelowego <paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int index, T[] array, int arrayIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 index, !T[] array, int32 arrayIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (index As Integer, array As T(), arrayIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int index, cli::array &lt;T&gt; ^ array, int arrayIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * 'T[] * int * int -&gt; unit" Usage="list.CopyTo (index, array, arrayIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Indeks (liczony od zera) w źródle <see cref="T:System.Collections.Generic.List`1" /> , w którym rozpoczyna się kopiowanie.</param>
        <param name="array">Jednowymiarowy <see cref="T:System.Array" /> , który jest miejscem docelowym elementów skopiowanych z <see cref="T:System.Collections.Generic.List`1" />. <see cref="T:System.Array" /> Musi mieć indeksowanie oparte na zero.</param>
        <param name="arrayIndex">Indeks (liczony od zera) <paramref name="array" /> , w którym rozpoczyna się kopiowanie.</param>
        <param name="count">Liczba elementów do skopiowania.</param>
        <summary>Kopiuje zakres elementów z <see cref="T:System.Collections.Generic.List`1" /> do zgodnej jednowymiarowej tablicy, rozpoczynając od określonego indeksu tablicy docelowej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa <xref:System.Array.Copy%2A?displayProperty=nameWithType> do kopiowania elementów.  
  
 Elementy są kopiowane do <xref:System.Array> tabeli w tej samej kolejności, w której moduł wyliczający iteruje <xref:System.Collections.Generic.List%601>przez.  
  
 Ta metoda jest operacją O (*n*), gdzie *n* jest `count`.  
  
   
  
## Examples  
 Poniższy przykład ilustruje wszystkie trzy przeciążenia <xref:System.Collections.Generic.List%601.CopyTo%2A> metody. <xref:System.Collections.Generic.List%601> Jest tworzony i wypełniany przy użyciu 5 ciągów. Zostanie utworzona pusta tablica ciągów o wartości 15 elementów, a <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%29> Przeciążenie metody jest używany do kopiowania wszystkich elementów listy do tablicy rozpoczynającej się od pierwszego elementu tablicy. Przeciążenie <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%2CSystem.Int32%29> metody służy do kopiowania wszystkich elementów listy do tablicy, zaczynając od indeksu tablicy 6 (pustego indeksu 5). Na koniec Przeciążenie metody jest używane do kopiowania 3 elementów z listy, zaczynając od indeksu 2, do tablicy rozpoczynającej się od indeksu tablicy 12 (pustego indeksu 11). <xref:System.Collections.Generic.List%601.CopyTo%28System.Int32%2C%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> Zostanie wyświetlona zawartość tablicy.  
  
 [!code-cpp[List\`1_CopyTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_CopyTo/cpp/source.cpp#1)]
 [!code-csharp[List\`1_CopyTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_CopyTo/cs/source.cs#1)]
 [!code-vb[List\`1_CopyTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_CopyTo/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />jest mniejsza niż 0.  
  
—lub— 
 <paramref name="arrayIndex" />jest mniejsza niż 0.  
  
—lub— 
 <paramref name="count" />jest mniejsza niż 0.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" />jest równa lub większa <see cref="P:System.Collections.Generic.List`1.Count" /> od wartości źródłowej. <see cref="T:System.Collections.Generic.List`1" />  
  
—lub— 
Liczba elementów od <paramref name="index" /> do końca źródła <see cref="T:System.Collections.Generic.List`1" /> jest większa niż dostępne miejsce od <paramref name="arrayIndex" /> do końca lokalizacji docelowej <paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.Generic.List&lt;'T&gt;.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyCollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę elementów zawartych w <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <value>Liczba elementów zawartych w <see cref="T:System.Collections.Generic.List`1" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601.Capacity%2A>to liczba elementów, które <xref:System.Collections.Generic.List%601> mogą być przechowywane przed zmianą rozmiarów. <xref:System.Collections.Generic.List%601.Count%2A>to liczba elementów, które faktycznie znajdują się w <xref:System.Collections.Generic.List%601>.  
  
 <xref:System.Collections.Generic.List%601.Capacity%2A>jest zawsze większa lub równa <xref:System.Collections.Generic.List%601.Count%2A>. Jeśli <xref:System.Collections.Generic.List%601.Count%2A> program <xref:System.Collections.Generic.List%601.Capacity%2A> przekracza podczas dodawania elementów, wydajność jest zwiększana przez automatyczne ponowne przydzielanie tablicy wewnętrznej przed skopiowaniem starych elementów i dodaniem nowych elementów.  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
   
  
## Examples  

 [!INCLUDE[interactive-note](~/includes/csharp-interactive-note-some.md)]

 Poniższy przykład ilustruje sposób sprawdzania pojemności i liczby <xref:System.Collections.Generic.List%601> , która zawiera prosty obiekt biznesowy, i ilustruje <xref:System.Collections.Generic.List%601.TrimExcess%2A> użycie metody w celu usunięcia dodatkowej pojemności.  
  
 [!code-csharp[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/vb/module1.vb#1)]  
  
 Poniższy przykład pokazuje wartość <xref:System.Collections.Generic.List%601.Count%2A> właściwości w różnych punktach w okresie istnienia listy. Po utworzeniu i wypełnieniu listy i wyświetleniu <xref:System.Collections.Generic.List%601.Capacity%2A> jej elementów są wyświetlane właściwości i. <xref:System.Collections.Generic.List%601.Count%2A> Te właściwości są wyświetlane ponownie po <xref:System.Collections.Generic.List%601.TrimExcess%2A> wywołaniu metody i ponownie po wyczyszczeniu zawartości listy.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp-interactive[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public bool Exists (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Exists(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Exists (match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Exists(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.Exists : Predicate&lt;'T&gt; -&gt; bool" Usage="list.Exists match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match"><see cref="T:System.Predicate`1" /> Delegat, który definiuje warunki elementów do wyszukania.</param>
        <summary>Określa, czy <see cref="T:System.Collections.Generic.List`1" /> zawiera elementy, które pasują do warunków zdefiniowanych przez określony predykat.</summary>
        <returns><see langword="true" />Jeśli zawiera jeden lub więcej elementów, które pasują do warunków zdefiniowanych przez określony predykat; <see langword="false" />w przeciwnym razie. <see cref="T:System.Collections.Generic.List`1" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest delegatem metody, która zwraca `true` , jeśli obiekt przeszedł do niego, odpowiada warunkom zdefiniowanym w obiekcie delegowanym. <xref:System.Predicate%601>  Elementy bieżącego <xref:System.Collections.Generic.List%601> są indywidualnie przesyłane <xref:System.Predicate%601> do delegata, a przetwarzanie jest przerywane po znalezieniu dopasowania.  
  
 Ta metoda przeprowadza wyszukiwanie liniowe; w związku z tym ta metoda jest operacją O (*n*) ** , gdzie <xref:System.Collections.Generic.List%601.Count%2A>n jest.  
  
   
  
## Examples  
 W poniższym <xref:System.Collections.Generic.List%601.Contains%2A> przykładzie pokazano metody <xref:System.Collections.Generic.List%601> i <xref:System.Collections.Generic.List%601.Exists%2A> , które zawierają prosty obiekt biznesowy, który implementuje <xref:System.IEquatable%601.Equals%2A>.  
  
 [!code-csharp[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/vb/module1.vb#1)]  
  
 Poniższy przykład ilustruje <xref:System.Collections.Generic.List%601.Exists%2A> metodę i kilka innych metod, które <xref:System.Predicate%601> używają delegata ogólnego.  
  
 Tworzony jest ciąg z 8. nazwami, z których dwa są (w pozycjach 1 i 5) kończą się znakiem "saurus". <xref:System.Collections.Generic.List%601> W przykładzie zdefiniowano także metodę predykatu wyszukiwania `EndsWithSaurus`o nazwie, która akceptuje parametr String i zwraca wartość logiczną wskazującą, czy ciąg wejściowy jest kończący się na "saurus".  
  
 Metody <xref:System.Collections.Generic.List%601.Find%2A> <xref:System.Collections.Generic.List%601.RemoveAll%2A> , <xref:System.Collections.Generic.List%601.FindLast%2A>, i <xref:System.Collections.Generic.List%601.FindAll%2A> są używane do przeszukiwania listy za pomocą metody predykatu wyszukiwania, a następnie metoda jest używana do usuwania wszystkich wpisów kończących się ciągiem "saurus".  
  
 Na <xref:System.Collections.Generic.List%601.Exists%2A> koniec Metoda jest wywoływana. Przechodzi na listę od początku, przekazując każdy element z kolei do `EndsWithSaurus` metody. Wyszukiwanie zostaje zatrzymane i metoda zwraca `true` , `EndsWithSaurus` Jeśli metoda zwraca `true` dla dowolnego elementu. Metoda <xref:System.Collections.Generic.List%601.Exists%2A> zwraca`false` , ponieważ wszystkie takie elementy zostały usunięte.  
  
> [!NOTE]
>  W C# i Visual Basic nie jest konieczne jawne utworzenie `Predicate<string>` delegata (`Predicate(Of String)` w Visual Basic). Te języki wnioskują o poprawnym delegacie z kontekstu, a następnie są tworzone automatycznie.  
  
 [!code-cpp[List\`1_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[List\`1_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_FindEtAl/cs/source.cs#1)]
 [!code-vb[List\`1_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" />jest <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public T Find (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T Find(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T Find(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.Find : Predicate&lt;'T&gt; -&gt; 'T" Usage="list.Find match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match"><see cref="T:System.Predicate`1" /> Delegat, który definiuje warunki elementu do wyszukania.</param>
        <summary>Wyszukuje element, który odpowiada warunkom zdefiniowanym przez określony predykat, i zwraca pierwsze wystąpienie w całości <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>Pierwszy element, który odpowiada warunkom zdefiniowanym przez określony predykat, jeśli znaleziono; w przeciwnym razie wartość domyślna dla typu <paramref name="T" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest delegatem metody, która zwraca `true` , jeśli obiekt przeszedł do niego, odpowiada warunkom zdefiniowanym w obiekcie delegowanym. <xref:System.Predicate%601>  Elementy bieżącego <xref:System.Collections.Generic.List%601> są indywidualnie przekazywane <xref:System.Predicate%601> do delegata <xref:System.Collections.Generic.List%601>, przenoszone do przodu w, rozpoczynając od pierwszego elementu i kończąc na ostatnim elemencie.  Przetwarzanie jest zatrzymane po znalezieniu dopasowania.  
  
> [!IMPORTANT]
>  Podczas wyszukiwania listy zawierającej typy wartości upewnij się, że wartość domyślna dla tego typu nie spełnia predykatu wyszukiwania. W przeciwnym razie nie istnieje sposób rozróżniania między wartością domyślną wskazującą, że nie znaleziono dopasowania i element listy, który ma mieć wartość domyślną dla tego typu. Jeśli wartość domyślna spełnia predykat wyszukiwania, zamiast tego użyj <xref:System.Collections.Generic.List%601.FindIndex%2A> metody.  
  
 Ta metoda przeprowadza wyszukiwanie liniowe; w związku z tym ta metoda jest operacją O (*n*) ** , gdzie <xref:System.Collections.Generic.List%601.Count%2A>n jest.  
  
   
  
## Examples  
 Poniższy przykład ilustruje <xref:System.Collections.Generic.List%601.Find%2A> metodę <xref:System.Collections.Generic.List%601> , która zawiera prosty obiekt złożony.  
  
 [!code-csharp[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/vb/module1.vb#1)]  
  
 Poniższy przykład ilustruje metody znajdowania dla <xref:System.Collections.Generic.List%601> klasy. Przykład dla <xref:System.Collections.Generic.List%601> klasy zawiera `book` obiekty klasy `Book`, przy użyciu danych z [przykładowego pliku XML: Książki (LINQ to XML)](https://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). Metoda w przykładzie używa [LINQ to XML](https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) , aby przeanalizować wartości z XML do wartości `book` właściwości obiektów. `FillList`  
  
 W poniższej tabeli opisano przykłady dotyczące metod znajdowania.  
  
|Metoda|Przykład|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Znajduje książkę według identyfikatora przy użyciu `IDToFind` delegata predykatu.<br /><br /> C#przykład używa anonimowego delegata.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Znajdź wszystkie książki, `Genre` których właściwość jest "Computer" `FindComputer` przy użyciu delegata predykatu.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Znajduje ostatnią książkę w kolekcji, która ma datę opublikowania przed 2001, przy użyciu `PubBefore2001` delegata predykatu.<br /><br /> C#przykład używa anonimowego delegata.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Znajduje indeks pierwszej książki komputerowej przy użyciu `FindComputer` delegata predykatu.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Znajduje indeks ostatniej książki komputerowej przy użyciu `FindComputer` delegata predykatu.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Znajduje indeks pierwszej książki komputerowej w drugiej połowie kolekcji przy użyciu `FindComputer` delegata predykatu.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Znajduje indeks ostatniej książki komputerowej w drugiej połowie kolekcji przy użyciu `FindComputer` delegata predykatu.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" />jest <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindAll">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;T&gt; FindAll (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;!T&gt; FindAll(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindAll (match As Predicate(Of T)) As List(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;T&gt; ^ FindAll(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindAll : Predicate&lt;'T&gt; -&gt; System.Collections.Generic.List&lt;'T&gt;" Usage="list.FindAll match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match"><see cref="T:System.Predicate`1" /> Delegat, który definiuje warunki elementów do wyszukania.</param>
        <summary>Pobiera wszystkie elementy, które pasują do warunków zdefiniowanych przez określony predykat.</summary>
        <returns>Zawiera wszystkie elementy, które pasują do warunków określonych przez określony predykat, jeśli zostały znalezione; w przeciwnym razie jest <see cref="T:System.Collections.Generic.List`1" />puste. <see cref="T:System.Collections.Generic.List`1" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest delegatem metody, która zwraca `true` , jeśli obiekt przeszedł do niego, odpowiada warunkom zdefiniowanym w obiekcie delegowanym. <xref:System.Predicate%601>  Elementy bieżącego <xref:System.Collections.Generic.List%601> są indywidualnie przenoszone <xref:System.Predicate%601> do delegata, a elementy zgodne z warunkami są zapisywane w zwracanym <xref:System.Collections.Generic.List%601>elemencie.  
  
 Ta metoda przeprowadza wyszukiwanie liniowe; w związku z tym ta metoda jest operacją O (*n*) ** , gdzie <xref:System.Collections.Generic.List%601.Count%2A>n jest.  
  
   
  
## Examples  
 Poniższy przykład ilustruje metody znajdowania dla <xref:System.Collections.Generic.List%601> klasy. Przykład dla <xref:System.Collections.Generic.List%601> klasy zawiera `book` obiekty klasy `Book`, przy użyciu danych z [przykładowego pliku XML: Książki (LINQ to XML)](https://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). Metoda w przykładzie używa [LINQ to XML](https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) , aby przeanalizować wartości z XML do wartości `book` właściwości obiektów. `FillList`  
  
 W poniższej tabeli opisano przykłady dotyczące metod znajdowania.  
  
|Metoda|Przykład|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Znajduje książkę według identyfikatora przy użyciu `IDToFind` delegata predykatu.<br /><br /> C#przykład używa anonimowego delegata.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Znajdź wszystkie książki, `Genre` których właściwość jest "Computer" `FindComputer` przy użyciu delegata predykatu.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Znajduje ostatnią książkę w kolekcji, która ma datę opublikowania przed 2001, przy użyciu `PubBefore2001` delegata predykatu.<br /><br /> C#przykład używa anonimowego delegata.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Znajduje indeks pierwszej książki komputerowej przy użyciu `FindComputer` delegata predykatu.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Znajduje indeks ostatniej książki komputerowej przy użyciu `FindComputer` delegata predykatu.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Znajduje indeks pierwszej książki komputerowej w drugiej połowie kolekcji przy użyciu `FindComputer` delegata predykatu.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Znajduje indeks ostatniej książki komputerowej w drugiej połowie kolekcji przy użyciu `FindComputer` delegata predykatu.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" />jest <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindIndex">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wyszukuje element, który odpowiada warunkom zdefiniowanym przez określony predykat, i zwraca indeks (liczony od zera) pierwszego wystąpienia w <see cref="T:System.Collections.Generic.List`1" /> lub jego części. Ta metoda zwraca wartość-1, jeśli nie znaleziono elementu pasującego do warunków.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindIndex">
      <MemberSignature Language="C#" Value="public int FindIndex (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindIndex(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindIndex(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindIndex (match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindIndex(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindIndex : Predicate&lt;'T&gt; -&gt; int" Usage="list.FindIndex match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match"><see cref="T:System.Predicate`1" /> Delegat, który definiuje warunki elementu do wyszukania.</param>
        <summary>Wyszukuje element, który odpowiada warunkom zdefiniowanym przez określony predykat, i zwraca indeks (liczony od zera) pierwszego wystąpienia w całości <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>Indeks (liczony od zera) pierwszego wystąpienia elementu, który jest zgodny z warunkami zdefiniowanymi przez <paramref name="match" />, jeśli został znaleziony; w przeciwnym razie-1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> Jest przeszukiwany do przodu, zaczynając od pierwszego elementu i kończąc na ostatnim elemencie.  
  
 Jest delegatem metody, która zwraca `true` , jeśli obiekt przeszedł do niego, odpowiada warunkom zdefiniowanym w obiekcie delegowanym. <xref:System.Predicate%601>  Elementy bieżącego <xref:System.Collections.Generic.List%601> są indywidualnie przesyłane <xref:System.Predicate%601> do delegata. Delegat ma sygnaturę:  
  
```csharp  
public bool methodName(T obj)  
```  
  
```vb  
Public Function methodName(obj As T) As Boolean  
```  
  
 Ta metoda przeprowadza wyszukiwanie liniowe; w związku z tym ta metoda jest operacją O (*n*) ** , gdzie <xref:System.Collections.Generic.List%601.Count%2A>n jest.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano `Employee` klasę z dwoma `Name` polami i `Id`. Definiuje `EmployeeSearch` również klasę z pojedynczą metodą, `StartsWith`która wskazuje, czy `Employee.Name` pole rozpoczyna się od `EmployeeSearch` określonego podciągu, który jest dostarczany do konstruktora klasy. Zwróć uwagę na podpis tej metody  
  
```csharp  
public bool StartsWith(Employee e)  
```  
  
```vb  
Public Function StartsWith(e As Employee) As Boolean  
```  
  
 odnosi się do podpisu delegata, który może zostać przesłany do <xref:System.Collections.Generic.List%601.FindIndex%2A> metody. Przykład tworzy `List<Employee>` wystąpienie obiektu, dodaje do niego <xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29> `Employee` wiele obiektów, a następnie wywołuje metodę dwa razy, aby przeszukać całą kolekcję, po raz pierwszy dla pierwszego `Employee` obiektu, którego `Name` rozpoczyna się pole w przypadku elementu "J" i drugiego czasu dla pierwszego `Employee` obiektu, którego `Name` pole zaczyna się od "ju".  
  
 [!code-csharp[System.Collections.Generic.List.FindIndex#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/cs/FindIndex2.cs#2)]
 [!code-vb[System.Collections.Generic.List.FindIndex#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/vb/FindIndex2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" />jest <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex">
      <MemberSignature Language="C#" Value="public int FindIndex (int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindIndex(int32 startIndex, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindIndex (startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindIndex(int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindIndex : int * Predicate&lt;'T&gt; -&gt; int" Usage="list.FindIndex (startIndex, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">Wartość początkowa indeksu zaczynającego się od zera dla wyszukiwania.</param>
        <param name="match"><see cref="T:System.Predicate`1" /> Delegat, który definiuje warunki elementu do wyszukania.</param>
        <summary>Wyszukuje element, który odpowiada warunkom zdefiniowanym przez określony predykat, i zwraca indeks (liczony od zera) pierwszego wystąpienia w zakresie elementów w programie <see cref="T:System.Collections.Generic.List`1" /> , który rozciąga się od określonego indeksu do ostatniego elementu.</summary>
        <returns>Indeks (liczony od zera) pierwszego wystąpienia elementu, który jest zgodny z warunkami zdefiniowanymi przez <paramref name="match" />, jeśli został znaleziony; w przeciwnym razie-1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest przeszukiwany do przodu `startIndex` i kończący się na ostatnim elemencie. <xref:System.Collections.Generic.List%601>  
  
 Jest delegatem metody, która zwraca `true` , jeśli obiekt przeszedł do niego, odpowiada warunkom zdefiniowanym w obiekcie delegowanym. <xref:System.Predicate%601>  Elementy bieżącego <xref:System.Collections.Generic.List%601> są indywidualnie przesyłane <xref:System.Predicate%601> do delegata. Delegat ma sygnaturę:  
  
```csharp  
public bool methodName(T obj)  
```  
  
```vb  
Public Function methodName(obj As T) As Boolean  
```  
  
 Ta metoda przeprowadza wyszukiwanie liniowe; w związku z tym ta metoda jest operacją o (*n*), gdzie *n* jest liczbą elementów od `startIndex` do końca <xref:System.Collections.Generic.List%601>.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano `Employee` klasę z dwoma `Name` polami i `Id`. Definiuje `EmployeeSearch` również klasę z pojedynczą metodą, `StartsWith`która wskazuje, czy `Employee.Name` pole rozpoczyna się od `EmployeeSearch` określonego podciągu, który jest dostarczany do konstruktora klasy. Zwróć uwagę na podpis tej metody  
  
```csharp  
public bool StartsWith(Employee e)  
```  
  
```vb  
Public Function StartsWith(e As Employee) As Boolean  
```  
  
 odnosi się do podpisu delegata, który może zostać przesłany do <xref:System.Collections.Generic.List%601.FindIndex%2A> metody. Przykład tworzy wystąpienie `List<Employee>` obiektu, dodaje do niego `Employee` wiele obiektów <xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29> , a następnie wywołuje metodę dwa razy, aby przeszukać kolekcję, rozpoczynając od jej piątego elementu członkowskiego (czyli elementu członkowskiego w indeksie 4). `Employee` Po raz pierwszy wyszukuje pierwszy obiekt, którego `Name` pole zaczyna się od "J"; drugi raz wyszukuje pierwszy `Employee` obiekt, którego `Name` pole zaczyna się od "ju".  
  
 [!code-csharp[System.Collections.Generic.List.FindIndex#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/cs/FindIndex3.cs#3)]
 [!code-vb[System.Collections.Generic.List.FindIndex#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/vb/FindIndex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" />znajduje się poza zakresem prawidłowych indeksów dla <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex">
      <MemberSignature Language="C#" Value="public int FindIndex (int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindIndex(int32 startIndex, int32 count, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindIndex (startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindIndex(int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindIndex : int * int * Predicate&lt;'T&gt; -&gt; int" Usage="list.FindIndex (startIndex, count, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">Wartość początkowa indeksu zaczynającego się od zera dla wyszukiwania.</param>
        <param name="count">Liczba elementów w sekcji do wyszukania.</param>
        <param name="match"><see cref="T:System.Predicate`1" /> Delegat, który definiuje warunki elementu do wyszukania.</param>
        <summary>Wyszukuje element, który odpowiada warunkom zdefiniowanym przez określony predykat, i zwraca indeks (liczony od zera) pierwszego wystąpienia w zakresie elementów <see cref="T:System.Collections.Generic.List`1" /> , który zaczyna się od określonego indeksu i zawiera określoną liczbę elementów.</summary>
        <returns>Indeks (liczony od zera) pierwszego wystąpienia elementu, który jest zgodny z warunkami zdefiniowanymi przez <paramref name="match" />, jeśli został znaleziony; w przeciwnym razie-1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `count` `count` `startIndex` `startIndex` Program jest przeszukiwany do przodu, rozpoczynając od i kończąc o minus 1, jeśli jest większy niż 0. <xref:System.Collections.Generic.List%601>  
  
 Jest delegatem metody, która zwraca `true` , jeśli obiekt przeszedł do niego, odpowiada warunkom zdefiniowanym w obiekcie delegowanym. <xref:System.Predicate%601>  Elementy bieżącego <xref:System.Collections.Generic.List%601> są indywidualnie przesyłane <xref:System.Predicate%601> do delegata. Delegat ma sygnaturę:  
  
```csharp  
public bool methodName(T obj)  
```  
  
```vb  
Public Function methodName(obj As T) As Boolean  
```  
  
 Ta metoda przeprowadza wyszukiwanie liniowe; w związku z tym ta metoda jest operacją O (*n*) ** , gdzie `count`n jest.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano `Employee` klasę z dwoma `Name` polami i `Id`. Definiuje `EmployeeSearch` również klasę z pojedynczą metodą, `StartsWith`która wskazuje, czy `Employee.Name` pole rozpoczyna się od `EmployeeSearch` określonego podciągu, który jest dostarczany do konstruktora klasy. Zwróć uwagę na podpis tej metody  
  
```csharp  
public bool StartsWith(Employee e)  
```  
  
```vb  
Public Function StartsWith(e As Employee) As Boolean  
```  
  
 odnosi się do podpisu delegata, który może zostać przesłany do <xref:System.Collections.Generic.List%601.FindIndex%2A> metody. Przykład tworzy wystąpienie `List<Employee>` obiektu, dodaje do niego `Employee` wiele obiektów <xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29> , a następnie wywołuje metodę dwa razy, aby wyszukać całą kolekcję (czyli elementy członkowskie z indeksu 0 do indeksu <xref:System.Collections.Generic.List%601.Count%2A> -1). `Employee` Po raz pierwszy wyszukuje pierwszy obiekt, którego `Name` pole zaczyna się od "J"; drugi raz wyszukuje pierwszy `Employee` obiekt, którego `Name` pole zaczyna się od "ju".  
  
 [!code-csharp[System.Collections.Generic.List.FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/cs/FindIndex1.cs#1)]
 [!code-vb[System.Collections.Generic.List.FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/vb/FindIndex1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" />znajduje się poza zakresem prawidłowych indeksów dla <see cref="T:System.Collections.Generic.List`1" />.  
  
—lub— 
 <paramref name="count" />jest mniejsza niż 0.  
  
—lub— 
 <paramref name="startIndex" />i <paramref name="count" /> nie określaj prawidłowej sekcji <see cref="T:System.Collections.Generic.List`1" />w.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLast">
      <MemberSignature Language="C#" Value="public T FindLast (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T FindLast(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLast (match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T FindLast(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindLast : Predicate&lt;'T&gt; -&gt; 'T" Usage="list.FindLast match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match"><see cref="T:System.Predicate`1" /> Delegat, który definiuje warunki elementu do wyszukania.</param>
        <summary>Wyszukuje element, który odpowiada warunkom zdefiniowanym przez określony predykat, i zwraca ostatnie wystąpienie w całości <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>Ostatni element, który jest zgodny z warunkami zdefiniowanymi przez określony predykat, jeśli znaleziono; w przeciwnym razie wartość domyślna dla typu <paramref name="T" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest delegatem metody, która zwraca `true` , jeśli obiekt przeszedł do niego, odpowiada warunkom zdefiniowanym w obiekcie delegowanym. <xref:System.Predicate%601>  Elementy bieżącego <xref:System.Collections.Generic.List%601> są indywidualnie przesyłane <xref:System.Predicate%601> do delegata <xref:System.Collections.Generic.List%601>, przenoszące wstecz w, rozpoczynając od ostatniego elementu i kończąc na pierwszym elemencie.  Przetwarzanie jest zatrzymane po znalezieniu dopasowania.  
  
> [!IMPORTANT]
>  Podczas wyszukiwania listy zawierającej typy wartości upewnij się, że wartość domyślna dla tego typu nie spełnia predykatu wyszukiwania. W przeciwnym razie nie istnieje sposób rozróżniania między wartością domyślną wskazującą, że nie znaleziono dopasowania i element listy, który ma mieć wartość domyślną dla tego typu. Jeśli wartość domyślna spełnia predykat wyszukiwania, zamiast tego użyj <xref:System.Collections.Generic.List%601.FindLastIndex%2A> metody.  
  
 Ta metoda przeprowadza wyszukiwanie liniowe; w związku z tym ta metoda jest operacją O (*n*) ** , gdzie <xref:System.Collections.Generic.List%601.Count%2A>n jest.  
  
   
  
## Examples  
 Poniższy przykład ilustruje metody znajdowania dla <xref:System.Collections.Generic.List%601> klasy. Przykład dla <xref:System.Collections.Generic.List%601> klasy zawiera `book` obiekty klasy `Book`, przy użyciu danych z [przykładowego pliku XML: Książki (LINQ to XML)](https://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). Metoda w przykładzie używa [LINQ to XML](https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) , aby przeanalizować wartości z XML do wartości `book` właściwości obiektów. `FillList`  
  
 W poniższej tabeli opisano przykłady dotyczące metod znajdowania.  
  
|Metoda|Przykład|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Znajduje książkę według identyfikatora przy użyciu `IDToFind` delegata predykatu.<br /><br /> C#przykład używa anonimowego delegata.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Znajdź wszystkie książki, `Genre` których właściwość jest "Computer" `FindComputer` przy użyciu delegata predykatu.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Znajduje ostatnią książkę w kolekcji, która ma datę opublikowania przed 2001, przy użyciu `PubBefore2001` delegata predykatu.<br /><br /> C#przykład używa anonimowego delegata.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Znajduje indeks pierwszej książki komputerowej przy użyciu `FindComputer` delegata predykatu.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Znajduje indeks ostatniej książki komputerowej przy użyciu `FindComputer` delegata predykatu.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Znajduje indeks pierwszej książki komputerowej w drugiej połowie kolekcji przy użyciu `FindComputer` delegata predykatu.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Znajduje indeks ostatniej książki komputerowej w drugiej połowie kolekcji przy użyciu `FindComputer` delegata predykatu.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" />jest <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindLastIndex">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wyszukuje element, który odpowiada warunkom zdefiniowanym przez określony predykat, i zwraca indeks (liczony od zera) ostatniego wystąpienia w <see cref="T:System.Collections.Generic.List`1" /> lub jego części.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindLastIndex">
      <MemberSignature Language="C#" Value="public int FindLastIndex (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindLastIndex(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLastIndex(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLastIndex (match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindLastIndex(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindLastIndex : Predicate&lt;'T&gt; -&gt; int" Usage="list.FindLastIndex match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match"><see cref="T:System.Predicate`1" /> Delegat, który definiuje warunki elementu do wyszukania.</param>
        <summary>Wyszukuje element, który odpowiada warunkom zdefiniowanym przez określony predykat, i zwraca indeks (liczony od zera) ostatniego wystąpienia w całości <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>Indeks (liczony od zera) ostatniego wystąpienia elementu, który jest zgodny z warunkami zdefiniowanymi przez <paramref name="match" />, jeśli został znaleziony; w przeciwnym razie-1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> Jest przeszukiwany wstecz od ostatniego elementu i kończący się na pierwszym elemencie.  
  
 Jest delegatem metody, która zwraca `true` , jeśli obiekt przeszedł do niego, odpowiada warunkom zdefiniowanym w obiekcie delegowanym. <xref:System.Predicate%601>  Elementy bieżącego <xref:System.Collections.Generic.List%601> są indywidualnie przesyłane <xref:System.Predicate%601> do delegata.  
  
 Ta metoda przeprowadza wyszukiwanie liniowe; w związku z tym ta metoda jest operacją O (*n*) ** , gdzie <xref:System.Collections.Generic.List%601.Count%2A>n jest.  
  
   
  
## Examples  
 Poniższy przykład ilustruje metody znajdowania dla <xref:System.Collections.Generic.List%601> klasy. Przykład dla <xref:System.Collections.Generic.List%601> klasy zawiera `book` obiekty klasy `Book`, przy użyciu danych z [przykładowego pliku XML: Książki (LINQ to XML)](https://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). Metoda w przykładzie używa [LINQ to XML](https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) , aby przeanalizować wartości z XML do wartości `book` właściwości obiektów. `FillList`  
  
 W poniższej tabeli opisano przykłady dotyczące metod znajdowania.  
  
|Metoda|Przykład|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Znajduje książkę według identyfikatora przy użyciu `IDToFind` delegata predykatu.<br /><br /> C#przykład używa anonimowego delegata.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Znajdź wszystkie książki, `Genre` których właściwość jest "Computer" `FindComputer` przy użyciu delegata predykatu.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Znajduje ostatnią książkę w kolekcji, która ma datę opublikowania przed 2001, przy użyciu `PubBefore2001` delegata predykatu.<br /><br /> C#przykład używa anonimowego delegata.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Znajduje indeks pierwszej książki komputerowej przy użyciu `FindComputer` delegata predykatu.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Znajduje indeks ostatniej książki komputerowej przy użyciu `FindComputer` delegata predykatu.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Znajduje indeks pierwszej książki komputerowej w drugiej połowie kolekcji przy użyciu `FindComputer` delegata predykatu.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Znajduje indeks ostatniej książki komputerowej w drugiej połowie kolekcji przy użyciu `FindComputer` delegata predykatu.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" />jest <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex">
      <MemberSignature Language="C#" Value="public int FindLastIndex (int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindLastIndex(int32 startIndex, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLastIndex (startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindLastIndex(int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindLastIndex : int * Predicate&lt;'T&gt; -&gt; int" Usage="list.FindLastIndex (startIndex, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">Wartość początkowa indeksu zaczynającego się od zera dla wyszukiwania wstecznego.</param>
        <param name="match"><see cref="T:System.Predicate`1" /> Delegat, który definiuje warunki elementu do wyszukania.</param>
        <summary>Wyszukuje element, który odpowiada warunkom zdefiniowanym przez określony predykat, i zwraca indeks (liczony od zera) ostatniego wystąpienia w zakresie elementów w <see cref="T:System.Collections.Generic.List`1" /> , który rozciąga się od pierwszego elementu do określonego indeksu.</summary>
        <returns>Indeks (liczony od zera) ostatniego wystąpienia elementu, który jest zgodny z warunkami zdefiniowanymi przez <paramref name="match" />, jeśli został znaleziony; w przeciwnym razie-1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest przeszukiwany wstecz od początku `startIndex` i kończąc na pierwszym elemencie. <xref:System.Collections.Generic.List%601>  
  
 Jest delegatem metody, która zwraca `true` , jeśli obiekt przeszedł do niego, odpowiada warunkom zdefiniowanym w obiekcie delegowanym. <xref:System.Predicate%601>  Elementy bieżącego <xref:System.Collections.Generic.List%601> są indywidualnie przesyłane <xref:System.Predicate%601> do delegata.  
  
 Ta metoda przeprowadza wyszukiwanie liniowe; w związku z tym ta metoda jest operacją o (*n*), gdzie *n* jest liczbą elementów od <xref:System.Collections.Generic.List%601> początku do. `startIndex`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" />znajduje się poza zakresem prawidłowych indeksów dla <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex">
      <MemberSignature Language="C#" Value="public int FindLastIndex (int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindLastIndex(int32 startIndex, int32 count, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLastIndex (startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindLastIndex(int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindLastIndex : int * int * Predicate&lt;'T&gt; -&gt; int" Usage="list.FindLastIndex (startIndex, count, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">Wartość początkowa indeksu zaczynającego się od zera dla wyszukiwania wstecznego.</param>
        <param name="count">Liczba elementów w sekcji do wyszukania.</param>
        <param name="match"><see cref="T:System.Predicate`1" /> Delegat, który definiuje warunki elementu do wyszukania.</param>
        <summary>Wyszukuje element, który odpowiada warunkom zdefiniowanym przez określony predykat, i zwraca indeks (liczony od zera) ostatniego wystąpienia w zakresie elementów w <see cref="T:System.Collections.Generic.List`1" /> , który zawiera określoną liczbę elementów i kończą się na określony indeks.</summary>
        <returns>Indeks (liczony od zera) ostatniego wystąpienia elementu, który jest zgodny z warunkami zdefiniowanymi przez <paramref name="match" />, jeśli został znaleziony; w przeciwnym razie-1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `count` `count` `startIndex` `startIndex` Program jest przeszukiwany wstecz od i kończąc od minusa plus 1, jeśli jest większy niż 0. <xref:System.Collections.Generic.List%601>  
  
 Jest delegatem metody, która zwraca `true` , jeśli obiekt przeszedł do niego, odpowiada warunkom zdefiniowanym w obiekcie delegowanym. <xref:System.Predicate%601>  Elementy bieżącego <xref:System.Collections.Generic.List%601> są indywidualnie przesyłane <xref:System.Predicate%601> do delegata.  
  
 Ta metoda przeprowadza wyszukiwanie liniowe; w związku z tym ta metoda jest operacją O (*n*) ** , gdzie `count`n jest.  
  
   
  
## Examples  
 Poniższy przykład ilustruje metody znajdowania dla <xref:System.Collections.Generic.List%601> klasy. Przykład dla <xref:System.Collections.Generic.List%601> klasy zawiera `book` obiekty klasy `Book`, przy użyciu danych z [przykładowego pliku XML: Książki (LINQ to XML)](https://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). Metoda w przykładzie używa [LINQ to XML](https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) , aby przeanalizować wartości z XML do wartości `book` właściwości obiektów. `FillList`  
  
 W poniższej tabeli opisano przykłady dotyczące metod znajdowania.  
  
|Metoda|Przykład|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Znajduje książkę według identyfikatora przy użyciu `IDToFind` delegata predykatu.<br /><br /> C#przykład używa anonimowego delegata.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Znajdź wszystkie książki, `Genre` których właściwość jest "Computer" `FindComputer` przy użyciu delegata predykatu.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Znajduje ostatnią książkę w kolekcji, która ma datę opublikowania przed 2001, przy użyciu `PubBefore2001` delegata predykatu.<br /><br /> C#przykład używa anonimowego delegata.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Znajduje indeks pierwszej książki komputerowej przy użyciu `FindComputer` delegata predykatu.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Znajduje indeks ostatniej książki komputerowej przy użyciu `FindComputer` delegata predykatu.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Znajduje indeks pierwszej książki komputerowej w drugiej połowie kolekcji przy użyciu `FindComputer` delegata predykatu.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Znajduje indeks ostatniej książki komputerowej w drugiej połowie kolekcji przy użyciu `FindComputer` delegata predykatu.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" />znajduje się poza zakresem prawidłowych indeksów dla <see cref="T:System.Collections.Generic.List`1" />.  
  
—lub— 
 <paramref name="count" />jest mniejsza niż 0.  
  
—lub— 
 <paramref name="startIndex" />i <paramref name="count" /> nie określaj prawidłowej sekcji <see cref="T:System.Collections.Generic.List`1" />w.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="ForEach">
      <MemberSignature Language="C#" Value="public void ForEach (Action&lt;T&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ForEach(class System.Action`1&lt;!T&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.ForEach(System.Action{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub ForEach (action As Action(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ForEach(Action&lt;T&gt; ^ action);" />
      <MemberSignature Language="F#" Value="member this.ForEach : Action&lt;'T&gt; -&gt; unit" Usage="list.ForEach action" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="action">Delegat do wykonania na każdym elemencie <see cref="T:System.Collections.Generic.List`1" />. <see cref="T:System.Action`1" /></param>
        <summary>Wykonuje określoną akcję dla każdego elementu <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Action%601> Jest delegatem do metody, która wykonuje akcję na obiekcie, do którego została przeniesiona.  Elementy bieżącego <xref:System.Collections.Generic.List%601> są indywidualnie przesyłane <xref:System.Action%601> do delegata.  
  
 Ta metoda jest operacją O (*n*), gdzie *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 Modyfikowanie podstawowej kolekcji w treści <xref:System.Action%601> delegata nie jest obsługiwane i powoduje niezdefiniowane zachowanie.  
  
   
  
## Examples  
 Poniższy przykład ilustruje użycie <xref:System.Action%601> delegata do drukowania zawartości <xref:System.Collections.Generic.List%601> obiektu. W tym przykładzie `Print` Metoda jest używana do wyświetlania zawartości listy w konsoli programu.  
  
> [!NOTE]
>  Oprócz wyświetlania zawartości przy użyciu `Print` metody C# przykład ilustruje użycie [metod anonimowych](~/docs/csharp/programming-guide/statements-expressions-operators/anonymous-methods.md) , aby wyświetlić wyniki w konsoli.  
  
 [!code-csharp[System.Action_PrintExample#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Action_PrintExample/cs/action.cs#01)]
 [!code-vb[System.Action_PrintExample#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Action_PrintExample/vb/action.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="action" />jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Element w kolekcji został zmodyfikowany.</exception>
        <altmember cref="T:System.Action`1" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;T&gt;.Enumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Collections.Generic.List`1/Enumerator&lt;!T&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As List(Of T).Enumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;T&gt;::Enumerator GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; System.Collections.Generic.List&lt;'T&gt;.Enumerator" Usage="list.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;T&gt;+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca moduł wyliczający, który wykonuje iterację przez <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns><see cref="T:System.Collections.Generic.List`1.Enumerator" /> A<see cref="T:System.Collections.Generic.List`1" />dla.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `foreach` Instrukcja C# języka(`for each` C++w VisualBasic)ukrywazłożonośćmodułówwyliczających.`For Each` W związku z `foreach` tym zaleca się użycie zamiast bezpośredniego manipulowania modułem wyliczającym.  
  
 Moduły wyliczające mogą służyć do odczytu danych w kolekcji, ale nie można za ich pomocą modyfikować kolekcji źródłowej.  
  
 Początkowo moduł wyliczający jest umieszczony przed pierwszym elementem w kolekcji. W tym miejscu <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> właściwość jest niezdefiniowana. W związku z tym, należy <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> wywołać metodę, aby wykonać przechodzenie modułu wyliczającego do pierwszego elementu kolekcji przed odczytem <xref:System.Collections.Generic.List%601.Enumerator.Current%2A>wartości.  
  
 Właściwość zwraca ten sam obiekt, dopóki <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> nie zostanie wywołana. <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A>ustawia <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> do następnego elementu.  
  
 Jeśli <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> przekazuje koniec kolekcji, moduł wyliczający jest umieszczony po ostatnim elemencie w kolekcji i <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> zwraca `false`. Gdy moduł wyliczający znajduje się w tym miejscu, kolejne <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> wywołania również `false`zwracają. Jeśli ostatnie wywołanie <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> zwrócone `false`, <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> nie jest zdefiniowane. Nie można ponownie <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> ustawić na pierwszy element kolekcji; zamiast tego należy utworzyć nowe wystąpienie modułu wyliczającego.  
  
 Moduł wyliczający zachowuje ważność tak długo, jak długo kolekcja pozostaje niezmieniona. Jeśli w kolekcji zostaną wprowadzone zmiany, takie jak dodanie, zmodyfikowanie lub usunięcie elementów, moduł wyliczający jest nieodwracalnie unieważniony i następne wywołanie <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> lub <xref:System.Collections.Generic.List%601.Enumerator.System%23Collections%23IEnumerator%23Reset%2A> wygeneruje <xref:System.InvalidOperationException>.  
  
 Moduł wyliczający nie ma wyłącznego dostępu do kolekcji, w związku z tym wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość. Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania.  Aby zezwolić wielu wątkom na dostęp do kolekcji w celu odczytu i zapisu danych, należy zaimplementować własny mechanizm synchronizacji.  
  
 Domyślne implementacje kolekcji w <xref:System.Collections.Generic?displayProperty=nameWithType> przestrzeni nazw nie są zsynchronizowane.  
  
 Ta metoda jest operacją O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.List`1.Enumerator" />
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="GetRange">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;T&gt; GetRange (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;!T&gt; GetRange(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRange (index As Integer, count As Integer) As List(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;T&gt; ^ GetRange(int index, int count);" />
      <MemberSignature Language="F#" Value="member this.GetRange : int * int -&gt; System.Collections.Generic.List&lt;'T&gt;" Usage="list.GetRange (index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Indeks (liczony od <see cref="T:System.Collections.Generic.List`1" /> zera), w którym zaczyna się zakres.</param>
        <param name="count">Liczba elementów w zakresie.</param>
        <summary>Tworzy skróconą kopię zakresu elementów w źródle <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>Skrócona kopia zakresu elementów w źródle <see cref="T:System.Collections.Generic.List`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Skrócona kopia kolekcji typów referencyjnych lub podzbiór tej kolekcji zawiera tylko odwołania do elementów kolekcji. Same obiekty nie są kopiowane. Odwołania na nowej liście wskazują te same obiekty jak odwołania na liście pierwotnej.  
  
 Skrócona kopia kolekcji typów wartości lub podzbiór tej kolekcji zawiera elementy kolekcji. Jeśli jednak elementy kolekcji zawierają odwołania do innych obiektów, te obiekty nie są kopiowane. Odwołania w elementach nowej kolekcji wskazują te same obiekty jak odwołania w elementach oryginalnej kolekcji.  
  
 Z kolei Szczegółowa kopia kolekcji Kopiuje elementy i wszystko bezpośrednio lub pośrednio odwołujące się do elementów.  
  
 Ta metoda jest operacją O (*n*), gdzie *n* jest `count`.  
  
   
  
## Examples  
 Poniższy przykład ilustruje <xref:System.Collections.Generic.List%601.GetRange%2A> metodę i inne metody <xref:System.Collections.Generic.List%601> klasy, które działają na zakresach. Na końcu przykładu <xref:System.Collections.Generic.List%601.GetRange%2A> Metoda jest używana do uzyskania trzech elementów z listy, rozpoczynając od lokalizacji indeksu 2. Metoda jest wywoływana na skutek <xref:System.Collections.Generic.List%601>, tworząc tablicę trzech elementów. <xref:System.Collections.Generic.List%601.ToArray%2A> Wyświetlane są elementy tablicy.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />jest mniejsza niż 0.  
  
—lub— 
 <paramref name="count" />jest mniejsza niż 0.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" />i <paramref name="count" /> nie należy wskazywać prawidłowego zakresu elementów <see cref="T:System.Collections.Generic.List`1" />w.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca indeks (liczony od zera) pierwszego wystąpienia wartości w <see cref="T:System.Collections.Generic.List`1" /> lub w części.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.IndexOf(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOf(T item);" />
      <MemberSignature Language="F#" Value="abstract member IndexOf : 'T -&gt; int&#xA;override this.IndexOf : 'T -&gt; int" Usage="list.IndexOf item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.IndexOf(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Obiekt, który ma zostać zlokalizowany w <see cref="T:System.Collections.Generic.List`1" />. Wartość może być <see langword="null" /> dla typów referencyjnych.</param>
        <summary>Wyszukuje określony obiekt i zwraca indeks (liczony od zera) pierwszego wystąpienia w całości <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>Indeks (liczony od zera) pierwszego wystąpienia <paramref name="item" /> w całości <see cref="T:System.Collections.Generic.List`1" />, jeśli został znaleziony; w przeciwnym razie-1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> Jest przeszukiwany do przodu, zaczynając od pierwszego elementu i kończąc na ostatnim elemencie.  
  
 Ta metoda określa równość przy użyciu domyślnej funkcji <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> porównującej `T`równość dla, typu wartości na liście.  
  
 Ta metoda przeprowadza wyszukiwanie liniowe; w związku z tym ta metoda jest operacją O (*n*) ** , gdzie <xref:System.Collections.Generic.List%601.Count%2A>n jest.  
  
   
  
## Examples  
 Poniższy przykład ilustruje wszystkie trzy przeciążenia <xref:System.Collections.Generic.List%601.IndexOf%2A> metody. <xref:System.Collections.Generic.List%601> Zostanie utworzony ciąg z jednym wpisem, który występuje dwa razy, w lokalizacji indeksu 0 i lokalizacji indeksu 5. Przeciążenie <xref:System.Collections.Generic.List%601.IndexOf%28%600%29> metody przeszukuje listę od początku i odnajduje pierwsze wystąpienie ciągu. Przeciążenie <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%29> metody służy do przeszukiwania listy zaczynającej się od lokalizacji indeksu 3 i kontynuowania na końcu listy i znajdowania drugiego wystąpienia ciągu. Na koniec Przeciążenie metody służy do przeszukiwania zakresu dwóch wpisów, zaczynając od lokalizacji indeksu dwa; zwraca wartość-1, ponieważ w tym zakresie nie ma wystąpień ciągu wyszukiwania. <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29>  
  
 [!code-cpp[List\`1_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_IndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Wykonywanie niezależnych od kultury operacji na ciągach w kolekcjach</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (T item, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(!T item, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (item As T, index As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(T item, int index);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : 'T * int -&gt; int" Usage="list.IndexOf (item, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">Obiekt, który ma zostać zlokalizowany w <see cref="T:System.Collections.Generic.List`1" />. Wartość może być <see langword="null" /> dla typów referencyjnych.</param>
        <param name="index">Wartość początkowa indeksu zaczynającego się od zera dla wyszukiwania. wartość 0 (zero) jest prawidłowa na pustej liście.</param>
        <summary>Wyszukuje określony obiekt i zwraca indeks (liczony od zera) pierwszego wystąpienia w zakresie elementów w <see cref="T:System.Collections.Generic.List`1" /> elemencie, który rozciąga się od określonego indeksu do ostatniego elementu.</summary>
        <returns>Indeks (liczony od zera) pierwszego wystąpienia <paramref name="item" /> w zakresie elementów <see cref="T:System.Collections.Generic.List`1" /> w programie, który rozciąga się od <paramref name="index" /> do ostatniego elementu, jeśli został znaleziony; w przeciwnym razie-1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest przeszukiwany do przodu `index` i kończący się na ostatnim elemencie. <xref:System.Collections.Generic.List%601>  
  
 Ta metoda określa równość przy użyciu domyślnej funkcji <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> porównującej `T`równość dla, typu wartości na liście.  
  
 Ta metoda przeprowadza wyszukiwanie liniowe; w związku z tym ta metoda jest operacją o (*n*), gdzie *n* jest liczbą elementów od `index` do końca <xref:System.Collections.Generic.List%601>.  
  
   
  
## Examples  
 Poniższy przykład ilustruje wszystkie trzy przeciążenia <xref:System.Collections.Generic.List%601.IndexOf%2A> metody. <xref:System.Collections.Generic.List%601> Zostanie utworzony ciąg z jednym wpisem, który występuje dwa razy, w lokalizacji indeksu 0 i lokalizacji indeksu 5. Przeciążenie <xref:System.Collections.Generic.List%601.IndexOf%28%600%29> metody przeszukuje listę od początku i odnajduje pierwsze wystąpienie ciągu. Przeciążenie <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%29> metody służy do przeszukiwania listy zaczynającej się od lokalizacji indeksu 3 i kontynuowania na końcu listy i znajdowania drugiego wystąpienia ciągu. Na koniec Przeciążenie metody służy do przeszukiwania zakresu dwóch wpisów, zaczynając od lokalizacji indeksu dwa; zwraca wartość-1, ponieważ w tym zakresie nie ma wystąpień ciągu wyszukiwania. <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29>  
  
 [!code-cpp[List\`1_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_IndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />znajduje się poza zakresem prawidłowych indeksów dla <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Wykonywanie niezależnych od kultury operacji na ciągach w kolekcjach</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (T item, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(!T item, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (item As T, index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(T item, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : 'T * int * int -&gt; int" Usage="list.IndexOf (item, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">Obiekt, który ma zostać zlokalizowany w <see cref="T:System.Collections.Generic.List`1" />. Wartość może być <see langword="null" /> dla typów referencyjnych.</param>
        <param name="index">Wartość początkowa indeksu zaczynającego się od zera dla wyszukiwania. wartość 0 (zero) jest prawidłowa na pustej liście.</param>
        <param name="count">Liczba elementów w sekcji do wyszukania.</param>
        <summary>Wyszukuje określony obiekt i zwraca indeks (liczony od zera) pierwszego wystąpienia w zakresie elementów w <see cref="T:System.Collections.Generic.List`1" /> obiekcie, który zaczyna się od określonego indeksu i zawiera określoną liczbę elementów.</summary>
        <returns>Indeks (liczony od zera) pierwszego <paramref name="item" /> wystąpienia elementu <see cref="T:System.Collections.Generic.List`1" /> w zakresie, który zaczyna się <paramref name="index" /> od i zawiera <paramref name="count" /> liczbę elementów, jeśli został znaleziony; w przeciwnym razie-1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `count` `count` `index` `index` Program jest przeszukiwany do przodu, rozpoczynając od i kończąc o minus 1, jeśli jest większy niż 0. <xref:System.Collections.Generic.List%601>  
  
 Ta metoda określa równość przy użyciu domyślnej funkcji <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> porównującej `T`równość dla, typu wartości na liście.  
  
 Ta metoda przeprowadza wyszukiwanie liniowe; w związku z tym ta metoda jest operacją O (*n*) ** , gdzie `count`n jest.  
  
   
  
## Examples  
 Poniższy przykład ilustruje wszystkie trzy przeciążenia <xref:System.Collections.Generic.List%601.IndexOf%2A> metody. <xref:System.Collections.Generic.List%601> Zostanie utworzony ciąg z jednym wpisem, który występuje dwa razy, w lokalizacji indeksu 0 i lokalizacji indeksu 5. Przeciążenie <xref:System.Collections.Generic.List%601.IndexOf%28%600%29> metody przeszukuje listę od początku i odnajduje pierwsze wystąpienie ciągu. Przeciążenie <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%29> metody służy do przeszukiwania listy zaczynającej się od lokalizacji indeksu 3 i kontynuowania na końcu listy i znajdowania drugiego wystąpienia ciągu. Na koniec Przeciążenie metody służy do przeszukiwania zakresu dwóch wpisów, zaczynając od lokalizacji indeksu dwa; zwraca wartość-1, ponieważ w tym zakresie nie ma wystąpień ciągu wyszukiwania. <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29>  
  
 [!code-cpp[List\`1_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_IndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />znajduje się poza zakresem prawidłowych indeksów dla <see cref="T:System.Collections.Generic.List`1" />.  
  
—lub— 
 <paramref name="count" />jest mniejsza niż 0.  
  
—lub— 
 <paramref name="index" />i <paramref name="count" /> nie określaj prawidłowej sekcji <see cref="T:System.Collections.Generic.List`1" />w.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Wykonywanie niezależnych od kultury operacji na ciągach w kolekcjach</related>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public void Insert (int index, T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Insert(int32 index, !T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Insert (index As Integer, item As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Insert(int index, T item);" />
      <MemberSignature Language="F#" Value="abstract member Insert : int * 'T -&gt; unit&#xA;override this.Insert : int * 'T -&gt; unit" Usage="list.Insert (index, item)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="index">Indeks (liczony od zera), <paramref name="item" /> który powinien zostać wstawiony.</param>
        <param name="item">Obiekt do wstawienia. Wartość może być <see langword="null" /> dla typów referencyjnych.</param>
        <summary>Wstawia element do <see cref="T:System.Collections.Generic.List`1" /> obiektu o określonym indeksie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601>akceptuje `null` jako prawidłową wartość dla typów odwołań i umożliwia duplikowanie elementów.  
  
 Jeśli <xref:System.Collections.Generic.List%601.Count%2A> już jest <xref:System.Collections.Generic.List%601.Capacity%2A>równa <xref:System.Collections.Generic.List%601> , Pojemność programu jest zwiększana przez automatyczne ponowne przydzielanie tablicy wewnętrznej, a istniejące elementy są kopiowane do nowej tablicy przed dodaniem nowego elementu.  
  
 Jeśli `index` jest `item` <xref:System.Collections.Generic.List%601>równa, jest dodawany do końca. <xref:System.Collections.Generic.List%601.Count%2A>  
  
 Ta metoda jest operacją O (*n*), gdzie *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  

 [!INCLUDE[interactive-note](~/includes/csharp-interactive-note-some.md)]

 Poniższy przykład pokazuje, jak dodawać, usuwać i wstawiać prosty obiekt biznesowy w programie <xref:System.Collections.Generic.List%601>.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 Poniższy przykład demonstruje <xref:System.Collections.Generic.List%601.Insert%2A> metodę wraz z różnymi innymi właściwościami i metodami <xref:System.Collections.Generic.List%601> klasy generycznej. Po utworzeniu listy są dodawane elementy. <xref:System.Collections.Generic.List%601.Insert%2A> Metoda służy do wstawiania elementu do środka listy. Wstawiony element jest duplikatem, który został później usunięty przy użyciu <xref:System.Collections.Generic.List%601.Remove%2A> metody.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp-interactive[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />jest mniejsza niż 0.  
  
—lub— 
 <paramref name="index" />jest większa niż <see cref="P:System.Collections.Generic.List`1.Count" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
      </Docs>
    </Member>
    <Member MemberName="InsertRange">
      <MemberSignature Language="C#" Value="public void InsertRange (int index, System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertRange(int32 index, class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub InsertRange (index As Integer, collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InsertRange(int index, System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberSignature Language="F#" Value="member this.InsertRange : int * seq&lt;'T&gt; -&gt; unit" Usage="list.InsertRange (index, collection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="index">Indeks (liczony od zera), w którym należy wstawić nowe elementy.</param>
        <param name="collection">Kolekcja, której elementy powinny być wstawiane do <see cref="T:System.Collections.Generic.List`1" />. Sama kolekcja nie może być <see langword="null" />, ale może zawierać elementy, które są <see langword="null" />, jeśli typ <paramref name="T" /> jest typem referencyjnym.</param>
        <summary>Wstawia elementy kolekcji do <see cref="T:System.Collections.Generic.List`1" /> określonego indeksu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601>akceptuje `null` jako prawidłową wartość dla typów odwołań i umożliwia duplikowanie elementów.  
  
 Jeśli nowy <xref:System.Collections.Generic.List%601.Count%2A> (bieżący <xref:System.Collections.Generic.List%601.Count%2A> i rozmiar kolekcji) będzie większy niż <xref:System.Collections.Generic.List%601.Capacity%2A>, pojemność <xref:System.Collections.Generic.List%601> jest zwiększana przez automatyczne ponowne przydzielanie tablicy wewnętrznej w celu uwzględnienia nowych elementów, a istniejące elementy są kopiowane do nowej tablicy przed dodaniem nowych elementów.  
  
 Jeśli `index` jest <xref:System.Collections.Generic.List%601>równa, elementy są dodawane na końcu. <xref:System.Collections.Generic.List%601.Count%2A>  
  
 Kolejność elementów w kolekcji jest zachowywana w <xref:System.Collections.Generic.List%601>.  
  
 Ta metoda jest operacją o (*n* * *m*), gdzie *n* to liczba elementów do dodania i m jest. ** <xref:System.Collections.Generic.List%601.Count%2A>  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.Collections.Generic.List%601.InsertRange%2A> metodę i różne inne metody <xref:System.Collections.Generic.List%601> klasy, które działają na zakresach. Gdy lista została utworzona i uzupełniona o nazwy kilku pokojowych dinozaurów, Metoda ta <xref:System.Collections.Generic.List%601.InsertRange%2A> jest używana do wstawienia tablicy trzech ferociousów, które są dinozaurami do listy, rozpoczynając od lokalizacji indeksu 3.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="collection" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />jest mniejsza niż 0.  
  
—lub— 
 <paramref name="index" />jest większa niż <see cref="P:System.Collections.Generic.List`1.Count" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public T this[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Item(index As Integer) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T default[int] { T get(int index); void set(int index, T value); };" />
      <MemberSignature Language="F#" Value="member this.Item(int) : 'T with get, set" Usage="System.Collections.Generic.List&lt;'T&gt;.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IList`1.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Liczony od zera indeks elementu, który ma zostać pobrany lub skonfigurowany.</param>
        <summary>Pobieranie lub konfigurowanie elementów pod określonym indeksem.</summary>
        <value>Element pod określonym indeksem.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601>akceptuje `null` jako prawidłową wartość dla typów odwołań i umożliwia duplikowanie elementów.  
  
 Ta właściwość zapewnia możliwość dostępu do określonego elementu w kolekcji przy użyciu następującej składni: `myCollection[index]`.  
  
 Pobieranie wartości tej właściwości jest operacją O (1); ustawienie właściwości jest również operacją O (1).  
  
   
  
## Examples  
 W przykładzie w tej sekcji przedstawiono <xref:System.Collections.Generic.List%601.Item%2A> Właściwość (indeksator w programie C#) i różne inne właściwości <xref:System.Collections.Generic.List%601> i metody klasy generycznej. Po utworzeniu listy i wypełnieniu jej przy użyciu <xref:System.Collections.Generic.List%601.Add%2A> metody element jest pobierany i wyświetlany <xref:System.Collections.Generic.List%601.Item%2A> przy użyciu właściwości. (W przypadku przykładu korzystającego <xref:System.Collections.Generic.List%601.Item%2A> z właściwości w celu ustawienia wartości elementu listy Zobacz <xref:System.Collections.Generic.List%601.AsReadOnly%2A>).  
  
> [!NOTE]
>  Visual Basic, C#i C++ wszystkie mają składnię dostępu <xref:System.Collections.Generic.List%601.Item%2A> do właściwości bez użycia jej nazwy. Zamiast tego zmienna zawierająca <xref:System.Collections.Generic.List%601> jest używana tak, jakby była tablicą.  
  
 C# Język używa [`this`](~/docs/csharp/language-reference/keywords/this.md) słowa kluczowego do definiowania indeksatorów <xref:System.Collections.Generic.List%601.Item%2A> zamiast implementowania właściwości. Visual Basic implementuje <xref:System.Collections.Generic.List%601.Item%2A> jako właściwość domyślną, która zapewnia te same funkcje indeksowania.  
  
 [!code-csharp[List`1_Class#2](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#2)]
 [!code-vb[List`1_Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#2)]  
[!code-csharp[List`1_Class#3](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#3)]
[!code-vb[List`1_Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />jest mniejsza niż 0.  
  
—lub— 
 <paramref name="index" />jest równa lub większa niż <see cref="P:System.Collections.Generic.List`1.Count" />.</exception>
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca indeks (liczony od zera) ostatniego wystąpienia wartości w <see cref="T:System.Collections.Generic.List`1" /> lub w części.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(T item);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : 'T -&gt; int" Usage="list.LastIndexOf item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Obiekt, który ma zostać zlokalizowany w <see cref="T:System.Collections.Generic.List`1" />. Wartość może być <see langword="null" /> dla typów referencyjnych.</param>
        <summary>Wyszukuje określony obiekt i zwraca indeks (liczony od zera) ostatniego wystąpienia w całości <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>Indeks (liczony od zera) ostatniego wystąpienia <paramref name="item" /> w <see cref="T:System.Collections.Generic.List`1" />całości, jeśli został znaleziony; w przeciwnym razie-1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> Jest przeszukiwany wstecz od ostatniego elementu i kończący się na pierwszym elemencie.  
  
 Ta metoda określa równość przy użyciu domyślnej funkcji <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> porównującej `T`równość dla, typu wartości na liście.  
  
 Ta metoda przeprowadza wyszukiwanie liniowe; w związku z tym ta metoda jest operacją O (*n*) ** , gdzie <xref:System.Collections.Generic.List%601.Count%2A>n jest.  
  
   
  
## Examples  
 Poniższy przykład ilustruje wszystkie trzy przeciążenia <xref:System.Collections.Generic.List%601.LastIndexOf%2A> metody. <xref:System.Collections.Generic.List%601> Zostanie utworzony ciąg z jednym wpisem, który występuje dwa razy, w lokalizacji indeksu 0 i lokalizacji indeksu 5. Przeciążenie <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%29> metody przeszukuje całą listę od końca i znajduje drugie wystąpienie ciągu. Przeciążenie <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%29> metody służy do przeszukiwania listy wstecz Zaczynając od lokalizacji indeksu 3 i kontynuowania na początku listy, dlatego Znajdź pierwsze wystąpienie ciągu na liście. Na koniec metoda przeciążenia jest używana do wyszukiwania zakresu czterech wpisów, rozpoczynając od lokalizacji indeksu 4 i rozszerzania do tyłu (to znaczy przeszukuje elementy w lokalizacjach 4, 3, 2 i 1). Wyszukiwanie zwraca wartość-1, ponieważ nie ma wystąpień wyszukiwania <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> ciąg w tym zakresie.  
  
 [!code-cpp[List\`1_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_LastIndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Wykonywanie niezależnych od kultury operacji na ciągach w kolekcjach</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (T item, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(!T item, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (item As T, index As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(T item, int index);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : 'T * int -&gt; int" Usage="list.LastIndexOf (item, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">Obiekt, który ma zostać zlokalizowany w <see cref="T:System.Collections.Generic.List`1" />. Wartość może być <see langword="null" /> dla typów referencyjnych.</param>
        <param name="index">Wartość początkowa indeksu zaczynającego się od zera dla wyszukiwania wstecznego.</param>
        <summary>Wyszukuje określony obiekt i zwraca indeks (liczony od zera) ostatniego wystąpienia w zakresie elementów w <see cref="T:System.Collections.Generic.List`1" /> elemencie, który rozciąga się od pierwszego elementu do określonego indeksu.</summary>
        <returns>Indeks (liczony od zera) ostatniego wystąpienia <paramref name="item" /> w zakresie elementów <see cref="T:System.Collections.Generic.List`1" /> w programie, który rozciąga się od pierwszego elementu do <paramref name="index" />, jeśli został znaleziony; w przeciwnym razie-1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest przeszukiwany wstecz od początku `index` i kończąc na pierwszym elemencie. <xref:System.Collections.Generic.List%601>  
  
 Ta metoda określa równość przy użyciu domyślnej funkcji <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> porównującej `T`równość dla, typu wartości na liście.  
  
 Ta metoda przeprowadza wyszukiwanie liniowe; w związku z tym ta metoda jest operacją o (*n*), gdzie *n* jest liczbą elementów od <xref:System.Collections.Generic.List%601> początku do. `index`  
  
   
  
## Examples  
 Poniższy przykład ilustruje wszystkie trzy przeciążenia <xref:System.Collections.Generic.List%601.LastIndexOf%2A> metody. <xref:System.Collections.Generic.List%601> Zostanie utworzony ciąg z jednym wpisem, który występuje dwa razy, w lokalizacji indeksu 0 i lokalizacji indeksu 5. Przeciążenie <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%29> metody przeszukuje całą listę od końca i znajduje drugie wystąpienie ciągu. Przeciążenie <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%29> metody służy do przeszukiwania listy wstecz Zaczynając od lokalizacji indeksu 3 i kontynuowania na początku listy, dlatego Znajdź pierwsze wystąpienie ciągu na liście. Na koniec metoda przeciążenia jest używana do wyszukiwania zakresu czterech wpisów, rozpoczynając od lokalizacji indeksu 4 i rozszerzania do tyłu (to znaczy przeszukuje elementy w lokalizacjach 4, 3, 2 i 1). Wyszukiwanie zwraca wartość-1, ponieważ nie ma wystąpień wyszukiwania <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> ciąg w tym zakresie.  
  
 [!code-cpp[List\`1_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_LastIndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />znajduje się poza zakresem prawidłowych indeksów dla <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Wykonywanie niezależnych od kultury operacji na ciągach w kolekcjach</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (T item, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(!T item, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (item As T, index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(T item, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : 'T * int * int -&gt; int" Usage="list.LastIndexOf (item, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">Obiekt, który ma zostać zlokalizowany w <see cref="T:System.Collections.Generic.List`1" />. Wartość może być <see langword="null" /> dla typów referencyjnych.</param>
        <param name="index">Wartość początkowa indeksu zaczynającego się od zera dla wyszukiwania wstecznego.</param>
        <param name="count">Liczba elementów w sekcji do wyszukania.</param>
        <summary>Wyszukuje określony obiekt i zwraca indeks (liczony od zera) ostatniego wystąpienia w zakresie elementów w <see cref="T:System.Collections.Generic.List`1" /> elemencie, który zawiera określoną liczbę elementów i kończą się określonym indeksem.</summary>
        <returns>Indeks (liczony od zera) ostatniego <paramref name="item" /> wystąpienia elementu <see cref="T:System.Collections.Generic.List`1" /> w zakresie, który zawiera <paramref name="count" /> liczbę elementów i kończą się o <paramref name="index" />, jeśli został znaleziony; w przeciwnym razie-1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `count` `count` `index` `index` Program jest przeszukiwany wstecz od i kończąc od minusa plus 1, jeśli jest większy niż 0. <xref:System.Collections.Generic.List%601>  
  
 Ta metoda określa równość przy użyciu domyślnej funkcji <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> porównującej `T`równość dla, typu wartości na liście.  
  
 Ta metoda przeprowadza wyszukiwanie liniowe; w związku z tym ta metoda jest operacją O (*n*) ** , gdzie `count`n jest.  
  
   
  
## Examples  
 Poniższy przykład ilustruje wszystkie trzy przeciążenia <xref:System.Collections.Generic.List%601.LastIndexOf%2A> metody. <xref:System.Collections.Generic.List%601> Zostanie utworzony ciąg z jednym wpisem, który występuje dwa razy, w lokalizacji indeksu 0 i lokalizacji indeksu 5. Przeciążenie <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%29> metody przeszukuje całą listę od końca i znajduje drugie wystąpienie ciągu. Przeciążenie <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%29> metody służy do przeszukiwania listy wstecz Zaczynając od lokalizacji indeksu 3 i kontynuowania na początku listy, dlatego Znajdź pierwsze wystąpienie ciągu na liście. Na koniec metoda przeciążenia jest używana do wyszukiwania zakresu 4 wpisów, rozpoczynając od lokalizacji indeksu 4 i rozszerzania do tyłu (to oznacza, że przeszukuje elementy w lokalizacjach 4, 3, 2 i 1). Wyszukiwanie zwraca wartość-1, ponieważ nie ma wystąpień wyszukiwania <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> ciąg w tym zakresie.  
  
 [!code-cpp[List\`1_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_LastIndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />znajduje się poza zakresem prawidłowych indeksów dla <see cref="T:System.Collections.Generic.List`1" />.  
  
—lub— 
 <paramref name="count" />jest mniejsza niż 0.  
  
—lub— 
 <paramref name="index" />i <paramref name="count" /> nie określaj prawidłowej sekcji <see cref="T:System.Collections.Generic.List`1" />w.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Wykonywanie niezależnych od kultury operacji na ciągach w kolekcjach</related>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Remove(T item);" />
      <MemberSignature Language="F#" Value="abstract member Remove : 'T -&gt; bool&#xA;override this.Remove : 'T -&gt; bool" Usage="list.Remove item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Obiekt, który ma zostać usunięty <see cref="T:System.Collections.Generic.List`1" />z. Wartość może być <see langword="null" /> dla typów referencyjnych.</param>
        <summary>Usuwa pierwsze wystąpienie określonego obiektu z <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns><see langword="true" />Jeśli <paramref name="item" /> program<see langword="false" />został pomyślnie usunięty; w przeciwnym razie.  Ta metoda zwraca również <see langword="false" /> wartość <paramref name="item" /> , <see cref="T:System.Collections.Generic.List`1" />Jeśli nie została znaleziona w.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli typ `T` <xref:System.IEquatable%601.Equals%2A> implementuje interfejs <xref:System.Object.Equals%2A?displayProperty=nameWithType>ogólny, funkcja porównująca równość jest metodą tego interfejsu; w przeciwnym razie domyślna funkcja porównująca równość to. <xref:System.IEquatable%601>  
  
 Ta metoda przeprowadza wyszukiwanie liniowe; w związku z tym ta metoda jest operacją O (*n*) ** , gdzie <xref:System.Collections.Generic.List%601.Count%2A>n jest.  
  
   
  
## Examples  

 [!INCLUDE[interactive-note](~/includes/csharp-interactive-note-some.md)]

 Poniższy przykład pokazuje, jak dodawać, usuwać i wstawiać prosty obiekt biznesowy w programie <xref:System.Collections.Generic.List%601>.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 Poniższy przykład ilustruje <xref:System.Collections.Generic.List%601.Remove%2A> metodę. Kilka właściwości i metod <xref:System.Collections.Generic.List%601> klasy generycznej służy do dodawania, wstawiania i wyszukiwania listy. Po wykonaniu tych operacji lista zawiera duplikat. <xref:System.Collections.Generic.List%601.Remove%2A> Metoda jest używana do usuwania pierwszego wystąpienia zduplikowanego elementu, a zawartość zostanie wyświetlona. <xref:System.Collections.Generic.List%601.Remove%2A> Metoda zawsze usuwa pierwsze wystąpienie, które napotka.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp-interactive[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Wykonywanie niezależnych od kultury operacji na ciągach w kolekcjach</related>
      </Docs>
    </Member>
    <Member MemberName="RemoveAll">
      <MemberSignature Language="C#" Value="public int RemoveAll (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 RemoveAll(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.RemoveAll(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAll (match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int RemoveAll(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.RemoveAll : Predicate&lt;'T&gt; -&gt; int" Usage="list.RemoveAll match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match"><see cref="T:System.Predicate`1" /> Delegat, który definiuje warunki elementów do usunięcia.</param>
        <summary>Usuwa wszystkie elementy, które pasują do warunków zdefiniowanych przez określony predykat.</summary>
        <returns>Liczba elementów usuniętych z <see cref="T:System.Collections.Generic.List`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest delegatem metody, która zwraca `true` , jeśli obiekt przeszedł do niego, odpowiada warunkom zdefiniowanym w obiekcie delegowanym. <xref:System.Predicate%601>  Elementy bieżącego <xref:System.Collections.Generic.List%601> są indywidualnie przenoszone <xref:System.Predicate%601> do delegata, a elementy, które pasują do <xref:System.Collections.Generic.List%601>warunków, są usuwane z.  
  
 Ta metoda przeprowadza wyszukiwanie liniowe; w związku z tym ta metoda jest operacją O (*n*) ** , gdzie <xref:System.Collections.Generic.List%601.Count%2A>n jest.  
  
   
  
## Examples  
 Poniższy przykład ilustruje <xref:System.Collections.Generic.List%601.RemoveAll%2A> metodę i kilka innych metod, które <xref:System.Predicate%601> używają delegata ogólnego.  
  
 Tworzony jest ciąg z 8. nazwami, z których dwa są (w pozycjach 1 i 5) kończą się znakiem "saurus". <xref:System.Collections.Generic.List%601> W przykładzie zdefiniowano także metodę predykatu wyszukiwania `EndsWithSaurus`o nazwie, która akceptuje parametr String i zwraca wartość logiczną wskazującą, czy ciąg wejściowy jest kończący się na "saurus".  
  
 Metody <xref:System.Collections.Generic.List%601.Find%2A>, <xref:System.Collections.Generic.List%601.FindLast%2A>, i<xref:System.Collections.Generic.List%601.FindAll%2A> są używane do przeszukiwania listy za pomocą metody predykatu wyszukiwania.  
  
 <xref:System.Collections.Generic.List%601.RemoveAll%2A> Metoda służy do usuwania wszystkich wpisów kończących się ciągiem "saurus". Przechodzi na listę od początku, przekazując każdy element z kolei do `EndsWithSaurus` metody. Element jest usuwany, jeśli `EndsWithSaurus` Metoda zwraca `true`.  
  
> [!NOTE]
>  W C# i Visual Basic nie jest konieczne jawne utworzenie `Predicate<string>` delegata (`Predicate(Of String)` w Visual Basic). W tych językach zostanie wywnioskowany poprawny delegat z kontekstu i utworzony automatycznie.  
  
 Na <xref:System.Collections.Generic.List%601.Exists%2A> koniec metoda weryfikuje, czy na liście nie ma żadnych ciągów kończących się na "saurus".  
  
 [!code-cpp[List\`1_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[List\`1_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_FindEtAl/cs/source.cs#1)]
 [!code-vb[List\`1_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" />jest <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="T:System.Predicate`1" />
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public void RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAt (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveAt(int index);" />
      <MemberSignature Language="F#" Value="abstract member RemoveAt : int -&gt; unit&#xA;override this.RemoveAt : int -&gt; unit" Usage="list.RemoveAt index" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)</InterfaceMember>
        <InterfaceMember>M:System.Collections.IList.RemoveAt(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Indeks (liczony od zera) elementu do usunięcia.</param>
        <summary>Usuwa element w określonym indeksie <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po wywołaniu <xref:System.Collections.Generic.List%601.RemoveAt%2A> usunięcia elementu pozostałe elementy na liście są ponownie numerowane w celu zastąpienia usuniętego elementu. Na przykład, jeśli usuniesz element o indeksie 3, element pod indeksem 4 zostanie przeniesiony do pozycji 3. Ponadto liczba elementów na liście (w formie reprezentowanej przez <xref:System.Collections.Generic.List%601.Count%2A> Właściwość) jest ograniczona przez 1.  
  
 Ta metoda jest operacją O (*n*), gdzie *n* to (<xref:System.Collections.Generic.List%601.Count%2A> - `index`).  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak dodawać, usuwać i wstawiać prosty obiekt biznesowy w programie <xref:System.Collections.Generic.List%601>.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />jest mniejsza niż 0.  
  
—lub— 
 <paramref name="index" />jest równa lub większa niż <see cref="P:System.Collections.Generic.List`1.Count" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveRange">
      <MemberSignature Language="C#" Value="public void RemoveRange (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveRange(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveRange (index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveRange(int index, int count);" />
      <MemberSignature Language="F#" Value="member this.RemoveRange : int * int -&gt; unit" Usage="list.RemoveRange (index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Początkowy indeks (liczony od zera) zakresu elementów do usunięcia.</param>
        <param name="count">Liczba elementów do usunięcia.</param>
        <summary>Usuwa zakres elementów z <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Elementy zostaną usunięte, a wszystkie elementy po nich <xref:System.Collections.Generic.List%601> są ograniczone przez. `count`  
  
 Ta metoda jest operacją O (*n*), gdzie *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Poniższy przykład ilustruje <xref:System.Collections.Generic.List%601.RemoveRange%2A> metodę i różne inne metody <xref:System.Collections.Generic.List%601> klasy, które działają na zakresach. Po utworzeniu i zmodyfikowaniu <xref:System.Collections.Generic.List%601.RemoveRange%2A> listy Metoda jest używana do usuwania dwóch elementów z listy, rozpoczynając od lokalizacji indeksu 2.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />jest mniejsza niż 0.  
  
—lub— 
 <paramref name="count" />jest mniejsza niż 0.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" />i <paramref name="count" /> nie należy wskazywać prawidłowego zakresu elementów <see cref="T:System.Collections.Generic.List`1" />w.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Reverse">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Odwraca kolejność elementów w <see cref="T:System.Collections.Generic.List`1" /> lub jej części.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public void Reverse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reverse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Reverse" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reverse ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Reverse();" />
      <MemberSignature Language="F#" Value="member this.Reverse : unit -&gt; unit" Usage="list.Reverse " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odwraca kolejność elementów w całości <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa <xref:System.Array.Reverse%2A?displayProperty=nameWithType> do odwrócenia kolejności elementów.  
  
 Ta metoda jest operacją O (*n*), gdzie *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Poniższy przykład ilustruje oba przeciążenia <xref:System.Collections.Generic.List%601.Reverse%2A> metody. Przykład tworzy <xref:System.Collections.Generic.List%601> ciągi i dodaje sześć ciągów. Przeciążenie metody jest używane do odwrócenia listy, a <xref:System.Collections.Generic.List%601.Reverse%28System.Int32%2CSystem.Int32%29> następnie Przeciążenie metody jest używany do odwrócenia środka listy, zaczynając od elementu 1 i obejmującego cztery elementy. <xref:System.Collections.Generic.List%601.Reverse>  
  
 [!code-cpp[List\`1_Reverse#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Reverse/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Reverse#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Reverse/cs/source.cs#1)]
 [!code-vb[List\`1_Reverse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Reverse/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public void Reverse (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reverse(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Reverse(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reverse (index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Reverse(int index, int count);" />
      <MemberSignature Language="F#" Value="member this.Reverse : int * int -&gt; unit" Usage="list.Reverse (index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Początkowy indeks (liczony od zera) zakresu do odwrócenia.</param>
        <param name="count">Liczba elementów w zakresie do odwrócenia.</param>
        <summary>Odwraca kolejność elementów w określonym zakresie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa <xref:System.Array.Reverse%2A?displayProperty=nameWithType> do odwrócenia kolejności elementów.  
  
 Ta metoda jest operacją O (*n*), gdzie *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Poniższy przykład ilustruje oba przeciążenia <xref:System.Collections.Generic.List%601.Reverse%2A> metody. Przykład tworzy <xref:System.Collections.Generic.List%601> ciągi i dodaje sześć ciągów. Przeciążenie metody jest używane do odwrócenia listy, a <xref:System.Collections.Generic.List%601.Reverse%28System.Int32%2CSystem.Int32%29> następnie Przeciążenie metody jest używany do odwrócenia środka listy, zaczynając od elementu 1 i obejmującego cztery elementy. <xref:System.Collections.Generic.List%601.Reverse>  
  
 [!code-cpp[List\`1_Reverse#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Reverse/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Reverse#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Reverse/cs/source.cs#1)]
 [!code-vb[List\`1_Reverse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Reverse/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />jest mniejsza niż 0.  
  
—lub— 
 <paramref name="count" />jest mniejsza niż 0.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" />i <paramref name="count" /> nie należy wskazywać prawidłowego zakresu elementów <see cref="T:System.Collections.Generic.List`1" />w.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Sort">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sortuje elementy lub część elementów w programie <see cref="T:System.Collections.Generic.List`1" /> przy użyciu określonej lub domyślnej <see cref="T:System.Collections.Generic.IComparer`1" /> implementacji lub podanego <see cref="T:System.Comparison`1" /> delegata do porównania elementów listy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort();" />
      <MemberSignature Language="F#" Value="member this.Sort : unit -&gt; unit" Usage="list.Sort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sortuje elementy w całości <see cref="T:System.Collections.Generic.List`1" /> przy użyciu domyślnej funkcji porównującej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa domyślnej wartości porównującej <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> dla typu `T` w celu określenia kolejności elementów listy. Właściwość sprawdza, czy typ `T` implementuje <xref:System.IComparable%601> interfejs generyczny i używa tej implementacji, jeśli jest dostępny. <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>  Jeśli nie, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> Sprawdź, czy `T` typ implementuje <xref:System.IComparable> interfejs.  Jeśli typ `T` nie implementuje żadnego interfejsu, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> zgłasza <xref:System.InvalidOperationException>.  
  
 Ta metoda używa <xref:System.Array.Sort%2A?displayProperty=nameWithType> metody, która stosuje sortowanie algorytmu w następujący sposób:  
  
-   Jeśli rozmiar partycji jest mniejszy niż 16 elementów, używa algorytmu sortowania wstawiania.  
  
-   Jeśli liczba partycji przekracza 2 log *n*, gdzie *n* jest zakresem tablicy wejściowej, używa algorytmu kopcowanie.  
  
-   W przeciwnym razie używa algorytmu sortowania.  
  
 Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana. Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.  
  
 Średnio ta metoda jest operacją o (*n* log *n*), gdzie *n* <xref:System.Collections.Generic.List%601.Count%2A>to; w najgorszym przypadku jest to operacja o (*n*<sup>2</sup>).  
  
   
  
## Examples  
 Poniższy przykład dodaje nazwy do `List<String>` obiektu, wyświetla listę w kolejności niesortowanej, <xref:System.Collections.Generic.List%601.Sort%2A> wywołuje metodę, a następnie wyświetla posortowaną listę.  
  
 [!code-csharp[System.Collections.Generic.List.Sort#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.sort/cs/Sort1.cs#2)]
 [!code-vb[System.Collections.Generic.List.Sort#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.sort/vb/Sort1.vb#2)]  
  
 Poniższy kod ilustruje <xref:System.Collections.Generic.List%601.Sort> przeciążenia metody i <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> w prostym obiekcie biznesowym. Wywołanie metody powoduje użycie domyślnej funkcji porównującej dla typu części, <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> a metoda jest implementowana przy użyciu metody anonimowej. <xref:System.Collections.Generic.List%601.Sort>  
  
 [!code-csharp[System.Collections.Generic.List.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.sort/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.sort/vb/module1.vb#1)]  
  
 Poniższy przykład ilustruje <xref:System.Collections.Generic.List%601.Sort> Przeciążenie metody <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> i Przeciążenie metody. <xref:System.Collections.Generic.List%601> Ciąg jest tworzony i wypełniany czterema ciągami, w określonej kolejności. Lista zostanie wyświetlona, posortowana i wyświetlona ponownie.  
  
 Przeciążenie metody jest następnie używane do wyszukiwania dwóch ciągów, które nie znajdują się na liście, <xref:System.Collections.Generic.List%601.Insert%2A> a metoda jest używana do ich wstawiania. <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> Wartość <xref:System.Collections.Generic.List%601.BinarySearch%2A> zwracana metody jest ujemna w każdym przypadku, ponieważ ciągi nie znajdują się na liście. Przejęcie bitowego uzupełniania (operator ~ w C# i C++Wizualizacja `Xor` ,-1 w Visual Basic) tej liczby ujemnej daje indeks pierwszego elementu na liście, który jest większy niż ciąg wyszukiwania i wstawiania w tej lokalizacji zachowuje porządek sortowania. Drugi ciąg wyszukiwania jest większy niż dowolny element na liście, więc pozycja wstawiania znajduje się na końcu listy.  
  
 [!code-cpp[List\`1_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearch/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Domyślna funkcja porównująca <see cref="P:System.Collections.Generic.Comparer`1.Default" /> nie może znaleźć implementacji <see cref="T:System.IComparable`1" /> interfejsu generycznego lub <see cref="T:System.IComparable" /> interfejsu dla typu <paramref name="T" />.</exception>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Wykonywanie niezależnych od kultury operacji na ciągach w kolekcjach</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort (System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort(class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort(System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort (comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort(System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="member this.Sort : System.Collections.Generic.IComparer&lt;'T&gt; -&gt; unit" Usage="list.Sort comparer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="comparer">Implementacja do użycia podczas porównywania elementów lub <see langword="null" /> używania domyślnego programu porównującego <see cref="P:System.Collections.Generic.Comparer`1.Default" />. <see cref="T:System.Collections.Generic.IComparer`1" /></param>
        <summary>Sortuje elementy w całości <see cref="T:System.Collections.Generic.List`1" /> przy użyciu określonej funkcji porównującej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `comparer` jest podany, elementy <xref:System.Collections.Generic.List%601> elementu są sortowane przy użyciu określonej <xref:System.Collections.Generic.IComparer%601> implementacji.  
  
 Jeśli `comparer` jest `null`, domyślna funkcja porównująca <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> sprawdza, `T` czy typ <xref:System.IComparable%601> implementuje interfejs generyczny i używa tej implementacji, jeśli jest dostępny.  Jeśli nie, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> Sprawdź, czy `T` typ implementuje <xref:System.IComparable> interfejs.  Jeśli typ `T` nie implementuje żadnego interfejsu, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> zgłasza <xref:System.InvalidOperationException>.  
  
 Ta metoda używa <xref:System.Array.Sort%2A?displayProperty=nameWithType> metody, która stosuje sortowanie algorytmu w następujący sposób:  
  
-   Jeśli rozmiar partycji jest mniejszy niż 16 elementów, używa algorytmu sortowania wstawiania.  
  
-   Jeśli liczba partycji przekracza 2 log *n*, gdzie *n* jest zakresem tablicy wejściowej, używa algorytmu kopcowanie.  
  
-   W przeciwnym razie używa algorytmu sortowania.  
  
 Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana. Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.  
  
 Średnio ta metoda jest operacją o (*n* log *n*), gdzie *n* <xref:System.Collections.Generic.List%601.Count%2A>to; w najgorszym przypadku jest to operacja o (*n*<sup>2</sup>).  
  
   
  
## Examples  
 Poniższy przykład ilustruje <xref:System.Collections.Generic.List%601.Sort%28System.Collections.Generic.IComparer%7B%600%7D%29> Przeciążenie metody <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> i Przeciążenie metody.  
  
 W przykładzie zdefiniowano alternatywną funkcję porównującą dla ciągów o nazwie DinoCompare `IComparer<string>` ,`IComparer(Of String)` która implementuje interfejs `IComparer<String^>` ogólny ( C++w Visual Basic w języku Visual). Moduł porównujący działa w następujący sposób: Najpierw comparands są testowane dla `null`, a odwołanie o wartości null jest traktowane jako mniejsze niż wartość null. W drugim, długości ciągu są porównywane, a dłuższy ciąg jest uznawany za większy. Trzecia, jeśli długości są równe, używane jest zwykłe Porównywanie ciągów.  
  
 <xref:System.Collections.Generic.List%601> Ciąg jest tworzony i wypełniany czterema ciągami, w określonej kolejności. Zostanie wyświetlona lista, posortowana przy użyciu alternatywnej funkcji porównującej i ponownie wyświetlana.  
  
 Przeciążenie <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> metody jest następnie używane do wyszukiwania kilku ciągów, które nie znajdują się na liście, przy użyciu alternatywnego porównania. <xref:System.Collections.Generic.List%601.Insert%2A> Metoda jest używana do wstawiania ciągów. Te dwie metody znajdują się w funkcji o `SearchAndInsert`nazwie, wraz z kodem, aby przyjmować użycie bitowe (operator ~ w C# i C++Wizualizacja `Xor` ,-1 w Visual Basic) liczb ujemnych zwracanych <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> przez i używać go jako indeks służący do wstawiania nowego ciągu.  
  
 [!code-cpp[List\`1_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" />jest <see langword="null" />, a domyślna funkcja porównująca <see cref="T:System.IComparable`1" /> <see cref="P:System.Collections.Generic.Comparer`1.Default" /> nie może znaleźć implementacji interfejsu generycznego lub <see cref="T:System.IComparable" /> interfejsu dla typu <paramref name="T" />.</exception>
        <exception cref="T:System.ArgumentException">Implementacja <paramref name="comparer" /> spowodowała błąd podczas sortowania. Na przykład, <paramref name="comparer" /> program nie może zwrócić wartości 0 podczas porównywania elementu z samym sobą.</exception>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Wykonywanie niezależnych od kultury operacji na ciągach w kolekcjach</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort (Comparison&lt;T&gt; comparison);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort(class System.Comparison`1&lt;!T&gt; comparison) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort(System.Comparison{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort (comparison As Comparison(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort(Comparison&lt;T&gt; ^ comparison);" />
      <MemberSignature Language="F#" Value="member this.Sort : Comparison&lt;'T&gt; -&gt; unit" Usage="list.Sort comparison" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparison" Type="System.Comparison&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="comparison"><see cref="T:System.Comparison`1" /> Do użycia podczas porównywania elementów.</param>
        <summary>Sortuje elementy w całości <see cref="T:System.Collections.Generic.List`1" /> przy użyciu określonego. <see cref="T:System.Comparison`1" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `comparison` jest podany, elementy <xref:System.Collections.Generic.List%601> elementu są sortowane przy użyciu metody reprezentowanej przez delegata.  
  
 Jeśli `comparison` jest `null` ,<xref:System.ArgumentNullException> jest zgłaszany.  
  
 Ta metoda używa <xref:System.Array.Sort%2A?displayProperty=nameWithType>metody, która stosuje sortowanie algorytmu w następujący sposób:  
  
-   Jeśli rozmiar partycji jest mniejszy niż 16 elementów, używa algorytmu sortowania wstawiania  
  
-   Jeśli liczba partycji przekracza 2 log *n*, gdzie *n* jest zakresem tablicy wejściowej, używa algorytmu [kopcowanie](https://en.wikipedia.org/wiki/Heapsort) .  
  
-   W przeciwnym razie używa algorytmu sortowania.  
  
 Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana. Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.  
  
 Średnio ta metoda jest operacją o (*n* log *n*), gdzie *n* <xref:System.Collections.Generic.List%601.Count%2A>to; w najgorszym przypadku jest to operacja o (*n*<sup>2</sup>).  
  
   
  
## Examples  
 Poniższy kod ilustruje <xref:System.Collections.Generic.List%601.Sort%2A> przeciążenia metody i <xref:System.Collections.Generic.List%601.Sort%2A> w prostym obiekcie biznesowym. Wywołanie metody powoduje użycie domyślnej funkcji porównującej dla typu części, <xref:System.Collections.Generic.List%601.Sort%2A> a metoda jest implementowana przy użyciu metody anonimowej. <xref:System.Collections.Generic.List%601.Sort%2A>  
  
 [!code-csharp[System.Collections.Generic.List.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.sort/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.sort/vb/module1.vb#1)]  
  
 Poniższy przykład ilustruje <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> Przeciążenie metody.  
  
 W przykładzie zdefiniowano alternatywną metodę porównania dla ciągów o `CompareDinosByLength`nazwie. Ta metoda działa w następujący sposób: Najpierw comparands są testowane dla `null`, a odwołanie o wartości null jest traktowane jako mniejsze niż wartość null. W drugim, długości ciągu są porównywane, a dłuższy ciąg jest uznawany za większy. Trzecia, jeśli długości są równe, używane jest zwykłe Porównywanie ciągów.  
  
 <xref:System.Collections.Generic.List%601> Ciąg jest tworzony i wypełniany czterema ciągami, w określonej kolejności. Lista zawiera również pusty ciąg i odwołanie o wartości null. Zostanie wyświetlona lista, posortowana przy użyciu <xref:System.Comparison%601> ogólnego delegata `CompareDinosByLength` reprezentującego metodę i ponownie wyświetlana.  
  
 [!code-cpp[List\`1_SortComparison#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortComparison/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortComparison#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortComparison/cs/source.cs#1)]
 [!code-vb[List\`1_SortComparison#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortComparison/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="comparison" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Implementacja <paramref name="comparison" /> spowodowała błąd podczas sortowania. Na przykład, <paramref name="comparison" /> program nie może zwrócić wartości 0 podczas porównywania elementu z samym sobą.</exception>
        <altmember cref="T:System.Comparison`1" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Wykonywanie niezależnych od kultury operacji na ciągach w kolekcjach</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort (int index, int count, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort(int32 index, int32 count, class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort (index As Integer, count As Integer, comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort(int index, int count, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="member this.Sort : int * int * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; unit" Usage="list.Sort (index, count, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="index">Początkowy indeks (liczony od zera) zakresu, który ma zostać posortowany.</param>
        <param name="count">Długość zakresu, który ma zostać posortowany.</param>
        <param name="comparer">Implementacja do użycia podczas porównywania elementów lub <see langword="null" /> używania domyślnego programu porównującego <see cref="P:System.Collections.Generic.Comparer`1.Default" />. <see cref="T:System.Collections.Generic.IComparer`1" /></param>
        <summary>Sortuje elementy w zakresie elementów <see cref="T:System.Collections.Generic.List`1" /> przy użyciu określonej funkcji porównującej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `comparer` jest podany, elementy <xref:System.Collections.Generic.List%601> elementu są sortowane przy użyciu określonej <xref:System.Collections.Generic.IComparer%601> implementacji.  
  
 Jeśli `comparer` jest `null`, domyślna funkcja porównująca <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> sprawdza, `T` czy typ <xref:System.IComparable%601> implementuje interfejs generyczny i używa tej implementacji, jeśli jest dostępny.  Jeśli nie, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> Sprawdź, czy `T` typ implementuje <xref:System.IComparable> interfejs.  Jeśli typ `T` nie implementuje żadnego interfejsu, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> zgłasza <xref:System.InvalidOperationException>.  
  
 Ta metoda używa <xref:System.Array.Sort%2A?displayProperty=nameWithType>metody, która stosuje sortowanie algorytmu w następujący sposób:  
  
-   Jeśli rozmiar partycji jest mniejszy niż 16 elementów, używa algorytmu sortowania wstawiania  
  
-   Jeśli liczba partycji przekracza 2 log *n*, gdzie *n* jest zakresem tablicy wejściowej, używa algorytmu [kopcowanie](https://en.wikipedia.org/wiki/Heapsort) .  
  
-   W przeciwnym razie używa algorytmu sortowania.  
  
 Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana. Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.  
  
 Średnio ta metoda jest operacją o (*n* log *n*), gdzie *n* <xref:System.Collections.Generic.List%601.Count%2A>to; w najgorszym przypadku jest to operacja o (*n*<sup>2</sup>).  
  
   
  
## Examples  
 Poniższy przykład ilustruje <xref:System.Collections.Generic.List%601.Sort%28System.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> Przeciążenie metody <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> i Przeciążenie metody.  
  
 W przykładzie zdefiniowano alternatywną funkcję porównującą dla ciągów o nazwie DinoCompare `IComparer<string>` ,`IComparer(Of String)` która implementuje interfejs `IComparer<String^>` ogólny ( C++w Visual Basic w języku Visual). Moduł porównujący działa w następujący sposób: Najpierw comparands są testowane dla `null`, a odwołanie o wartości null jest traktowane jako mniejsze niż wartość null. W drugim, długości ciągu są porównywane, a dłuższy ciąg jest uznawany za większy. Trzecia, jeśli długości są równe, używane jest zwykłe Porównywanie ciągów.  
  
 <xref:System.Collections.Generic.List%601> Jest tworzony i wypełniany przy użyciu nazw pięciu herbivorous dinozaurów i trzech dinozaurów carnivorous. W ramach każdej z tych dwóch grup nazwy nie są w żadnym konkretnym porządku sortowania. Zostanie wyświetlona lista, zakres herbivores jest sortowany przy użyciu alternatywnej funkcji porównującej, a lista zostanie ponownie wyświetlona.  
  
 Przeciążenie <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> metody jest następnie używane do przeszukiwania tylko zakresu herbivores dla "Brachiosaurus". Nie odnaleziono C# ciągu, a dopełnienie bitowe (operator ~ w i wizualizacja C++, `Xor` -1 w Visual Basic) liczby ujemnej zwracanej przez <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> metodę jest używany jako indeks do wstawiania nowego ciągu.  
  
 [!code-cpp[List\`1_SortSearchComparerRange#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparerRange#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparerRange#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparerRange/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />jest mniejsza niż 0.  
  
—lub— 
 <paramref name="count" />jest mniejsza niż 0.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" />i <paramref name="count" /> nie określaj prawidłowego zakresu <see cref="T:System.Collections.Generic.List`1" />w.  
  
—lub— 
Implementacja <paramref name="comparer" /> spowodowała błąd podczas sortowania. Na przykład, <paramref name="comparer" /> program nie może zwrócić wartości 0 podczas porównywania elementu z samym sobą.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" />jest <see langword="null" />, a domyślna funkcja porównująca <see cref="T:System.IComparable`1" /> <see cref="P:System.Collections.Generic.Comparer`1.Default" /> nie może znaleźć implementacji interfejsu generycznego lub <see cref="T:System.IComparable" /> interfejsu dla typu <paramref name="T" />.</exception>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Wykonywanie niezależnych od kultury operacji na ciągach w kolekcjach</related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#Generic#ICollection&lt;T&gt;#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements ICollection(Of T).IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::Generic::ICollection&lt;T&gt;::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy jest <see cref="T:System.Collections.Generic.ICollection`1" /> tylko do odczytu.</summary>
        <value><see langword="true" />Jeśli jest <see cref="T:System.Collections.Generic.ICollection`1" /> tylko do odczytu; <see langword="false" />w przeciwnym razie.  W domyślnej implementacji programu <see cref="T:System.Collections.Generic.List`1" />ta właściwość zawsze zwraca wartość. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W kolekcji tylko do odczytu po jej utworzeniu nie można dodawać, usuwać ani modyfikować elementów.  
  
 Kolekcja, która jest tylko do odczytu, jest po prostu zbiorem z otoką uniemożliwiającą zmianę kolekcji; w związku z tym, jeśli zmiany zostaną wprowadzone do podstawowej kolekcji, kolekcja tylko do odczytu uwzględni te zmiany.  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;!T&gt; System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#Generic#IEnumerable&lt;T&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of T) Implements IEnumerable(Of T).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;T&gt; ^ System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;T&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca moduł wyliczający, który dokonuje iteracji w kolekcji.</summary>
        <returns><see cref="T:System.Collections.Generic.IEnumerator`1" /> , Który może być używany do iteracji kolekcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `foreach` Instrukcja C# języka(`for each` C++w VisualBasic)ukrywazłożonośćmodułówwyliczających.`For Each` W związku z `foreach` tym zaleca się użycie zamiast bezpośredniego manipulowania modułem wyliczającym.  
  
 Moduły wyliczające mogą służyć do odczytu danych w kolekcji, ale nie można za ich pomocą modyfikować kolekcji źródłowej.  
  
 Początkowo moduł wyliczający jest umieszczony przed pierwszym elementem w kolekcji. W tym miejscu <xref:System.Collections.Generic.IEnumerator%601.Current%2A> właściwość jest niezdefiniowana. W związku z tym, należy <xref:System.Collections.IEnumerator.MoveNext%2A> wywołać metodę, aby wykonać przechodzenie modułu wyliczającego do pierwszego elementu kolekcji przed odczytem <xref:System.Collections.Generic.IEnumerator%601.Current%2A>wartości.  
  
 Właściwość zwraca ten sam obiekt, dopóki <xref:System.Collections.IEnumerator.MoveNext%2A> nie zostanie wywołana. <xref:System.Collections.Generic.IEnumerator%601.Current%2A> <xref:System.Collections.IEnumerator.MoveNext%2A>ustawia <xref:System.Collections.Generic.IEnumerator%601.Current%2A> do następnego elementu.  
  
 Jeśli <xref:System.Collections.IEnumerator.MoveNext%2A> przekazuje koniec kolekcji, moduł wyliczający jest umieszczony po ostatnim elemencie w kolekcji i <xref:System.Collections.IEnumerator.MoveNext%2A> zwraca `false`. Gdy moduł wyliczający znajduje się w tym miejscu, kolejne <xref:System.Collections.IEnumerator.MoveNext%2A> wywołania również `false`zwracają. Jeśli ostatnie wywołanie <xref:System.Collections.IEnumerator.MoveNext%2A> zwrócone `false`, <xref:System.Collections.Generic.IEnumerator%601.Current%2A> nie jest zdefiniowane. Nie można ponownie <xref:System.Collections.Generic.IEnumerator%601.Current%2A> ustawić na pierwszy element kolekcji; zamiast tego należy utworzyć nowe wystąpienie modułu wyliczającego.  
  
 Moduł wyliczający zachowuje ważność tak długo, jak długo kolekcja pozostaje niezmieniona. Jeśli w kolekcji zostaną wprowadzone zmiany, takie jak dodanie, zmodyfikowanie lub usunięcie elementów, moduł wyliczający jest nieodwracalnie unieważniony i następne wywołanie <xref:System.Collections.IEnumerator.MoveNext%2A> lub <xref:System.Collections.IEnumerator.Reset%2A> wygeneruje <xref:System.InvalidOperationException>.  
  
 Moduł wyliczający nie ma wyłącznego dostępu do kolekcji, w związku z tym wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość. Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania.  Aby zezwolić wielu wątkom na dostęp do kolekcji w celu odczytu i zapisu danych, należy zaimplementować własny mechanizm synchronizacji.  
  
 Domyślne implementacje kolekcji w <xref:System.Collections.Generic?displayProperty=nameWithType> przestrzeni nazw nie są zsynchronizowane.  
  
 Ta metoda jest operacją O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int arrayIndex) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Jednowymiarowy <see cref="T:System.Array" /> , który jest miejscem docelowym elementów skopiowanych z <see cref="T:System.Collections.ICollection" />. <see cref="T:System.Array" /> Musi mieć indeksowanie oparte na zero.</param>
        <param name="arrayIndex">Indeks (liczony od zera) <paramref name="array" /> , w którym rozpoczyna się kopiowanie.</param>
        <summary>Kopiuje elementy <see cref="T:System.Collections.ICollection" /> <see cref="T:System.Array" />do, zaczynając od określonego <see cref="T:System.Array" /> indeksu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Jeśli nie można automatycznie rzutować <xref:System.Collections.ICollection> typu źródła na typ docelowy `array`, nieogólne implementacje <xref:System.Collections.ICollection.CopyTo%2A?displayProperty=nameWithType> throw <xref:System.InvalidCastException>, podczas gdy są zgłaszane implementacje <xref:System.ArgumentException>ogólne.  
  
 Ta metoda jest operacją O (*n*), gdzie *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="arrayIndex" />jest mniejsza niż 0.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="array" />jest wielowymiarowych.  
  
—lub— 
 <paramref name="array" />nie ma indeksowania opartego na zero.  
  
—lub— 
Liczba elementów w źródle <see cref="T:System.Collections.ICollection" /> jest większa niż dostępne miejsce od <paramref name="arrayIndex" /> do końca miejsca docelowego <paramref name="array" />.  
  
—lub— 
Nie można automatycznie rzutować <see cref="T:System.Collections.ICollection" /> typu źródła na typ docelowy. <paramref name="array" /></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, <see cref="T:System.Collections.ICollection" /> czy dostęp do elementu jest synchronizowany (bezpieczny wątkowo).</summary>
        <value><see langword="true" />Jeśli dostęp do programu <see cref="T:System.Collections.ICollection" /> jest synchronizowany (wątek bezpieczny); <see langword="false" />w przeciwnym razie.  W domyślnej implementacji programu <see cref="T:System.Collections.Generic.List`1" />ta właściwość zawsze zwraca wartość. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślne implementacje kolekcji w <xref:System.Collections.Generic?displayProperty=nameWithType> przestrzeni nazw nie są zsynchronizowane.  
  
 Wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość.  W rzadkich przypadkach, gdy Wyliczenie jest zgodne z dostępem do zapisu, można zablokować kolekcję podczas całego wyliczania.  Aby zezwolić wielu wątkom na dostęp do kolekcji w celu odczytu i zapisu danych, należy zaimplementować własny mechanizm synchronizacji.  
  
 <xref:System.Collections.ICollection.SyncRoot%2A>zwraca obiekt, który może służyć do synchronizowania dostępu do <xref:System.Collections.ICollection>elementu. Synchronizacja jest skuteczna tylko wtedy, gdy wszystkie wątki blokują ten obiekt przed uzyskaniem dostępu do kolekcji.  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Generic.List`1.System#Collections#ICollection#SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera obiekt, który może służyć do synchronizowania dostępu do <see cref="T:System.Collections.ICollection" />.</summary>
        <value>Obiekt, który może służyć do synchronizowania dostępu do <see cref="T:System.Collections.ICollection" />.  W domyślnej implementacji programu <see cref="T:System.Collections.Generic.List`1" />ta właściwość zawsze zwraca bieżące wystąpienie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślne implementacje kolekcji w <xref:System.Collections.Generic?displayProperty=nameWithType> przestrzeni nazw nie są zsynchronizowane.  
  
 Wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość.  Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania.  Aby zezwolić wielu wątkom na dostęp do kolekcji w celu odczytu i zapisu danych, należy zaimplementować własny mechanizm synchronizacji.  
  
 <xref:System.Collections.ICollection.SyncRoot%2A>zwraca obiekt, który może służyć do synchronizowania dostępu do <xref:System.Collections.ICollection>elementu. Synchronizacja jest skuteczna tylko wtedy, gdy wszystkie wątki blokują ten obiekt przed uzyskaniem dostępu do kolekcji. Poniższy kod przedstawia użycie <xref:System.Collections.ICollection.SyncRoot%2A> właściwości dla C#, C++i Visual Basic.  
  
```csharp  
ICollection ic = ...;  
lock (ic.SyncRoot)   
{  
    // Access the collection.  
}  
```  
  
```vb  
Dim ic As ICollection = ...  
SyncLock ic.SyncRoot  
    ' Access the collection.  
End SyncLock  
```  
  
```cpp#  
ICollection^ ic = ...;  
try   
{  
    Monitor::Enter(ic->SyncRoot);  
    // Access the collection.  
}  
finally   
{  
    Monitor::Exit(ic->SyncRoot);  
}  
```  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Generic.List`1.System#Collections#ICollection#IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca moduł wyliczający, który dokonuje iteracji w kolekcji.</summary>
        <returns><see cref="T:System.Collections.IEnumerator" /> , Który może być używany do iteracji kolekcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `foreach` Instrukcja C# języka(`for each` C++w VisualBasic)ukrywazłożonośćmodułówwyliczających.`For Each` W związku z `foreach` tym zaleca się użycie zamiast bezpośredniego manipulowania modułem wyliczającym.  
  
 Moduły wyliczające mogą służyć do odczytu danych w kolekcji, ale nie można za ich pomocą modyfikować kolekcji źródłowej.  
  
 Początkowo moduł wyliczający jest umieszczony przed pierwszym elementem w kolekcji. <xref:System.Collections.IEnumerator.Reset%2A>przywraca również moduł wyliczający z powrotem do tego położenia.  W tym miejscu <xref:System.Collections.IEnumerator.Current%2A> właściwość jest niezdefiniowana. W związku z tym, należy <xref:System.Collections.IEnumerator.MoveNext%2A> wywołać metodę, aby wykonać przechodzenie modułu wyliczającego do pierwszego elementu kolekcji przed odczytem <xref:System.Collections.IEnumerator.Current%2A>wartości.  
  
 Właściwość zwraca ten sam obiekt <xref:System.Collections.IEnumerator.MoveNext%2A> do momentu wywołania <xref:System.Collections.IEnumerator.Reset%2A>lub. <xref:System.Collections.IEnumerator.Current%2A> <xref:System.Collections.IEnumerator.MoveNext%2A>ustawia <xref:System.Collections.IEnumerator.Current%2A> do następnego elementu.  
  
 Jeśli <xref:System.Collections.IEnumerator.MoveNext%2A> przekazuje koniec kolekcji, moduł wyliczający jest umieszczony po ostatnim elemencie w kolekcji i <xref:System.Collections.IEnumerator.MoveNext%2A> zwraca `false`. Gdy moduł wyliczający znajduje się w tym miejscu, kolejne <xref:System.Collections.IEnumerator.MoveNext%2A> wywołania również `false`zwracają. Jeśli ostatnie wywołanie <xref:System.Collections.IEnumerator.MoveNext%2A> zwrócone `false`, <xref:System.Collections.IEnumerator.Current%2A> nie jest zdefiniowane. Aby ponownie <xref:System.Collections.IEnumerator.Current%2A> ustawić na pierwszy element kolekcji, możesz wywołać metodę <xref:System.Collections.IEnumerator.Reset%2A> i <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Moduł wyliczający zachowuje ważność tak długo, jak długo kolekcja pozostaje niezmieniona. Jeśli w kolekcji zostaną wprowadzone zmiany, takie jak dodanie, zmodyfikowanie lub usunięcie elementów, moduł wyliczający jest nieodwracalnie unieważniony i następne wywołanie <xref:System.Collections.IEnumerator.MoveNext%2A> lub <xref:System.Collections.IEnumerator.Reset%2A> wygeneruje <xref:System.InvalidOperationException>.  
  
 Moduł wyliczający nie ma wyłącznego dostępu do kolekcji, w związku z tym wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość.  Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania.  Aby zezwolić wielu wątkom na dostęp do kolekcji w celu odczytu i zapisu danych, należy zaimplementować własny mechanizm synchronizacji.  
  
 Domyślne implementacje kolekcji w <xref:System.Collections.Generic?displayProperty=nameWithType> przestrzeni nazw nie są zsynchronizowane.  
  
 Ta metoda jest operacją O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Add">
      <MemberSignature Language="C#" Value="int IList.Add (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.Add(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Add (item As Object) As Integer Implements IList.Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.Add(System::Object ^ item) = System::Collections::IList::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Add(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">, <see cref="T:System.Object" /> Aby dodać <see cref="T:System.Collections.IList" />do.</param>
        <summary>Dodaje element do <see cref="T:System.Collections.IList" />elementu.</summary>
        <returns>Położenie, do którego wstawiono nowy element.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Collections.Generic.List%601.Count%2A> jest mniejsza niż <xref:System.Collections.Generic.List%601.Capacity%2A>, ta metoda jest operacją o (1). Jeśli pojemność musi zostać zwiększona w celu uwzględnienia nowego elementu, ta metoda będzie operacją O (*n*), gdzie *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="item" />jest typu, którego nie można przypisać do <see cref="T:System.Collections.IList" />elementu.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Contains">
      <MemberSignature Language="C#" Value="bool IList.Contains (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IList.Contains(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Contains (item As Object) As Boolean Implements IList.Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IList.Contains(System::Object ^ item) = System::Collections::IList::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item"><see cref="T:System.Object" /> Aby zlokalizować <see cref="T:System.Collections.IList" />w.</param>
        <summary>Określa, <see cref="T:System.Collections.IList" /> czy zawiera konkretną wartość.</summary>
        <returns><see langword="true" />Jeśli <paramref name="item" /> znajduje się <see cref="T:System.Collections.IList" />w; w przeciwnym razie <see langword="false" />,.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda określa równość przy użyciu domyślnej funkcji <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> porównującej `T`równość dla, typu wartości na liście.  
  
 Ta metoda przeprowadza wyszukiwanie liniowe; w związku z tym ta metoda jest operacją O (*n*) ** , gdzie <xref:System.Collections.Generic.List%601.Count%2A>n jest.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IndexOf">
      <MemberSignature Language="C#" Value="int IList.IndexOf (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.IndexOf(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#IndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function IndexOf (item As Object) As Integer Implements IList.IndexOf" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.IndexOf(System::Object ^ item) = System::Collections::IList::IndexOf;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.IndexOf(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">Obiekt, który ma zostać zlokalizowany w <see cref="T:System.Collections.IList" />.</param>
        <summary>Określa indeks określonego elementu w <see cref="T:System.Collections.IList" />.</summary>
        <returns>Indeks elementu <paramref name="item" /> if znajduje się na liście; w przeciwnym razie-1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda określa równość przy użyciu domyślnej funkcji <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> porównującej `T`równość dla, typu wartości na liście.  
  
 Ta metoda przeprowadza wyszukiwanie liniowe; w związku z tym ta metoda jest operacją O (*n*) ** , gdzie <xref:System.Collections.Generic.List%601.Count%2A>n jest.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="item" />jest typu, którego nie można przypisać do <see cref="T:System.Collections.IList" />elementu.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Insert">
      <MemberSignature Language="C#" Value="void IList.Insert (int index, object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Insert(int32 index, object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Insert (index As Integer, item As Object) Implements IList.Insert" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Insert(int index, System::Object ^ item) = System::Collections::IList::Insert;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Insert(System.Int32,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">Indeks (liczony od zera), <paramref name="item" /> który powinien zostać wstawiony.</param>
        <param name="item">Obiekt, który ma zostać wstawiony <see cref="T:System.Collections.IList" />do.</param>
        <summary>Wstawia element do <see cref="T:System.Collections.IList" /> obiektu o określonym indeksie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `index` jest równa liczbie elementów <xref:System.Collections.IList>w, `item` jest dołączany na końcu.  
  
 Ta metoda jest operacją O (*n*), gdzie *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />nie jest prawidłowym indeksem w <see cref="T:System.Collections.IList" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="item" />jest typu, którego nie można przypisać do <see cref="T:System.Collections.IList" />elementu.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#IList#IsFixedSize" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFixedSize As Boolean Implements IList.IsFixedSize" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IList::IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, <see cref="T:System.Collections.IList" /> czy ma stały rozmiar.</summary>
        <value><see langword="true" />Jeśli ma stały rozmiar; <see langword="false" />w przeciwnym razie. <see cref="T:System.Collections.IList" />  W domyślnej implementacji programu <see cref="T:System.Collections.Generic.List`1" />ta właściwość zawsze zwraca wartość. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W kolekcji o stałym rozmiarze po jej utworzeniu nie można dodawać ani usuwać elementów, jednak można modyfikować istniejące elementy.  
  
 Kolekcja o stałym rozmiarze jest po prostu kolekcją z otoką, która zapobiega dodawaniu i usuwaniu elementów; w związku z tym, jeśli wprowadzono zmiany do źródłowej kolekcji, w tym dodawanie lub usuwanie elementów, kolekcja o stałym rozmiarze odzwierciedla te zmiany.  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#IList#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements IList.IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IList::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy jest <see cref="T:System.Collections.IList" /> tylko do odczytu.</summary>
        <value><see langword="true" />Jeśli jest <see cref="T:System.Collections.IList" /> tylko do odczytu; <see langword="false" />w przeciwnym razie.  W domyślnej implementacji programu <see cref="T:System.Collections.Generic.List`1" />ta właściwość zawsze zwraca wartość. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W kolekcji tylko do odczytu po jej utworzeniu nie można dodawać, usuwać ani modyfikować elementów.  
  
 Kolekcja, która jest tylko do odczytu, jest po prostu zbiorem z otoką uniemożliwiającą zmianę kolekcji; w związku z tym, jeśli zmiany zostaną wprowadzone do podstawowej kolekcji, kolekcja tylko do odczytu uwzględni te zmiany.  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IList.Item[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IList.Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#IList#Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" Property Item(index As Integer) As Object Implements IList.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::IList::Item[int] { System::Object ^ get(int index); void set(int index, System::Object ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Liczony od zera indeks elementu, który ma zostać pobrany lub skonfigurowany.</param>
        <summary>Pobieranie lub konfigurowanie elementów pod określonym indeksem.</summary>
        <value>Element pod określonym indeksem.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Język używa [tego](~/docs/csharp/language-reference/keywords/this.md) słowa kluczowego, aby zdefiniować indeksatory zamiast implementowania <xref:System.Collections.Generic.List%601.System%23Collections%23IList%23Item%2A> właściwości. C# Visual Basic implementuje <xref:System.Collections.Generic.List%601.System%23Collections%23IList%23Item%2A> jako właściwość domyślną, która zapewnia te same funkcje indeksowania.  
  
 Pobieranie wartości tej właściwości jest operacją O (1); ustawienie właściwości jest również operacją O (1).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />nie jest prawidłowym indeksem w <see cref="T:System.Collections.IList" />.</exception>
        <exception cref="T:System.ArgumentException">Właściwość jest ustawiona i <paramref name="value" /> jest typu, którego nie <see cref="T:System.Collections.IList" />można przypisać do elementu.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Remove">
      <MemberSignature Language="C#" Value="void IList.Remove (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Remove(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Remove (item As Object) Implements IList.Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Remove(System::Object ^ item) = System::Collections::IList::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">Obiekt, który ma zostać usunięty <see cref="T:System.Collections.IList" />z.</param>
        <summary>Usuwa pierwsze wystąpienie określonego obiektu z <see cref="T:System.Collections.IList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda określa równość przy użyciu domyślnej funkcji <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> porównującej `T`równość dla, typu wartości na liście.  
  
 Ta metoda przeprowadza wyszukiwanie liniowe; w związku z tym ta metoda jest operacją O (*n*) ** , gdzie <xref:System.Collections.Generic.List%601.Count%2A>n jest.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="item" />jest typu, którego nie można przypisać do <see cref="T:System.Collections.IList" />elementu.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public T[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T[] ToArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.ToArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToArray () As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;T&gt; ^ ToArray();" />
      <MemberSignature Language="F#" Value="member this.ToArray : unit -&gt; 'T[]" Usage="list.ToArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Kopiuje elementy <see cref="T:System.Collections.Generic.List`1" /> do nowej tablicy.</summary>
        <returns>Tablica zawierająca kopie elementów <see cref="T:System.Collections.Generic.List`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Elementy są kopiowane przy użyciu <xref:System.Array.Copy%2A?displayProperty=nameWithType>, która jest operacją o (*n*), gdzie *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 Ta metoda jest operacją O (*n*), gdzie *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Poniższy przykład ilustruje <xref:System.Collections.Generic.List%601.ToArray%2A> metodę i inne metody <xref:System.Collections.Generic.List%601> klasy, które działają na zakresach. Na końcu przykładu <xref:System.Collections.Generic.List%601.GetRange%2A> Metoda jest używana do uzyskania trzech elementów z listy, rozpoczynając od lokalizacji indeksu 2. Metoda jest wywoływana na skutek <xref:System.Collections.Generic.List%601>, tworząc tablicę trzech elementów. <xref:System.Collections.Generic.List%601.ToArray%2A> Wyświetlane są elementy tablicy.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimExcess">
      <MemberSignature Language="C#" Value="public void TrimExcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TrimExcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.TrimExcess" />
      <MemberSignature Language="VB.NET" Value="Public Sub TrimExcess ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TrimExcess();" />
      <MemberSignature Language="F#" Value="member this.TrimExcess : unit -&gt; unit" Usage="list.TrimExcess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ustawia pojemność na rzeczywistą liczbę elementów w <see cref="T:System.Collections.Generic.List`1" />, jeśli ta liczba jest mniejsza niż wartość progowa.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tej metody można użyć do zminimalizowania obciążenia pamięci kolekcji, jeśli do kolekcji nie zostaną dodane żadne nowe elementy. Koszt ponownej alokacji i kopiowania dużego <xref:System.Collections.Generic.List%601> może być istotny, <xref:System.Collections.Generic.List%601.TrimExcess%2A> Dlatego metoda nie robi nic, jeśli lista ma więcej niż 90% pojemności. Pozwala to uniknąć ponoszenia dużego kosztu ponownego alokacji dla stosunkowo małego wzmocnienia.  
  
> [!NOTE]
>  Bieżący próg 90 procent może ulec zmianie w przyszłych wydaniach.  
  
 Ta metoda jest operacją O (*n*), gdzie *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 Aby zresetować <xref:System.Collections.Generic.List%601> do stanu początkowego, należy <xref:System.Collections.Generic.List%601.Clear%2A> wywołać metodę przed wywołaniem <xref:System.Collections.Generic.List%601.TrimExcess%2A> metody. Przycinanie pustego <xref:System.Collections.Generic.List%601> zestawu ustawia pojemność <xref:System.Collections.Generic.List%601> do pojemności domyślnej.  
  
 Wydajność można również ustawić przy użyciu <xref:System.Collections.Generic.List%601.Capacity%2A> właściwości.  
  
   
  
## Examples  

 [!INCLUDE[interactive-note](~/includes/csharp-interactive-note-some.md)]

 Poniższy przykład ilustruje sposób sprawdzania pojemności i liczby <xref:System.Collections.Generic.List%601> , która zawiera prosty obiekt biznesowy, i ilustruje <xref:System.Collections.Generic.List%601.TrimExcess%2A> użycie metody w celu usunięcia dodatkowej pojemności.  
  
 [!code-csharp[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/vb/module1.vb#1)]  
  
 Poniższy przykład demonstruje <xref:System.Collections.Generic.List%601.TrimExcess%2A> metodę. Kilka właściwości i metod <xref:System.Collections.Generic.List%601> klasy służy do dodawania, wstawiania i usuwania elementów z listy ciągów. Następnie metoda jest używana w celu zredukowania pojemności do liczby, <xref:System.Collections.Generic.List%601.Capacity%2A> a są wyświetlane właściwości i <xref:System.Collections.Generic.List%601.Count%2A>. <xref:System.Collections.Generic.List%601.TrimExcess%2A> Jeśli niewykorzystana pojemność była mniejsza niż 10 procent całkowitej pojemności, nie można zmienić rozmiaru listy. Na koniec zawartość listy jest czyszczona.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp-interactive[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.Clear" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="TrueForAll">
      <MemberSignature Language="C#" Value="public bool TrueForAll (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TrueForAll(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function TrueForAll (match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TrueForAll(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.TrueForAll : Predicate&lt;'T&gt; -&gt; bool" Usage="list.TrueForAll match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match"><see cref="T:System.Predicate`1" /> Delegat, który definiuje warunki do sprawdzenia względem elementów.</param>
        <summary>Określa, czy każdy element w <see cref="T:System.Collections.Generic.List`1" /> jest zgodny z warunkami zdefiniowanymi przez określony predykat.</summary>
        <returns><see langword="true" />Jeśli każdy element w jest <see cref="T:System.Collections.Generic.List`1" /> zgodny z warunkami zdefiniowanymi przez określony predykat; w przeciwnym <see langword="false" />razie,. Jeśli lista nie zawiera żadnych elementów, wartość zwracana to <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest delegatem metody, która zwraca `true` , jeśli obiekt przeszedł do niego, odpowiada warunkom zdefiniowanym w obiekcie delegowanym. <xref:System.Predicate%601>  Elementy bieżącego <xref:System.Collections.Generic.List%601> są indywidualnie przesyłane <xref:System.Predicate%601> do delegata, a przetwarzanie jest przerywane, gdy delegat zwraca `false` dla dowolnego elementu. Elementy są przetwarzane w kolejności, a wszystkie wywołania są wykonywane na pojedynczym wątku.  
  
 Ta metoda jest operacją O (*n*), gdzie *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Poniższy przykład ilustruje <xref:System.Collections.Generic.List%601.TrueForAll%2A> metodę i kilka innych metod, które używają <xref:System.Predicate%601> delegata ogólnego.  
  
 Tworzony jest ciąg z 8. nazwami, z których dwa są (w pozycjach 1 i 5) kończą się znakiem "saurus". <xref:System.Collections.Generic.List%601> W przykładzie zdefiniowano także metodę predykatu wyszukiwania `EndsWithSaurus`o nazwie, która akceptuje parametr String i zwraca wartość logiczną wskazującą, czy ciąg wejściowy jest kończący się na "saurus".  
  
 Metoda przechodzi na listę od początku, przekazując każdy element z kolei `EndsWithSaurus` do metody. <xref:System.Collections.Generic.List%601.TrueForAll%2A> Wyszukiwanie jest zatrzymywane, `EndsWithSaurus` gdy metoda `false`zwraca.  
  
> [!NOTE]
>  W C# i Visual Basic nie jest konieczne jawne utworzenie `Predicate<string>` delegata (`Predicate(Of String)` w Visual Basic). Te języki wnioskują o poprawnym delegacie z kontekstu, a następnie są tworzone automatycznie.  
  
 [!code-cpp[List\`1_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[List\`1_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_FindEtAl/cs/source.cs#1)]
 [!code-vb[List\`1_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" />jest <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
  </Members>
</Type>

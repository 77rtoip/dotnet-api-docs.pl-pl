<Type Name="List&lt;T&gt;" FullName="System.Collections.Generic.List&lt;T&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="5035684f29f82639926fd626a0bd3d07d7928ac0" /><Meta Name="ms.sourcegitcommit" Value="b0551d7828f015124aca601dbb64bd913cc5067d" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="12/13/2018" /><Meta Name="ms.locfileid" Value="53334733" /></Metadata><TypeSignature Language="C#" Value="public class List&lt;T&gt; : System.Collections.Generic.ICollection&lt;T&gt;, System.Collections.Generic.IEnumerable&lt;T&gt;, System.Collections.Generic.IList&lt;T&gt;, System.Collections.Generic.IReadOnlyCollection&lt;T&gt;, System.Collections.Generic.IReadOnlyList&lt;T&gt;, System.Collections.IList" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit List`1&lt;T&gt; extends System.Object implements class System.Collections.Generic.ICollection`1&lt;!T&gt;, class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.Generic.IList`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyList`1&lt;!T&gt;, class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Generic.List`1" />
  <TypeSignature Language="VB.NET" Value="Public Class List(Of T)&#xA;Implements ICollection(Of T), IEnumerable(Of T), IList, IList(Of T), IReadOnlyCollection(Of T), IReadOnlyList(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class List : System::Collections::Generic::ICollection&lt;T&gt;, System::Collections::Generic::IEnumerable&lt;T&gt;, System::Collections::Generic::IList&lt;T&gt;, System::Collections::Generic::IReadOnlyCollection&lt;T&gt;, System::Collections::Generic::IReadOnlyList&lt;T&gt;, System::Collections::IList" />
  <TypeSignature Language="F#" Value="type List&lt;'T&gt; = class&#xA;    interface IList&lt;'T&gt;&#xA;    interface IList&#xA;    interface IReadOnlyList&lt;'T&gt;&#xA;    interface ICollection&lt;'T&gt;&#xA;    interface seq&lt;'T&gt;&#xA;    interface IEnumerable&#xA;    interface ICollection&#xA;    interface IReadOnlyCollection&lt;'T&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Collections</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IList&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyList&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.Mscorlib_CollectionDebugView`1))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">Typ elementów na liście.</typeparam>
    <summary>Reprezentuje silnie typizowaną listę obiektów, które mogą być udostępniane przez indeks. Udostępnia metody, aby wyszukiwać, sortować i manipulować listy.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> Klasa jest ogólny odpowiednik <xref:System.Collections.ArrayList> klasy. Implementuje <xref:System.Collections.Generic.IList%601> wymagany interfejs ogólny przy użyciu tablicy, której rozmiar jest dynamicznie zwiększany w miarę.  
  
 Można dodać elementy do <xref:System.Collections.Generic.List%601> przy użyciu <xref:System.Collections.Generic.List%601.Add%2A> lub <xref:System.Collections.Generic.List%601.AddRange%2A> metody.  
  
 <xref:System.Collections.Generic.List%601> Klasa używa moduł porównujący równość i szeregowania porównania.  
  
-   Metody takie jak <xref:System.Collections.Generic.List%601.Contains%2A>, <xref:System.Collections.Generic.List%601.IndexOf%2A>, <xref:System.Collections.Generic.List%601.LastIndexOf%2A>, i <xref:System.Collections.Generic.Dictionary%602.Remove%2A> moduł porównujący równość na użytek elementów listy. Domyślny moduł porównujący równość typu `T` jest określany w następujący sposób. Jeśli typ `T` implementuje <xref:System.IEquatable%601> ogólny interfejs, a następnie moduł porównujący równość jest <xref:System.IEquatable%601.Equals%28%600%29> metody tego interfejsu; w przeciwnym razie jest domyślny moduł porównujący równość <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>.  
  
-   Metody takie jak <xref:System.Collections.Generic.List%601.BinarySearch%2A> i <xref:System.Collections.Generic.List%601.Sort%2A> Użyj szeregowania moduł porównujący dla elementów listy. Domyślny moduł porównujący dla typu `T` jest określany w następujący sposób.  Jeśli typ `T` implementuje <xref:System.IComparable%601> jest ogólny interfejs, a następnie domyślny moduł porównujący <xref:System.IComparable%601.CompareTo%28%600%29> metody tego interfejsu; w przeciwnym razie, jeśli typ `T` implementuje nongeneric <xref:System.IComparable> interfejsu, a następnie wartość domyślna Moduł porównujący jest <xref:System.IComparable.CompareTo%28System.Object%29> metody tego interfejsu. Jeśli typ `T` implementuje ani interfejsu, a nie ma żadnych domyślny moduł porównujący, delegat modułu porównującego lub porównywania należy podać jawne.  
  
 <xref:System.Collections.Generic.List%601> Nie jest gwarantowana ma zostać posortowana.  Możesz sortować <xref:System.Collections.Generic.List%601> przed wykonaniem operacji (takich jak <xref:System.Collections.Generic.List%601.BinarySearch%2A>), które wymagają <xref:System.Collections.Generic.List%601> ma zostać posortowana.  
  
 Elementy w tej kolekcji są dostępne przy użyciu indeksu liczba całkowita.  Indeksy w tej kolekcji są oparte na zerze.  
  
 Dla bardzo dużych <xref:System.Collections.Generic.List%601> obiektów, zwiększenia maksymalnej pojemności do 2 miliardów elementów w systemie 64-bitowych, ustawiając `enabled` atrybutu tego elementu konfiguracji `true` w środowisku uruchomieniowym.  
  
 <xref:System.Collections.Generic.List%601> akceptuje `null` prawidłową wartość dla odwołania do typów i pozwala zduplikowane elementy.  
  
 Niezmienne wersję <xref:System.Collections.Generic.List%601> klasy, zobacz <xref:System.Collections.Immutable.ImmutableList%601>.  
  
## <a name="performance-considerations"></a>Zagadnienia dotyczące wydajności  
 Przy podejmowaniu decyzji, czy ma być używany <xref:System.Collections.Generic.List%601> lub <xref:System.Collections.ArrayList> klasy, które mają podobne funkcje, należy pamiętać, że <xref:System.Collections.Generic.List%601> klasa działa lepiej w większości przypadków i jest bezpiecznego typu. Jeśli typ odwołania jest używana dla typu `T` z <xref:System.Collections.Generic.List%601> klasy, zachowaniem dwóch klas jest identyczna. Jednakże jeśli typ wartości jest używany dla typu `T`, należy wziąć pod uwagę implementacji i pakowania problemów.  
  
 Jeśli typ wartości jest używany dla typu `T`, kompilator generuje implementację <xref:System.Collections.Generic.List%601> klasy specjalnie dla tego typu wartości. Oznacza to, że element listy <xref:System.Collections.Generic.List%601> obiekt nie ma zostać opakowany przed element może być używany, a po utworzeniu około 500 elementów listy pamięci zapisane, opakowywanie nie elementów listy jest większy niż pamięć używana do generowania Implementacja klasy.  
  
 Należy upewnić się, typ wartości dla typu `T` implementuje <xref:System.IEquatable%601> interfejs generyczny. Jeśli nie, metody, takie jak <xref:System.Collections.Generic.List%601.Contains%2A> musi wywołać <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> metody, która pola elementu dotyczy list. Jeśli typ wartości implementuje <xref:System.IComparable> interfejsu i właścicielem kodu źródłowego, również implementują <xref:System.IComparable%601> interfejs ogólny, aby zapobiec <xref:System.Collections.Generic.List%601.BinarySearch%2A> i <xref:System.Collections.Generic.List%601.Sort%2A> metody z konwersja boxing elementów listy. Jeśli nie jesteś właścicielem kodu źródłowego, przekazać <xref:System.Collections.Generic.IComparer%601> obiekt <xref:System.Collections.Generic.List%601.BinarySearch%2A> i <xref:System.Collections.Generic.List%601.Sort%2A> metody  
  
 Jest się używać implementacji specyficznych dla typu <xref:System.Collections.Generic.List%601> klasy zamiast <xref:System.Collections.ArrayList> klasy lub napisanie kolekcję silnie typizowaną otokę. Przyczyną jest implementacji należy wykonać co programu .NET Framework jest dla Ciebie już i środowisko uruchomieniowe języka wspólnego może współużytkować kod języka pośredniego firmy Microsoft i metadanych, które nie implementacji.  
  
## <a name="f-considerations"></a>F#Zagadnienia dotyczące  
 <xref:System.Collections.Generic.List%601> Klasa jest używana rzadko w F# kodu.  Zamiast tego [Wyświetla](https://msdn.microsoft.com/library/83102799-f251-42e1-93ef-64232e8c5b1d), które są niezmienne, pojedynczo połączoną list, są zazwyczaj preferowane. F# Lista zawiera uporządkowany i niezmienne serii wartości i jest przeznaczony do użytku w rozwoju w stylu funkcjonalności. W przypadku używania z F#, <xref:System.Collections.Generic.List%601> klasy jest zwykle określany przez [ResizeArray\<'T >](https://msdn.microsoft.com/library/ee353447.aspx) — typ skrótu, aby uniknąć konfliktu nazw z F# listy  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak dodawanie, usuwanie i wstawianie obiektu proste biznesowych w <xref:System.Collections.Generic.List%601>.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 W poniższym przykładzie pokazano kilka właściwości i metod <xref:System.Collections.Generic.List%601> klasy ogólnej typu String. (Na przykład <xref:System.Collections.Generic.List%601> złożonych typów, zobacz <xref:System.Collections.Generic.List%601.Contains%2A> metody.)  
  
 Domyślny konstruktor jest używany do tworzenia listy ciągów przy użyciu domyślnej pojemności. <xref:System.Collections.Generic.List%601.Capacity%2A> Właściwość jest wyświetlana i następnie <xref:System.Collections.Generic.List%601.Add%2A> metoda służy do dodawania wielu elementów. Elementy są wyświetlane i <xref:System.Collections.Generic.List%601.Capacity%2A> właściwość jest wyświetlana, wraz z <xref:System.Collections.Generic.List%601.Count%2A> właściwości, aby pokazać, że pojemność została zwiększona, zgodnie z potrzebami.  
  
 <xref:System.Collections.Generic.List%601.Contains%2A> Metoda służy do testowania obecności elementu na liście <xref:System.Collections.Generic.List%601.Insert%2A> metoda służy do wstawiania nowego elementu w środku listy i ponownie jest wyświetlana zawartość listy.  
  
 Wartość domyślna <xref:System.Collections.Generic.List%601.Item%2A> (indeksatora w języku C#) jest używana do pobierania elementu <xref:System.Collections.Generic.List%601.Remove%2A> metoda jest używana do usunięcia pierwszego wystąpienia zduplikowany element dodano wcześniej i ponownie wyświetlana zawartość. <xref:System.Collections.Generic.List%601.Remove%2A> Metoda zawsze usuwa pierwsze wystąpienie napotka.  
  
 <xref:System.Collections.Generic.List%601.TrimExcess%2A> Metoda jest używana do zmniejszenia pojemności do dopasowania liczby, a <xref:System.Collections.Generic.List%601.Capacity%2A> i <xref:System.Collections.Generic.List%601.Count%2A> właściwości są wyświetlane. Jeśli nieużywaną pojemność była mniejsza niż 10 procent całkowitej wydajności, lista czy nie został zmieniony.  
  
 Na koniec <xref:System.Collections.Generic.List%601.Clear%2A> metoda jest używana, aby usunąć wszystkie elementy z listy, a <xref:System.Collections.Generic.List%601.Capacity%2A> i <xref:System.Collections.Generic.List%601.Count%2A> właściwości są wyświetlane.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
    </remarks>
    <threadsafe>Publiczne statyczne (<see langword="Shared" /> w języku Visual Basic) elementy członkowskie tego typu są bezpieczne dla wątków. Wystąpienia elementów członkowskich nie dają gwarancji bezpieczeństwa wątków.  
  
Można bezpiecznie wykonać wiele operacji odczytu na <see cref="T:System.Collections.Generic.List`1" />, ale problemy mogą wystąpić, jeśli kolekcja jest modyfikowana podczas jej odczytywania. Aby zapewnić bezpieczeństwo wątków, należy zablokować kolekcję podczas odczytu lub zapisu operacji. Aby włączyć kolekcję, aby uzyskiwał dostęp do wielu wątków do odczytu i zapisu, należy zaimplementować własny mechanizm synchronizacji. W przypadku kolekcji z wbudowanych synchronizacji, zawiera opis klas w <see cref="N:System.Collections.Concurrent" /> przestrzeni nazw. Aby zamiast natury metodą o bezpiecznych wątkach, zobacz <see cref="T:System.Collections.Immutable.ImmutableList`1" /> klasy.</threadsafe>
    <altmember cref="T:System.Collections.IList" />
    <altmember cref="T:System.Collections.Immutable.ImmutableList`1" />
    <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Wykonywanie niezależnych od kultury operacji na ciągach w kolekcjach</related>
    <related type="Article" href="https://msdn.microsoft.com/library/f45331db-d595-46ec-9142-551d3d1eb1a7">Iteratory (C# i Visual Basic)</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Collections.Generic.List`1" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public List ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; List();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Collections.Generic.List`1" /> klasę, która jest pusta i ma pojemność domyślna.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pojemność <xref:System.Collections.Generic.List%601> jest liczba elementów, <xref:System.Collections.Generic.List%601> może przechowywać. Gdy elementy są dodawane do <xref:System.Collections.Generic.List%601>, pojemność jest automatycznie zwiększana zgodnie z wymaganiami relokacja wewnętrznego tablicy.  
  
 Jeśli rozmiar kolekcji można oszacować, za pomocą <xref:System.Collections.Generic.List%601.%23ctor%28System.Int32%29> Konstruktor i określając pojemność eliminuje konieczność wykonania wielu operacji zmiany rozmiaru podczas dodawania elementów do <xref:System.Collections.Generic.List%601>.  
  
 Można zmniejszyć pojemność przez wywołanie metody <xref:System.Collections.Generic.List%601.TrimExcess%2A> metody lub przez ustawienie <xref:System.Collections.Generic.List%601.Capacity%2A> właściwość jawnie. Zmniejsza pojemność przydzieli pamięci, a następnie kopiuje wszystkie elementy w <xref:System.Collections.Generic.List%601>.  
  
 Ten konstruktor jest operacją O(1).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano domyślny konstruktor obiektu <xref:System.Collections.Generic.List%601> klasy ogólnej. Domyślny konstruktor tworzy listę pojemność domyślna, jak pokazano, wyświetlając <xref:System.Collections.Generic.List%601.Capacity%2A> właściwości.  
  
 Przykład dodaje wstawia i usuwa elementy, pokazujący, jak wydajność zmienia się te metody są używane.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public List (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.#ctor(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; List(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.List&lt;'T&gt; : seq&lt;'T&gt; -&gt; System.Collections.Generic.List&lt;'T&gt;" Usage="new System.Collections.Generic.List&lt;'T&gt; collection" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">Kolekcja, której elementy są kopiowane do nowej listy.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Collections.Generic.List`1" /> skopiowane klasę, która zawiera elementy kopiowane z określonej kolekcji i ma wystarczającej wydajności, aby obsłużyć liczbę elementów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Elementy są kopiowane na <xref:System.Collections.Generic.List%601> w tej samej kolejności, które są odczytywane przez moduł wyliczający kolekcji.  
  
 Ten konstruktor jest O (*n*) operacji, gdzie *n* jest liczba elementów w `collection`.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Collections.Generic.List%601.%23ctor%2A> Konstruktor i różnych metod <xref:System.Collections.Generic.List%601> klasę, która działa na zakresach. Tablica ciągów jest tworzony i przekazywany do konstruktora, wypełnianie listy przy użyciu elementów tablicy. <xref:System.Collections.Generic.List%601.Capacity%2A> Właściwość zostanie wyświetlona, aby pokazać, że pojemność jest dokładnie co jest wymagane do przechowywania elementów wejściowych.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="collection" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Collections.Generic.IEnumerable`1" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public List (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; List(int capacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.List&lt;'T&gt; : int -&gt; System.Collections.Generic.List&lt;'T&gt;" Usage="new System.Collections.Generic.List&lt;'T&gt; capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">Liczba elementów, które początkowo przechowywać nową listę.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Collections.Generic.List`1" /> klasę, która jest pusta i ma określony pojemność.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pojemność <xref:System.Collections.Generic.List%601> jest liczba elementów, <xref:System.Collections.Generic.List%601> może przechowywać. Gdy elementy są dodawane do <xref:System.Collections.Generic.List%601>, pojemność jest automatycznie zwiększana zgodnie z wymaganiami relokacja wewnętrznego tablicy.  
  
 Jeśli rozmiar kolekcji można oszacować, określający początkowej pojemności eliminuje konieczność wykonania wielu operacji zmiany rozmiaru podczas dodawania elementów do <xref:System.Collections.Generic.List%601>.  
  
 Można zmniejszyć pojemność przez wywołanie metody <xref:System.Collections.Generic.List%601.TrimExcess%2A> metody lub przez ustawienie <xref:System.Collections.Generic.List%601.Capacity%2A> właściwość jawnie. Zmniejsza pojemność przydzieli pamięci, a następnie kopiuje wszystkie elementy w <xref:System.Collections.Generic.List%601>.  
  
 Ten konstruktor jest O (*n*) operacji, gdzie *n* jest `capacity`.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Collections.Generic.List%601.%23ctor%28System.Int32%29> konstruktora. A <xref:System.Collections.Generic.List%601> ciągów o pojemności 4 zostanie utworzony, ponieważ ultimate rozmiar listy jest znany jako dokładnie 4. Lista jest wypełniana przy użyciu czterech ciągów i kopię tylko do odczytu jest tworzona przy użyciu <xref:System.Collections.Generic.List%601.AsReadOnly%2A> metody.  
  
 [!code-cpp[List\`1_AsReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_AsReadOnly/cpp/source.cpp#1)]
 [!code-csharp[List\`1_AsReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_AsReadOnly/cs/source.cs#1)]
 [!code-vb[List\`1_AsReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_AsReadOnly/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> jest mniejsza niż 0.</exception>
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Add(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (item As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Add(T item);" />
      <MemberSignature Language="F#" Value="abstract member Add : 'T -&gt; unit&#xA;override this.Add : 'T -&gt; unit" Usage="list.Add item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Obiekt do dodania na koniec <see cref="T:System.Collections.Generic.List`1" />. Wartość może być <see langword="null" /> dla typów odwołań.</param>
        <summary>Dodaje obiekt na koniec <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> akceptuje `null` prawidłową wartość dla odwołania do typów i pozwala zduplikowane elementy.  
  
 Jeśli <xref:System.Collections.Generic.List%601.Count%2A> jest już równa <xref:System.Collections.Generic.List%601.Capacity%2A>, pojemność <xref:System.Collections.Generic.List%601> jest zwiększana o automatyczne ponowne przydzielanie wewnętrznego tablicy, a istniejące elementy są kopiowane do nowej tablicy, przed dodaniem nowego elementu.  
  
 Jeśli <xref:System.Collections.Generic.List%601.Count%2A> jest mniejsza niż <xref:System.Collections.Generic.List%601.Capacity%2A>, ta metoda jest operacją O(1). Jeśli pojemność musi zostać zwiększona, aby pomieścić nowy element, ta metoda staje się O (*n*) operacji, gdzie *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak dodawanie, usuwanie i wstawianie obiektu proste biznesowych w <xref:System.Collections.Generic.List%601>.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 W poniższym przykładzie pokazano kilka właściwości i metod <xref:System.Collections.Generic.List%601> klasy ogólnej, w tym <xref:System.Collections.Generic.List%601.Add%2A> metody. Domyślny konstruktor jest używany do tworzenia listy ciągów o pojemności 0. <xref:System.Collections.Generic.List%601.Capacity%2A> Właściwości jest wyświetlana, a następnie <xref:System.Collections.Generic.List%601.Add%2A> metoda służy do dodawania wielu elementów. Elementy są wyświetlane i <xref:System.Collections.Generic.List%601.Capacity%2A> właściwość jest wyświetlana, wraz z <xref:System.Collections.Generic.List%601.Count%2A> właściwości, aby pokazać, że pojemność została zwiększona, zgodnie z potrzebami.  
  
 Inne właściwości i metody umożliwiają wyszukiwanie, wstawianie i usuwanie elementów z listy, a na koniec aby wyczyścić listę.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddRange (collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddRange(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberSignature Language="F#" Value="member this.AddRange : seq&lt;'T&gt; -&gt; unit" Usage="list.AddRange collection" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">Kolekcja, której elementy powinny zostać dodane do końca <see cref="T:System.Collections.Generic.List`1" />. Sama kolekcja nie może być <see langword="null" />, ale może zawierać elementy, które są <see langword="null" />, jeśli typ <paramref name="T" /> jest typem referencyjnym.</param>
        <summary>Dodaje elementy określonej kolekcji na końcu <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kolejność elementów w kolekcji jest zachowywana w <xref:System.Collections.Generic.List%601>.  
  
 Jeśli nowy <xref:System.Collections.Generic.List%601.Count%2A> (bieżący <xref:System.Collections.Generic.List%601.Count%2A> plus rozmiar kolekcji) będą większe niż <xref:System.Collections.Generic.List%601.Capacity%2A>, pojemność <xref:System.Collections.Generic.List%601> jest zwiększana o automatyczne ponowne przydzielanie wewnętrznego tablicy, aby uwzględnić nowe elementy i istniejące elementy są kopiowane do nowej tablicy, zanim nowe elementy są dodawane.  
  
 Jeśli <xref:System.Collections.Generic.List%601> może obsłużyć nowych elementów bez zwiększania <xref:System.Collections.Generic.List%601.Capacity%2A>, ta metoda jest O (*n*) operacji, gdzie *n* jest liczba elementów do dodania. Jeśli pojemność musi zostać zwiększona w celu uwzględnienia nowych elementów, ta metoda staje się O (*n* + *m*) operacji, gdzie *n* jest liczba elementów do dodania i *m* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Collections.Generic.List%601.AddRange%2A> metody i różnych innych metod <xref:System.Collections.Generic.List%601> klasę, która działa na zakresach. Tablica ciągów jest tworzony i przekazywany do konstruktora, wypełnianie listy przy użyciu elementów tablicy. <xref:System.Collections.Generic.List%601.AddRange%2A> Metoda jest wywoływana z listą jako argumentem. Powoduje to, że bieżące elementy listy są dodawane na końcu listy duplikowania wszystkie elementy.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="collection" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Collections.Generic.IEnumerable`1" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="AsReadOnly">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt; AsReadOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;!T&gt; AsReadOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.AsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Function AsReadOnly () As ReadOnlyCollection(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::ReadOnlyCollection&lt;T&gt; ^ AsReadOnly();" />
      <MemberSignature Language="F#" Value="member this.AsReadOnly : unit -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;'T&gt;" Usage="list.AsReadOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca tylko do odczytu <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> otoki dla bieżącej kolekcji.</summary>
        <returns>Obiekt, który działa jako tylko do odczytu otokę bieżącego <see cref="T:System.Collections.Generic.List`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby zapobiec wszelkie modyfikacje <xref:System.Collections.Generic.List%601> obiektów, uwidocznieniu go tylko przez tę otokę. A <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> obiekt nie ujawnia metody modyfikujące kolekcji. Jednak jeśli zmiany zostały wprowadzone do podstawowej <xref:System.Collections.Generic.List%601> obiektów i kolekcji tylko do odczytu uwzględni te zmiany.  
  
 Ta metoda jest operacją O(1).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Collections.Generic.List%601.AsReadOnly%2A> metody. A <xref:System.Collections.Generic.List%601> ciągów o pojemności 4 zostanie utworzony, ponieważ ultimate rozmiar listy jest znany jako dokładnie 4. Lista jest wypełniana przy użyciu czterech ciągów i <xref:System.Collections.Generic.List%601.AsReadOnly%2A> metoda jest używana do pobierania tylko do odczytu <xref:System.Collections.Generic.IList%601> implementacji ogólny interfejs, który otacza oryginalna lista.  
  
 Element oryginalnej listy jest ustawiony na wartość "Coelophysis" przy użyciu <xref:System.Collections.Generic.List%601.Item%2A> właściwości (indeksatora w języku C#) i zawartości listy tylko do odczytu są wyświetlane ponownie aby zademonstrować, jest on tylko otoka dla oryginalnej listy.  
  
 [!code-cpp[List\`1_AsReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_AsReadOnly/cpp/source.cpp#1)]
 [!code-csharp[List\`1_AsReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_AsReadOnly/cs/source.cs#1)]
 [!code-vb[List\`1_AsReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_AsReadOnly/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BinarySearch">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Używa algorytmu wyszukiwania binarnego do zlokalizowania określonego elementu w sortowany <see cref="T:System.Collections.Generic.List`1" /> lub jego część.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public int BinarySearch (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 BinarySearch(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.BinarySearch(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function BinarySearch (item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int BinarySearch(T item);" />
      <MemberSignature Language="F#" Value="member this.BinarySearch : 'T -&gt; int" Usage="list.BinarySearch item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Obiekt do zlokalizowania. Wartość może być <see langword="null" /> dla typów odwołań.</param>
        <summary>Przeszukuje cały sortowane <see cref="T:System.Collections.Generic.List`1" /> elementu przy użyciu domyślny moduł porównujący i zwraca liczony od zera indeks elementu.</summary>
        <returns>Liczony od zera indeks <paramref name="item" /> w sortowany <see cref="T:System.Collections.Generic.List`1" />, jeśli <paramref name="item" /> zostanie odnaleziony; w przeciwnym razie to liczba ujemna, czyli uzupełnienie bitowe indeks elementu, który jest większy niż <paramref name="item" /> lub, jeśli nie ma żadnych większych elementu uzupełnienie bitowe <see cref="P:System.Collections.Generic.List`1.Count" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wykorzystuje domyślny moduł porównujący <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> dla typu `T` można określić kolejność elementów listy. <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> Sprawdzenia właściwości tego, czy typ `T` implementuje <xref:System.IComparable%601> ogólny interfejs i wykorzystuje tę implementację, jeśli jest dostępny.  W przeciwnym razie <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> kontroli tego, czy typ `T` implementuje <xref:System.IComparable> interfejsu.  Jeśli typ `T` nie implementuje albo interfejsu <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> zgłasza <xref:System.InvalidOperationException>.  
  
 <xref:System.Collections.Generic.List%601> Muszą być już posortowane zgodnie z implementacji modułu porównującego; w przeciwnym razie wynikiem jest niepoprawny.  
  
 Porównywanie `null` za pomocą dowolnego odwołania do typu jest dozwolone i nie generuje wyjątek, korzystając z <xref:System.IComparable%601> interfejs generyczny. Podczas sortowania `null` jest uważany za mniej niż jakikolwiek inny obiekt.  
  
 Jeśli <xref:System.Collections.Generic.List%601> zawiera więcej niż jeden element o tej samej wartości, Metoda ta zwraca tylko jedno z wystąpień, a może zwrócić dowolną wystąpień, niekoniecznie pierwszy z nich.  
  
 Jeśli <xref:System.Collections.Generic.List%601> nie zawiera określonej wartości, Metoda ta zwraca ujemną liczbę całkowitą. Operacja dopełnienia bitowego (~) można zastosować do tego ujemną liczbę całkowitą, aby uzyskać indeks pierwszego elementu, który jest większa niż wartość wyszukiwania. Podczas wstawiania wartości do <xref:System.Collections.Generic.List%601>, ten indeks powinny służyć jako punkt wstawiania do utrzymania porządku sortowania.  
  
 Ta metoda jest O (log *n*) operacji, gdzie *n* jest liczba elementów w zakresie.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Collections.Generic.List%601.Sort> przeciążenie metody i <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> przeciążenie metody. A <xref:System.Collections.Generic.List%601> ciągów, zostanie utworzony i wypełniony czterech ciągów, w losowej kolejności. Lista jest wyświetlana, sortowane i ponownie wyświetlone.  
  
 <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> Przeciążenie metody jest następnie używany do wyszukiwania dwa ciągi, które nie są na liście i <xref:System.Collections.Generic.List%601.Insert%2A> metoda służy do wstawiania ich. Wartość zwracana przez <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> — metoda ma ujemną wartość w każdym przypadku, ponieważ ciągi nie są na liście. Biorąc dopełnienia bitowego (~ operatora w języku C# i Visual C++ `Xor` -1 w języku Visual Basic) z tym ujemna generuje numer indeksu pierwszego elementu na liście, który jest większy niż ciąg wyszukiwania i wstawianie w tym miejscu zachowuje sortowania kolejność. Drugi ciąg wyszukiwania jest większy niż dowolny element na liście, więc pozycji wstawiania znajduje się na końcu listy.  
  
 [!code-cpp[List\`1_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearch/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Domyślny moduł porównujący <see cref="P:System.Collections.Generic.Comparer`1.Default" /> nie można odnaleźć implementacji <see cref="T:System.IComparable`1" /> ogólny interfejs lub <see cref="T:System.IComparable" /> interfejsu dla typu <paramref name="T" />.</exception>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Wykonywanie niezależnych od kultury operacji na ciągach w kolekcjach</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public int BinarySearch (T item, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 BinarySearch(!T item, class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function BinarySearch (item As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int BinarySearch(T item, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="member this.BinarySearch : 'T * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; int" Usage="list.BinarySearch (item, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="item">Obiekt do zlokalizowania. Wartość może być <see langword="null" /> dla typów odwołań.</param>
        <param name="comparer"><see cref="T:System.Collections.Generic.IComparer`1" /> Wdrożenia do użycia podczas porównywania elementów.  
  
—lub— 
 <see langword="null" /> Aby użyć domyślny moduł porównujący <see cref="P:System.Collections.Generic.Comparer`1.Default" />.</param>
        <summary>Przeszukuje cały sortowane <see cref="T:System.Collections.Generic.List`1" /> elementu przy użyciu określona funkcja porównująca i zwraca liczony od zera indeks elementu.</summary>
        <returns>Liczony od zera indeks <paramref name="item" /> w sortowany <see cref="T:System.Collections.Generic.List`1" />, jeśli <paramref name="item" /> zostanie odnaleziony; w przeciwnym razie to liczba ujemna, czyli uzupełnienie bitowe indeks elementu, który jest większy niż <paramref name="item" /> lub, jeśli nie ma żadnych większych elementu uzupełnienie bitowe <see cref="P:System.Collections.Generic.List`1.Count" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Moduł porównujący dostosowuje sposób porównywania elementów. Na przykład, można użyć <xref:System.Collections.CaseInsensitiveComparer> wystąpienia jako modułu porównującego do wyszukiwania ciągów bez uwzględniania wielkości liter.  
  
 Jeśli `comparer` zostanie podany, elementy <xref:System.Collections.Generic.List%601> są porównywane z określoną wartość, przy użyciu określonego <xref:System.Collections.Generic.IComparer%601> implementacji.  
  
 Jeśli `comparer` jest `null`, domyślny moduł porównujący <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> kontroli tego, czy typ `T` implementuje <xref:System.IComparable%601> ogólny interfejs i wykorzystuje tę implementację, jeśli jest dostępny.  W przeciwnym razie <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> kontroli tego, czy typ `T` implementuje <xref:System.IComparable> interfejsu.  Jeśli typ `T` nie implementuje albo interfejsu <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> zgłasza <xref:System.InvalidOperationException>.  
  
 <xref:System.Collections.Generic.List%601> Muszą być już posortowane zgodnie z implementacji modułu porównującego; w przeciwnym razie wynikiem jest niepoprawny.  
  
 Porównywanie `null` za pomocą dowolnego odwołania do typu jest dozwolone i nie generuje wyjątek, korzystając z <xref:System.IComparable%601> interfejs generyczny. Podczas sortowania `null` jest uważany za mniej niż jakikolwiek inny obiekt.  
  
 Jeśli <xref:System.Collections.Generic.List%601> zawiera więcej niż jeden element o tej samej wartości, Metoda ta zwraca tylko jedno z wystąpień, a może zwrócić dowolną wystąpień, niekoniecznie pierwszy z nich.  
  
 Jeśli <xref:System.Collections.Generic.List%601> nie zawiera określonej wartości, Metoda ta zwraca ujemną liczbę całkowitą. Operacja dopełnienia bitowego (~) można zastosować do tego ujemną liczbę całkowitą, aby uzyskać indeks pierwszego elementu, który jest większa niż wartość wyszukiwania. Podczas wstawiania wartości do <xref:System.Collections.Generic.List%601>, ten indeks powinny służyć jako punkt wstawiania do utrzymania porządku sortowania.  
  
 Ta metoda jest O (log *n*) operacji, gdzie *n* jest liczba elementów w zakresie.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Collections.Generic.List%601.Sort%28System.Collections.Generic.IComparer%7B%600%7D%29> przeciążenie metody i <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> przeciążenie metody.  
  
 W przykładzie zdefiniowano alternatywny moduł porównujący dla ciągów o nazwie DinoCompare, która implementuje `IComparer<string>` (`IComparer(Of String)` w języku Visual Basic `IComparer<String^>` w programie Visual C++) interfejs generyczny. Modułu porównującego działa w następujący sposób: Po pierwsze, są sprawdzane pod kątem leksykalną `null`, odwołanie o wartości null jest traktowany jako mniejsza niż inna niż null. Po drugie długości ciągów są porównywane i dłuższego ciągu jest uznawany za większy. Po trzecie Jeśli długości są równe, porównywania ciągów znaków zwykłych jest używany.  
  
 A <xref:System.Collections.Generic.List%601> ciągów, zostanie utworzony i wypełniony czterech ciągów, w losowej kolejności. Zostanie wyświetlona lista, sortowane, przy użyciu alternatywny moduł porównujący i wyświetlone ponownie.  
  
 <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> Przeciążenie metody jest następnie używany do wyszukiwania kilka ciągów, które są nie na liście zatrudniających alternatywny moduł porównujący. <xref:System.Collections.Generic.List%601.Insert%2A> Metoda służy do wstawiania ciągi. Te dwie metody znajdują się w funkcji o nazwie `SearchAndInsert`, wraz z kodem, aby móc dopełnienia bitowego (~ operatora w języku C# i Visual C++ `Xor` -1 w języku Visual Basic) liczby ujemne zwracane przez <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> i używać go jako indeks dla Wstawianie nowego ciągu znaków.  
  
 [!code-cpp[List\`1_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> jest <see langword="null" />, a domyślny moduł porównujący <see cref="P:System.Collections.Generic.Comparer`1.Default" /> nie można odnaleźć implementacji <see cref="T:System.IComparable`1" /> ogólny interfejs lub <see cref="T:System.IComparable" /> interfejsu dla typu <paramref name="T" />.</exception>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Wykonywanie niezależnych od kultury operacji na ciągach w kolekcjach</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public int BinarySearch (int index, int count, T item, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 BinarySearch(int32 index, int32 count, !T item, class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function BinarySearch (index As Integer, count As Integer, item As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int BinarySearch(int index, int count, T item, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="member this.BinarySearch : int * int * 'T * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; int" Usage="list.BinarySearch (index, count, item, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="item" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="index">Liczony od zera indeks początkowy zakresu wyszukiwania.</param>
        <param name="count">Długość zakresu wyszukiwania.</param>
        <param name="item">Obiekt do zlokalizowania. Wartość może być <see langword="null" /> dla typów odwołań.</param>
        <param name="comparer"><see cref="T:System.Collections.Generic.IComparer`1" /> Wdrożenia do użycia podczas porównywania elementów, lub <see langword="null" /> używać domyślny moduł porównujący <see cref="P:System.Collections.Generic.Comparer`1.Default" />.</param>
        <summary>Wyszukuje zakres elementów w sortowany <see cref="T:System.Collections.Generic.List`1" /> elementu przy użyciu określona funkcja porównująca i zwraca liczony od zera indeks elementu.</summary>
        <returns>Liczony od zera indeks <paramref name="item" /> w sortowany <see cref="T:System.Collections.Generic.List`1" />, jeśli <paramref name="item" /> zostanie odnaleziony; w przeciwnym razie to liczba ujemna, czyli uzupełnienie bitowe indeks elementu, który jest większy niż <paramref name="item" /> lub, jeśli nie ma żadnych większych elementu uzupełnienie bitowe <see cref="P:System.Collections.Generic.List`1.Count" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Moduł porównujący dostosowuje sposób porównywania elementów. Na przykład, można użyć <xref:System.Collections.CaseInsensitiveComparer> wystąpienia jako modułu porównującego do wyszukiwania ciągów bez uwzględniania wielkości liter.  
  
 Jeśli `comparer` zostanie podany, elementy <xref:System.Collections.Generic.List%601> są porównywane z określoną wartość, przy użyciu określonego <xref:System.Collections.Generic.IComparer%601> implementacji.  
  
 Jeśli `comparer` jest `null`, domyślny moduł porównujący <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> kontroli tego, czy typ `T` implementuje <xref:System.IComparable%601> ogólny interfejs i wykorzystuje tę implementację, jeśli jest dostępny.  W przeciwnym razie <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> kontroli tego, czy typ `T` implementuje <xref:System.IComparable> interfejsu.  Jeśli typ `T` nie implementuje albo interfejsu <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> zgłasza <xref:System.InvalidOperationException>.  
  
 <xref:System.Collections.Generic.List%601> Muszą być już posortowane zgodnie z implementacji modułu porównującego; w przeciwnym razie wynikiem jest niepoprawny.  
  
 Porównywanie `null` za pomocą dowolnego odwołania do typu jest dozwolone i nie generuje wyjątek, korzystając z <xref:System.IComparable%601> interfejs generyczny. Podczas sortowania `null` jest uważany za mniej niż jakikolwiek inny obiekt.  
  
 Jeśli <xref:System.Collections.Generic.List%601> zawiera więcej niż jeden element o tej samej wartości, Metoda ta zwraca tylko jedno z wystąpień, a może zwrócić dowolną wystąpień, niekoniecznie pierwszy z nich.  
  
 Jeśli <xref:System.Collections.Generic.List%601> nie zawiera określonej wartości, Metoda ta zwraca ujemną liczbę całkowitą. Operacja dopełnienia bitowego (~) można zastosować do tego ujemną liczbę całkowitą, aby uzyskać indeks pierwszego elementu, który jest większa niż wartość wyszukiwania. Podczas wstawiania wartości do <xref:System.Collections.Generic.List%601>, ten indeks powinny służyć jako punkt wstawiania do utrzymania porządku sortowania.  
  
 Ta metoda jest O (log *n*) operacji, gdzie *n* jest liczba elementów w zakresie.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Collections.Generic.List%601.Sort%28System.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> przeciążenie metody i <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> przeciążenie metody.  
  
 W przykładzie zdefiniowano alternatywny moduł porównujący dla ciągów o nazwie DinoCompare, która implementuje `IComparer<string>` (`IComparer(Of String)` w języku Visual Basic `IComparer<String^>` w programie Visual C++) interfejs generyczny. Modułu porównującego działa w następujący sposób: Po pierwsze, są sprawdzane pod kątem leksykalną `null`, odwołanie o wartości null jest traktowany jako mniejsza niż inna niż null. Po drugie długości ciągów są porównywane i dłuższego ciągu jest uznawany za większy. Po trzecie Jeśli długości są równe, porównywania ciągów znaków zwykłych jest używany.  
  
 A <xref:System.Collections.Generic.List%601> ciągów, zostanie utworzony i wypełniony nazw dinozaurów herbivorous pięć i trzy dinozaurów mięsożernych zwierząt. W ramach każdej z tych dwóch grup nazwy nie są w dowolnej kolejności sortowania określonego. Zostanie wyświetlona lista, zakres zwierząt roślinożernych są sortowane przy użyciu alternatywny moduł porównujący i ponownie zostanie wyświetlona lista.  
  
 <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> Przeciążenie metody jest następnie używany do wyszukiwania tylko zakres zwierząt roślinożernych "Brachiosaurus". Ciąg nie zostanie znaleziony i dopełnienia bitowego (~ operatora w języku C# i Visual C++ `Xor` -1 w języku Visual Basic) liczby ujemne zwracane przez <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> metoda jest używana jako indeks do wstawiania nowego ciągu znaków.  
  
 [!code-cpp[List\`1_SortSearchComparerRange#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparerRange#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparerRange#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparerRange/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> jest mniejsza niż 0.  
  
—lub— 
 <paramref name="count" /> jest mniejsza niż 0.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> i <paramref name="count" /> nie określa prawidłowego zakresu <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> jest <see langword="null" />, a domyślny moduł porównujący <see cref="P:System.Collections.Generic.Comparer`1.Default" /> nie można odnaleźć implementacji <see cref="T:System.IComparable`1" /> ogólny interfejs lub <see cref="T:System.IComparable" /> interfejsu dla typu <paramref name="T" />.</exception>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Wykonywanie niezależnych od kultury operacji na ciągach w kolekcjach</related>
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.Capacity" />
      <MemberSignature Language="VB.NET" Value="Public Property Capacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Capacity { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Capacity : int with get, set" Usage="System.Collections.Generic.List&lt;'T&gt;.Capacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia całkowitą liczbę elementów, które może przechowywać struktury danych wewnętrznych, bez zmiany rozmiaru.</summary>
        <value>Liczba elementów, <see cref="T:System.Collections.Generic.List`1" /> może zawierać przed zmianą rozmiaru jest wymagana.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601.Capacity%2A> jest to liczba elementów, <xref:System.Collections.Generic.List%601> można przechowywać przed zmianą rozmiaru jest wymagany, natomiast <xref:System.Collections.Generic.List%601.Count%2A> jest liczba elementów, które są rzeczywiście w <xref:System.Collections.Generic.List%601>.  
  
 <xref:System.Collections.Generic.List%601.Capacity%2A> zawsze jest większa niż lub równa <xref:System.Collections.Generic.List%601.Count%2A>. Jeśli <xref:System.Collections.Generic.List%601.Count%2A> przekracza <xref:System.Collections.Generic.List%601.Capacity%2A> podczas dodawania elementów, pojemność jest zwiększana o automatycznie relokacja tablicy wewnętrznej przed skopiowaniem starymi elementami i dodawanie nowych elementów.  
  
 Jeśli pojemność jest znacznie większa niż liczba i chcesz zmniejszyć pamięci używanej przez <xref:System.Collections.Generic.List%601>, można zmniejszyć pojemność przez wywołanie metody <xref:System.Collections.Generic.List%601.TrimExcess%2A> metody lub przez ustawienie <xref:System.Collections.Generic.List%601.Capacity%2A> jawnie niższą wartość właściwości. Gdy wartość <xref:System.Collections.Generic.List%601.Capacity%2A> jest ustawiona, jawnie tablicy wewnętrznej alokowaniu również uwzględnić określonej pojemności, a wszystkie elementy są kopiowane.  
  
 Pobieranie wartości tej właściwości jest operacją O(1); Ustawienie właściwości jest O (*n*) operacji, gdzie *n* jest nową pojemność.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób sprawdzić pojemność i liczba <xref:System.Collections.Generic.List%601> , zawierający obiektu proste biznesowego, a ilustruje użycie <xref:System.Collections.Generic.List%601.TrimExcess%2A> metodę, aby usunąć dodatkowej pojemności.  
  
 [!code-csharp[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/vb/module1.vb#1)]  
  
 W poniższym przykładzie przedstawiono <xref:System.Collections.Generic.List%601.Capacity%2A> właściwość w kilku miejscach pracy listy. Domyślny konstruktor jest używany do tworzenia listy ciągów o pojemności 0, a <xref:System.Collections.Generic.List%601.Capacity%2A> ukazują to właściwość jest wyświetlany. Po <xref:System.Collections.Generic.List%601.Add%2A> metoda została już użyta w można dodać kilka elementów, elementy są wyświetlane, a następnie <xref:System.Collections.Generic.List%601.Capacity%2A> właściwość jest wyświetlana, wraz z <xref:System.Collections.Generic.List%601.Count%2A> właściwości, aby pokazać, że pojemność została zwiększona, zgodnie z potrzebami.  
  
 <xref:System.Collections.Generic.List%601.Capacity%2A> Właściwości jest wyświetlany ponownie po <xref:System.Collections.Generic.List%601.TrimExcess%2A> metoda jest używana do zmniejszenia pojemności do dopasowania liczby. Na koniec <xref:System.Collections.Generic.List%601.Clear%2A> metoda jest używana, aby usunąć wszystkie elementy z listy, a <xref:System.Collections.Generic.List%601.Capacity%2A> i <xref:System.Collections.Generic.List%601.Count%2A> ponownie wyświetlić właściwości.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><see cref="P:System.Collections.Generic.List`1.Capacity" /> jest ustawiona na wartość, która jest mniejsza niż <see cref="P:System.Collections.Generic.List`1.Count" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Brak dostępnej wystarczającej ilości pamięci w systemie.</exception>
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="list.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Clear</InterfaceMember>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa wszystkie elementy z <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601.Count%2A> jest równa 0, a ponadto są również zwalniane odwołania do innych obiektów z elementów kolekcji.  
  
 <xref:System.Collections.Generic.List%601.Capacity%2A> pozostaje bez zmian. Aby zresetować pojemność <xref:System.Collections.Generic.List%601>, wywołanie <xref:System.Collections.Generic.List%601.TrimExcess%2A> metody lub zestawu <xref:System.Collections.Generic.List%601.Capacity%2A> właściwość bezpośrednio. Zmniejsza pojemność przydzieli pamięci, a następnie kopiuje wszystkie elementy w <xref:System.Collections.Generic.List%601>. Przycinanie pustą <xref:System.Collections.Generic.List%601> ustawia pojemność <xref:System.Collections.Generic.List%601> do pojemności domyślnej.  
  
 Ta metoda jest O (*n*) operacji, gdzie *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Collections.Generic.List%601.Clear%2A> metody i różnych innych właściwości i metod <xref:System.Collections.Generic.List%601> klasy ogólnej. <xref:System.Collections.Generic.List%601.Clear%2A> Metoda jest używana na końcu programu, aby usunąć wszystkie elementy z listy, a <xref:System.Collections.Generic.List%601.Capacity%2A> i <xref:System.Collections.Generic.List%601.Count%2A> właściwości są następnie wyświetlane.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.TrimExcess" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Contains(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(T item);" />
      <MemberSignature Language="F#" Value="abstract member Contains : 'T -&gt; bool&#xA;override this.Contains : 'T -&gt; bool" Usage="list.Contains item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Obiekt do zlokalizowania w <see cref="T:System.Collections.Generic.List`1" />. Wartość może być <see langword="null" /> dla typów odwołań.</param>
        <summary>Określa, czy element jest <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns><see langword="true" /> Jeśli <paramref name="item" /> znajduje się w <see cref="T:System.Collections.Generic.List`1" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda określa równość za pomocą domyślny moduł porównujący równość, zgodnie z definicją implementacji obiektu <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> metodę `T` (typ wartości na liście).  
  
 Ta metoda przeprowadza wyszukiwanie liniowe; w związku z tym, ta metoda jest O (*n*) operacji, gdzie *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Collections.Generic.List%601.Contains%2A> i <xref:System.Collections.Generic.List%601.Exists%2A> metod <xref:System.Collections.Generic.List%601> zawierającą obiekt firmy simple, który implementuje <xref:System.IEquatable%601.Equals%2A>.  
  
 [!code-csharp[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/vb/module1.vb#1)]  
  
 Poniższy przykład zawiera listę obiektów złożonych typu `Cube`. `Cube` Klasy implementuje <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> metody, aby dwa moduły są traktowane jako równe, jeżeli ich wymiary są takie same. W tym przykładzie <xref:System.Collections.Generic.List%601.Contains%2A> metoda zwraca `true`, ponieważ moduł, który ma określony wymiarów znajduje się już w kolekcji.  
  
 [!code-csharp[System.Collections.Generic.List.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.contains/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.contains/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Wykonywanie niezależnych od kultury operacji na ciągach w kolekcjach</related>
      </Docs>
    </Member>
    <Member MemberName="ConvertAll&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;TOutput&gt; ConvertAll&lt;TOutput&gt; (Converter&lt;T,TOutput&gt; converter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;!!TOutput&gt; ConvertAll&lt;TOutput&gt;(class System.Converter`2&lt;!T, !!TOutput&gt; converter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.ConvertAll``1(System.Converter{`0,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function ConvertAll(Of TOutput) (converter As Converter(Of T, TOutput)) As List(Of TOutput)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOutput&gt;&#xA; System::Collections::Generic::List&lt;TOutput&gt; ^ ConvertAll(Converter&lt;T, TOutput&gt; ^ converter);" />
      <MemberSignature Language="F#" Value="member this.ConvertAll : Converter&lt;'T, 'Output&gt; -&gt; System.Collections.Generic.List&lt;'Output&gt;" Usage="list.ConvertAll converter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;TOutput&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="converter" Type="System.Converter&lt;T,TOutput&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">Typ elementów tablicy docelowej.</typeparam>
        <param name="converter">A <see cref="T:System.Converter`2" /> delegat, który konwertuje każdy element z jednego typu na inny typ.</param>
        <summary>Konwertuje elementy w bieżącym <see cref="T:System.Collections.Generic.List`1" /> do innego typu i zwraca listę zawierającą przekonwertowane elementów.</summary>
        <returns>A <see cref="T:System.Collections.Generic.List`1" /> typu docelowego zawierający elementy przekonwertowana z bieżącej <see cref="T:System.Collections.Generic.List`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Converter%602> Jest delegatem metody, która konwertuje obiekt na typ docelowy.  Elementy bieżącego <xref:System.Collections.Generic.List%601> są indywidualnie przekazywane do <xref:System.Converter%602> delegata i przekonwertowane elementy, które są zapisywane w nowym <xref:System.Collections.Generic.List%601>.  
  
 Bieżący <xref:System.Collections.Generic.List%601> pozostaje bez zmian.  
  
 Ta metoda jest O (*n*) operacji, gdzie *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano metodę o nazwie `PointFToPoint` konwertująca <xref:System.Drawing.PointF> struktury do <xref:System.Drawing.Point> struktury. Przykład tworzy następnie <xref:System.Collections.Generic.List%601> z <xref:System.Drawing.PointF> struktury, tworzy `Converter\<PointF, Point>` delegowanie (`Converter(Of PointF, Point)` w języku Visual Basic) do reprezentowania `PointFToPoint` metody i przekazuje delegata do <xref:System.Collections.Generic.List%601.ConvertAll%2A> metody. <xref:System.Collections.Generic.List%601.ConvertAll%2A> Metoda kończy się powodzeniem każdy element listy danych wejściowych w celu `PointFToPoint` metody i umieszcza elementy przekonwertowana z nową listę <xref:System.Drawing.Point> struktury. Zarówno listy są wyświetlane.  
  
 [!code-cpp[List\`1_ConvertAll#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_ConvertAll/cpp/source.cpp#1)]
 [!code-csharp[List\`1_ConvertAll#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_ConvertAll/cs/source.cs#1)]
 [!code-vb[List\`1_ConvertAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_ConvertAll/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="converter" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Converter`2" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kopiuje <see cref="T:System.Collections.Generic.List`1" /> lub jego części bez upoważnienia do tablicy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.CopyTo(`0[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : 'T[] -&gt; unit" Usage="list.CopyTo array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <param name="array">Jednowymiarowy <see cref="T:System.Array" /> czyli miejscem docelowym elementów kopiowanych z <see cref="T:System.Collections.Generic.List`1" />. <see cref="T:System.Array" /> Musi mieć Indeksowanie oparte na zerze.</param>
        <summary>Kopiuje cały <see cref="T:System.Collections.Generic.List`1" /> celu niezgodne jednowymiarowej tablicy, zaczynając od początku tablicy docelowej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa <xref:System.Array.Copy%2A?displayProperty=nameWithType> można skopiować elementów.  
  
 Elementy są kopiowane do <xref:System.Array> w tej samej kolejności, w której moduł wyliczający wykonuje iterację przez <xref:System.Collections.Generic.List%601>.  
  
 Ta metoda jest O (*n*) operacji, gdzie *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano wszystkich trzech przeciążeń <xref:System.Collections.Generic.List%601.CopyTo%2A> metody. A <xref:System.Collections.Generic.List%601> ciągów, zostanie utworzony i wypełniony 5 ciągów. Pustą tablicę ciągów elementów 15 zostanie utworzony i <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%29> przeciążenia metody umożliwia kopiowanie wszystkich elementów listy do tablicy, zaczynając od pierwszego elementu tablicy. <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%2CSystem.Int32%29> Metoda przeciążenia służy do kopiowania wszystkie elementy na liście, aby tablicy, zaczynając od indeksu tablicy 6 (opuścić pusty indeks 5). Na koniec <xref:System.Collections.Generic.List%601.CopyTo%28System.Int32%2C%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> metoda przeciążenia służy do kopiowania 3 elementy z listy, począwszy od indeksu 2, do tablicy, zaczynając od tablicy indeks 12 (opuścić indeks 11 pusty). Następnie jest wyświetlana zawartość tablicy.  
  
 [!code-cpp[List\`1_CopyTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_CopyTo/cpp/source.cpp#1)]
 [!code-csharp[List\`1_CopyTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_CopyTo/cs/source.cs#1)]
 [!code-vb[List\`1_CopyTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_CopyTo/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Liczba elementów w źródle <see cref="T:System.Collections.Generic.List`1" /> jest większa niż liczba elementów, miejsce docelowe <paramref name="array" /> może zawierać.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(!T[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.CopyTo(`0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T(), arrayIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(cli::array &lt;T&gt; ^ array, int arrayIndex);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : 'T[] * int -&gt; unit&#xA;override this.CopyTo : 'T[] * int -&gt; unit" Usage="list.CopyTo (array, arrayIndex)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Jednowymiarowy <see cref="T:System.Array" /> czyli miejscem docelowym elementów kopiowanych z <see cref="T:System.Collections.Generic.List`1" />. <see cref="T:System.Array" /> Musi mieć Indeksowanie oparte na zerze.</param>
        <param name="arrayIndex">Liczony od zera indeks w <paramref name="array" /> od rozpoczyna się kopiowanie które.</param>
        <summary>Kopiuje cały <see cref="T:System.Collections.Generic.List`1" /> celu niezgodne jednowymiarowej tablicy, zaczynając od określonego indeksu tablicy docelowej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa <xref:System.Array.Copy%2A?displayProperty=nameWithType> można skopiować elementów.  
  
 Elementy są kopiowane do <xref:System.Array> w tej samej kolejności, w której moduł wyliczający wykonuje iterację przez <xref:System.Collections.Generic.List%601>.  
  
 Ta metoda jest O (*n*) operacji, gdzie *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano wszystkich trzech przeciążeń <xref:System.Collections.Generic.List%601.CopyTo%2A> metody. A <xref:System.Collections.Generic.List%601> ciągów, zostanie utworzony i wypełniony 5 ciągów. Pustą tablicę ciągów elementów 15 zostanie utworzony i <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%29> przeciążenia metody umożliwia kopiowanie wszystkich elementów listy do tablicy, zaczynając od pierwszego elementu tablicy. <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%2CSystem.Int32%29> Metoda przeciążenia służy do kopiowania wszystkie elementy na liście, aby tablicy, zaczynając od indeksu tablicy 6 (opuścić pusty indeks 5). Na koniec <xref:System.Collections.Generic.List%601.CopyTo%28System.Int32%2C%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> metoda przeciążenia służy do kopiowania 3 elementy z listy, począwszy od indeksu 2, do tablicy, zaczynając od tablicy indeks 12 (opuścić indeks 11 pusty). Następnie jest wyświetlana zawartość tablicy.  
  
 [!code-cpp[List\`1_CopyTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_CopyTo/cpp/source.cpp#1)]
 [!code-csharp[List\`1_CopyTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_CopyTo/cs/source.cs#1)]
 [!code-vb[List\`1_CopyTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_CopyTo/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="arrayIndex" /> jest mniejsza niż 0.</exception>
        <exception cref="T:System.ArgumentException">Liczba elementów w źródle <see cref="T:System.Collections.Generic.List`1" /> jest większa niż dostępna ilość miejsca od <paramref name="arrayIndex" /> do końca tablicy docelowej <paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int index, T[] array, int arrayIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 index, !T[] array, int32 arrayIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (index As Integer, array As T(), arrayIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int index, cli::array &lt;T&gt; ^ array, int arrayIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * 'T[] * int * int -&gt; unit" Usage="list.CopyTo (index, array, arrayIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Liczony od zera indeks w źródle <see cref="T:System.Collections.Generic.List`1" /> od rozpoczyna się kopiowanie które.</param>
        <param name="array">Jednowymiarowy <see cref="T:System.Array" /> czyli miejscem docelowym elementów kopiowanych z <see cref="T:System.Collections.Generic.List`1" />. <see cref="T:System.Array" /> Musi mieć Indeksowanie oparte na zerze.</param>
        <param name="arrayIndex">Liczony od zera indeks w <paramref name="array" /> od rozpoczyna się kopiowanie które.</param>
        <param name="count">Liczba elementów do skopiowania.</param>
        <summary>Kopiuje szereg elementów z <see cref="T:System.Collections.Generic.List`1" /> celu niezgodne jednowymiarowej tablicy, zaczynając od określonego indeksu tablicy docelowej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa <xref:System.Array.Copy%2A?displayProperty=nameWithType> można skopiować elementów.  
  
 Elementy są kopiowane do <xref:System.Array> w tej samej kolejności, w której moduł wyliczający wykonuje iterację przez <xref:System.Collections.Generic.List%601>.  
  
 Ta metoda jest O (*n*) operacji, gdzie *n* jest `count`.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano wszystkich trzech przeciążeń <xref:System.Collections.Generic.List%601.CopyTo%2A> metody. A <xref:System.Collections.Generic.List%601> ciągów, zostanie utworzony i wypełniony 5 ciągów. Pustą tablicę ciągów elementów 15 zostanie utworzony i <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%29> przeciążenia metody umożliwia kopiowanie wszystkich elementów listy do tablicy, zaczynając od pierwszego elementu tablicy. <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%2CSystem.Int32%29> Metoda przeciążenia służy do kopiowania wszystkie elementy na liście, aby tablicy, zaczynając od indeksu tablicy 6 (opuścić pusty indeks 5). Na koniec <xref:System.Collections.Generic.List%601.CopyTo%28System.Int32%2C%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> metoda przeciążenia służy do kopiowania 3 elementy z listy, począwszy od indeksu 2, do tablicy, zaczynając od tablicy indeks 12 (opuścić indeks 11 pusty). Następnie jest wyświetlana zawartość tablicy.  
  
 [!code-cpp[List\`1_CopyTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_CopyTo/cpp/source.cpp#1)]
 [!code-csharp[List\`1_CopyTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_CopyTo/cs/source.cs#1)]
 [!code-vb[List\`1_CopyTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_CopyTo/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> jest mniejsza niż 0.  
  
—lub— 
 <paramref name="arrayIndex" /> jest mniejsza niż 0.  
  
—lub— 
 <paramref name="count" /> jest mniejsza niż 0.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> jest równa lub większa niż <see cref="P:System.Collections.Generic.List`1.Count" /> źródła <see cref="T:System.Collections.Generic.List`1" />.  
  
—lub— 
Liczba elementów od <paramref name="index" /> -to-end źródła <see cref="T:System.Collections.Generic.List`1" /> jest większa niż dostępna ilość miejsca od <paramref name="arrayIndex" /> do końca tablicy docelowej <paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.Generic.List&lt;'T&gt;.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyCollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę elementów znajdujących się w <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <value>Liczba elementów zawartych w słowniku <see cref="T:System.Collections.Generic.List`1" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601.Capacity%2A> jest to liczba elementów, <xref:System.Collections.Generic.List%601> można przechowywać przed zmianą rozmiaru jest wymagana. <xref:System.Collections.Generic.List%601.Count%2A> jest to liczba elementów, które są rzeczywiście w <xref:System.Collections.Generic.List%601>.  
  
 <xref:System.Collections.Generic.List%601.Capacity%2A> zawsze jest większa niż lub równa <xref:System.Collections.Generic.List%601.Count%2A>. Jeśli <xref:System.Collections.Generic.List%601.Count%2A> przekracza <xref:System.Collections.Generic.List%601.Capacity%2A> podczas dodawania elementów, pojemność jest zwiększana o automatycznie relokacja tablicy wewnętrznej przed skopiowaniem starymi elementami i dodawanie nowych elementów.  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób sprawdzić pojemność i liczba <xref:System.Collections.Generic.List%601> , zawierający obiektu proste biznesowego, a ilustruje użycie <xref:System.Collections.Generic.List%601.TrimExcess%2A> metodę, aby usunąć dodatkowej pojemności.  
  
 [!code-csharp[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/vb/module1.vb#1)]  
  
 W poniższym przykładzie pokazano wartość <xref:System.Collections.Generic.List%601.Count%2A> właściwość w różnych punktach w życiu listy. Po liście został utworzony i wypełniony i jego elementy są wyświetlane, <xref:System.Collections.Generic.List%601.Capacity%2A> i <xref:System.Collections.Generic.List%601.Count%2A> właściwości są wyświetlane. Te właściwości są wyświetlane po <xref:System.Collections.Generic.List%601.TrimExcess%2A> metoda została wywołana i ponownie po zawartości listy są usuwane.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public bool Exists (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Exists(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Exists (match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Exists(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.Exists : Predicate&lt;'T&gt; -&gt; bool" Usage="list.Exists match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match"><see cref="T:System.Predicate`1" /> Delegat definiujący warunki elementy do wyszukania.</param>
        <summary>Określa, czy <see cref="T:System.Collections.Generic.List`1" /> zawiera elementy odpowiadające warunkom zdefiniowanym przez określony predykat.</summary>
        <returns><see langword="true" /> Jeśli <see cref="T:System.Collections.Generic.List`1" /> zawiera jeden lub więcej elementów, które pasują do warunków zdefiniowanych przez określony predykat; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601> Jest delegatem metody, która zwraca `true` jeśli przekazany obiekt jest zgodny z warunkami zdefiniowanymi dla delegata.  Elementy bieżącego <xref:System.Collections.Generic.List%601> są indywidualnie przekazywane do <xref:System.Predicate%601> delegata, a przetwarzanie jest zatrzymywany, gdy zostanie znalezione dopasowanie.  
  
 Ta metoda przeprowadza wyszukiwanie liniowe; w związku z tym, ta metoda jest O (*n*) operacji, gdzie *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Collections.Generic.List%601.Contains%2A> i <xref:System.Collections.Generic.List%601.Exists%2A> metod <xref:System.Collections.Generic.List%601> zawierającą obiekt firmy simple, który implementuje <xref:System.IEquatable%601.Equals%2A>.  
  
 [!code-csharp[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/vb/module1.vb#1)]  
  
 W poniższym przykładzie pokazano <xref:System.Collections.Generic.List%601.Exists%2A> metody i kilka innych metod, które używają <xref:System.Predicate%601> Delegat ogólny.  
  
 A <xref:System.Collections.Generic.List%601> ciągów jest tworzona, zawierająca 8 nazw dinozaurów, dwa z nich (w pozycjach 1 i 5) kończy się ciągiem "saurus". W przykładzie zdefiniowano również metodę wyszukiwania predykatów o nazwie `EndsWithSaurus`, który przyjmuje parametr ciąg i zwraca wartość logiczną wskazującą, czy ciąg wejściowy kończy się na "saurus".  
  
 <xref:System.Collections.Generic.List%601.Find%2A>, <xref:System.Collections.Generic.List%601.FindLast%2A>, I <xref:System.Collections.Generic.List%601.FindAll%2A> metody są używane do wyszukiwania na liście metodę wyszukiwania predykatów, a następnie <xref:System.Collections.Generic.List%601.RemoveAll%2A> metoda jest używana, aby usunąć wszystkie wpisy, które kończą się ciągiem "saurus".  
  
 Na koniec <xref:System.Collections.Generic.List%601.Exists%2A> metoda jest wywoływana. Przechodzi przez listę od początku, przekazywać z kolei do każdego elementu `EndsWithSaurus` metody. Zatrzymuje wyszukiwanie i zwraca metoda `true` Jeśli `EndsWithSaurus` metoda zwraca `true` dla każdego elementu. <xref:System.Collections.Generic.List%601.Exists%2A> Metoda zwraca `false` ponieważ takie elementy zostały usunięte.  
  
> [!NOTE]
>  W języku C# i Visual Basic nie jest niezbędne do utworzenia `Predicate<string>` delegowanie (`Predicate(Of String)` w języku Visual Basic) jawnie. Te języki wnioskują o poprawnym delegacie z kontekstu, a następnie są tworzone automatycznie.  
  
 [!code-cpp[List\`1_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[List\`1_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_FindEtAl/cs/source.cs#1)]
 [!code-vb[List\`1_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public T Find (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T Find(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T Find(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.Find : Predicate&lt;'T&gt; -&gt; 'T" Usage="list.Find match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match"><see cref="T:System.Predicate`1" /> Delegat definiujący warunki elementu do wyszukania.</param>
        <summary>Wyszukuje element, który pasuje do warunków zdefiniowanych przez określony predykat i zwraca pierwsze wystąpienie w ramach całego <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>Pierwszy element, który pasuje do warunków zdefiniowanych przez określony predykat, jeśli znaleziono; w przeciwnym razie wartość domyślna dla typu <paramref name="T" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601> Jest delegatem metody, która zwraca `true` jeśli przekazany obiekt jest zgodny z warunkami zdefiniowanymi dla delegata.  Elementy bieżącego <xref:System.Collections.Generic.List%601> są indywidualnie przekazywane do <xref:System.Predicate%601> delegata, przenoszenie do przodu w <xref:System.Collections.Generic.List%601>, rozpoczynając od pierwszego elementu, a kończąc na ostatnim elemencie.  Przetwarzanie jest zatrzymywany, gdy zostanie znalezione dopasowanie.  
  
> [!IMPORTANT]
>  Podczas wyszukiwania listę zawierającą typy wartości, upewnij się, że wartość domyślna dla typu nie spełniają predykat wyszukiwania. W przeciwnym razie jest sposobem rozróżnienia wartość z domyślną wskazującą, że nie znaleziono dopasowania i element listy, który stanie się mają wartość domyślną dla typu. Jeśli wartości domyślne spełniają predykat wyszukiwania, użyj <xref:System.Collections.Generic.List%601.FindIndex%2A> metody zamiast tego.  
  
 Ta metoda przeprowadza wyszukiwanie liniowe; w związku z tym, ta metoda jest O (*n*) operacji, gdzie *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Collections.Generic.List%601.Find%2A> metody <xref:System.Collections.Generic.List%601> zawierający prostego obiektu złożonego.  
  
 [!code-csharp[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/vb/module1.vb#1)]  
  
 W poniższym przykładzie pokazano metody Znajdź <xref:System.Collections.Generic.List%601> klasy. Przykład <xref:System.Collections.Generic.List%601> klasa zawiera `book` obiektów klasy `Book`, przy użyciu danych z [przykładowy plik XML: Książki (LINQ to XML)](https://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). `FillList` Metoda w przykładzie wykorzystuje [LINQ to XML](https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) można przeanalizować wartości z pliku XML do wartości właściwości `book` obiektów.  
  
 W poniższej tabeli opisano przykłady związane z metody wyszukiwania.  
  
|Metoda|Przykład|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Umożliwia znalezienie książki przy użyciu Identyfikatora `IDToFind` predykatu delegata.<br /><br /> Przykład w języku C# używa delegata anonimowego.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Znajdź wszystkie książek, że których `Genre` właściwość jest "Computer" przy użyciu `FindComputer` predykatu delegata.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Znajduje ostatni książki w kolekcji zawierającej daty opublikowania, przed 2001, przy użyciu `PubBefore2001` predykatu delegata.<br /><br /> Przykład w języku C# używa delegata anonimowego.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Znajduje indeks pierwszego książki komputera przy użyciu `FindComputer` predykatu delegata.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Znajduje indeks ostatniego komputera książki przy użyciu `FindComputer` predykatu delegata.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Znajduje indeks pierwszego komputera książki w drugim, połowa kolekcji, za pomocą `FindComputer` predykatu delegata.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Znajduje indeks ostatniego książki komputera w ciągu sekundy, połowa kolekcji, za pomocą `FindComputer` predykatu delegata.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindAll">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;T&gt; FindAll (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;!T&gt; FindAll(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindAll (match As Predicate(Of T)) As List(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;T&gt; ^ FindAll(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindAll : Predicate&lt;'T&gt; -&gt; System.Collections.Generic.List&lt;'T&gt;" Usage="list.FindAll match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match"><see cref="T:System.Predicate`1" /> Delegat definiujący warunki elementy do wyszukania.</param>
        <summary>Pobiera wszystkie elementy odpowiadające warunkom zdefiniowanym przez określony predykat.</summary>
        <returns>A <see cref="T:System.Collections.Generic.List`1" /> zawierający wszystkie elementy spełniających warunki zdefiniowane przez określony predykat, jeśli je znaleziono; w przeciwnym razie, pusta <see cref="T:System.Collections.Generic.List`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601> Jest delegatem metody, która zwraca `true` jeśli przekazany obiekt jest zgodny z warunkami zdefiniowanymi dla delegata.  Elementy bieżącego <xref:System.Collections.Generic.List%601> są indywidualnie przekazywane do <xref:System.Predicate%601> delegata i elementy, które spełniają warunki są zapisywane w zwróconym elemencie <xref:System.Collections.Generic.List%601>.  
  
 Ta metoda przeprowadza wyszukiwanie liniowe; w związku z tym, ta metoda jest O (*n*) operacji, gdzie *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano metody Znajdź <xref:System.Collections.Generic.List%601> klasy. Przykład <xref:System.Collections.Generic.List%601> klasa zawiera `book` obiektów klasy `Book`, przy użyciu danych z [przykładowy plik XML: Książki (LINQ to XML)](https://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). `FillList` Metoda w przykładzie wykorzystuje [LINQ to XML](https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) można przeanalizować wartości z pliku XML do wartości właściwości `book` obiektów.  
  
 W poniższej tabeli opisano przykłady związane z metody wyszukiwania.  
  
|Metoda|Przykład|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Umożliwia znalezienie książki przy użyciu Identyfikatora `IDToFind` predykatu delegata.<br /><br /> Przykład w języku C# używa delegata anonimowego.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Znajdź wszystkie książek, że których `Genre` właściwość jest "Computer" przy użyciu `FindComputer` predykatu delegata.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Znajduje ostatni książki w kolekcji zawierającej daty opublikowania, przed 2001, przy użyciu `PubBefore2001` predykatu delegata.<br /><br /> Przykład w języku C# używa delegata anonimowego.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Znajduje indeks pierwszego książki komputera przy użyciu `FindComputer` predykatu delegata.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Znajduje indeks ostatniego komputera książki przy użyciu `FindComputer` predykatu delegata.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Znajduje indeks pierwszego komputera książki w drugim, połowa kolekcji, za pomocą `FindComputer` predykatu delegata.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Znajduje indeks ostatniego książki komputera w ciągu sekundy, połowa kolekcji, za pomocą `FindComputer` predykatu delegata.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindIndex">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wyszukuje element, który pasuje do warunków zdefiniowanych przez określony predykat i zwraca liczony od zera indeks pierwszego wystąpienia w ramach <see cref="T:System.Collections.Generic.List`1" /> lub jego część. Ta metoda zwraca wartość -1, jeśli nie zostanie znaleziony element, który pasuje do warunków.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindIndex">
      <MemberSignature Language="C#" Value="public int FindIndex (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindIndex(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindIndex(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindIndex (match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindIndex(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindIndex : Predicate&lt;'T&gt; -&gt; int" Usage="list.FindIndex match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match"><see cref="T:System.Predicate`1" /> Delegat definiujący warunki elementu do wyszukania.</param>
        <summary>Wyszukuje element, który pasuje do warunków zdefiniowanych przez określony predykat i zwraca liczony od zera indeks pierwszego wystąpienia w ramach całego <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>Liczony od zera indeks pierwszego wystąpienia elementu, który pasuje do warunków zdefiniowanych przez <paramref name="match" />, jeśli je znaleziono; w przeciwnym razie wartość -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> Przeszukiwany jest do przodu zaczynając od pierwszego elementu, a kończąc na ostatnim elemencie.  
  
 <xref:System.Predicate%601> Jest delegatem metody, która zwraca `true` jeśli przekazany obiekt jest zgodny z warunkami zdefiniowanymi dla delegata.  Elementy bieżącego <xref:System.Collections.Generic.List%601> są indywidualnie przekazywane do <xref:System.Predicate%601> delegować. Pełnomocnik ma podpis:  
  
```csharp  
public bool methodName(T obj)  
```  
  
```vb  
Public Function methodName(obj As T) As Boolean  
```  
  
 Ta metoda przeprowadza wyszukiwanie liniowe; w związku z tym, ta metoda jest O (*n*) operacji, gdzie *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano `Employee` klasy przy użyciu dwóch pól `Name` i `Id`. Umożliwia on również definiowanie `EmployeeSearch` klasy za pomocą pojedynczej metody `StartsWith`, oznacza to, czy `Employee.Name` pola zaczyna się podanym podciągiem, która jest dostarczana do `EmployeeSearch` konstruktora klasy. Należy pamiętać podpis tej metody  
  
```csharp  
public bool StartsWith(Employee e)  
```  
  
```vb  
Public Function StartsWith(e As Employee) As Boolean  
```  
  
 odnosi się do podpis delegata, który może być przekazywany do <xref:System.Collections.Generic.List%601.FindIndex%2A> metody. Przykład tworzy `List<Employee>` obiektów, dodaje wiele `Employee` objets go, a następnie wywołania <xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29> metodę dwa razy, aby przeszukać całą kolekcję po raz pierwszy w pierwszym `Employee` którego `Name` rozpoczyna się pola za pomocą "J" i po raz drugi w pierwszym `Employee` którego `Name` pola zaczyna się od "Ju".  
  
 [!code-csharp[System.Collections.Generic.List.FindIndex#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/cs/FindIndex2.cs#2)]
 [!code-vb[System.Collections.Generic.List.FindIndex#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/vb/FindIndex2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex">
      <MemberSignature Language="C#" Value="public int FindIndex (int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindIndex(int32 startIndex, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindIndex (startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindIndex(int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindIndex : int * Predicate&lt;'T&gt; -&gt; int" Usage="list.FindIndex (startIndex, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">Wartość początkowa indeksu zaczynającego się od zera dla wyszukiwania.</param>
        <param name="match"><see cref="T:System.Predicate`1" /> Delegat definiujący warunki elementu do wyszukania.</param>
        <summary>Wyszukuje element, który pasuje do warunków zdefiniowanych przez określony predykat i zwraca liczony od zera indeks pierwszego wystąpienia w zakresie elementów w <see cref="T:System.Collections.Generic.List`1" /> który rozciąga się od określonego indeksu do ostatniego elementu.</summary>
        <returns>Liczony od zera indeks pierwszego wystąpienia elementu, który pasuje do warunków zdefiniowanych przez <paramref name="match" />, jeśli je znaleziono; w przeciwnym razie wartość -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> Jest przeszukiwany w przód od `startIndex` a kończąc na do ostatniego elementu.  
  
 <xref:System.Predicate%601> Jest delegatem metody, która zwraca `true` jeśli przekazany obiekt jest zgodny z warunkami zdefiniowanymi dla delegata.  Elementy bieżącego <xref:System.Collections.Generic.List%601> są indywidualnie przekazywane do <xref:System.Predicate%601> delegować. Pełnomocnik ma podpis:  
  
```csharp  
public bool methodName(T obj)  
```  
  
```vb  
Public Function methodName(obj As T) As Boolean  
```  
  
 Ta metoda przeprowadza wyszukiwanie liniowe; w związku z tym, ta metoda jest O (*n*) operacji, gdzie *n* jest liczba elementów od `startIndex` na końcu <xref:System.Collections.Generic.List%601>.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano `Employee` klasy przy użyciu dwóch pól `Name` i `Id`. Umożliwia on również definiowanie `EmployeeSearch` klasy za pomocą pojedynczej metody `StartsWith`, oznacza to, czy `Employee.Name` pola zaczyna się podanym podciągiem, która jest dostarczana do `EmployeeSearch` konstruktora klasy. Należy pamiętać podpis tej metody  
  
```csharp  
public bool StartsWith(Employee e)  
```  
  
```vb  
Public Function StartsWith(e As Employee) As Boolean  
```  
  
 odnosi się do podpis delegata, który może być przekazywany do <xref:System.Collections.Generic.List%601.FindIndex%2A> metody. Przykład tworzy `List<Employee>` obiektów, dodaje wiele `Employee` objets go, a następnie wywołania <xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29> metodę dwa razy, aby wyszukać kolekcji, począwszy od jego piąty element członkowski (oznacza to, że element członkowski o indeksie 4). Po raz pierwszy, wyszukuje pierwszy `Employee` którego `Name` pola zaczyna się od "J"; po raz drugi, wyszukuje pierwszy `Employee` którego `Name` pola zaczyna się od "Ju".  
  
 [!code-csharp[System.Collections.Generic.List.FindIndex#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/cs/FindIndex3.cs#3)]
 [!code-vb[System.Collections.Generic.List.FindIndex#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/vb/FindIndex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> znajduje się poza zakresem prawidłowych indeksów dla <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex">
      <MemberSignature Language="C#" Value="public int FindIndex (int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindIndex(int32 startIndex, int32 count, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindIndex (startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindIndex(int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindIndex : int * int * Predicate&lt;'T&gt; -&gt; int" Usage="list.FindIndex (startIndex, count, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">Wartość początkowa indeksu zaczynającego się od zera dla wyszukiwania.</param>
        <param name="count">Liczba elementów w sekcji do wyszukania.</param>
        <param name="match"><see cref="T:System.Predicate`1" /> Delegat definiujący warunki elementu do wyszukania.</param>
        <summary>Wyszukuje element, który pasuje do warunków zdefiniowanych przez określony predykat i zwraca liczony od zera indeks pierwszego wystąpienia w zakresie elementów w <see cref="T:System.Collections.Generic.List`1" /> , rozpoczyna się od określonego indeksu i zawiera określoną liczbę elementów.</summary>
        <returns>Liczony od zera indeks pierwszego wystąpienia elementu, który pasuje do warunków zdefiniowanych przez <paramref name="match" />, jeśli je znaleziono; w przeciwnym razie wartość -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> Jest przeszukiwany w przód od `startIndex` i kończące się wierszem `startIndex` oraz `count` minus 1, jeśli `count` jest większa niż 0.  
  
 <xref:System.Predicate%601> Jest delegatem metody, która zwraca `true` jeśli przekazany obiekt jest zgodny z warunkami zdefiniowanymi dla delegata.  Elementy bieżącego <xref:System.Collections.Generic.List%601> są indywidualnie przekazywane do <xref:System.Predicate%601> delegować. Pełnomocnik ma podpis:  
  
```csharp  
public bool methodName(T obj)  
```  
  
```vb  
Public Function methodName(obj As T) As Boolean  
```  
  
 Ta metoda przeprowadza wyszukiwanie liniowe; w związku z tym, ta metoda jest O (*n*) operacji, gdzie *n* jest `count`.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano `Employee` klasy przy użyciu dwóch pól `Name` i `Id`. Umożliwia on również definiowanie `EmployeeSearch` klasy za pomocą pojedynczej metody `StartsWith`, oznacza to, czy `Employee.Name` pola zaczyna się podanym podciągiem, która jest dostarczana do `EmployeeSearch` konstruktora klasy. Należy pamiętać podpis tej metody  
  
```csharp  
public bool StartsWith(Employee e)  
```  
  
```vb  
Public Function StartsWith(e As Employee) As Boolean  
```  
  
 odnosi się do podpis delegata, który może być przekazywany do <xref:System.Collections.Generic.List%601.FindIndex%2A> metody. Przykład tworzy `List<Employee>` obiektów, dodaje wiele `Employee` objets go, a następnie wywołania <xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29> metodę dwa razy, aby wyszukać całej kolekcji (czyli elementów członkowskich z indeksu od 0 do indeksu <xref:System.Collections.Generic.List%601.Count%2A> - 1). Po raz pierwszy, wyszukuje pierwszy `Employee` którego `Name` pola zaczyna się od "J"; po raz drugi, wyszukuje pierwszy `Employee` którego `Name` pola zaczyna się od "Ju".  
  
 [!code-csharp[System.Collections.Generic.List.FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/cs/FindIndex1.cs#1)]
 [!code-vb[System.Collections.Generic.List.FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/vb/FindIndex1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> znajduje się poza zakresem prawidłowych indeksów dla <see cref="T:System.Collections.Generic.List`1" />.  
  
—lub— 
 <paramref name="count" /> jest mniejsza niż 0.  
  
—lub— 
 <paramref name="startIndex" /> i <paramref name="count" /> nie określają prawidłowej sekcji w <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLast">
      <MemberSignature Language="C#" Value="public T FindLast (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T FindLast(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLast (match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T FindLast(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindLast : Predicate&lt;'T&gt; -&gt; 'T" Usage="list.FindLast match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match"><see cref="T:System.Predicate`1" /> Delegat definiujący warunki elementu do wyszukania.</param>
        <summary>Wyszukuje element, który pasuje do warunków zdefiniowanych przez określony predykat i zwraca ostatnie wystąpienie w ramach całego <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>Ostatni element, który pasuje do warunków zdefiniowanych przez określony predykat, jeśli znaleziono; w przeciwnym razie wartość domyślna dla typu <paramref name="T" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601> Jest delegatem metody, która zwraca `true` jeśli przekazany obiekt jest zgodny z warunkami zdefiniowanymi dla delegata.  Elementy bieżącego <xref:System.Collections.Generic.List%601> są indywidualnie przekazywane do <xref:System.Predicate%601> delegata, przenoszenie do tyłu w <xref:System.Collections.Generic.List%601>, począwszy od ostatniego elementu, a kończąc na pierwszy element.  Przetwarzanie jest zatrzymywany, gdy zostanie znalezione dopasowanie.  
  
> [!IMPORTANT]
>  Podczas wyszukiwania listę zawierającą typy wartości, upewnij się, że wartość domyślna dla typu nie spełniają predykat wyszukiwania. W przeciwnym razie jest sposobem rozróżnienia wartość z domyślną wskazującą, że nie znaleziono dopasowania i element listy, który stanie się mają wartość domyślną dla typu. Jeśli wartości domyślne spełniają predykat wyszukiwania, użyj <xref:System.Collections.Generic.List%601.FindLastIndex%2A> metody zamiast tego.  
  
 Ta metoda przeprowadza wyszukiwanie liniowe; w związku z tym, ta metoda jest O (*n*) operacji, gdzie *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano metody Znajdź <xref:System.Collections.Generic.List%601> klasy. Przykład <xref:System.Collections.Generic.List%601> klasa zawiera `book` obiektów klasy `Book`, przy użyciu danych z [przykładowy plik XML: Książki (LINQ to XML)](https://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). `FillList` Metoda w przykładzie wykorzystuje [LINQ to XML](https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) można przeanalizować wartości z pliku XML do wartości właściwości `book` obiektów.  
  
 W poniższej tabeli opisano przykłady związane z metody wyszukiwania.  
  
|Metoda|Przykład|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Umożliwia znalezienie książki przy użyciu Identyfikatora `IDToFind` predykatu delegata.<br /><br /> Przykład w języku C# używa delegata anonimowego.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Znajdź wszystkie książek, że których `Genre` właściwość jest "Computer" przy użyciu `FindComputer` predykatu delegata.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Znajduje ostatni książki w kolekcji zawierającej daty opublikowania, przed 2001, przy użyciu `PubBefore2001` predykatu delegata.<br /><br /> Przykład w języku C# używa delegata anonimowego.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Znajduje indeks pierwszego książki komputera przy użyciu `FindComputer` predykatu delegata.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Znajduje indeks ostatniego komputera książki przy użyciu `FindComputer` predykatu delegata.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Znajduje indeks pierwszego komputera książki w drugim, połowa kolekcji, za pomocą `FindComputer` predykatu delegata.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Znajduje indeks ostatniego książki komputera w ciągu sekundy, połowa kolekcji, za pomocą `FindComputer` predykatu delegata.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindLastIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindLastIndex">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wyszukuje element, który pasuje do warunków zdefiniowanych przez określony predykat i zwraca liczony od zera indeks ostatniego wystąpienia w ramach <see cref="T:System.Collections.Generic.List`1" /> lub jego część.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindLastIndex">
      <MemberSignature Language="C#" Value="public int FindLastIndex (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindLastIndex(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLastIndex(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLastIndex (match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindLastIndex(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindLastIndex : Predicate&lt;'T&gt; -&gt; int" Usage="list.FindLastIndex match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match"><see cref="T:System.Predicate`1" /> Delegat definiujący warunki elementu do wyszukania.</param>
        <summary>Wyszukuje element, który pasuje do warunków zdefiniowanych przez określony predykat i zwraca liczony od zera indeks ostatniego wystąpienia w ramach całego <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>Liczony od zera indeks ostatniego wystąpienia elementu, który pasuje do warunków zdefiniowanych przez <paramref name="match" />, jeśli je znaleziono; w przeciwnym razie wartość -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> Jest przeszukiwany w tył od ostatniego elementu, a kończąc na pierwszy element.  
  
 <xref:System.Predicate%601> Jest delegatem metody, która zwraca `true` jeśli przekazany obiekt jest zgodny z warunkami zdefiniowanymi dla delegata.  Elementy bieżącego <xref:System.Collections.Generic.List%601> są indywidualnie przekazywane do <xref:System.Predicate%601> delegować.  
  
 Ta metoda przeprowadza wyszukiwanie liniowe; w związku z tym, ta metoda jest O (*n*) operacji, gdzie *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano metody Znajdź <xref:System.Collections.Generic.List%601> klasy. Przykład <xref:System.Collections.Generic.List%601> klasa zawiera `book` obiektów klasy `Book`, przy użyciu danych z [przykładowy plik XML: Książki (LINQ to XML)](https://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). `FillList` Metoda w przykładzie wykorzystuje [LINQ to XML](https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) można przeanalizować wartości z pliku XML do wartości właściwości `book` obiektów.  
  
 W poniższej tabeli opisano przykłady związane z metody wyszukiwania.  
  
|Metoda|Przykład|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Umożliwia znalezienie książki przy użyciu Identyfikatora `IDToFind` predykatu delegata.<br /><br /> Przykład w języku C# używa delegata anonimowego.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Znajdź wszystkie książek, że których `Genre` właściwość jest "Computer" przy użyciu `FindComputer` predykatu delegata.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Znajduje ostatni książki w kolekcji zawierającej daty opublikowania, przed 2001, przy użyciu `PubBefore2001` predykatu delegata.<br /><br /> Przykład w języku C# używa delegata anonimowego.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Znajduje indeks pierwszego książki komputera przy użyciu `FindComputer` predykatu delegata.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Znajduje indeks ostatniego komputera książki przy użyciu `FindComputer` predykatu delegata.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Znajduje indeks pierwszego komputera książki w drugim, połowa kolekcji, za pomocą `FindComputer` predykatu delegata.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Znajduje indeks ostatniego książki komputera w ciągu sekundy, połowa kolekcji, za pomocą `FindComputer` predykatu delegata.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex">
      <MemberSignature Language="C#" Value="public int FindLastIndex (int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindLastIndex(int32 startIndex, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLastIndex (startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindLastIndex(int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindLastIndex : int * Predicate&lt;'T&gt; -&gt; int" Usage="list.FindLastIndex (startIndex, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">Wartość początkowa indeksu zaczynającego się od zera dla wyszukiwania wstecznego.</param>
        <param name="match"><see cref="T:System.Predicate`1" /> Delegat definiujący warunki elementu do wyszukania.</param>
        <summary>Wyszukuje element, który pasuje do warunków zdefiniowanych przez określony predykat i zwraca liczony od zera indeks ostatniego wystąpienia w zakresie elementów w <see cref="T:System.Collections.Generic.List`1" /> który rozciąga się od pierwszego elementu zgodnie z określonym indeksem.</summary>
        <returns>Liczony od zera indeks ostatniego wystąpienia elementu, który pasuje do warunków zdefiniowanych przez <paramref name="match" />, jeśli je znaleziono; w przeciwnym razie wartość -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> Jest wyszukiwanych ze starszymi wersjami zaczynając od `startIndex` a kończąc na pierwszy element.  
  
 <xref:System.Predicate%601> Jest delegatem metody, która zwraca `true` jeśli przekazany obiekt jest zgodny z warunkami zdefiniowanymi dla delegata.  Elementy bieżącego <xref:System.Collections.Generic.List%601> są indywidualnie przekazywane do <xref:System.Predicate%601> delegować.  
  
 Ta metoda przeprowadza wyszukiwanie liniowe; w związku z tym, ta metoda jest O (*n*) operacji, gdzie *n* jest liczba elementów od początku <xref:System.Collections.Generic.List%601> do `startIndex`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> znajduje się poza zakresem prawidłowych indeksów dla <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex">
      <MemberSignature Language="C#" Value="public int FindLastIndex (int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindLastIndex(int32 startIndex, int32 count, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FindLastIndex (startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindLastIndex(int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.FindLastIndex : int * int * Predicate&lt;'T&gt; -&gt; int" Usage="list.FindLastIndex (startIndex, count, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">Wartość początkowa indeksu zaczynającego się od zera dla wyszukiwania wstecznego.</param>
        <param name="count">Liczba elementów w sekcji do wyszukania.</param>
        <param name="match"><see cref="T:System.Predicate`1" /> Delegat definiujący warunki elementu do wyszukania.</param>
        <summary>Wyszukuje element, który pasuje do warunków zdefiniowanych przez określony predykat i zwraca liczony od zera indeks ostatniego wystąpienia w zakresie elementów w <see cref="T:System.Collections.Generic.List`1" /> , zawierający określoną liczbę elementów, a kończy się na określony indeks.</summary>
        <returns>Liczony od zera indeks ostatniego wystąpienia elementu, który pasuje do warunków zdefiniowanych przez <paramref name="match" />, jeśli je znaleziono; w przeciwnym razie wartość -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> Jest wyszukiwanych ze starszymi wersjami zaczynając od `startIndex` i kończące się wierszem `startIndex` minus `count` plus 1, jeśli `count` jest większa niż 0.  
  
 <xref:System.Predicate%601> Jest delegatem metody, która zwraca `true` jeśli przekazany obiekt jest zgodny z warunkami zdefiniowanymi dla delegata.  Elementy bieżącego <xref:System.Collections.Generic.List%601> są indywidualnie przekazywane do <xref:System.Predicate%601> delegować.  
  
 Ta metoda przeprowadza wyszukiwanie liniowe; w związku z tym, ta metoda jest O (*n*) operacji, gdzie *n* jest `count`.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano metody Znajdź <xref:System.Collections.Generic.List%601> klasy. Przykład <xref:System.Collections.Generic.List%601> klasa zawiera `book` obiektów klasy `Book`, przy użyciu danych z [przykładowy plik XML: Książki (LINQ to XML)](https://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). `FillList` Metoda w przykładzie wykorzystuje [LINQ to XML](https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) można przeanalizować wartości z pliku XML do wartości właściwości `book` obiektów.  
  
 W poniższej tabeli opisano przykłady związane z metody wyszukiwania.  
  
|Metoda|Przykład|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Umożliwia znalezienie książki przy użyciu Identyfikatora `IDToFind` predykatu delegata.<br /><br /> Przykład w języku C# używa delegata anonimowego.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Znajdź wszystkie książek, że których `Genre` właściwość jest "Computer" przy użyciu `FindComputer` predykatu delegata.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Znajduje ostatni książki w kolekcji zawierającej daty opublikowania, przed 2001, przy użyciu `PubBefore2001` predykatu delegata.<br /><br /> Przykład w języku C# używa delegata anonimowego.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Znajduje indeks pierwszego książki komputera przy użyciu `FindComputer` predykatu delegata.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Znajduje indeks ostatniego komputera książki przy użyciu `FindComputer` predykatu delegata.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Znajduje indeks pierwszego komputera książki w drugim, połowa kolekcji, za pomocą `FindComputer` predykatu delegata.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Znajduje indeks ostatniego książki komputera w ciągu sekundy, połowa kolekcji, za pomocą `FindComputer` predykatu delegata.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> znajduje się poza zakresem prawidłowych indeksów dla <see cref="T:System.Collections.Generic.List`1" />.  
  
—lub— 
 <paramref name="count" /> jest mniejsza niż 0.  
  
—lub— 
 <paramref name="startIndex" /> i <paramref name="count" /> nie określają prawidłowej sekcji w <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="Overload:System.Collections.Generic.List`1.FindIndex" />
        <altmember cref="Overload:System.Collections.Generic.List`1.BinarySearch" />
        <altmember cref="Overload:System.Collections.Generic.List`1.IndexOf" />
        <altmember cref="Overload:System.Collections.Generic.List`1.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="ForEach">
      <MemberSignature Language="C#" Value="public void ForEach (Action&lt;T&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ForEach(class System.Action`1&lt;!T&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.ForEach(System.Action{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub ForEach (action As Action(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ForEach(Action&lt;T&gt; ^ action);" />
      <MemberSignature Language="F#" Value="member this.ForEach : Action&lt;'T&gt; -&gt; unit" Usage="list.ForEach action" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="action"><see cref="T:System.Action`1" /> Delegata do wykonania dla każdego elementu <see cref="T:System.Collections.Generic.List`1" />.</param>
        <summary>Wykonuje określoną czynność dla każdego elementu <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Action%601> Jest przekazany obiekt delegowany do metody, która wykonuje akcję na obiekcie.  Elementy bieżącego <xref:System.Collections.Generic.List%601> są indywidualnie przekazywane do <xref:System.Action%601> delegować.  
  
 Ta metoda jest O (*n*) operacji, gdzie *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 Modyfikowanie kolekcji źródłowej w treści <xref:System.Action%601> delegata nie jest obsługiwane i powoduje niezdefiniowane zachowanie.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie <xref:System.Action%601> delegata do drukowania zawartości <xref:System.Collections.Generic.List%601> obiektu. W tym przykładzie `Print` metoda jest używana do wyświetlania zawartości listy do konsoli.  
  
> [!NOTE]
>  Oprócz wyświetlania zawartości przy użyciu `Print` metody przykład C# pokazano użycie do wyświetlania wyników do konsoli.  
  
 [!code-csharp[System.Action_PrintExample#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Action_PrintExample/cs/action.cs#01)]
 [!code-vb[System.Action_PrintExample#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Action_PrintExample/vb/action.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="action" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Zmodyfikowano element w kolekcji.</exception>
        <altmember cref="T:System.Action`1" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;T&gt;.Enumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Collections.Generic.List`1/Enumerator&lt;!T&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As List(Of T).Enumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;T&gt;::Enumerator GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; System.Collections.Generic.List&lt;'T&gt;.Enumerator" Usage="list.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;T&gt;+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca moduł wyliczający, który iteruje po <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>A <see cref="T:System.Collections.Generic.List`1.Enumerator" /> dla <see cref="T:System.Collections.Generic.List`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `foreach` Instrukcja języka C# (`for each` w języku C++, `For Each` w języku Visual Basic) powoduje ukrycie złożoności modułów wyliczających. W związku z tym, za pomocą `foreach` jest to zalecane, zamiast bezpośredniego wykonywania operacji modułu wyliczającego.  
  
 Moduły wyliczające mogą służyć do odczytu danych w kolekcji, ale nie można za ich pomocą modyfikować kolekcji źródłowej.  
  
 Początkowo moduł wyliczający jest umieszczony przed pierwszym elementem w kolekcji. W tym miejscu <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> właściwość jest niezdefiniowana. W związku z tym, należy wywołać <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> metody wyprzedzeniem modułu wyliczającego do pierwszego elementu kolekcji przed odczytaniem wartości właściwości <xref:System.Collections.Generic.List%601.Enumerator.Current%2A>.  
  
 <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> Właściwość zwraca tego samego obiektu, dopóki nie <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> jest wywoływana. <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> Ustawia <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> do następnego elementu.  
  
 Jeśli <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> przebiegów koniec kolekcji, moduł wyliczający jest umieszczany za ostatnim elementem w kolekcji i <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> zwraca `false`. Gdy moduł wyliczający jest w tym miejscu, kolejne wywołania <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> również zwracać `false`. Jeśli ostatnie wywołanie <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> zwrócił `false`, <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> jest niezdefiniowana. Nie można ustawić <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> do pierwszego elementu w kolekcji; należy utworzyć nowe wystąpienie modułu wyliczającego zamiast tego.  
  
 Moduł wyliczający zachowuje ważność tak długo, jak długo kolekcja pozostaje niezmieniona. Jeśli zmiany zostały wprowadzone do kolekcji, takie jak dodawanie, modyfikowanie lub usuwanie elementów, moduł wyliczający jest nieodwracalnie unieważnione, a następne wywołanie <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> lub <xref:System.Collections.Generic.List%601.Enumerator.System%23Collections%23IEnumerator%23Reset%2A> zgłasza <xref:System.InvalidOperationException>.  
  
 Moduł wyliczający nie ma wyłącznego dostępu do kolekcji, w związku z tym wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość. Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania.  Aby zezwolić wielu wątkom na dostęp do kolekcji w celu odczytu i zapisu danych, należy zaimplementować własny mechanizm synchronizacji.  
  
 Domyślne implementacje kolekcji w <xref:System.Collections.Generic?displayProperty=nameWithType> przestrzeni nazw nie są zsynchronizowane.  
  
 Ta metoda jest operacją O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.List`1.Enumerator" />
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="GetRange">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;T&gt; GetRange (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;!T&gt; GetRange(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRange (index As Integer, count As Integer) As List(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;T&gt; ^ GetRange(int index, int count);" />
      <MemberSignature Language="F#" Value="member this.GetRange : int * int -&gt; System.Collections.Generic.List&lt;'T&gt;" Usage="list.GetRange (index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Liczony od zera <see cref="T:System.Collections.Generic.List`1" /> indeksu, który rozpoczyna się zakres.</param>
        <param name="count">Liczba elementów w zakresie.</param>
        <summary>Tworzy kopię pobieżną zakres elementów w źródle <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>Kopia pobieżna zakres elementów w źródle <see cref="T:System.Collections.Generic.List`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Płytką kopię kolekcji typów referencyjnych lub być podzbiorem wartości tej kolekcji, zawiera tylko odwołania do elementów kolekcji. Same obiekty nie są kopiowane. Punkt odniesienia w nowej listy na te same obiekty jako odwołania w oryginalnej listy.  
  
 Płytką kopię kolekcji typów wartości lub być podzbiorem wartości tej kolekcji zawiera elementy kolekcji. Jednakże jeśli elementy kolekcji zawiera odwołania do innych obiektów, te obiekty nie są kopiowane. Odwołania w elementach nowej kolekcji wskazują na te same obiekty jako odwołania w elementach oryginalnej kolekcji.  
  
 Z kolei kopię głęboką kolekcji kopiuje elementy i wszystko bezpośrednio lub pośrednio odwołuje się elementów.  
  
 Ta metoda jest O (*n*) operacji, gdzie *n* jest `count`.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Collections.Generic.List%601.GetRange%2A> metody i innych metod <xref:System.Collections.Generic.List%601> klasę, która działa na zakresach. Na koniec przykładzie <xref:System.Collections.Generic.List%601.GetRange%2A> metoda jest używana do pobierania trzy elementy z listy, począwszy od indeksu w lokalizacji 2. <xref:System.Collections.Generic.List%601.ToArray%2A> Metoda jest wywoływana w wynikowym <xref:System.Collections.Generic.List%601>, tworząc tablicę trzy elementy. Elementy tablicy są wyświetlane.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> jest mniejsza niż 0.  
  
—lub— 
 <paramref name="count" /> jest mniejsza niż 0.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> i <paramref name="count" /> określa prawidłowy zakres elementów w <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca liczony od zera indeks pierwszego wystąpienia wartości w <see cref="T:System.Collections.Generic.List`1" /> lub w jego części.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.IndexOf(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOf(T item);" />
      <MemberSignature Language="F#" Value="abstract member IndexOf : 'T -&gt; int&#xA;override this.IndexOf : 'T -&gt; int" Usage="list.IndexOf item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.IndexOf(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Obiekt do zlokalizowania w <see cref="T:System.Collections.Generic.List`1" />. Wartość może być <see langword="null" /> dla typów odwołań.</param>
        <summary>Wyszukuje określonego obiektu i zwraca liczony od zera indeks pierwszego wystąpienia w ramach całego <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>Liczony od zera indeks pierwszego wystąpienia <paramref name="item" /> w obrębie całego <see cref="T:System.Collections.Generic.List`1" />, jeśli je znaleziono; w przeciwnym razie wartość -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> Przeszukiwany jest do przodu zaczynając od pierwszego elementu, a kończąc na ostatnim elemencie.  
  
 Ta metoda określa równość za pomocą domyślny moduł porównujący równość <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> dla `T`, typ wartości na liście.  
  
 Ta metoda przeprowadza wyszukiwanie liniowe; w związku z tym, ta metoda jest O (*n*) operacji, gdzie *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano wszystkich trzech przeciążeń <xref:System.Collections.Generic.List%601.IndexOf%2A> metody. A <xref:System.Collections.Generic.List%601> ciągów jest tworzona, jeden wpis, który pojawia się dwukrotnie lokalizacją indeksu 0 i lokalizacją indeksu 5. <xref:System.Collections.Generic.List%601.IndexOf%28%600%29> Przeciążenie metody przeszukuje listę od początku, a znajduje pierwsze wystąpienie ciągu. <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%29> Metoda przeciążenia służy do wyszukiwania listy rozpoczynający się z lokalizacją indeksu 3 i przechodzić do końca listy i znajduje drugie wystąpienie ciągu. Na koniec <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> metoda przeciążenia służy do wyszukiwania szeroką gamę dwóch wpisów, rozpoczynając od lokalizacji indeksu dwóch; zwraca wartość -1, ponieważ żadnych wystąpień wyszukiwanego ciągu w tym zakresie.  
  
 [!code-cpp[List\`1_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_IndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Wykonywanie niezależnych od kultury operacji na ciągach w kolekcjach</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (T item, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(!T item, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (item As T, index As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(T item, int index);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : 'T * int -&gt; int" Usage="list.IndexOf (item, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">Obiekt do zlokalizowania w <see cref="T:System.Collections.Generic.List`1" />. Wartość może być <see langword="null" /> dla typów odwołań.</param>
        <param name="index">Wartość początkowa indeksu zaczynającego się od zera dla wyszukiwania. 0 (zero) jest prawidłowa w pustej listy.</param>
        <summary>Wyszukuje określonego obiektu i zwraca liczony od zera indeks pierwszego wystąpienia w zakresie elementów w <see cref="T:System.Collections.Generic.List`1" /> który rozciąga się od określonego indeksu do ostatniego elementu.</summary>
        <returns>Liczony od zera indeks pierwszego wystąpienia <paramref name="item" /> w zakresie elementów w <see cref="T:System.Collections.Generic.List`1" /> rozciąga się od <paramref name="index" /> do ostatniego elementu, jeśli je znaleziono; w przeciwnym razie wartość -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> Jest przeszukiwany w przód od `index` a kończąc na do ostatniego elementu.  
  
 Ta metoda określa równość za pomocą domyślny moduł porównujący równość <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> dla `T`, typ wartości na liście.  
  
 Ta metoda przeprowadza wyszukiwanie liniowe; w związku z tym, ta metoda jest O (*n*) operacji, gdzie *n* jest liczba elementów od `index` na końcu <xref:System.Collections.Generic.List%601>.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano wszystkich trzech przeciążeń <xref:System.Collections.Generic.List%601.IndexOf%2A> metody. A <xref:System.Collections.Generic.List%601> ciągów jest tworzona, jeden wpis, który pojawia się dwukrotnie lokalizacją indeksu 0 i lokalizacją indeksu 5. <xref:System.Collections.Generic.List%601.IndexOf%28%600%29> Przeciążenie metody przeszukuje listę od początku, a znajduje pierwsze wystąpienie ciągu. <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%29> Metoda przeciążenia służy do wyszukiwania listy rozpoczynający się z lokalizacją indeksu 3 i przechodzić do końca listy i znajduje drugie wystąpienie ciągu. Na koniec <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> metoda przeciążenia służy do wyszukiwania szeroką gamę dwóch wpisów, rozpoczynając od lokalizacji indeksu dwóch; zwraca wartość -1, ponieważ żadnych wystąpień wyszukiwanego ciągu w tym zakresie.  
  
 [!code-cpp[List\`1_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_IndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> znajduje się poza zakresem prawidłowych indeksów dla <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Wykonywanie niezależnych od kultury operacji na ciągach w kolekcjach</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (T item, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(!T item, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (item As T, index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(T item, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : 'T * int * int -&gt; int" Usage="list.IndexOf (item, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">Obiekt do zlokalizowania w <see cref="T:System.Collections.Generic.List`1" />. Wartość może być <see langword="null" /> dla typów odwołań.</param>
        <param name="index">Wartość początkowa indeksu zaczynającego się od zera dla wyszukiwania. 0 (zero) jest prawidłowa w pustej listy.</param>
        <param name="count">Liczba elementów w sekcji do wyszukania.</param>
        <summary>Wyszukuje określonego obiektu i zwraca liczony od zera indeks pierwszego wystąpienia w zakresie elementów w <see cref="T:System.Collections.Generic.List`1" /> , rozpoczyna się od określonego indeksu i zawiera określonej liczby elementów.</summary>
        <returns>Liczony od zera indeks pierwszego wystąpienia <paramref name="item" /> w zakresie elementów w <see cref="T:System.Collections.Generic.List`1" /> rozpoczynająca się w <paramref name="index" /> i zawiera <paramref name="count" /> liczby elementów, jeśli je znaleziono; w przeciwnym razie wartość -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> Jest przeszukiwany w przód od `index` i kończące się wierszem `index` oraz `count` minus 1, jeśli `count` jest większa niż 0.  
  
 Ta metoda określa równość za pomocą domyślny moduł porównujący równość <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> dla `T`, typ wartości na liście.  
  
 Ta metoda przeprowadza wyszukiwanie liniowe; w związku z tym, ta metoda jest O (*n*) operacji, gdzie *n* jest `count`.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano wszystkich trzech przeciążeń <xref:System.Collections.Generic.List%601.IndexOf%2A> metody. A <xref:System.Collections.Generic.List%601> ciągów jest tworzona, jeden wpis, który pojawia się dwukrotnie lokalizacją indeksu 0 i lokalizacją indeksu 5. <xref:System.Collections.Generic.List%601.IndexOf%28%600%29> Przeciążenie metody przeszukuje listę od początku, a znajduje pierwsze wystąpienie ciągu. <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%29> Metoda przeciążenia służy do wyszukiwania listy rozpoczynający się z lokalizacją indeksu 3 i przechodzić do końca listy i znajduje drugie wystąpienie ciągu. Na koniec <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> metoda przeciążenia służy do wyszukiwania szeroką gamę dwóch wpisów, rozpoczynając od lokalizacji indeksu dwóch; zwraca wartość -1, ponieważ żadnych wystąpień wyszukiwanego ciągu w tym zakresie.  
  
 [!code-cpp[List\`1_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_IndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> znajduje się poza zakresem prawidłowych indeksów dla <see cref="T:System.Collections.Generic.List`1" />.  
  
—lub— 
 <paramref name="count" /> jest mniejsza niż 0.  
  
—lub— 
 <paramref name="index" /> i <paramref name="count" /> nie określają prawidłowej sekcji w <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Wykonywanie niezależnych od kultury operacji na ciągach w kolekcjach</related>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public void Insert (int index, T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Insert(int32 index, !T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Insert (index As Integer, item As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Insert(int index, T item);" />
      <MemberSignature Language="F#" Value="abstract member Insert : int * 'T -&gt; unit&#xA;override this.Insert : int * 'T -&gt; unit" Usage="list.Insert (index, item)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="index">Liczony od zera indeks, w którym <paramref name="item" /> powinien zostać wstawiony.</param>
        <param name="item">Obiekt do wstawienia. Wartość może być <see langword="null" /> dla typów odwołań.</param>
        <summary>Wstawia element do <see cref="T:System.Collections.Generic.List`1" /> pod określonym indeksem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> akceptuje `null` prawidłową wartość dla odwołania do typów i pozwala zduplikowane elementy.  
  
 Jeśli <xref:System.Collections.Generic.List%601.Count%2A> jest już równa <xref:System.Collections.Generic.List%601.Capacity%2A>, pojemność <xref:System.Collections.Generic.List%601> jest zwiększana o automatyczne ponowne przydzielanie wewnętrznego tablicy, a istniejące elementy są kopiowane do nowej tablicy, przed dodaniem nowego elementu.  
  
 Jeśli `index` jest równa <xref:System.Collections.Generic.List%601.Count%2A>, `item` zostanie dodany na końcu <xref:System.Collections.Generic.List%601>.  
  
 Ta metoda jest O (*n*) operacji, gdzie *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak dodawanie, usuwanie i wstawianie obiektu proste biznesowych w <xref:System.Collections.Generic.List%601>.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 W poniższym przykładzie pokazano <xref:System.Collections.Generic.List%601.Insert%2A> metoda wraz z różnych właściwości i metod <xref:System.Collections.Generic.List%601> klasy ogólnej. Po utworzeniu listy elementy są dodawane. <xref:System.Collections.Generic.List%601.Insert%2A> Metoda jest używana do Wstawianie elementu do środka listy. Element wstawiony jest duplikatem, później zostanie usunięty, za pomocą <xref:System.Collections.Generic.List%601.Remove%2A> metody.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> jest mniejsza niż 0.  
  
—lub— 
 <paramref name="index" /> jest większa niż <see cref="P:System.Collections.Generic.List`1.Count" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
      </Docs>
    </Member>
    <Member MemberName="InsertRange">
      <MemberSignature Language="C#" Value="public void InsertRange (int index, System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertRange(int32 index, class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub InsertRange (index As Integer, collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InsertRange(int index, System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberSignature Language="F#" Value="member this.InsertRange : int * seq&lt;'T&gt; -&gt; unit" Usage="list.InsertRange (index, collection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="index">Liczony od zera indeks, w którym należy dodać nowe elementy.</param>
        <param name="collection">Kolekcja, której elementy powinien zostać wstawiony do <see cref="T:System.Collections.Generic.List`1" />. Sama kolekcja nie może być <see langword="null" />, ale może zawierać elementy, które są <see langword="null" />, jeśli typ <paramref name="T" /> jest typem referencyjnym.</param>
        <summary>Wstawia elementy kolekcji do <see cref="T:System.Collections.Generic.List`1" /> pod określonym indeksem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> akceptuje `null` prawidłową wartość dla odwołania do typów i pozwala zduplikowane elementy.  
  
 Jeśli nowy <xref:System.Collections.Generic.List%601.Count%2A> (bieżący <xref:System.Collections.Generic.List%601.Count%2A> plus rozmiar kolekcji) będą większe niż <xref:System.Collections.Generic.List%601.Capacity%2A>, pojemność <xref:System.Collections.Generic.List%601> jest zwiększana o automatyczne ponowne przydzielanie wewnętrznego tablicy, aby uwzględnić nowe elementy i istniejące elementy są kopiowane do nowej tablicy, zanim nowe elementy są dodawane.  
  
 Jeśli `index` jest równa <xref:System.Collections.Generic.List%601.Count%2A>, elementy są dodawane na końcu <xref:System.Collections.Generic.List%601>.  
  
 Kolejność elementów w kolekcji jest zachowywana w <xref:System.Collections.Generic.List%601>.  
  
 Ta metoda jest O (*n* * *m*) operacji, gdzie *n* jest liczba elementów do dodania i *m* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Collections.Generic.List%601.InsertRange%2A> metody i różnych innych metod <xref:System.Collections.Generic.List%601> klasę, która działa na zakresach. Po utworzeniu listy i wypełniane przy użyciu nazwy kilka uspokajające pochłaniając zakładu produkcyjnego dinozaurów <xref:System.Collections.Generic.List%601.InsertRange%2A> metoda jest używana do wstawienia tablicę dinozaurów trzy pochłaniając mięsa zajadłymi do listy, zaczynając od indeksu lokalizacja 3.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="collection" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> jest mniejsza niż 0.  
  
—lub— 
 <paramref name="index" /> jest większa niż <see cref="P:System.Collections.Generic.List`1.Count" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public T this[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Item(index As Integer) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T default[int] { T get(int index); void set(int index, T value); };" />
      <MemberSignature Language="F#" Value="member this.Item(int) : 'T with get, set" Usage="System.Collections.Generic.List&lt;'T&gt;.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IList`1.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Liczony od zera indeks elementu, który ma zostać pobrany lub skonfigurowany.</param>
        <summary>Pobieranie lub konfigurowanie elementów pod określonym indeksem.</summary>
        <value>Element pod określonym indeksem.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> akceptuje `null` prawidłową wartość dla odwołania do typów i pozwala zduplikowane elementy.  
  
 Ta właściwość umożliwia dostęp do określonego elementu w kolekcji przy użyciu następującej składni: `myCollection[index]`.  
  
 Pobieranie wartości tej właściwości jest operacją O(1); Ustawianie właściwości również jest operacją O(1).  
  
   
  
## Examples  
 W przykładzie w tej sekcji pokazano <xref:System.Collections.Generic.List%601.Item%2A> właściwości (indeksatora w języku C#) i różnych innych właściwości i metod <xref:System.Collections.Generic.List%601> klasy ogólnej. Po liście został utworzony i wypełniony przy użyciu <xref:System.Collections.Generic.List%601.Add%2A> metody elementu są pobierane i wyświetlane przy użyciu <xref:System.Collections.Generic.List%601.Item%2A> właściwości. (Aby uzyskać przykład, który używa <xref:System.Collections.Generic.List%601.Item%2A> właściwość umożliwiająca ustawienie wartości elementu listy, zobacz <xref:System.Collections.Generic.List%601.AsReadOnly%2A>.)  
  
> [!NOTE]
>  Visual Basic, C# i C++ wszystkie mają składnię do uzyskiwania dostępu do <xref:System.Collections.Generic.List%601.Item%2A> właściwości bez użycia jego nazwa. Zamiast tego zmienną zawierającą <xref:System.Collections.Generic.List%601> jest używany, tak jakby tablicy.  
  
 W języku C# używa słowa kluczowego w celu zdefiniowania indeksatorów, a nie Implementowanie <xref:System.Collections.Generic.List%601.Item%2A> właściwości. Implementuje języka Visual Basic <xref:System.Collections.Generic.List%601.Item%2A> jako właściwość domyślną, która zapewnia taką samą funkcjonalność indeksowania.  
  
 [!code-csharp[List`1_Class#2](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#2)]
 [!code-vb[List`1_Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#2)]  
[!code-csharp[List`1_Class#3](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#3)]
[!code-vb[List`1_Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> jest mniejsza niż 0.  
  
—lub— 
 <paramref name="index" /> jest równa lub większa niż <see cref="P:System.Collections.Generic.List`1.Count" />.</exception>
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca liczony od zera indeks ostatniego wystąpienia wartości w <see cref="T:System.Collections.Generic.List`1" /> lub w jego części.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (item As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(T item);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : 'T -&gt; int" Usage="list.LastIndexOf item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Obiekt do zlokalizowania w <see cref="T:System.Collections.Generic.List`1" />. Wartość może być <see langword="null" /> dla typów odwołań.</param>
        <summary>Wyszukuje określonego obiektu i zwraca liczony od zera indeks ostatniego wystąpienia w ramach całego <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>Liczony od zera indeks ostatniego wystąpienia <paramref name="item" /> w obrębie całego <see cref="T:System.Collections.Generic.List`1" />, jeśli je znaleziono; w przeciwnym razie wartość -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> Jest przeszukiwany w tył od ostatniego elementu, a kończąc na pierwszy element.  
  
 Ta metoda określa równość za pomocą domyślny moduł porównujący równość <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> dla `T`, typ wartości na liście.  
  
 Ta metoda przeprowadza wyszukiwanie liniowe; w związku z tym, ta metoda jest O (*n*) operacji, gdzie *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano wszystkich trzech przeciążeń <xref:System.Collections.Generic.List%601.LastIndexOf%2A> metody. A <xref:System.Collections.Generic.List%601> ciągów jest tworzona, jeden wpis, który pojawia się dwukrotnie lokalizacją indeksu 0 i lokalizacją indeksu 5. <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%29> Przeciążenie metody przeszukuje całą listę od końca, a drugie wystąpienie ciągu znajduje. <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%29> Metoda przeciążenia służy do wyszukiwania na liście z poprzednimi wersjami, zaczynając od indeksu lokalizacja 3 i w dalszym ciągu początku listy, więc jego znajduje pierwsze wystąpienie ciągu na liście. Na koniec <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> metoda przeciążenia służy do wyszukiwania szeroką gamę cztery wpisy, rozpoczynając od lokalizacji indeksu 4 i rozszerzanie Wstecz (czyli wyszukuje elementy w lokalizacjach, 4, 3, 2 i 1); to wyszukiwanie zwraca wartość -1, ponieważ żadnych wystąpień wyszukiwania ciąg, w tym zakresie.  
  
 [!code-cpp[List\`1_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_LastIndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Wykonywanie niezależnych od kultury operacji na ciągach w kolekcjach</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (T item, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(!T item, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (item As T, index As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(T item, int index);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : 'T * int -&gt; int" Usage="list.LastIndexOf (item, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">Obiekt do zlokalizowania w <see cref="T:System.Collections.Generic.List`1" />. Wartość może być <see langword="null" /> dla typów odwołań.</param>
        <param name="index">Wartość początkowa indeksu zaczynającego się od zera dla wyszukiwania wstecznego.</param>
        <summary>Wyszukuje określonego obiektu i zwraca liczony od zera indeks ostatniego wystąpienia w zakresie elementów w <see cref="T:System.Collections.Generic.List`1" /> który rozciąga się od pierwszego elementu zgodnie z określonym indeksem.</summary>
        <returns>Liczony od zera indeks ostatniego wystąpienia <paramref name="item" /> w zakresie elementów w <see cref="T:System.Collections.Generic.List`1" /> rozciąga się od pierwszego elementu na <paramref name="index" />, jeśli je znaleziono; w przeciwnym razie wartość -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> Jest wyszukiwanych ze starszymi wersjami zaczynając od `index` a kończąc na pierwszy element.  
  
 Ta metoda określa równość za pomocą domyślny moduł porównujący równość <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> dla `T`, typ wartości na liście.  
  
 Ta metoda przeprowadza wyszukiwanie liniowe; w związku z tym, ta metoda jest O (*n*) operacji, gdzie *n* jest liczba elementów od początku <xref:System.Collections.Generic.List%601> do `index`.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano wszystkich trzech przeciążeń <xref:System.Collections.Generic.List%601.LastIndexOf%2A> metody. A <xref:System.Collections.Generic.List%601> ciągów jest tworzona, jeden wpis, który pojawia się dwukrotnie lokalizacją indeksu 0 i lokalizacją indeksu 5. <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%29> Przeciążenie metody przeszukuje całą listę od końca, a drugie wystąpienie ciągu znajduje. <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%29> Metoda przeciążenia służy do wyszukiwania na liście z poprzednimi wersjami, zaczynając od indeksu lokalizacja 3 i w dalszym ciągu początku listy, więc jego znajduje pierwsze wystąpienie ciągu na liście. Na koniec <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> metoda przeciążenia służy do wyszukiwania szeroką gamę cztery wpisy, rozpoczynając od lokalizacji indeksu 4 i rozszerzanie Wstecz (czyli wyszukuje elementy w lokalizacjach, 4, 3, 2 i 1); to wyszukiwanie zwraca wartość -1, ponieważ żadnych wystąpień wyszukiwania ciąg, w tym zakresie.  
  
 [!code-cpp[List\`1_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_LastIndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> znajduje się poza zakresem prawidłowych indeksów dla <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Wykonywanie niezależnych od kultury operacji na ciągach w kolekcjach</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (T item, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(!T item, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (item As T, index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(T item, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : 'T * int * int -&gt; int" Usage="list.LastIndexOf (item, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">Obiekt do zlokalizowania w <see cref="T:System.Collections.Generic.List`1" />. Wartość może być <see langword="null" /> dla typów odwołań.</param>
        <param name="index">Wartość początkowa indeksu zaczynającego się od zera dla wyszukiwania wstecznego.</param>
        <param name="count">Liczba elementów w sekcji do wyszukania.</param>
        <summary>Wyszukuje określonego obiektu i zwraca liczony od zera indeks ostatniego wystąpienia w zakresie elementów w <see cref="T:System.Collections.Generic.List`1" /> zawierający określoną liczbę elementów i kończy się pod określonym indeksem.</summary>
        <returns>Liczony od zera indeks ostatniego wystąpienia <paramref name="item" /> w zakresie elementów w <see cref="T:System.Collections.Generic.List`1" /> zawierający <paramref name="count" /> liczby elementów i kończy o godzinie <paramref name="index" />, jeśli je znaleziono; w przeciwnym razie wartość -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601> Jest wyszukiwanych ze starszymi wersjami zaczynając od `index` i kończące się wierszem `index` minus `count` plus 1, jeśli `count` jest większa niż 0.  
  
 Ta metoda określa równość za pomocą domyślny moduł porównujący równość <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> dla `T`, typ wartości na liście.  
  
 Ta metoda przeprowadza wyszukiwanie liniowe; w związku z tym, ta metoda jest O (*n*) operacji, gdzie *n* jest `count`.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano wszystkich trzech przeciążeń <xref:System.Collections.Generic.List%601.LastIndexOf%2A> metody. A <xref:System.Collections.Generic.List%601> ciągów jest tworzona, jeden wpis, który pojawia się dwukrotnie lokalizacją indeksu 0 i lokalizacją indeksu 5. <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%29> Przeciążenie metody przeszukuje całą listę od końca, a drugie wystąpienie ciągu znajduje. <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%29> Metoda przeciążenia służy do wyszukiwania na liście z poprzednimi wersjami, zaczynając od indeksu lokalizacja 3 i w dalszym ciągu początku listy, więc jego znajduje pierwsze wystąpienie ciągu na liście. Na koniec <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> metoda przeciążenia służy do wyszukiwania szeroką gamę 4 pozycje, rozpoczynając od lokalizacji indeksu 4 i rozszerzanie Wstecz (czyli wyszukuje elementy w lokalizacjach, 4, 3, 2 i 1); to wyszukiwanie zwraca wartość -1, ponieważ żadnych wystąpień wyszukiwania ciąg, w tym zakresie.  
  
 [!code-cpp[List\`1_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_LastIndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> znajduje się poza zakresem prawidłowych indeksów dla <see cref="T:System.Collections.Generic.List`1" />.  
  
—lub— 
 <paramref name="count" /> jest mniejsza niż 0.  
  
—lub— 
 <paramref name="index" /> i <paramref name="count" /> nie określają prawidłowej sekcji w <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.IndexOf(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Contains(`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Wykonywanie niezależnych od kultury operacji na ciągach w kolekcjach</related>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Remove(T item);" />
      <MemberSignature Language="F#" Value="abstract member Remove : 'T -&gt; bool&#xA;override this.Remove : 'T -&gt; bool" Usage="list.Remove item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">Obiekt do usunięcia z <see cref="T:System.Collections.Generic.List`1" />. Wartość może być <see langword="null" /> dla typów odwołań.</param>
        <summary>Usuwa pierwsze wystąpienie określonego obiektu z <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns><see langword="true" /> Jeśli <paramref name="item" /> zostanie pomyślnie usunięty; w przeciwnym razie <see langword="false" />.  Ta metoda zwraca też wartość <see langword="false" /> Jeśli <paramref name="item" /> nie został znaleziony w <see cref="T:System.Collections.Generic.List`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli typ `T` implementuje <xref:System.IEquatable%601> jest moduł porównujący równość ogólny interfejs <xref:System.IEquatable%601.Equals%2A> metody tego interfejsu; w przeciwnym razie jest domyślny moduł porównujący równość <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Ta metoda przeprowadza wyszukiwanie liniowe; w związku z tym, ta metoda jest O (*n*) operacji, gdzie *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak dodawanie, usuwanie i wstawianie obiektu proste biznesowych w <xref:System.Collections.Generic.List%601>.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 W poniższym przykładzie pokazano <xref:System.Collections.Generic.List%601.Remove%2A> metody. Kilka właściwości i metod <xref:System.Collections.Generic.List%601> ogólnej klasy są używane do dodawania, wstawiania i wyszukiwania listy. Po tych operacji lista zawiera zduplikowany. <xref:System.Collections.Generic.List%601.Remove%2A> Metoda służy do usuwania pierwsze wystąpienie zduplikowanego elementu, a zawartość jest wyświetlana. <xref:System.Collections.Generic.List%601.Remove%2A> Metoda zawsze usuwa pierwsze wystąpienie napotka.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Wykonywanie niezależnych od kultury operacji na ciągach w kolekcjach</related>
      </Docs>
    </Member>
    <Member MemberName="RemoveAll">
      <MemberSignature Language="C#" Value="public int RemoveAll (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 RemoveAll(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.RemoveAll(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveAll (match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int RemoveAll(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.RemoveAll : Predicate&lt;'T&gt; -&gt; int" Usage="list.RemoveAll match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match"><see cref="T:System.Predicate`1" /> Delegat definiujący warunki elementów do usunięcia.</param>
        <summary>Usuwa wszystkie elementy odpowiadające warunkom zdefiniowanym przez określony predykat.</summary>
        <returns>Liczba elementów usuniętych z <see cref="T:System.Collections.Generic.List`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601> Jest delegatem metody, która zwraca `true` jeśli przekazany obiekt jest zgodny z warunkami zdefiniowanymi dla delegata.  Elementy bieżącego <xref:System.Collections.Generic.List%601> są indywidualnie przekazywane do <xref:System.Predicate%601> delegata i elementy, które spełniają warunki są usuwane z <xref:System.Collections.Generic.List%601>.  
  
 Ta metoda przeprowadza wyszukiwanie liniowe; w związku z tym, ta metoda jest O (*n*) operacji, gdzie *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Collections.Generic.List%601.RemoveAll%2A> metody i kilka innych metod, które używają <xref:System.Predicate%601> Delegat ogólny.  
  
 A <xref:System.Collections.Generic.List%601> ciągów jest tworzona, zawierająca 8 nazw dinozaurów, dwa z nich (w pozycjach 1 i 5) kończy się ciągiem "saurus". W przykładzie zdefiniowano również metodę wyszukiwania predykatów o nazwie `EndsWithSaurus`, który przyjmuje parametr ciąg i zwraca wartość logiczną wskazującą, czy ciąg wejściowy kończy się na "saurus".  
  
 <xref:System.Collections.Generic.List%601.Find%2A>, <xref:System.Collections.Generic.List%601.FindLast%2A>, I <xref:System.Collections.Generic.List%601.FindAll%2A> metody są używane do wyszukiwania na liście metodę wyszukiwania predykatów.  
  
 <xref:System.Collections.Generic.List%601.RemoveAll%2A> Metoda jest używana, aby usunąć wszystkie wpisy, które kończą się ciągiem "saurus". Przechodzi przez listę od początku, przekazywać z kolei do każdego elementu `EndsWithSaurus` metody. Element zostanie usunięty, jeśli `EndsWithSaurus` metoda zwraca `true`.  
  
> [!NOTE]
>  W języku C# i Visual Basic nie jest niezbędne do utworzenia `Predicate<string>` delegowanie (`Predicate(Of String)` w języku Visual Basic) jawnie. Te języki wnioskują o poprawnym delegacie z kontekstu i tworzone automatycznie.  
  
 Na koniec <xref:System.Collections.Generic.List%601.Exists%2A> metoda sprawdza, czy istnieją Brak zobowiązań na liście, które kończą się ciągiem "saurus".  
  
 [!code-cpp[List\`1_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[List\`1_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_FindEtAl/cs/source.cs#1)]
 [!code-vb[List\`1_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
        <altmember cref="T:System.Predicate`1" />
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public void RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAt (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveAt(int index);" />
      <MemberSignature Language="F#" Value="abstract member RemoveAt : int -&gt; unit&#xA;override this.RemoveAt : int -&gt; unit" Usage="list.RemoveAt index" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)</InterfaceMember>
        <InterfaceMember>M:System.Collections.IList.RemoveAt(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Liczony od zera indeks elementu do usunięcia.</param>
        <summary>Usuwa element o określonym indeksie <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy wywołujesz <xref:System.Collections.Generic.List%601.RemoveAt%2A> usuwania elementu, pozostałe elementy na liście są numerowane zastąpić usuniętego elementu. Na przykład jeśli usuniesz element o indeksie 3, element o indeksie 4 jest przenoszony 3 pozycji. Ponadto liczba elementów na liście (reprezentowane przez <xref:System.Collections.Generic.List%601.Count%2A> właściwość) została zmniejszona o 1.  
  
 Ta metoda jest O (*n*) operacji, gdzie *n* jest (<xref:System.Collections.Generic.List%601.Count%2A> - `index`).  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak dodawanie, usuwanie i wstawianie obiektu proste biznesowych w <xref:System.Collections.Generic.List%601>.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> jest mniejsza niż 0.  
  
—lub— 
 <paramref name="index" /> jest równa lub większa niż <see cref="P:System.Collections.Generic.List`1.Count" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.Add(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveRange">
      <MemberSignature Language="C#" Value="public void RemoveRange (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveRange(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveRange (index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveRange(int index, int count);" />
      <MemberSignature Language="F#" Value="member this.RemoveRange : int * int -&gt; unit" Usage="list.RemoveRange (index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Liczony od zera indeks początkowy zakresu elementów do usunięcia.</param>
        <param name="count">Liczba elementów do usunięcia.</param>
        <summary>Usuwa zakres elementów z <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Elementy są usuwane, a wszystkie elementy przestrzeganie ich w <xref:System.Collections.Generic.List%601> ich indeksy zmniejszona `count`.  
  
 Ta metoda jest O (*n*) operacji, gdzie *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Collections.Generic.List%601.RemoveRange%2A> metody i różnych innych metod <xref:System.Collections.Generic.List%601> klasę, która działa na zakresach. Po utworzeniu i modyfikacji, listy <xref:System.Collections.Generic.List%601.RemoveRange%2A> metoda służy do usuwania dwa elementy na liście, rozpoczynając od indeksu w lokalizacji 2.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> jest mniejsza niż 0.  
  
—lub— 
 <paramref name="count" /> jest mniejsza niż 0.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> i <paramref name="count" /> określa prawidłowy zakres elementów w <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Remove(`0)" />
        <altmember cref="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
        <altmember cref="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
        <altmember cref="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Reverse">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Odwraca kolejność elementów w <see cref="T:System.Collections.Generic.List`1" /> lub jego część.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public void Reverse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reverse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Reverse" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reverse ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Reverse();" />
      <MemberSignature Language="F#" Value="member this.Reverse : unit -&gt; unit" Usage="list.Reverse " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odwraca kolejność elementów w całej <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa <xref:System.Array.Reverse%2A?displayProperty=nameWithType> odwrócić kolejność elementów.  
  
 Ta metoda jest O (*n*) operacji, gdzie *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano oba przeciążenia <xref:System.Collections.Generic.List%601.Reverse%2A> metody. W przykładzie jest tworzony <xref:System.Collections.Generic.List%601> z ciągów i dodaje sześć ciągów. <xref:System.Collections.Generic.List%601.Reverse> Metoda przeciążenia służy do odwrócić na liście, a następnie <xref:System.Collections.Generic.List%601.Reverse%28System.Int32%2CSystem.Int32%29> metoda przeciążenia służy do odwrócić w środku listy, zaczynając od elementu 1 i obejmującej cztery elementy.  
  
 [!code-cpp[List\`1_Reverse#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Reverse/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Reverse#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Reverse/cs/source.cs#1)]
 [!code-vb[List\`1_Reverse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Reverse/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public void Reverse (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reverse(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Reverse(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reverse (index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Reverse(int index, int count);" />
      <MemberSignature Language="F#" Value="member this.Reverse : int * int -&gt; unit" Usage="list.Reverse (index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Liczony od zera indeks początkowy zakresu, aby odwrócić.</param>
        <param name="count">Liczba elementów w zakresie, aby odwrócić.</param>
        <summary>Odwraca kolejność elementów w określonym zakresie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda używa <xref:System.Array.Reverse%2A?displayProperty=nameWithType> odwrócić kolejność elementów.  
  
 Ta metoda jest O (*n*) operacji, gdzie *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano oba przeciążenia <xref:System.Collections.Generic.List%601.Reverse%2A> metody. W przykładzie jest tworzony <xref:System.Collections.Generic.List%601> z ciągów i dodaje sześć ciągów. <xref:System.Collections.Generic.List%601.Reverse> Metoda przeciążenia służy do odwrócić na liście, a następnie <xref:System.Collections.Generic.List%601.Reverse%28System.Int32%2CSystem.Int32%29> metoda przeciążenia służy do odwrócić w środku listy, zaczynając od elementu 1 i obejmującej cztery elementy.  
  
 [!code-cpp[List\`1_Reverse#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Reverse/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Reverse#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Reverse/cs/source.cs#1)]
 [!code-vb[List\`1_Reverse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Reverse/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> jest mniejsza niż 0.  
  
—lub— 
 <paramref name="count" /> jest mniejsza niż 0.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> i <paramref name="count" /> określa prawidłowy zakres elementów w <see cref="T:System.Collections.Generic.List`1" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Sort">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sortuje elementy lub części elementów w <see cref="T:System.Collections.Generic.List`1" /> przy użyciu dowolnego określonego lub domyślnych <see cref="T:System.Collections.Generic.IComparer`1" /> implementacji lub podana <see cref="T:System.Comparison`1" /> delegata do porównywania elementów listy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort();" />
      <MemberSignature Language="F#" Value="member this.Sort : unit -&gt; unit" Usage="list.Sort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sortuje elementów w całej <see cref="T:System.Collections.Generic.List`1" /> przy użyciu domyślna funkcja porównująca.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wykorzystuje domyślny moduł porównujący <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> dla typu `T` można określić kolejność elementów listy. <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> Sprawdzenia właściwości tego, czy typ `T` implementuje <xref:System.IComparable%601> ogólny interfejs i wykorzystuje tę implementację, jeśli jest dostępny.  W przeciwnym razie <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> kontroli tego, czy typ `T` implementuje <xref:System.IComparable> interfejsu.  Jeśli typ `T` nie implementuje albo interfejsu <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> zgłasza <xref:System.InvalidOperationException>.  
  
 Ta metoda używa <xref:System.Array.Sort%2A?displayProperty=nameWithType> metody, która ma zastosowanie sortowania w następujący sposób:  
  
-   Jeśli rozmiar partycji wynosi mniej niż 16 elementów, używa algorytmu sortowania wstawiania.  
  
-   Jeśli liczba partycji przekracza 2 dziennika *n*, gdzie *n* to zakres tablicy wejściowej, używa algorytmu sortowania przez Kopcowanie.  
  
-   W przeciwnym razie używa algorytmu sortowania.  
  
 Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana. Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.  
  
 Średnio, ta metoda jest O (*n* dziennika *n*) operacji, gdzie *n* jest <xref:System.Collections.Generic.List%601.Count%2A>; w najgorszym przypadku jest O (*n* <sup>2</sup>) operacji.  
  
   
  
## Examples  
 Poniższy przykład dodaje kilka nazw, aby `List<String>` object, wyświetla listę w kolejności nieposortowana wywołuje <xref:System.Collections.Generic.List%601.Sort%2A> metody, a następnie wyświetla posortowaną listę.  
  
 [!code-csharp[System.Collections.Generic.List.Sort#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.sort/cs/Sort1.cs#2)]
 [!code-vb[System.Collections.Generic.List.Sort#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.sort/vb/Sort1.vb#2)]  
  
 Poniższy przykład demonstruje <xref:System.Collections.Generic.List%601.Sort> i <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> przeciążenia metody do obiektu proste biznesowych. Wywoływanie <xref:System.Collections.Generic.List%601.Sort> metody powoduje użycie domyślny moduł porównujący dla typu części i <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> metoda jest implementowana przy użyciu metody anonimowej.  
  
 [!code-csharp[System.Collections.Generic.List.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.sort/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.sort/vb/module1.vb#1)]  
  
 W poniższym przykładzie pokazano <xref:System.Collections.Generic.List%601.Sort> przeciążenie metody i <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> przeciążenie metody. A <xref:System.Collections.Generic.List%601> ciągów, zostanie utworzony i wypełniony czterech ciągów, w losowej kolejności. Lista jest wyświetlana, sortowane i ponownie wyświetlone.  
  
 <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> Przeciążenie metody jest następnie używany do wyszukiwania dwa ciągi, które nie są na liście i <xref:System.Collections.Generic.List%601.Insert%2A> metoda służy do wstawiania ich. Wartość zwracana przez <xref:System.Collections.Generic.List%601.BinarySearch%2A> — metoda ma ujemną wartość w każdym przypadku, ponieważ ciągi nie są na liście. Biorąc dopełnienia bitowego (~ operatora w języku C# i Visual C++ `Xor` -1 w języku Visual Basic) z tym ujemna generuje numer indeksu pierwszego elementu na liście, który jest większy niż ciąg wyszukiwania i wstawianie w tym miejscu zachowuje sortowania kolejność. Drugi ciąg wyszukiwania jest większy niż dowolny element na liście, więc pozycji wstawiania znajduje się na końcu listy.  
  
 [!code-cpp[List\`1_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearch/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Domyślny moduł porównujący <see cref="P:System.Collections.Generic.Comparer`1.Default" /> nie można odnaleźć implementacji <see cref="T:System.IComparable`1" /> ogólny interfejs lub <see cref="T:System.IComparable" /> interfejsu dla typu <paramref name="T" />.</exception>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Wykonywanie niezależnych od kultury operacji na ciągach w kolekcjach</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort (System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort(class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort(System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort (comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort(System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="member this.Sort : System.Collections.Generic.IComparer&lt;'T&gt; -&gt; unit" Usage="list.Sort comparer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="comparer"><see cref="T:System.Collections.Generic.IComparer`1" /> Wdrożenia do użycia podczas porównywania elementów, lub <see langword="null" /> używać domyślny moduł porównujący <see cref="P:System.Collections.Generic.Comparer`1.Default" />.</param>
        <summary>Sortuje elementów w całej <see cref="T:System.Collections.Generic.List`1" /> przy użyciu określona funkcja porównująca.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `comparer` zostanie podany, elementy <xref:System.Collections.Generic.List%601> są sortowane przy użyciu określonego <xref:System.Collections.Generic.IComparer%601> implementacji.  
  
 Jeśli `comparer` jest `null`, domyślny moduł porównujący <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> kontroli tego, czy typ `T` implementuje <xref:System.IComparable%601> ogólny interfejs i wykorzystuje tę implementację, jeśli jest dostępny.  W przeciwnym razie <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> kontroli tego, czy typ `T` implementuje <xref:System.IComparable> interfejsu.  Jeśli typ `T` nie implementuje albo interfejsu <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> zgłasza <xref:System.InvalidOperationException>.  
  
 Ta metoda używa <xref:System.Array.Sort%2A?displayProperty=nameWithType> metody, która ma zastosowanie sortowania w następujący sposób:  
  
-   Jeśli rozmiar partycji wynosi mniej niż 16 elementów, używa algorytmu sortowania wstawiania.  
  
-   Jeśli liczba partycji przekracza 2 dziennika *n*, gdzie *n* to zakres tablicy wejściowej, używa algorytmu sortowania przez Kopcowanie.  
  
-   W przeciwnym razie używa algorytmu sortowania.  
  
 Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana. Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.  
  
 Średnio, ta metoda jest O (*n* dziennika *n*) operacji, gdzie *n* jest <xref:System.Collections.Generic.List%601.Count%2A>; w najgorszym przypadku jest O (*n* <sup>2</sup>) operacji.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Collections.Generic.List%601.Sort%28System.Collections.Generic.IComparer%7B%600%7D%29> przeciążenie metody i <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> przeciążenie metody.  
  
 W przykładzie zdefiniowano alternatywny moduł porównujący dla ciągów o nazwie DinoCompare, która implementuje `IComparer<string>` (`IComparer(Of String)` w języku Visual Basic `IComparer<String^>` w programie Visual C++) interfejs generyczny. Modułu porównującego działa w następujący sposób: Po pierwsze, są sprawdzane pod kątem leksykalną `null`, odwołanie o wartości null jest traktowany jako mniejsza niż inna niż null. Po drugie długości ciągów są porównywane i dłuższego ciągu jest uznawany za większy. Po trzecie Jeśli długości są równe, porównywania ciągów znaków zwykłych jest używany.  
  
 A <xref:System.Collections.Generic.List%601> ciągów, zostanie utworzony i wypełniony czterech ciągów, w losowej kolejności. Zostanie wyświetlona lista, sortowane, przy użyciu alternatywny moduł porównujący i wyświetlone ponownie.  
  
 <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> Przeciążenie metody jest następnie używany do wyszukiwania kilka ciągów, które są nie na liście zatrudniających alternatywny moduł porównujący. <xref:System.Collections.Generic.List%601.Insert%2A> Metoda służy do wstawiania ciągi. Te dwie metody znajdują się w funkcji o nazwie `SearchAndInsert`, wraz z kodem, aby móc dopełnienia bitowego (~ operatora w języku C# i Visual C++ `Xor` -1 w języku Visual Basic) liczby ujemne zwracane przez <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> i używać go jako indeks dla Wstawianie nowego ciągu znaków.  
  
 [!code-cpp[List\`1_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> jest <see langword="null" />, a domyślny moduł porównujący <see cref="P:System.Collections.Generic.Comparer`1.Default" /> nie można odnaleźć implementacji <see cref="T:System.IComparable`1" /> ogólny interfejs lub <see cref="T:System.IComparable" /> interfejsu dla typu <paramref name="T" />.</exception>
        <exception cref="T:System.ArgumentException">Implementacja <paramref name="comparer" /> spowodowane błędem podczas sortowania. Na przykład <paramref name="comparer" /> mogą nie zwracać na 0, podczas porównywania elementów z samym sobą.</exception>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Wykonywanie niezależnych od kultury operacji na ciągach w kolekcjach</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort (Comparison&lt;T&gt; comparison);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort(class System.Comparison`1&lt;!T&gt; comparison) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort(System.Comparison{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort (comparison As Comparison(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort(Comparison&lt;T&gt; ^ comparison);" />
      <MemberSignature Language="F#" Value="member this.Sort : Comparison&lt;'T&gt; -&gt; unit" Usage="list.Sort comparison" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparison" Type="System.Comparison&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="comparison"><see cref="T:System.Comparison`1" /> Do użycia podczas porównywania elementów.</param>
        <summary>Sortuje elementów w całej <see cref="T:System.Collections.Generic.List`1" /> przy użyciu określonego <see cref="T:System.Comparison`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `comparison` zostanie podany, elementy <xref:System.Collections.Generic.List%601> są sortowane przy użyciu metody reprezentowanej przez delegata.  
  
 Jeśli `comparison` jest `null`, <xref:System.ArgumentNullException> zgłaszany.  
  
 Ta metoda używa <xref:System.Array.Sort%2A?displayProperty=nameWithType>, którego dotyczy sortowania w następujący sposób:  
  
-   Jeśli rozmiar partycji wynosi mniej niż 16 elementów, używa algorytmu sortowania wstawiania  
  
-   Jeśli liczba partycji przekracza 2 dziennika *n*, gdzie *n* to zakres tablicy wejściowej, używa [sortowania przez Kopcowanie](https://en.wikipedia.org/wiki/Heapsort) algorytmu.  
  
-   W przeciwnym razie używa algorytmu sortowania.  
  
 Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana. Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.  
  
 Średnio, ta metoda jest O (*n* dziennika *n*) operacji, gdzie *n* jest <xref:System.Collections.Generic.List%601.Count%2A>; w najgorszym przypadku jest O (*n* <sup>2</sup>) operacji.  
  
   
  
## Examples  
 Poniższy przykład demonstruje <xref:System.Collections.Generic.List%601.Sort%2A> i <xref:System.Collections.Generic.List%601.Sort%2A> przeciążenia metody do obiektu proste biznesowych. Wywoływanie <xref:System.Collections.Generic.List%601.Sort%2A> metody powoduje użycie domyślny moduł porównujący dla typu części i <xref:System.Collections.Generic.List%601.Sort%2A> metoda jest implementowana przy użyciu metody anonimowej.  
  
 [!code-csharp[System.Collections.Generic.List.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.sort/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.sort/vb/module1.vb#1)]  
  
 W poniższym przykładzie pokazano <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> przeciążenie metody.  
  
 W przykładzie zdefiniowano metodę alternatywnych porównania ciągów o nazwie `CompareDinosByLength`. Ta metoda działa w następujący sposób: Po pierwsze, są sprawdzane pod kątem leksykalną `null`, odwołanie o wartości null jest traktowany jako mniejsza niż inna niż null. Po drugie długości ciągów są porównywane i dłuższego ciągu jest uznawany za większy. Po trzecie Jeśli długości są równe, porównywania ciągów znaków zwykłych jest używany.  
  
 A <xref:System.Collections.Generic.List%601> ciągów, zostanie utworzony i wypełniony czterech ciągów, w losowej kolejności. Lista zawiera również ciąg pusty i odwołanie o wartości null. Zostanie wyświetlona lista sortowane przy użyciu <xref:System.Comparison%601> Delegat ogólny reprezentujący `CompareDinosByLength` metody i ponownie wyświetlone.  
  
 [!code-cpp[List\`1_SortComparison#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortComparison/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortComparison#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortComparison/cs/source.cs#1)]
 [!code-vb[List\`1_SortComparison#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortComparison/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="comparison" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Implementacja <paramref name="comparison" /> spowodowane błędem podczas sortowania. Na przykład <paramref name="comparison" /> mogą nie zwracać na 0, podczas porównywania elementów z samym sobą.</exception>
        <altmember cref="T:System.Comparison`1" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Wykonywanie niezależnych od kultury operacji na ciągach w kolekcjach</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort (int index, int count, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort(int32 index, int32 count, class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort (index As Integer, count As Integer, comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Sort(int index, int count, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="member this.Sort : int * int * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; unit" Usage="list.Sort (index, count, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="index">Liczony od zera indeks początkowy zakresu do sortowania.</param>
        <param name="count">Długość zakresu do sortowania.</param>
        <param name="comparer"><see cref="T:System.Collections.Generic.IComparer`1" /> Wdrożenia do użycia podczas porównywania elementów, lub <see langword="null" /> używać domyślny moduł porównujący <see cref="P:System.Collections.Generic.Comparer`1.Default" />.</param>
        <summary>Sortuje elementy w zakresie elementów w <see cref="T:System.Collections.Generic.List`1" /> przy użyciu określona funkcja porównująca.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `comparer` zostanie podany, elementy <xref:System.Collections.Generic.List%601> są sortowane przy użyciu określonego <xref:System.Collections.Generic.IComparer%601> implementacji.  
  
 Jeśli `comparer` jest `null`, domyślny moduł porównujący <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> kontroli tego, czy typ `T` implementuje <xref:System.IComparable%601> ogólny interfejs i wykorzystuje tę implementację, jeśli jest dostępny.  W przeciwnym razie <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> kontroli tego, czy typ `T` implementuje <xref:System.IComparable> interfejsu.  Jeśli typ `T` nie implementuje albo interfejsu <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> zgłasza <xref:System.InvalidOperationException>.  
  
 Ta metoda używa <xref:System.Array.Sort%2A?displayProperty=nameWithType>, którego dotyczy sortowania w następujący sposób:  
  
-   Jeśli rozmiar partycji wynosi mniej niż 16 elementów, używa algorytmu sortowania wstawiania  
  
-   Jeśli liczba partycji przekracza 2 dziennika *n*, gdzie *n* to zakres tablicy wejściowej, używa [sortowania przez Kopcowanie](https://en.wikipedia.org/wiki/Heapsort) algorytmu.  
  
-   W przeciwnym razie używa algorytmu sortowania.  
  
 Ta implementacja wykonuje niestabilne sortowanie; oznacza to, że jeśli dwa elementy są równe, ich kolejność może nie zostać zachowana. Natomiast stabilne sortowanie zachowuje kolejność elementów, które są równe.  
  
 Średnio, ta metoda jest O (*n* dziennika *n*) operacji, gdzie *n* jest <xref:System.Collections.Generic.List%601.Count%2A>; w najgorszym przypadku jest O (*n* <sup>2</sup>) operacji.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Collections.Generic.List%601.Sort%28System.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> przeciążenie metody i <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> przeciążenie metody.  
  
 W przykładzie zdefiniowano alternatywny moduł porównujący dla ciągów o nazwie DinoCompare, która implementuje `IComparer<string>` (`IComparer(Of String)` w języku Visual Basic `IComparer<String^>` w programie Visual C++) interfejs generyczny. Modułu porównującego działa w następujący sposób: Po pierwsze, są sprawdzane pod kątem leksykalną `null`, odwołanie o wartości null jest traktowany jako mniejsza niż inna niż null. Po drugie długości ciągów są porównywane i dłuższego ciągu jest uznawany za większy. Po trzecie Jeśli długości są równe, porównywania ciągów znaków zwykłych jest używany.  
  
 A <xref:System.Collections.Generic.List%601> ciągów, zostanie utworzony i wypełniony nazw dinozaurów herbivorous pięć i trzy dinozaurów mięsożernych zwierząt. W ramach każdej z tych dwóch grup nazwy nie są w dowolnej kolejności sortowania określonego. Zostanie wyświetlona lista, zakres zwierząt roślinożernych są sortowane przy użyciu alternatywny moduł porównujący i ponownie zostanie wyświetlona lista.  
  
 <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> Przeciążenie metody jest następnie używany do wyszukiwania tylko zakres zwierząt roślinożernych "Brachiosaurus". Ciąg nie zostanie znaleziony i dopełnienia bitowego (~ operatora w języku C# i Visual C++ `Xor` -1 w języku Visual Basic) liczby ujemne zwracane przez <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> metoda jest używana jako indeks do wstawiania nowego ciągu znaków.  
  
 [!code-cpp[List\`1_SortSearchComparerRange#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparerRange#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparerRange#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparerRange/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> jest mniejsza niż 0.  
  
—lub— 
 <paramref name="count" /> jest mniejsza niż 0.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> i <paramref name="count" /> nie określono prawidłowego zakresu <see cref="T:System.Collections.Generic.List`1" />.  
  
—lub— 
Implementacja <paramref name="comparer" /> spowodowane błędem podczas sortowania. Na przykład <paramref name="comparer" /> mogą nie zwracać na 0, podczas porównywania elementów z samym sobą.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> jest <see langword="null" />, a domyślny moduł porównujący <see cref="P:System.Collections.Generic.Comparer`1.Default" /> nie można odnaleźć implementacji <see cref="T:System.IComparable`1" /> ogólny interfejs lub <see cref="T:System.IComparable" /> interfejsu dla typu <paramref name="T" />.</exception>
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-collections.md">Wykonywanie niezależnych od kultury operacji na ciągach w kolekcjach</related>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#Generic#ICollection&lt;T&gt;#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements ICollection(Of T).IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::Generic::ICollection&lt;T&gt;::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Collections.Generic.ICollection`1" /> jest tylko do odczytu.</summary>
        <value><see langword="true" /> Jeśli <see cref="T:System.Collections.Generic.ICollection`1" /> jest tylko do odczytu; w przeciwnym razie <see langword="false" />.  W implementacji domyślnej <see cref="T:System.Collections.Generic.List`1" />, właściwość ta zwraca zawsze <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W kolekcji tylko do odczytu po jej utworzeniu nie można dodawać, usuwać ani modyfikować elementów.  
  
 Kolekcja, która jest tylko do odczytu, jest po prostu zbiorem z otoką uniemożliwiającą zmianę kolekcji; w związku z tym, jeśli zmiany zostaną wprowadzone do podstawowej kolekcji, kolekcja tylko do odczytu uwzględni te zmiany.  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;!T&gt; System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#Generic#IEnumerable&lt;T&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of T) Implements IEnumerable(Of T).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;T&gt; ^ System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;T&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca moduł wyliczający, który dokonuje iteracji w kolekcji.</summary>
        <returns><see cref="T:System.Collections.Generic.IEnumerator`1" /> Który może służyć do iterowania po kolekcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `foreach` Instrukcja języka C# (`for each` w języku C++, `For Each` w języku Visual Basic) powoduje ukrycie złożoności modułów wyliczających. W związku z tym, za pomocą `foreach` jest to zalecane, zamiast bezpośredniego wykonywania operacji modułu wyliczającego.  
  
 Moduły wyliczające mogą służyć do odczytu danych w kolekcji, ale nie można za ich pomocą modyfikować kolekcji źródłowej.  
  
 Początkowo moduł wyliczający jest umieszczony przed pierwszym elementem w kolekcji. W tym miejscu <xref:System.Collections.Generic.IEnumerator%601.Current%2A> właściwość jest niezdefiniowana. W związku z tym, należy wywołać <xref:System.Collections.IEnumerator.MoveNext%2A> metody wyprzedzeniem modułu wyliczającego do pierwszego elementu kolekcji przed odczytaniem wartości właściwości <xref:System.Collections.Generic.IEnumerator%601.Current%2A>.  
  
 <xref:System.Collections.Generic.IEnumerator%601.Current%2A> Właściwość zwraca tego samego obiektu, dopóki nie <xref:System.Collections.IEnumerator.MoveNext%2A> jest wywoływana. <xref:System.Collections.IEnumerator.MoveNext%2A> Ustawia <xref:System.Collections.Generic.IEnumerator%601.Current%2A> do następnego elementu.  
  
 Jeśli <xref:System.Collections.IEnumerator.MoveNext%2A> przebiegów koniec kolekcji, moduł wyliczający jest umieszczany za ostatnim elementem w kolekcji i <xref:System.Collections.IEnumerator.MoveNext%2A> zwraca `false`. Gdy moduł wyliczający jest w tym miejscu, kolejne wywołania <xref:System.Collections.IEnumerator.MoveNext%2A> również zwracać `false`. Jeśli ostatnie wywołanie <xref:System.Collections.IEnumerator.MoveNext%2A> zwrócił `false`, <xref:System.Collections.Generic.IEnumerator%601.Current%2A> jest niezdefiniowana. Nie można ustawić <xref:System.Collections.Generic.IEnumerator%601.Current%2A> do pierwszego elementu w kolekcji; należy utworzyć nowe wystąpienie modułu wyliczającego zamiast tego.  
  
 Moduł wyliczający zachowuje ważność tak długo, jak długo kolekcja pozostaje niezmieniona. Jeśli zmiany zostały wprowadzone do kolekcji, takie jak dodawanie, modyfikowanie lub usuwanie elementów, moduł wyliczający jest nieodwracalnie unieważnione, a następne wywołanie <xref:System.Collections.IEnumerator.MoveNext%2A> lub <xref:System.Collections.IEnumerator.Reset%2A> zgłasza <xref:System.InvalidOperationException>.  
  
 Moduł wyliczający nie ma wyłącznego dostępu do kolekcji, w związku z tym wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość. Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania.  Aby zezwolić wielu wątkom na dostęp do kolekcji w celu odczytu i zapisu danych, należy zaimplementować własny mechanizm synchronizacji.  
  
 Domyślne implementacje kolekcji w <xref:System.Collections.Generic?displayProperty=nameWithType> przestrzeni nazw nie są zsynchronizowane.  
  
 Ta metoda jest operacją O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int arrayIndex) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Jednowymiarowy <see cref="T:System.Array" /> czyli miejscem docelowym elementów kopiowanych z <see cref="T:System.Collections.ICollection" />. <see cref="T:System.Array" /> Musi mieć Indeksowanie oparte na zerze.</param>
        <param name="arrayIndex">Liczony od zera indeks w <paramref name="array" /> od rozpoczyna się kopiowanie które.</param>
        <summary>Kopiuje elementy ze <see cref="T:System.Collections.ICollection" /> do <see cref="T:System.Array" />, rozpoczynając od określonego <see cref="T:System.Array" /> indeksu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Jeśli typ źródła <xref:System.Collections.ICollection> nie można automatycznie rzutować na typ docelowy `array`, nierodzajowymi implementacje <xref:System.Collections.ICollection.CopyTo%2A?displayProperty=nameWithType> throw <xref:System.InvalidCastException>, podczas gdy throw ogólnego implementacje <xref:System.ArgumentException>.  
  
 Ta metoda jest O (*n*) operacji, gdzie *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="arrayIndex" /> jest mniejsza niż 0.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="array" /> ma charakter wielowymiarowy.  
  
—lub— 
 <paramref name="array" /> nie ma indeksowania zaczynającego się od zera.  
  
—lub— 
Liczba elementów w źródle <see cref="T:System.Collections.ICollection" /> jest większa niż dostępna ilość miejsca od <paramref name="arrayIndex" /> do końca tablicy docelowej <paramref name="array" />.  
  
—lub— 
Typ źródła <see cref="T:System.Collections.ICollection" /> nie można automatycznie rzutować na typ docelowy <paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy dostęp do <see cref="T:System.Collections.ICollection" /> jest synchronizowane (wątkowo).</summary>
        <value><see langword="true" /> Jeśli dostęp do <see cref="T:System.Collections.ICollection" /> jest synchronizowane (wątkowo); w przeciwnym razie <see langword="false" />.  W implementacji domyślnej <see cref="T:System.Collections.Generic.List`1" />, właściwość ta zwraca zawsze <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślne implementacje kolekcji w <xref:System.Collections.Generic?displayProperty=nameWithType> przestrzeni nazw nie są zsynchronizowane.  
  
 Wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość.  W rzadkich przypadkach, w którym wyliczenie twierdzi, przy użyciu uzyskuje dostęp do zapisu można zablokować kolekcję podczas całego procesu wyliczania.  Aby zezwolić wielu wątkom na dostęp do kolekcji w celu odczytu i zapisu danych, należy zaimplementować własny mechanizm synchronizacji.  
  
 <xref:System.Collections.ICollection.SyncRoot%2A> Zwraca obiekt, który może służyć do synchronizowania dostępu do <xref:System.Collections.ICollection>. Synchronizacja jest efektywne tylko wtedy, gdy wszystkie wątki zablokowania obiektu przed uzyskaniem dostępu do kolekcji.  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Generic.List`1.System#Collections#ICollection#SyncRoot" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera obiekt, który może służyć do synchronizowania dostępu do <see cref="T:System.Collections.ICollection" />.</summary>
        <value>Obiekt, który może służyć do synchronizowania dostępu do <see cref="T:System.Collections.ICollection" />.  W implementacji domyślnej <see cref="T:System.Collections.Generic.List`1" />, właściwość ta zwraca zawsze bieżącego wystąpienia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślne implementacje kolekcji w <xref:System.Collections.Generic?displayProperty=nameWithType> przestrzeni nazw nie są zsynchronizowane.  
  
 Wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość.  Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania.  Aby zezwolić wielu wątkom na dostęp do kolekcji w celu odczytu i zapisu danych, należy zaimplementować własny mechanizm synchronizacji.  
  
 <xref:System.Collections.ICollection.SyncRoot%2A> Zwraca obiekt, który może służyć do synchronizowania dostępu do <xref:System.Collections.ICollection>. Synchronizacja jest efektywne tylko wtedy, gdy wszystkie wątki zablokowania obiektu przed uzyskaniem dostępu do kolekcji. Poniższy kod przedstawia użycie <xref:System.Collections.ICollection.SyncRoot%2A> właściwość dla języka C#, C++ i Visual Basic.  
  
```csharp  
ICollection ic = ...;  
lock (ic.SyncRoot)   
{  
    // Access the collection.  
}  
```  
  
```vb  
Dim ic As ICollection = ...  
SyncLock ic.SyncRoot  
    ' Access the collection.  
End SyncLock  
```  
  
```cpp#  
ICollection^ ic = ...;  
try   
{  
    Monitor::Enter(ic->SyncRoot);  
    // Access the collection.  
}  
finally   
{  
    Monitor::Exit(ic->SyncRoot);  
}  
```  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.Generic.List`1.System#Collections#ICollection#IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca moduł wyliczający, który dokonuje iteracji w kolekcji.</summary>
        <returns><see cref="T:System.Collections.IEnumerator" /> Który może służyć do iterowania po kolekcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `foreach` Instrukcja języka C# (`for each` w języku C++, `For Each` w języku Visual Basic) powoduje ukrycie złożoności modułów wyliczających. W związku z tym, za pomocą `foreach` jest to zalecane, zamiast bezpośredniego wykonywania operacji modułu wyliczającego.  
  
 Moduły wyliczające mogą służyć do odczytu danych w kolekcji, ale nie można za ich pomocą modyfikować kolekcji źródłowej.  
  
 Początkowo moduł wyliczający jest umieszczony przed pierwszym elementem w kolekcji. <xref:System.Collections.IEnumerator.Reset%2A> Przełącza moduł wyliczający do tej pozycji.  W tym miejscu <xref:System.Collections.IEnumerator.Current%2A> właściwość jest niezdefiniowana. W związku z tym, należy wywołać <xref:System.Collections.IEnumerator.MoveNext%2A> metody wyprzedzeniem modułu wyliczającego do pierwszego elementu kolekcji przed odczytaniem wartości właściwości <xref:System.Collections.IEnumerator.Current%2A>.  
  
 <xref:System.Collections.IEnumerator.Current%2A> Właściwość zwraca ten sam obiekt, do momentu <xref:System.Collections.IEnumerator.MoveNext%2A> lub <xref:System.Collections.IEnumerator.Reset%2A> jest wywoływana. <xref:System.Collections.IEnumerator.MoveNext%2A> Ustawia <xref:System.Collections.IEnumerator.Current%2A> do następnego elementu.  
  
 Jeśli <xref:System.Collections.IEnumerator.MoveNext%2A> przebiegów koniec kolekcji, moduł wyliczający jest umieszczany za ostatnim elementem w kolekcji i <xref:System.Collections.IEnumerator.MoveNext%2A> zwraca `false`. Gdy moduł wyliczający jest w tym miejscu, kolejne wywołania <xref:System.Collections.IEnumerator.MoveNext%2A> również zwracać `false`. Jeśli ostatnie wywołanie <xref:System.Collections.IEnumerator.MoveNext%2A> zwrócił `false`, <xref:System.Collections.IEnumerator.Current%2A> jest niezdefiniowana. Aby ustawić <xref:System.Collections.IEnumerator.Current%2A> do pierwszego elementu w kolekcji ponownie wywołaj <xref:System.Collections.IEnumerator.Reset%2A> następuje <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Moduł wyliczający zachowuje ważność tak długo, jak długo kolekcja pozostaje niezmieniona. Jeśli zmiany zostały wprowadzone do kolekcji, takie jak dodawanie, modyfikowanie lub usuwanie elementów, moduł wyliczający jest nieodwracalnie unieważnione, a następne wywołanie <xref:System.Collections.IEnumerator.MoveNext%2A> lub <xref:System.Collections.IEnumerator.Reset%2A> zgłasza <xref:System.InvalidOperationException>.  
  
 Moduł wyliczający nie ma wyłącznego dostępu do kolekcji, w związku z tym wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość.  Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania.  Aby zezwolić wielu wątkom na dostęp do kolekcji w celu odczytu i zapisu danych, należy zaimplementować własny mechanizm synchronizacji.  
  
 Domyślne implementacje kolekcji w <xref:System.Collections.Generic?displayProperty=nameWithType> przestrzeni nazw nie są zsynchronizowane.  
  
 Ta metoda jest operacją O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Add">
      <MemberSignature Language="C#" Value="int IList.Add (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.Add(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Add (item As Object) As Integer Implements IList.Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.Add(System::Object ^ item) = System::Collections::IList::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Add(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item"><see cref="T:System.Object" /> Do dodania do <see cref="T:System.Collections.IList" />.</param>
        <summary>Dodaje element do <see cref="T:System.Collections.IList" />.</summary>
        <returns>Pozycja, do którego dodano nowy element.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Collections.Generic.List%601.Count%2A> jest mniejsza niż <xref:System.Collections.Generic.List%601.Capacity%2A>, ta metoda jest operacją O(1). Jeśli pojemność musi zostać zwiększona, aby pomieścić nowy element, ta metoda staje się O (*n*) operacji, gdzie *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="item" /> jest typu, który nie jest możliwy do przypisania do <see cref="T:System.Collections.IList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Contains">
      <MemberSignature Language="C#" Value="bool IList.Contains (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IList.Contains(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Contains (item As Object) As Boolean Implements IList.Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IList.Contains(System::Object ^ item) = System::Collections::IList::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item"><see cref="T:System.Object" /> Do zlokalizowania w <see cref="T:System.Collections.IList" />.</param>
        <summary>Określa, czy <see cref="T:System.Collections.IList" /> zawiera określoną wartość.</summary>
        <returns><see langword="true" /> Jeśli <paramref name="item" /> znajduje się w <see cref="T:System.Collections.IList" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda określa równość za pomocą domyślny moduł porównujący równość <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> dla `T`, typ wartości na liście.  
  
 Ta metoda przeprowadza wyszukiwanie liniowe; w związku z tym, ta metoda jest O (*n*) operacji, gdzie *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IndexOf">
      <MemberSignature Language="C#" Value="int IList.IndexOf (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.IndexOf(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#IndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function IndexOf (item As Object) As Integer Implements IList.IndexOf" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.IndexOf(System::Object ^ item) = System::Collections::IList::IndexOf;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.IndexOf(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">Obiekt do zlokalizowania w <see cref="T:System.Collections.IList" />.</param>
        <summary>Określa indeks konkretny element w <see cref="T:System.Collections.IList" />.</summary>
        <returns>Indeks <paramref name="item" /> Jeśli na liście; w przeciwnym razie wartość -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda określa równość za pomocą domyślny moduł porównujący równość <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> dla `T`, typ wartości na liście.  
  
 Ta metoda przeprowadza wyszukiwanie liniowe; w związku z tym, ta metoda jest O (*n*) operacji, gdzie *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="item" /> jest typu, który nie jest możliwy do przypisania do <see cref="T:System.Collections.IList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Insert">
      <MemberSignature Language="C#" Value="void IList.Insert (int index, object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Insert(int32 index, object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Insert (index As Integer, item As Object) Implements IList.Insert" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Insert(int index, System::Object ^ item) = System::Collections::IList::Insert;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Insert(System.Int32,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">Liczony od zera indeks, w którym <paramref name="item" /> powinien zostać wstawiony.</param>
        <param name="item">Obiekt do wstawienia do <see cref="T:System.Collections.IList" />.</param>
        <summary>Wstawia element do <see cref="T:System.Collections.IList" /> pod określonym indeksem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `index` jest równa liczbie elementów w <xref:System.Collections.IList>, następnie `item` jest dołączany na końcu.  
  
 Ta metoda jest O (*n*) operacji, gdzie *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> nie jest prawidłowym indeksem w <see cref="T:System.Collections.IList" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="item" /> jest typu, który nie jest możliwy do przypisania do <see cref="T:System.Collections.IList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#IList#IsFixedSize" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFixedSize As Boolean Implements IList.IsFixedSize" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IList::IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Collections.IList" /> ma stały rozmiar.</summary>
        <value><see langword="true" /> Jeśli <see cref="T:System.Collections.IList" /> ma stały rozmiar; w przeciwnym razie <see langword="false" />.  W implementacji domyślnej <see cref="T:System.Collections.Generic.List`1" />, właściwość ta zwraca zawsze <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W kolekcji o stałym rozmiarze po jej utworzeniu nie można dodawać ani usuwać elementów, jednak można modyfikować istniejące elementy.  
  
 Kolekcja o stałym rozmiarze jest po prostu zbiorem z otoką, który uniemożliwia Dodawanie i usuwanie elementów; w związku z tym jeśli zmiany zostały wprowadzone do podstawowej kolekcji, w tym dodawania lub usuwania elementów kolekcji o stałym rozmiarze uwzględni te zmiany.  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#IList#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements IList.IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IList::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Collections.IList" /> jest tylko do odczytu.</summary>
        <value><see langword="true" /> Jeśli <see cref="T:System.Collections.IList" /> jest tylko do odczytu; w przeciwnym razie <see langword="false" />.  W implementacji domyślnej <see cref="T:System.Collections.Generic.List`1" />, właściwość ta zwraca zawsze <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W kolekcji tylko do odczytu po jej utworzeniu nie można dodawać, usuwać ani modyfikować elementów.  
  
 Kolekcja, która jest tylko do odczytu, jest po prostu zbiorem z otoką uniemożliwiającą zmianę kolekcji; w związku z tym, jeśli zmiany zostaną wprowadzone do podstawowej kolekcji, kolekcja tylko do odczytu uwzględni te zmiany.  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IList.Item[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IList.Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#IList#Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" Property Item(index As Integer) As Object Implements IList.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::IList::Item[int] { System::Object ^ get(int index); void set(int index, System::Object ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Liczony od zera indeks elementu, który ma zostać pobrany lub skonfigurowany.</param>
        <summary>Pobieranie lub konfigurowanie elementów pod określonym indeksem.</summary>
        <value>Element pod określonym indeksem.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Język C# używa [to](~/docs/csharp/language-reference/keywords/this.md) — słowo kluczowe, aby zdefiniować indeksatorów, a nie Implementowanie <xref:System.Collections.Generic.List%601.System%23Collections%23IList%23Item%2A> właściwości. Implementuje języka Visual Basic <xref:System.Collections.Generic.List%601.System%23Collections%23IList%23Item%2A> jako właściwość domyślną, która zapewnia taką samą funkcjonalność indeksowania.  
  
 Pobieranie wartości tej właściwości jest operacją O(1); Ustawianie właściwości również jest operacją O(1).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> nie jest prawidłowym indeksem w <see cref="T:System.Collections.IList" />.</exception>
        <exception cref="T:System.ArgumentException">Właściwość została ustawiona i <paramref name="value" /> typu, który nie jest możliwy do przypisania do <see cref="T:System.Collections.IList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Remove">
      <MemberSignature Language="C#" Value="void IList.Remove (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Remove(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Remove (item As Object) Implements IList.Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Remove(System::Object ^ item) = System::Collections::IList::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">Obiekt do usunięcia z <see cref="T:System.Collections.IList" />.</param>
        <summary>Usuwa pierwsze wystąpienie określonego obiektu z <see cref="T:System.Collections.IList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda określa równość za pomocą domyślny moduł porównujący równość <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> dla `T`, typ wartości na liście.  
  
 Ta metoda przeprowadza wyszukiwanie liniowe; w związku z tym, ta metoda jest O (*n*) operacji, gdzie *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="item" /> jest typu, który nie jest możliwy do przypisania do <see cref="T:System.Collections.IList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public T[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T[] ToArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.ToArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToArray () As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;T&gt; ^ ToArray();" />
      <MemberSignature Language="F#" Value="member this.ToArray : unit -&gt; 'T[]" Usage="list.ToArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Kopiuje elementy ze <see cref="T:System.Collections.Generic.List`1" /> do nowej tablicy.</summary>
        <returns>Tablica zawierająca kopie elementów <see cref="T:System.Collections.Generic.List`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Elementy są kopiowane, za pomocą <xref:System.Array.Copy%2A?displayProperty=nameWithType>, czyli O (*n*) operacji, gdzie *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 Ta metoda jest O (*n*) operacji, gdzie *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Collections.Generic.List%601.ToArray%2A> metody i innych metod <xref:System.Collections.Generic.List%601> klasę, która działa na zakresach. Na koniec przykładzie <xref:System.Collections.Generic.List%601.GetRange%2A> metoda jest używana do pobierania trzy elementy z listy, począwszy od indeksu w lokalizacji 2. <xref:System.Collections.Generic.List%601.ToArray%2A> Metoda jest wywoływana w wynikowym <xref:System.Collections.Generic.List%601>, tworząc tablicę trzy elementy. Elementy tablicy są wyświetlane.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimExcess">
      <MemberSignature Language="C#" Value="public void TrimExcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TrimExcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.TrimExcess" />
      <MemberSignature Language="VB.NET" Value="Public Sub TrimExcess ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TrimExcess();" />
      <MemberSignature Language="F#" Value="member this.TrimExcess : unit -&gt; unit" Usage="list.TrimExcess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ustawia pojemność do rzeczywistej liczby elementów w <see cref="T:System.Collections.Generic.List`1" />, jeśli ta liczba jest mniejsza niż wartość progowa.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może być używana aby zminimalizować obciążenie pamięci kolekcji, jeśli żadne nowe elementy, które zostaną dodane do kolekcji. Koszt ponowne przydzielanie i kopiowania dużych <xref:System.Collections.Generic.List%601> mogą być jednak znaczące, więc <xref:System.Collections.Generic.List%601.TrimExcess%2A> metody nie robi nic, jeśli lista jest więcej niż 90 procent pojemność. Pozwala to uniknąć ponoszenia koszt dużych ponownej alokacji dla niewielkich korzyści.  
  
> [!NOTE]
>  Bieżący próg 90 procent mogą ulec zmianie w przyszłych wersjach.  
  
 Ta metoda jest O (*n*) operacji, gdzie *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 Aby zresetować <xref:System.Collections.Generic.List%601> do stanu początkowego wywołania <xref:System.Collections.Generic.List%601.Clear%2A> metoda przed wywołaniem <xref:System.Collections.Generic.List%601.TrimExcess%2A> metody. Przycinanie pustą <xref:System.Collections.Generic.List%601> ustawia pojemność <xref:System.Collections.Generic.List%601> do pojemności domyślnej.  
  
 Wydajność można również ustawić za pomocą <xref:System.Collections.Generic.List%601.Capacity%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykład ilustruje sposób sprawdzić pojemność i liczba <xref:System.Collections.Generic.List%601> , zawierający obiektu proste biznesowego, a ilustruje użycie <xref:System.Collections.Generic.List%601.TrimExcess%2A> metodę, aby usunąć dodatkowej pojemności.  
  
 [!code-csharp[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/vb/module1.vb#1)]  
  
 W poniższym przykładzie pokazano <xref:System.Collections.Generic.List%601.TrimExcess%2A> metody. Kilka właściwości i metod <xref:System.Collections.Generic.List%601> klasy są używane do dodawania, wstawianie i usuwanie elementów z listy ciągów. A następnie <xref:System.Collections.Generic.List%601.TrimExcess%2A> metoda jest używana do zmniejszenia pojemności do dopasowania liczby, a <xref:System.Collections.Generic.List%601.Capacity%2A> i <xref:System.Collections.Generic.List%601.Count%2A> właściwości są wyświetlane. Jeśli nieużywaną pojemność była mniejsza niż 10 procent całkowitej wydajności, lista czy nie został zmieniony. Na koniec zawartości listy zostaną wyczyszczone.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.Generic.List`1.Clear" />
        <altmember cref="P:System.Collections.Generic.List`1.Capacity" />
        <altmember cref="P:System.Collections.Generic.List`1.Count" />
      </Docs>
    </Member>
    <Member MemberName="TrueForAll">
      <MemberSignature Language="C#" Value="public bool TrueForAll (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TrueForAll(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function TrueForAll (match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TrueForAll(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.TrueForAll : Predicate&lt;'T&gt; -&gt; bool" Usage="list.TrueForAll match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match"><see cref="T:System.Predicate`1" /> Delegat definiujący warunki sprawdzania elementów.</param>
        <summary>Określa, czy każdy element w kolekcji <see cref="T:System.Collections.Generic.List`1" /> pasuje do warunków zdefiniowanych przez określony predykat.</summary>
        <returns><see langword="true" /> Jeśli każdy element w kolekcji <see cref="T:System.Collections.Generic.List`1" /> pasuje do warunków zdefiniowanych przez określony predykat; w przeciwnym razie <see langword="false" />. Jeśli lista nie zawiera żadnych elementów, wartość zwracana jest <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Predicate%601> Jest delegatem metody, która zwraca `true` jeśli przekazany obiekt jest zgodny z warunkami zdefiniowanymi dla delegata.  Elementy bieżącego <xref:System.Collections.Generic.List%601> są indywidualnie przekazywane do <xref:System.Predicate%601> delegata, a przetwarzanie jest zatrzymywany, gdy zwraca delegata `false` dla każdego elementu. Elementy są przetwarzane w kolejności, a wszystkie wywołania są wykonywane w jednym wątku.  
  
 Ta metoda jest O (*n*) operacji, gdzie *n* jest <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano <xref:System.Collections.Generic.List%601.TrueForAll%2A> metody i kilka innych metod, które używają <xref:System.Predicate%601> Delegat ogólny.  
  
 A <xref:System.Collections.Generic.List%601> ciągów jest tworzona, zawierająca 8 nazw dinozaurów, dwa z nich (w pozycjach 1 i 5) kończy się ciągiem "saurus". W przykładzie zdefiniowano również metodę wyszukiwania predykatów o nazwie `EndsWithSaurus`, który przyjmuje parametr ciąg i zwraca wartość logiczną wskazującą, czy ciąg wejściowy kończy się na "saurus".  
  
 <xref:System.Collections.Generic.List%601.TrueForAll%2A> Metoda przechodzi przez listę od początku, przekazywać z kolei do każdego elementu `EndsWithSaurus` metody. Wyszukiwanie zatrzymuje się, gdy `EndsWithSaurus` metoda zwraca `false`.  
  
> [!NOTE]
>  W języku C# i Visual Basic nie jest niezbędne do utworzenia `Predicate<string>` delegowanie (`Predicate(Of String)` w języku Visual Basic) jawnie. Te języki wnioskują o poprawnym delegacie z kontekstu, a następnie są tworzone automatycznie.  
  
 [!code-cpp[List\`1_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[List\`1_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_FindEtAl/cs/source.cs#1)]
 [!code-vb[List\`1_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="match" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="PromptBuilder" FullName="System.Speech.Synthesis.PromptBuilder">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="30cce191eab8eb309679813dd4b1e75f0b4f72a3" />
    <Meta Name="ms.sourcegitcommit" Value="df6cf590aa3087f6c7c202712eee781c6a3c8f96" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="05/07/2018" />
    <Meta Name="ms.locfileid" Value="33684413" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class PromptBuilder" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit PromptBuilder extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Speech.Synthesis.PromptBuilder" />
  <TypeSignature Language="VB.NET" Value="Public Class PromptBuilder" />
  <TypeSignature Language="C++ CLI" Value="public ref class PromptBuilder" />
  <AssemblyInfo>
    <AssemblyName>System.Speech</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Tworzy pustą <see cref="T:System.Speech.Synthesis.Prompt" /> obiektu i udostępnia metody do dodawania zawartości, wybierając głosy, kontrolowanie atrybutów głosu i kontrolowanie Wymowa wypowiadane słowa.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Z <xref:System.Speech.Synthesis.PromptBuilder>, można dodać różne typy zawartości do wiersza, w tym zwykłego tekstu, znaczników SSML (jako ciąg lub pliku), rejestrowane audio, lub nawet innego <xref:System.Speech.Synthesis.PromptBuilder> obiektu.  
  
 Aby dołączyć tekst <xref:System.Speech.Synthesis.PromptBuilder> obiektu i opcjonalnie kontrolować głosu atrybuty, takie jak nacisk, szybkość i wolumin, użyj jednej z <xref:System.Speech.Synthesis.PromptBuilder.AppendText%2A> metody.  Można również sterować atrybuty głosu jako grupa o <xref:System.Speech.Synthesis.PromptBuilder.StartStyle%2A> i <xref:System.Speech.Synthesis.PromptBuilder.EndStyle%2A> metody.  
  
 Można dołączać tekstu i kontrolować, co jest używany lub, w jaki sposób jest widoczny, za pomocą <xref:System.Speech.Synthesis.PromptBuilder.AppendTextWithHint%2A>, <xref:System.Speech.Synthesis.PromptBuilder.AppendTextWithAlias%2A>, <xref:System.Speech.Synthesis.PromptBuilder.AppendTextWithPronunciation%2A>, <xref:System.Speech.Synthesis.PromptBuilder.AppendSsml%2A>, lub <xref:System.Speech.Synthesis.PromptBuilder.AppendSsmlMarkup%2A> metody.  
  
 Zmienić aktualnie wybrany głos mowy w wierszu przy użyciu jednej z przeciążone <xref:System.Speech.Synthesis.PromptBuilder.StartVoice%2A> metody nazw określonych głosu do użycia lub określając wymagane właściwości głosowych, takich jak wiek i płci.  
  
 Do generowania mowy <xref:System.Speech.Synthesis.PromptBuilder> obiektów i przekaż go jako argument <xref:System.Speech.Synthesis.SpeechSynthesizer.Speak%2A> metody.  
  
 Aby uzyskać więcej informacji, zobacz [tworzenia złożonych monitu](http://msdn.microsoft.com/library/552cb356-7344-473e-b0f2-7a9983f8c1a4).  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy nowe wystąpienie klasy <see cref="T:System.Speech.Synthesis.PromptBuilder" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PromptBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PromptBuilder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Tworzy nowe wystąpienie klasy <see cref="T:System.Speech.Synthesis.PromptBuilder" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy nową <xref:System.Speech.Synthesis.PromptBuilder> wystąpienia i dodaje do niej ciąg tekstowy.  
  
```csharp  
using System.Speech.Synthesis;  
  
public void MySimpleText ()  
{  
    PromptBuilder builder = new PromptBuilder ();  
    builder.AppendText("Hello world!");  
}  
```  
  
 Następujący kod przedstawia odpowiednik w mowy syntezy Markup Language (SSML), (`xml:lang` jest wymaganego atrybutu `speak` element):  
  
```xml  
<speak version="1.0"  
 xmlns="http://www.w3.org/2001/10/synthesis" xml:lang="en-US">  
  Hello world!  
</speak>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PromptBuilder (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.#ctor(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (culture As CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PromptBuilder(System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="culture">Zawiera informacje o określoną kulturę, takie jak jego język, nazwę kultury, system pisma i używany kalendarz i sposób formatowania dat i sortowania ciągów.</param>
        <summary>Tworzy nowe wystąpienie klasy <see cref="T:System.Speech.Synthesis.PromptBuilder" /> , określa kulturę.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor ustawia wartość <xref:System.Speech.Synthesis.PromptBuilder.Culture%2A> właściwości. <xref:System.Speech.Synthesis.SpeechSynthesizer> Obiektu będzie podejmować próby wybierz zainstalowanych głosowych, obsługujący język określony przez `culture` parametru do przetworzenia monitu. Jeśli zostanie znaleziony głosu z określonej kultury, będzie używany. Jeśli nie można odnaleźć głosu z określonej kultury, głosu domyślne będą używane.  
  
 Poprawnie Wymowa wyrazów w języku określonym przez `culture` parametru mowy aparatu syntezy (tekst na mowę lub TTS), obsługujący język musi być zainstalowany. Zainstalowany aparat TTS jest nazywany głosu. Aby uzyskać informacje o tym, które są zainstalowane głosy na określoną kulturę, użyj <xref:System.Speech.Synthesis.SpeechSynthesizer.GetInstalledVoices%2A> metody.  
  
 Microsoft Windows i interfejsu API System.Speech Zaakceptuj wszystkie prawidłowe kody kraju języka jako wartości `culture`. Aparaty TTS, które zostały wydane z systemem Windows 7 obsługuje następujące kody kraju języka:  
  
-   en-US. Angielski (Stany Zjednoczone)  
  
-   zh-CN. Chiński (Chiny)  
  
-   zh-TW. Chiński (Tajwan)  
  
 Dozwolone są również kodów dwuliterowych języka na przykład "en".  
  
   
  
## Examples  
 W następującym przykładzie jest tworzony <xref:System.Speech.Synthesis.PromptBuilder> wystąpienia i określa jego <xref:System.Speech.Synthesis.PromptBuilder.Culture%2A>.  
  
```csharp  
using System.Speech.Synthesis;  
  
public void MySimpleText ()  
{  
    PromptBuilder builder = new PromptBuilder(new System.Globalization.CultureInfo("en-US"));  
    builder.AppendText("Hello world!");  
}  
```  
  
 Następujący kod przedstawia równoważne SSML:  
  
```xml  
<speak version="1.0"  
 xmlns="http://www.w3.org/2001/10/synthesis" xml:lang="en-US">  
  Hello world!  
</speak>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendAudio">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dołącza określony plik audio do <see cref="T:System.Speech.Synthesis.PromptBuilder" /> obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendAudio">
      <MemberSignature Language="C#" Value="public void AppendAudio (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendAudio(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.AppendAudio(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendAudio (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendAudio(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Pełna ścieżka do pliku dźwiękowego.</param>
        <summary>Dołącza określony plik dźwiękowy do <see cref="T:System.Speech.Synthesis.PromptBuilder" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendAudio">
      <MemberSignature Language="C#" Value="public void AppendAudio (Uri audioFile);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendAudio(class System.Uri audioFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.AppendAudio(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendAudio (audioFile As Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendAudio(Uri ^ audioFile);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="audioFile" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="audioFile">Identyfikator URI dla pliku audio.</param>
        <summary>Dołącza plik dźwiękowy na określony identyfikator URI do <see cref="T:System.Speech.Synthesis.PromptBuilder" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład inicjuje nowe wystąpienie klasy <xref:System.Speech.Synthesis.PromptBuilder> klasy, a następnie dodaje do niego, a następnie plik dźwiękowy tekstu.  
  
```csharp  
using System.Speech.PromptBuilder;  
  
public void SimpleConcatenation()  
{  
    // Add a prompt fragment from a .wav file.  
    PromptBuilder builder = new PromptBuilder ();  
    builder.AppendText("How are you today?");  
    builder.AppendAudio(new Uri ("http://www.speech.microsoft.com/ding.wav"));  
}  
```  
  
 Następujący kod przedstawia równoważne znaczników SSML.  
  
```xml  
<speak xmlns="http://www.w3.org/2001/10/synthesis"  
       xmlns:ms="http://www.microsoft.com/speech/synthesis" xml:lang="en">  
  
  How are you today?  
  <audio src="http://www.speech.microsoft.com/ding.wav" />  
  
</speak>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendAudio">
      <MemberSignature Language="C#" Value="public void AppendAudio (Uri audioFile, string alternateText);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendAudio(class System.Uri audioFile, string alternateText) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.AppendAudio(System.Uri,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendAudio (audioFile As Uri, alternateText As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendAudio(Uri ^ audioFile, System::String ^ alternateText);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="audioFile" Type="System.Uri" />
        <Parameter Name="alternateText" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="audioFile">Identyfikator URI dla pliku audio.</param>
        <param name="alternateText">Ciąg zawierający tekst zastępczy reprezentujący audio.</param>
        <summary>Dołącza określony plik audio i tekst alternatywny do <see cref="T:System.Speech.Synthesis.PromptBuilder" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aparat rozpoznawania mowy syntezy będzie odtwarzać tekst alternatywny, jeśli nie można odtworzyć pliku dźwiękowego.  
  
   
  
## Examples  
 Poniższe przykłady dodaje plik dźwiękowy do <xref:System.Speech.Synthesis.PromptBuilder> wystąpienia i określa tekst, który ma mowy, jeśli nie można odtworzyć pliku dźwiękowego.  
  
```csharp  
using System.Speech.PromptBuilder;  
  
public void SimpleConcatenation()  
{  
  
    // Concatenate a prompt fragment from a .wav file.  
    PromptBuilder builder = new PromptBuilder ();  
    builder.AppendAudio(new Uri ("C:\\OnHold.wav"), "Your call will be answered in the order it was received");  
}  
```  
  
 Następujący kod przedstawia równoważne znaczników SSML.  
  
```xml  
<speak xmlns="http://www.w3.org/2001/10/synthesis"  
       xmlns:ms="http://www.microsoft.com/speech/synthesis" xml:lang="en">  
  
  <audio src="C:\OnHold.wav"> Your call will be answered in the order it was received. </audio>  
  
</speak>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendBookmark">
      <MemberSignature Language="C#" Value="public void AppendBookmark (string bookmarkName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendBookmark(string bookmarkName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.AppendBookmark(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendBookmark (bookmarkName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendBookmark(System::String ^ bookmarkName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bookmarkName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="bookmarkName">Ciąg zawierający nazwę dołączany zakładki.</param>
        <summary>Dołącza do zakładki <see cref="T:System.Speech.Synthesis.PromptBuilder" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aparat syntezy mowy wygeneruje <xref:System.Speech.Synthesis.SpeechSynthesizer.BookmarkReached> zdarzeń, jeśli wykryje zakładki podczas trwania mowy monit przy użyciu dowolnego <xref:System.Speech.Synthesis.SpeechSynthesizer.Speak%2A>, <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakAsync%2A>, <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakSsml%2A>, lub <xref:System.Speech.Synthesis.SpeechSynthesizer.SpeakSsmlAsync%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład tworzy wiersz zawiera dwa zakładek i wysyła dane wyjściowe do pliku WAV przy odtwarzaniu. Program obsługi dla <xref:System.Speech.Synthesis.SpeechSynthesizer.BookmarkReached> zdarzeń zapisuje nazwę zakładki i położenia w strumieniem audio po zdarzeniu został zgłoszony do konsoli.  
  
```csharp  
using System;  
using System.Speech.Synthesis;  
  
namespace SampleSynthesis  
{  
  class Program  
  {  
    static void Main(string[] args)  
    {  
  
      // Initialize a new instance of the SpeechSynthesizer.  
      using (SpeechSynthesizer synth = new SpeechSynthesizer())  
      {  
  
        // Configure the audio output.   
        synth.SetOutputToWaveFile(@"C:\test\weather.wav");  
  
        // Create a SoundPlayer instance to play the output audio file.  
        System.Media.SoundPlayer m_SoundPlayer =  
          new System.Media.SoundPlayer(@"C:\test\weather.wav");  
  
        // Build a prompt and append bookmarks.  
        PromptBuilder builder = new PromptBuilder(  
          new System.Globalization.CultureInfo("en-US"));  
        builder.AppendText(  
          "The weather forecast for today is partly cloudy with some sun breaks.");  
        builder.AppendBookmark("Daytime forecast");  
        builder.AppendText(  
          "Tonight's weather will be cloudy with a 30% chance of showers.");  
        builder.AppendBookmark("Nightime forecast");  
  
        // Add a handler for the BookmarkReached event.  
        synth.BookmarkReached +=  
          new EventHandler<BookmarkReachedEventArgs>(synth_BookmarkReached);  
  
        // Speak the prompt and play back the output file.  
        synth.Speak(builder);  
        m_SoundPlayer.Play();  
      }  
  
      Console.WriteLine();  
      Console.WriteLine("Press any key to exit...");  
      Console.ReadKey();  
    }  
  
    // Write the name and position of the bookmark to the console.  
    static void synth_BookmarkReached(object sender, BookmarkReachedEventArgs e)  
    {  
      Console.WriteLine("Bookmark ({0}) reached at: {1} ",  
        e.Bookmark, e.AudioPosition);  
    }  
  }  
}  
  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendBreak">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wstawia podział (Wstrzymaj) w zawartości <see cref="T:System.Speech.Synthesis.PromptBuilder" /> obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendBreak">
      <MemberSignature Language="C#" Value="public void AppendBreak ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendBreak() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.AppendBreak" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendBreak ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendBreak();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Dołącza break, aby <see cref="T:System.Speech.Synthesis.PromptBuilder" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie określa czas przerwy. <xref:System.Speech.Synthesis.SpeechSynthesizer> Określi wartość typu duration na podstawie kontekstu językowe.  
  
   
  
## Examples  
 Poniższy przykład tworzy wiersz zawierający dwa zdania oddzielone podziału i mówi monit domyślnego urządzenia audio na komputerze.  
  
```csharp  
using System;  
using System.Speech.Synthesis;  
  
namespace SampleSynthesis  
{  
  class Program  
  {  
    static void Main(string[] args)  
    {  
  
      // Initialize a new instance of the SpeechSynthesizer.  
      using (SpeechSynthesizer synth = new SpeechSynthesizer())  
      {  
  
        // Configure the audio output.   
        synth.SetOutputToDefaultAudioDevice();  
  
        // Build a prompt with two sentences separated by a break.  
        PromptBuilder builder = new PromptBuilder(  
          new System.Globalization.CultureInfo("en-US"));  
        builder.AppendText(  
          "Tonight's movie showings in theater A are at 5:45, 7:15, and 8:45.");  
        builder.AppendBreak();  
        builder.AppendText(  
          "Tonight's movie showings in theater B are at 5:15, 7:30, and 9:15.");  
  
        // Speak the prompt.  
        synth.Speak(builder);  
      }  
  
      Console.WriteLine();  
      Console.WriteLine("Press any key to exit...");  
      Console.ReadKey();  
    }  
  }  
}  
  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendBreak">
      <MemberSignature Language="C#" Value="public void AppendBreak (System.Speech.Synthesis.PromptBreak strength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendBreak(valuetype System.Speech.Synthesis.PromptBreak strength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.AppendBreak(System.Speech.Synthesis.PromptBreak)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendBreak (strength As PromptBreak)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendBreak(System::Speech::Synthesis::PromptBreak strength);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strength" Type="System.Speech.Synthesis.PromptBreak" />
      </Parameters>
      <Docs>
        <param name="strength">Wskazuje czas trwania podziału, z następującymi wartościami zwiększa:</param>
        <summary>Dołącza break, aby <see cref="T:System.Speech.Synthesis.PromptBuilder" /> obiektu i określa jego siły (czas trwania).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartości w <xref:System.Speech.Synthesis.PromptBreak> wyliczenie reprezentuje zakres oddzielenie przedziałów (pauzy) między granicami programu word. Aparat rozpoznawania mowy syntezy określa dokładny czas trwania interwału. Po zażądaniu podział jedną z następujących wartości są przekazywane do zamiany tekstu na mowę aparat (TTS), który zawiera mapowania między te wartości i wartości odpowiednich podziału milisekund.  
  
   
  
## Examples  
 Poniższy przykład tworzy wiersz zawierający dwa zdania oddzielone podziału i wysyła dane wyjściowe do pliku WAV do odtwarzania.  
  
```csharp  
using System;  
using System.Speech.Synthesis;  
  
namespace SampleSynthesis  
{  
  class Program  
  {  
    static void Main(string[] args)  
    {  
  
      // Initialize a new instance of the SpeechSynthesizer.  
      using (SpeechSynthesizer synth = new SpeechSynthesizer())  
      {  
  
        // Configure the audio output.   
        synth.SetOutputToWaveFile(@"C:\test\weather.wav");  
  
        // Create a SoundPlayer instance to play the output audio file.  
        System.Media.SoundPlayer m_SoundPlayer =  
          new System.Media.SoundPlayer(@"C:\test\weather.wav");  
  
        // Build a prompt with two sentences separated by a break.  
        PromptBuilder builder = new PromptBuilder(  
          new System.Globalization.CultureInfo("en-US"));  
        builder.AppendText(  
          "Tonight's movie showings in theater A are at 5:45, 7:15, and 8:45");  
        builder.AppendBreak(PromptBreak.Medium);  
        builder.AppendText(  
          "Tonight's movie showings in theater B are at 5:15, 7:15, and 9:15");  
  
        // Speak the prompt and play back the output file.  
        synth.Speak(builder);  
        m_SoundPlayer.Play();  
      }  
  
      Console.WriteLine();  
      Console.WriteLine("Press any key to exit...");  
      Console.ReadKey();  
    }  
  }  
}  
  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendBreak">
      <MemberSignature Language="C#" Value="public void AppendBreak (TimeSpan duration);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendBreak(valuetype System.TimeSpan duration) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.AppendBreak(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendBreak (duration As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendBreak(TimeSpan duration);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="duration" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="duration">Czas w taktach, w której jeden znaczników jest równa 100 nanosekundach.</param>
        <summary>Dołącza podział podany czas trwania do <see cref="T:System.Speech.Synthesis.PromptBuilder" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podział może służyć do sterowania pauzy lub innych akcent granice między wyrazami. Podział jest opcjonalne. Jeśli podziału nie jest obecny, że Syntezator określa podziału między wyrazami, w zależności od kontekst językowy.  
  
   
  
## Examples  
 Poniższy przykład tworzy wiersz zawierający dwa zdania oddzielone podział 15000000 znaczniki (1,5 s), a mówi monit domyślnego urządzenia audio na komputerze.  
  
```csharp  
using System;  
using System.Speech.Synthesis;  
  
namespace SampleSynthesis  
{  
  class Program  
  {  
    static void Main(string[] args)  
    {  
  
      // Initialize a new instance of the SpeechSynthesizer.  
      using (SpeechSynthesizer synth = new SpeechSynthesizer())  
      {  
  
        // Configure the audio output.   
        synth.SetOutputToDefaultAudioDevice();  
  
        // Build a prompt with two sentences separated by a break.  
        PromptBuilder builder = new PromptBuilder(  
          new System.Globalization.CultureInfo("en-US"));  
        builder.AppendText(  
          "Tonight's movie showings in theater A are at 5:45, 7:15, and 8:45");  
        builder.AppendBreak(new TimeSpan(15000000));  
        builder.AppendText(  
          "Tonight's movie showings in theater B are at 5:15, 7:15, and 9:15");  
  
        // Speak the prompt.  
        synth.Speak(builder);  
      }  
  
      Console.WriteLine();  
      Console.WriteLine("Press any key to exit...");  
      Console.ReadKey();  
    }  
  }  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendPromptBuilder">
      <MemberSignature Language="C#" Value="public void AppendPromptBuilder (System.Speech.Synthesis.PromptBuilder promptBuilder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendPromptBuilder(class System.Speech.Synthesis.PromptBuilder promptBuilder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.AppendPromptBuilder(System.Speech.Synthesis.PromptBuilder)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendPromptBuilder(System::Speech::Synthesis::PromptBuilder ^ promptBuilder);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="promptBuilder" Type="System.Speech.Synthesis.PromptBuilder" />
      </Parameters>
      <Docs>
        <param name="promptBuilder">Zawartość, która ma zostać dołączony.</param>
        <summary>Dołącza <see cref="T:System.Speech.Synthesis.PromptBuilder" /> obiektu do innego <see cref="T:System.Speech.Synthesis.PromptBuilder" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Przykład, w którym następuje utworzenie dwóch <xref:System.Speech.Synthesis.PromptBuilder> wystąpień i dołącza je do innej <xref:System.Speech.Synthesis.PromptBuilder>.  
  
```csharp  
using System;  
using System.Speech.Synthesis;  
  
namespace SampleSynthesis  
{  
  class Program  
  {  
    static void Main(string[] args)  
    {  
  
      // Initialize a new instance of the SpeechSynthesizer.  
      using (SpeechSynthesizer synth = new SpeechSynthesizer())  
      {  
  
        // Configure the audio output.   
        synth.SetOutputToWaveFile(@"C:\test\showtimes.wav");  
  
        // Create a SoundPlayer instance to play the output audio file.  
        System.Media.SoundPlayer m_SoundPlayer =  
          new System.Media.SoundPlayer(@"C:\test\showtimes.wav");  
  
        // Build child prompts.  
        PromptBuilder theatreA = new PromptBuilder();  
        theatreA.AppendText(  
          "Tonight's movie showings in theater A are at 5:45, 7:15, and 9:30");  
        theatreA.AppendBreak(PromptBreak.Large);  
        PromptBuilder theatreB = new PromptBuilder();  
        theatreB.AppendText(  
          "Tonight's movie showings in theater B are at 5:15, 7:15, and 9:15");  
  
        // Build the parent prompt and append the two child prompts.  
        PromptBuilder showTimes = new PromptBuilder(  
          new System.Globalization.CultureInfo("en-US"));  
        showTimes.AppendText(  
          "The following are the show times for tonight's movies:");  
        showTimes.AppendPromptBuilder(theatreA);  
        showTimes.AppendPromptBuilder(theatreB);  
  
        // Speak the prompt and play back the output file.  
        synth.Speak(showTimes);  
        m_SoundPlayer.Play();  
      }  
  
      Console.WriteLine();  
      Console.WriteLine("Press any key to exit...");  
      Console.ReadKey();  
    }  
  }  
}  
  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendSsml">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dołącza pliku SSML <see cref="T:System.Speech.Synthesis.PromptBuilder" /> obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendSsml">
      <MemberSignature Language="C#" Value="public void AppendSsml (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendSsml(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.AppendSsml(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendSsml (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendSsml(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Pełna ścieżka do pliku SSML do dołączenia.</param>
        <summary>Dołącza w określonej ścieżce do pliku SSML <see cref="T:System.Speech.Synthesis.PromptBuilder" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Plik SSML musi być plikiem formatu XML, który odpowiada [mowy syntezy Markup Language (SSML) w wersji 1.0](http://go.microsoft.com/fwlink/?LinkId=201763) specyfikacji.  
  
 Można także dołączyć znaczników SSML jako ciągu przy użyciu <xref:System.Speech.Synthesis.PromptBuilder.AppendSsmlMarkup%2A>.  
  
   
  
## Examples  
 W następującym przykładzie jest tworzony <xref:System.Speech.Synthesis.PromptBuilder> obiektu i dołącza zawartość pliku SSML przy użyciu <xref:System.Speech.Synthesis.PromptBuilder.AppendSsml%2A> metody.  
  
```csharp  
using System;  
using System.Speech.Synthesis;  
  
namespace SampleSynthesis  
{  
  class Program  
  {  
    static void Main(string[] args)  
    {  
  
      // Initialize a new instance of the SpeechSynthesizer.  
      using (SpeechSynthesizer synth = new SpeechSynthesizer())  
      {  
  
        // Configure the audio output.   
        synth.SetOutputToDefaultAudioDevice();  
  
        // Create a PromptBuilder object and append a file that defines an SSML prompt.  
        PromptBuilder ssmlFile = new PromptBuilder();  
        ssmlFile.AppendSsml("c:\\test\\Weather.ssml");  
  
        // Speak the contents of the SSML prompt.  
        synth.Speak(ssmlFile);  
      }  
  
      Console.WriteLine();  
      Console.WriteLine("Press any key to exit...");  
      Console.ReadKey();  
    }  
  }  
}  
  
```  
  
 Poniżej znajduje się plik SSML, który odwołuje się do poprzedniego przykładu.  
  
```xml  
<?xml version="1.0" encoding="ISO-8859-1"?>  
<speak version="1.0"  
 xmlns="http://www.w3.org/2001/10/synthesis"  
 xml:lang="en-US">  
  
  <s> The weather forecast for today is partly cloudy with some sun breaks. </s>  
  
</speak>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendSsml">
      <MemberSignature Language="C#" Value="public void AppendSsml (Uri ssmlFile);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendSsml(class System.Uri ssmlFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.AppendSsml(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendSsml (ssmlFile As Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendSsml(Uri ^ ssmlFile);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ssmlFile" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="ssmlFile">Pełny identyfikator URI do pliku SSML do dołączenia.</param>
        <summary>Dołącza plik SSML na określony identyfikator URI do <see cref="T:System.Speech.Synthesis.PromptBuilder" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Plik SSML musi być plikiem formatu XML, który odpowiada [mowy syntezy Markup Language (SSML) w wersji 1.0](https://www.w3.org/TR/speech-synthesis/) specyfikacji.  
  
 Można także dołączyć znaczników SSML jako ciągu przy użyciu <xref:System.Speech.Synthesis.PromptBuilder.AppendSsmlMarkup%2A>.  
  
   
  
## Examples  
 W następującym przykładzie jest tworzony <xref:System.Speech.Synthesis.PromptBuilder> obiektu i dołącza zawartość pliku SSML przy użyciu <xref:System.Speech.Synthesis.PromptBuilder.AppendSsml%2A> metody.  
  
```csharp  
using System;  
using System.Speech.Synthesis;  
  
namespace SampleSynthesis  
{  
  class Program  
  {  
    static void Main(string[] args)  
    {  
  
      // Initialize a new instance of the SpeechSynthesizer.  
      using (SpeechSynthesizer synth = new SpeechSynthesizer())  
      {  
  
        // Configure the audio output.   
        synth.SetOutputToDefaultAudioDevice();  
  
        // Create a PromptBuilder object and append a file that defines an SSML prompt.  
        PromptBuilder ssmlFile = new PromptBuilder();  
        ssmlFile.AppendSsml(new Uri("c:\\test\\Weather.ssml"));  
  
        // Speak the contents of the SSML prompt.  
        synth.Speak(ssmlFile);  
      }  
  
      Console.WriteLine();  
      Console.WriteLine("Press any key to exit...");  
      Console.ReadKey();  
    }  
  }  
}  
```  
  
 Poniżej znajduje się plik SSML, który odwołuje się do poprzedniego przykładu.  
  
```xml  
<?xml version="1.0" encoding="ISO-8859-1"?>  
<speak version="1.0"  
 xmlns="http://www.w3.org/2001/10/synthesis"  
 xml:lang="en-US">  
  
  <s> The weather forecast for today is partly cloudy with some sun breaks. </s>  
  
</speak>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendSsml">
      <MemberSignature Language="C#" Value="public void AppendSsml (System.Xml.XmlReader ssmlFile);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendSsml(class System.Xml.XmlReader ssmlFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.AppendSsml(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendSsml (ssmlFile As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendSsml(System::Xml::XmlReader ^ ssmlFile);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ssmlFile" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="ssmlFile">Pełna nazwa pliku XML do dołączenia.</param>
        <summary>Dołącza <c>XMLReader</c> obiekt, który odwołuje się do SSML monit <see cref="T:System.Speech.Synthesis.PromptBuilder" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Plik SSML musi być plikiem formatu XML, który odpowiada [mowy syntezy Markup Language (SSML) w wersji 1.0](https://www.w3.org/TR/speech-synthesis/) specyfikacji.  
  
 Można także dołączyć znaczników SSML jako ciągu przy użyciu <xref:System.Speech.Synthesis.PromptBuilder.AppendSsmlMarkup%2A>.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Speech.Synthesis.PromptBuilder> obiekt z <xref:System.Xml.XmlReader> obiektu, który odwołuje się do pliku zawierającego znaczników mowy syntezy Markup Language (SSML).  
  
```csharp  
using System;  
using System.Xml;  
using System.IO;  
using System.Speech.Synthesis;  
  
namespace SampleSynthesis  
{  
  class Program  
  {  
    static void Main(string[] args)  
    {  
  
      // Initialize a new instance of the SpeechSynthesizer.  
      using (SpeechSynthesizer synth = new SpeechSynthesizer())  
      {  
  
        // Configure the audio output.   
        synth.SetOutputToWaveFile(@"C:\test\weather.wav");  
  
        // Create a SoundPlayer instance to play the output audio file.  
        System.Media.SoundPlayer m_SoundPlayer =  
          new System.Media.SoundPlayer(@"C:\test\weather.wav");  
  
        // Create the path to the SSML file.  
        string weatherFile = Path.GetFullPath("c:\\test\\Weather.xml");  
        PromptBuilder builder = null;  
  
        // Create an XML Reader from the file, create a PromptBuilder and   
        // append the XmlReader.  
        if (File.Exists(weatherFile))  
        {  
          XmlReader reader = XmlReader.Create(weatherFile);  
          builder = new PromptBuilder();  
          builder.AppendSsml(reader);  
          reader.Close();  
        }  
  
        // Speak the prompt and play back the output file.  
        synth.Speak(builder);  
        m_SoundPlayer.Play();  
      }  
  
      Console.WriteLine();  
      Console.WriteLine("Press any key to exit...");  
      Console.ReadKey();  
    }  
  }  
}  
  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendSsmlMarkup">
      <MemberSignature Language="C#" Value="public void AppendSsmlMarkup (string ssmlMarkup);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendSsmlMarkup(string ssmlMarkup) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.AppendSsmlMarkup(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendSsmlMarkup (ssmlMarkup As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendSsmlMarkup(System::String ^ ssmlMarkup);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ssmlMarkup" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="ssmlMarkup">Ciąg zawierający SSML znacznik.</param>
        <summary>Dołącza określony ciąg zawierający znaczników SSML <see cref="T:System.Speech.Synthesis.PromptBuilder" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy użyć znaków ucieczki odpowiednie podczas dołączania znaczników SSML. Zwróć uwagę, z poprzednimi wersjami ułamkowe-poprzedzających cudzysłowów otaczającej wartość `interpret-as` atrybutu w poniższym przykładzie:  
  
```csharp  
builder.AppendSsmlMarkup("<say-as interpret-as = \"characters\"> chair </say-as>");  
```  
  
> [!NOTE]
>  Ciąg używany jako argument <xref:System.Speech.Synthesis.PromptBuilder.AppendSsmlMarkup%2A> nie może zawierać `speak` elementu.  
  
 Korzystając z <xref:System.Speech.Synthesis.PromptBuilder.AppendSsmlMarkup%2A> do określenia wymowy wbudowany w `phoneme` elementu, można użyć telefony z dowolnego z następujących fonetyczny małych liter, pod warunkiem że bieżącego aparatu rozpoznawania mowy obsługuje:  
  
-   Międzynarodowy alfabet fonetyczny (IPA)  
  
-   Phone uniwersalnego zestawu (UPS)  
  
-   Zestaw Phone SAPI  
  
 Wszystkie zgodne SSML aparat rozpoznawania mowy będzie odtwarzać telefony z IPA.  
  
 Można także dołączyć plik zawierający znaczników SSML przy użyciu jednej z <xref:System.Speech.Synthesis.PromptBuilder.AppendSsml%2A> metody. Aby dołączyć wymawianie tekstu, który nie jest sformatowany z językiem znaczników, użyj jednej z <xref:System.Speech.Synthesis.PromptBuilder.AppendText%2A>, <xref:System.Speech.Synthesis.PromptBuilder.AppendTextWithAlias%2A>, <xref:System.Speech.Synthesis.PromptBuilder.AppendTextWithHint%2A>, lub <xref:System.Speech.Synthesis.PromptBuilder.AppendTextWithPronunciation%2A> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendText">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dołącza tekst <see cref="T:System.Speech.Synthesis.PromptBuilder" /> obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendText">
      <MemberSignature Language="C#" Value="public void AppendText (string textToSpeak);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendText(string textToSpeak) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.AppendText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendText (textToSpeak As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendText(System::String ^ textToSpeak);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textToSpeak" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="textToSpeak">Ciąg zawierający tekst, który ma być używany.</param>
        <summary>Określa tekst, aby dołączyć do <see cref="T:System.Speech.Synthesis.PromptBuilder" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby dołączyć tekst sformatowany jako język znaczników SSML, należy użyć <xref:System.Speech.Synthesis.PromptBuilder.AppendSsmlMarkup%2A>.  
  
   
  
## Examples  
 W następującym przykładzie jest tworzony <xref:System.Speech.Synthesis.PromptBuilder> obiektu i dołącza ciąg tekstu za pomocą <xref:System.Speech.Synthesis.PromptBuilder.AppendText%2A> metody.  
  
```csharp  
using System;  
using System.Speech.Synthesis;  
  
namespace SampleSynthesis  
{  
  class Program  
  {  
    static void Main(string[] args)  
    {  
  
      // Initialize a new instance of the SpeechSynthesizer.  
      using (SpeechSynthesizer synth = new SpeechSynthesizer())  
      {  
  
        // Configure the audio output.   
        synth.SetOutputToDefaultAudioDevice();  
  
        // Create a PromptBuilder object and append a text string.  
        PromptBuilder speakText = new PromptBuilder();  
        speakText.AppendText("Say the name of the song you want to hear");  
  
        // Speak the contents of the prompt.  
        synth.Speak(speakText);  
      }  
  
      Console.WriteLine();  
      Console.WriteLine("Press any key to exit...");  
      Console.ReadKey();  
    }  
  }  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendText">
      <MemberSignature Language="C#" Value="public void AppendText (string textToSpeak, System.Speech.Synthesis.PromptEmphasis emphasis);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendText(string textToSpeak, valuetype System.Speech.Synthesis.PromptEmphasis emphasis) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.AppendText(System.String,System.Speech.Synthesis.PromptEmphasis)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendText (textToSpeak As String, emphasis As PromptEmphasis)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendText(System::String ^ textToSpeak, System::Speech::Synthesis::PromptEmphasis emphasis);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textToSpeak" Type="System.String" />
        <Parameter Name="emphasis" Type="System.Speech.Synthesis.PromptEmphasis" />
      </Parameters>
      <Docs>
        <param name="textToSpeak">Ciąg zawierający tekst, który ma być używany.</param>
        <param name="emphasis">Wartość dla wyróżnienia lub obciążenia do zastosowania w tekście.</param>
        <summary>Dołącza tekst <see cref="T:System.Speech.Synthesis.PromptBuilder" /> obiektu i określa stopień wyróżnienia do tekstu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aparaty syntezy w systemie Windows nie obsługują parametr wyróżnienia w tej chwili. Ustawienie wartości dla parametru nacisk powodują brak dźwiękowe zmian w danych wyjściowych syntezatora mowy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendText">
      <MemberSignature Language="C#" Value="public void AppendText (string textToSpeak, System.Speech.Synthesis.PromptRate rate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendText(string textToSpeak, valuetype System.Speech.Synthesis.PromptRate rate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.AppendText(System.String,System.Speech.Synthesis.PromptRate)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendText (textToSpeak As String, rate As PromptRate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendText(System::String ^ textToSpeak, System::Speech::Synthesis::PromptRate rate);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textToSpeak" Type="System.String" />
        <Parameter Name="rate" Type="System.Speech.Synthesis.PromptRate" />
      </Parameters>
      <Docs>
        <param name="textToSpeak">Ciąg zawierający tekst, który ma być używany.</param>
        <param name="rate">Wartość wymowy szybkość do zastosowania w tekście.</param>
        <summary>Dołącza tekst <see cref="T:System.Speech.Synthesis.PromptBuilder" /> obiektu i określa szybkość mowy tekstu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy <xref:System.Speech.Synthesis.PromptBuilder> obiektu i dołącza ciągów tekstowych. W przykładzie użyto <xref:System.Speech.Synthesis.PromptBuilder.AppendText%2A> metodę, aby określić powolne mówiąc szybkości dla ciągu dodawane, które wylicza zawartości zamówienia.  
  
```csharp  
using System;  
using System.Speech.Synthesis;  
  
namespace SampleSynthesis  
{  
  class Program  
  {  
    static void Main(string[] args)  
    {  
  
      // Initialize a new instance of the SpeechSynthesizer.  
      using (SpeechSynthesizer synth = new SpeechSynthesizer())  
      {  
  
        // Configure the audio output.   
        synth.SetOutputToDefaultAudioDevice();  
  
        // Create a PromptBuilder object and add content.  
        PromptBuilder speakRate = new PromptBuilder();  
        speakRate.AppendText("Your order for");  
        speakRate.AppendText("one kitchen sink and one faucet", PromptRate.Slow);  
        speakRate.AppendText("has been confirmed.");  
  
        // Speak the contents of the SSML prompt.  
        synth.Speak(speakRate);  
      }  
  
      Console.WriteLine();  
      Console.WriteLine("Press any key to exit...");  
      Console.ReadKey();  
    }  
  }  
}  
  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendText">
      <MemberSignature Language="C#" Value="public void AppendText (string textToSpeak, System.Speech.Synthesis.PromptVolume volume);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendText(string textToSpeak, valuetype System.Speech.Synthesis.PromptVolume volume) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.AppendText(System.String,System.Speech.Synthesis.PromptVolume)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendText (textToSpeak As String, volume As PromptVolume)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendText(System::String ^ textToSpeak, System::Speech::Synthesis::PromptVolume volume);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textToSpeak" Type="System.String" />
        <Parameter Name="volume" Type="System.Speech.Synthesis.PromptVolume" />
      </Parameters>
      <Docs>
        <param name="textToSpeak">Ciąg zawierający tekst, który ma być używany.</param>
        <param name="volume">Wartość dla woluminu mowy (głośności) do zastosowania w tekście.</param>
        <summary>Dołącza tekst <see cref="T:System.Speech.Synthesis.PromptBuilder" /> obiektu i określa wielkość porozmawiać tekst.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Synthesis.PromptVolume.Default> Ustawienie <xref:System.Speech.Synthesis.PromptVolume> jest całego woluminu, która jest taka sama jak <xref:System.Speech.Synthesis.PromptVolume.ExtraLoud>. Inne ustawienia zmniejszyć wolumin mowie względem całego woluminu.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Speech.Synthesis.PromptBuilder.AppendText%2A> metodę, aby określić ustawienia woluminu który <xref:System.Speech.Synthesis.SpeechSynthesizer> dotyczą mowie.  
  
```csharp  
using System;  
using System.Speech.Synthesis;  
  
namespace SampleSynthesis  
{  
  class Program  
  {  
    static void Main(string[] args)  
    {  
  
      // Initialize a new instance of the SpeechSynthesizer.  
      using (SpeechSynthesizer synth = new SpeechSynthesizer())  
      {  
  
        // Configure the audio output.   
        synth.SetOutputToDefaultAudioDevice();  
  
        // Build a prompt that applies different volume settings.  
        PromptBuilder builder = new PromptBuilder();  
        builder.AppendText("This is the default speaking volume.", PromptVolume.Default);  
        builder.AppendBreak();  
        builder.AppendText("This is the extra loud speaking volume.", PromptVolume.ExtraLoud);  
        builder.AppendBreak();  
        builder.AppendText("This is the medium speaking volume.", PromptVolume.Medium);  
  
        // Speak the prompt.  
        synth.Speak(builder);  
      }  
  
      Console.WriteLine();  
      Console.WriteLine("Press any key to exit...");  
      Console.ReadKey();  
    }  
  }  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendTextWithAlias">
      <MemberSignature Language="C#" Value="public void AppendTextWithAlias (string textToSpeak, string substitute);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendTextWithAlias(string textToSpeak, string substitute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.AppendTextWithAlias(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendTextWithAlias (textToSpeak As String, substitute As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendTextWithAlias(System::String ^ textToSpeak, System::String ^ substitute);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textToSpeak" Type="System.String" />
        <Parameter Name="substitute" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="textToSpeak">Ciąg zawierający Reprezentacja tekstowa.</param>
        <param name="substitute">Ciąg zawierający tekst, który ma być używany.</param>
        <summary>Dołącza tekst <see cref="T:System.Speech.Synthesis.PromptBuilder" /> obiektu i określa tekst alias wymawiane zamiast dołączony tekst.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dzięki temu dokument zawierający rozmowy i zapisywane formularza pojawił się monit. Na przykład napisane formularza może być skrótem, takich jak SAPI, a mówionej formy może być rozwinięty tekst akronim, w tym sprawy mowę Application Programming Interface.  
  
   
  
## Examples  
 Poniższy przykład dołącza ciąg tekstowy ("mowy syntezy Markup Language") i jego alias ("SSML") do <xref:System.Speech.Synthesis.PromptBuilder> obiektu. Syntezator będzie Wypowiedz "S S M L".  
  
```  
PromptBuilder alias = new PromptBuilder();  
alias.AppendTextWithAlias("Speech Synthesis Markup Language","SSML");   
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendTextWithHint">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dołącza tekst <see cref="T:System.Speech.Synthesis.PromptBuilder" /> obiektu i określa typ zawartości tekstu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendTextWithHint">
      <MemberSignature Language="C#" Value="public void AppendTextWithHint (string textToSpeak, System.Speech.Synthesis.SayAs sayAs);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendTextWithHint(string textToSpeak, valuetype System.Speech.Synthesis.SayAs sayAs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.AppendTextWithHint(System.String,System.Speech.Synthesis.SayAs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendTextWithHint(System::String ^ textToSpeak, System::Speech::Synthesis::SayAs sayAs);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textToSpeak" Type="System.String" />
        <Parameter Name="sayAs" Type="System.Speech.Synthesis.SayAs" />
      </Parameters>
      <Docs>
        <param name="textToSpeak">Ciąg zawierający tekst, który ma być używany.</param>
        <param name="sayAs">Typ zawartości tekstu.</param>
        <summary>Dołącza tekst <see cref="T:System.Speech.Synthesis.PromptBuilder" /> obiektu i określa typ zawartości przy użyciu członkiem <see cref="T:System.Speech.Synthesis.SayAs" /> wyliczenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Określony przez typ zawartości `sayAs` zapewniają wskazówki dotyczące aparat rozpoznawania mowy syntezy o Wymowa zawartość `textToSpeak`.  
  
   
  
## Examples  
  
```csharp  
using System;  
using System.Speech.Synthesis;  
  
namespace SampleSynthesis  
{  
  class Program  
  {  
    static void Main(string[] args)  
    {  
  
      // Initialize a new instance of the SpeechSynthesizer.  
      using (SpeechSynthesizer synth = new SpeechSynthesizer())  
      {  
  
        // Configure the audio output.   
        synth.SetOutputToDefaultAudioDevice();  
  
        // Create a PromptBuilder object and define the data types for some of the added strings.  
        PromptBuilder sayAs = new PromptBuilder();  
        sayAs.AppendText("Your");  
        sayAs.AppendTextWithHint("1st", SayAs.NumberOrdinal);  
        sayAs.AppendText("request was for");  
        sayAs.AppendTextWithHint("1", SayAs.NumberCardinal);  
        sayAs.AppendText("room, on");  
        sayAs.AppendTextWithHint("10/19/2012,", SayAs.MonthDayYear);  
        sayAs.AppendText("with early arrival at");  
        sayAs.AppendTextWithHint("12:35pm", SayAs.Time12);  
  
        // Speak the contents of the SSML prompt.  
        synth.Speak(sayAs);  
      }  
  
      Console.WriteLine();  
      Console.WriteLine("Press any key to exit...");  
      Console.ReadKey();  
    }  
  }  
}  
  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendTextWithHint">
      <MemberSignature Language="C#" Value="public void AppendTextWithHint (string textToSpeak, string sayAs);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendTextWithHint(string textToSpeak, string sayAs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.AppendTextWithHint(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendTextWithHint (textToSpeak As String, sayAs As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendTextWithHint(System::String ^ textToSpeak, System::String ^ sayAs);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textToSpeak" Type="System.String" />
        <Parameter Name="sayAs" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="textToSpeak">Ciąg zawierający tekst, który ma być używany.</param>
        <param name="sayAs">Typ zawartości tekstu.</param>
        <summary>Dołącza tekst <see cref="T:System.Speech.Synthesis.PromptBuilder" /> obiektu i <see cref="T:System.String" /> , który określa typ zawartości tekstu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do określania typu zawartości, które nie są uwzględnione w <xref:System.Speech.Synthesis.SayAs> wyliczenia. Jednak aparatu TTS musi obsługiwać parametr, który określisz.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendTextWithPronunciation">
      <MemberSignature Language="C#" Value="public void AppendTextWithPronunciation (string textToSpeak, string pronunciation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendTextWithPronunciation(string textToSpeak, string pronunciation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.AppendTextWithPronunciation(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendTextWithPronunciation (textToSpeak As String, pronunciation As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendTextWithPronunciation(System::String ^ textToSpeak, System::String ^ pronunciation);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textToSpeak" Type="System.String" />
        <Parameter Name="pronunciation" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="textToSpeak">Ciąg zawierający formularz napisane programu word za pomocą z konwencjonalnej alfabetu języka.</param>
        <param name="pronunciation">Ciąg zawierający telefony wymawiane z międzynarodowy alfabet fonetyczny (IPA).</param>
        <summary>Dołącza tekst <see cref="T:System.Speech.Synthesis.PromptBuilder" /> obiektu i określa wymowy tekstu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Syntezator mówi zawartość `pronunciation` parametr, nie zawartość `textToSpeak` parametru.  
  
 Wymowy określonym tekście monity mają zastosowanie tylko do pojedynczych wystąpień wyrazu i zastąpić wymowy aparat rozpoznawania mowy lub jego leksykonów obecnie aktywne. Zazwyczaj użyjesz wymowy wbudowanego wymowy niestandardowych słów istniejących lub wymowy rzadko słów, takich jak poprawnej nazwy, które syntezy aparat rozpoznawania mowy nie może Wypowiedz, a także oczekiwano.  
  
 Wbudowany wymowy musi być określona za pomocą telefony z międzynarodowy alfabet fonetyczny (IPA). Telefon jest literą lub znak, który reprezentuje niejawnego dźwięk mowy. Aparaty, które są zgodne z [mowy syntezy Markup Language (SSML) w wersji 1.0](http://go.microsoft.com/fwlink/?LinkId=201763) specyfikacji będzie Wypowiedz telefony z IPA. Aby określić przy użyciu innych alfabetach fonetyczny wymowy wbudowany, zobacz <xref:System.Speech.Synthesis.PromptBuilder.AppendSsmlMarkup%2A>.  
  
 Publikuje IPA [wykresu](http://go.microsoft.com/fwlink/?LinkId=58362) wyświetla jego telefony i mapuje je numery Unicode.  
  
 Niektórych telefonach alfabetu IPA mieć tego samego reprezentacje jako litery alfabetu łacińskiego. W takich przypadkach jest możliwe wpisz znak Latin i ma odpowiednie reprezentacji dla telefonu. Ponieważ znaki alfabetu łacińskiego, jak często używane w tekście może reprezentować kilka telefony zestawu phone IPA, po prostu wpisywania znaków łacińskich mogą utrudnić dokładne phone IPA potrzebne. Inne telefony IPA alfabetu konieczność można przedstawić w kodzie jako znak odwołania składające się z ampersand (&), znak numeru (#), a liczbą Unicode dla żądanego telefonu w formacie szesnastkowym lub decimal, wszystkie następuje średnik (;). Na przykład schwa (&\#x0259;) może być reprezentowany przez `&#x0259;`.  
  
 Aby dodać nowe lub niestandardowych wymowy wiele słów, na przykład dialekty express regionalnych lub dodać nazwiska lub słownictwa specyficzne dla dziedziny edukacji lub medyczne, Tworzenie słownika i dodać go do <xref:System.Speech.Synthesis.SpeechSynthesizer> przy użyciu <xref:System.Speech.Synthesis.SpeechSynthesizer.AddLexicon%2A>.  
  
   
  
## Examples  
 Poniższy przykład inicjuje nowe wystąpienie klasy <xref:System.Speech.Synthesis.PromptBuilder> klasy. Następnie dołącza ciągu tekstowego "mojej nazwy jest" do wystąpienia. Na koniec dołącza ciąg zawierający nazwę odpowiedniego "Ptak-Małysiak" i określa Wymowa nazwy.  
  
```csharp  
public void ProperName()  
{  
    PromptBuilder builder = new PromptBuilder();  
    builder.AppendText("My name is");  
  
    // Add a proper name and its pronunciation.  
    builder.AppendTextWithPronunciation("DuBois", "duˈbwɑ");     
}  
```  
  
 Następujący kod przedstawia SSML tego <xref:System.Speech.Synthesis.PromptBuilder> generuje obiektu.  
  
```xml  
<speak xmlns="http://www.w3.org/2001/10/synthesis" xml:lang="en-us">  
  My name is <phoneme ph="duˈbwɑ"> DuBois </phoneme>  
</speak>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearContent">
      <MemberSignature Language="C#" Value="public void ClearContent ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearContent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.ClearContent" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearContent ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearContent();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Czyści zawartość z <see cref="T:System.Speech.Synthesis.PromptBuilder" /> obiektu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Culture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo Culture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo Culture" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Synthesis.PromptBuilder.Culture" />
      <MemberSignature Language="VB.NET" Value="Public Property Culture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ Culture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia informacje o ustawieniach kulturowych dla <see cref="T:System.Speech.Synthesis.PromptBuilder" /> obiektu.</summary>
        <value>To be added.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Synthesis.SpeechSynthesizer> Obiektu będzie podejmować próby wybierz zainstalowanych głosowych, obsługujący język określony przez <xref:System.Speech.Synthesis.PromptBuilder.Culture%2A> właściwości do przetwarzania w wierszu. Jeśli zostanie znaleziony głosu z określonej kultury, będzie używany. Jeśli nie można odnaleźć głosu z określonej kultury, głosu domyślne będą używane.  
  
 Można także określić kulturę w wierszu niejawnego sekcji zawartości przy użyciu <xref:System.Speech.Synthesis.PromptBuilder.StartVoice%2A>, <xref:System.Speech.Synthesis.PromptBuilder.StartParagraph%2A>, i <xref:System.Speech.Synthesis.PromptBuilder.StartSentence%2A> metody. Kultura określona dla fragmentu zawartości przy użyciu jednej z metod powyżej spowoduje zastąpienie <xref:System.Speech.Synthesis.PromptBuilder.Culture%2A> właściwości, a w efekcie i <xref:System.Speech.Synthesis.SpeechSynthesizer> podejmie próbę wybierz zainstalowanych głosowych, obsługujący język określony przez `culture` Parametr metody.  
  
 Poprawnie Wymowa wyrazów w języku określonym przez <xref:System.Speech.Synthesis.PromptBuilder.Culture%2A> właściwości mowy aparatu syntezy (tekst na mowę lub TTS), obsługujący język musi być zainstalowany. Zainstalowany aparat TTS jest nazywany głosu. Aby uzyskać informacje o tym, które są zainstalowane głosy na określoną kulturę, użyj <xref:System.Speech.Synthesis.SpeechSynthesizer.GetInstalledVoices%2A> metody.  
  
 Microsoft Windows i interfejsu API System.Speech Zaakceptuj wszystkie prawidłowe kody kraju języka jako wartości `culture`. Aparaty TTS, które zostały wydane z systemem Windows 7 obsługuje następujące kody kraju języka:  
  
-   en-US. Angielski (Stany Zjednoczone)  
  
-   zh-CN. Chiński (Chiny)  
  
-   zh-TW. Chiński (Tajwan)  
  
 Dozwolone są również kodów dwuliterowych języka na przykład "en".  Zobacz [stałe identyfikator języka i ciągi](http://msdn.microsoft.com/library/dd318693\(VS.85\).aspx) Aby uzyskać pełną listę kodów języków.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndParagraph">
      <MemberSignature Language="C#" Value="public void EndParagraph ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndParagraph() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.EndParagraph" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndParagraph ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndParagraph();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Określa koniec akapitu w <see cref="T:System.Speech.Synthesis.PromptBuilder" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Długie monity może być renderowana bardziej przypominają mowy ludzi, jeśli są one podzielone na zdań i akapitów. Zobacz <xref:System.Speech.Synthesis.PromptBuilder.StartParagraph%2A> przykład.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndSentence">
      <MemberSignature Language="C#" Value="public void EndSentence ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndSentence() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.EndSentence" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndSentence ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndSentence();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Określa koniec zdanie w <see cref="T:System.Speech.Synthesis.PromptBuilder" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Długie monity może być renderowana bardziej przypominają mowy ludzi, jeśli są one podzielone na zdań i akapitów. Zobacz <xref:System.Speech.Synthesis.PromptBuilder.StartSentence%2A> przykład.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndStyle">
      <MemberSignature Language="C#" Value="public void EndStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.EndStyle" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndStyle ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndStyle();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Określa koniec stylu w <see cref="T:System.Speech.Synthesis.PromptBuilder" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Synthesis.PromptBuilder.EndStyle%2A> Metoda zatrzymuje bieżącego wymowy. Wymowy powraca do ustawienia, które obowiązywały przed były <xref:System.Speech.Synthesis.PromptBuilder.StartStyle%2A> metody zainicjował nowe wymowy. Zobacz <xref:System.Speech.Synthesis.PromptBuilder.StartStyle%2A> przykład.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndVoice">
      <MemberSignature Language="C#" Value="public void EndVoice ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndVoice() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.EndVoice" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndVoice ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndVoice();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Określa koniec użyj głosu w <see cref="T:System.Speech.Synthesis.PromptBuilder" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Synthesis.PromptBuilder.EndVoice%2A> Metoda zatrzymuje stosowania bieżący głos mowie. Głos powraca do ustawienia, które obowiązywały przed były <xref:System.Speech.Synthesis.PromptBuilder.StartVoice%2A> metody zainicjował nowy głos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEmpty">
      <MemberSignature Language="C#" Value="public bool IsEmpty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEmpty" />
      <MemberSignature Language="DocId" Value="P:System.Speech.Synthesis.PromptBuilder.IsEmpty" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsEmpty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEmpty { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera czy <see cref="T:System.Speech.Synthesis.PromptBuilder" /> jest pusta.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="StartParagraph">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Określa początek akapitu w <see cref="T:System.Speech.Synthesis.PromptBuilder" /> obiekt oraz opcjonalnie określa język.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Długie monity może być renderowana bardziej przypominają mowy ludzi, jeśli są one podzielone na zdań i akapitów.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="StartParagraph">
      <MemberSignature Language="C#" Value="public void StartParagraph ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void StartParagraph() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.StartParagraph" />
      <MemberSignature Language="VB.NET" Value="Public Sub StartParagraph ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void StartParagraph();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Określa początek akapitu w <see cref="T:System.Speech.Synthesis.PromptBuilder" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Długie monity może być renderowana bardziej przypominają mowy ludzi, jeśli są one podzielone na zdań i akapitów.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Speech.Synthesis.PromptBuilder> obiekt, dołącza zawartość i organizuje zawartość w akapitów i zdań.  
  
```csharp  
using System;  
using System.Speech.Synthesis;  
  
namespace SampleSynthesis  
{  
  class Program  
  {  
    static void Main(string[] args)  
    {  
  
      // Initialize a new instance of the SpeechSynthesizer.  
      using (SpeechSynthesizer synth = new SpeechSynthesizer())  
      {  
  
        // Configure the audio output.   
        synth.SetOutputToDefaultAudioDevice();  
  
        // Create a PromptBuilder object and add content as paragraphs and sentences.  
        PromptBuilder parSent = new PromptBuilder();  
        parSent.StartParagraph();  
        parSent.StartSentence();  
        parSent.AppendText("Introducing the sentence element.");  
        parSent.EndSentence();  
        parSent.StartSentence();  
        parSent.AppendText("You can use it to mark individual sentences.");  
        parSent.EndSentence();  
        parSent.EndParagraph();  
        parSent.StartParagraph();  
        parSent.AppendText("Another simple paragraph. Sentence structure in this paragraph" +  
          "is not explicitly marked.");  
        parSent.EndParagraph();  
  
        // Speak the contents of the SSML prompt.  
        synth.Speak(parSent);  
      }  
  
      Console.WriteLine();  
      Console.WriteLine("Press any key to exit...");  
      Console.ReadKey();  
    }  
  }  
}  
  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StartParagraph">
      <MemberSignature Language="C#" Value="public void StartParagraph (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void StartParagraph(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.StartParagraph(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Sub StartParagraph (culture As CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void StartParagraph(System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="culture">Zawiera informacje o określoną kulturę, takich jak język, nazwę kultury, system pisma i używany kalendarz i sposób formatowania dat i sortowania ciągów.</param>
        <summary>Określa początek akapitu w określonej kultury w <see cref="T:System.Speech.Synthesis.PromptBuilder" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Długie monity może być renderowana bardziej przypominają mowy ludzi, jeśli są one podzielone na zdań i akapitów.  
  
 `culture` Parametr akapitu może być inny niż <xref:System.Speech.Synthesis.PromptBuilder.Culture%2A> właściwość <xref:System.Speech.Synthesis.PromptBuilder> obiektu, który go zawiera. W efekcie podczas wartość `culture` spowoduje zastąpienie parametru <xref:System.Speech.Synthesis.PromptBuilder.Culture%2A> właściwości. <xref:System.Speech.Synthesis.SpeechSynthesizer> Podejmie próbę wybierz zainstalowanych głosowych, obsługujący język określony przez `culture` parametru porozmawiać akapitu. Jeśli zostanie znaleziony głosu z określonej kultury, będzie używany. Jeśli nie można odnaleźć głosu z określonej kultury, głosu domyślne będą używane. Aby zaprzestać używania głosu określony przez <xref:System.Speech.Synthesis.PromptBuilder.StartParagraph%2A>, wywołaj <xref:System.Speech.Synthesis.PromptBuilder.EndParagraph%2A>.  
  
 Poprawnie Wymowa wyrazów w języku określonym przez `culture` parametru mowy aparatu syntezy (tekst na mowę lub TTS), obsługujący język musi być zainstalowany. Zainstalowany aparat TTS jest nazywany głosu. Aby uzyskać informacje o tym, które są zainstalowane głosy na określoną kulturę, użyj <xref:System.Speech.Synthesis.SpeechSynthesizer.GetInstalledVoices%2A> metody.  
  
 Microsoft Windows i interfejsu API System.Speech Zaakceptuj wszystkie prawidłowe kody kraju języka jako wartości `culture`. Aparaty TTS, które zostały wydane z systemem Windows 7 obsługuje następujące kody kraju języka:  
  
-   en-US. Angielski (Stany Zjednoczone)  
  
-   zh-CN. Chiński (Chiny)  
  
-   zh-TW. Chiński (Tajwan)  
  
 Dozwolone są również kodów dwuliterowych języka na przykład "en".  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="StartSentence">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Określa początek zdanie w <see cref="T:System.Speech.Synthesis.PromptBuilder" /> obiekt oraz opcjonalnie określa język.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Długie monity może być renderowana bardziej przypominają mowy ludzi, jeśli są one podzielone na zdań i akapitów.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="StartSentence">
      <MemberSignature Language="C#" Value="public void StartSentence ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void StartSentence() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.StartSentence" />
      <MemberSignature Language="VB.NET" Value="Public Sub StartSentence ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void StartSentence();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Określa początek zdanie w <see cref="T:System.Speech.Synthesis.PromptBuilder" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Długie monity może być renderowana bardziej przypominają mowy ludzi, jeśli są one podzielone na zdań i akapitów.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Speech.Synthesis.PromptBuilder> obiekt, dołącza zawartość i organizuje zawartość w akapitów i zdań.  
  
```csharp  
using System;  
using System.Speech.Synthesis;  
  
namespace SampleSynthesis  
{  
  class Program  
  {  
    static void Main(string[] args)  
    {  
  
      // Initialize a new instance of the SpeechSynthesizer.  
      using (SpeechSynthesizer synth = new SpeechSynthesizer())  
      {  
  
        // Configure the audio output.   
        synth.SetOutputToDefaultAudioDevice();  
  
        // Create a PromptBuilder object and add content as paragraphs and sentences.  
        PromptBuilder parSent = new PromptBuilder();  
        parSent.StartParagraph();  
        parSent.StartSentence();  
        parSent.AppendText("Introducing the sentence element.");  
        parSent.EndSentence();  
        parSent.StartSentence();  
        parSent.AppendText("You can use it to mark individual sentences.");  
        parSent.EndSentence();  
        parSent.EndParagraph();  
        parSent.StartParagraph();  
        parSent.AppendText("Another simple paragraph. Sentence structure in this paragraph" +  
          "is not explicitly marked.");  
        parSent.EndParagraph();  
  
        // Speak the contents of the SSML prompt.  
        synth.Speak(parSent);  
      }  
  
      Console.WriteLine();  
      Console.WriteLine("Press any key to exit...");  
      Console.ReadKey();  
    }  
  }  
}  
  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StartSentence">
      <MemberSignature Language="C#" Value="public void StartSentence (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void StartSentence(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.StartSentence(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Sub StartSentence (culture As CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void StartSentence(System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="culture">Zawiera informacje o określoną kulturę, takich jak język, nazwę kultury, system pisma i używany kalendarz i sposób formatowania dat i sortowania ciągów.</param>
        <summary>Określa początek zdanie w określonej kultury w <see cref="T:System.Speech.Synthesis.PromptBuilder" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Długie monity może być renderowana bardziej przypominają mowy ludzi, jeśli są one podzielone na zdań i akapitów.  
  
 `culture` Parametr zdania może być inna niż `culture` parametr akapit, który zawiera zdanie lub <xref:System.Speech.Synthesis.PromptBuilder.Culture%2A> właściwość <xref:System.Speech.Synthesis.PromptBuilder> obiektu, który je zawiera.  
  
 W efekcie podczas wartość `culture` spowoduje zastąpienie parametru <xref:System.Speech.Synthesis.PromptBuilder.Culture%2A> właściwości i `culture` parametr akapit, który zawiera zdanie. <xref:System.Speech.Synthesis.SpeechSynthesizer> Podejmie próbę wybierz zainstalowanych głosowych, obsługujący język określony przez `culture` parametru porozmawiać zdanie. Jeśli zostanie znaleziony głosu z określonej kultury, będzie używany. Jeśli nie można odnaleźć głosu z określonej kultury, głosu domyślne będą używane. Aby zaprzestać używania głosu określony przez <xref:System.Speech.Synthesis.PromptBuilder.StartSentence%2A>, wywołaj <xref:System.Speech.Synthesis.PromptBuilder.EndSentence%2A>.  
  
 Poprawnie Wymowa wyrazów w języku określonym przez `culture` parametru mowy aparatu syntezy (tekst na mowę lub TTS), obsługujący język musi być zainstalowany. Zainstalowany aparat TTS jest nazywany głosu. Aby uzyskać informacje o tym, które są zainstalowane głosy na określoną kulturę, użyj <xref:System.Speech.Synthesis.SpeechSynthesizer.GetInstalledVoices%2A> metody.  
  
 Microsoft Windows i interfejsu API System.Speech Zaakceptuj wszystkie prawidłowe kody kraju języka jako wartości `culture`. Aparaty TTS, które zostały wydane z systemem Windows 7 obsługuje następujące kody kraju języka:  
  
-   en-US. Angielski (Stany Zjednoczone)  
  
-   zh-CN. Chiński (Chiny)  
  
-   zh-TW. Chiński (Tajwan)  
  
 Dozwolone są również kodów dwuliterowych języka na przykład "en".  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StartStyle">
      <MemberSignature Language="C#" Value="public void StartStyle (System.Speech.Synthesis.PromptStyle style);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void StartStyle(class System.Speech.Synthesis.PromptStyle style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.StartStyle(System.Speech.Synthesis.PromptStyle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub StartStyle (style As PromptStyle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void StartStyle(System::Speech::Synthesis::PromptStyle ^ style);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="style" Type="System.Speech.Synthesis.PromptStyle" />
      </Parameters>
      <Docs>
        <param name="style">Styl, aby rozpocząć.</param>
        <summary>Określa początek stylu w <see cref="T:System.Speech.Synthesis.PromptBuilder" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Synthesis.PromptBuilder.StartStyle%2A> Ma metodę <xref:System.Speech.Synthesis.PromptStyle> obiektu jako jej argument. Można użyć właściwości <xref:System.Speech.Synthesis.PromptStyle> obiektu w celu ustawienia wyróżnienia mówiąc szybkości i woluminów (głośności) do zastosowania do mowy output styl w czasie działania. Aby zatrzymać przy użyciu bieżącego stylu, należy wywołać <xref:System.Speech.Synthesis.PromptBuilder.EndStyle%2A> metody.  
  
> [!NOTE]
>  -   Aparaty syntezy w systemie Windows nie obsługują parametr wyróżnienia w tej chwili. Ustawienie wartości dla parametru nacisk powodują brak dźwiękowe zmian w danych wyjściowych syntezatora mowy.  
> -   <xref:System.Speech.Synthesis.PromptVolume.Default> Ustawienie <xref:System.Speech.Synthesis.PromptVolume> jest całego woluminu, która jest taka sama jak <xref:System.Speech.Synthesis.PromptVolume.ExtraLoud>. Inne ustawienia zmniejszyć wolumin mowie względem całego woluminu.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Speech.Synthesis.PromptBuilder> obiektu i dołącza ciągów tekstowych. W przykładzie użyto <xref:System.Speech.Synthesis.PromptBuilder.StartStyle%2A> metodę, aby określić powolne mówiąc szybkości dla ciągu dodawane, które wylicza zawartości zamówienia.  
  
```csharp  
using System;  
using System.Speech.Synthesis;  
  
namespace SampleSynthesis  
{  
  class Program  
  {  
    static void Main(string[] args)  
    {  
  
      // Initialize a new instance of the SpeechSynthesizer.  
      using (SpeechSynthesizer synth = new SpeechSynthesizer())  
      {  
  
        // Configure the audio output.   
        synth.SetOutputToDefaultAudioDevice();  
  
        // Create a PromptBuilder object and add content.  
        PromptBuilder style = new PromptBuilder();  
        style.AppendText("Your order for");  
        style.StartStyle(new PromptStyle(PromptRate.Slow));  
        style.AppendText("one kitchen sink and one faucet");  
        style.EndStyle();  
        style.AppendText("has been confirmed.");  
  
        // Speak the contents of the SSML prompt.  
        synth.Speak(style);  
      }  
  
      Console.WriteLine();  
      Console.WriteLine("Press any key to exit...");  
      Console.ReadKey();  
    }  
  }  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="StartVoice">
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Powoduje, że Syntezator zmienić głosowe w <see cref="T:System.Speech.Synthesis.PromptBuilder" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Głosu reprezentuje zainstalowanych aparatu TTS. Użyj <xref:System.Speech.Synthesis.SpeechSynthesizer.GetInstalledVoices%2A> metod i <xref:System.Speech.Synthesis.VoiceInfo> klasy można uzyskać nazwy i atrybuty zainstalowany głosy tekst na mowę (TTS), które można wybrać.  
  
 Gdy aplikacja wywołuje <xref:System.Speech.Synthesis.SpeechSynthesizer.GetInstalledVoices%2A>, ta metoda sprawdza, czy każdy głosy znajdzie się w rejestrze spełnia określone kryteria minimalne. Wszelkie głosu Niepowodzenie weryfikacji <xref:System.Speech.Synthesis.SpeechSynthesizer.GetInstalledVoices%2A> ustawia jego <xref:System.Speech.Synthesis.InstalledVoice.Enabled%2A> właściwości `False`. Aplikacji nie można wywołać żadnego z <xref:System.Speech.Synthesis.PromptBuilder.StartVoice%2A> metody głosu których <xref:System.Speech.Synthesis.InstalledVoice.Enabled%2A> jest właściwość `False`. Zwykle, aplikacje nie ustawi głosu <xref:System.Speech.Synthesis.InstalledVoice.Enabled%2A> właściwości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="StartVoice">
      <MemberSignature Language="C#" Value="public void StartVoice (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void StartVoice(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.StartVoice(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Sub StartVoice (culture As CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void StartVoice(System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="culture">Zawiera informacje o określoną kulturę, takich jak język, nazwę kultury, system pisma i używany kalendarz i sposób formatowania dat i sortowania ciągów.</param>
        <summary>Powoduje, że Syntezator zmienić głosowe w <see cref="T:System.Speech.Synthesis.PromptBuilder" /> obiektu i określa kulturę głosu do użycia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `culture` Parametr <xref:System.Speech.Synthesis.PromptBuilder.StartVoice%2A> może być inna niż <xref:System.Speech.Synthesis.PromptBuilder.Culture%2A> właściwość <xref:System.Speech.Synthesis.PromptBuilder> obiektu, który go zawiera.  W efekcie podczas wartość `culture` spowoduje zastąpienie parametru <xref:System.Speech.Synthesis.PromptBuilder.Culture%2A> właściwości. <xref:System.Speech.Synthesis.SpeechSynthesizer> Podejmie próbę wybierz zainstalowanych głosowych, obsługujący język określony przez `culture` parametru porozmawiać zawartości umieszczonej w <xref:System.Speech.Synthesis.PromptBuilder.StartVoice%2A> i <xref:System.Speech.Synthesis.PromptBuilder.EndVoice%2A>. Jeśli zostanie znaleziony głosu z określonej kultury, będzie używany. Jeśli nie można odnaleźć głosu z określonej kultury, głosu domyślne będą używane. Aby zaprzestać używania głosu określony przez <xref:System.Speech.Synthesis.PromptBuilder.StartVoice%2A>, wywołaj <xref:System.Speech.Synthesis.PromptBuilder.EndVoice%2A>.  
  
 Poprawnie Wymowa wyrazów w języku określonym przez `culture` parametru mowy aparatu syntezy (tekst na mowę lub TTS), obsługujący język musi być zainstalowany. Zainstalowany aparat TTS jest nazywany głosu. Aby uzyskać informacje o tym, które są zainstalowane głosy na określoną kulturę, użyj <xref:System.Speech.Synthesis.SpeechSynthesizer.GetInstalledVoices%2A> metody.  
  
 Microsoft Windows i interfejsu API System.Speech Zaakceptuj wszystkie prawidłowe kody kraju języka jako wartości `culture`. Aparaty TTS, które zostały wydane z systemem Windows 7 obsługuje następujące kody kraju języka:  
  
-   en-US. Angielski (Stany Zjednoczone)  
  
-   zh-CN. Chiński (Chiny)  
  
-   zh-TW. Chiński (Tajwan)  
  
 Dozwolone są również kodów dwuliterowych języka na przykład "en".  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StartVoice">
      <MemberSignature Language="C#" Value="public void StartVoice (System.Speech.Synthesis.VoiceGender gender);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void StartVoice(valuetype System.Speech.Synthesis.VoiceGender gender) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.StartVoice(System.Speech.Synthesis.VoiceGender)" />
      <MemberSignature Language="VB.NET" Value="Public Sub StartVoice (gender As VoiceGender)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void StartVoice(System::Speech::Synthesis::VoiceGender gender);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="gender" Type="System.Speech.Synthesis.VoiceGender" />
      </Parameters>
      <Docs>
        <param name="gender">Płeć głosu do użycia.</param>
        <summary>Powoduje, że Syntezator zmienić głosowe w <see cref="T:System.Speech.Synthesis.PromptBuilder" /> obiektu i określa płci głosu do użycia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Speech.Synthesis.SpeechSynthesizer.GetInstalledVoices%2A> metod i <xref:System.Speech.Synthesis.VoiceInfo> klasy można uzyskać nazwy i atrybuty zainstalowany głosy tekst na mowę (TTS), które można wybrać.  
  
 Aby zaprzestać używania głosu określony przez <xref:System.Speech.Synthesis.PromptBuilder.StartVoice%2A> wywołania <xref:System.Speech.Synthesis.PromptBuilder.EndVoice%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StartVoice">
      <MemberSignature Language="C#" Value="public void StartVoice (System.Speech.Synthesis.VoiceInfo voice);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void StartVoice(class System.Speech.Synthesis.VoiceInfo voice) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.StartVoice(System.Speech.Synthesis.VoiceInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Sub StartVoice (voice As VoiceInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void StartVoice(System::Speech::Synthesis::VoiceInfo ^ voice);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="voice" Type="System.Speech.Synthesis.VoiceInfo" />
      </Parameters>
      <Docs>
        <param name="voice">Kryteria głosu do użycia.</param>
        <summary>Powoduje, że Syntezator zmienić głosowe w <see cref="T:System.Speech.Synthesis.PromptBuilder" /> obiektu i określa kryteria nowy głos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Speech.Synthesis.SpeechSynthesizer.GetInstalledVoices%2A> metod i <xref:System.Speech.Synthesis.VoiceInfo> klasy można uzyskać nazwy i atrybuty zainstalowany głosy tekst na mowę (TTS), które można wybrać.  
  
 Aby zaprzestać używania głosu określony przez <xref:System.Speech.Synthesis.PromptBuilder.StartVoice%2A> wywołania <xref:System.Speech.Synthesis.PromptBuilder.EndVoice%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StartVoice">
      <MemberSignature Language="C#" Value="public void StartVoice (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void StartVoice(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.StartVoice(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub StartVoice (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void StartVoice(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa głosu do użycia.</param>
        <summary>Powoduje, że Syntezator zmienić głosowe w <see cref="T:System.Speech.Synthesis.PromptBuilder" /> obiektu i określa nazwę głosu do użycia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać informacje o tym, które są zainstalowane głosy, użyj jednej z <xref:System.Speech.Synthesis.SpeechSynthesizer.GetInstalledVoices%2A> metody.  
  
 Aby zaprzestać używania głosu określony przez <xref:System.Speech.Synthesis.PromptBuilder.StartVoice%2A> wywołania <xref:System.Speech.Synthesis.PromptBuilder.EndVoice%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StartVoice">
      <MemberSignature Language="C#" Value="public void StartVoice (System.Speech.Synthesis.VoiceGender gender, System.Speech.Synthesis.VoiceAge age);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void StartVoice(valuetype System.Speech.Synthesis.VoiceGender gender, valuetype System.Speech.Synthesis.VoiceAge age) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.StartVoice(System.Speech.Synthesis.VoiceGender,System.Speech.Synthesis.VoiceAge)" />
      <MemberSignature Language="VB.NET" Value="Public Sub StartVoice (gender As VoiceGender, age As VoiceAge)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void StartVoice(System::Speech::Synthesis::VoiceGender gender, System::Speech::Synthesis::VoiceAge age);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="gender" Type="System.Speech.Synthesis.VoiceGender" />
        <Parameter Name="age" Type="System.Speech.Synthesis.VoiceAge" />
      </Parameters>
      <Docs>
        <param name="gender">Płeć nowy głos do użycia.</param>
        <param name="age">Wiek głosu do użycia.</param>
        <summary>Powoduje, że Syntezator zmienić głosowe w <see cref="T:System.Speech.Synthesis.PromptBuilder" /> obiektu i określa płeć i wiek nowy głos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Speech.Synthesis.SpeechSynthesizer.GetInstalledVoices%2A> metod i <xref:System.Speech.Synthesis.VoiceInfo> klasy można uzyskać nazwy i atrybuty zainstalowany głosy tekst na mowę (TTS), które można wybrać.  
  
 Aby zaprzestać używania głosu określony przez <xref:System.Speech.Synthesis.PromptBuilder.StartVoice%2A> wywołania <xref:System.Speech.Synthesis.PromptBuilder.EndVoice%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StartVoice">
      <MemberSignature Language="C#" Value="public void StartVoice (System.Speech.Synthesis.VoiceGender gender, System.Speech.Synthesis.VoiceAge age, int voiceAlternate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void StartVoice(valuetype System.Speech.Synthesis.VoiceGender gender, valuetype System.Speech.Synthesis.VoiceAge age, int32 voiceAlternate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.StartVoice(System.Speech.Synthesis.VoiceGender,System.Speech.Synthesis.VoiceAge,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub StartVoice (gender As VoiceGender, age As VoiceAge, voiceAlternate As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void StartVoice(System::Speech::Synthesis::VoiceGender gender, System::Speech::Synthesis::VoiceAge age, int voiceAlternate);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="gender" Type="System.Speech.Synthesis.VoiceGender" />
        <Parameter Name="age" Type="System.Speech.Synthesis.VoiceAge" />
        <Parameter Name="voiceAlternate" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="gender">Płeć głosu do użycia.</param>
        <param name="age">Wiek głosu do użycia.</param>
        <param name="voiceAlternate">Liczba całkowita określająca preferowany głosowych, gdy jest zgodna z więcej niż jeden głos <c>płci</c> i <c>wieku</c> parametrów.</param>
        <summary>Powoduje, że Syntezator zmienić głosowe w <see cref="T:System.Speech.Synthesis.PromptBuilder" /> obiektu i określa jego płci, wieku i preferowany głosu zgodny z określonym płci i wiek.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aparat syntezy mowy liczby dopasowań wyszukiwanie określonych parametrów i zwraca głosu, gdy liczba jest równa `voiceAlternate` parametru.  
  
 Użyj <xref:System.Speech.Synthesis.SpeechSynthesizer.GetInstalledVoices%2A> metod i <xref:System.Speech.Synthesis.VoiceInfo> klasy można uzyskać nazwy i atrybuty zainstalowany głosy tekst na mowę (TTS), które można wybrać.  
  
 Aby zaprzestać używania głosu określony przez <xref:System.Speech.Synthesis.PromptBuilder.StartVoice%2A> wywołania <xref:System.Speech.Synthesis.PromptBuilder.EndVoice%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Speech.Synthesis.PromptBuilder.StartVoice(System.Speech.Synthesis.VoiceGender,System.Speech.Synthesis.VoiceAge)" />
      </Docs>
    </Member>
    <Member MemberName="ToXml">
      <MemberSignature Language="C#" Value="public string ToXml ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToXml() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Speech.Synthesis.PromptBuilder.ToXml" />
      <MemberSignature Language="VB.NET" Value="Public Function ToXml () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToXml();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Speech</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca SSML generowane na podstawie <see cref="T:System.Speech.Synthesis.PromptBuilder" /> obiektu.</summary>
        <returns>Zwraca SSML generowane na podstawie <see cref="T:System.Speech.Synthesis.PromptBuilder" /> obiektu jako jeden wiersz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Speech.Synthesis.PromptBuilder.ToXml%2A> Metody sprawia, że próba sformatować zwrócony SSML w dowolny sposób.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Speech.Synthesis.PromptBuilder> obiektu, dołącza tekstu, a następnie zapisuje odpowiednik SSML w wierszu polecenia programu do konsoli, przed mówiąc zawartość wiersza.  
  
```csharp  
  
using System;  
using System.Speech.Synthesis;  
  
namespace SampleSynthesis  
{  
  class Program  
  {  
    static void Main(string[] args)  
    {  
  
      // Initialize a new instance of the SpeechSynthesizer.  
      using (SpeechSynthesizer synth = new SpeechSynthesizer())  
      {  
  
        // Configure the audio output.   
        synth.SetOutputToDefaultAudioDevice();  
  
        // Create a PromptBuilder object and add content.  
        PromptBuilder style = new PromptBuilder();  
        style.AppendText("Your order for");  
        style.StartStyle(new PromptStyle(PromptRate.Slow));  
        style.AppendText("one kitchen sink and one faucet");  
        style.EndStyle();  
        style.AppendText("has been confirmed.");  
  
        // Write the contents of the PromptBuilder object to the console as  
        // an SSML-compatible XML file.  
        string myXml = style.ToXml();  
        Console.WriteLine("This is the SSML equivalent of the PromptBuilder: \n\n" + myXml);  
  
        // Speak the contents of the SSML prompt.  
        synth.Speak(style);  
      }  
  
      Console.WriteLine();  
      Console.WriteLine("Press any key to exit...");  
      Console.ReadKey();  
    }  
  }  
}  
  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
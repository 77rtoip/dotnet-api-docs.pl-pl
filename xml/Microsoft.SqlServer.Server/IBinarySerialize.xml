<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="IBinarySerialize.xml" source-language="en-US" target-language="pl-PL">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5aa6d2af7371832ccbdde5ed90bb40f43e554dba4.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">aa6d2af7371832ccbdde5ed90bb40f43e554dba4</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:Microsoft.SqlServer.Server.IBinarySerialize">
          <source>Provides custom implementation for user-defined type (UDT) and user-defined aggregate serialization and deserialization.</source>
          <target state="translated">Udostępnia implementację niestandardowych dla typu zdefiniowanego przez użytkownika (UDT) i zdefiniowanych przez użytkownika agregacji serializacji i deserializacji.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:Microsoft.SqlServer.Server.IBinarySerialize">
          <source>User-defined types (UDTs) and user-defined aggregates are required to define a storage format, which can be either <ph id="ph1">&lt;xref:Microsoft.SqlServer.Server.Format&gt;</ph>.<ph id="ph2">`Native`</ph></source>
          <target state="translated">Typy danych zdefiniowane przez użytkownika (UDTs) i agregacje zdefiniowane przez użytkownika są wymagane do zdefiniowania formacie magazynu, które mogą być <ph id="ph1">&lt;xref:Microsoft.SqlServer.Server.Format&gt;</ph>.<ph id="ph2">`Native`</ph></target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:Microsoft.SqlServer.Server.IBinarySerialize">
          <source>or <ph id="ph1">&lt;xref:Microsoft.SqlServer.Server.Format&gt;</ph>.<ph id="ph2">`UserDefined`</ph>.</source>
          <target state="translated">lub <ph id="ph1">&lt;xref:Microsoft.SqlServer.Server.Format&gt;</ph>.<ph id="ph2">`UserDefined`</ph>.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:Microsoft.SqlServer.Server.IBinarySerialize">
          <source><ph id="ph1">&lt;xref:Microsoft.SqlServer.Server.Format&gt;</ph>.<ph id="ph2">`Native`</ph></source>
          <target state="translated"><ph id="ph1">&lt;xref:Microsoft.SqlServer.Server.Format&gt;</ph>.<ph id="ph2">`Native`</ph></target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:Microsoft.SqlServer.Server.IBinarySerialize">
          <source>allows SQL Server to handle serialization and deserialization automatically, but the format has restrictions on the kind of types it can handle.</source>
          <target state="translated">zezwala programowi SQL Server do obsługi serializacji i deserializacji automatycznie, ale format ma ograniczenia typu typów, które może obsługiwać.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:Microsoft.SqlServer.Server.IBinarySerialize">
          <source><ph id="ph1">&lt;xref:Microsoft.SqlServer.Server.Format&gt;</ph>.<ph id="ph2">`UserDefined`</ph></source>
          <target state="translated"><ph id="ph1">&lt;xref:Microsoft.SqlServer.Server.Format&gt;</ph>.<ph id="ph2">`UserDefined`</ph></target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:Microsoft.SqlServer.Server.IBinarySerialize">
          <source>allows user-defined types and aggregates to handle their own serialization.</source>
          <target state="translated">Umożliwia typy danych zdefiniowane przez użytkownika która agreguje obsługują własną serializację.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:Microsoft.SqlServer.Server.IBinarySerialize">
          <source>User-defined types and aggregates must be marked with <ph id="ph1">&lt;xref:Microsoft.SqlServer.Server.Format&gt;</ph>.<ph id="ph2">`UserDefined`</ph></source>
          <target state="translated">Typy definiowane przez użytkownika i wartości zagregowanych muszą być oznaczone <ph id="ph1">&lt;xref:Microsoft.SqlServer.Server.Format&gt;</ph>.<ph id="ph2">`UserDefined`</ph></target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:Microsoft.SqlServer.Server.IBinarySerialize">
          <source>in the <ph id="ph1">`SqlUserDefinedType`</ph> or <ph id="ph2">`SqlUserDefinedAggregate`</ph> attribute, and must implement the <ph id="ph3">&lt;xref:Microsoft.SqlServer.Server.IBinarySerialize&gt;</ph> interface.</source>
          <target state="translated">w <ph id="ph1">`SqlUserDefinedType`</ph> lub <ph id="ph2">`SqlUserDefinedAggregate`</ph> atrybutu i musi implementować <ph id="ph3">&lt;xref:Microsoft.SqlServer.Server.IBinarySerialize&gt;</ph> interfejsu.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:Microsoft.SqlServer.Server.IBinarySerialize">
          <source>Note that even with custom serialization, the total size of each instance must be under the maximum allowed limit, currently 8000 bytes.</source>
          <target state="translated">Pamiętaj, że nawet w przypadku serializacji niestandardowej całkowity rozmiar każde wystąpienie musi być w obszarze maksymalny dozwolony limit, obecnie 8000 bajtów.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" uid="M:Microsoft.SqlServer.Server.IBinarySerialize.Read(System.IO.BinaryReader)">
          <source>The <ph id="ph1">&lt;see cref="T:System.IO.BinaryReader" /&gt;</ph> stream from which the object is deserialized.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IO.BinaryReader" /&gt;</ph> Strumienia, z którego deserializowany jest obiekt.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" uid="M:Microsoft.SqlServer.Server.IBinarySerialize.Read(System.IO.BinaryReader)">
          <source>Generates a user-defined type (UDT) or user-defined aggregate from its binary form.</source>
          <target state="translated">Generuje typu zdefiniowanego przez użytkownika (UDT) lub agregacji zdefiniowanej przez użytkownika na podstawie jego postaci binarnej.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.SqlServer.Server.IBinarySerialize.Read(System.IO.BinaryReader)">
          <source>The <ph id="ph1">&lt;xref:Microsoft.SqlServer.Server.IBinarySerialize.Read%2A&gt;</ph> method must reconstitute your object using the information written by the <ph id="ph2">&lt;xref:Microsoft.SqlServer.Server.IBinarySerialize.Write%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:Microsoft.SqlServer.Server.IBinarySerialize.Read%2A&gt;</ph> Metody musi odtworzenia obiektu przy użyciu informacji zapisanych przez <ph id="ph2">&lt;xref:Microsoft.SqlServer.Server.IBinarySerialize.Write%2A&gt;</ph> metody.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.SqlServer.Server.IBinarySerialize.Read(System.IO.BinaryReader)">
          <source>The following example shows the implementation of the <ph id="ph1">&lt;xref:Microsoft.SqlServer.Server.IBinarySerialize.Read%2A&gt;</ph> method of a UDT, which uses a <ph id="ph2">&lt;xref:System.IO.BinaryReader&gt;</ph> to de-serialize a previously persisted UDT.</source>
          <target state="translated">Poniższy przykład przedstawia implementację <ph id="ph1">&lt;xref:Microsoft.SqlServer.Server.IBinarySerialize.Read%2A&gt;</ph> metody UDT, który używa <ph id="ph2">&lt;xref:System.IO.BinaryReader&gt;</ph> można zdeserializować UDT utrwalonych wcześniej.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.SqlServer.Server.IBinarySerialize.Read(System.IO.BinaryReader)">
          <source>This example assumes that the UDT has two data properties: <ph id="ph1">`StringValue`</ph> and <ph id="ph2">`DoubleValue`</ph>.</source>
          <target state="translated">W tym przykładzie przyjęto założenie, że UDT ma dwie właściwości danych: <ph id="ph1">`StringValue`</ph> i <ph id="ph2">`DoubleValue`</ph>.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" uid="M:Microsoft.SqlServer.Server.IBinarySerialize.Write(System.IO.BinaryWriter)">
          <source>The <ph id="ph1">&lt;see cref="T:System.IO.BinaryWriter" /&gt;</ph> stream to which the UDT or user-defined aggregate is serialized.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IO.BinaryWriter" /&gt;</ph> Strumień, do którego serializowany jest UDT lub agregacji zdefiniowanej przez użytkownika.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" uid="M:Microsoft.SqlServer.Server.IBinarySerialize.Write(System.IO.BinaryWriter)">
          <source>Converts a user-defined type (UDT) or user-defined aggregate into its binary format so that it may be persisted.</source>
          <target state="translated">Konwertuje typu zdefiniowanego przez użytkownika (UDT) lub agregacji zdefiniowanej przez użytkownika na jego format binarny, dzięki czemu może zostać utrwalona.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.SqlServer.Server.IBinarySerialize.Write(System.IO.BinaryWriter)">
          <source>Write sufficient information to the binary stream to allow the <ph id="ph1">&lt;xref:Microsoft.SqlServer.Server.IBinarySerialize.Read%2A&gt;</ph> method to reconstitute your UDT or user-defined aggregate.</source>
          <target state="translated">Zapisywanie informacji wystarczających do strumienia danych binarnych, aby umożliwić <ph id="ph1">&lt;xref:Microsoft.SqlServer.Server.IBinarySerialize.Read%2A&gt;</ph> metody do odtworzenia z UDT lub agregacji zdefiniowanej przez użytkownika.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.SqlServer.Server.IBinarySerialize.Write(System.IO.BinaryWriter)">
          <source>The following example shows the implementation of the <ph id="ph1">&lt;xref:Microsoft.SqlServer.Server.IBinarySerialize.Write%2A&gt;</ph> method of a UDT, which uses a <ph id="ph2">&lt;xref:System.IO.BinaryWriter&gt;</ph> to serialize the UDT in the user-defined binary format.</source>
          <target state="translated">Poniższy przykład przedstawia implementację <ph id="ph1">&lt;xref:Microsoft.SqlServer.Server.IBinarySerialize.Write%2A&gt;</ph> metody UDT, który używa <ph id="ph2">&lt;xref:System.IO.BinaryWriter&gt;</ph> do serializacji UDT w formacie binarnym zdefiniowane przez użytkownika.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="M:Microsoft.SqlServer.Server.IBinarySerialize.Write(System.IO.BinaryWriter)">
          <source>The purpose of the null character padding is to ensure that the string value is completely separated from the double value, so that one UDT is compared to another in Transact-SQL code, string bytes are compared to string bytes and double bytes are compared to double bytes.</source>
          <target state="translated">Dopełnienie znak null ma na celu upewnij się, że wartość ciągu jest całkowicie oddzielony od podwójna wartość tak, aby jeden UDT jest porównywany z innego w kodzie języka Transact-SQL, bajtów ciągu są porównywane bajtów ciągu i bajtów podwójne są porównywane podwójne Liczba bajtów.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>
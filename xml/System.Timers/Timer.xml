<Type Name="Timer" FullName="System.Timers.Timer">
  <Metadata><Meta Name="ms.openlocfilehash" Value="9cc59ace9aec449d4419a4b242c58dbbaf76179a" /><Meta Name="ms.sourcegitcommit" Value="81833381d2d0b5a8c55f71b43f00769fd38298af" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/17/2019" /><Meta Name="ms.locfileid" Value="69572216" /></Metadata><TypeSignature Language="C#" Value="public class Timer : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Timer extends System.ComponentModel.Component implements class System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="DocId" Value="T:System.Timers.Timer" />
  <TypeSignature Language="VB.NET" Value="Public Class Timer&#xA;Inherits Component&#xA;Implements ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class Timer : System::ComponentModel::Component, System::ComponentModel::ISupportInitialize" />
  <TypeSignature Language="F#" Value="type Timer = class&#xA;    inherit Component&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-3.0;netstandard-2.1">
      <AttributeName>System.ComponentModel.DefaultEvent("Elapsed")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-3.0;netstandard-2.1">
      <AttributeName>System.ComponentModel.DefaultProperty("Interval")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Generuje zdarzenie po określonym interwale z opcją generowania zdarzeń cyklicznych.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Składnik jest czasomierzem opartym na serwerze, który <xref:System.Timers.Timer.Elapsed> wywołuje zdarzenie w aplikacji po upływie <xref:System.Timers.Timer.Interval%2A> liczby milisekund we właściwości. <xref:System.Timers.Timer> Można skonfigurować <xref:System.Timers.Timer> obiekt, aby zgłosić zdarzenie tylko raz lub wielokrotnie <xref:System.Timers.Timer.AutoReset%2A> przy użyciu właściwości. <xref:System.Timers.Timer> Zazwyczaj obiekt jest zadeklarowany na poziomie klasy, dzięki czemu pozostaje w zakresie, o ile jest to konieczne. Następnie można obsłużyć <xref:System.Timers.Timer.Elapsed> zdarzenie, aby zapewnić regularne przetwarzanie. Załóżmy na przykład, że masz krytyczny serwer, który musi być uruchomiony przez 24 godziny dziennie, 7 dni w tygodniu. Można utworzyć usługę, która używa <xref:System.Timers.Timer> obiektu, aby okresowo sprawdzać serwer i upewnić się, że system działa. Jeśli system nie odpowiada, usługa może spróbować ponownie uruchomić serwer lub powiadomić administratora.  
  
> [!IMPORTANT]
> <xref:System.Timers.Timer> Klasa nie jest dostępna dla wszystkich implementacji i wersji platformy .NET, takich jak .NET standard 1,6 i niższych wersjach.
> W takich przypadkach można użyć <xref:System.Threading.Timer?displayProperty=nameWithType> klasy.
  
 Ten typ implementuje <xref:System.IDisposable> interfejs. Po zakończeniu korzystania z typu należy usunąć jego wartość bezpośrednio lub pośrednio. Aby usunąć typ bezpośrednio <xref:System.IDisposable.Dispose%2A> , wywołaj jego metodę `try` / `catch` w bloku. Aby usunąć go pośrednio, użyj konstrukcji języka, takiej jak `using` (in C#) lub `Using` (w Visual Basic). Aby uzyskać więcej informacji, zobacz sekcję "Używanie obiektu implementującego <xref:System.IDisposable> interfejs IDisposable" w temacie dotyczącym interfejsu.  
  
 Klasa oparta <xref:System.Timers.Timer?displayProperty=nameWithType> na serwerze jest przeznaczona do użycia z wątkami roboczymi w środowisku wielowątkowym. Czasomierze serwera mogą poruszać się między wątkami <xref:System.Timers.Timer.Elapsed> w celu obsługi zdarzenia zgłoszonego, co skutkuje większą dokładnością niż czasomierze systemu Windows podczas podnoszenia zdarzenia w czasie.  
  
 Składnik zgłasza zdarzenie, na podstawie wartości ( <xref:System.Timers.Timer.Interval%2A> w milisekundach) właściwości. <xref:System.Timers.Timer.Elapsed> <xref:System.Timers.Timer?displayProperty=nameWithType> To zdarzenie można obsłużyć w celu przeprowadzenia przetwarzania, którego potrzebujesz. Załóżmy na przykład, że masz aplikację sprzedaży online, która ciągle zapisuje zamówienia sprzedaży do bazy danych. Usługa, która kompiluje instrukcje do wysyłki, działa na partii zamówień zamiast przetwarzania poszczególnych zamówień indywidualnie. Można użyć, <xref:System.Timers.Timer> aby rozpocząć przetwarzanie wsadowe co 30 minut.  
  
> [!IMPORTANT]
>  Klasa System. Timers. czasomierz ma takie samo rozwiązanie jak zegar systemowy. Oznacza to, że <xref:System.Timers.Timer.Elapsed> zdarzenie zostanie wyzwolone w interwale zdefiniowanym przez rozwiązanie zegara systemowego, <xref:System.Timers.Timer.Interval%2A> Jeśli właściwość jest mniejsza niż rozdzielczość zegara systemowego. Aby uzyskać więcej informacji, zobacz <xref:System.Timers.Timer.Interval%2A> właściwość.  
  
 Gdy <xref:System.Timers.Timer.AutoReset%2A> jest ustawiona na `false` <xref:System.Timers.Timer?displayProperty=nameWithType> <xref:System.Timers.Timer.Interval%2A> , obiekt zgłasza zdarzenie tylko raz, po upływie pierwszego czasu. <xref:System.Timers.Timer.Elapsed> Aby zachować <xref:System.Timers.Timer.Elapsed> regularne generowanie zdarzenia w interwale zdefiniowanym <xref:System.Timers.Timer.Interval%2A>przez, ustaw <xref:System.Timers.Timer.AutoReset%2A> na `true`wartość, która jest wartością domyślną.  
  
 Składnik przechwytuje i pomija wszystkie wyjątki zgłoszone przez programy obsługi zdarzeń <xref:System.Timers.Timer.Elapsed> dla zdarzenia. <xref:System.Timers.Timer> Takie zachowanie może ulec zmianie w przyszłych wersjach .NET Framework. Należy jednak zauważyć, że nie jest to prawdą dla programów obsługi zdarzeń, które wykonują asynchronicznie `await` i zawierają operator C#(in) `Await` lub operator (w Visual Basic). Wyjątki zgłoszone w tych obsłudze zdarzeń są propagowane z powrotem do wywołującego wątku, jak pokazano w poniższym przykładzie. Aby uzyskać więcej informacji na temat wyjątków zgłoszonych w metodach asynchronicznych, zobacz [Obsługa wyjątków](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 [!code-csharp[System.Timers.Timer#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/AsyncHandlerEx1.cs#3)]
 [!code-vb[System.Timers.Timer#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/AsyncHandlerEx1.vb#3)]  
  
 Jeśli właściwość ma `null`wartość, <xref:System.Timers.Timer.Elapsed> zdarzenie jest zgłaszane w <xref:System.Threading.ThreadPool> wątku. <xref:System.Timers.Timer.SynchronizingObject%2A> Jeśli przetwarzanie <xref:System.Timers.Timer.Elapsed> zdarzenia trwa dłużej niż <xref:System.Timers.Timer.Interval%2A>, zdarzenie może zostać zgłoszone ponownie w innym <xref:System.Threading.ThreadPool> wątku. W takiej sytuacji procedura obsługi zdarzeń powinna być współużytkowana.  
  
> [!NOTE]
>  Metoda obsługi zdarzeń może być uruchamiana w jednym wątku w tym samym czasie, w którym inny wątek <xref:System.Timers.Timer.Stop%2A> wywołuje metodę lub <xref:System.Timers.Timer.Enabled%2A> ustawia właściwość na `false`. Może to spowodować, że <xref:System.Timers.Timer.Elapsed> zdarzenie zostanie wywołane po zatrzymaniu czasomierza. Przykładowy kod dla <xref:System.Timers.Timer.Stop%2A> metody pokazuje jeden ze sposobów, aby uniknąć tego warunku wyścigu.  
  
 Nawet jeśli <xref:System.Timers.Timer.SynchronizingObject%2A> nie jest `null`, <xref:System.Timers.Timer.Elapsed> zdarzenia mogą wystąpić po wywołaniu <xref:System.Timers.Timer.Dispose%2A> lub <xref:System.Timers.Timer.Stop%2A> metody lub po ustawieniu <xref:System.Timers.Timer.Enabled%2A> właściwości `false`, ponieważ sygnał do podniesienia <xref:System.Timers.Timer.Elapsed> zdarzenia jest zawsze umieszczany w kolejce do wykonania w wątku puli wątków. Jednym ze sposobów na rozwiązanie tego warunku wyścigu jest ustawienie flagi, która instruuje procedurę obsługi <xref:System.Timers.Timer.Elapsed> zdarzeń, aby ignorować kolejne zdarzenia.  
  
 Jeśli używasz <xref:System.Timers.Timer?displayProperty=nameWithType> klasy z elementem interfejsu użytkownika, takim jak formularz lub kontrolka, bez umieszczania czasomierza tego elementu interfejsu użytkownika, przypisz formularz lub kontrolkę <xref:System.Timers.Timer> zawierającą do <xref:System.Timers.Timer.SynchronizingObject%2A> właściwości, tak aby zdarzenie było organizowane w wątku interfejsu użytkownika.  
  
 Aby uzyskać listę domyślnych wartości właściwości dla wystąpienia <xref:System.Timers.Timer>, <xref:System.Timers.Timer.%23ctor%2A> Zobacz Konstruktor.  
  
> [!TIP]
>  Należy pamiętać, że platforma .NET zawiera cztery `Timer`klasy o nazwie, z których każda oferuje różne funkcje:  
>   
> - <xref:System.Timers.Timer?displayProperty=nameWithType>(w tym temacie): uruchamia zdarzenie w regularnych odstępach czasu. Klasa jest przeznaczona do użycia jako składnik serwera lub usługi w środowisku wielowątkowym. nie ma interfejsu użytkownika i nie jest widoczny w czasie wykonywania.  
> - <xref:System.Threading.Timer?displayProperty=nameWithType>: wykonuje pojedynczą metodę wywołania zwrotnego w wątku puli wątków w regularnych odstępach czasu. Metoda wywołania zwrotnego jest definiowana podczas tworzenia wystąpienia czasomierza i nie można jej zmienić. Podobnie jak <xref:System.Timers.Timer?displayProperty=nameWithType> w przypadku klasy, ta klasa jest przeznaczona do użycia jako składnik serwera lub usługi w środowisku wielowątkowym. nie ma interfejsu użytkownika i nie jest widoczna w czasie wykonywania.  
> - <xref:System.Windows.Forms.Timer?displayProperty=nameWithType>(Tylko .NET Framework): składnik Windows Forms, który uruchamia zdarzenie w regularnych odstępach czasu. Składnik nie ma interfejsu użytkownika i jest przeznaczony do użytku w środowisku jednowątkowym.  
> - <xref:System.Web.UI.Timer?displayProperty=nameWithType>(Tylko .NET Framework): składnik ASP.NET, który wykonuje asynchroniczne lub synchroniczne ogłaszanie stron sieci Web w regularnych odstępach czasu.  

## Examples  
 Poniższy przykład tworzy wystąpienie `System.Timers.Timer` obiektu, który uruchamia jego <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> zdarzenie co dwie sekundy (2 000 milisekund), konfiguruje procedurę obsługi zdarzeń dla zdarzenia i uruchamia czasomierz. Program obsługi zdarzeń wyświetla wartość <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> właściwości przy każdym wygenerowanym czasie.  
  
 [!code-csharp[System.Timers.Timer#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer2a.cs#2)]
 [!code-vb[System.Timers.Timer#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer2a.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Wszystkie publiczne <see langword="static" /> elementy członkowskie tego typu są bezpieczne wątkowo. Wystąpienia elementów członkowskich nie dają gwarancji bezpieczeństwa wątków.</threadsafe>
    <altmember cref="P:System.Timers.Timer.AutoReset" />
    <altmember cref="P:System.Timers.Timer.Interval" />
    <altmember cref="E:System.Timers.Timer.Elapsed" />
    <altmember cref="M:System.Timers.Timer.#ctor" />
    <altmember cref="T:System.Threading.Timer" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Timers.Timer" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Timer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Timer();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Timers.Timer" /> klasy i ustawia wszystkie właściwości na ich wartości początkowe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono początkowe wartości właściwości dla wystąpienia <xref:System.Timers.Timer>.  
  
|Właściwość|Wartość początkowa|  
|--------------|-------------------|  
|<xref:System.Timers.Timer.AutoReset%2A>|`true`|  
|<xref:System.Timers.Timer.Enabled%2A>|`false`|  
|<xref:System.Timers.Timer.Interval%2A>|100 milisekund|  
|<xref:System.Timers.Timer.SynchronizingObject%2A>|Odwołanie o wartości null (`Nothing` w języku Visual Basic).|  
  
   
  
## Examples  
 Poniższy przykład tworzy wystąpienie <xref:System.Timers.Timer> obiektu, który uruchamia jego <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> zdarzenie co dwie sekundy (2000 milisekund), konfiguruje procedurę obsługi zdarzeń dla zdarzenia i uruchamia czasomierz. Program obsługi zdarzeń wyświetla wartość <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> właściwości przy każdym wygenerowanym czasie.  
  
 [!code-cpp[System.Timers.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.timers.timer/cpp/timer1.cpp#1)]
 [!code-csharp[System.Timers.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer1.cs#1)]
 [!code-vb[System.Timers.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Timers.Timer.AutoReset" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="P:System.Timers.Timer.Interval" />
        <altmember cref="P:System.Timers.Timer.SynchronizingObject" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Timer (double interval);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 interval) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.#ctor(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (interval As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Timer(double interval);" />
      <MemberSignature Language="F#" Value="new System.Timers.Timer : double -&gt; System.Timers.Timer" Usage="new System.Timers.Timer interval" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="interval" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="interval">Czas (w milisekundach) między zdarzeniami. Wartość musi być większa niż zero i mniejsza lub równa <see cref="F:System.Int32.MaxValue" />.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Timers.Timer" /> klasy i <see cref="P:System.Timers.Timer.Interval" /> ustawia właściwość na określoną liczbę milisekund.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor ustawia <xref:System.Timers.Timer.Interval%2A> właściwość nowego wystąpienia czasomierza, ale nie włącza czasomierza.  
  
   
  
## Examples  
 Poniższy przykład tworzy wystąpienie <xref:System.Timers.Timer> obiektu, który uruchamia jego <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> zdarzenie co dwie sekundy (2000 milisekund), konfiguruje procedurę obsługi zdarzeń dla zdarzenia i uruchamia czasomierz. Program obsługi zdarzeń wyświetla wartość <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> właściwości przy każdym wygenerowanym czasie.  
  
 [!code-csharp[System.Timers.Timer#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/AsyncHandlerEx1.cs#3)]
 [!code-vb[System.Timers.Timer#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/AsyncHandlerEx1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wartość <paramref name="interval" /> parametru jest mniejsza lub równa zero lub większa niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <altmember cref="P:System.Timers.Timer.Interval" />
      </Docs>
    </Member>
    <Member MemberName="AutoReset">
      <MemberSignature Language="C#" Value="public bool AutoReset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoReset" />
      <MemberSignature Language="DocId" Value="P:System.Timers.Timer.AutoReset" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoReset As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutoReset { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoReset : bool with get, set" Usage="System.Timers.Timer.AutoReset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Timers.TimersDescription("Indicates whether the timer will be restarted when it is enabled.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.Timers.TimersDescription("TimerAutoReset")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość logiczną wskazującą, czy <see cref="T:System.Timers.Timer" /> <see cref="E:System.Timers.Timer.Elapsed" /> zdarzenie powinno zostać zgłoszone tylko raz<see langword="false" />(), czy<see langword="true" />wielokrotnie ().</summary>
        <value><see langword="true" /><see cref="E:System.Timers.Timer.Elapsed" /> Jeśli zdarzenie powinno zostać zgłoszone przy każdym upłynięciu interwału; <see cref="T:System.Timers.Timer" /> <see langword="false" /> Jeśli <see cref="E:System.Timers.Timer.Elapsed" /> zdarzenie powinno zostać zgłoszone tylko raz, po pierwszym upłynięciu interwału. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli jest już włączona, <xref:System.Timers.Timer.Start%2A> gdy metoda jest wywoływana, interwał jest resetowany. <xref:System.Timers.Timer> Jeśli <xref:System.Timers.Timer.AutoReset%2A> jest `false` ,<xref:System.Timers.Timer.Start%2A> Metoda musi zostać wywołana w celu ponownego uruchomienia liczby.  
  
 Resetowanie interwału ma wpływ na <xref:System.Timers.Timer.Elapsed> to, kiedy zdarzenie jest zgłaszane. Na przykład jeśli ustawisz interwał na 5 sekund, a następnie ustawisz <xref:System.Timers.Timer.Enabled%2A> właściwość na `true`, liczba rozpocznie się w momencie <xref:System.Timers.Timer.Enabled%2A> ustawienia. W przypadku zresetowania interwału do 10 sekund, gdy liczba wynosi 3 sekundy, <xref:System.Timers.Timer.Elapsed> zdarzenie jest zgłaszane po raz pierwszy <xref:System.Timers.Timer.Enabled%2A> po upływie 13 sekund od ustawienia `true`właściwości.  
  
   
  
## Examples  
 Poniższy przykład tworzy zdarzenie, <xref:System.Timers.Timer> którego <xref:System.Timers.Timer.Elapsed> wygenerowane po 1,5 sekund. W jego obsłudze zdarzeń zostanie wyświetlony komunikat "Hello world!" w konsoli programu.  
  
 [!code-cpp[Classic Timer.Timer1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Timer.Timer1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Timer.Timer1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Timer.Timer1 Example/CS/source.cs#1)]
 [!code-vb[Classic Timer.Timer1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Timer.Timer1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Timers.Timer.Interval" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="M:System.Timers.Timer.Start" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="timer.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rozpoczyna inicjalizację <see cref="T:System.Timers.Timer" /> w czasie wykonywania, która jest używana w formularzu lub przez inny składnik.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Środowisko [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] projektowe używa tej metody do uruchamiania inicjowania składnika, który jest używany w formularzu lub przez inny składnik. <xref:System.Timers.Timer.EndInit%2A> Metoda przerywa inicjalizację. Użycie metod <xref:System.Timers.Timer.EndInit%2A> i uniemożliwia użycie kontrolki przed jej pełnym zainicjowaniem. <xref:System.Timers.Timer.BeginInit%2A>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="M:System.Timers.Timer.EndInit" />
        <altmember cref="P:System.Timers.Timer.Interval" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="timer.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia zasoby używane przez <see cref="T:System.Timers.Timer" />program.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda z kolei `Dispose` wywołuje metodę. <xref:System.Timers.Timer.Close%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="timer.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" />Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> do zwolnienia tylko zasobów niezarządzanych.</param>
        <summary>Zwalnia wszystkie zasoby używane przez bieżące <see cref="T:System.Timers.Timer" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Elapsed">
      <MemberSignature Language="C#" Value="public event System.Timers.ElapsedEventHandler Elapsed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Timers.ElapsedEventHandler Elapsed" />
      <MemberSignature Language="DocId" Value="E:System.Timers.Timer.Elapsed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Elapsed As ElapsedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Timers::ElapsedEventHandler ^ Elapsed;" />
      <MemberSignature Language="F#" Value="member this.Elapsed : System.Timers.ElapsedEventHandler " Usage="member this.Elapsed : System.Timers.ElapsedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Timers.TimersDescription("Occurs when the Interval has elapsed.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.Timers.TimersDescription("TimerIntervalElapsed")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Timers.ElapsedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po upłynięciu interwału.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zdarzenie jest zgłaszane, <xref:System.Timers.Timer.Enabled%2A> Jeśli właściwość jest `true` i <xref:System.Timers.Timer.Interval%2A> przedział czasu (w milisekundach) zdefiniowany przez właściwość. <xref:System.Timers.Timer.Elapsed> Jeśli właściwość ma `true`wartość, zdarzenie jest zgłaszane wielokrotnie w interwale zdefiniowanym przez <xref:System.Timers.Timer.Interval%2A> właściwość; w przeciwnym razie zdarzenie jest <xref:System.Timers.Timer.Interval%2A> zgłaszane tylko raz, przy pierwszym upłynięciu wartości. <xref:System.Timers.Timer.AutoReset%2A>  
  
 Jeśli <xref:System.Timers.Timer.Interval%2A> jest ustawiona <xref:System.Timers.Timer> po uruchomieniu, licznik zostanie zresetowany. Na przykład jeśli ustawisz interwał na 5 sekund, a następnie ustawisz <xref:System.Timers.Timer.Enabled%2A> `true`wartość, liczba rozpocznie się w momencie <xref:System.Timers.Timer.Enabled%2A> ustawienia. W przypadku zresetowania interwału do 10 sekund, gdy liczba wynosi 3 sekundy <xref:System.Timers.Timer.Elapsed> , zdarzenie jest zgłaszane po raz pierwszy po upływie <xref:System.Timers.Timer.Enabled%2A> 13 sekund po `true`ustawieniu na.  
  
 Jeśli właściwość ma `null`wartość, <xref:System.Timers.Timer.Elapsed> zdarzenie jest zgłaszane w <xref:System.Threading.ThreadPool> wątku. <xref:System.Timers.Timer.SynchronizingObject%2A> Jeśli przetwarzanie <xref:System.Timers.Timer.Elapsed> zdarzenia trwa dłużej niż <xref:System.Timers.Timer.Interval%2A>, zdarzenie może zostać zgłoszone ponownie w innym <xref:System.Threading.ThreadPool> wątku. W takiej sytuacji procedura obsługi zdarzeń powinna być współużytkowana.  
  
> [!NOTE]
>  Metoda obsługi zdarzeń może być uruchamiana w jednym wątku w tym samym czasie, w którym inny wątek <xref:System.Timers.Timer.Stop%2A> wywołuje metodę lub <xref:System.Timers.Timer.Enabled%2A> ustawia właściwość na `false`. Może to spowodować, że <xref:System.Timers.Timer.Elapsed> zdarzenie zostanie wywołane po zatrzymaniu czasomierza. Przykładowy kod dla <xref:System.Timers.Timer.Stop%2A> metody pokazuje jeden ze sposobów, aby uniknąć tego warunku wyścigu.  
  
 Nawet jeśli <xref:System.Timers.Timer.SynchronizingObject%2A> nie jest `null`, <xref:System.Timers.Timer.Elapsed> zdarzenia mogą wystąpić po wywołaniu <xref:System.Timers.Timer.Dispose%2A> lub <xref:System.Timers.Timer.Stop%2A> metody lub po ustawieniu <xref:System.Timers.Timer.Enabled%2A> właściwości `false`, ponieważ sygnał do podniesienia <xref:System.Timers.Timer.Elapsed> zdarzenia jest zawsze umieszczany w kolejce do wykonania w wątku puli wątków. Jednym ze sposobów na rozwiązanie tego warunku wyścigu jest ustawienie flagi, która instruuje procedurę obsługi <xref:System.Timers.Timer.Elapsed> zdarzeń, aby ignorować kolejne zdarzenia.  
  
 Składnik przechwytuje i pomija wszystkie wyjątki zgłoszone przez programy obsługi zdarzeń <xref:System.Timers.Timer.Elapsed> dla zdarzenia. <xref:System.Timers.Timer> Takie zachowanie może ulec zmianie w przyszłych wersjach .NET Framework.  
  
   
  
## Examples  
 Poniższy przykład tworzy wystąpienie <xref:System.Timers.Timer> obiektu, który uruchamia jego <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> zdarzenie co dwie sekundy (2000 milisekund), konfiguruje procedurę obsługi zdarzeń dla zdarzenia i uruchamia czasomierz. Program obsługi zdarzeń wyświetla wartość <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> właściwości przy każdym wygenerowanym czasie.  
  
 [!code-cpp[System.Timers.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.timers.timer/cpp/timer1.cpp#1)]
 [!code-csharp[System.Timers.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer1.cs#1)]
 [!code-vb[System.Timers.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Timers.Timer.Interval" />
        <altmember cref="P:System.Timers.Timer.AutoReset" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
        <altmember cref="T:System.Timers.ElapsedEventArgs" />
        <altmember cref="T:System.Timers.ElapsedEventHandler" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
      </Docs>
    </Member>
    <Member MemberName="Enabled">
      <MemberSignature Language="C#" Value="public bool Enabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Enabled" />
      <MemberSignature Language="DocId" Value="P:System.Timers.Timer.Enabled" />
      <MemberSignature Language="VB.NET" Value="Public Property Enabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Enabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Enabled : bool with get, set" Usage="System.Timers.Timer.Enabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Timers.TimersDescription("Indicates whether the timer is enabled to fire events at a defined interval.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.Timers.TimersDescription("TimerEnabled")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy <see cref="T:System.Timers.Timer" /> <see cref="E:System.Timers.Timer.Elapsed" /> zdarzenie powinno zostać zgłoszone.</summary>
        <value><see langword="true" />Jeśli powinna zgłosić zdarzenie; w przeciwnym razie <see langword="false" />. <see cref="E:System.Timers.Timer.Elapsed" /> <see cref="T:System.Timers.Timer" /> Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustawienie <xref:System.Timers.Timer.Enabled%2A> <xref:System.Timers.Timer.Start%2A> <xref:System.Timers.Timer.Enabled%2A> na jesttakie`false` samo jak wywołanie, podczas gdy ustawienie jest takie samo jak wywołanie <xref:System.Timers.Timer.Stop%2A>. `true`  
  
> [!NOTE]
>  Sygnał służący do podniesienia <xref:System.Timers.Timer.Elapsed> zdarzenia jest zawsze umieszczany w kolejce do wykonania <xref:System.Threading.ThreadPool> w wątku. Może to spowodować, że <xref:System.Timers.Timer.Elapsed> zdarzenie zostanie wywołane <xref:System.Timers.Timer.Enabled%2A> po ustawieniu właściwości na `false`. Przykład kodu dla <xref:System.Timers.Timer.Stop%2A> metody pokazuje jeden ze sposobów obejścia tego warunku wyścigu.  
  
 Jeśli <xref:System.Timers.Timer.Enabled%2A> jest ustawiona na `true` i <xref:System.Timers.Timer.AutoReset%2A> jest ustawiona na `false`, <xref:System.Timers.Timer> wywołuje <xref:System.Timers.Timer.Elapsed> zdarzenie tylko raz, podczas pierwszego interwału.  
  
 Jeśli interwał zostanie ustawiony po <xref:System.Timers.Timer> rozpoczęciu, licznik zostanie zresetowany. Na przykład jeśli ustawisz interwał na 5 sekund, a następnie ustawisz <xref:System.Timers.Timer.Enabled%2A> właściwość na `true`, liczba rozpocznie się w momencie <xref:System.Timers.Timer.Enabled%2A> ustawienia. W przypadku zresetowania interwału do 10 sekund, gdy liczba wynosi 3 sekundy <xref:System.Timers.Timer.Elapsed> , zdarzenie jest zgłaszane po raz pierwszy po upływie <xref:System.Timers.Timer.Enabled%2A> 13 sekund po `true`ustawieniu na.  
  
> [!NOTE]
>  Niektóre projektanci wizualizacji, takie jak te w Microsoft Visual Studio, ustawiają <xref:System.Timers.Timer.Enabled%2A> właściwość na `true` podczas wstawiania nowej <xref:System.Timers.Timer>.  
  
   
  
## Examples  
 Poniższy przykład tworzy wystąpienie <xref:System.Timers.Timer> obiektu, który uruchamia jego <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> zdarzenie co dwie sekundy (2000 milisekund), konfiguruje procedurę obsługi zdarzeń dla zdarzenia i uruchamia czasomierz. Program obsługi zdarzeń wyświetla wartość <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> właściwości przy każdym wygenerowanym czasie.  
  
 [!code-cpp[System.Timers.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.timers.timer/cpp/timer1.cpp#1)]
 [!code-csharp[System.Timers.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer1.cs#1)]
 [!code-vb[System.Timers.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Nie można ustawić tej właściwości, ponieważ czasomierz został usunięty.</exception>
        <exception cref="T:System.ArgumentException">Właściwość została ustawiona na wartość większą niż <see cref="F:System.Int32.MaxValue" /> przed włączeniem czasomierza. <see cref="P:System.Timers.Timer.Interval" /></exception>
        <altmember cref="P:System.Timers.Timer.Interval" />
        <altmember cref="P:System.Timers.Timer.AutoReset" />
        <altmember cref="M:System.Timers.Timer.Start" />
        <altmember cref="M:System.Timers.Timer.Stop" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="timer.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zakończenie inicjacji <see cref="T:System.Timers.Timer" /> w czasie wykonywania, która jest używana w formularzu lub przez inny składnik.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Środowisko [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] projektowe używa tej metody do zakończenia inicjowania składnika, który jest używany w formularzu lub przez inny składnik. <xref:System.Timers.Timer.BeginInit%2A> Metoda uruchamia inicjalizację. Użycie metod <xref:System.Timers.Timer.EndInit%2A> i uniemożliwia użycie kontrolki przed jej pełnym zainicjowaniem. <xref:System.Timers.Timer.BeginInit%2A>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Timers.Timer.BeginInit" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="P:System.Timers.Timer.Interval" />
      </Docs>
    </Member>
    <Member MemberName="Interval">
      <MemberSignature Language="C#" Value="public double Interval { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Interval" />
      <MemberSignature Language="DocId" Value="P:System.Timers.Timer.Interval" />
      <MemberSignature Language="VB.NET" Value="Public Property Interval As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Interval { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Interval : double with get, set" Usage="System.Timers.Timer.Interval" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(100)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Timers.TimersDescription("The number of milliseconds between timer events.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.Timers.TimersDescription("TimerInterval")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia interwał wyrażony w milisekundach, w którym ma zostać <see cref="E:System.Timers.Timer.Elapsed" /> zgłoszone zdarzenie.</summary>
        <value>Czas (w milisekundach) między <see cref="E:System.Timers.Timer.Elapsed" /> zdarzeniami. Wartość musi być większa od zera i mniejsza lub równa <see cref="F:System.Int32.MaxValue" />. Wartość domyślna to 100 milisekund.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj właściwości, <xref:System.Timers.Timer.Interval%2A> aby określić częstotliwość, z <xref:System.Timers.Timer.Elapsed> jaką zdarzenie jest wywoływane. <xref:System.Timers.Timer> Ponieważ Klasa zależy od zegara systemowego, ma takie samo rozwiązanie jak zegar systemowy. Oznacza to, że <xref:System.Timers.Timer.Elapsed> zdarzenie zostanie wyzwolone w interwale zdefiniowanym przez rozwiązanie zegara systemowego, <xref:System.Timers.Timer.Interval%2A> Jeśli właściwość jest mniejsza niż rozdzielczość zegara systemowego. Poniższy przykład ustawia <xref:System.Timers.Timer.Interval%2A> właściwość na 5 milisekund. W przypadku uruchamiania w [!INCLUDE[win7](~/includes/win7-md.md)] systemie, którego zegar systemowy ma rozdzielczość około 15 milisekund, zdarzenie jest wyzwalane co około 15 milisekund, a nie co 5 milisekund.  
  
 [!code-csharp[System.Timers.Timer.Interval#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer.interval/cs/interval2.cs#1)]
 [!code-vb[System.Timers.Timer.Interval#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer.interval/vb/interval2.vb#1)]  
  
 Aby określić rozdzielczość zegara systemowego w bieżącym systemie, można użyć poniższego kodu:  
  
 [!code-csharp[System.Timers.Timer.Interval#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer.interval/cs/resolution1.cs#2)]
 [!code-vb[System.Timers.Timer.Interval#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer.interval/vb/resolution1.vb#2)]  
  
 Jeśli aplikacja wymaga większej rozdzielczości niż oferowana przez <xref:System.Timers.Timer> klasę lub zegar systemowy, należy użyć czasomierzy multimediów o wysokiej rozdzielczości; zobacz [How to: Użyj czasomierza](https://msdn.microsoft.com/library/aa964692.aspx)o wysokiej rozdzielczości.  
  
 Jeśli interwał zostanie ustawiony po <xref:System.Timers.Timer> rozpoczęciu, licznik zostanie zresetowany. Na przykład jeśli ustawisz interwał na 5 sekund, a następnie ustawisz <xref:System.Timers.Timer.Enabled%2A> właściwość na `true`, liczba rozpocznie się w momencie <xref:System.Timers.Timer.Enabled%2A> ustawienia. W przypadku zresetowania interwału do 10 sekund, gdy liczba wynosi 3 sekundy <xref:System.Timers.Timer.Elapsed> , zdarzenie jest zgłaszane po raz pierwszy po upływie <xref:System.Timers.Timer.Enabled%2A> 13 sekund po `true`ustawieniu na.  
  
 Jeśli <xref:System.Timers.Timer.Enabled%2A> jest ustawiona na `true` i <xref:System.Timers.Timer.AutoReset%2A> jest ustawiona na `false`, <xref:System.Timers.Timer> wywołuje <xref:System.Timers.Timer.Elapsed> zdarzenie tylko raz, podczas pierwszego interwału. <xref:System.Timers.Timer.Enabled%2A>jest następnie ustawiany na `false`.  
  
> [!NOTE]
>  Jeśli <xref:System.Timers.Timer.Enabled%2A> `false`i <xref:System.Timers.Timer.Interval%2A> <xref:System.Timers.Timer.Elapsed> są ustawione na, a czasomierz został wcześniej włączony, ustawienie właściwości <xref:System.Timers.Timer.Enabled%2A> powoduje, że zdarzenie zostanie podniesione jednokrotnie, tak jakby właściwość została ustawiona na <xref:System.Timers.Timer.AutoReset%2A> `true`. Aby ustawić interwał bez podnoszenia zdarzenia, można <xref:System.Timers.Timer.Enabled%2A> tymczasowo ustawić właściwość na `true`wartość, ustawić <xref:System.Timers.Timer.Interval%2A> żądany interwał <xref:System.Timers.Timer.Enabled%2A> czasu, a następnie natychmiast ustawić właściwość z powrotem na `false`.  
  
   
  
## Examples  
 Poniższy przykład tworzy wystąpienie <xref:System.Timers.Timer> obiektu, który uruchamia jego <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> zdarzenie co dwie sekundy (2000 milisekund), konfiguruje procedurę obsługi zdarzeń dla zdarzenia i uruchamia czasomierz. Program obsługi zdarzeń wyświetla wartość <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> właściwości przy każdym wygenerowanym czasie.  
  
 [!code-cpp[System.Timers.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.timers.timer/cpp/timer1.cpp#1)]
 [!code-csharp[System.Timers.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer1.cs#1)]
 [!code-vb[System.Timers.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Interwał jest mniejszy lub równy zero.  
  
—lub— 
Interwał jest większy niż <see cref="F:System.Int32.MaxValue" />, a czasomierz jest obecnie włączony. (Jeśli czasomierz nie jest obecnie włączony, nie jest zgłaszany żaden wyjątek, dopóki nie zostanie włączony).</exception>
        <altmember cref="P:System.Timers.Timer.AutoReset" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.Timers.Timer.Site" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Site : System.ComponentModel.ISite with get, set" Usage="System.Timers.Timer.Site" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia lokację, która wiąże <see cref="T:System.Timers.Timer" /> się z kontenerem w trybie projektowania.</summary>
        <value>Interfejs reprezentujący lokację, która wiąże <see cref="T:System.Timers.Timer" /> obiekt z jego kontenerem. <see cref="T:System.ComponentModel.ISite" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lokacje są <xref:System.ComponentModel.Component> powiązane <xref:System.ComponentModel.Container> z i umożliwiają komunikację między nimi, a także umożliwianie kontenerowi zarządzania jego składnikami.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; unit" Usage="timer.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Uruchamia podnoszenie <see cref="E:System.Timers.Timer.Elapsed" /> poziomu zdarzenia przez <see cref="P:System.Timers.Timer.Enabled" /> ustawienie <see langword="true" />do.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Timers.Timer.Start%2A> jest wywoływana i <xref:System.Timers.Timer.AutoReset%2A> `false` jestustawiona<xref:System.Timers.Timer.Elapsed> na, wywołuje zdarzenie tylko raz, podczas pierwszego interwału. <xref:System.Timers.Timer> Jeśli <xref:System.Timers.Timer.Start%2A> jest wywoływana i <xref:System.Timers.Timer.AutoReset%2A> `true` mawartość<xref:System.Timers.Timer> , wywołuje Zdarzenieprzypierwszymupłynięciuinterwałuikontynuujepodnoszeniezdarzeniawokreślonyminterwale.<xref:System.Timers.Timer.Elapsed>  
  
 Możesz również rozpocząć od ustawienia <xref:System.Timers.Timer.Enabled%2A> do. `true`  
  
> [!NOTE]
>  Jeśli <xref:System.Timers.Timer.AutoReset%2A> jest `false` ,<xref:System.Timers.Timer.Start%2A> Metoda musi zostać wywołana w celu ponownego uruchomienia liczby.  
  
 Wywołanie <xref:System.Timers.Timer.Start%2A> metody, gdy czasomierz jest włączony, nie ma żadnego wpływu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Jest tworzony z interwałem równym lub większym niż <see cref="F:System.Int32.MaxValue" /> + 1 lub ustawionym na interwał mniejszy od zera. <see cref="T:System.Timers.Timer" /></exception>
        <altmember cref="P:System.Timers.Timer.Interval" />
        <altmember cref="P:System.Timers.Timer.AutoReset" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="M:System.Timers.Timer.Stop" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop();" />
      <MemberSignature Language="F#" Value="member this.Stop : unit -&gt; unit" Usage="timer.Stop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Powoduje zatrzymanie wywoływania <see cref="P:System.Timers.Timer.Enabled" /> <see langword="false" />zdarzenia przez ustawienie do. <see cref="E:System.Timers.Timer.Elapsed" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz również zatrzymać chronometraż przez ustawienie <xref:System.Timers.Timer.Enabled%2A> do. `false`  
  
> [!NOTE]
>  Sygnał służący do podniesienia <xref:System.Timers.Timer.Elapsed> zdarzenia jest zawsze umieszczany <xref:System.Threading.ThreadPool> w kolejce do wykonania w wątku, dlatego metoda obsługi zdarzeń może być uruchomiona w jednym wątku w tym samym czasie <xref:System.Timers.Timer.Stop%2A> , w którym wywołanie metody jest uruchamiane w innym wątku. Może to spowodować, że <xref:System.Timers.Timer.Elapsed> zdarzenie zostanie wywołane <xref:System.Timers.Timer.Stop%2A> po wywołaniu metody. Drugi przykład kodu w sekcji [przykłady](#examples) przedstawia jeden ze sposobów obejścia tego warunku wyścigu.  
  
   
  
## Examples  
 Poniższy przykład tworzy wystąpienie `System.Timers.Timer` obiektu, który uruchamia jego <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> zdarzenie co dwie sekundy (2 000 milisekund), konfiguruje procedurę obsługi zdarzeń dla zdarzenia i uruchamia czasomierz. Program obsługi zdarzeń wyświetla wartość <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> właściwości przy każdym wygenerowanym czasie. Gdy użytkownik naciśnie klawisz ENTER, aplikacja wywołuje <xref:System.Timers.Timer.Stop%2A> metodę przed zakończeniem działania aplikacji.  
  
 [!code-csharp[System.Timers.Timer#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer2a.cs#2)]
 [!code-vb[System.Timers.Timer#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer2a.vb#2)]  
  
 Poniższy przykład kodu przedstawia jeden ze sposobów, aby zapobiec wykonywaniu wątku, <xref:System.Timers.Timer.Stop%2A> który wywołuje metodę, do momentu <xref:System.Timers.Timer.Elapsed> zakończenia aktualnie wykonywanego zdarzenia, a także <xref:System.Timers.Timer.Elapsed> zapobiegania dwóm zdarzeniom wykonywania programu obsługi zdarzeń w tym samym czas (często określany jako współużytkowania wątkowości).  
  
 Przykład wykonuje przebiegi testowe 100. Przy każdym uruchomieniu testu czasomierz jest uruchamiany z interwałem 150 milisekund. Procedura obsługi zdarzeń używa <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> metody do symulowania zadania, które losowo różni się od 50 do 200 milisekund. Metoda testowa uruchamia również wątek kontrolny, który czeka na sekundę, a następnie kończy działanie czasomierza. Jeśli zdarzenie jest obsługiwane, gdy wątek kontrolny zatrzyma czasomierz, wątek kontrolny musi czekać do zakończenia zdarzenia przed kontynuowaniem.  
  
 Przeciążenie <xref:System.Threading.Interlocked.CompareExchange%28System.Int32%40%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> metody służy do uniknięcia współużytkowania wątkowości i zapobiegania kontynuowaniu wątku kontroli do momentu zakończenia wykonywania zdarzenia. Procedura obsługi zdarzeń używa metody <xref:System.Threading.Interlocked.CompareExchange%28System.Int32%40%2CSystem.Int32%2CSystem.Int32%29> , aby ustawić zmienną kontroli na 1, ale tylko wtedy, gdy wartość jest obecnie równa zero. Jest to operacja niepodzielna. Jeśli wartość zwracana wynosi zero, zmienna kontroli została ustawiona na 1, a procedura obsługi zdarzeń będzie kontynuowała pracę. Jeśli zwracana wartość jest różna od zera, zdarzenie jest po prostu odrzucone, aby uniknąć współużytkowania wątkowości. (Jeśli było konieczne wykonanie każdego zdarzenia, <xref:System.Threading.Monitor> Klasa będzie lepszym sposobem synchronizacji zdarzeń). Po zakończeniu obsługi zdarzeń ustawia zmienną kontroli z powrotem na zero. Przykład rejestruje łączną liczbę wykonanych zdarzeń, które zostały odrzucone z powodu współużytkowania wątkowości i które wystąpiły po <xref:System.Timers.Timer.Stop%2A> wywołaniu metody.  
  
 Wątek kontrolny używa <xref:System.Threading.Interlocked.CompareExchange%28System.Int32%40%2CSystem.Int32%2CSystem.Int32%29> metody, aby ustawić zmienną kontroli na-1 (minus jeden), ale tylko wtedy, gdy wartość jest obecnie równa zero. Jeśli operacja niepodzielna zwróci wartość różną od zera, trwa wykonywanie zdarzenia. Wątek kontrolny czeka i ponawia próbę. Przykład rejestruje, ile razy wątek kontrolny musiał oczekiwać na zakończenie zdarzenia.  
  
 [!code-csharp[Timer.Stop#1](~/samples/snippets/csharp/VS_Snippets_CLR/Timer.Stop/CS/source.cs#1)]
 [!code-vb[Timer.Stop#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Timer.Stop/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="M:System.Timers.Timer.Start" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Timers.Timer.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.Timers.Timer.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Timers.TimersDescription("The object used to marshal the event handler calls issued when an interval has elapsed.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.Timers.TimersDescription("TimerSynchronizingObject")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia obiekt używany do organizowania wywołań obsługi zdarzeń, które są wydawane po upłynięciu interwału.</summary>
        <value><see cref="T:System.ComponentModel.ISynchronizeInvoke" /> Reprezentuje obiekt używany do organizowania wywołań obsługi zdarzeń, które są wydawane po upłynięciu interwału. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Timers.Timer.SynchronizingObject%2A> tak `null`jest, metoda, która obsługuje <xref:System.Timers.Timer.Elapsed> zdarzenie jest wywoływana na wątku z puli wątków systemu. Aby uzyskać więcej informacji na temat pul wątków systemu, <xref:System.Threading.ThreadPool>Zobacz.  
  
 <xref:System.Timers.Timer.Elapsed> Gdy zdarzenie jest obsługiwane przez składnik Visual Windows Forms, taki jak przycisk, uzyskanie dostępu do składnika za pomocą puli wątków systemu może spowodować wyjątek lub może nie działać. Należy unikać tego efektu, <xref:System.Timers.Timer.SynchronizingObject%2A> ustawiając składnik Windows Forms, co powoduje, że metoda, która <xref:System.Timers.Timer.Elapsed> obsługuje zdarzenie, ma być wywoływana w tym samym wątku, w którym został utworzony składnik.  
  
> [!NOTE]
>  Nawet jeśli <xref:System.Timers.Timer.SynchronizingObject%2A> właściwość nie <xref:System.Timers.Timer.Stop%2A> `false` <xref:System.Timers.Timer.Enabled%2A> <xref:System.Timers.Timer.Dispose%2A> jest, <xref:System.Timers.Timer.Elapsed> zdarzenia mogą wystąpić po wywołaniu metody lub, lub po ustawieniu właściwości na, ponieważ sygnał do wywołania `null` <xref:System.Timers.Timer.Elapsed> zdarzenie jest zawsze umieszczane w kolejce do wykonania w wątku puli wątków. Jednym ze sposobów na rozwiązanie tego warunku wyścigu jest ustawienie flagi, która instruuje procedurę obsługi <xref:System.Timers.Timer.Elapsed> zdarzeń, aby ignorować kolejne zdarzenia.  
  
 Jeśli jest używana wewnątrz programu Visual Studio w projektancie Windows Forms, <xref:System.Timers.Timer.SynchronizingObject%2A> jest automatycznie ustawiana na kontrolkę zawierającą <xref:System.Timers.Timer>. <xref:System.Timers.Timer> Na przykład jeśli <xref:System.Timers.Timer> umieścisz w projektancie dla `Form1` (który <xref:System.Timers.Timer.SynchronizingObject%2A> dziedziczy z <xref:System.Windows.Forms.Form>), właściwość <xref:System.Timers.Timer> jest ustawiona na wystąpienie `Form1`.  
  
   
  
## Examples  
 Poniższy przykład to Windows Forms aplikacji, która służy jako bardzo prosty edytor plików tekstowych. Gdy tekst w polu tekstowym nie zostanie zapisany, aplikacja prosi użytkownika o przedziały czasu jednej minuty, czy chce zapisać zawartość pola tekstowego.  W tym celu <xref:System.Timers.Timer.SynchronizingObject%2A> <xref:System.Windows.Forms.Form> właściwość jest ustawiana na jedną minutę (60 000 MS), a właściwość jest ustawiona na obiekt. <xref:System.Timers.Timer.Interval%2A>  
  
 [!code-csharp[System.Timers.Timer.SynchronizingObject#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Timers.Timer.SynchronizingObject/cs/Form1.cs#1)]
 [!code-vb[System.Timers.Timer.SynchronizingObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Timers.Timer.SynchronizingObject/vb/Form1.vb#1)]  
  
 Przykład wymaga dodania następujących kontrolek do formularza:  
  
-   Kontrolka o `TextBox1` nazwie (jej nazwa domyślna). <xref:System.Windows.Forms.TextBox>  
  
-   Kontrolka o `Button1` nazwie (jej nazwa domyślna). <xref:System.Windows.Forms.Button>  
  
-   Kontrolka o `SaveSaveFileDialog1` nazwie (jej nazwa domyślna). <xref:System.Windows.Forms.SaveFileDialog>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Form" />
        <altmember cref="T:System.ComponentModel.ISynchronizeInvoke" />
        <altmember cref="T:System.Threading.ThreadPool" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
  </Members>
</Type>

<Type Name="Timer" FullName="System.Timers.Timer">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="fcc0e5e5a3656054b36a6ed93ec6732ed26646c9" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36406583" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Timer : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Timer extends System.ComponentModel.Component implements class System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="DocId" Value="T:System.Timers.Timer" />
  <TypeSignature Language="VB.NET" Value="Public Class Timer&#xA;Inherits Component&#xA;Implements ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class Timer : System::ComponentModel::Component, System::ComponentModel::ISupportInitialize" />
  <TypeSignature Language="F#" Value="type Timer = class&#xA;    inherit Component&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Elapsed")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("Interval")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Generuje zdarzenie po upływie czasu zestawu z opcją generowanie zdarzeń cyklicznego.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Timers.Timer> Składnik jest czasomierza na serwerze, który wywołuje <xref:System.Timers.Timer.Elapsed> zdarzeń aplikacji po liczbę milisekund <xref:System.Timers.Timer.Interval%2A> upłynął właściwości. Można skonfigurować <xref:System.Timers.Timer> obiekt, aby zgłosić zdarzenie tylko raz lub wielokrotnie przy użyciu <xref:System.Timers.Timer.AutoReset%2A> właściwości. Zazwyczaj <xref:System.Timers.Timer> obiektu jest zadeklarowane na poziomie klasy tak, aby pozostaje w zakresie tak długo, jak jest to potrzebne. Następnie można obsługiwać jego <xref:System.Timers.Timer.Elapsed> zdarzeń, aby zapewnić prawidłowe przetwarzania. Na przykład, załóżmy, że krytyczne serwer, który musi znajdować się systemem 24 godziny na dobę, 7 dni w tygodniu. Można utworzyć usługi, która używa <xref:System.Timers.Timer> obiekt, aby okresowo Sprawdź serwer i upewnij się, że system jest uruchomiona. Jeśli system nie odpowiada, usługa może próbować ponownie uruchomić serwer lub zawiadomić administratora.  
  
> [!IMPORTANT]
> <xref:System.Timers.Timer> Klasa nie jest dostępna dla wszystkich implementacje .NET i wersji, takie jak standardowe 1.6 .NET i niższych wersjach.
> W takich przypadkach można użyć <xref:System.Threading.Timer?displayProperty=nameWithType> zamiast klasy.
  
 Ten typ implementuje <xref:System.IDisposable> interfejsu. Po zakończeniu przy użyciu typu bezpośrednio lub pośrednio należy usunąć z niego. Do usuwania tego typu, należy wywołać jej <xref:System.IDisposable.Dispose%2A> metody w `try` / `catch` bloku. Do usunięcia ich pośrednio, użyj konstrukcji języka takiego jak `using` (w języku C#) lub `Using` (w języku Visual Basic). Aby uzyskać więcej informacji, zobacz sekcję "Przy użyciu obiektu który implementuje interfejs IDisposable" w <xref:System.IDisposable> interfejsu tematu.  
  
 Na serwerze <xref:System.Timers.Timer?displayProperty=nameWithType> klasy jest przeznaczony do użytku z wątków roboczych w środowisku wielowątkowym. Czasomierze serwera można przenosić między wątków do obsługi zgłoszono <xref:System.Timers.Timer.Elapsed> zdarzenie powodujące dokładności więcej niż czasomierze systemu Windows w wywołaniem zdarzenia w czasie.  
  
 <xref:System.Timers.Timer?displayProperty=nameWithType> Składnik wywołuje <xref:System.Timers.Timer.Elapsed> zdarzenia na podstawie wartości (w milisekundach) z <xref:System.Timers.Timer.Interval%2A> właściwości. Może obsłużyć tego zdarzenia do przetwarzania, które są potrzebne. Na przykład załóżmy, że masz aplikację sprzedaży online stale ogłoszeń zamówień z bazą danych. Usługi, który kompiluje się instrukcje dotyczące wysyłania działa na partię zamówienia, a nie poszczególnych kolejność przetwarzania indywidualnie. Można użyć <xref:System.Timers.Timer> można uruchomić co 30 minut przetwarzania wsadowego.  
  
> [!IMPORTANT]
>  Klasa System.Timers.Timer ma taką samą rozdzielczość zegara systemowego. Oznacza to, że <xref:System.Timers.Timer.Elapsed> zdarzenia będą uruchamiane w odstępach czasu zdefiniowanych uzyskuje się poprzez rozpoznanie zegar systemowy, jeśli <xref:System.Timers.Timer.Interval%2A> właściwości jest mniejsza niż rozdzielczość zegara systemowego. Aby uzyskać więcej informacji, zobacz <xref:System.Timers.Timer.Interval%2A> właściwości.  
  
 Gdy <xref:System.Timers.Timer.AutoReset%2A> ma ustawioną wartość `false`, <xref:System.Timers.Timer?displayProperty=nameWithType> obiekt zgłasza <xref:System.Timers.Timer.Elapsed> zdarzeń tylko jeden raz, po pierwszym <xref:System.Timers.Timer.Interval%2A> upłynął. Aby zachować wywoływanie <xref:System.Timers.Timer.Elapsed> zdarzeń regularnie w odstępach czasu zdefiniowanych przez <xref:System.Timers.Timer.Interval%2A>ustaw <xref:System.Timers.Timer.AutoReset%2A> do `true`, która jest wartością domyślną.  
  
 <xref:System.Timers.Timer> Składnika przechwytuje i pomija wszystkie wyjątki zgłaszane przez programy obsługi zdarzeń dla <xref:System.Timers.Timer.Elapsed> zdarzeń. Jest to zachowanie może ulec zmianie w przyszłych wersjach programu .NET Framework. Należy jednak pamiętać, że nie jest to wartość true, programów obsługi zdarzeń, które asynchroniczne i obejmują `await` — operator (w języku C#) lub `Await` — operator (w języku Visual Basic). Wyjątki zgłaszane w tych programów obsługi zdarzeń są propagowane do wątek wywołujący, jak pokazano w poniższym przykładzie. Aby uzyskać więcej informacji na wyjątki zgłaszane w metodach asynchronicznych, zobacz [obsługi wyjątków](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 [!code-csharp[System.Timers.Timer#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/AsyncHandlerEx1.cs#3)]
 [!code-vb[System.Timers.Timer#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/AsyncHandlerEx1.vb#3)]  
  
 Jeśli <xref:System.Timers.Timer.SynchronizingObject%2A> właściwość jest `null`, <xref:System.Timers.Timer.Elapsed> zdarzenie jest zgłaszane przy <xref:System.Threading.ThreadPool> wątku. Jeśli przetwarzanie <xref:System.Timers.Timer.Elapsed> zdarzenia okresu dłuższego niż <xref:System.Timers.Timer.Interval%2A>, zdarzenie może zostać wywołane ponownie na innym <xref:System.Threading.ThreadPool> wątku. W takiej sytuacji należy współużytkowane programu obsługi zdarzeń.  
  
> [!NOTE]
>  Metoda obsługi zdarzeń może działać w jednym wątku, w tym samym czasie, który wywołuje inny wątek <xref:System.Timers.Timer.Stop%2A> metody lub zestawy <xref:System.Timers.Timer.Enabled%2A> właściwości `false`. Może to spowodować <xref:System.Timers.Timer.Elapsed> zdarzenie jest wywoływane po czasomierz jest zatrzymana. Przykład kodu dla <xref:System.Timers.Timer.Stop%2A> metody przedstawia sposób, aby uniknąć tej sytuacji wyścigu.  
  
 Nawet jeśli <xref:System.Timers.Timer.SynchronizingObject%2A> nie jest `null`, <xref:System.Timers.Timer.Elapsed> zdarzeń może wystąpić po <xref:System.Timers.Timer.Dispose%2A> lub <xref:System.Timers.Timer.Stop%2A> została wywołana metoda lub po <xref:System.Timers.Timer.Enabled%2A> ustawioną właściwość `false`, ponieważ sygnału, aby podnieść <xref:System.Timers.Timer.Elapsed> zdarzenie jest zawsze w kolejce do wykonania w wątku puli wątków. Jednym ze sposobów rozwiązania jest sytuacja wyścigu można ustawić flagi, który informuje program obsługi zdarzeń dla <xref:System.Timers.Timer.Elapsed> zdarzeń ignorowanie kolejnych zdarzeń.  
  
 Jeśli używasz <xref:System.Timers.Timer?displayProperty=nameWithType> klasy z elementu interfejsu użytkownika, takich jak formularz lub formant bez wprowadzania czasomierza na ten element interfejsu użytkownika, przypisać do formularza lub kontrolki, która zawiera <xref:System.Timers.Timer> do <xref:System.Timers.Timer.SynchronizingObject%2A> właściwości, tak, aby zdarzenia przekazywane do wątku interfejsu użytkownika.  
  
 Aby uzyskać listę domyślnych wartości właściwości dla wystąpienia <xref:System.Timers.Timer>, zobacz <xref:System.Timers.Timer.%23ctor%2A> konstruktora.  
  
> [!TIP]
>  Należy pamiętać, że .NET zawiera cztery klasy o nazwie `Timer`, każdy z którym znajdują się różne funkcje:  
>   
> - <xref:System.Timers.Timer?displayProperty=nameWithType> (w tym temacie): wyzwala zdarzenie w regularnych odstępach czasu. Klasa jest przeznaczony do użycia jako oparte na serwerze lub składnik usługi w środowisku wielowątkowym; nie ma interfejsu użytkownika, a nie jest widoczny w czasie wykonywania.  
> - <xref:System.Threading.Timer?displayProperty=nameWithType>: wykonuje metodę jednego wywołania zwrotnego w wątku puli wątków w regularnych odstępach czasu. Metody wywołania zwrotnego jest zdefiniowany, gdy zegar zostanie uruchomiony i nie można zmienić. Podobnie jak <xref:System.Timers.Timer?displayProperty=nameWithType> klasy, ta klasa jest przeznaczona do użycia jako składnik serwera lub usługi w środowisku wielowątkowym; nie ma interfejsu użytkownika, a nie jest widoczny w czasie wykonywania.  
> - <xref:System.Windows.Forms.Timer?displayProperty=nameWithType> (Tylko w programie .NET framework): składnik formularzy systemu Windows, który wyzwala zdarzenie w regularnych odstępach czasu. Składnik nie ma interfejsu użytkownika i jest przeznaczony do użytku w środowisku jednowątkowy.  
> - <xref:System.Web.UI.Timer?displayProperty=nameWithType> (Tylko w programie .NET framework): składnik ASP.NET, który wykonuje asynchroniczne i synchroniczne strony sieci web ogłaszania zwrotnego w regularnych odstępach czasu.  

## Examples  
 Poniższy przykład tworzy `System.Timers.Timer` obiekt, który uruchamia się jego <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> zdarzeń co dwie sekundy (2000 MS), ustawia program obsługi zdarzeń dla zdarzenia i uruchamia czasomierz. Program obsługi zdarzeń zawiera wartość <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> właściwość zawsze jest on uruchamiany.  
  
 [!code-csharp[System.Timers.Timer#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer2a.cs#2)]
 [!code-vb[System.Timers.Timer#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer2a.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Wszystkie publiczne <see langword="static" /> elementy członkowskie tego typu są bezpieczne dla wątków. Wystąpienia elementów członkowskich nie dają gwarancji bezpieczeństwa wątków.</threadsafe>
    <altmember cref="P:System.Timers.Timer.AutoReset" />
    <altmember cref="P:System.Timers.Timer.Interval" />
    <altmember cref="E:System.Timers.Timer.Elapsed" />
    <altmember cref="M:System.Timers.Timer.#ctor" />
    <altmember cref="T:System.Threading.Timer" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Timers.Timer" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Timer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Timer();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Timers.Timer" /> klasy, a następnie ustawia wszystkie właściwości ich wartości początkowe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono początkowe wartości właściwości dla wystąpienia <xref:System.Timers.Timer>.  
  
|Właściwość|Wartość początkowa|  
|--------------|-------------------|  
|<xref:System.Timers.Timer.AutoReset%2A>|`true`|  
|<xref:System.Timers.Timer.Enabled%2A>|`false`|  
|<xref:System.Timers.Timer.Interval%2A>|100 milisekund|  
|<xref:System.Timers.Timer.SynchronizingObject%2A>|Odwołanie o wartości null (`Nothing` w języku Visual Basic).|  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Timers.Timer> obiekt, który uruchamia się jego <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> zdarzeń co dwie sekundy (2000 MS), ustawia program obsługi zdarzeń dla zdarzenia i uruchamia czasomierz. Program obsługi zdarzeń zawiera wartość <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> właściwość zawsze jest on uruchamiany.  
  
 [!code-cpp[System.Timers.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.timers.timer/cpp/timer1.cpp#1)]
 [!code-csharp[System.Timers.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer1.cs#1)]
 [!code-vb[System.Timers.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Timers.Timer.AutoReset" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="P:System.Timers.Timer.Interval" />
        <altmember cref="P:System.Timers.Timer.SynchronizingObject" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Timer (double interval);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 interval) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.#ctor(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (interval As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Timer(double interval);" />
      <MemberSignature Language="F#" Value="new System.Timers.Timer : double -&gt; System.Timers.Timer" Usage="new System.Timers.Timer interval" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="interval" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="interval">Czas w milisekundach między zdarzeniami. Wartość musi być większa niż zero i mniejsza niż lub równa <see cref="F:System.Int32.MaxValue" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Timers.Timer" /> klasy i zestawy <see cref="P:System.Timers.Timer.Interval" /> właściwości na określoną liczbę milisekund.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor ustawia <xref:System.Timers.Timer.Interval%2A> właściwości nowe wystąpienie czasomierza, ale nie obsługuje czasomierza.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Timers.Timer> obiekt, który uruchamia się jego <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> zdarzeń co dwie sekundy (2000 MS), ustawia program obsługi zdarzeń dla zdarzenia i uruchamia czasomierz. Program obsługi zdarzeń zawiera wartość <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> właściwość zawsze jest on uruchamiany.  
  
 [!code-csharp[System.Timers.Timer#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/AsyncHandlerEx1.cs#3)]
 [!code-vb[System.Timers.Timer#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/AsyncHandlerEx1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wartość <paramref name="interval" /> parametr jest większa od zera lub większej niż <see cref="F:System.Int32.MaxValue" />.</exception>
        <altmember cref="P:System.Timers.Timer.Interval" />
      </Docs>
    </Member>
    <Member MemberName="AutoReset">
      <MemberSignature Language="C#" Value="public bool AutoReset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoReset" />
      <MemberSignature Language="DocId" Value="P:System.Timers.Timer.AutoReset" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoReset As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutoReset { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoReset : bool with get, set" Usage="System.Timers.Timer.AutoReset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Timers.TimersDescription("Indicates whether the timer will be restarted when it is enabled.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość logiczna wskazującą czy <see cref="T:System.Timers.Timer" /> należy podnieść <see cref="E:System.Timers.Timer.Elapsed" /> zdarzeń tylko raz (<see langword="false" />) lub wielokrotnie (<see langword="true" />).</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Timers.Timer" /> należy podnieść <see cref="E:System.Timers.Timer.Elapsed" /> zdarzeń zawsze czasu; <see langword="false" /> powinien on podniesieniu <see cref="E:System.Timers.Timer.Elapsed" /> zdarzeń tylko raz, po raz pierwszy czasu. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Timers.Timer> jest już włączona, gdy <xref:System.Timers.Timer.Start%2A> metoda jest wywoływana, interwał zostanie zresetowana. Jeśli <xref:System.Timers.Timer.AutoReset%2A> jest `false`, <xref:System.Timers.Timer.Start%2A> można wywołać metody, aby można było rozpocząć obliczanie ponownie.  
  
 Resetowanie interwał wpływa na kiedy <xref:System.Timers.Timer.Elapsed> zdarzenia. Na przykład ustawić interwał wynoszący 5 sekund, a następnie ustaw <xref:System.Timers.Timer.Enabled%2A> właściwości `true`, licznik, który rozpoczyna się w czasie <xref:System.Timers.Timer.Enabled%2A> jest ustawiona. Jeśli zresetujesz interwał na 10 sekund, jeśli licznik osiągnie wartość 3 sekundy <xref:System.Timers.Timer.Elapsed> zdarzenie jest wywoływane po raz pierwszy 13 sekund po <xref:System.Timers.Timer.Enabled%2A> ustawiono właściwość `true`.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Timers.Timer> którego <xref:System.Timers.Timer.Elapsed> zdarzenie wyzwalane po 1,5 s. Jej procedura obsługi zdarzeń następnie wyświetla "Witaj świecie!" w konsoli.  
  
 [!code-cpp[Classic Timer.Timer1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Timer.Timer1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Timer.Timer1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Timer.Timer1 Example/CS/source.cs#1)]
 [!code-vb[Classic Timer.Timer1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Timer.Timer1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Timers.Timer.Interval" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="M:System.Timers.Timer.Start" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="timer.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rozpoczyna inicjowanie środowiska wykonawczego <see cref="T:System.Timers.Timer" /> używany w formularzu lub przez inny składnik.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] Projekt środowiska korzystania z tej metody można uruchomić inicjowania składnika, który jest używany w formularzu lub przez inny składnik. <xref:System.Timers.Timer.EndInit%2A> Metoda kończy się inicjowania. Przy użyciu <xref:System.Timers.Timer.BeginInit%2A> i <xref:System.Timers.Timer.EndInit%2A> metody uniemożliwia użycie przed pełnym zainicjowaniem formantu.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="M:System.Timers.Timer.EndInit" />
        <altmember cref="P:System.Timers.Timer.Interval" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="timer.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia zasoby używane przez <see cref="T:System.Timers.Timer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Timers.Timer.Close%2A> Metoda z kolei wywołuje `Dispose` metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="timer.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> aby zwolnić tylko zasoby niezarządzane.</param>
        <summary>Zwalnia wszelkie zasoby używane przez bieżące <see cref="T:System.Timers.Timer" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Elapsed">
      <MemberSignature Language="C#" Value="public event System.Timers.ElapsedEventHandler Elapsed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Timers.ElapsedEventHandler Elapsed" />
      <MemberSignature Language="DocId" Value="E:System.Timers.Timer.Elapsed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Elapsed As ElapsedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Timers::ElapsedEventHandler ^ Elapsed;" />
      <MemberSignature Language="F#" Value="member this.Elapsed : System.Timers.ElapsedEventHandler " Usage="member this.Elapsed : System.Timers.ElapsedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Timers.TimersDescription("Occurs when the Interval has elapsed.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Timers.ElapsedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy upłynie interwał.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Timers.Timer.Elapsed> Zdarzenie jest wywoływane, gdy <xref:System.Timers.Timer.Enabled%2A> właściwość jest `true` i przedział czasu (w milisekundach) zdefiniowanych przez <xref:System.Timers.Timer.Interval%2A> upłynie właściwości. Jeśli <xref:System.Timers.Timer.AutoReset%2A> właściwość jest `true`, zdarzenie jest wywoływane wielokrotnie w odstępach czasu zdefiniowanych przez <xref:System.Timers.Timer.Interval%2A> właściwość; w przeciwnym razie zdarzenie jest wywoływane tylko raz, po raz pierwszy <xref:System.Timers.Timer.Interval%2A> wartość upłynie.  
  
 Jeśli <xref:System.Timers.Timer.Interval%2A> jest ustawiany po <xref:System.Timers.Timer> została uruchomiona, zostanie zresetowany. Na przykład ustawić interwał wynoszący 5 sekund, a następnie ustaw <xref:System.Timers.Timer.Enabled%2A> do `true`, licznik, który rozpoczyna się w czasie <xref:System.Timers.Timer.Enabled%2A> jest ustawiona. Jeśli zresetujesz interwał na 10 sekund, gdy liczba jest 3 sekundy <xref:System.Timers.Timer.Elapsed> zdarzenie jest wywoływane po raz pierwszy 13 sekund po <xref:System.Timers.Timer.Enabled%2A> ustawiono `true`.  
  
 Jeśli <xref:System.Timers.Timer.SynchronizingObject%2A> właściwość jest `null`, <xref:System.Timers.Timer.Elapsed> zdarzenie jest zgłaszane przy <xref:System.Threading.ThreadPool> wątku. Jeśli przetwarzanie <xref:System.Timers.Timer.Elapsed> zdarzenia okresu dłuższego niż <xref:System.Timers.Timer.Interval%2A>, zdarzenie może zostać wywołane ponownie na innym <xref:System.Threading.ThreadPool> wątku. W takiej sytuacji należy współużytkowane programu obsługi zdarzeń.  
  
> [!NOTE]
>  Metoda obsługi zdarzeń może działać w jednym wątku, w tym samym czasie, który wywołuje inny wątek <xref:System.Timers.Timer.Stop%2A> metody lub zestawy <xref:System.Timers.Timer.Enabled%2A> właściwości `false`. Może to spowodować <xref:System.Timers.Timer.Elapsed> zdarzenie jest wywoływane po czasomierz jest zatrzymana. Przykład kodu dla <xref:System.Timers.Timer.Stop%2A> metody przedstawia sposób, aby uniknąć tej sytuacji wyścigu.  
  
 Nawet jeśli <xref:System.Timers.Timer.SynchronizingObject%2A> nie jest `null`, <xref:System.Timers.Timer.Elapsed> zdarzeń może wystąpić po <xref:System.Timers.Timer.Dispose%2A> lub <xref:System.Timers.Timer.Stop%2A> została wywołana metoda lub po <xref:System.Timers.Timer.Enabled%2A> ustawioną właściwość `false`, ponieważ sygnału, aby podnieść <xref:System.Timers.Timer.Elapsed> zdarzenie jest zawsze w kolejce do wykonania w wątku puli wątków. Jednym ze sposobów rozwiązania jest sytuacja wyścigu można ustawić flagi, który informuje program obsługi zdarzeń dla <xref:System.Timers.Timer.Elapsed> zdarzeń ignorowanie kolejnych zdarzeń.  
  
 <xref:System.Timers.Timer> Składnika przechwytuje i pomija wszystkie wyjątki zgłaszane przez programy obsługi zdarzeń dla <xref:System.Timers.Timer.Elapsed> zdarzeń. Jest to zachowanie może ulec zmianie w przyszłych wersjach programu .NET Framework.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Timers.Timer> obiekt, który uruchamia się jego <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> zdarzeń co dwie sekundy (2000 MS), ustawia program obsługi zdarzeń dla zdarzenia i uruchamia czasomierz. Program obsługi zdarzeń zawiera wartość <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> właściwość zawsze jest on uruchamiany.  
  
 [!code-cpp[System.Timers.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.timers.timer/cpp/timer1.cpp#1)]
 [!code-csharp[System.Timers.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer1.cs#1)]
 [!code-vb[System.Timers.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Timers.Timer.Interval" />
        <altmember cref="P:System.Timers.Timer.AutoReset" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
        <altmember cref="T:System.Timers.ElapsedEventArgs" />
        <altmember cref="T:System.Timers.ElapsedEventHandler" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
      </Docs>
    </Member>
    <Member MemberName="Enabled">
      <MemberSignature Language="C#" Value="public bool Enabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Enabled" />
      <MemberSignature Language="DocId" Value="P:System.Timers.Timer.Enabled" />
      <MemberSignature Language="VB.NET" Value="Public Property Enabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Enabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Enabled : bool with get, set" Usage="System.Timers.Timer.Enabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Timers.TimersDescription("Indicates whether the timer is enabled to fire events at a defined interval.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą czy <see cref="T:System.Timers.Timer" /> należy podnieść <see cref="E:System.Timers.Timer.Elapsed" /> zdarzeń.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Timers.Timer" /> należy podnieść <see cref="E:System.Timers.Timer.Elapsed" /> zdarzeń; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustawienie <xref:System.Timers.Timer.Enabled%2A> do `true` jest taka sama jak wywołanie <xref:System.Timers.Timer.Start%2A>, podczas gdy ustawienie <xref:System.Timers.Timer.Enabled%2A> do `false` jest taka sama jak wywołanie <xref:System.Timers.Timer.Stop%2A>.  
  
> [!NOTE]
>  Sygnał podnieść <xref:System.Timers.Timer.Elapsed> zdarzenie jest zawsze umieszczonych w kolejce do wykonania na <xref:System.Threading.ThreadPool> wątku. Może to spowodować <xref:System.Timers.Timer.Elapsed> zdarzenie jest wywoływane po <xref:System.Timers.Timer.Enabled%2A> właściwość jest ustawiona na `false`. Przykład kodu dla <xref:System.Timers.Timer.Stop%2A> metody przedstawia sposób obejścia sytuacja wyścigu.  
  
 Jeśli <xref:System.Timers.Timer.Enabled%2A> ustawiono `true` i <xref:System.Timers.Timer.AutoReset%2A> ustawiono `false`, <xref:System.Timers.Timer> zgłasza <xref:System.Timers.Timer.Elapsed> upływa zdarzeń tylko raz, po raz pierwszy interwał.  
  
 Jeśli interwał jest ustawiany po <xref:System.Timers.Timer> została uruchomiona, zostanie zresetowany. Na przykład ustawić interwał wynoszący 5 sekund, a następnie ustaw <xref:System.Timers.Timer.Enabled%2A> właściwości `true`, licznik, który rozpoczyna się w czasie <xref:System.Timers.Timer.Enabled%2A> jest ustawiona. Jeśli zresetujesz interwał na 10 sekund, gdy liczba jest 3 sekundy <xref:System.Timers.Timer.Elapsed> zdarzenie jest wywoływane po raz pierwszy 13 sekund po <xref:System.Timers.Timer.Enabled%2A> ustawiono `true`.  
  
> [!NOTE]
>  Niektóre wizualnych projektantów, takich jak w programie Microsoft Visual Studio, ustaw <xref:System.Timers.Timer.Enabled%2A> właściwości `true` przy wstawianiu nowy <xref:System.Timers.Timer>.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Timers.Timer> obiekt, który uruchamia się jego <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> zdarzeń co dwie sekundy (2000 MS), ustawia program obsługi zdarzeń dla zdarzenia i uruchamia czasomierz. Program obsługi zdarzeń zawiera wartość <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> właściwość zawsze jest on uruchamiany.  
  
 [!code-cpp[System.Timers.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.timers.timer/cpp/timer1.cpp#1)]
 [!code-csharp[System.Timers.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer1.cs#1)]
 [!code-vb[System.Timers.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Nie można ustawić tej właściwości, ponieważ zegar został usunięty.</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Timers.Timer.Interval" /> Właściwość została ustawiona na wartość większą niż <see cref="F:System.Int32.MaxValue" /> przed włączeniem czasomierza.</exception>
        <altmember cref="P:System.Timers.Timer.Interval" />
        <altmember cref="P:System.Timers.Timer.AutoReset" />
        <altmember cref="M:System.Timers.Timer.Start" />
        <altmember cref="M:System.Timers.Timer.Stop" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="timer.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Kończy się inicjowanie środowiska wykonawczego <see cref="T:System.Timers.Timer" /> używany w formularzu lub przez inny składnik.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] Projekt środowiska korzystania z tej metody do zakończenia inicjowania składnika, który jest używany w formularzu lub przez inny składnik. <xref:System.Timers.Timer.BeginInit%2A> Metoda uruchamia inicjowania. Przy użyciu <xref:System.Timers.Timer.BeginInit%2A> i <xref:System.Timers.Timer.EndInit%2A> metody uniemożliwia użycie przed pełnym zainicjowaniem formantu.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Timers.Timer.BeginInit" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="P:System.Timers.Timer.Interval" />
      </Docs>
    </Member>
    <Member MemberName="Interval">
      <MemberSignature Language="C#" Value="public double Interval { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Interval" />
      <MemberSignature Language="DocId" Value="P:System.Timers.Timer.Interval" />
      <MemberSignature Language="VB.NET" Value="Public Property Interval As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Interval { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Interval : double with get, set" Usage="System.Timers.Timer.Interval" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(100)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Timers.TimersDescription("The number of milliseconds between timer events.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia interwał wyrażony w milisekundach, w którym należy podnieść <see cref="E:System.Timers.Timer.Elapsed" /> zdarzeń.</summary>
        <value>Czas w milisekundach między <see cref="E:System.Timers.Timer.Elapsed" /> zdarzenia. Wartość musi być większa niż zero i mniejsza niż lub równa <see cref="F:System.Int32.MaxValue" />. Wartość domyślna to 100 milisekund.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz użyć <xref:System.Timers.Timer.Interval%2A> właściwość, aby ustalić częstotliwość, z jaką <xref:System.Timers.Timer.Elapsed> zdarzenie jest wywoływane. Ponieważ <xref:System.Timers.Timer> klasy zależy zegar systemowy, ma taką samą rozdzielczość zegara systemowego. Oznacza to, że <xref:System.Timers.Timer.Elapsed> zdarzenia będą uruchamiane w odstępach czasu zdefiniowanych uzyskuje się poprzez rozpoznanie zegar systemowy, jeśli <xref:System.Timers.Timer.Interval%2A> właściwości jest mniejsza niż rozdzielczość zegara systemowego. W poniższym przykładzie <xref:System.Timers.Timer.Interval%2A> właściwości do 5 w milisekundach. Uruchomienia [!INCLUDE[win7](~/includes/win7-md.md)] systemu, w których zegara systemowego ma rozdzielczość około 15 milisekund, generowane zdarzenie co około 15 milisekund niż co 5 milisekund.  
  
 [!code-csharp[System.Timers.Timer.Interval#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer.interval/cs/interval2.cs#1)]
 [!code-vb[System.Timers.Timer.Interval#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer.interval/vb/interval2.vb#1)]  
  
 Poniższy kod umożliwia określenie rozdzielczości zegara systemowego w bieżącym systemie:  
  
 [!code-csharp[System.Timers.Timer.Interval#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer.interval/cs/resolution1.cs#2)]
 [!code-vb[System.Timers.Timer.Interval#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer.interval/vb/resolution1.vb#2)]  
  
 Jeśli aplikacja wymaga rozpoznawania większa niż oferowane przez <xref:System.Timers.Timer> klasy lub zegar systemowy, użyj wysokiej rozdzielczości czasomierze multimediów; zobacz [porady: Użyj czasomierza rozdzielczości](http://msdn.microsoft.com/library/aa964692.aspx).  
  
 Jeśli interwał jest ustawiany po <xref:System.Timers.Timer> została uruchomiona, zostanie zresetowany. Na przykład ustawić interwał wynoszący 5 sekund, a następnie ustaw <xref:System.Timers.Timer.Enabled%2A> właściwości `true`, licznik, który rozpoczyna się w czasie <xref:System.Timers.Timer.Enabled%2A> jest ustawiona. Jeśli zresetujesz interwał na 10 sekund, gdy liczba jest 3 sekundy <xref:System.Timers.Timer.Elapsed> zdarzenie jest wywoływane po raz pierwszy 13 sekund po <xref:System.Timers.Timer.Enabled%2A> ustawiono `true`.  
  
 Jeśli <xref:System.Timers.Timer.Enabled%2A> ustawiono `true` i <xref:System.Timers.Timer.AutoReset%2A> ustawiono `false`, <xref:System.Timers.Timer> zgłasza <xref:System.Timers.Timer.Elapsed> upływa zdarzeń tylko raz, po raz pierwszy interwał. <xref:System.Timers.Timer.Enabled%2A> następnie ustawiono `false`.  
  
> [!NOTE]
>  Jeśli <xref:System.Timers.Timer.Enabled%2A> i <xref:System.Timers.Timer.AutoReset%2A> są ustawione na `false`, i czasomierza wcześniej została włączona, ustawienie <xref:System.Timers.Timer.Interval%2A> powoduje, że właściwość <xref:System.Timers.Timer.Elapsed> się jeden raz, zdarzenia tak, jakby <xref:System.Timers.Timer.Enabled%2A> właściwość ma wartość `true`. Aby ustawić interwał bez wywołaniem zdarzenia, można tymczasowo ustawić <xref:System.Timers.Timer.Enabled%2A> właściwości `true`, ustaw <xref:System.Timers.Timer.Interval%2A> przedział czasu odpowiednią dla właściwości, a następnie ustaw natychmiast <xref:System.Timers.Timer.Enabled%2A> właściwości z powrotem do `false`.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Timers.Timer> obiekt, który uruchamia się jego <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> zdarzeń co dwie sekundy (2000 MS), ustawia program obsługi zdarzeń dla zdarzenia i uruchamia czasomierz. Program obsługi zdarzeń zawiera wartość <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> właściwość zawsze jest on uruchamiany.  
  
 [!code-cpp[System.Timers.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.timers.timer/cpp/timer1.cpp#1)]
 [!code-csharp[System.Timers.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer1.cs#1)]
 [!code-vb[System.Timers.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Interwał jest mniejsza lub równa zero.  Interwał jest większa niż - lub - <see cref="F:System.Int32.MaxValue" />, a czasomierz jest aktualnie włączone. (Jeśli licznik nie jest aktualnie włączone, nie jest zwracany wyjątek, dopóki nie zostanie włączona.)</exception>
        <altmember cref="P:System.Timers.Timer.AutoReset" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.Timers.Timer.Site" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Site : System.ComponentModel.ISite with get, set" Usage="System.Timers.Timer.Site" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia lokacji, która jest powiązywana <see cref="T:System.Timers.Timer" /> do jego kontenera w trybie projektowania.</summary>
        <value>
          <see cref="T:System.ComponentModel.ISite" /> Interfejs reprezentujący lokacji, która jest powiązywana <see cref="T:System.Timers.Timer" /> obiektu do jego kontenera.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Powiązania witryny <xref:System.ComponentModel.Component> do <xref:System.ComponentModel.Container> i umożliwić komunikację między nimi, dzięki czemu kontener, aby zarządzać jego składniki.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; unit" Usage="timer.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Uruchamia wywoływanie <see cref="E:System.Timers.Timer.Elapsed" /> zdarzenia przez ustawienie <see cref="P:System.Timers.Timer.Enabled" /> do <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Timers.Timer.Start%2A> nosi nazwę i <xref:System.Timers.Timer.AutoReset%2A> ustawiono `false`, <xref:System.Timers.Timer> zgłasza <xref:System.Timers.Timer.Elapsed> upływa zdarzeń tylko raz, po raz pierwszy interwał. Jeśli <xref:System.Timers.Timer.Start%2A> nosi nazwę i <xref:System.Timers.Timer.AutoReset%2A> jest `true`, <xref:System.Timers.Timer> zgłasza <xref:System.Timers.Timer.Elapsed> czas trwania zdarzenia pierwszy interwał upływa i będzie nadal występować wywołać zdarzenia w określonym przedziale czasu.  
  
 Można także uruchomić przez ustawienie czasu <xref:System.Timers.Timer.Enabled%2A> do `true`.  
  
> [!NOTE]
>  Jeśli <xref:System.Timers.Timer.AutoReset%2A> jest `false`, <xref:System.Timers.Timer.Start%2A> można wywołać metody, aby można było rozpocząć obliczanie ponownie.  
  
 Wywołanie <xref:System.Timers.Timer.Start%2A> metody włączenie czasomierza nie ma wpływu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <see cref="T:System.Timers.Timer" /> Utworzeniu interwał równy lub większy niż <see cref="F:System.Int32.MaxValue" /> + 1 lub ustaw interwał mniejsze od zera.</exception>
        <altmember cref="P:System.Timers.Timer.Interval" />
        <altmember cref="P:System.Timers.Timer.AutoReset" />
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="M:System.Timers.Timer.Stop" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Timers.Timer.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop();" />
      <MemberSignature Language="F#" Value="member this.Stop : unit -&gt; unit" Usage="timer.Stop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zatrzymuje wywoływanie <see cref="E:System.Timers.Timer.Elapsed" /> zdarzenia przez ustawienie <see cref="P:System.Timers.Timer.Enabled" /> do <see langword="false" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można również zatrzymać chronometrażu przez ustawienie <xref:System.Timers.Timer.Enabled%2A> do `false`.  
  
> [!NOTE]
>  Sygnał podnieść <xref:System.Timers.Timer.Elapsed> zdarzenie jest zawsze umieszczonych w kolejce do wykonania na <xref:System.Threading.ThreadPool> wątku, co metoda obsługi zdarzeń może być uruchamiane w jeden wątek, w tym samym czasie, który wywołanie <xref:System.Timers.Timer.Stop%2A> metoda jest uruchamiana w innym wątku. Może to spowodować <xref:System.Timers.Timer.Elapsed> zdarzenie jest wywoływane po <xref:System.Timers.Timer.Stop%2A> metoda jest wywoływana. W następnej sekcji przykładowy kod przedstawia sposób obejścia sytuacja wyścigu.  
  
   
  
## Examples  
 Poniższy przykład tworzy `System.Timers.Timer` obiekt, który uruchamia się jego <xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType> zdarzeń co dwie sekundy (2000 MS), ustawia program obsługi zdarzeń dla zdarzenia i uruchamia czasomierz. Program obsługi zdarzeń zawiera wartość <xref:System.Timers.ElapsedEventArgs.SignalTime%2A?displayProperty=nameWithType> właściwość zawsze jest on uruchamiany. Gdy użytkownik naciśnie klawisz Enter, <xref:System.Timers.Timer.Stop%2A> metoda przed zakończeniem aplikacji.  
  
 [!code-csharp[System.Timers.Timer#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.timers.timer/cs/timer2a.cs#2)]
 [!code-vb[System.Timers.Timer#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.timers.timer/vb/timer2a.vb#2)]  
  
 Poniższy przykładowy kod przedstawia sposób zapobiec wątku, który wywołuje <xref:System.Timers.Timer.Stop%2A> metoda przed kontynuowaniem do aktualnie wykonywanych <xref:System.Timers.Timer.Elapsed> zakończenia zdarzenia i również dwa zapobiec <xref:System.Timers.Timer.Elapsed> zdarzenia wykonywanie programu obsługi zdarzeń w tym samym czas (nazywanej często ponownego rozpoczęcia).  
  
 Przykład wykonuje 100 uruchomień testów. Zawsze, gdy test jest uruchomiony, czasomierza została uruchomiona z interwałem równym 150 milisekund. Program obsługi zdarzeń używa <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> metodę, aby symulować zadanie, które losowo różni się o długości od 50 do 200 ms. Metoda testowa uruchamia również wątku formant, który oczekuje na sekundę, a następnie zatrzymuje czasomierza. Jeśli zdarzenie jest obsługiwane czasomierza zatrzymania wątku kontroli, wątek kontroli musi poczekać na zdarzenie zostało zakończone przed kontynuowaniem.  
  
 <xref:System.Threading.Interlocked.CompareExchange%28System.Int32%40%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> Przeciążenie metody jest używana w celu uniknięcia ponownego rozpoczęcia i uniemożliwić wątku kontroli kontynuowana do czasu zakończenia wykonywania zdarzenia. Program obsługi zdarzeń używa <xref:System.Threading.Interlocked.CompareExchange%28System.Int32%40%2CSystem.Int32%2CSystem.Int32%29> metodę, aby ustawić formantu zmiennej na wartość 1, ale tylko wtedy, gdy wartość jest obecnie zero. Jest to niepodzielną operację. Jeśli wartość zwracana jest wartość zero, 1 została ustawiona zmienna kontroli i obsługi zdarzeń będzie kontynuowana. Jeśli wartość zwracana jest niezerowa, zdarzenie jest po prostu odrzucony Aby uniknąć ponownego rozpoczęcia. (Jakby wykonać każde zdarzenie <xref:System.Threading.Monitor> klasy będzie lepszym sposobem zdarzenia synchronizacji.) Po zakończeniu obsługi zdarzeń, ustawia zmienna sterująca wstecz na zero. Przykład rejestruje łączną liczbę zdarzeń, które wykonane, które zostały odrzucone z powodu ponownego rozpoczęcia i które wystąpiły po <xref:System.Timers.Timer.Stop%2A> wywołano metodę.  
  
 Wątek kontroli używa <xref:System.Threading.Interlocked.CompareExchange%28System.Int32%40%2CSystem.Int32%2CSystem.Int32%29> metodę, aby ustawić formant zmiennej na wartość -1 (minus jeden), ale tylko wtedy, gdy wartość jest obecnie zero. Jeśli niepodzielną operację zwraca wartość inną niż zero, zdarzenie jest obecnie wykonywane. Wątek kontroli czeka i próbuje ponownie. Przykład rejestruje liczbę razy wątku formant miał oczekiwania na zdarzenie zakończyć.  
  
 [!code-csharp[Timer.Stop#1](~/samples/snippets/csharp/VS_Snippets_CLR/Timer.Stop/CS/source.cs#1)]
 [!code-vb[Timer.Stop#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Timer.Stop/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Timers.Timer.Enabled" />
        <altmember cref="M:System.Timers.Timer.Start" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Timers.Timer.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.Timers.Timer.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.TypeConverter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Timers.TimersDescription("The object used to marshal the event handler calls issued when an interval has elapsed.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia obiekt używany do organizowania wywołań obsługi zdarzeń, które są wydawane po upłynięciu interwału.</summary>
        <value>
          <see cref="T:System.ComponentModel.ISynchronizeInvoke" /> Reprezentujący obiekt używany do organizowania wywołań obsługi zdarzeń, które są wydawane po upłynięciu interwału. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Timers.Timer.SynchronizingObject%2A> jest `null`, metoda obsługująca <xref:System.Timers.Timer.Elapsed> zdarzenie jest wywoływane w wątku z puli wątków systemu. Aby uzyskać więcej informacji na pule wątków systemu, zobacz <xref:System.Threading.ThreadPool>.  
  
 Gdy <xref:System.Timers.Timer.Elapsed> zdarzenie jest obsługiwane przez składnik visual formularzy systemu Windows, takie jak przycisk, uzyskiwanie dostępu do składnika za pośrednictwem puli wątków systemu może wynik wyjątku lub po prostu mogą nie działać. Ustawiając uniknąć tego efektu <xref:System.Timers.Timer.SynchronizingObject%2A> składnika formularzy systemu Windows, co powoduje, że metoda obsługująca <xref:System.Timers.Timer.Elapsed> zdarzeń ma być wywołane na tym samym wątku, który składnik został utworzony na.  
  
> [!NOTE]
>  Nawet jeśli <xref:System.Timers.Timer.SynchronizingObject%2A> właściwość nie jest `null`, <xref:System.Timers.Timer.Elapsed> zdarzeń może wystąpić po <xref:System.Timers.Timer.Dispose%2A> lub <xref:System.Timers.Timer.Stop%2A> została wywołana metoda lub po <xref:System.Timers.Timer.Enabled%2A> ustawioną właściwość `false`, ponieważ sygnału, aby wywołać <xref:System.Timers.Timer.Elapsed> zdarzenie jest zawsze w kolejce do wykonania w wątku puli wątków. Jednym ze sposobów rozwiązania jest sytuacja wyścigu można ustawić flagi, który informuje program obsługi zdarzeń dla <xref:System.Timers.Timer.Elapsed> zdarzeń ignorowanie kolejnych zdarzeń.  
  
 Jeśli <xref:System.Timers.Timer> jest używany w programie Visual Studio za pomocą projektanta formularzy systemu Windows <xref:System.Timers.Timer.SynchronizingObject%2A> jest automatycznie ustawiana formant, który zawiera <xref:System.Timers.Timer>. Na przykład, jeśli zostanie <xref:System.Timers.Timer> na projektanta dla `Form1` (który dziedziczy z <xref:System.Windows.Forms.Form>), <xref:System.Timers.Timer.SynchronizingObject%2A> właściwość <xref:System.Timers.Timer> ustawiono wystąpienie `Form1`.  
  
   
  
## Examples  
 Poniższy przykład jest aplikacji formularzy systemu Windows, która służy jako edytora tekstu bardzo proste. Gdy tekst w polu tekstowym nie został zapisany, aplikacja pyta użytkownika w odstępach jednej minuty czy chce można zapisać zawartości pola tekstowego.  Aby to zrobić, <xref:System.Timers.Timer.Interval%2A> właściwość jest ustawiona na minutę (60 000 w milisekundach) i <xref:System.Timers.Timer.SynchronizingObject%2A> ma ustawioną właściwość <xref:System.Windows.Forms.Form> obiektu.  
  
 [!code-csharp[System.Timers.Timer.SynchronizingObject#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Timers.Timer.SynchronizingObject/cs/Form1.cs#1)]
 [!code-vb[System.Timers.Timer.SynchronizingObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Timers.Timer.SynchronizingObject/vb/Form1.vb#1)]  
  
 Przykład wymaga, Dodaj następujące formanty do formularza:  
  
-   A <xref:System.Windows.Forms.TextBox> formantu o nazwie `TextBox1` (domyślnej nazwy).  
  
-   A <xref:System.Windows.Forms.Button> formantu o nazwie `Button1` (domyślnej nazwy).  
  
-   A <xref:System.Windows.Forms.SaveFileDialog> formantu o nazwie `SaveSaveFileDialog1` (domyślnej nazwy).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Form" />
        <altmember cref="T:System.ComponentModel.ISynchronizeInvoke" />
        <altmember cref="T:System.Threading.ThreadPool" />
        <altmember cref="E:System.Timers.Timer.Elapsed" />
      </Docs>
    </Member>
  </Members>
</Type>
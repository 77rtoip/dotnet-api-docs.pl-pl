<Type Name="Pkcs8PrivateKeyInfo" FullName="System.Security.Cryptography.Pkcs.Pkcs8PrivateKeyInfo">
  <Metadata><Meta Name="ms.openlocfilehash" Value="0562a4e0cc885c88fd2cf17c1086a058bd79dc8d" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69263638" /></Metadata><TypeSignature Language="C#" Value="public sealed class Pkcs8PrivateKeyInfo" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Pkcs8PrivateKeyInfo extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Security.Cryptography.Pkcs.Pkcs8PrivateKeyInfo" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Pkcs8PrivateKeyInfo" />
  <TypeSignature Language="C++ CLI" Value="public ref class Pkcs8PrivateKeyInfo sealed" />
  <TypeSignature Language="F#" Value="type Pkcs8PrivateKeyInfo = class" />
  <AssemblyInfo>
    <AssemblyName>System.Security.Cryptography.Pkcs</AssemblyName>
    <AssemblyVersion>4.0.4.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Włącza inspekcję i tworzenie wartości PKCS # 8 PrivateKeyInfo i EncryptedPrivateKeyInfo. Klasa ta nie może być dziedziczona.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Pkcs8PrivateKeyInfo (System.Security.Cryptography.Oid algorithmId, Nullable&lt;ReadOnlyMemory&lt;byte&gt;&gt; algorithmParameters, ReadOnlyMemory&lt;byte&gt; privateKey, bool skipCopies = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Security.Cryptography.Oid algorithmId, valuetype System.Nullable`1&lt;valuetype System.ReadOnlyMemory`1&lt;unsigned int8&gt;&gt; algorithmParameters, valuetype System.ReadOnlyMemory`1&lt;unsigned int8&gt; privateKey, bool skipCopies) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Pkcs.Pkcs8PrivateKeyInfo.#ctor(System.Security.Cryptography.Oid,System.Nullable{System.ReadOnlyMemory{System.Byte}},System.ReadOnlyMemory{System.Byte},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (algorithmId As Oid, algorithmParameters As Nullable(Of ReadOnlyMemory(Of Byte)), privateKey As ReadOnlyMemory(Of Byte), Optional skipCopies As Boolean = false)" />
      <MemberSignature Language="F#" Value="new System.Security.Cryptography.Pkcs.Pkcs8PrivateKeyInfo : System.Security.Cryptography.Oid * Nullable&lt;ReadOnlyMemory&lt;byte&gt;&gt; * ReadOnlyMemory&lt;byte&gt; * bool -&gt; System.Security.Cryptography.Pkcs.Pkcs8PrivateKeyInfo" Usage="new System.Security.Cryptography.Pkcs.Pkcs8PrivateKeyInfo (algorithmId, algorithmParameters, privateKey, skipCopies)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Pkcs</AssemblyName>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="algorithmId" Type="System.Security.Cryptography.Oid" />
        <Parameter Name="algorithmParameters" Type="System.Nullable&lt;System.ReadOnlyMemory&lt;System.Byte&gt;&gt;" />
        <Parameter Name="privateKey" Type="System.ReadOnlyMemory&lt;System.Byte&gt;" />
        <Parameter Name="skipCopies" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="algorithmId">Identyfikator obiektu (OID) identyfikujący algorytm asymetryczny, którego dotyczy ten klucz.</param>
        <param name="algorithmParameters">Parametry algorytmu z kodowaniem i skojarzone z tym kluczem lub <see langword="null" /> do pomijania parametrów algorytmu podczas kodowania.</param>
        <param name="privateKey">Zakodowany klucz prywatny związany z algorytmem.</param>
        <param name="skipCopies"><see langword="true" />do przechowywania <paramref name="algorithmParameters" /> i <paramref name="privateKey" /> bez tworzenia kopii <see langword="false" />obronnej; w przeciwnym razie. Wartość domyślna to <see langword="false" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Security.Cryptography.Pkcs.Pkcs8PrivateKeyInfo" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Nie wykonano walidacji w `privateKey` parametrze; nie wszystkie algorytmy wymagają wartości zakodowanej przez funkcję.

Domyślnym zachowaniem tego konstruktora jest, aby wykonać kopię obronną obu `algorithmParameters` `privateKey` parametrów i.
Gdy parametr ma wartość `true`, ta kopia obronna jest pomijana. `skipCopies`
Jeśli kopia obronna jest pomijana i zawartość `algorithmParameters` lub `privateKey` zmienia się w okresie istnienia zwróconej wartości lub dowolnego obiektu utworzonego przez jego metody lub właściwości, metody i właściwości dotyczące tych obiektów mogą generować niesensy wyniki lub zgłoś wyjątki ze względu na uszkodzony stan.
W związku z tym zaleca się użycie `true` wartości `skipCopies` parametru tylko wtedy, gdy można mieć pewność, że dane pozostaną nienaruszone.
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="algorithmId" /></exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><paramref name="algorithmParameters" /> Parametr nie<see langword="null" />jest pusty lub ma jedną wartość zakodowaną przy użyciu wartości.</exception>
        <altmember cref="M:System.Security.Cryptography.Pkcs.Pkcs8PrivateKeyInfo.Create(System.Security.Cryptography.AsymmetricAlgorithm)" />
        <altmember cref="Overload:System.Security.Cryptography.Pkcs.Pkcs8PrivateKeyInfo.Decode" />
        <altmember cref="Overload:System.Security.Cryptography.Pkcs.Pkcs8PrivateKeyInfo.DecryptAndDecode" />
      </Docs>
    </Member>
    <Member MemberName="AlgorithmId">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.Oid AlgorithmId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.Oid AlgorithmId" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.Pkcs.Pkcs8PrivateKeyInfo.AlgorithmId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AlgorithmId As Oid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::Oid ^ AlgorithmId { System::Security::Cryptography::Oid ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AlgorithmId : System.Security.Cryptography.Oid" Usage="System.Security.Cryptography.Pkcs.Pkcs8PrivateKeyInfo.AlgorithmId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Pkcs</AssemblyName>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.Oid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość identyfikatora obiektu (OID) identyfikującą algorytm tego klucza.</summary>
        <value>Wartość identyfikatora obiektu (OID) identyfikująca algorytm, dla którego jest używany ten klucz.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AlgorithmParameters">
      <MemberSignature Language="C#" Value="public Nullable&lt;ReadOnlyMemory&lt;byte&gt;&gt; AlgorithmParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Nullable`1&lt;valuetype System.ReadOnlyMemory`1&lt;unsigned int8&gt;&gt; AlgorithmParameters" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.Pkcs.Pkcs8PrivateKeyInfo.AlgorithmParameters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AlgorithmParameters As Nullable(Of ReadOnlyMemory(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Nullable&lt;ReadOnlyMemory&lt;System::Byte&gt;&gt; AlgorithmParameters { Nullable&lt;ReadOnlyMemory&lt;System::Byte&gt;&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.AlgorithmParameters : Nullable&lt;ReadOnlyMemory&lt;byte&gt;&gt;" Usage="System.Security.Cryptography.Pkcs.Pkcs8PrivateKeyInfo.AlgorithmParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Pkcs</AssemblyName>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.ReadOnlyMemory&lt;System.Byte&gt;&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość pamięci zawierającą parametry algorytmu zakodowane za pomocą wartości z tego klucza.</summary>
        <value>Wartość pamięci zawierająca parametry algorytmu zakodowane przy użyciu klucza, skojarzone z tym kluczem <see langword="null" /> lub parametry nie były obecne.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.CryptographicAttributeObjectCollection Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.CryptographicAttributeObjectCollection Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.Pkcs.Pkcs8PrivateKeyInfo.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Attributes As CryptographicAttributeObjectCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::CryptographicAttributeObjectCollection ^ Attributes { System::Security::Cryptography::CryptographicAttributeObjectCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Attributes : System.Security.Cryptography.CryptographicAttributeObjectCollection" Usage="System.Security.Cryptography.Pkcs.Pkcs8PrivateKeyInfo.Attributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Pkcs</AssemblyName>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.CryptographicAttributeObjectCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera modyfikowalną kolekcję atrybutów dla tego klucza prywatnego.</summary>
        <value>Modyfikowalna Kolekcja atrybutów do kodowania przy użyciu klucza prywatnego.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.Pkcs.Pkcs8PrivateKeyInfo Create (System.Security.Cryptography.AsymmetricAlgorithm privateKey);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.Cryptography.Pkcs.Pkcs8PrivateKeyInfo Create(class System.Security.Cryptography.AsymmetricAlgorithm privateKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Pkcs.Pkcs8PrivateKeyInfo.Create(System.Security.Cryptography.AsymmetricAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (privateKey As AsymmetricAlgorithm) As Pkcs8PrivateKeyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Cryptography::Pkcs::Pkcs8PrivateKeyInfo ^ Create(System::Security::Cryptography::AsymmetricAlgorithm ^ privateKey);" />
      <MemberSignature Language="F#" Value="static member Create : System.Security.Cryptography.AsymmetricAlgorithm -&gt; System.Security.Cryptography.Pkcs.Pkcs8PrivateKeyInfo" Usage="System.Security.Cryptography.Pkcs.Pkcs8PrivateKeyInfo.Create privateKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Pkcs</AssemblyName>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.Pkcs.Pkcs8PrivateKeyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="privateKey" Type="System.Security.Cryptography.AsymmetricAlgorithm" />
      </Parameters>
      <Docs>
        <param name="privateKey">Klucz prywatny do reprezentowania w PrivateKeyInfo PKCS # 8.</param>
        <summary>Eksportuje określony klucz jako PrivateKeyInfo PKCS # 8 i zwraca zdekodowaną interpretację.</summary>
        <returns>Dekodowane interpretacja wyeksportowanego pliku PKCS # 8 PrivateKeyInfo.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="privateKey" /></exception>
        <altmember cref="M:System.Security.Cryptography.AsymmetricAlgorithm.ExportPkcs8PrivateKey" />
        <altmember cref="Overload:System.Security.Cryptography.Pkcs.Pkcs8PrivateKeyInfo.Decode" />
      </Docs>
    </Member>
    <Member MemberName="Decode">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.Pkcs.Pkcs8PrivateKeyInfo Decode (ReadOnlyMemory&lt;byte&gt; source, out int bytesRead, bool skipCopy = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.Cryptography.Pkcs.Pkcs8PrivateKeyInfo Decode(valuetype System.ReadOnlyMemory`1&lt;unsigned int8&gt; source, [out] int32&amp; bytesRead, bool skipCopy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Pkcs.Pkcs8PrivateKeyInfo.Decode(System.ReadOnlyMemory{System.Byte},System.Int32@,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Decode (source As ReadOnlyMemory(Of Byte), ByRef bytesRead As Integer, Optional skipCopy As Boolean = false) As Pkcs8PrivateKeyInfo" />
      <MemberSignature Language="F#" Value="static member Decode : ReadOnlyMemory&lt;byte&gt; *  * bool -&gt; System.Security.Cryptography.Pkcs.Pkcs8PrivateKeyInfo" Usage="System.Security.Cryptography.Pkcs.Pkcs8PrivateKeyInfo.Decode (source, bytesRead, skipCopy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Pkcs</AssemblyName>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.Pkcs.Pkcs8PrivateKeyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlyMemory&lt;System.Byte&gt;" />
        <Parameter Name="bytesRead" Type="System.Int32" RefType="out" />
        <Parameter Name="skipCopy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="source">Dane, które mają być interpretowane jako wartość PrivateKeyInfo PKCS # 8.</param>
        <param name="bytesRead">Gdy ta metoda zwraca, zawiera wartość wskazującą liczbę bajtów odczytywanych z <paramref name="source" />. Ten parametr jest traktowany jako niezainicjowany.</param>
        <param name="skipCopy"><see langword="true" />do przechowywania <paramref name="source" /> bez tworzenia kopii obronnej; <see langword="false" />w przeciwnym razie. Wartość domyślna to <see langword="false" />.</param>
        <summary>Odczytuje dostarczone dane jako PrivateKeyInfo PKCS # 8 i zwraca widok obiektu zawartości.</summary>
        <returns>Widok obiektu zawartości zdekodowany jako PrivateKeyInfo PKCS # 8.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks
 Domyślnym zachowaniem tej metody jest skopiowanie obrony z pierwszego `bytesConsumed` bajtu z. `source`
Gdy parametr ma wartość `true`, ta kopia obronna jest pomijana. `skipCopy`
Jeśli kopia obronna została pominięta i zawartość pierwszych `bytesConsumed` `source` bajtów zmiany w okresie istnienia zwracanej wartości lub dowolnego obiektu utworzonego przez jego metody lub właściwości, metody i właściwości dotyczące tych obiektów mogą generować wyniki niewykrywające lub zgłoś wyjątki ze względu na uszkodzony stan.
W związku z tym zaleca się użycie `true` wartości `skipCopy` parametru tylko wtedy, gdy można mieć pewność, że dane pozostaną nienaruszone.
 
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Zawartość <paramref name="source" /> parametru nie została pomyślnie zdekodowana jako PKCS # 8 PrivateKeyInfo.</exception>
      </Docs>
    </Member>
    <Member MemberName="DecryptAndDecode">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.Pkcs.Pkcs8PrivateKeyInfo DecryptAndDecode (ReadOnlySpan&lt;byte&gt; passwordBytes, ReadOnlyMemory&lt;byte&gt; source, out int bytesRead);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.Cryptography.Pkcs.Pkcs8PrivateKeyInfo DecryptAndDecode(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; passwordBytes, valuetype System.ReadOnlyMemory`1&lt;unsigned int8&gt; source, [out] int32&amp; bytesRead) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Pkcs.Pkcs8PrivateKeyInfo.DecryptAndDecode(System.ReadOnlySpan{System.Byte},System.ReadOnlyMemory{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DecryptAndDecode (passwordBytes As ReadOnlySpan(Of Byte), source As ReadOnlyMemory(Of Byte), ByRef bytesRead As Integer) As Pkcs8PrivateKeyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Cryptography::Pkcs::Pkcs8PrivateKeyInfo ^ DecryptAndDecode(ReadOnlySpan&lt;System::Byte&gt; passwordBytes, ReadOnlyMemory&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] int % bytesRead);" />
      <MemberSignature Language="F#" Value="static member DecryptAndDecode : ReadOnlySpan&lt;byte&gt; * ReadOnlyMemory&lt;byte&gt; *  -&gt; System.Security.Cryptography.Pkcs.Pkcs8PrivateKeyInfo" Usage="System.Security.Cryptography.Pkcs.Pkcs8PrivateKeyInfo.DecryptAndDecode (passwordBytes, source, bytesRead)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Pkcs</AssemblyName>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.Pkcs.Pkcs8PrivateKeyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="passwordBytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="source" Type="System.ReadOnlyMemory&lt;System.Byte&gt;" />
        <Parameter Name="bytesRead" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="passwordBytes">Bajty, które mają być używane jako hasło podczas odszyfrowywania materiału klucza.</param>
        <param name="source">Dane, które mają zostać odczytane jako struktura EncryptedPrivateKeyInfo PKCS # 8 w kodowaniu ASN. 1-w.</param>
        <param name="bytesRead">Gdy ta metoda zwraca, zawiera wartość wskazującą liczbę bajtów odczytywanych z <paramref name="source" />. Ten parametr jest traktowany jako niezainicjowany.</param>
        <summary>Odszyfrowuje dostarczone dane przy użyciu podanego hasła opartego na bajtach i dekoduje dane wyjściowe w widoku obiektu PKCS # 8 PrivateKeyInfo.</summary>
        <returns>Widok obiektu zawartości odszyfrowany zdekodowaną jako PKCS # 8 PrivateKeyInfo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bajty hasła są przesyłane bezpośrednio do funkcji wyprowadzania klucza (KDF) używanej przez algorytm wskazywany `pbeParameters`przez.
Dzięki temu można zapewnić zgodność z innymi systemami, które używają kodowania tekstu innego niż UTF-8 podczas przetwarzania haseł z PBKDF2 (klucz oparty na haśle funkcja 2).

 Ta metoda obsługuje tylko kodowanie binarne (//CER/DER) EncryptedPrivateKeyInfo.
Jeśli wartość jest zakodowana algorytmem Base64 lub w formacie tekstowym PEM, wywołujący musi zdekodować zawartość przed wywołaniem tej metody.

 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Hasło jest niepoprawne.

—lub—

Zawartość <paramref name="source" /> wskaż funkcję wyprowadzania klucza (KDF), która ma zostać zastosowana, jest starszą wersją PKCS # 12 <see cref="T:System.Char" />KDF, która wymaga haseł opartych na plikach.

—lub—

Zawartość <paramref name="source" /> nie reprezentuje struktury EncryptedPrivateKeyInfo PKCS # 8 w formacie ASN. 1.</exception>
      </Docs>
      <altmember cref="M:System.Security.Cryptography.AsymmetricAlgorithm.ImportPkcs8PrivateKey" />
    </Member>
    <Member MemberName="DecryptAndDecode">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.Pkcs.Pkcs8PrivateKeyInfo DecryptAndDecode (ReadOnlySpan&lt;char&gt; password, ReadOnlyMemory&lt;byte&gt; source, out int bytesRead);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.Cryptography.Pkcs.Pkcs8PrivateKeyInfo DecryptAndDecode(valuetype System.ReadOnlySpan`1&lt;char&gt; password, valuetype System.ReadOnlyMemory`1&lt;unsigned int8&gt; source, [out] int32&amp; bytesRead) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Pkcs.Pkcs8PrivateKeyInfo.DecryptAndDecode(System.ReadOnlySpan{System.Char},System.ReadOnlyMemory{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DecryptAndDecode (password As ReadOnlySpan(Of Char), source As ReadOnlyMemory(Of Byte), ByRef bytesRead As Integer) As Pkcs8PrivateKeyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Cryptography::Pkcs::Pkcs8PrivateKeyInfo ^ DecryptAndDecode(ReadOnlySpan&lt;char&gt; password, ReadOnlyMemory&lt;System::Byte&gt; source, [Runtime::InteropServices::Out] int % bytesRead);" />
      <MemberSignature Language="F#" Value="static member DecryptAndDecode : ReadOnlySpan&lt;char&gt; * ReadOnlyMemory&lt;byte&gt; *  -&gt; System.Security.Cryptography.Pkcs.Pkcs8PrivateKeyInfo" Usage="System.Security.Cryptography.Pkcs.Pkcs8PrivateKeyInfo.DecryptAndDecode (password, source, bytesRead)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Pkcs</AssemblyName>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.Pkcs.Pkcs8PrivateKeyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="password" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="source" Type="System.ReadOnlyMemory&lt;System.Byte&gt;" />
        <Parameter Name="bytesRead" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="password">Hasło, które ma być używane podczas odszyfrowywania materiału klucza.</param>
        <param name="source">Bajty struktury EncryptedPrivateKeyInfo PKCS # 8 w kodowaniu ASN. 1-w.</param>
        <param name="bytesRead">Gdy ta metoda zwraca, zawiera wartość wskazującą liczbę bajtów odczytywanych z <paramref name="source" />. Ten parametr jest traktowany jako niezainicjowany.</param>
        <summary>Odszyfrowuje dostarczone dane przy użyciu podanego hasła opartego na znakach i dekoduje dane wyjściowe w widoku obiektu PKCS # 8 PrivateKeyInfo.</summary>
        <returns>Widok obiektu zawartości odszyfrowany zdekodowaną jako PKCS # 8 PrivateKeyInfo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy zawartość `source` wskazuje algorytm używający funkcji PBKDF1 (klucza opartego na hasłach) lub PBKDF2 (klucz oparty na hasłach, funkcja 2), hasło jest konwertowane na bajty przy użyciu kodowania UTF-8.

 Ta metoda obsługuje tylko kodowanie binarne (//CER/DER) EncryptedPrivateKeyInfo.
Jeśli wartość jest zakodowana algorytmem Base64 lub w formacie tekstowym PEM, wywołujący musi zdekodować zawartość przed wywołaniem tej metody.

 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Security.Cryptography.AsymmetricAlgorithm.ImportEncryptedPkcs8PrivateKey" />
      </Docs>
    </Member>
    <Member MemberName="Encode">
      <MemberSignature Language="C#" Value="public byte[] Encode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] Encode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Pkcs.Pkcs8PrivateKeyInfo.Encode" />
      <MemberSignature Language="VB.NET" Value="Public Function Encode () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ Encode();" />
      <MemberSignature Language="F#" Value="member this.Encode : unit -&gt; byte[]" Usage="pkcs8PrivateKeyInfo.Encode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Pkcs</AssemblyName>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Koduje dane właściwości tego wystąpienia jako PKCS # 8 PrivateKeyInfo i zwraca kodowanie jako tablicę bajtów.</summary>
        <returns>Tablica bajtów reprezentująca zakodowaną postać PKCS # 8 PrivateKeyInfo.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="Overload:System.Security.Cryptography.Pkcs.Pkcs8PrivateKeyInfo.TryEncode" />
      </Docs>
    </Member>
    <Member MemberName="Encrypt">
      <MemberSignature Language="C#" Value="public byte[] Encrypt (ReadOnlySpan&lt;byte&gt; passwordBytes, System.Security.Cryptography.PbeParameters pbeParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] Encrypt(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; passwordBytes, class System.Security.Cryptography.PbeParameters pbeParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Pkcs.Pkcs8PrivateKeyInfo.Encrypt(System.ReadOnlySpan{System.Byte},System.Security.Cryptography.PbeParameters)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ Encrypt(ReadOnlySpan&lt;System::Byte&gt; passwordBytes, System::Security::Cryptography::PbeParameters ^ pbeParameters);" />
      <MemberSignature Language="F#" Value="member this.Encrypt : ReadOnlySpan&lt;byte&gt; * System.Security.Cryptography.PbeParameters -&gt; byte[]" Usage="pkcs8PrivateKeyInfo.Encrypt (passwordBytes, pbeParameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Pkcs</AssemblyName>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="passwordBytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="pbeParameters" Type="System.Security.Cryptography.PbeParameters" />
      </Parameters>
      <Docs>
        <param name="passwordBytes">Bajty, które mają być używane jako hasło podczas szyfrowania materiału klucza.</param>
        <param name="pbeParameters">Parametry szyfrowania opartego na hasłach (PBE), które mają być używane podczas szyfrowania materiału klucza.</param>
        <summary>Tworzy EncryptedPrivateKeyInfo PKCS # 8 z zawartości właściwości tego obiektu po szyfrowaniu przy użyciu określonych parametrów hasła i szyfrowania opartych na bajtach.</summary>
        <returns>Tablica bajtowa zawierająca zakodowaną postać PKCS # 8 EncryptedPrivateKeyInfo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bajty hasła są przesyłane bezpośrednio do funkcji wyprowadzania klucza (KDF) używanej przez algorytm wskazywany `pbeParameters`przez.
Dzięki temu można zapewnić zgodność z innymi systemami, które używają kodowania tekstu innego niż UTF-8 podczas przetwarzania haseł z PBKDF2 (klucz oparty na haśle funkcja 2).

 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException"><paramref name="pbeParameters" />wskazuje, <see cref="F:System.Security.Cryptography.PbeEncryptionAlgorithm.TripleDes3KeyPkcs12" /> że powinny być używane, które <see cref="T:System.Char" />wymaga haseł opartych na.</exception>
        <altmember cref="Overload:System.Security.Cryptography.Pkcs.Pkcs8PrivateKeyInfo.TryEncrypt" />
      </Docs>
    </Member>
    <Member MemberName="Encrypt">
      <MemberSignature Language="C#" Value="public byte[] Encrypt (ReadOnlySpan&lt;char&gt; password, System.Security.Cryptography.PbeParameters pbeParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] Encrypt(valuetype System.ReadOnlySpan`1&lt;char&gt; password, class System.Security.Cryptography.PbeParameters pbeParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Pkcs.Pkcs8PrivateKeyInfo.Encrypt(System.ReadOnlySpan{System.Char},System.Security.Cryptography.PbeParameters)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ Encrypt(ReadOnlySpan&lt;char&gt; password, System::Security::Cryptography::PbeParameters ^ pbeParameters);" />
      <MemberSignature Language="F#" Value="member this.Encrypt : ReadOnlySpan&lt;char&gt; * System.Security.Cryptography.PbeParameters -&gt; byte[]" Usage="pkcs8PrivateKeyInfo.Encrypt (password, pbeParameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Pkcs</AssemblyName>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="password" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="pbeParameters" Type="System.Security.Cryptography.PbeParameters" />
      </Parameters>
      <Docs>
        <param name="password">Hasło, które ma być używane podczas szyfrowania materiału klucza.</param>
        <param name="pbeParameters">Parametry szyfrowania opartego na hasłach (PBE), które mają być używane podczas szyfrowania materiału klucza.</param>
        <summary>Tworzy EncryptedPrivateKeyInfo PKCS # 8 z zawartości właściwości tego obiektu po szyfrowaniu przy użyciu określonych parametrów na podstawie hasła i szyfrowania.</summary>
        <returns>Tablica bajtowa zawierająca zakodowaną postać PKCS # 8 EncryptedPrivateKeyInfo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy `pbeParameters` wskazuje algorytm korzystający z PBKDF2 (klucz oparty na hasłach funkcja 2), hasło jest konwertowane na bajty przy użyciu kodowania UTF-8.

 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Security.Cryptography.Pkcs.Pkcs8PrivateKeyInfo.TryEncrypt" />
      </Docs>
    </Member>
    <Member MemberName="PrivateKeyBytes">
      <MemberSignature Language="C#" Value="public ReadOnlyMemory&lt;byte&gt; PrivateKeyBytes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ReadOnlyMemory`1&lt;unsigned int8&gt; PrivateKeyBytes" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.Pkcs.Pkcs8PrivateKeyInfo.PrivateKeyBytes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivateKeyBytes As ReadOnlyMemory(Of Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property ReadOnlyMemory&lt;System::Byte&gt; PrivateKeyBytes { ReadOnlyMemory&lt;System::Byte&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivateKeyBytes : ReadOnlyMemory&lt;byte&gt;" Usage="System.Security.Cryptography.Pkcs.Pkcs8PrivateKeyInfo.PrivateKeyBytes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Pkcs</AssemblyName>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlyMemory&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość pamięci reprezentującą zakodowany klucz prywatny.</summary>
        <value>Wartość pamięci reprezentująca zakodowany klucz prywatny.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryEncode">
      <MemberSignature Language="C#" Value="public bool TryEncode (Span&lt;byte&gt; destination, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEncode(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Pkcs.Pkcs8PrivateKeyInfo.TryEncode(System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEncode (destination As Span(Of Byte), ByRef bytesWritten As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEncode(Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberSignature Language="F#" Value="member this.TryEncode : Span&lt;byte&gt; *  -&gt; bool" Usage="pkcs8PrivateKeyInfo.TryEncode (destination, bytesWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Pkcs</AssemblyName>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="destination">Zakres bajtów do odbierania danych PrivateKeyInfo PKCS # 8.</param>
        <param name="bytesWritten">Gdy ta metoda zwraca, zawiera wartość wskazującą liczbę bajtów, do <paramref name="destination" />których zapisano. Ten parametr jest traktowany jako niezainicjowany.</param>
        <summary>Próbuje zakodować dane właściwości tego wystąpienia jako PKCS # 8 PrivateKeyInfo, pisząc wyniki do podanego buforu.</summary>
        <returns><see langword="true" />Jeśli <paramref name="destination" /> jest wystarczająco duży, <see langword="false" />Aby uzyskać dane wyjściowe; w przeciwnym razie.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Security.Cryptography.Pkcs.Pkcs8PrivateKeyInfo.Encode" />
      </Docs>
    </Member>
    <Member MemberName="TryEncrypt">
      <MemberSignature Language="C#" Value="public bool TryEncrypt (ReadOnlySpan&lt;byte&gt; passwordBytes, System.Security.Cryptography.PbeParameters pbeParameters, Span&lt;byte&gt; destination, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEncrypt(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; passwordBytes, class System.Security.Cryptography.PbeParameters pbeParameters, valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Pkcs.Pkcs8PrivateKeyInfo.TryEncrypt(System.ReadOnlySpan{System.Byte},System.Security.Cryptography.PbeParameters,System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEncrypt(ReadOnlySpan&lt;System::Byte&gt; passwordBytes, System::Security::Cryptography::PbeParameters ^ pbeParameters, Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberSignature Language="F#" Value="member this.TryEncrypt : ReadOnlySpan&lt;byte&gt; * System.Security.Cryptography.PbeParameters * Span&lt;byte&gt; *  -&gt; bool" Usage="pkcs8PrivateKeyInfo.TryEncrypt (passwordBytes, pbeParameters, destination, bytesWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Pkcs</AssemblyName>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="passwordBytes" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="pbeParameters" Type="System.Security.Cryptography.PbeParameters" />
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="passwordBytes">Bajty, które mają być używane jako hasło podczas szyfrowania materiału klucza.</param>
        <param name="pbeParameters">Parametry szyfrowania opartego na hasłach (PBE), które mają być używane podczas szyfrowania materiału klucza.</param>
        <param name="destination">Zakres bajtów do odbierania danych EncryptedPrivateKeyInfo PKCS # 8.</param>
        <param name="bytesWritten">Gdy ta metoda zwraca, zawiera wartość wskazującą liczbę bajtów, do <paramref name="destination" />których zapisano. Ten parametr jest traktowany jako niezainicjowany.</param>
        <summary>Program podejmuje próbę utworzenia EncryptedPrivateKeyInfo PKCS # 8 z zawartości właściwości tego obiektu po zaszyfrowaniu przy użyciu określonych parametrów hasła i szyfrowania, pisząc wyniki w określonym buforze.</summary>
        <returns><see langword="true" />Jeśli <paramref name="destination" /> jest wystarczająco duży, <see langword="false" />Aby uzyskać dane wyjściowe; w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bajty hasła są przesyłane bezpośrednio do funkcji wyprowadzania klucza (KDF) używanej przez algorytm wskazywany `pbeParameters`przez.
Dzięki temu można zapewnić zgodność z innymi systemami, które używają kodowania tekstu innego niż UTF-8 podczas przetwarzania haseł z PBKDF2 (klucz oparty na haśle funkcja 2).

 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Security.Cryptography.Pkcs.Pkcs8PrivateKeyInfo.Encrypt" />
      </Docs>
    </Member>
    <Member MemberName="TryEncrypt">
      <MemberSignature Language="C#" Value="public bool TryEncrypt (ReadOnlySpan&lt;char&gt; password, System.Security.Cryptography.PbeParameters pbeParameters, Span&lt;byte&gt; destination, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryEncrypt(valuetype System.ReadOnlySpan`1&lt;char&gt; password, class System.Security.Cryptography.PbeParameters pbeParameters, valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Pkcs.Pkcs8PrivateKeyInfo.TryEncrypt(System.ReadOnlySpan{System.Char},System.Security.Cryptography.PbeParameters,System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryEncrypt(ReadOnlySpan&lt;char&gt; password, System::Security::Cryptography::PbeParameters ^ pbeParameters, Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberSignature Language="F#" Value="member this.TryEncrypt : ReadOnlySpan&lt;char&gt; * System.Security.Cryptography.PbeParameters * Span&lt;byte&gt; *  -&gt; bool" Usage="pkcs8PrivateKeyInfo.TryEncrypt (password, pbeParameters, destination, bytesWritten)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Pkcs</AssemblyName>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="password" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="pbeParameters" Type="System.Security.Cryptography.PbeParameters" />
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="password">Hasło, które ma być używane podczas szyfrowania materiału klucza.</param>
        <param name="pbeParameters">Parametry szyfrowania opartego na hasłach (PBE), które mają być używane podczas szyfrowania materiału klucza.</param>
        <param name="destination">Zakres bajtów do odbierania danych EncryptedPrivateKeyInfo PKCS # 8.</param>
        <param name="bytesWritten">Gdy ta metoda zwraca, zawiera wartość wskazującą liczbę bajtów, do <paramref name="destination" />których zapisano. Ten parametr jest traktowany jako niezainicjowany.</param>
        <summary>Program podejmuje próbę utworzenia EncryptedPrivateKeyInfo PKCS # 8 z zawartości właściwości tego obiektu po zaszyfrowaniu przy użyciu określonych parametrów opartych na znakach i szyfrowania, pisząc wynik w określonym buforze.</summary>
        <returns><see langword="true" />Jeśli <paramref name="destination" /> jest wystarczająco duży, <see langword="false" />Aby uzyskać dane wyjściowe; w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy `pbeParameters` wskazuje algorytm korzystający z PBKDF2 (klucz oparty na hasłach funkcja 2), hasło jest konwertowane na bajty przy użyciu kodowania UTF-8.

 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Security.Cryptography.Pkcs.Pkcs8PrivateKeyInfo.Encrypt" />
      </Docs>
    </Member>
  </Members>
</Type>

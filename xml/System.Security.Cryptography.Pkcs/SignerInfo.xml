<Type Name="SignerInfo" FullName="System.Security.Cryptography.Pkcs.SignerInfo">
  <Metadata><Meta Name="ms.openlocfilehash" Value="34475c5032278e74852ddc8ca3a9dc103f36ea84" /><Meta Name="ms.sourcegitcommit" Value="43c8e74d92c78325492baf27e41b400443f0dfbf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/08/2019" /><Meta Name="ms.locfileid" Value="68858866" /></Metadata><TypeSignature Language="C#" Value="public sealed class SignerInfo" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit SignerInfo extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Security.Cryptography.Pkcs.SignerInfo" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class SignerInfo" />
  <TypeSignature Language="C++ CLI" Value="public ref class SignerInfo sealed" />
  <TypeSignature Language="F#" Value="type SignerInfo = class" />
  <AssemblyInfo>
    <AssemblyName>System.Security</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Security.Cryptography.Pkcs</AssemblyName>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.1</AssemblyVersion>
    <AssemblyVersion>4.0.4.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Klasa reprezentuje podpisującego skojarzonego <see cref="T:System.Security.Cryptography.Pkcs.SignedCms" /> z obiektem, który reprezentuje komunikat #7 CMS/PKCS. <see cref="T:System.Security.Cryptography.Pkcs.SignerInfo" /></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sygnatury reprezentowane przez <xref:System.Security.Cryptography.Pkcs.SignerInfo> klasę mogą być za pośrednictwem treści wiadomości lub podpisu. Ten ostatni rodzaj podpisu jest określany jako *kontrpodpis*.  
  
 Ta implementacja #7 CMS/PKCS obsługuje tylko jeden poziom kontrpodpis.  Oznacza to, że podpis może być podpisany, który tworzy element kontrpodpis, ale nie można ponownie podpisać kontrpodpis.  
  
 Ta klasa nie ma konstruktora publicznego; w związku z tym nie można publicznie utworzyć wystąpienia. Jest ona klasą tylko do odczytu dostępną z <xref:System.Security.Cryptography.Pkcs.SignedCms.SignerInfos%2A?displayProperty=nameWithType> właściwości.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AddUnsignedAttribute">
      <MemberSignature Language="C#" Value="public void AddUnsignedAttribute (System.Security.Cryptography.AsnEncodedData asnEncodedData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddUnsignedAttribute(class System.Security.Cryptography.AsnEncodedData asnEncodedData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Pkcs.SignerInfo.AddUnsignedAttribute(System.Security.Cryptography.AsnEncodedData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddUnsignedAttribute(System::Security::Cryptography::AsnEncodedData ^ asnEncodedData);" />
      <MemberSignature Language="F#" Value="member this.AddUnsignedAttribute : System.Security.Cryptography.AsnEncodedData -&gt; unit" Usage="signerInfo.AddUnsignedAttribute asnEncodedData" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Pkcs</AssemblyName>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asnEncodedData" Type="System.Security.Cryptography.AsnEncodedData" Index="0" FrameworkAlternate="dotnet-plat-ext-3.0" />
      </Parameters>
      <Docs>
        <param name="asnEncodedData">Atrybut z kodowaniem ASN. 1, który ma zostać dodany do dokumentu.</param>
        <summary>Dodaje określony atrybut do bieżącego dokumentu.</summary>
        <remarks>  
          <format type="text/markdown"><![CDATA[  

Jeśli określony atrybut już istnieje w dokumencie, jest on scalany z istniejącym elementem.

Po dodaniu dokumentu zostanie on jeszcze zakodowany.

         ]]></format>
         </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Nie można znaleźć oryginalnej osoby podpisującej.
        
 —lub—

ASN1 uszkodzone dane.</exception>
      </Docs>
    </Member>
    <Member MemberName="Certificate">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.X509Certificates.X509Certificate2 Certificate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.X509Certificates.X509Certificate2 Certificate" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.Pkcs.SignerInfo.Certificate" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Certificate As X509Certificate2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::X509Certificates::X509Certificate2 ^ Certificate { System::Security::Cryptography::X509Certificates::X509Certificate2 ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Certificate : System.Security.Cryptography.X509Certificates.X509Certificate2" Usage="System.Security.Cryptography.Pkcs.SignerInfo.Certificate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Pkcs</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.1</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509Certificate2</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Security.Cryptography.Pkcs.SignerInfo.Certificate" /> Właściwość pobiera certyfikat podpisywania skojarzony z informacjami o logowaniu.</summary>
        <value><see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> Obiekt, który reprezentuje certyfikat podpisywania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli certyfikat podpisywania nie zostanie uwzględniony podczas podpisywania przy użyciu <xref:System.Security.Cryptography.Pkcs.CmsSigner.IncludeOption%2A?displayProperty=nameWithType> właściwości, certyfikat nie zostanie zwrócony.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.CounterSignerInfos" />
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.DigestAlgorithm" />
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.SignedAttributes" />
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.SignerIdentifier" />
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.UnsignedAttributes" />
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.Version" />
      </Docs>
    </Member>
    <Member MemberName="CheckHash">
      <MemberSignature Language="C#" Value="public void CheckHash ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CheckHash() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Pkcs.SignerInfo.CheckHash" />
      <MemberSignature Language="VB.NET" Value="Public Sub CheckHash ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CheckHash();" />
      <MemberSignature Language="F#" Value="member this.CheckHash : unit -&gt; unit" Usage="signerInfo.CheckHash " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Pkcs</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.1</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="M:System.Security.Cryptography.Pkcs.SignerInfo.CheckHash" /> Metoda weryfikuje integralność danych informacji o podpisywaniu komunikatów #7 CMS/PKCS. <see cref="M:System.Security.Cryptography.Pkcs.SignerInfo.CheckHash" />jest wyspecjalizowaną metodą używaną w określonych aplikacjach infrastruktury zabezpieczeń, w której podmiot korzysta **** z elementu członkowskiego <see cref="T:System.Security.Cryptography.Pkcs.SubjectIdentifierType" /> HashOnly <see cref="T:System.Security.Cryptography.Pkcs.CmsSigner" /> podczas konfigurowania obiektu. <see cref="M:System.Security.Cryptography.Pkcs.SignerInfo.CheckHash" />nie uwierzytelnia informacji osoby podpisującej, ponieważ ta metoda nie obejmuje weryfikowania podpisu cyfrowego. Aby uzyskać ogólne informacje na temat integralności i autentyczności informacji o podpisywaniu i kontrasygnatur komunikatów usługi CMS/PKCS #7, użyj <see cref="M:System.Security.Cryptography.Pkcs.SignerInfo.CheckSignature(System.Boolean)" /> metod <see cref="M:System.Security.Cryptography.Pkcs.SignerInfo.CheckSignature(System.Security.Cryptography.X509Certificates.X509Certificate2Collection,System.Boolean)" /> lub.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie zapewnia uwierzytelniania informacji o logowaniu do usługi CMS/PKCS #7.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Nie można ukończyć operacji kryptograficznej.</exception>
        <altmember cref="T:System.Security.Cryptography.Pkcs.CmsSigner" />
        <altmember cref="M:System.Security.Cryptography.Pkcs.SignedCms.CheckHash" />
        <altmember cref="T:System.Security.Cryptography.Pkcs.SubjectIdentifierType" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CheckSignature">
      <AssemblyInfo>
        <AssemblyName>System.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Weryfikuje podpis cyfrowy wiadomości.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CheckSignature">
      <MemberSignature Language="C#" Value="public void CheckSignature (bool verifySignatureOnly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CheckSignature(bool verifySignatureOnly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Pkcs.SignerInfo.CheckSignature(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CheckSignature (verifySignatureOnly As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CheckSignature(bool verifySignatureOnly);" />
      <MemberSignature Language="F#" Value="member this.CheckSignature : bool -&gt; unit" Usage="signerInfo.CheckSignature verifySignatureOnly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Pkcs</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.1</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="verifySignatureOnly" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="verifySignatureOnly">Wartość logiczna określająca, czy jest weryfikowany tylko podpis cyfrowy. Jeśli <paramref name="verifySignatureOnly" /> ma<see langword="true" />wartość, tylko podpis zostanie zweryfikowany. Jeśli <paramref name="verifySignatureOnly" /> jest<see langword="false" />, podpis cyfrowy zostanie zweryfikowany, łańcuch certyfikatów zostanie sprawdzony, a cele certyfikatów są weryfikowane. Cele certyfikatu są uznawane za prawidłowe, jeśli certyfikat nie ma użycia klucza lub jeśli użycie klucza obsługuje podpis cyfrowy lub wyprawność.</param>
        <summary><see cref="M:System.Security.Cryptography.Pkcs.SignerInfo.CheckSignature(System.Boolean)" /> Metoda weryfikuje podpis cyfrowy wiadomości i, opcjonalnie, sprawdza poprawność certyfikatu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zgłasza wyjątek, Jeśli weryfikacja podpisu cyfrowego nie powiedzie się lub żadne wymagania dotyczące weryfikacji nie są spełnione.  
  
 Jeśli wymagana jest bardziej złożona Walidacja, obiekt wywołujący może określić, że tylko podpis zostanie zweryfikowany, <xref:System.Security.Cryptography.X509Certificates.X509Chain> a następnie użyć obiektu do przeprowadzenia niestandardowej walidacji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Odwołanie o wartości null zostało przesłane do metody, która nie akceptuje jej jako prawidłowego argumentu.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Nie można ukończyć operacji kryptograficznej.</exception>
        <exception cref="T:System.InvalidOperationException">Wywołanie metody było nieprawidłowe dla bieżącego stanu obiektu.</exception>
      </Docs>
    </Member>
    <Member MemberName="CheckSignature">
      <MemberSignature Language="C#" Value="public void CheckSignature (System.Security.Cryptography.X509Certificates.X509Certificate2Collection extraStore, bool verifySignatureOnly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CheckSignature(class System.Security.Cryptography.X509Certificates.X509Certificate2Collection extraStore, bool verifySignatureOnly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Pkcs.SignerInfo.CheckSignature(System.Security.Cryptography.X509Certificates.X509Certificate2Collection,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CheckSignature (extraStore As X509Certificate2Collection, verifySignatureOnly As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CheckSignature(System::Security::Cryptography::X509Certificates::X509Certificate2Collection ^ extraStore, bool verifySignatureOnly);" />
      <MemberSignature Language="F#" Value="member this.CheckSignature : System.Security.Cryptography.X509Certificates.X509Certificate2Collection * bool -&gt; unit" Usage="signerInfo.CheckSignature (extraStore, verifySignatureOnly)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Pkcs</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.1</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="extraStore" Type="System.Security.Cryptography.X509Certificates.X509Certificate2Collection" />
        <Parameter Name="verifySignatureOnly" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="extraStore"><see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2Collection" /> Obiekt, który może służyć do sprawdzania poprawności łańcucha. Jeśli żadne dodatkowe certyfikaty nie będą używane do walidacji łańcucha, użyj <see cref="M:System.Security.Cryptography.Pkcs.SignerInfo.CheckSignature(System.Boolean)" /> <see cref="M:System.Security.Cryptography.Pkcs.SignerInfo.CheckSignature(System.Security.Cryptography.X509Certificates.X509Certificate2Collection,System.Boolean)" />zamiast.</param>
        <param name="verifySignatureOnly">Wartość logiczna określająca, czy jest weryfikowany tylko podpis cyfrowy. Jeśli <paramref name="verifySignatureOnly" /> ma<see langword="true" />wartość, tylko podpis zostanie zweryfikowany. Jeśli <paramref name="verifySignatureOnly" /> jest<see langword="false" />, podpis cyfrowy zostanie zweryfikowany, łańcuch certyfikatów zostanie sprawdzony, a cele certyfikatów są weryfikowane. Cele certyfikatu są uznawane za prawidłowe, jeśli certyfikat nie ma użycia klucza lub jeśli użycie klucza obsługuje podpis cyfrowy lub wyprawność.</param>
        <summary><see cref="M:System.Security.Cryptography.Pkcs.SignerInfo.CheckSignature(System.Security.Cryptography.X509Certificates.X509Certificate2Collection,System.Boolean)" /> Metoda weryfikuje podpis cyfrowy wiadomości przy użyciu określonej kolekcji certyfikatów i, opcjonalnie, sprawdza poprawność certyfikatu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zgłasza wyjątek, Jeśli weryfikacja podpisu cyfrowego nie powiedzie się lub żadne wymagania dotyczące weryfikacji nie są spełnione.  
  
 Jeśli wymagana jest bardziej złożona Walidacja, obiekt wywołujący może określić, że tylko podpis zostanie zweryfikowany, <xref:System.Security.Cryptography.X509Certificates.X509Chain> a następnie użyć obiektu do przeprowadzenia niestandardowej walidacji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Odwołanie o wartości null zostało przesłane do metody, która nie akceptuje jej jako prawidłowego argumentu.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Nie można ukończyć operacji kryptograficznej.</exception>
        <exception cref="T:System.InvalidOperationException">Wywołanie metody było nieprawidłowe dla bieżącego stanu obiektu.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ComputeCounterSignature">
      <AssemblyInfo>
        <AssemblyName>System.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy kontrpodpis i dodaje sygnaturę do wiadomości CMS/PKCS #7.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ComputeCounterSignature">
      <MemberSignature Language="C#" Value="public void ComputeCounterSignature ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ComputeCounterSignature() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Pkcs.SignerInfo.ComputeCounterSignature" />
      <MemberSignature Language="VB.NET" Value="Public Sub ComputeCounterSignature ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ComputeCounterSignature();" />
      <MemberSignature Language="F#" Value="member this.ComputeCounterSignature : unit -&gt; unit" Usage="signerInfo.ComputeCounterSignature " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Pkcs</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.1</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="dotnet-plat-ext-2.1;netcore-2.1;netcore-2.2;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="M:System.Security.Cryptography.Pkcs.SignerInfo.ComputeCounterSignature" /> Metoda monituje użytkownika o wybranie certyfikatu podpisywania, tworzy kontrpodpis i dodaje sygnaturę do wiadomości CMS/PKCS #7. Kontrasygnatur są ograniczone do jednego poziomu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta implementacja #7 CMS/PKCS obsługuje tylko jeden poziom kontrpodpis.  Oznacza to, że podpis może być podpisany, który tworzy element kontrpodpis, ale nie można ponownie podpisać kontrpodpis.  
  
 Ta metoda wyświetla interfejs użytkownika, w którym wybiera się osoby podpisujące dla tej wiadomości. Wymaga to, aby bieżący proces działał w *trybie interaktywnym użytkownika*, co oznacza, że <xref:System.Environment.UserInteractive%2A?displayProperty=nameWithType> właściwość jest ustawiona na `true`. Proces jest zwykle w trybie interaktywnym użytkownika, chyba że jest to proces usługi lub działa w aplikacji sieci Web.  
  
 Na liście zostaną wyświetlone osoby podpisujące, których certyfikaty spełniają następujące warunki:  
  
-   Z certyfikatem jest skojarzony klucz prywatny.  
  
-   Certyfikat jest w okresie ważności.  
  
-   Certyfikat nie zawiera klucza lub użycie klucza obsługującego podpisy cyfrowe lub wyuznawanie.  
  
 Certyfikaty osoby podpisującej są wybierane ze sklepu my.  
  
## <a name="net-framework-security"></a>Zabezpieczenia.NET Framework  
 Aby wyświetlić interfejs użytkownika, wymagane są następujące uprawnienia:  
  
-   <xref:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows?displayProperty=nameWithType>  
  
 Do uzyskania dostępu do klucza podpisu wymagane są następujące uprawnienia:  
  
-   <xref:System.Security.Permissions.KeyContainerPermissionFlags.Open?displayProperty=nameWithType>  
  
-   <xref:System.Security.Permissions.KeyContainerPermissionFlags.Sign?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Odwołanie o wartości null zostało przesłane do metody, która nie akceptuje jej jako prawidłowego argumentu.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Nie można ukończyć operacji kryptograficznej.</exception>
      </Docs>
    </Member>
    <Member MemberName="ComputeCounterSignature">
      <MemberSignature Language="C#" Value="public void ComputeCounterSignature (System.Security.Cryptography.Pkcs.CmsSigner signer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ComputeCounterSignature(class System.Security.Cryptography.Pkcs.CmsSigner signer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Pkcs.SignerInfo.ComputeCounterSignature(System.Security.Cryptography.Pkcs.CmsSigner)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ComputeCounterSignature (signer As CmsSigner)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ComputeCounterSignature(System::Security::Cryptography::Pkcs::CmsSigner ^ signer);" />
      <MemberSignature Language="F#" Value="member this.ComputeCounterSignature : System.Security.Cryptography.Pkcs.CmsSigner -&gt; unit" Usage="signerInfo.ComputeCounterSignature signer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Pkcs</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.1</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="signer" Type="System.Security.Cryptography.Pkcs.CmsSigner" />
      </Parameters>
      <Docs>
        <param name="signer"><see cref="T:System.Security.Cryptography.Pkcs.CmsSigner" /> Obiekt, który reprezentuje osoby podpisującej.</param>
        <summary><see cref="M:System.Security.Cryptography.Pkcs.SignerInfo.ComputeCounterSignature(System.Security.Cryptography.Pkcs.CmsSigner)" /> Metoda tworzy kontrpodpis przy użyciu określonej osoby podpisującej i dodaje sygnaturę do wiadomości CMS/PKCS #7. Kontrasygnatur są ograniczone do jednego poziomu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta implementacja #7 CMS/PKCS obsługuje tylko jeden poziom kontrpodpis.  Oznacza to, że podpis może być podpisany, który tworzy element kontrpodpis, ale nie można ponownie podpisać kontrpodpis.  
  
## <a name="net-framework-security"></a>Zabezpieczenia.NET Framework  
 Do uzyskania dostępu do klucza podpisu wymagane są następujące uprawnienia:  
  
-   <xref:System.Security.Permissions.KeyContainerPermissionFlags.Open?displayProperty=nameWithType>  
  
-   <xref:System.Security.Permissions.KeyContainerPermissionFlags.Sign?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Odwołanie o wartości null zostało przesłane do metody, która nie akceptuje jej jako prawidłowego argumentu.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Nie można ukończyć operacji kryptograficznej.</exception>
      </Docs>
    </Member>
    <Member MemberName="CounterSignerInfos">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.Pkcs.SignerInfoCollection CounterSignerInfos { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.Pkcs.SignerInfoCollection CounterSignerInfos" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.Pkcs.SignerInfo.CounterSignerInfos" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CounterSignerInfos As SignerInfoCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::Pkcs::SignerInfoCollection ^ CounterSignerInfos { System::Security::Cryptography::Pkcs::SignerInfoCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CounterSignerInfos : System.Security.Cryptography.Pkcs.SignerInfoCollection" Usage="System.Security.Cryptography.Pkcs.SignerInfo.CounterSignerInfos" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Pkcs</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.1</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.Pkcs.SignerInfoCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Security.Cryptography.Pkcs.SignerInfo.CounterSignerInfos" /> Właściwość pobiera zestaw podpisywania liczników skojarzonych z informacjami o logowaniu.</summary>
        <value><see cref="T:System.Security.Cryptography.Pkcs.SignerInfoCollection" /> Kolekcja, która reprezentuje osoby podpisujące dane osoby podpisującej. Jeśli nie ma żadnych podpisywania liczników, właściwość jest pustą kolekcją.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta implementacja #7 CMS/PKCS obsługuje tylko jeden poziom kontrpodpis. Oznacza to, że podpis może być podpisany, który tworzy element kontrpodpis, ale nie można ponownie podpisać kontrpodpis.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.Certificate" />
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.DigestAlgorithm" />
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.SignedAttributes" />
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.SignerIdentifier" />
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.UnsignedAttributes" />
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.Version" />
      </Docs>
    </Member>
    <Member MemberName="DigestAlgorithm">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.Oid DigestAlgorithm { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.Oid DigestAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.Pkcs.SignerInfo.DigestAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DigestAlgorithm As Oid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::Oid ^ DigestAlgorithm { System::Security::Cryptography::Oid ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DigestAlgorithm : System.Security.Cryptography.Oid" Usage="System.Security.Cryptography.Pkcs.SignerInfo.DigestAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Pkcs</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.1</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.Oid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Security.Cryptography.Pkcs.SignerInfo.DigestAlgorithm" /> Właściwość<see cref="T:System.Security.Cryptography.Oid" /> pobiera obiekt, który reprezentuje algorytm wyznaczania wartości skrótu używany w obliczeniach sygnatur.</summary>
        <value><see cref="T:System.Security.Cryptography.Oid" /> Obiekt, który reprezentuje algorytm wyznaczania wartości skrótu używany z podpisem.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.Certificate" />
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.CounterSignerInfos" />
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.SignedAttributes" />
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.SignerIdentifier" />
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.UnsignedAttributes" />
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.Version" />
      </Docs>
    </Member>
    <Member MemberName="GetSignature">
      <MemberSignature Language="C#" Value="public byte[] GetSignature ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetSignature() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Pkcs.SignerInfo.GetSignature" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSignature () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetSignature();" />
      <MemberSignature Language="F#" Value="member this.GetSignature : unit -&gt; byte[]" Usage="signerInfo.GetSignature " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Pkcs</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.1</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera sygnaturę dla bieżącego <see cref="T:System.Security.Cryptography.Pkcs.SignerInfo" /> obiektu.</summary>
        <returns>Podpis dla bieżącego <see cref="T:System.Security.Cryptography.Pkcs.SignerInfo" /> obiektu.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RemoveCounterSignature">
      <AssemblyInfo>
        <AssemblyName>System.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Usuwa określony kontrpodpis z <see cref="P:System.Security.Cryptography.Pkcs.SignerInfo.CounterSignerInfos" /> kolekcji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RemoveCounterSignature">
      <MemberSignature Language="C#" Value="public void RemoveCounterSignature (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveCounterSignature(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Pkcs.SignerInfo.RemoveCounterSignature(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveCounterSignature (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveCounterSignature(int index);" />
      <MemberSignature Language="F#" Value="member this.RemoveCounterSignature : int -&gt; unit" Usage="signerInfo.RemoveCounterSignature index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Pkcs</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.1</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Indeks (liczony od zera) kontrpodpis do usunięcia.</param>
        <summary>Metoda usuwa kontrpodpis o określonym indeksie <see cref="P:System.Security.Cryptography.Pkcs.SignerInfo.CounterSignerInfos" /> kolekcji. <see cref="M:System.Security.Cryptography.Pkcs.SignerInfo.RemoveCounterSignature(System.Int32)" /></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Nie można ukończyć operacji kryptograficznej.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveCounterSignature">
      <MemberSignature Language="C#" Value="public void RemoveCounterSignature (System.Security.Cryptography.Pkcs.SignerInfo counterSignerInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveCounterSignature(class System.Security.Cryptography.Pkcs.SignerInfo counterSignerInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Pkcs.SignerInfo.RemoveCounterSignature(System.Security.Cryptography.Pkcs.SignerInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveCounterSignature (counterSignerInfo As SignerInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveCounterSignature(System::Security::Cryptography::Pkcs::SignerInfo ^ counterSignerInfo);" />
      <MemberSignature Language="F#" Value="member this.RemoveCounterSignature : System.Security.Cryptography.Pkcs.SignerInfo -&gt; unit" Usage="signerInfo.RemoveCounterSignature counterSignerInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Pkcs</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.1</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="counterSignerInfo" Type="System.Security.Cryptography.Pkcs.SignerInfo" />
      </Parameters>
      <Docs>
        <param name="counterSignerInfo"><see cref="T:System.Security.Cryptography.Pkcs.SignerInfo" /> Obiekt, który reprezentuje kontrpodpis do usunięcia.</param>
        <summary>Metoda usuwa kontrpodpis dla określonego <see cref="T:System.Security.Cryptography.Pkcs.SignerInfo" /> obiektu. <see cref="M:System.Security.Cryptography.Pkcs.SignerInfo.RemoveCounterSignature(System.Security.Cryptography.Pkcs.SignerInfo)" /></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Odwołanie o wartości null zostało przesłane do metody, która nie akceptuje jej jako prawidłowego argumentu.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość argumentu jest poza dozwolonym zakresem wartości zdefiniowanym przez wywołaną metodę.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Nie można ukończyć operacji kryptograficznej.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveUnsignedAttribute">
      <MemberSignature Language="C#" Value="public void RemoveUnsignedAttribute (System.Security.Cryptography.AsnEncodedData asnEncodedData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveUnsignedAttribute(class System.Security.Cryptography.AsnEncodedData asnEncodedData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Pkcs.SignerInfo.RemoveUnsignedAttribute(System.Security.Cryptography.AsnEncodedData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveUnsignedAttribute(System::Security::Cryptography::AsnEncodedData ^ asnEncodedData);" />
      <MemberSignature Language="F#" Value="member this.RemoveUnsignedAttribute : System.Security.Cryptography.AsnEncodedData -&gt; unit" Usage="signerInfo.RemoveUnsignedAttribute asnEncodedData" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Pkcs</AssemblyName>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asnEncodedData" Type="System.Security.Cryptography.AsnEncodedData" Index="0" FrameworkAlternate="dotnet-plat-ext-3.0" />
      </Parameters>
      <Docs>
        <param name="asnEncodedData">Atrybut "ASN. 1" z kodowaniem do usunięcia z dokumentu.</param>
        <summary>Usuwa określony atrybut z bieżącego dokumentu.</summary>
        <remarks>  
          <format type="text/markdown"><![CDATA[  

Po usunięciu dokument zostanie po nim zakodowany.

         ]]></format>
         </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Nie można znaleźć oryginalnej osoby podpisującej.

 —lub—

Nie znaleziono atrybutu.

 —lub—
 
ASN1 uszkodzone dane.</exception>
      </Docs>
    </Member>
    <Member MemberName="SignatureAlgorithm">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.Oid SignatureAlgorithm { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.Oid SignatureAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.Pkcs.SignerInfo.SignatureAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SignatureAlgorithm As Oid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::Oid ^ SignatureAlgorithm { System::Security::Cryptography::Oid ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SignatureAlgorithm : System.Security.Cryptography.Oid" Usage="System.Security.Cryptography.Pkcs.SignerInfo.SignatureAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Pkcs</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.1</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.Oid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera identyfikator algorytmu podpisu używanego przez bieżący <see cref="T:System.Security.Cryptography.Pkcs.SignerInfo" /> obiekt.</summary>
        <value>Identyfikator algorytmu podpisu używany przez bieżący <see cref="T:System.Security.Cryptography.Pkcs.SignerInfo" /> obiekt.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SignedAttributes">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.CryptographicAttributeObjectCollection SignedAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.CryptographicAttributeObjectCollection SignedAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.Pkcs.SignerInfo.SignedAttributes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SignedAttributes As CryptographicAttributeObjectCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::CryptographicAttributeObjectCollection ^ SignedAttributes { System::Security::Cryptography::CryptographicAttributeObjectCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SignedAttributes : System.Security.Cryptography.CryptographicAttributeObjectCollection" Usage="System.Security.Cryptography.Pkcs.SignerInfo.SignedAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Pkcs</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.1</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.CryptographicAttributeObjectCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Security.Cryptography.Pkcs.SignerInfo.SignedAttributes" /> Właściwość<see cref="T:System.Security.Cryptography.CryptographicAttributeObjectCollection" /> Pobiera kolekcję podpisanych atrybutów, które są skojarzone z informacjami o logowaniu. Podpisane atrybuty są podpisane wraz z resztą zawartości komunikatu.</summary>
        <value><see cref="T:System.Security.Cryptography.CryptographicAttributeObjectCollection" /> Kolekcja, która reprezentuje podpisane atrybuty. Jeśli nie ma żadnych podpisanych atrybutów, właściwość jest pustą kolekcją.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przykładem podpisanego atrybutu, który może zostać uwzględniony w <xref:System.Security.Cryptography.CryptographicAttributeObjectCollection> kolekcji pobranej <xref:System.Security.Cryptography.Pkcs.SignerInfo.SignedAttributes%2A> przez właściwość, jest <xref:System.Security.Cryptography.Pkcs.Pkcs9SigningTime> atrybut czasu podpisania.  
  
 Podpisane atrybuty są podpisane wraz z resztą <xref:System.Security.Cryptography.Pkcs.SignedCms> zawartości komunikatu. Oznacza to, że strona, która pomyślnie weryfikuje sygnaturę, może mieć pewność, że zawartość tych atrybutów jest autentyczna i nie została zmieniona.  
  
 Obiekt i obiekt zostanie automatycznie <xref:System.Security.Cryptography.Pkcs.SignerInfo.SignedAttributes%2A> wygenerowany i umieszczony we właściwości za każdym razem, <xref:System.Security.Cryptography.Pkcs.CmsSigner.SignedAttributes%2A?displayProperty=nameWithType> gdy właściwość odpowiadającego podpisu nie jest pusta. <xref:System.Security.Cryptography.Pkcs.Pkcs9MessageDigest> <xref:System.Security.Cryptography.Pkcs.Pkcs9ContentType>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.Certificate" />
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.CounterSignerInfos" />
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.DigestAlgorithm" />
        <altmember cref="T:System.Security.Cryptography.Pkcs.Pkcs9SigningTime" />
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.SignerIdentifier" />
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.UnsignedAttributes" />
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.Version" />
      </Docs>
    </Member>
    <Member MemberName="SignerIdentifier">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.Pkcs.SubjectIdentifier SignerIdentifier { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.Pkcs.SubjectIdentifier SignerIdentifier" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.Pkcs.SignerInfo.SignerIdentifier" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SignerIdentifier As SubjectIdentifier" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::Pkcs::SubjectIdentifier ^ SignerIdentifier { System::Security::Cryptography::Pkcs::SubjectIdentifier ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SignerIdentifier : System.Security.Cryptography.Pkcs.SubjectIdentifier" Usage="System.Security.Cryptography.Pkcs.SignerInfo.SignerIdentifier" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Pkcs</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.1</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.Pkcs.SubjectIdentifier</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Security.Cryptography.Pkcs.SignerInfo.SignerIdentifier" /> Właściwość pobiera identyfikator certyfikatu osoby podpisującej skojarzonej z informacjami o logowaniu.</summary>
        <value><see cref="T:System.Security.Cryptography.Pkcs.SubjectIdentifier" /> Obiekt, który jednoznacznie identyfikuje certyfikat skojarzony z informacjami o logowaniu.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.Certificate" />
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.CounterSignerInfos" />
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.DigestAlgorithm" />
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.SignedAttributes" />
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.UnsignedAttributes" />
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.Version" />
      </Docs>
    </Member>
    <Member MemberName="UnsignedAttributes">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.CryptographicAttributeObjectCollection UnsignedAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.CryptographicAttributeObjectCollection UnsignedAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.Pkcs.SignerInfo.UnsignedAttributes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UnsignedAttributes As CryptographicAttributeObjectCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::CryptographicAttributeObjectCollection ^ UnsignedAttributes { System::Security::Cryptography::CryptographicAttributeObjectCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UnsignedAttributes : System.Security.Cryptography.CryptographicAttributeObjectCollection" Usage="System.Security.Cryptography.Pkcs.SignerInfo.UnsignedAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Pkcs</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.1</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.CryptographicAttributeObjectCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Właściwość pobiera kolekcję niepodpisanych atrybutów, które są skojarzone z <see cref="T:System.Security.Cryptography.Pkcs.SignerInfo" /> zawartością. <see cref="T:System.Security.Cryptography.CryptographicAttributeObjectCollection" /> <see cref="P:System.Security.Cryptography.Pkcs.SignerInfo.UnsignedAttributes" /> Niepodpisane atrybuty można modyfikować bez unieważniania podpisu.</summary>
        <value><see cref="T:System.Security.Cryptography.CryptographicAttributeObjectCollection" /> Kolekcja, która reprezentuje niepodpisane atrybuty. Jeśli nie ma żadnych niepodpisanych atrybutów, właściwość jest pustą kolekcją.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niepodpisane atrybuty nie są podpisane wraz z resztą <xref:System.Security.Cryptography.Pkcs.SignedCms> zawartości komunikatu. Mimo że strona pomyślnie weryfikuje podpis, atrybuty bez znaku mogły zostać zmienione i nie powinny być uważane za posiadające autentyczność lub integralność.  
  
 Przykładem niepodpisanego atrybutu, który może zostać uwzględniony <xref:System.Security.Cryptography.CryptographicAttributeObjectCollection> w kolekcji pobranej <xref:System.Security.Cryptography.Pkcs.SignerInfo.UnsignedAttributes%2A> przez właściwość, jest kontrpodpis.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.Certificate" />
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.CounterSignerInfos" />
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.DigestAlgorithm" />
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.SignedAttributes" />
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.SignerIdentifier" />
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.Version" />
      </Docs>
    </Member>
    <Member MemberName="Version">
      <MemberSignature Language="C#" Value="public int Version { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Version" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.Pkcs.SignerInfo.Version" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Version As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Version { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Version : int" Usage="System.Security.Cryptography.Pkcs.SignerInfo.Version" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Pkcs</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.1</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Security.Cryptography.Pkcs.SignerInfo.Version" /> Właściwość pobiera wersję informacji o podpisującej.</summary>
        <value>Wartość int, która określa wersję informacji osoby podpisującej.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wersja określa, czy wiadomość jest wiadomością PKCS #7, czy komunikatem o składni wiadomości kryptograficznych (CMS). CMS to nowszy nadzbiór #7 PKCS.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.Certificate" />
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.CounterSignerInfos" />
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.DigestAlgorithm" />
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.SignedAttributes" />
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.SignerIdentifier" />
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.UnsignedAttributes" />
      </Docs>
    </Member>
  </Members>
</Type>

<Type Name="SignerInfo" FullName="System.Security.Cryptography.Pkcs.SignerInfo">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c153a1aaa05190173e6e100157b88389d76369e0" />
    <Meta Name="ms.sourcegitcommit" Value="d877ae76e9e11799bf919379507239e2c4072742" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="08/09/2018" />
    <Meta Name="ms.locfileid" Value="39955613" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class SignerInfo" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit SignerInfo extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Security.Cryptography.Pkcs.SignerInfo" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class SignerInfo" />
  <TypeSignature Language="C++ CLI" Value="public ref class SignerInfo sealed" />
  <TypeSignature Language="F#" Value="type SignerInfo = class" />
  <AssemblyInfo>
    <AssemblyName>System.Security</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <see cref="T:System.Security.Cryptography.Pkcs.SignerInfo" /> Klasa reprezentuje podpis, skojarzone z <see cref="T:System.Security.Cryptography.Pkcs.SignedCms" /> obiekt, który reprezentuje komunikat CMS/PKCS #7.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podpisy reprezentowany przez <xref:System.Security.Cryptography.Pkcs.SignerInfo> klasa może być albo za pośrednictwem zawartości wiadomości lub podpisu. Ostatni typ podpisu jest określany jako *kontrasygnaturze*.  
  
 Ta implementacja CMS/PKCS #7 obsługuje tylko jeden poziom kontrasygnaturze.  Oznacza to, że sygnatury może być podpisana, która stanowi kontrasygnaturze, ale nie można ponownie podpisać tym kontrasygnaturze.  
  
 Ta klasa nie ma on publicznego konstruktora; w związku z tym go nie może być publicznie tworzone. Jest dostępna z klasy tylko do odczytu <xref:System.Security.Cryptography.Pkcs.SignedCms.SignerInfos%2A?displayProperty=nameWithType> właściwości.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Certificate">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.X509Certificates.X509Certificate2 Certificate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.X509Certificates.X509Certificate2 Certificate" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.Pkcs.SignerInfo.Certificate" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Certificate As X509Certificate2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::X509Certificates::X509Certificate2 ^ Certificate { System::Security::Cryptography::X509Certificates::X509Certificate2 ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Certificate : System.Security.Cryptography.X509Certificates.X509Certificate2" Usage="System.Security.Cryptography.Pkcs.SignerInfo.Certificate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509Certificate2</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Security.Cryptography.Pkcs.SignerInfo.Certificate" /> Właściwość pobiera certyfikat podpisywania, skojarzony z informacjami osoby podpisującej.</summary>
        <value>
          <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> Obiekt, który reprezentuje certyfikatu podpisywania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli certyfikat podpisywania nie jest dołączony podczas podpisywania czasu za pomocą <xref:System.Security.Cryptography.Pkcs.CmsSigner.IncludeOption%2A?displayProperty=nameWithType> właściwości, a następnie certyfikat nie zostanie zwrócona.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.CounterSignerInfos" />
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.DigestAlgorithm" />
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.SignedAttributes" />
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.SignerIdentifier" />
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.UnsignedAttributes" />
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.Version" />
      </Docs>
    </Member>
    <Member MemberName="CheckHash">
      <MemberSignature Language="C#" Value="public void CheckHash ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CheckHash() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Pkcs.SignerInfo.CheckHash" />
      <MemberSignature Language="VB.NET" Value="Public Sub CheckHash ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CheckHash();" />
      <MemberSignature Language="F#" Value="member this.CheckHash : unit -&gt; unit" Usage="signerInfo.CheckHash " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="M:System.Security.Cryptography.Pkcs.SignerInfo.CheckHash" /> Metoda sprawdza integralność danych w przypadku informacji osoby podpisującej wiadomości CMS/PKCS #7. <see cref="M:System.Security.Cryptography.Pkcs.SignerInfo.CheckHash" /> jest metodą wyspecjalizowane używanych w aplikacjach infrastruktury zabezpieczeń, w których podmiot używa **HashOnly** członkiem <see cref="T:System.Security.Cryptography.Pkcs.SubjectIdentifierType" /> wyliczenie podczas konfigurowania <see cref="T:System.Security.Cryptography.Pkcs.CmsSigner" /> obiektu. <see cref="M:System.Security.Cryptography.Pkcs.SignerInfo.CheckHash" /> informacje podpisujący nie uwierzytelnić, ponieważ ta metoda nie wiąże się weryfikowanie podpisu cyfrowego. Ogólnego przeznaczenia sprawdzania integralności i autentyczności CMS/PKCS #7 komunikat osoby podpisującej informacji i kontrasygnatur, użyj <see cref="M:System.Security.Cryptography.Pkcs.SignerInfo.CheckSignature(System.Boolean)" /> lub <see cref="M:System.Security.Cryptography.Pkcs.SignerInfo.CheckSignature(System.Security.Cryptography.X509Certificates.X509Certificate2Collection,System.Boolean)" /> metody.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie zapewnia uwierzytelniania informacje osoby podpisującej komunikatu CMS/PKCS #7.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Nie można ukończyć operacji kryptograficznych.</exception>
        <altmember cref="T:System.Security.Cryptography.Pkcs.CmsSigner" />
        <altmember cref="M:System.Security.Cryptography.Pkcs.SignedCms.CheckHash" />
        <altmember cref="T:System.Security.Cryptography.Pkcs.SubjectIdentifierType" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CheckSignature">
      <AssemblyInfo>
        <AssemblyName>System.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Weryfikuje podpis cyfrowy wiadomości.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CheckSignature">
      <MemberSignature Language="C#" Value="public void CheckSignature (bool verifySignatureOnly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CheckSignature(bool verifySignatureOnly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Pkcs.SignerInfo.CheckSignature(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CheckSignature (verifySignatureOnly As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CheckSignature(bool verifySignatureOnly);" />
      <MemberSignature Language="F#" Value="member this.CheckSignature : bool -&gt; unit" Usage="signerInfo.CheckSignature verifySignatureOnly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="verifySignatureOnly" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="verifySignatureOnly">Wartość logiczna określająca, czy podpis cyfrowy jest weryfikowany. Jeśli <c>verifySignatureOnly</c> jest <see langword="true" />, tylko podpis jest weryfikowany. Jeśli <c>verifySignatureOnly</c> jest <see langword="false" />, podpis cyfrowy jest weryfikowany, sprawdzania poprawności łańcucha certyfikatu i celów certyfikaty są weryfikowane. Cele tego certyfikatu są traktowane jako prawidłowe, jeśli certyfikat nie ma żadnego użycia klucza, lub jeśli użycie klucza obsługuje podpisu cyfrowego lub niemożność wyparcia.</param>
        <summary>
          <see cref="M:System.Security.Cryptography.Pkcs.SignerInfo.CheckSignature(System.Boolean)" /> Metoda weryfikuje podpis cyfrowy wiadomości i, opcjonalnie, weryfikuje certyfikat.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zgłasza wyjątek, jeśli Weryfikacja podpisu cyfrowego zakończy się niepowodzeniem lub nie są spełnione wszystkie wymagania weryfikacji.  
  
 Jeśli wymagane jest bardziej złożoną walidację, obiekt wywołujący można określić, że tylko podpis jest weryfikowany, a następnie użyj <xref:System.Security.Cryptography.X509Certificates.X509Chain> obiektu w celu wykonania niestandardowego sprawdzania poprawności.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Odwołanie o wartości null został przekazany do metody, które nie akceptują jako nieprawidłowy argument.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Nie można ukończyć operacji kryptograficznych.</exception>
        <exception cref="T:System.InvalidOperationException">Wywołanie metody jest nieprawidłowa dla bieżącego stanu obiektu.</exception>
      </Docs>
    </Member>
    <Member MemberName="CheckSignature">
      <MemberSignature Language="C#" Value="public void CheckSignature (System.Security.Cryptography.X509Certificates.X509Certificate2Collection extraStore, bool verifySignatureOnly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CheckSignature(class System.Security.Cryptography.X509Certificates.X509Certificate2Collection extraStore, bool verifySignatureOnly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Pkcs.SignerInfo.CheckSignature(System.Security.Cryptography.X509Certificates.X509Certificate2Collection,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CheckSignature (extraStore As X509Certificate2Collection, verifySignatureOnly As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CheckSignature(System::Security::Cryptography::X509Certificates::X509Certificate2Collection ^ extraStore, bool verifySignatureOnly);" />
      <MemberSignature Language="F#" Value="member this.CheckSignature : System.Security.Cryptography.X509Certificates.X509Certificate2Collection * bool -&gt; unit" Usage="signerInfo.CheckSignature (extraStore, verifySignatureOnly)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="extraStore" Type="System.Security.Cryptography.X509Certificates.X509Certificate2Collection" />
        <Parameter Name="verifySignatureOnly" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="extraStore">
          <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2Collection" /> Obiektu, który może służyć do sprawdzania poprawności łańcucha. Jeśli żadnych dodatkowych certyfikatów, które mają być używane do sprawdzania poprawności łańcucha, użyj <see cref="M:System.Security.Cryptography.Pkcs.SignerInfo.CheckSignature(System.Boolean)" /> zamiast <see cref="M:System.Security.Cryptography.Pkcs.SignerInfo.CheckSignature(System.Security.Cryptography.X509Certificates.X509Certificate2Collection,System.Boolean)" />.</param>
        <param name="verifySignatureOnly">Wartość logiczna określająca, czy podpis cyfrowy jest weryfikowany. Jeśli <c>verifySignatureOnly</c> jest <see langword="true" />, tylko podpis jest weryfikowany. Jeśli <c>verifySignatureOnly</c> jest <see langword="false" />, podpis cyfrowy jest weryfikowany, sprawdzania poprawności łańcucha certyfikatu i celów certyfikaty są weryfikowane. Cele tego certyfikatu są traktowane jako prawidłowe, jeśli certyfikat nie ma żadnego użycia klucza, lub jeśli użycie klucza obsługuje podpisu cyfrowego lub niemożność wyparcia.</param>
        <summary>
          <see cref="M:System.Security.Cryptography.Pkcs.SignerInfo.CheckSignature(System.Security.Cryptography.X509Certificates.X509Certificate2Collection,System.Boolean)" /> Metoda weryfikuje podpis cyfrowy wiadomości przy użyciu określonej kolekcji certyfikatów i, opcjonalnie, weryfikuje certyfikat.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zgłasza wyjątek, jeśli Weryfikacja podpisu cyfrowego zakończy się niepowodzeniem lub nie są spełnione wszystkie wymagania weryfikacji.  
  
 Jeśli wymagane jest bardziej złożoną walidację, obiekt wywołujący można określić, że tylko podpis jest weryfikowany, a następnie użyj <xref:System.Security.Cryptography.X509Certificates.X509Chain> obiektu w celu wykonania niestandardowego sprawdzania poprawności.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Odwołanie o wartości null został przekazany do metody, które nie akceptują jako nieprawidłowy argument.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Nie można ukończyć operacji kryptograficznych.</exception>
        <exception cref="T:System.InvalidOperationException">Wywołanie metody jest nieprawidłowa dla bieżącego stanu obiektu.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ComputeCounterSignature">
      <AssemblyInfo>
        <AssemblyName>System.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy kontrasygnaturze i dodaje podpis wiadomość CMS/PKCS #7.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ComputeCounterSignature">
      <MemberSignature Language="C#" Value="public void ComputeCounterSignature ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ComputeCounterSignature() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Pkcs.SignerInfo.ComputeCounterSignature" />
      <MemberSignature Language="VB.NET" Value="Public Sub ComputeCounterSignature ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ComputeCounterSignature();" />
      <MemberSignature Language="F#" Value="member this.ComputeCounterSignature : unit -&gt; unit" Usage="signerInfo.ComputeCounterSignature " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="M:System.Security.Cryptography.Pkcs.SignerInfo.ComputeCounterSignature" /> Metoda monituje użytkownika o wybranie certyfikatu podpisywania, tworzy kontrasygnaturze i dodaje podpisu do komunikatu CMS/PKCS #7. Kontrasygnatur są ograniczone do jednego poziomu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta implementacja CMS/PKCS #7 obsługuje tylko jeden poziom kontrasygnaturze.  Oznacza to, że sygnatury może być podpisana, która stanowi kontrasygnaturze, ale nie można ponownie podpisać tym kontrasygnaturze.  
  
 Ta metoda Wy wyświetla interfejsu użytkownika, w którym możesz wybrać które podpisały dla tego komunikatu. Wymaga to, czy bieżący proces jest uruchomiony *tryb interakcyjny użytkownika*, co oznacza że <xref:System.Environment.UserInteractive%2A?displayProperty=nameWithType> właściwość jest ustawiona na `true`. Proces jest zwykle w trybie interaktywnym użytkownika, o ile nie jest uruchomiona wewnątrz aplikacji sieci Web lub procesu usługi.  
  
 Które podpisały, których certyfikaty spełniać następujące warunki będą wyświetlane na liście:  
  
-   Certyfikat ma skojarzony klucz prywatny.  
  
-   Certyfikat jest okresem ważności.  
  
-   Certyfikat ma nie użycia klucza lub użycie klucza obsługującego podpisów cyfrowych lub niemożność wyparcia.  
  
 Podpisujący certyfikaty są wybierane w magazynie użytkownika.  
  
## <a name="net-framework-security"></a>Zabezpieczenia.NET Framework  
 Następujące uprawnienia są wymagane do wyświetlania interfejsu użytkownika:  
  
-   <xref:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows?displayProperty=nameWithType>  
  
 Następujące uprawnienia są wymagane do uzyskania dostępu do klucza podpisu:  
  
-   <xref:System.Security.Permissions.KeyContainerPermissionFlags.Open?displayProperty=nameWithType>  
  
-   <xref:System.Security.Permissions.KeyContainerPermissionFlags.Sign?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Odwołanie o wartości null został przekazany do metody, które nie akceptują jako nieprawidłowy argument.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Nie można ukończyć operacji kryptograficznych.</exception>
      </Docs>
    </Member>
    <Member MemberName="ComputeCounterSignature">
      <MemberSignature Language="C#" Value="public void ComputeCounterSignature (System.Security.Cryptography.Pkcs.CmsSigner signer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ComputeCounterSignature(class System.Security.Cryptography.Pkcs.CmsSigner signer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Pkcs.SignerInfo.ComputeCounterSignature(System.Security.Cryptography.Pkcs.CmsSigner)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ComputeCounterSignature (signer As CmsSigner)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ComputeCounterSignature(System::Security::Cryptography::Pkcs::CmsSigner ^ signer);" />
      <MemberSignature Language="F#" Value="member this.ComputeCounterSignature : System.Security.Cryptography.Pkcs.CmsSigner -&gt; unit" Usage="signerInfo.ComputeCounterSignature signer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="signer" Type="System.Security.Cryptography.Pkcs.CmsSigner" />
      </Parameters>
      <Docs>
        <param name="signer">A <see cref="T:System.Security.Cryptography.Pkcs.CmsSigner" /> obiekt, który reprezentuje podpis licznika.</param>
        <summary>
          <see cref="M:System.Security.Cryptography.Pkcs.SignerInfo.ComputeCounterSignature(System.Security.Cryptography.Pkcs.CmsSigner)" /> Metoda tworzy kontrasygnaturze przy użyciu określonej osoby podpisującej i dodaje podpisu do komunikatu CMS/PKCS #7. Kontrasygnatur są ograniczone do jednego poziomu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta implementacja CMS/PKCS #7 obsługuje tylko jeden poziom kontrasygnaturze.  Oznacza to, że sygnatury może być podpisana, która stanowi kontrasygnaturze, ale nie można ponownie podpisać tym kontrasygnaturze.  
  
## <a name="net-framework-security"></a>Zabezpieczenia.NET Framework  
 Następujące uprawnienia są wymagane do uzyskania dostępu do klucza podpisu:  
  
-   <xref:System.Security.Permissions.KeyContainerPermissionFlags.Open?displayProperty=nameWithType>  
  
-   <xref:System.Security.Permissions.KeyContainerPermissionFlags.Sign?displayProperty=nameWithType>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Odwołanie o wartości null został przekazany do metody, które nie akceptują jako nieprawidłowy argument.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Nie można ukończyć operacji kryptograficznych.</exception>
      </Docs>
    </Member>
    <Member MemberName="CounterSignerInfos">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.Pkcs.SignerInfoCollection CounterSignerInfos { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.Pkcs.SignerInfoCollection CounterSignerInfos" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.Pkcs.SignerInfo.CounterSignerInfos" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CounterSignerInfos As SignerInfoCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::Pkcs::SignerInfoCollection ^ CounterSignerInfos { System::Security::Cryptography::Pkcs::SignerInfoCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CounterSignerInfos : System.Security.Cryptography.Pkcs.SignerInfoCollection" Usage="System.Security.Cryptography.Pkcs.SignerInfo.CounterSignerInfos" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.Pkcs.SignerInfoCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Security.Cryptography.Pkcs.SignerInfo.CounterSignerInfos" /> Właściwość pobiera zbiór które podpisały licznik skojarzony z informacjami osoby podpisującej.</summary>
        <value>A <see cref="T:System.Security.Cryptography.Pkcs.SignerInfoCollection" /> kolekcję, która reprezentuje które podpisały licznika informacji osoby podpisującej. W przypadku nie które podpisały liczników właściwość jest pusta kolekcja.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta implementacja CMS/PKCS #7 obsługuje tylko jeden poziom kontrasygnaturze. Oznacza to, że sygnatury może być podpisana, która stanowi kontrasygnaturze, ale nie można ponownie podpisać tym kontrasygnaturze.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.Certificate" />
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.DigestAlgorithm" />
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.SignedAttributes" />
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.SignerIdentifier" />
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.UnsignedAttributes" />
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.Version" />
      </Docs>
    </Member>
    <Member MemberName="DigestAlgorithm">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.Oid DigestAlgorithm { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.Oid DigestAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.Pkcs.SignerInfo.DigestAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DigestAlgorithm As Oid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::Oid ^ DigestAlgorithm { System::Security::Cryptography::Oid ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DigestAlgorithm : System.Security.Cryptography.Oid" Usage="System.Security.Cryptography.Pkcs.SignerInfo.DigestAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.Oid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Security.Cryptography.Pkcs.SignerInfo.DigestAlgorithm" /> Pobiera właściwość <see cref="T:System.Security.Cryptography.Oid" /> obiekt, który reprezentuje algorytm wyznaczania wartości skrótu używany w obliczeniach sygnatur.</summary>
        <value>
          <see cref="T:System.Security.Cryptography.Oid" /> Obiekt, który reprezentuje algorytm wyznaczania wartości skrótu używany z podpisem.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.Certificate" />
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.CounterSignerInfos" />
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.SignedAttributes" />
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.SignerIdentifier" />
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.UnsignedAttributes" />
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.Version" />
      </Docs>
    </Member>
    <Member MemberName="GetSignature">
      <MemberSignature Language="C#" Value="public byte[] GetSignature ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetSignature() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Pkcs.SignerInfo.GetSignature" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSignature () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetSignature();" />
      <MemberSignature Language="F#" Value="member this.GetSignature : unit -&gt; byte[]" Usage="signerInfo.GetSignature " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera podpisu dla bieżącego <see cref="T:System.Security.Cryptography.Pkcs.SignerInfo" /> obiektu.</summary>
        <returns>Podpis dla bieżącego <see cref="T:System.Security.Cryptography.Pkcs.SignerInfo" /> obiektu.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RemoveCounterSignature">
      <AssemblyInfo>
        <AssemblyName>System.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Usuwa określony kontrasygnaturze z <see cref="P:System.Security.Cryptography.Pkcs.SignerInfo.CounterSignerInfos" /> kolekcji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RemoveCounterSignature">
      <MemberSignature Language="C#" Value="public void RemoveCounterSignature (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveCounterSignature(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Pkcs.SignerInfo.RemoveCounterSignature(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveCounterSignature (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveCounterSignature(int index);" />
      <MemberSignature Language="F#" Value="member this.RemoveCounterSignature : int -&gt; unit" Usage="signerInfo.RemoveCounterSignature index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Liczony od zera indeks kontrasygnaturze do usunięcia.</param>
        <summary>
          <see cref="M:System.Security.Cryptography.Pkcs.SignerInfo.RemoveCounterSignature(System.Int32)" /> Metoda usuwa kontrasygnaturze w określonym indeksie <see cref="P:System.Security.Cryptography.Pkcs.SignerInfo.CounterSignerInfos" /> kolekcji.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Nie można ukończyć operacji kryptograficznych.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveCounterSignature">
      <MemberSignature Language="C#" Value="public void RemoveCounterSignature (System.Security.Cryptography.Pkcs.SignerInfo counterSignerInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveCounterSignature(class System.Security.Cryptography.Pkcs.SignerInfo counterSignerInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Pkcs.SignerInfo.RemoveCounterSignature(System.Security.Cryptography.Pkcs.SignerInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveCounterSignature (counterSignerInfo As SignerInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveCounterSignature(System::Security::Cryptography::Pkcs::SignerInfo ^ counterSignerInfo);" />
      <MemberSignature Language="F#" Value="member this.RemoveCounterSignature : System.Security.Cryptography.Pkcs.SignerInfo -&gt; unit" Usage="signerInfo.RemoveCounterSignature counterSignerInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="counterSignerInfo" Type="System.Security.Cryptography.Pkcs.SignerInfo" />
      </Parameters>
      <Docs>
        <param name="counterSignerInfo">A <see cref="T:System.Security.Cryptography.Pkcs.SignerInfo" /> obiekt, który reprezentuje kontrasygnaturze usuwany.</param>
        <summary>
          <see cref="M:System.Security.Cryptography.Pkcs.SignerInfo.RemoveCounterSignature(System.Security.Cryptography.Pkcs.SignerInfo)" /> Metoda usuwa kontrasygnaturze dla określonego <see cref="T:System.Security.Cryptography.Pkcs.SignerInfo" /> obiektu.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Odwołanie o wartości null został przekazany do metody, które nie akceptują jako nieprawidłowy argument.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość argumentu był poza dozwolonym zakresem wartości zgodnie z definicją wywoływanej metody.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Nie można ukończyć operacji kryptograficznych.</exception>
      </Docs>
    </Member>
    <Member MemberName="SignatureAlgorithm">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.Oid SignatureAlgorithm { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.Oid SignatureAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.Pkcs.SignerInfo.SignatureAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SignatureAlgorithm As Oid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::Oid ^ SignatureAlgorithm { System::Security::Cryptography::Oid ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SignatureAlgorithm : System.Security.Cryptography.Oid" Usage="System.Security.Cryptography.Pkcs.SignerInfo.SignatureAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.Oid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera identyfikator algorytmu podpisu używane przez bieżące <see cref="T:System.Security.Cryptography.Pkcs.SignerInfo" /> obiektu.</summary>
        <value>Identyfikator algorytmu podpisu używane przez bieżące <see cref="T:System.Security.Cryptography.Pkcs.SignerInfo" /> obiektu.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SignedAttributes">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.CryptographicAttributeObjectCollection SignedAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.CryptographicAttributeObjectCollection SignedAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.Pkcs.SignerInfo.SignedAttributes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SignedAttributes As CryptographicAttributeObjectCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::CryptographicAttributeObjectCollection ^ SignedAttributes { System::Security::Cryptography::CryptographicAttributeObjectCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SignedAttributes : System.Security.Cryptography.CryptographicAttributeObjectCollection" Usage="System.Security.Cryptography.Pkcs.SignerInfo.SignedAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.CryptographicAttributeObjectCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Security.Cryptography.Pkcs.SignerInfo.SignedAttributes" /> Pobiera właściwość <see cref="T:System.Security.Cryptography.CryptographicAttributeObjectCollection" /> kolekcję atrybutów podpisem, który jest skojarzony z informacjami o osoby podpisującej. Atrybuty podpisem zalogowano się wraz z pozostałej części treści wiadomości.</summary>
        <value>A <see cref="T:System.Security.Cryptography.CryptographicAttributeObjectCollection" /> kolekcję, która reprezentuje podpisaną atrybutów. Jeśli nie istnieją żadne atrybuty podpisem, właściwość jest pusta kolekcja.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przykładem podpisem atrybut, który mógłby być zawarty w <xref:System.Security.Cryptography.CryptographicAttributeObjectCollection> kolekcji pobierane przez <xref:System.Security.Cryptography.Pkcs.SignerInfo.SignedAttributes%2A> właściwość <xref:System.Security.Cryptography.Pkcs.Pkcs9SigningTime> podpisywania atrybutu czasu.  
  
 Atrybuty podpisem są podpisane i resztę <xref:System.Security.Cryptography.Pkcs.SignedCms> zawartości komunikatu. Oznacza to, że innych firm, które pomyślnie weryfikuje podpis mogą mieć pewność, że zawartość te atrybuty są autentyczne i nie została zmieniona.  
  
 A <xref:System.Security.Cryptography.Pkcs.Pkcs9ContentType> obiektu i <xref:System.Security.Cryptography.Pkcs.Pkcs9MessageDigest> obiekt zostanie automatycznie wygenerowany i umieszczane w <xref:System.Security.Cryptography.Pkcs.SignerInfo.SignedAttributes%2A> właściwość zawsze wtedy, gdy <xref:System.Security.Cryptography.Pkcs.CmsSigner.SignedAttributes%2A?displayProperty=nameWithType> właściwość odpowiednie osoby podpisującej nie jest pusty.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.Certificate" />
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.CounterSignerInfos" />
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.DigestAlgorithm" />
        <altmember cref="T:System.Security.Cryptography.Pkcs.Pkcs9SigningTime" />
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.SignerIdentifier" />
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.UnsignedAttributes" />
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.Version" />
      </Docs>
    </Member>
    <Member MemberName="SignerIdentifier">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.Pkcs.SubjectIdentifier SignerIdentifier { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.Pkcs.SubjectIdentifier SignerIdentifier" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.Pkcs.SignerInfo.SignerIdentifier" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SignerIdentifier As SubjectIdentifier" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::Pkcs::SubjectIdentifier ^ SignerIdentifier { System::Security::Cryptography::Pkcs::SubjectIdentifier ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SignerIdentifier : System.Security.Cryptography.Pkcs.SubjectIdentifier" Usage="System.Security.Cryptography.Pkcs.SignerInfo.SignerIdentifier" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.Pkcs.SubjectIdentifier</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Security.Cryptography.Pkcs.SignerInfo.SignerIdentifier" /> Właściwość pobiera identyfikator certyfikatu osoby podpisującej skojarzony z informacjami osoby podpisującej.</summary>
        <value>A <see cref="T:System.Security.Cryptography.Pkcs.SubjectIdentifier" /> obiekt, który unikatowo identyfikuje certyfikat skojarzony z informacjami osoby podpisującej.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.Certificate" />
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.CounterSignerInfos" />
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.DigestAlgorithm" />
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.SignedAttributes" />
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.UnsignedAttributes" />
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.Version" />
      </Docs>
    </Member>
    <Member MemberName="UnsignedAttributes">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.CryptographicAttributeObjectCollection UnsignedAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.CryptographicAttributeObjectCollection UnsignedAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.Pkcs.SignerInfo.UnsignedAttributes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UnsignedAttributes As CryptographicAttributeObjectCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::CryptographicAttributeObjectCollection ^ UnsignedAttributes { System::Security::Cryptography::CryptographicAttributeObjectCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UnsignedAttributes : System.Security.Cryptography.CryptographicAttributeObjectCollection" Usage="System.Security.Cryptography.Pkcs.SignerInfo.UnsignedAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.CryptographicAttributeObjectCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Security.Cryptography.Pkcs.SignerInfo.UnsignedAttributes" /> Pobiera właściwość <see cref="T:System.Security.Cryptography.CryptographicAttributeObjectCollection" /> kolekcji atrybutów bez znaku, które jest skojarzone z <see cref="T:System.Security.Cryptography.Pkcs.SignerInfo" /> zawartości. Atrybuty bez znaku, można zmodyfikować bez unieważnienia podpisu.</summary>
        <value>A <see cref="T:System.Security.Cryptography.CryptographicAttributeObjectCollection" /> kolekcji, która reprezentuje atrybuty bez znaku. Jeśli nie istnieją żadne atrybuty bez znaku, właściwość jest pusta kolekcja.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Atrybuty bez znaku nie są podpisane i resztę <xref:System.Security.Cryptography.Pkcs.SignedCms> zawartości komunikatu. Mimo że strona pomyślnie weryfikuje podpis, niepodpisane atrybuty został zmieniony i nie powinny być traktowane autentyczności lub integralności.  
  
 Przykład niepodpisane atrybut, który mógłby być zawarty w <xref:System.Security.Cryptography.CryptographicAttributeObjectCollection> kolekcji pobierane przez <xref:System.Security.Cryptography.Pkcs.SignerInfo.UnsignedAttributes%2A> właściwość jest kontrasygnaturze.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.Certificate" />
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.CounterSignerInfos" />
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.DigestAlgorithm" />
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.SignedAttributes" />
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.SignerIdentifier" />
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.Version" />
      </Docs>
    </Member>
    <Member MemberName="Version">
      <MemberSignature Language="C#" Value="public int Version { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Version" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.Pkcs.SignerInfo.Version" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Version As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Version { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Version : int" Usage="System.Security.Cryptography.Pkcs.SignerInfo.Version" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="P:System.Security.Cryptography.Pkcs.SignerInfo.Version" /> Właściwość pobiera jest wersja informacji osoby podpisującej.</summary>
        <value>Wartość int, która określa wersję informacji osoby podpisującej.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wersja Określa, czy komunikat jest komunikatu PKCS #7 lub komunikatu składni wiadomości kryptograficznych (CMS). System CMS to nadzbiór nowszej PKCS #7.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.Certificate" />
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.CounterSignerInfos" />
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.DigestAlgorithm" />
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.SignedAttributes" />
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.SignerIdentifier" />
        <altmember cref="P:System.Security.Cryptography.Pkcs.SignerInfo.UnsignedAttributes" />
      </Docs>
    </Member>
  </Members>
</Type>
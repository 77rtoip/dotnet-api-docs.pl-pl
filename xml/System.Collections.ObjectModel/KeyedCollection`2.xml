<Type Name="KeyedCollection&lt;TKey,TItem&gt;" FullName="System.Collections.ObjectModel.KeyedCollection&lt;TKey,TItem&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="3375080ab008f35379a851d18f700db732edfd23" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30440778" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class KeyedCollection&lt;TKey,TItem&gt; : System.Collections.ObjectModel.Collection&lt;TItem&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit KeyedCollection`2&lt;TKey, TItem&gt; extends System.Collections.ObjectModel.Collection`1&lt;!TItem&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Collections.ObjectModel.KeyedCollection`2" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class KeyedCollection(Of TKey, TItem)&#xA;Inherits Collection(Of TItem)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TKey, typename TItem&gt;&#xA;public ref class KeyedCollection abstract : System::Collections::ObjectModel::Collection&lt;TItem&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.ObjectModel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TKey" />
    <TypeParameter Name="TItem" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Collections.ObjectModel.Collection&lt;TItem&gt;</BaseTypeName>
    <BaseTypeArguments>
      <BaseTypeArgument TypeParamName="T">TItem</BaseTypeArgument>
    </BaseTypeArguments>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.Mscorlib_KeyedCollectionDebugView`2))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="TKey">Typ kluczy w kolekcji.</typeparam>
    <typeparam name="TItem">Typ elementów w kolekcji.</typeparam>
    <summary>Udostępnia abstrakcyjna klasa podstawowa dla kolekcji, w której klucze są osadzone w wartości.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ObjectModel.KeyedCollection%602> Klasa udostępnia zarówno O(1) indeksowane pobierania i pobieranie powodujące zbliżenie O(1) z kluczem. Jest typem abstrakcyjnym lub dokładniej nieskończone zestawu typów abstrakcyjnych, ponieważ każdy jego skonstruowane typów ogólnych jest abstrakcyjna klasa podstawowa. Aby użyć <xref:System.Collections.ObjectModel.KeyedCollection%602>, pochodzi z typem kolekcji z odpowiedniego typu skonstruowane.  
  
 <xref:System.Collections.ObjectModel.KeyedCollection%602> Klasy jest hybrydowego między kolekcję na podstawie <xref:System.Collections.Generic.IList%601> ogólny interfejs i kolekcji na podstawie <xref:System.Collections.Generic.IDictionary%602> interfejs generyczny. Kolekcje oparte na, takich jak <xref:System.Collections.Generic.IList%601> ogólny interfejs <xref:System.Collections.ObjectModel.KeyedCollection%602> jest indeksowany listy elementów. Kolekcje oparte na, takich jak <xref:System.Collections.Generic.IDictionary%602> ogólny interfejs <xref:System.Collections.ObjectModel.KeyedCollection%602> ma klucz skojarzone z każdym elementem.  
  
 W przeciwieństwie do słowników, element <xref:System.Collections.ObjectModel.KeyedCollection%602> nie jest para klucza i wartości; zamiast tego cały element jest wartością i klucz jest osadzony w wartości.  Na przykład element kolekcji pochodną `KeyedCollection\<String,String>` (`KeyedCollection(Of String, String)` w języku Visual Basic) może być "Jr John Doe". Jeśli wartość jest "Jr John Doe". jak klucz "Nowak;" lub kolekcji o pracownikach zawierający klucze liczby całkowitej może pochodzić od `KeyedCollection\<int,Employee>`. Abstract <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> metody wyodrębnia klucz z elementu.  
  
 Domyślnie <xref:System.Collections.ObjectModel.KeyedCollection%602> zawiera słownik wyszukiwania, który można uzyskać z <xref:System.Collections.ObjectModel.KeyedCollection%602.Dictionary%2A> właściwości.  Gdy element zostanie dodany do <xref:System.Collections.ObjectModel.KeyedCollection%602>, klucza elementu wyodrębnione raz i zapisane w słowniku wyszukiwania w celu szybszego wyszukiwania. To zachowanie jest przesłonić, określając próg tworzenia słownika, podczas tworzenia <xref:System.Collections.ObjectModel.KeyedCollection%602>. Słownik wyszukiwania jest tworzony po raz pierwszy tej wartości progowej przekracza liczbę elementów.  Jeśli określisz -1 jako wartość progową, nigdy nie zostanie utworzony słownika wyszukiwania.  
  
> [!NOTE]
>  W przypadku słownik wewnętrzny wyszukiwania zawiera odwołania do wszystkich elementów w kolekcji, jeśli `TItem` jest typem referencyjnym lub kopiuje wszystkie elementy w kolekcji, jeśli `TItem` jest typem wartości. W związku z tym, za pomocą słownika wyszukiwania mogą nie być odpowiednie Jeśli `TItem` jest typem wartości.  
  
 Dostęp do elementu za pomocą jego indeksu lub klucza przy użyciu <xref:System.Collections.ObjectModel.KeyedCollection%602.Item%2A> właściwości. Można dodawać elementów bez klucza, ale te elementy mogą następnie uzyskiwać tylko przez indeks.  
  
   
  
## Examples  
 Ten rozdział zawiera dwa przykłady kodu. Pierwszy przykład przedstawia minimalny kod wymagany do pochodzi od <xref:System.Collections.ObjectModel.KeyedCollection%602>oraz przedstawia liczbę dziedziczonej metody. Drugi przykład przedstawia sposób przesłonięcia metody chronionych <xref:System.Collections.ObjectModel.KeyedCollection%602> zapewniające niestandardowych.  
  
 **Przykład 1**  
  
 Ten przykładowy kod przedstawia minimalne kodu konieczne pochodzi z klasy kolekcji <xref:System.Collections.ObjectModel.KeyedCollection%602>: zastępowanie <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> — metoda i zapewnianie konstruktora publicznego, który deleguje do konstruktora klasy podstawowej. Przykładowy kod przedstawia również wiele właściwości i metody dziedziczone z <xref:System.Collections.ObjectModel.KeyedCollection%602> i <xref:System.Collections.ObjectModel.Collection%601> klasy.  
  
 `SimpleOrder` Klasy jest bardzo proste zapotrzebowania lista zawierająca `OrderItem` obiektów, z których każdy reprezentuje elementu wiersza w kolejności. Klucz `OrderItem` nie można modyfikować, ważną kwestią dla klas, które pochodzą z <xref:System.Collections.ObjectModel.KeyedCollection%602>. Na przykład kodu, która używa kluczy modyfikowalne, zobacz <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection/cs/source.cs#1)]
 [!code-vb[KeyedCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection/VB/source.vb#1)]  
  
 **Przykład 2**  
  
 Poniższy przykładowy kod przedstawia sposób przesłonięcia chronionej <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, i <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> metod, aby zapewnić zachowanie niestandardowych <xref:System.Collections.ObjectModel.Collection%601.Add%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A>, i <xref:System.Collections.ObjectModel.Collection%601.Clear%2A> metod oraz ustawienie domyślne <xref:System.Collections.ObjectModel.Collection%601.Item%2A> właściwości (indeksator w języku C#). Niestandardowe zachowanie, w tym przykładzie jest zdarzeniem powiadomienia o nazwie `Changed`, które jest wywoływane na końcu każdej z metod zastąpiona.  
  
 Przykład kodu tworzy `SimpleOrder` klasy, która jest pochodną <xref:System.Collections.ObjectModel.KeyedCollection%602> i formularza proste kolejności. Formularz zawiera `OrderItem` obiekty reprezentujący elementy uporządkowane. Przykład kodu tworzy także `SimpleOrderChangedEventArgs` klasa może zawierać informacje dotyczące zdarzenia, a wyliczenie do identyfikowania typ zmiany.  
  
 Przykład kodu pokazuje niestandardowe zachowanie, wywołując właściwości i metod klasy pochodnej w `Main` metody `Demo` klasy.  
  
 Ten przykładowy kod używa obiektów z kluczami niezmienialny. Na przykład kodu, która używa kluczy modyfikowalne, zobacz <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection2#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection2/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection2#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection2/cs/source.cs#1)]
 [!code-vb[KeyedCollection2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection2/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Collections.Specialized.StringDictionary" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected KeyedCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; KeyedCollection();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" /> klasy, która używa domyślna funkcja porównująca równości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Collections.ObjectModel.KeyedCollection%602> utworzone za pomocą tego konstruktora używa domyślna funkcja porównująca równości ogólny typ klucza, otrzymanego z <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType>. Aby określić porównania równości ogólnego różnych, użyj <xref:System.Collections.ObjectModel.KeyedCollection%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%29> konstruktora lub <xref:System.Collections.ObjectModel.KeyedCollection%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%2CSystem.Int32%29> konstruktora.  
  
 Domyślnie <xref:System.Collections.ObjectModel.KeyedCollection%602> zawiera słownik wyszukiwania, który jest tworzony po dodaniu pierwszego elementu. Gdy element zostanie dodany do <xref:System.Collections.ObjectModel.KeyedCollection%602>, klucza elementu wyodrębnione raz i zapisane w słowniku wyszukiwania w celu szybszego wyszukiwania. To zachowanie można przesłonić przy użyciu <xref:System.Collections.ObjectModel.KeyedCollection%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%2CSystem.Int32%29> Konstruktor i określanie próg tworzenia słownika.  
  
> [!NOTE]
>  Ponieważ <xref:System.Collections.ObjectModel.KeyedCollection%602> klasa jest abstrakcyjna (`MustInherit` w języku Visual Basic), musi pochodzić od niego, aby można było go używać. W Konstruktorze typu pochodnego wywołać odpowiednie <xref:System.Collections.ObjectModel.KeyedCollection%602> konstruktora. Nie jest konieczne do udostępnienia funkcji takich jak porównania równości lub próg tworzenia słownika w Twojej konstruktorów.  
  
 Ten konstruktor jest operacją O(1).  
  
   
  
## Examples  
 Ten przykładowy kod przedstawia minimalne kodu konieczne pochodzi z klasy kolekcji <xref:System.Collections.ObjectModel.KeyedCollection%602>: zastępowanie <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> — metoda i zapewnianie konstruktora publicznego, który deleguje do konstruktora klasy podstawowej. Przykładowy kod przedstawia również wiele właściwości i metody dziedziczone z <xref:System.Collections.ObjectModel.KeyedCollection%602> i <xref:System.Collections.ObjectModel.Collection%601> klasy.  
  
 `SimpleOrder` Klasy jest bardzo proste zapotrzebowania lista zawierająca `OrderItem` obiektów, z których każdy reprezentuje elementu wiersza w kolejności. Klucz `OrderItem` nie można modyfikować, ważną kwestią dla klas, które pochodzą z <xref:System.Collections.ObjectModel.KeyedCollection%602>. Na przykład kodu, która używa kluczy modyfikowalne, zobacz <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection/cs/source.cs#1)]
 [!code-vb[KeyedCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IEqualityComparer`1" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected KeyedCollection (System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEqualityComparer`1&lt;!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (comparer As IEqualityComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; KeyedCollection(System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <param name="comparer">Implementacja <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> ogólny interfejs do używania przy porównywaniu klucze, lub <see langword="null" /> do używania domyślnego porównania równości dla typu klucza, uzyskane z <see cref="P:System.Collections.Generic.EqualityComparer`1.Default" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" /> klasy, która używa porównania równości określony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie <xref:System.Collections.ObjectModel.KeyedCollection%602> zawiera słownik wyszukiwania, który jest tworzony po dodaniu pierwszego elementu. Gdy element zostanie dodany do <xref:System.Collections.ObjectModel.KeyedCollection%602>, klucza elementu wyodrębnione raz i zapisane w słowniku wyszukiwania w celu szybszego wyszukiwania. To zachowanie można przesłonić przy użyciu <xref:System.Collections.ObjectModel.KeyedCollection%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%2CSystem.Int32%29> Konstruktor i określanie próg tworzenia słownika.  
  
> [!NOTE]
>  Ponieważ <xref:System.Collections.ObjectModel.KeyedCollection%602> klasa jest abstrakcyjna (`MustInherit` w języku Visual Basic), musi pochodzić od niego, aby można było go używać. W Konstruktorze typu pochodnego wywołać odpowiednie <xref:System.Collections.ObjectModel.KeyedCollection%602> konstruktora. Nie jest konieczne do udostępnienia funkcji takich jak porównania równości lub próg tworzenia słownika w Twojej konstruktorów.  
  
 Ten konstruktor jest operacją O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IEqualityComparer`1" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected KeyedCollection (System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer, int dictionaryCreationThreshold);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEqualityComparer`1&lt;!TKey&gt; comparer, int32 dictionaryCreationThreshold) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.#ctor(System.Collections.Generic.IEqualityComparer{`0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (comparer As IEqualityComparer(Of TKey), dictionaryCreationThreshold As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; KeyedCollection(System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer, int dictionaryCreationThreshold);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
        <Parameter Name="dictionaryCreationThreshold" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="comparer">Implementacja <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> ogólny interfejs do używania przy porównywaniu klucze, lub <see langword="null" /> do używania domyślnego porównania równości dla typu klucza, uzyskane z <see cref="P:System.Collections.Generic.EqualityComparer`1.Default" />.</param>
        <param name="dictionaryCreationThreshold">Liczba elementów w kolekcji może zawierać bez tworzenia słownika wyszukiwania (0 tworzy słownik wyszukiwania, gdy pierwszy element zostanie dodany), lub -1, aby określić, czy słownik wyszukiwania nigdy nie został utworzony.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" /> klasy, która używa porównania równości określonego i tworzy słownik wyszukiwania, po przekroczeniu określonego progu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie <xref:System.Collections.ObjectModel.KeyedCollection%602> zawiera słownik wyszukiwania, który jest tworzony po dodaniu pierwszego elementu. Gdy element zostanie dodany do <xref:System.Collections.ObjectModel.KeyedCollection%602>, klucza elementu wyodrębnione raz i zapisane w słowniku wyszukiwania w celu szybszego wyszukiwania. Ten konstruktor służy do zastąpienia tego zachowania. Określ 0, aby utworzyć słownik po dodaniu pierwszego elementu, 1, aby utworzyć słownik po dodaniu drugiego elementu i tak dalej. Jeśli określisz -1 jako wartość progową, nigdy nie zostanie utworzony słownika wyszukiwania.  
  
 Bardzo małe kolekcji poprawy szybkości pobierania podał słownika wyszukiwania może nie być warto dodatkową pamięć wymagana przez słownik. Ustawianie wartości progowej, można zdecydować, kiedy należy utworzyć ten zależnościami.  
  
> [!NOTE]
>  Ponieważ <xref:System.Collections.ObjectModel.KeyedCollection%602> klasa jest abstrakcyjna (`MustInherit` w języku Visual Basic), musi pochodzić od niego, aby można było go używać. W Konstruktorze typu pochodnego wywołać odpowiednie <xref:System.Collections.ObjectModel.KeyedCollection%602> konstruktora. Nie jest konieczne do udostępnienia funkcji takich jak porównania równości lub próg tworzenia słownika w Twojej konstruktorów.  
  
 Ten konstruktor jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia sposób przesłonięcia chronionej <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, i <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> metod, aby zapewnić zachowanie niestandardowych <xref:System.Collections.ObjectModel.Collection%601.Add%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A>, i <xref:System.Collections.ObjectModel.Collection%601.Clear%2A> metod oraz ustawienie domyślne <xref:System.Collections.ObjectModel.Collection%601.Item%2A> właściwości (indeksator w języku C#). Niestandardowe zachowanie, w tym przykładzie jest zdarzeniem powiadomienia o nazwie `Changed`, które jest wywoływane na końcu każdej z metod zastąpiona.  
  
 Przykład kodu wykorzystuje <xref:System.Collections.ObjectModel.KeyedCollection%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%2CSystem.Int32%29> konstruktora z próg o wartości 0, tak że słownik wewnętrzny jest tworzony po raz pierwszy obiekt został dodany do kolekcji.  
  
 Przykład kodu tworzy `SimpleOrder` klasy, która jest pochodną <xref:System.Collections.ObjectModel.KeyedCollection%602> i formularza proste kolejności. Formularz zawiera `OrderItem` obiekty reprezentujący elementy uporządkowane. Przykład kodu tworzy także `SimpleOrderChangedEventArgs` klasa może zawierać informacje dotyczące zdarzenia, a wyliczenie do identyfikowania typ zmiany.  
  
 Przykład kodu pokazuje niestandardowe zachowanie, wywołując właściwości i metod klasy pochodnej w `Main` metody `Demo` klasy.  
  
 Ten przykładowy kod używa obiektów z kluczami niezmienialny. Na przykład kodu, która używa kluczy modyfikowalne, zobacz <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection2#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection2/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection2#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection2/cs/source.cs#1)]
 [!code-vb[KeyedCollection2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="dictionaryCreationThreshold" /> jest mniejsza niż -1.</exception>
        <altmember cref="T:System.Collections.Generic.IEqualityComparer`1" />
      </Docs>
    </Member>
    <Member MemberName="ChangeItemKey">
      <MemberSignature Language="C#" Value="protected void ChangeItemKey (TItem item, TKey newKey);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ChangeItemKey(!TItem item, !TKey newKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.ChangeItemKey(`1,`0)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ChangeItemKey (item As TItem, newKey As TKey)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ChangeItemKey(TItem item, TKey newKey);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="TItem" />
        <Parameter Name="newKey" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="item">Element, aby zmienić klucz.</param>
        <param name="newKey">Nowy klucz dla <c>elementu</c>.</param>
        <summary>Zmienia klucz skojarzony z określonym elementem w słowniku wyszukiwania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie modyfikuje klucza osadzone w `item`; po prostu zastępuje klucz zapisane w słowniku wyszukiwania.  W związku z tym jeśli `newKey` różni się od klucz, który jest osadzony w `item`, nie można uzyskać dostępu `item` przy użyciu klucza zwróconego przez <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A>.  
  
 Ta metoda nie robi nic, jeśli <xref:System.Collections.ObjectModel.KeyedCollection%602> nie ma słownika wyszukiwania.  
  
 Każdy klucz w <xref:System.Collections.ObjectModel.KeyedCollection%602> muszą być unikatowe. Klucz nie może być `null`.  
  
 Ta metoda jest operacją O(1).  
  
## <a name="notes-for-implementers"></a>Uwagi dotyczące implementacji  
 Przed klucz osadzone w elemencie, należy wywołać tę metodę, aby zaktualizować klucz w słowniku wyszukiwania. Jeśli próg tworzenia słownika jest -1, wywołanie tej metody nie jest konieczne.  
  
 Nie ujawniaj <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A> metodę jako publiczną metodę klasy pochodnej. Nieprawidłowe użycie tej metody umieszcza słownika wyszukiwania zsynchronizowane z kluczami elementu. Na przykład, ustawienie klucza `null` i ustawienie jej z inną wartością dodaje wielu kluczy dla element do słownika wyszukiwania. Ujawnia tej metody wewnętrznie, aby umożliwić modyfikowalną elementu kluczy: po zmianie klucza dla elementu, ta metoda służy do zmiany kluczem w słowniku wyszukiwania.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia sposób przesłonięcia chronionej <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A> metody do obsługi tych kluczy i sposób przesłonięcia chronionej <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, i <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> metod w celu zachowania integralności kluczy i Kolekcja.  
  
 Przykład kodu tworzy `MutableKeys` kolekcji, która jest pochodną <xref:System.Collections.ObjectModel.KeyedCollection%602>i `MutableKey` klasy. `MutableKey` Klasa ma można ustawić `Key` właściwości. Gdy nowy klucz jest przypisany do właściwości, wywołuje metodę ustawiającą właściwość `internal` (`Friend` w języku Visual Basic) `ChangeKey` metody kolekcji, aby sprawdzić, czy nowy klucz spowodowałoby to konflikt z istniejącym kluczem. Jeśli tak, jest zgłaszany wyjątek i nie ulega zmianie wartości właściwości.  
  
 Aby można było obsługiwać połączenia między `MutableKey` obiektu i `MutableKeys` kolekcji i uniemożliwić obiektu wstawiane do dwie kolekcje `MutableKey` klasa ma `internal` (`Friend` w języku Visual Basic) `Collection`pola. To pole jest obsługiwana przez metody chronione, zawierających niestandardowe zachowanie Dodawanie i usuwanie elementów z kolekcji, takie jak <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> metody. Pole jest ustawiona, gdy element zostanie dodany do kolekcji i wyczyszczone, gdy element zostanie usunięty.  
  
 [!code-csharp[KeyedCollectionMutable#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollectionMutable/cs/source.cs#1)]
 [!code-vb[KeyedCollectionMutable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollectionMutable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="item" /> jest <see langword="null" />.  
  
 —lub—  
  
 <paramref name="key" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="item" /> Nie znaleziono.  
  
 —lub—  
  
 <paramref name="key" /> istnieje już w <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />.</exception>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.GetKeyForItem(`1)" />
        <altmember cref="P:System.Collections.ObjectModel.KeyedCollection`2.Item(`0)" />
      </Docs>
    </Member>
    <Member MemberName="ClearItems">
      <MemberSignature Language="C#" Value="protected override void ClearItems ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void ClearItems() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.ClearItems" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub ClearItems ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void ClearItems();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa wszystkie elementy z <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku słownika wyszukiwania, ta metoda usuwa go, ale nie powoduje usunięcia.  
  
 Jeśli liczba elementów przekroczyła próg tworzenia słownika i <xref:System.Collections.ObjectModel.KeyedCollection%602> jest za pomocą słownika wyszukiwania, nadal będzie użycie słownika wyszukiwania, mimo że liczby elementów ponownie jest poniżej wartości progowej.  
  
 Ta metoda jest O (`n`) operację, której `n` jest <xref:System.Collections.ObjectModel.Collection%601.Count%2A>.  
  
## <a name="notes-for-implementers"></a>Uwagi dotyczące implementacji  
 Przesłonić tę metodę, aby zapewnić zachowanie dostosowane <xref:System.Collections.ObjectModel.Collection%601.Clear%2A> dziedziczone z metody <xref:System.Collections.ObjectModel.Collection%601> klasy ogólnej.  
  
 Wywołanie tej metody, aby wyczyścić kolekcja źródłowa i można wyczyścić słownika wyszukiwania Implementacja klasy podstawowej.  
  
   
  
## Examples  
 Ta sekcja zawiera dwa przykłady kodu, które przedstawiają zastępowanie <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A> metodę w celu zapewnienia zachowania niestandardowego czyszczenie wszystkich obiektów z kolekcji. Pierwszym przykładzie dodaje zdarzenie niestandardowe powiadomienie i drugi zapewnia obsługę kolekcji obiektów z tych kluczy.  
  
 Przykład 1  
  
 Poniższy przykładowy kod przedstawia sposób przesłonięcia chronionej <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, i <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> metod, aby zapewnić zachowanie niestandardowych <xref:System.Collections.ObjectModel.Collection%601.Add%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A>, i <xref:System.Collections.ObjectModel.Collection%601.Clear%2A> metod oraz ustawienie domyślne <xref:System.Collections.ObjectModel.Collection%601.Item%2A> właściwości (indeksator w języku C#). Niestandardowe zachowanie, w tym przykładzie jest zdarzeniem powiadomienia o nazwie `Changed`, które jest wywoływane na końcu każdej z metod zastąpiona.  
  
 Przykład kodu tworzy `SimpleOrder` klasy, która jest pochodną <xref:System.Collections.ObjectModel.KeyedCollection%602> i formularza proste kolejności. Formularz zawiera `OrderItem` obiekty reprezentujący elementy uporządkowane. Przykład kodu tworzy także `SimpleOrderChangedEventArgs` klasa może zawierać informacje dotyczące zdarzenia, a wyliczenie do identyfikowania typ zmiany.  
  
 Przykład kodu pokazuje niestandardowe zachowanie, wywołując właściwości i metod klasy pochodnej w `Main` metody `Demo` klasy.  
  
 Ten przykładowy kod używa obiektów z kluczami niezmienialny. Na przykład kodu, która używa kluczy modyfikowalne, zobacz <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection2#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection2/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection2#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection2/cs/source.cs#1)]
 [!code-vb[KeyedCollection2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection2/vb/source.vb#1)]  
  
 Przykład 2  
  
 Poniższy przykładowy kod przedstawia sposób przesłonięcia chronionej <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A> metody do obsługi tych kluczy i sposób przesłonięcia chronionej <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, i <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> metod w celu zachowania integralności kluczy i Kolekcja.  
  
 Przykład kodu tworzy `MutableKeys` kolekcji, która jest pochodną <xref:System.Collections.ObjectModel.KeyedCollection%602>i `MutableKey` klasy. `MutableKey` Klasa ma można ustawić `Key` właściwości. Gdy nowy klucz jest przypisany do właściwości, wywołuje metodę ustawiającą właściwość `internal` (`Friend` w języku Visual Basic) `ChangeKey` metody kolekcji, aby sprawdzić, czy nowy klucz spowodowałoby to konflikt z istniejącym kluczem. Jeśli tak, jest zgłaszany wyjątek i nie ulega zmianie wartości właściwości.  
  
 Aby można było obsługiwać połączenia między `MutableKey` obiektu i `MutableKeys` kolekcji i uniemożliwić obiektu wstawiane do dwie kolekcje `MutableKey` klasa ma `internal` (`Friend` w języku Visual Basic) `Collection`pola. To pole jest obsługiwana przez metody chronione, zawierających niestandardowe zachowanie Dodawanie i usuwanie elementów z kolekcji, takie jak <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> metody. Pole jest ustawiona, gdy element zostanie dodany do kolekcji i wyczyszczone, gdy element zostanie usunięty.  
  
 [!code-csharp[KeyedCollectionMutable#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollectionMutable/cs/source.cs#1)]
 [!code-vb[KeyedCollectionMutable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollectionMutable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.Remove(`0)" />
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.RemoveItem(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Comparer">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEqualityComparer&lt;TKey&gt; Comparer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEqualityComparer`1&lt;!TKey&gt; Comparer" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ObjectModel.KeyedCollection`2.Comparer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Comparer As IEqualityComparer(Of TKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ Comparer { System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEqualityComparer&lt;TKey&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera porównania równości ogólnego, który służy do określania równości klucze w kolekcji.</summary>
        <value>Implementacja <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> ogólny interfejs, który służy do określania równości klucze w kolekcji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.Contains(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (key As TKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(TKey key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Klucz do zlokalizowania w <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />.</param>
        <summary>Określa, czy kolekcja zawiera element z określonym kluczem.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" /> zawiera element z określonym kluczem, a w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Collections.ObjectModel.KeyedCollection%602> słownika wyszukiwania `key` służy do wyszukiwania słownika. Jeśli nie ma żadnych słownika wyszukiwania, klucz każdego elementu jest wyodrębniany przy użyciu <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> metody i w porównaniu z określonym kluczem.  
  
 Ta metoda jest operacją O(1), jeśli <xref:System.Collections.ObjectModel.KeyedCollection%602> słownika wyszukiwania; w przeciwnym razie jest O (`n`) operację, której `n` jest <xref:System.Collections.ObjectModel.Collection%601.Count%2A>.  
  
   
  
## Examples  
 Ten przykładowy kod przedstawia minimalne kodu konieczne pochodzi z klasy kolekcji <xref:System.Collections.ObjectModel.KeyedCollection%602>: zastępowanie <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> — metoda i zapewnianie konstruktora publicznego, który deleguje do konstruktora klasy podstawowej. Przykładowy kod przedstawia również wiele właściwości i metody dziedziczone z <xref:System.Collections.ObjectModel.KeyedCollection%602> i <xref:System.Collections.ObjectModel.Collection%601> klasy.  
  
 `SimpleOrder` Klasy jest bardzo proste zapotrzebowania lista zawierająca `OrderItem` obiektów, z których każdy reprezentuje elementu wiersza w kolejności. Klucz `OrderItem` nie można modyfikować, ważną kwestią dla klas, które pochodzą z <xref:System.Collections.ObjectModel.KeyedCollection%602>. Na przykład kodu, która używa kluczy modyfikowalne, zobacz <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection/cs/source.cs#1)]
 [!code-vb[KeyedCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.GetKeyForItem(`1)" />
      </Docs>
    </Member>
    <Member MemberName="Dictionary">
      <MemberSignature Language="C#" Value="protected System.Collections.Generic.IDictionary&lt;TKey,TItem&gt; Dictionary { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IDictionary`2&lt;!TKey, !TItem&gt; Dictionary" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ObjectModel.KeyedCollection`2.Dictionary" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Dictionary As IDictionary(Of TKey, TItem)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::Generic::IDictionary&lt;TKey, TItem&gt; ^ Dictionary { System::Collections::Generic::IDictionary&lt;TKey, TItem&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;TKey,TItem&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera słownik wyszukiwania <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />.</summary>
        <value>Słownik wyszukiwania <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />, jeśli istnieje; w przeciwnym razie <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie <xref:System.Collections.ObjectModel.KeyedCollection%602> zawiera słownik wyszukiwania, który jest tworzony po dodaniu pierwszego elementu. Gdy element zostanie dodany do <xref:System.Collections.ObjectModel.KeyedCollection%602>, klucza elementu wyodrębnione raz i zapisane w słowniku wyszukiwania w celu szybszego wyszukiwania. To zachowanie można przesłonić przy użyciu <xref:System.Collections.ObjectModel.KeyedCollection%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%2CSystem.Int32%29> Konstruktor i określanie próg tworzenia słownika.  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia sposób przesłonięcia chronionej <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A> metody do obsługi tych kluczy i sposób przesłonięcia chronionej <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, i <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> metod w celu zachowania integralności kluczy i Kolekcja.  
  
 Przykład kodu tworzy `MutableKeys` kolekcji, która jest pochodną <xref:System.Collections.ObjectModel.KeyedCollection%602>i `MutableKey` klasy. `MutableKey` Klasa ma można ustawić `Key` właściwości. Gdy nowy klucz jest przypisany do właściwości, wywołuje metodę ustawiającą właściwość `internal` (`Friend` w języku Visual Basic) `ChangeKey` metody kolekcji, aby sprawdzić, czy nowy klucz spowodowałoby to konflikt z istniejącym kluczem. Jeśli tak, jest zgłaszany wyjątek i nie ulega zmianie wartości właściwości.  
  
 Aby można było obsługiwać połączenia między `MutableKey` obiektu i `MutableKeys` kolekcji i uniemożliwić obiektu wstawiane do dwie kolekcje `MutableKey` klasa ma `internal` (`Friend` w języku Visual Basic) `Collection`pola. To pole jest obsługiwana przez metody chronione, zawierających niestandardowe zachowanie Dodawanie i usuwanie elementów z kolekcji, takie jak <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> metody. Pole jest ustawiona, gdy element zostanie dodany do kolekcji i wyczyszczone, gdy element zostanie usunięty.  
  
 [!code-csharp[KeyedCollectionMutable#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollectionMutable/cs/source.cs#1)]
 [!code-vb[KeyedCollectionMutable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollectionMutable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IDictionary`2" />
      </Docs>
    </Member>
    <Member MemberName="GetKeyForItem">
      <MemberSignature Language="C#" Value="protected abstract TKey GetKeyForItem (TItem item);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance !TKey GetKeyForItem(!TItem item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.GetKeyForItem(`1)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetKeyForItem (item As TItem) As TKey" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract TKey GetKeyForItem(TItem item);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="TItem" />
      </Parameters>
      <Docs>
        <param name="item">Element, z którego mają zostać wyodrębnione klucza.</param>
        <summary>Po zaimplementowaniu w klasie pochodnej pobiera klucz z określonego elementu.</summary>
        <returns>Klucz dla określonego elementu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli klucz w słowniku wyszukiwania jest inny niż klucz, który jest osadzony w `item`, nie można uzyskać dostępu `item` przy użyciu klucza zwróconego przez <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A>.  
  
 Można zaimplementować tę metodę, aby zwrócić `null` dla kolekcji, który zawiera elementy, bez kluczy, w którym to przypadku elementy są dostępne tylko według ich indeksu. Ta metoda jest operacją O(1).  
  
## <a name="notes-for-implementers"></a>Uwagi dotyczące implementacji  
 Należy przesłonić tę metodę, aby zapewnić słownik sposobem wyodrębniania klucze elementów w słowniku.  
  
 Ta metoda jest wywoływana wewnętrznie. Nie jest konieczne jest publiczny.  
  
   
  
## Examples  
 Ten przykładowy kod przedstawia minimalne kodu konieczne pochodzi z klasy kolekcji <xref:System.Collections.ObjectModel.KeyedCollection%602>: zastępowanie <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> — metoda i zapewnianie konstruktora publicznego, który deleguje do konstruktora klasy podstawowej. Przykładowy kod przedstawia również wiele właściwości i metody dziedziczone z <xref:System.Collections.ObjectModel.KeyedCollection%602> i <xref:System.Collections.ObjectModel.Collection%601> klasy.  
  
 `SimpleOrder` Klasy jest bardzo proste zapotrzebowania lista zawierająca `OrderItem` obiektów, z których każdy reprezentuje elementu wiersza w kolejności. Klucz `OrderItem` nie można modyfikować, ważną kwestią dla klas, które pochodzą z <xref:System.Collections.ObjectModel.KeyedCollection%602>. Na przykład kodu, która używa kluczy modyfikowalne, zobacz <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection/cs/source.cs#1)]
 [!code-vb[KeyedCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.ChangeItemKey(`1,`0)" />
        <altmember cref="P:System.Collections.ObjectModel.KeyedCollection`2.Item(`0)" />
      </Docs>
    </Member>
    <Member MemberName="InsertItem">
      <MemberSignature Language="C#" Value="protected override void InsertItem (int index, TItem item);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void InsertItem(int32 index, !TItem item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.InsertItem(System.Int32,`1)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub InsertItem (index As Integer, item As TItem)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void InsertItem(int index, TItem item);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="TItem" />
      </Parameters>
      <Docs>
        <param name="index">Liczony od zera indeks, w którym <c>elementu</c> powinien zostać wstawiony.</param>
        <param name="item">Obiekt do wstawienia.</param>
        <summary>Wstawia element do <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" /> pod określonym indeksem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `index` jest równa <xref:System.Collections.ObjectModel.Collection%601.Count%2A>, `item` zostanie dodany na końcu <xref:System.Collections.ObjectModel.KeyedCollection%602>.  
  
 Ta metoda jest O (`n`) operację, której `n` jest <xref:System.Collections.ObjectModel.Collection%601.Count%2A>.  
  
 <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> Metoda jest wywoływana przez <xref:System.Collections.ObjectModel.Collection%601.Add%2A> i <xref:System.Collections.ObjectModel.Collection%601.Insert%2A> metody.  
  
## <a name="notes-for-implementers"></a>Uwagi dotyczące implementacji  
 Przesłonić tę metodę, aby zapewnić zachowanie dostosowane <xref:System.Collections.ObjectModel.Collection%601.Add%2A> i <xref:System.Collections.ObjectModel.Collection%601.Insert%2A> metody odziedziczone <xref:System.Collections.ObjectModel.Collection%601> klasy ogólnej.  
  
 Wywołanie implementacji klasy podstawowej tej metody można umieścić element w kolekcji źródłowej oraz do aktualizowania słownika wyszukiwania.  
  
   
  
## Examples  
 Ta sekcja zawiera dwa przykłady kodu, które przedstawiają zastępowanie <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> metodę w celu zapewnienia zachowania niestandardowych w celu dodawania lub wstawianie obiektów do kolekcji. Pierwszym przykładzie dodaje zdarzenie niestandardowe powiadomienie i drugi zapewnia obsługę kolekcji obiektów z tych kluczy.  
  
 Przykład 1  
  
 Poniższy przykładowy kod przedstawia sposób przesłonięcia chronionej <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, i <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> metod, aby zapewnić zachowanie niestandardowych <xref:System.Collections.ObjectModel.Collection%601.Add%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A>, i <xref:System.Collections.ObjectModel.Collection%601.Clear%2A> metod oraz ustawienie domyślne <xref:System.Collections.ObjectModel.Collection%601.Item%2A> właściwości (indeksator w języku C#). Niestandardowe zachowanie, w tym przykładzie jest zdarzeniem powiadomienia o nazwie `Changed`, które jest wywoływane na końcu każdej z metod zastąpiona.  
  
 Przykład kodu tworzy `SimpleOrder` klasy, która jest pochodną <xref:System.Collections.ObjectModel.KeyedCollection%602> i formularza proste kolejności. Formularz zawiera `OrderItem` obiekty reprezentujący elementy uporządkowane. Przykład kodu tworzy także `SimpleOrderChangedEventArgs` klasa może zawierać informacje dotyczące zdarzenia, a wyliczenie do identyfikowania typ zmiany.  
  
 Przykład kodu pokazuje niestandardowe zachowanie, wywołując właściwości i metod klasy pochodnej w `Main` metody `Demo` klasy.  
  
 Ten przykładowy kod używa obiektów z kluczami niezmienialny. Na przykład kodu, która używa kluczy modyfikowalne, zobacz <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection2#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection2/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection2#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection2/cs/source.cs#1)]
 [!code-vb[KeyedCollection2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection2/vb/source.vb#1)]  
  
 Przykład 2  
  
 Poniższy przykładowy kod przedstawia sposób przesłonięcia chronionej <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A> metody do obsługi tych kluczy i sposób przesłonięcia chronionej <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, i <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> metod w celu zachowania integralności kluczy i Kolekcja.  
  
 Przykład kodu tworzy `MutableKeys` kolekcji, która jest pochodną <xref:System.Collections.ObjectModel.KeyedCollection%602>i `MutableKey` klasy. `MutableKey` Klasa ma można ustawić `Key` właściwości. Gdy nowy klucz jest przypisany do właściwości, wywołuje metodę ustawiającą właściwość `internal` (`Friend` w języku Visual Basic) `ChangeKey` metody kolekcji, aby sprawdzić, czy nowy klucz spowodowałoby to konflikt z istniejącym kluczem. Jeśli tak, jest zgłaszany wyjątek i nie ulega zmianie wartości właściwości.  
  
 Aby można było obsługiwać połączenia między `MutableKey` obiektu i `MutableKeys` kolekcji i uniemożliwić obiektu wstawiane do dwie kolekcje `MutableKey` klasa ma `internal` (`Friend` w języku Visual Basic) `Collection`pola. To pole jest obsługiwana przez metody chronione, zawierających niestandardowe zachowanie Dodawanie i usuwanie elementów z kolekcji, takie jak <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> metody. Pole jest ustawiona, gdy element zostanie dodany do kolekcji i wyczyszczone, gdy element zostanie usunięty.  
  
 [!code-csharp[KeyedCollectionMutable#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollectionMutable/cs/source.cs#1)]
 [!code-vb[KeyedCollectionMutable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollectionMutable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza niż 0.  
  
 —lub—  
  
 <paramref name="index" /> jest większa niż <see cref="P:System.Collections.ObjectModel.Collection`1.Count" />.</exception>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.SetItem(System.Int32,`1)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public TItem this[TKey key] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !TItem Item(!TKey)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ObjectModel.KeyedCollection`2.Item(`0)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(key As TKey) As TItem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TItem default[TKey] { TItem get(TKey key); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Klucz elementu do pobrania.</param>
        <summary>Pobiera element z określonym kluczem.</summary>
        <value>Element z określonym kluczem. Jeśli element z określonym kluczem nie zostanie znaleziony, jest zwracany wyjątek.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość umożliwia dostęp do określonego elementu w kolekcji przy użyciu następującej składni: `myCollection[key]` (`myCollection(key)` w języku Visual Basic).  
  
> [!NOTE]
>  Ta właściwość zawiera tylko unikatowe wiersze z dziedziczonego <xref:System.Collections.ObjectModel.Collection%601.Item%2A?displayProperty=nameWithType> właściwość, która pobiera i ustawia elementów według indeksu liczbowego. Jednak jeśli `TKey` jest typu <xref:System.Int32>, ta właściwość maski właściwość dziedziczona. W takim przypadku możesz uzyskać dostęp do właściwość dziedziczona, rzutowania <xref:System.Collections.ObjectModel.KeyedCollection%602> na jego typ podstawowy. Na przykład `KeyedCollection<int, MyType>` (`KeyedCollection(Of Integer, MyType)` w języku Visual Basic `KeyedCollection<int, MyType^>` w języku C++) mogą być rzutowane na `Collection<MyType>` (`Collection(Of MyType)` w języku Visual Basic `Collection<MyType^>` w języku C++).  
  
 Jeśli <xref:System.Collections.ObjectModel.KeyedCollection%602> słownika wyszukiwania `key` służy do pobierania elementu ze słownika.  Jeśli nie ma żadnych słownika wyszukiwania, klucz każdego elementu jest wyodrębniany przy użyciu <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> metody i w porównaniu z określonym kluczem.  
  
 Używa języka C# do definiowania indeksatory zamiast implementacja słowa kluczowego <xref:System.Collections.ObjectModel.KeyedCollection%602.Item%2A> właściwości. Implementuje Visual Basic <xref:System.Collections.ObjectModel.KeyedCollection%602.Item%2A> jako domyślna właściwość, która zapewnia te same funkcje indeksowania.  
  
 Pobieranie wartości tej właściwości jest operacją O(1), jeśli <xref:System.Collections.ObjectModel.KeyedCollection%602> słownika wyszukiwania; w przeciwnym razie jest O (`n`) operację, której `n` jest <xref:System.Collections.ObjectModel.Collection%601.Count%2A>.  
  
   
  
## Examples  
 Ten przykładowy kod przedstawia minimalne kodu konieczne pochodzi z klasy kolekcji <xref:System.Collections.ObjectModel.KeyedCollection%602>: zastępowanie <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> — metoda i zapewnianie konstruktora publicznego, który deleguje do konstruktora klasy podstawowej. Przykładowy kod przedstawia również wiele właściwości i metody dziedziczone z <xref:System.Collections.ObjectModel.KeyedCollection%602> i <xref:System.Collections.ObjectModel.Collection%601> klasy.  
  
 Przykładowy kod wywołuje zarówno <xref:System.Collections.ObjectModel.KeyedCollection%602.Item%2A?displayProperty=nameWithType> właściwość, która jest tylko do odczytu i pobiera klucz, oraz <xref:System.Collections.ObjectModel.Collection%601.Item%2A?displayProperty=nameWithType> właściwości, które można ustawić i pobiera według indeksu. Widoczny jest sposób dostępu ostatnie właściwości, gdy w obiektach w pochodnej kolekcji kluczy liczba całkowita, można odróżnić od liczby całkowite użyte do pobierania indeksowanego.  
  
 `SimpleOrder` Klasy jest bardzo proste zapotrzebowania lista zawierająca `OrderItem` obiektów, z których każdy reprezentuje elementu wiersza w kolejności. Klucz `OrderItem` nie można modyfikować, ważną kwestią dla klas, które pochodzą z <xref:System.Collections.ObjectModel.KeyedCollection%602>. Na przykład kodu, która używa kluczy modyfikowalne, zobacz <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection/cs/source.cs#1)]
 [!code-vb[KeyedCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Collections.Generic.KeyNotFoundException">Element z określonym kluczem nie istnieje w kolekcji.</exception>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.SetItem(System.Int32,`1)" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Remove(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (key As TKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Remove(TKey key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Klucz elementu do usunięcia.</param>
        <summary>Usuwa element z określonym kluczem z <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />.</summary>
        <returns>
          <see langword="true" /> Jeśli element został pomyślnie usunięty; w przeciwnym razie <see langword="false" />.  Ta metoda zwraca również wartość <see langword="false" /> Jeśli <paramref name="key" /> nie został znaleziony w <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klucz elementu powoduje również usunięcie ze słownika wyszukiwania.  
  
 Jeśli liczba elementów przekroczyła próg tworzenia słownika i <xref:System.Collections.ObjectModel.KeyedCollection%602> jest za pomocą słownika wyszukiwania, nadal będzie użycie słownika wyszukiwania, mimo że liczby elementów ponownie jest poniżej wartości progowej.  
  
> [!NOTE]
>  Aby dostosować zachowanie tej metody, należy zastąpić <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A> metody.  
  
 Ta metoda jest O (`n`) operację, której `n` jest <xref:System.Collections.ObjectModel.Collection%601.Count%2A>.  
  
   
  
## Examples  
 Ten przykładowy kod przedstawia minimalne kodu konieczne pochodzi z klasy kolekcji <xref:System.Collections.ObjectModel.KeyedCollection%602>: zastępowanie <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> — metoda i zapewnianie konstruktora publicznego, który deleguje do konstruktora klasy podstawowej. Przykładowy kod przedstawia również wiele właściwości i metody dziedziczone z <xref:System.Collections.ObjectModel.KeyedCollection%602> i <xref:System.Collections.ObjectModel.Collection%601> klasy.  
  
 W przykładzie pokazano <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A> odziedziczone — metoda <xref:System.Collections.ObjectModel.KeyedCollection%602>, która usuwa element z określonym kluczem, a także <xref:System.Collections.ObjectModel.Collection%601.Remove%2A> i <xref:System.Collections.ObjectModel.Collection%601.RemoveAt%2A> metody dziedziczone z <xref:System.Collections.ObjectModel.Collection%601>, którego usunięcie przez obiekt i przez indeks odpowiednio.  
  
 `SimpleOrder` Klasy jest bardzo proste zapotrzebowania lista zawierająca `OrderItem` obiektów, z których każdy reprezentuje elementu wiersza w kolejności. Klucz `OrderItem` nie można modyfikować, ważną kwestią dla klas, które pochodzą z <xref:System.Collections.ObjectModel.KeyedCollection%602>. Na przykład kodu, która używa kluczy modyfikowalne, zobacz <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection/cs/source.cs#1)]
 [!code-vb[KeyedCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.RemoveItem(System.Int32)" />
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.ClearItems" />
      </Docs>
    </Member>
    <Member MemberName="RemoveItem">
      <MemberSignature Language="C#" Value="protected override void RemoveItem (int index);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void RemoveItem(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.RemoveItem(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub RemoveItem (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void RemoveItem(int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Indeks elementu do usunięcia.</param>
        <summary>Usuwa element o określonym indeksie <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klucz elementu powoduje również usunięcie ze słownika wyszukiwania.  
  
 Jeśli liczba elementów przekroczyła próg tworzenia słownika i <xref:System.Collections.ObjectModel.KeyedCollection%602> jest za pomocą słownika wyszukiwania, nadal będzie użycie słownika wyszukiwania, mimo że liczby elementów ponownie jest poniżej wartości progowej.  
  
 Ta metoda jest O (`n`) operację, której `n` jest <xref:System.Collections.ObjectModel.Collection%601.Count%2A>.  
  
## <a name="notes-for-implementers"></a>Uwagi dotyczące implementacji  
 Przesłonić tę metodę, aby zapewnić zachowanie dostosowane dla <xref:System.Collections.ObjectModel.Collection%601.Remove%28%600%29> i <xref:System.Collections.ObjectModel.Collection%601.RemoveAt%28System.Int32%29> metody dziedziczone z <xref:System.Collections.ObjectModel.Collection%601> klasy ogólnej i <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%28%600%29> metody.  
  
 Wywołanie implementacji klasy podstawowej tej metody, aby usunąć element z kolekcji źródłowej oraz do aktualizowania słownika wyszukiwania.  
  
   
  
## Examples  
 Ta sekcja zawiera dwa przykłady kodu, które przedstawiają zastępowanie <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A> metodę w celu zapewnienia zachowania niestandardowych do usuwania obiektów z kolekcji. Pierwszym przykładzie dodaje zdarzenie niestandardowe powiadomienie i drugi zapewnia obsługę kolekcji obiektów z tych kluczy.  
  
 Przykład 1  
  
 Poniższy przykładowy kod przedstawia sposób przesłonięcia chronionej <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, i <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> metod, aby zapewnić zachowanie niestandardowych <xref:System.Collections.ObjectModel.Collection%601.Add%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A>, i <xref:System.Collections.ObjectModel.Collection%601.Clear%2A> metod oraz ustawienie domyślne <xref:System.Collections.ObjectModel.Collection%601.Item%2A> właściwości (indeksator w języku C#). Niestandardowe zachowanie, w tym przykładzie jest zdarzeniem powiadomienia o nazwie `Changed`, które jest wywoływane na końcu każdej z metod zastąpiona.  
  
 Przykład kodu tworzy `SimpleOrder` klasy, która jest pochodną <xref:System.Collections.ObjectModel.KeyedCollection%602> i formularza proste kolejności. Formularz zawiera `OrderItem` obiekty reprezentujący elementy uporządkowane. Przykład kodu tworzy także `SimpleOrderChangedEventArgs` klasa może zawierać informacje dotyczące zdarzenia, a wyliczenie do identyfikowania typ zmiany.  
  
 Przykład kodu pokazuje niestandardowe zachowanie, wywołując właściwości i metod klasy pochodnej w `Main` metody `Demo` klasy.  
  
 Ten przykładowy kod używa obiektów z kluczami niezmienialny. Na przykład kodu, która używa kluczy modyfikowalne, zobacz <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection2#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection2/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection2#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection2/cs/source.cs#1)]
 [!code-vb[KeyedCollection2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection2/vb/source.vb#1)]  
  
 Przykład 2  
  
 Poniższy przykładowy kod przedstawia sposób przesłonięcia chronionej <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A> metody do obsługi tych kluczy i sposób przesłonięcia chronionej <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, i <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> metod w celu zachowania integralności kluczy i Kolekcja.  
  
 Przykład kodu tworzy `MutableKeys` kolekcji, która jest pochodną <xref:System.Collections.ObjectModel.KeyedCollection%602>i `MutableKey` klasy. `MutableKey` Klasa ma można ustawić `Key` właściwości. Gdy nowy klucz jest przypisany do właściwości, wywołuje metodę ustawiającą właściwość `internal` (`Friend` w języku Visual Basic) `ChangeKey` metody kolekcji, aby sprawdzić, czy nowy klucz spowodowałoby to konflikt z istniejącym kluczem. Jeśli tak, jest zgłaszany wyjątek i nie ulega zmianie wartości właściwości.  
  
 Aby można było obsługiwać połączenia między `MutableKey` obiektu i `MutableKeys` kolekcji i uniemożliwić obiektu wstawiane do dwie kolekcje `MutableKey` klasa ma `internal` (`Friend` w języku Visual Basic) `Collection`pola. To pole jest obsługiwana przez metody chronione, zawierających niestandardowe zachowanie Dodawanie i usuwanie elementów z kolekcji, takie jak <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> metody. Pole jest ustawiona, gdy element zostanie dodany do kolekcji i wyczyszczone, gdy element zostanie usunięty.  
  
 [!code-csharp[KeyedCollectionMutable#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollectionMutable/cs/source.cs#1)]
 [!code-vb[KeyedCollectionMutable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollectionMutable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.Remove(`0)" />
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.ClearItems" />
      </Docs>
    </Member>
    <Member MemberName="SetItem">
      <MemberSignature Language="C#" Value="protected override void SetItem (int index, TItem item);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void SetItem(int32 index, !TItem item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.SetItem(System.Int32,`1)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub SetItem (index As Integer, item As TItem)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void SetItem(int index, TItem item);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="TItem" />
      </Parameters>
      <Docs>
        <param name="index">Liczony od zera indeks elementu do wymiany.</param>
        <param name="item">Nowy element.</param>
        <summary>Zamienia określony element element w określonym indeksie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Słownik wyszukiwania jest odpowiednio aktualizowany. Oznacza to klucza elementu, który jest zastępowany jest usunięty ze słownika wyszukiwania i klucza nowy element jest dodawany.  
  
 Ta metoda jest operacją O(1).  
  
## <a name="notes-for-implementers"></a>Uwagi dotyczące implementacji  
 Przesłonić tę metodę, aby zapewnić zachowanie dostosowane ustawienia <xref:System.Collections.ObjectModel.Collection%601.Item%2A> odziedziczone właściwości <xref:System.Collections.ObjectModel.Collection%601> klasy ogólnej.  
  
> [!NOTE]
>  Ta metoda nie ma wpływu na zachowanie <xref:System.Collections.ObjectModel.KeyedCollection%602.Item%2A?displayProperty=nameWithType> właściwość, która jest tylko do odczytu.  
  
 Wywołanie implementacji klasy podstawowej tej metody można ustawić elementu w kolekcji źródłowej oraz do aktualizowania słownika wyszukiwania.  
  
   
  
## Examples  
 Ta sekcja zawiera dwa przykłady kodu, które przedstawiają zastępowanie <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> metodę w celu zapewnienia zachowania niestandardowego ustawienia <xref:System.Collections.ObjectModel.Collection%601.Item%2A?displayProperty=nameWithType> właściwości. Pierwszym przykładzie dodaje zdarzenie niestandardowe powiadomienie i drugi zapewnia obsługę kolekcji obiektów z tych kluczy.  
  
 Przykład 1  
  
 Poniższy przykładowy kod przedstawia sposób przesłonięcia chronionej <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, i <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> metod, aby zapewnić zachowanie niestandardowych <xref:System.Collections.ObjectModel.Collection%601.Add%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A>, i <xref:System.Collections.ObjectModel.Collection%601.Clear%2A> metod oraz ustawienie domyślne <xref:System.Collections.ObjectModel.Collection%601.Item%2A> właściwości (indeksator w języku C#). Niestandardowe zachowanie, w tym przykładzie jest zdarzeniem powiadomienia o nazwie `Changed`, które jest wywoływane na końcu każdej z metod zastąpiona.  
  
 Przykład kodu tworzy `SimpleOrder` klasy, która jest pochodną <xref:System.Collections.ObjectModel.KeyedCollection%602> i formularza proste kolejności. Formularz zawiera `OrderItem` obiekty reprezentujący elementy uporządkowane. Przykład kodu tworzy także `SimpleOrderChangedEventArgs` klasa może zawierać informacje dotyczące zdarzenia, a wyliczenie do identyfikowania typ zmiany.  
  
 Przykład kodu pokazuje niestandardowe zachowanie, wywołując właściwości i metod klasy pochodnej w `Main` metody `Demo` klasy.  
  
 Ten przykładowy kod używa obiektów z kluczami niezmienialny. Na przykład kodu, która używa kluczy modyfikowalne, zobacz <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection2#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection2/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection2#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection2/cs/source.cs#1)]
 [!code-vb[KeyedCollection2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection2/vb/source.vb#1)]  
  
 Przykład 2  
  
 Poniższy przykładowy kod przedstawia sposób przesłonięcia chronionej <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A> metody do obsługi tych kluczy i sposób przesłonięcia chronionej <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, i <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> metod w celu zachowania integralności kluczy i Kolekcja.  
  
 Przykład kodu tworzy `MutableKeys` kolekcji, która jest pochodną <xref:System.Collections.ObjectModel.KeyedCollection%602>i `MutableKey` klasy. `MutableKey` Klasa ma można ustawić `Key` właściwości. Gdy nowy klucz jest przypisany do właściwości, wywołuje metodę ustawiającą właściwość `internal` (`Friend` w języku Visual Basic) `ChangeKey` metody kolekcji, aby sprawdzić, czy nowy klucz spowodowałoby to konflikt z istniejącym kluczem. Jeśli tak, jest zgłaszany wyjątek i nie ulega zmianie wartości właściwości.  
  
 Aby można było obsługiwać połączenia między `MutableKey` obiektu i `MutableKeys` kolekcji i uniemożliwić obiektu wstawiane do dwie kolekcje `MutableKey` klasa ma `internal` (`Friend` w języku Visual Basic) `Collection`pola. To pole jest obsługiwana przez metody chronione, zawierających niestandardowe zachowanie Dodawanie i usuwanie elementów z kolekcji, takie jak <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> metody. Pole jest ustawiona, gdy element zostanie dodany do kolekcji i wyczyszczone, gdy element zostanie usunięty.  
  
 [!code-csharp[KeyedCollectionMutable#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollectionMutable/cs/source.cs#1)]
 [!code-vb[KeyedCollectionMutable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollectionMutable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ObjectModel.KeyedCollection`2.Item(`0)" />
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.InsertItem(System.Int32,`1)" />
      </Docs>
    </Member>
    <Member MemberName="TryGetValue">
      <MemberSignature Language="C#" Value="public bool TryGetValue (TKey key, out TItem item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetValue(!TKey key, [out] !TItem&amp; item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.TryGetValue(`0,`1@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetValue (key As TKey, ByRef item As TItem) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetValue(TKey key, [Runtime::InteropServices::Out] TItem % item);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="item" Type="TItem&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <param name="item">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
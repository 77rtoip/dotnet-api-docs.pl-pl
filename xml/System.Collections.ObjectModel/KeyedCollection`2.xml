<Type Name="KeyedCollection&lt;TKey,TItem&gt;" FullName="System.Collections.ObjectModel.KeyedCollection&lt;TKey,TItem&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="f674f9e621e530f6ee1b3c61278c7bc6009ee991" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58694351" /></Metadata><TypeSignature Language="C#" Value="public abstract class KeyedCollection&lt;TKey,TItem&gt; : System.Collections.ObjectModel.Collection&lt;TItem&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit KeyedCollection`2&lt;TKey, TItem&gt; extends System.Collections.ObjectModel.Collection`1&lt;!TItem&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Collections.ObjectModel.KeyedCollection`2" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class KeyedCollection(Of TKey, TItem)&#xA;Inherits Collection(Of TItem)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TKey, typename TItem&gt;&#xA;public ref class KeyedCollection abstract : System::Collections::ObjectModel::Collection&lt;TItem&gt;" />
  <TypeSignature Language="F#" Value="type KeyedCollection&lt;'Key, 'Item&gt; = class&#xA;    inherit Collection&lt;'Item&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.ObjectModel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TKey" />
    <TypeParameter Name="TItem" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Collections.ObjectModel.Collection&lt;TItem&gt;</BaseTypeName>
    <BaseTypeArguments>
      <BaseTypeArgument TypeParamName="T">TItem</BaseTypeArgument>
    </BaseTypeArguments>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.Mscorlib_KeyedCollectionDebugView`2))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="TKey">Typ kluczy w kolekcji.</typeparam>
    <typeparam name="TItem">Typ elementów w kolekcji.</typeparam>
    <summary>Udostępnia abstrakcyjną klasę bazową dla kolekcji, których klucze są osadzone w wartościach.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ObjectModel.KeyedCollection%602> Klasa udostępnia zarówno O(1) indeksowane pobierania i opartych na kluczach pobierania, który zbliża się O(1). Jest typem abstrakcyjnym lub dokładniej nieskończone zestaw typów abstrakcyjnych, ponieważ każdy z jej skonstruowany typów ogólnych jest abstrakcyjną klasę bazową. Aby użyć <xref:System.Collections.ObjectModel.KeyedCollection%602>, dziedziczyć po odpowiedniego typu skonstruowanego typu kolekcji.  
  
 <xref:System.Collections.ObjectModel.KeyedCollection%602> Klasy jest hybrydą między kolekcję na podstawie <xref:System.Collections.Generic.IList%601> ogólny interfejs i kolekcji na podstawie <xref:System.Collections.Generic.IDictionary%602> interfejs generyczny. Kolekcje oparte na, takich jak <xref:System.Collections.Generic.IList%601> ogólny interfejs <xref:System.Collections.ObjectModel.KeyedCollection%602> jest indeksowany listę elementów. Kolekcje oparte na, takich jak <xref:System.Collections.Generic.IDictionary%602> ogólny interfejs <xref:System.Collections.ObjectModel.KeyedCollection%602> ma klucz skojarzony z każdego elementu.  
  
 W odróżnieniu od słowników, element <xref:System.Collections.ObjectModel.KeyedCollection%602> nie jest pary klucz/wartość; zamiast tego cały element jest wartością i klucz zostanie osadzony w wartości.  Na przykład element kolekcji pochodną `KeyedCollection\<String,String>` (`KeyedCollection(Of String, String)` w języku Visual Basic) może być "John Doe Jr." Jeśli wartość jest "John Doe Jr." a klucz jest "Doe"; lub zbiór rekordy pracowników, zawierający kluczy liczby całkowitej może pochodzić z `KeyedCollection\<int,Employee>`. Abstrakcyjna <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> metoda wyodrębnia klucz z elementu.  
  
 Domyślnie <xref:System.Collections.ObjectModel.KeyedCollection%602> zawiera słownik wyszukiwania, który można uzyskać za pomocą <xref:System.Collections.ObjectModel.KeyedCollection%602.Dictionary%2A> właściwości.  Po dodaniu elementu do <xref:System.Collections.ObjectModel.KeyedCollection%602>, klucz elementu jest wyodrębniany raz i zapisane w słowniku wyszukiwania, wyszukiwanie jest szybsze. To zachowanie jest zastępowany przez określenie próg Tworzenie słownika, podczas tworzenia <xref:System.Collections.ObjectModel.KeyedCollection%602>. Słownik wyszukiwania jest tworzony po raz pierwszy liczba elementów przekracza wartość progu.  Jeśli określisz wartość -1 jako wartość progową, słownika wyszukiwania nigdy nie zostanie utworzony.  
  
> [!NOTE]
>  Stosowania słownik wewnętrzny wyszukiwania zawiera odwołania do wszystkich elementów w kolekcji, jeśli `TItem` jest typem referencyjnym lub kopiuje wszystkich elementów w kolekcji, jeśli `TItem` jest typem wartości. W związku z tym, za pomocą słownika wyszukiwania może nie być odpowiednie Jeśli `TItem` jest typem wartości.  
  
 Dostęp do elementu za pomocą jego indeksu lub klucza przy użyciu <xref:System.Collections.ObjectModel.KeyedCollection%602.Item%2A> właściwości. Można dodawać elementy bez klucza, ale te elementy później są dostępne tylko za pomocą indeksu.  
  
   
  
## Examples  
 Ten rozdział zawiera dwa przykłady kodu. Pierwszy przykład pokazuje kod minimalne wymagane do uzyskania z <xref:System.Collections.ObjectModel.KeyedCollection%602>i pokazuje liczbę metody dziedziczone. Drugi przykład przedstawia sposób przesłonięcia metody chronionej <xref:System.Collections.ObjectModel.KeyedCollection%602> zapewnienie niestandardowe zachowanie.  
  
 **Przykład 1**  
  
 Ten przykład kodu pokazuje kod minimalne należy wyprowadzić klasę z kolekcji <xref:System.Collections.ObjectModel.KeyedCollection%602>: zastępowanie <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> metody i zapewniając Konstruktor publiczny, który deleguje do konstruktora klasy bazowej. W przykładzie kodu pokazano również wiele właściwości i metod odziedziczone <xref:System.Collections.ObjectModel.KeyedCollection%602> i <xref:System.Collections.ObjectModel.Collection%601> klasy.  
  
 `SimpleOrder` Klasa jest lista zapotrzebowania bardzo prosty, która zawiera `OrderItem` obiektów, z których każdy reprezentuje elementu wiersza w kolejności. Klucz `OrderItem` można modyfikować, ważną kwestią dla klas, które wynikają z <xref:System.Collections.ObjectModel.KeyedCollection%602>. Aby uzyskać przykładowy kod, który korzysta z kluczami modyfikowalny, zobacz <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection/cs/source.cs#1)]
 [!code-vb[KeyedCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection/VB/source.vb#1)]  
  
 **Przykład 2**  
  
 Poniższy przykład kodu przedstawia sposób przesłonięcia chronionego <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, i <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> metody w celu zapewnienia niestandardowe zachowanie <xref:System.Collections.ObjectModel.Collection%601.Add%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A>, i <xref:System.Collections.ObjectModel.Collection%601.Clear%2A> metod i ustawienie domyślne <xref:System.Collections.ObjectModel.Collection%601.Item%2A> właściwości (indeksatora w języku C#). Niestandardowe zachowanie, które podano w tym przykładzie jest to zdarzenie powiadomienia o nazwie `Changed`, które jest wywoływane na końcu każdego zastąpionych metod.  
  
 Przykład kodu tworzy `SimpleOrder` klasy, która jest pochodną <xref:System.Collections.ObjectModel.KeyedCollection%602> i reprezentuje kolejność prostego formularza. Formularz zawiera `OrderItem` obiekty reprezentujące elementy uporządkowane. Przykład kodu tworzy również `SimpleOrderChangedEventArgs` klasa może zawierać informacje o zdarzeniu i wyliczenia do identyfikowania typu zmiany.  
  
 Przykład kodu demonstruje niestandardowe zachowanie, wywołując właściwości i metody klasy pochodnej w `Main` metody `Demo` klasy.  
  
 Ten przykład kodu używa obiektów za pomocą niezmienialnych kluczy. Aby uzyskać przykładowy kod, który korzysta z kluczami modyfikowalny, zobacz <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection2#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection2/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection2#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection2/cs/source.cs#1)]
 [!code-vb[KeyedCollection2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection2/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Collections.Specialized.StringDictionary" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected KeyedCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; KeyedCollection();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" /> klasy, która używa domyślny moduł porównujący równość.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Collections.ObjectModel.KeyedCollection%602> utworzone za pomocą tego konstruktora używa domyślny moduł porównujący równość ogólny typ klucza, otrzymanego z <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType>. Aby określić funkcję porównującą inną równość ogólny, użyj <xref:System.Collections.ObjectModel.KeyedCollection%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%29> konstruktora lub <xref:System.Collections.ObjectModel.KeyedCollection%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%2CSystem.Int32%29> konstruktora.  
  
 Domyślnie <xref:System.Collections.ObjectModel.KeyedCollection%602> zawiera słownik wyszukiwania, który jest tworzony, gdy pierwszy element zostanie dodany. Po dodaniu elementu do <xref:System.Collections.ObjectModel.KeyedCollection%602>, klucz elementu jest wyodrębniany raz i zapisane w słowniku wyszukiwania, wyszukiwanie jest szybsze. To zachowanie można przesłonić przy użyciu <xref:System.Collections.ObjectModel.KeyedCollection%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%2CSystem.Int32%29> Konstruktor i określając próg Tworzenie słownika.  
  
> [!NOTE]
>  Ponieważ <xref:System.Collections.ObjectModel.KeyedCollection%602> klasa jest klasą abstrakcyjną (`MustInherit` w języku Visual Basic), musi pochodzić od niego, aby można było go używać. W Konstruktorze dla danego typu pochodnego, wywołaj odpowiedni <xref:System.Collections.ObjectModel.KeyedCollection%602> konstruktora. Nie jest wymagane do udostępnienia funkcji, takich jak moduł porównujący równość lub próg Tworzenie słownika w konstruktorach usługi.  
  
 Ten konstruktor jest operacją O(1).  
  
   
  
## Examples  
 Ten przykład kodu pokazuje kod minimalne należy wyprowadzić klasę z kolekcji <xref:System.Collections.ObjectModel.KeyedCollection%602>: zastępowanie <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> metody i zapewniając Konstruktor publiczny, który deleguje do konstruktora klasy bazowej. W przykładzie kodu pokazano również wiele właściwości i metod odziedziczone <xref:System.Collections.ObjectModel.KeyedCollection%602> i <xref:System.Collections.ObjectModel.Collection%601> klasy.  
  
 `SimpleOrder` Klasa jest lista zapotrzebowania bardzo prosty, która zawiera `OrderItem` obiektów, z których każdy reprezentuje elementu wiersza w kolejności. Klucz `OrderItem` można modyfikować, ważną kwestią dla klas, które wynikają z <xref:System.Collections.ObjectModel.KeyedCollection%602>. Aby uzyskać przykładowy kod, który korzysta z kluczami modyfikowalny, zobacz <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection/cs/source.cs#1)]
 [!code-vb[KeyedCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IEqualityComparer`1" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected KeyedCollection (System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEqualityComparer`1&lt;!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (comparer As IEqualityComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; KeyedCollection(System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt; : System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt;" Usage="new System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt; comparer" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <param name="comparer">Implementacja <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> ogólny interfejs do użycia podczas porównywania kluczy lub <see langword="null" /> do użycia typ klucza, domyślny moduł porównujący równość uzyskany z <see cref="P:System.Collections.Generic.EqualityComparer`1.Default" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" /> klasę, która używa moduł porównujący równość określony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie <xref:System.Collections.ObjectModel.KeyedCollection%602> zawiera słownik wyszukiwania, który jest tworzony, gdy pierwszy element zostanie dodany. Po dodaniu elementu do <xref:System.Collections.ObjectModel.KeyedCollection%602>, klucz elementu jest wyodrębniany raz i zapisane w słowniku wyszukiwania, wyszukiwanie jest szybsze. To zachowanie można przesłonić przy użyciu <xref:System.Collections.ObjectModel.KeyedCollection%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%2CSystem.Int32%29> Konstruktor i określając próg Tworzenie słownika.  
  
> [!NOTE]
>  Ponieważ <xref:System.Collections.ObjectModel.KeyedCollection%602> klasa jest klasą abstrakcyjną (`MustInherit` w języku Visual Basic), musi pochodzić od niego, aby można było go używać. W Konstruktorze dla danego typu pochodnego, wywołaj odpowiedni <xref:System.Collections.ObjectModel.KeyedCollection%602> konstruktora. Nie jest wymagane do udostępnienia funkcji, takich jak moduł porównujący równość lub próg Tworzenie słownika w konstruktorach usługi.  
  
 Ten konstruktor jest operacją O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IEqualityComparer`1" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected KeyedCollection (System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer, int dictionaryCreationThreshold);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEqualityComparer`1&lt;!TKey&gt; comparer, int32 dictionaryCreationThreshold) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.#ctor(System.Collections.Generic.IEqualityComparer{`0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (comparer As IEqualityComparer(Of TKey), dictionaryCreationThreshold As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; KeyedCollection(System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer, int dictionaryCreationThreshold);" />
      <MemberSignature Language="F#" Value="new System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt; : System.Collections.Generic.IEqualityComparer&lt;'Key&gt; * int -&gt; System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt;" Usage="new System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt; (comparer, dictionaryCreationThreshold)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
        <Parameter Name="dictionaryCreationThreshold" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="comparer">Implementacja <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> ogólny interfejs do użycia podczas porównywania kluczy lub <see langword="null" /> do użycia typ klucza, domyślny moduł porównujący równość uzyskany z <see cref="P:System.Collections.Generic.EqualityComparer`1.Default" />.</param>
        <param name="dictionaryCreationThreshold">Liczba elementów w kolekcji może zawierać bez tworzenia słownika wyszukiwania (0 tworzy słownik wyszukiwania, gdy pierwszy element zostanie dodany), lub wartość -1, aby określić, czy słownik wyszukiwania nigdy nie został utworzony.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" /> klasę, która używa moduł porównujący równość określonego i tworzy słownik wyszukiwania w przypadku przekroczenia określonego progu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie <xref:System.Collections.ObjectModel.KeyedCollection%602> zawiera słownik wyszukiwania, który jest tworzony, gdy pierwszy element zostanie dodany. Po dodaniu elementu do <xref:System.Collections.ObjectModel.KeyedCollection%602>, klucz elementu jest wyodrębniany raz i zapisane w słowniku wyszukiwania, wyszukiwanie jest szybsze. Ten konstruktor pozwala na zastąpienie tego zachowania. Określ 0, aby utworzyć słownik po dodaniu pierwszego elementu, 1, aby utworzyć słownik po dodaniu drugiego elementu i tak dalej. Jeśli określisz wartość -1 jako wartość progową, słownika wyszukiwania nigdy nie zostanie utworzony.  
  
 Bardzo mały kolekcji poprawę szybkość pobierania dostarczone przez słownik wyszukiwania może nie być warte dodatkową pamięć wymagana przez słownika. Ustawienie progu pozwala zdecydować, kiedy ustawić tego kosztem.  
  
> [!NOTE]
>  Ponieważ <xref:System.Collections.ObjectModel.KeyedCollection%602> klasa jest klasą abstrakcyjną (`MustInherit` w języku Visual Basic), musi pochodzić od niego, aby można było go używać. W Konstruktorze dla danego typu pochodnego, wywołaj odpowiedni <xref:System.Collections.ObjectModel.KeyedCollection%602> konstruktora. Nie jest wymagane do udostępnienia funkcji, takich jak moduł porównujący równość lub próg Tworzenie słownika w konstruktorach usługi.  
  
 Ten konstruktor jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład kodu przedstawia sposób przesłonięcia chronionego <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, i <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> metody w celu zapewnienia niestandardowe zachowanie <xref:System.Collections.ObjectModel.Collection%601.Add%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A>, i <xref:System.Collections.ObjectModel.Collection%601.Clear%2A> metod i ustawienie domyślne <xref:System.Collections.ObjectModel.Collection%601.Item%2A> właściwości (indeksatora w języku C#). Niestandardowe zachowanie, które podano w tym przykładzie jest to zdarzenie powiadomienia o nazwie `Changed`, które jest wywoływane na końcu każdego zastąpionych metod.  
  
 Przykład kodu wykorzystuje <xref:System.Collections.ObjectModel.KeyedCollection%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%2CSystem.Int32%29> konstruktora z próg o wartości 0, tak aby słownik wewnętrzny jest tworzony po raz pierwszy obiekt zostanie dodany do kolekcji.  
  
 Przykład kodu tworzy `SimpleOrder` klasy, która jest pochodną <xref:System.Collections.ObjectModel.KeyedCollection%602> i reprezentuje kolejność prostego formularza. Formularz zawiera `OrderItem` obiekty reprezentujące elementy uporządkowane. Przykład kodu tworzy również `SimpleOrderChangedEventArgs` klasa może zawierać informacje o zdarzeniu i wyliczenia do identyfikowania typu zmiany.  
  
 Przykład kodu demonstruje niestandardowe zachowanie, wywołując właściwości i metody klasy pochodnej w `Main` metody `Demo` klasy.  
  
 Ten przykład kodu używa obiektów za pomocą niezmienialnych kluczy. Aby uzyskać przykładowy kod, który korzysta z kluczami modyfikowalny, zobacz <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection2#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection2/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection2#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection2/cs/source.cs#1)]
 [!code-vb[KeyedCollection2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="dictionaryCreationThreshold" /> jest mniejsza niż -1.</exception>
        <altmember cref="T:System.Collections.Generic.IEqualityComparer`1" />
      </Docs>
    </Member>
    <Member MemberName="ChangeItemKey">
      <MemberSignature Language="C#" Value="protected void ChangeItemKey (TItem item, TKey newKey);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ChangeItemKey(!TItem item, !TKey newKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.ChangeItemKey(`1,`0)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ChangeItemKey (item As TItem, newKey As TKey)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ChangeItemKey(TItem item, TKey newKey);" />
      <MemberSignature Language="F#" Value="member this.ChangeItemKey : 'Item * 'Key -&gt; unit" Usage="keyedCollection.ChangeItemKey (item, newKey)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="TItem" />
        <Parameter Name="newKey" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="item">Element, aby zmienić klucz.</param>
        <param name="newKey">Nowy klucz dla <paramref name="item" />.</param>
        <summary>Zmienia klucz skojarzony z określonym elementem w słowniku wyszukiwania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie powoduje modyfikacji klucz osadzone w `item`; po prostu zastępuje klucz zapisany w słowniku wyszukiwania.  W związku z tym jeśli `newKey` różni się od klucza, który jest osadzony w `item`, nie masz dostępu do `item` przy użyciu klucza zwróconego przez <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A>.  
  
 Ta metoda nie robi nic Jeśli <xref:System.Collections.ObjectModel.KeyedCollection%602> nie ma słownika wyszukiwania.  
  
 Każdy klucz w <xref:System.Collections.ObjectModel.KeyedCollection%602> muszą być unikatowe. Klucz nie może być `null`.  
  
 Ta metoda jest operacją O(1).  
  
## <a name="notes-for-implementers"></a>Uwagi dotyczące implementacji  
 Zanim klucz osadzone w elemencie, musi wywołać tę metodę, aby zaktualizować klucz w słowniku wyszukiwania. Jeśli próg tworzenia słownika jest wartość -1, wywołanie tej metody nie jest konieczne.  
  
 Nie ujawniaj <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A> metodę jako publiczna metoda klasy pochodnej. Niewłaściwe korzystanie z tej metody umieszcza słownika wyszukiwania zsynchronizowany przy użyciu kluczy elementu. Na przykład, ustawienie klucza `null` i ustawienie jej z inną wartością dodaje wiele kluczy dla elementu do słownika wyszukiwania. Udostępnianie tej metody wewnętrznie, aby umożliwić klucze modyfikowalnych elementów: Po zmianie klucza dla elementu, ta metoda jest używana do zmiany kluczem w słowniku wyszukiwania.  
  
   
  
## Examples  
 Poniższy przykład kodu przedstawia sposób przesłonięcia chronionego <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A> metody w celu obsługi mutable kluczy i sposób zastąpienia chronionego <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, i <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> metod w celu zachowania integralności kluczy i Kolekcja.  
  
 Przykład kodu tworzy `MutableKeys` kolekcji, która jest pochodną <xref:System.Collections.ObjectModel.KeyedCollection%602>i `MutableKey` klasy. `MutableKey` Klasa ma Ustawialne `Key` właściwości. Gdy nowy klucz jest przypisywane do właściwości, metody ustawiającej właściwość wywołuje `internal` (`Friend` w języku Visual Basic) `ChangeKey` metody kolekcji, aby sprawdzić, czy nowy klucz spowodowałoby to konflikt z istniejącego klucza. Jeśli tak, jest zgłaszany wyjątek, a nie ulega zmianie wartość właściwości.  
  
 Aby zachować połączenie między `MutableKey` obiektu i `MutableKeys` kolekcji i aby zapobiec obiektu jest wstawiany do dwóch kolekcji `MutableKey` klasa ma `internal` (`Friend` w języku Visual Basic) `Collection`pola. To pole jest obsługiwane przez metody chronione, które zapewniają niestandardowe zachowanie w przypadku dodawania i usuwania elementów z kolekcji, takie jak <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> metody. Pole jest ustawiona, gdy element zostanie dodany do kolekcji i wyczyszczone, gdy element zostanie usunięty.  
  
 [!code-csharp[KeyedCollectionMutable#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollectionMutable/cs/source.cs#1)]
 [!code-vb[KeyedCollectionMutable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollectionMutable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="item" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="key" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="item" /> Nie można odnaleźć.  
  
—lub— 
 <paramref name="key" /> istnieje już w <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />.</exception>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.GetKeyForItem(`1)" />
        <altmember cref="P:System.Collections.ObjectModel.KeyedCollection`2.Item(`0)" />
      </Docs>
    </Member>
    <Member MemberName="ClearItems">
      <MemberSignature Language="C#" Value="protected override void ClearItems ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void ClearItems() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.ClearItems" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub ClearItems ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void ClearItems();" />
      <MemberSignature Language="F#" Value="override this.ClearItems : unit -&gt; unit" Usage="keyedCollection.ClearItems " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa wszystkie elementy z <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku słownika wyszukiwania, ta metoda usuwa go, ale nie spowoduje usunięcia go.  
  
 Jeśli liczba elementów został przekroczony próg Tworzenie słownika i <xref:System.Collections.ObjectModel.KeyedCollection%602> jest przy użyciu słownika wyszukiwania, nadal będzie użyć słownika wyszukiwania, mimo że liczba elementów, które jest ponownie od wartości progowej.  
  
 Ta metoda jest O (`n`) operacji, gdzie `n` jest <xref:System.Collections.ObjectModel.Collection%601.Count%2A>.  
  
## <a name="notes-for-implementers"></a>Uwagi dotyczące implementacji  
 Przesłonić tę metodę, aby zapewnić zachowanie niestandardowe <xref:System.Collections.ObjectModel.Collection%601.Clear%2A> metody dziedziczone z <xref:System.Collections.ObjectModel.Collection%601> klasy ogólnej.  
  
 Wywołanie tej metody, aby wyczyścić kolekcji źródłowej, a także można wyczyścić słownika wyszukiwania implementacji klasy podstawowej.  
  
   
  
## Examples  
 Ta sekcja zawiera dwa przykłady kodu, które pokazują, zastępowanie <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A> metody w celu zapewnienia niestandardowe zachowanie czyszczenia wszystkich obiektów z kolekcji. Pierwszy przykład dodaje zdarzenie niestandardowe powiadomienie, a drugi zapewnia obsługę kolekcji obiektów za pomocą tych kluczy.  
  
 Przykład 1  
  
 Poniższy przykład kodu przedstawia sposób przesłonięcia chronionego <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, i <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> metody w celu zapewnienia niestandardowe zachowanie <xref:System.Collections.ObjectModel.Collection%601.Add%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A>, i <xref:System.Collections.ObjectModel.Collection%601.Clear%2A> metod i ustawienie domyślne <xref:System.Collections.ObjectModel.Collection%601.Item%2A> właściwości (indeksatora w języku C#). Niestandardowe zachowanie, które podano w tym przykładzie jest to zdarzenie powiadomienia o nazwie `Changed`, które jest wywoływane na końcu każdego zastąpionych metod.  
  
 Przykład kodu tworzy `SimpleOrder` klasy, która jest pochodną <xref:System.Collections.ObjectModel.KeyedCollection%602> i reprezentuje kolejność prostego formularza. Formularz zawiera `OrderItem` obiekty reprezentujące elementy uporządkowane. Przykład kodu tworzy również `SimpleOrderChangedEventArgs` klasa może zawierać informacje o zdarzeniu i wyliczenia do identyfikowania typu zmiany.  
  
 Przykład kodu demonstruje niestandardowe zachowanie, wywołując właściwości i metody klasy pochodnej w `Main` metody `Demo` klasy.  
  
 Ten przykład kodu używa obiektów za pomocą niezmienialnych kluczy. Aby uzyskać przykładowy kod, który korzysta z kluczami modyfikowalny, zobacz <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection2#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection2/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection2#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection2/cs/source.cs#1)]
 [!code-vb[KeyedCollection2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection2/vb/source.vb#1)]  
  
 Przykład 2  
  
 Poniższy przykład kodu przedstawia sposób przesłonięcia chronionego <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A> metody w celu obsługi mutable kluczy i sposób zastąpienia chronionego <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, i <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> metod w celu zachowania integralności kluczy i Kolekcja.  
  
 Przykład kodu tworzy `MutableKeys` kolekcji, która jest pochodną <xref:System.Collections.ObjectModel.KeyedCollection%602>i `MutableKey` klasy. `MutableKey` Klasa ma Ustawialne `Key` właściwości. Gdy nowy klucz jest przypisywane do właściwości, metody ustawiającej właściwość wywołuje `internal` (`Friend` w języku Visual Basic) `ChangeKey` metody kolekcji, aby sprawdzić, czy nowy klucz spowodowałoby to konflikt z istniejącego klucza. Jeśli tak, jest zgłaszany wyjątek, a nie ulega zmianie wartość właściwości.  
  
 Aby zachować połączenie między `MutableKey` obiektu i `MutableKeys` kolekcji i aby zapobiec obiektu jest wstawiany do dwóch kolekcji `MutableKey` klasa ma `internal` (`Friend` w języku Visual Basic) `Collection`pola. To pole jest obsługiwane przez metody chronione, które zapewniają niestandardowe zachowanie w przypadku dodawania i usuwania elementów z kolekcji, takie jak <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> metody. Pole jest ustawiona, gdy element zostanie dodany do kolekcji i wyczyszczone, gdy element zostanie usunięty.  
  
 [!code-csharp[KeyedCollectionMutable#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollectionMutable/cs/source.cs#1)]
 [!code-vb[KeyedCollectionMutable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollectionMutable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.Remove(`0)" />
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.RemoveItem(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Comparer">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEqualityComparer&lt;TKey&gt; Comparer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEqualityComparer`1&lt;!TKey&gt; Comparer" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ObjectModel.KeyedCollection`2.Comparer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Comparer As IEqualityComparer(Of TKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ Comparer { System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Comparer : System.Collections.Generic.IEqualityComparer&lt;'Key&gt;" Usage="System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt;.Comparer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEqualityComparer&lt;TKey&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera modułu porównującego równości ogólny, który służy do określania równości kluczy w kolekcji.</summary>
        <value>Implementacja <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> ogólny interfejs, który służy do określania równości kluczy w kolekcji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.Contains(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (key As TKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(TKey key);" />
      <MemberSignature Language="F#" Value="override this.Contains : 'Key -&gt; bool" Usage="keyedCollection.Contains key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Klucz do zlokalizowania w <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />.</param>
        <summary>Określa, czy kolekcja zawiera element z określonym kluczem.</summary>
        <returns><see langword="true" /> Jeśli <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" /> zawiera element z określonym kluczem, a w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Collections.ObjectModel.KeyedCollection%602> ma słownika wyszukiwania `key` służy do wyszukiwania słownika. W przypadku żaden słownik wyszukiwania klucza każdy element jest wyodrębniany przy użyciu <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> metody i w porównaniu z określonym kluczem.  
  
 Ta metoda jest operacją O(1), jeśli <xref:System.Collections.ObjectModel.KeyedCollection%602> ma słownik wyszukiwanie; w przeciwnym razie jest O (`n`) operacji, gdzie `n` jest <xref:System.Collections.ObjectModel.Collection%601.Count%2A>.  
  
   
  
## Examples  
 Ten przykład kodu pokazuje kod minimalne należy wyprowadzić klasę z kolekcji <xref:System.Collections.ObjectModel.KeyedCollection%602>: zastępowanie <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> metody i zapewniając Konstruktor publiczny, który deleguje do konstruktora klasy bazowej. W przykładzie kodu pokazano również wiele właściwości i metod odziedziczone <xref:System.Collections.ObjectModel.KeyedCollection%602> i <xref:System.Collections.ObjectModel.Collection%601> klasy.  
  
 `SimpleOrder` Klasa jest lista zapotrzebowania bardzo prosty, która zawiera `OrderItem` obiektów, z których każdy reprezentuje elementu wiersza w kolejności. Klucz `OrderItem` można modyfikować, ważną kwestią dla klas, które wynikają z <xref:System.Collections.ObjectModel.KeyedCollection%602>. Aby uzyskać przykładowy kod, który korzysta z kluczami modyfikowalny, zobacz <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection/cs/source.cs#1)]
 [!code-vb[KeyedCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.GetKeyForItem(`1)" />
      </Docs>
    </Member>
    <Member MemberName="Dictionary">
      <MemberSignature Language="C#" Value="protected System.Collections.Generic.IDictionary&lt;TKey,TItem&gt; Dictionary { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IDictionary`2&lt;!TKey, !TItem&gt; Dictionary" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ObjectModel.KeyedCollection`2.Dictionary" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Dictionary As IDictionary(Of TKey, TItem)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::Generic::IDictionary&lt;TKey, TItem&gt; ^ Dictionary { System::Collections::Generic::IDictionary&lt;TKey, TItem&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Dictionary : System.Collections.Generic.IDictionary&lt;'Key, 'Item&gt;" Usage="System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt;.Dictionary" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;TKey,TItem&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera słownik wyszukiwania <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />.</summary>
        <value>Słownik wyszukiwania <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />, jeśli taki istnieje; w przeciwnym razie <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie <xref:System.Collections.ObjectModel.KeyedCollection%602> zawiera słownik wyszukiwania, który jest tworzony, gdy pierwszy element zostanie dodany. Po dodaniu elementu do <xref:System.Collections.ObjectModel.KeyedCollection%602>, klucz elementu jest wyodrębniany raz i zapisane w słowniku wyszukiwania, wyszukiwanie jest szybsze. To zachowanie można przesłonić przy użyciu <xref:System.Collections.ObjectModel.KeyedCollection%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%2CSystem.Int32%29> Konstruktor i określając próg Tworzenie słownika.  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład kodu przedstawia sposób przesłonięcia chronionego <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A> metody w celu obsługi mutable kluczy i sposób zastąpienia chronionego <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, i <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> metod w celu zachowania integralności kluczy i Kolekcja.  
  
 Przykład kodu tworzy `MutableKeys` kolekcji, która jest pochodną <xref:System.Collections.ObjectModel.KeyedCollection%602>i `MutableKey` klasy. `MutableKey` Klasa ma Ustawialne `Key` właściwości. Gdy nowy klucz jest przypisywane do właściwości, metody ustawiającej właściwość wywołuje `internal` (`Friend` w języku Visual Basic) `ChangeKey` metody kolekcji, aby sprawdzić, czy nowy klucz spowodowałoby to konflikt z istniejącego klucza. Jeśli tak, jest zgłaszany wyjątek, a nie ulega zmianie wartość właściwości.  
  
 Aby zachować połączenie między `MutableKey` obiektu i `MutableKeys` kolekcji i aby zapobiec obiektu jest wstawiany do dwóch kolekcji `MutableKey` klasa ma `internal` (`Friend` w języku Visual Basic) `Collection`pola. To pole jest obsługiwane przez metody chronione, które zapewniają niestandardowe zachowanie w przypadku dodawania i usuwania elementów z kolekcji, takie jak <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> metody. Pole jest ustawiona, gdy element zostanie dodany do kolekcji i wyczyszczone, gdy element zostanie usunięty.  
  
 [!code-csharp[KeyedCollectionMutable#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollectionMutable/cs/source.cs#1)]
 [!code-vb[KeyedCollectionMutable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollectionMutable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IDictionary`2" />
      </Docs>
    </Member>
    <Member MemberName="GetKeyForItem">
      <MemberSignature Language="C#" Value="protected abstract TKey GetKeyForItem (TItem item);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance !TKey GetKeyForItem(!TItem item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.GetKeyForItem(`1)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetKeyForItem (item As TItem) As TKey" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract TKey GetKeyForItem(TItem item);" />
      <MemberSignature Language="F#" Value="abstract member GetKeyForItem : 'Item -&gt; 'Key" Usage="keyedCollection.GetKeyForItem item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="TItem" />
      </Parameters>
      <Docs>
        <param name="item">Element, z którego ma zostać wyodrębniony klucz.</param>
        <summary>Po zaimplementowaniu w klasie pochodnej, wyodrębnia klucz z określonego elementu.</summary>
        <returns>Klucz dla określonego elementu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli kluczem w słowniku wyszukiwania jest inny niż klucz, który jest osadzony w `item`, nie masz dostępu do `item` przy użyciu klucza zwróconego przez <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A>.  
  
 Możesz zaimplementować tę metodę, aby zwrócić `null` dla kolekcji, która zawiera elementy, bez kluczy, w którym to przypadku elementy są dostępne tylko za pomocą ich indeksu. Ta metoda jest operacją O(1).  
  
## <a name="notes-for-implementers"></a>Uwagi dotyczące implementacji  
 Należy przesłonić tę metodę, aby zapewnić słownika umożliwia prowadzenie klucze elementów w słowniku.  
  
 Ta metoda jest wywoływana wewnętrznie. Nie jest konieczne, aby mogła być publiczne.  
  
   
  
## Examples  
 Ten przykład kodu pokazuje kod minimalne należy wyprowadzić klasę z kolekcji <xref:System.Collections.ObjectModel.KeyedCollection%602>: zastępowanie <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> metody i zapewniając Konstruktor publiczny, który deleguje do konstruktora klasy bazowej. W przykładzie kodu pokazano również wiele właściwości i metod odziedziczone <xref:System.Collections.ObjectModel.KeyedCollection%602> i <xref:System.Collections.ObjectModel.Collection%601> klasy.  
  
 `SimpleOrder` Klasa jest lista zapotrzebowania bardzo prosty, która zawiera `OrderItem` obiektów, z których każdy reprezentuje elementu wiersza w kolejności. Klucz `OrderItem` można modyfikować, ważną kwestią dla klas, które wynikają z <xref:System.Collections.ObjectModel.KeyedCollection%602>. Aby uzyskać przykładowy kod, który korzysta z kluczami modyfikowalny, zobacz <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection/cs/source.cs#1)]
 [!code-vb[KeyedCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.ChangeItemKey(`1,`0)" />
        <altmember cref="P:System.Collections.ObjectModel.KeyedCollection`2.Item(`0)" />
      </Docs>
    </Member>
    <Member MemberName="InsertItem">
      <MemberSignature Language="C#" Value="protected override void InsertItem (int index, TItem item);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void InsertItem(int32 index, !TItem item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.InsertItem(System.Int32,`1)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub InsertItem (index As Integer, item As TItem)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void InsertItem(int index, TItem item);" />
      <MemberSignature Language="F#" Value="override this.InsertItem : int * 'Item -&gt; unit" Usage="keyedCollection.InsertItem (index, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="TItem" />
      </Parameters>
      <Docs>
        <param name="index">Liczony od zera indeks, w którym <paramref name="item" /> powinien zostać wstawiony.</param>
        <param name="item">Obiekt do wstawienia.</param>
        <summary>Wstawia element do <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" /> pod określonym indeksem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `index` jest równa <xref:System.Collections.ObjectModel.Collection%601.Count%2A>, `item` zostanie dodany na końcu <xref:System.Collections.ObjectModel.KeyedCollection%602>.  
  
 Ta metoda jest O (`n`) operacji, gdzie `n` jest <xref:System.Collections.ObjectModel.Collection%601.Count%2A>.  
  
 <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> jest wywoływana przez <xref:System.Collections.ObjectModel.Collection%601.Add%2A> i <xref:System.Collections.ObjectModel.Collection%601.Insert%2A> metody.  
  
## <a name="notes-for-implementers"></a>Uwagi dotyczące implementacji  
 Przesłonić tę metodę, aby zapewnić zachowanie niestandardowe <xref:System.Collections.ObjectModel.Collection%601.Add%2A> i <xref:System.Collections.ObjectModel.Collection%601.Insert%2A> metod odziedziczone <xref:System.Collections.ObjectModel.Collection%601> klasy ogólnej.  
  
 Wywołania implementacji klasy podstawowej przez tę metodę, aby wstawić element do kolekcji źródłowej oraz do aktualizowania słownika wyszukiwania.  
  
   
  
## Examples  
 Ta sekcja zawiera dwa przykłady kodu, które pokazują, zastępowanie <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> metody w celu zapewnienia zachowania niestandardowe do dodawania lub wstawianie obiektów do kolekcji. Pierwszy przykład dodaje zdarzenie niestandardowe powiadomienie, a drugi zapewnia obsługę kolekcji obiektów za pomocą tych kluczy.  
  
 Przykład 1  
  
 Poniższy przykład kodu przedstawia sposób przesłonięcia chronionego <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, i <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> metody w celu zapewnienia niestandardowe zachowanie <xref:System.Collections.ObjectModel.Collection%601.Add%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A>, i <xref:System.Collections.ObjectModel.Collection%601.Clear%2A> metod i ustawienie domyślne <xref:System.Collections.ObjectModel.Collection%601.Item%2A> właściwości (indeksatora w języku C#). Niestandardowe zachowanie, które podano w tym przykładzie jest to zdarzenie powiadomienia o nazwie `Changed`, które jest wywoływane na końcu każdego zastąpionych metod.  
  
 Przykład kodu tworzy `SimpleOrder` klasy, która jest pochodną <xref:System.Collections.ObjectModel.KeyedCollection%602> i reprezentuje kolejność prostego formularza. Formularz zawiera `OrderItem` obiekty reprezentujące elementy uporządkowane. Przykład kodu tworzy również `SimpleOrderChangedEventArgs` klasa może zawierać informacje o zdarzeniu i wyliczenia do identyfikowania typu zmiany.  
  
 Przykład kodu demonstruje niestandardowe zachowanie, wywołując właściwości i metody klasy pochodnej w `Main` metody `Demo` klasy.  
  
 Ten przykład kodu używa obiektów za pomocą niezmienialnych kluczy. Aby uzyskać przykładowy kod, który korzysta z kluczami modyfikowalny, zobacz <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection2#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection2/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection2#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection2/cs/source.cs#1)]
 [!code-vb[KeyedCollection2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection2/vb/source.vb#1)]  
  
 Przykład 2  
  
 Poniższy przykład kodu przedstawia sposób przesłonięcia chronionego <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A> metody w celu obsługi mutable kluczy i sposób zastąpienia chronionego <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, i <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> metod w celu zachowania integralności kluczy i Kolekcja.  
  
 Przykład kodu tworzy `MutableKeys` kolekcji, która jest pochodną <xref:System.Collections.ObjectModel.KeyedCollection%602>i `MutableKey` klasy. `MutableKey` Klasa ma Ustawialne `Key` właściwości. Gdy nowy klucz jest przypisywane do właściwości, metody ustawiającej właściwość wywołuje `internal` (`Friend` w języku Visual Basic) `ChangeKey` metody kolekcji, aby sprawdzić, czy nowy klucz spowodowałoby to konflikt z istniejącego klucza. Jeśli tak, jest zgłaszany wyjątek, a nie ulega zmianie wartość właściwości.  
  
 Aby zachować połączenie między `MutableKey` obiektu i `MutableKeys` kolekcji i aby zapobiec obiektu jest wstawiany do dwóch kolekcji `MutableKey` klasa ma `internal` (`Friend` w języku Visual Basic) `Collection`pola. To pole jest obsługiwane przez metody chronione, które zapewniają niestandardowe zachowanie w przypadku dodawania i usuwania elementów z kolekcji, takie jak <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> metody. Pole jest ustawiona, gdy element zostanie dodany do kolekcji i wyczyszczone, gdy element zostanie usunięty.  
  
 [!code-csharp[KeyedCollectionMutable#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollectionMutable/cs/source.cs#1)]
 [!code-vb[KeyedCollectionMutable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollectionMutable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> jest mniejsza niż 0.  
  
—lub— 
 <paramref name="index" /> jest większa niż <see cref="P:System.Collections.ObjectModel.Collection`1.Count" />.</exception>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.SetItem(System.Int32,`1)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public TItem this[TKey key] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !TItem Item(!TKey)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ObjectModel.KeyedCollection`2.Item(`0)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(key As TKey) As TItem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TItem default[TKey] { TItem get(TKey key); };" />
      <MemberSignature Language="F#" Value="member this.Item('Key) : 'Item" Usage="System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt;.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Klucz elementu do pobrania.</param>
        <summary>Pobiera element z określonym kluczem.</summary>
        <value>Element z określonym kluczem. Jeśli element z określonym kluczem nie zostanie znaleziony, jest zgłaszany wyjątek.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość umożliwia dostęp do określonego elementu w kolekcji przy użyciu następującej składni: `myCollection[key]` (`myCollection(key)` w języku Visual Basic).  
  
> [!NOTE]
>  Właściwość ta różni się od dziedziczonego <xref:System.Collections.ObjectModel.Collection%601.Item%2A?displayProperty=nameWithType> właściwość, która pobiera i ustawia elementów według indeksu liczbowego. Jednak jeśli `TKey` typu <xref:System.Int32>, ta właściwość maskuje właściwość dziedziczona. W takim przypadku możesz uzyskać dostęp właściwość dziedziczona przez rzutowanie <xref:System.Collections.ObjectModel.KeyedCollection%602> na jego typ bazowy. Na przykład `KeyedCollection<int, MyType>` (`KeyedCollection(Of Integer, MyType)` w języku Visual Basic `KeyedCollection<int, MyType^>` w języku C++) mogą być rzutowane na `Collection<MyType>` (`Collection(Of MyType)` w języku Visual Basic `Collection<MyType^>` w języku C++).  
  
 Jeśli <xref:System.Collections.ObjectModel.KeyedCollection%602> ma słownika wyszukiwania `key` służy do pobierania elementu ze słownika.  W przypadku żaden słownik wyszukiwania klucza każdy element jest wyodrębniany przy użyciu <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> metody i w porównaniu z określonym kluczem.  
  
 W języku C# używa słowa kluczowego w celu zdefiniowania indeksatorów, a nie Implementowanie <xref:System.Collections.ObjectModel.KeyedCollection%602.Item%2A> właściwości. Implementuje języka Visual Basic <xref:System.Collections.ObjectModel.KeyedCollection%602.Item%2A> jako właściwość domyślną, która zapewnia taką samą funkcjonalność indeksowania.  
  
 Pobieranie wartości tej właściwości jest operacją O(1), jeśli <xref:System.Collections.ObjectModel.KeyedCollection%602> ma słownik wyszukiwanie; w przeciwnym razie jest O (`n`) operacji, gdzie `n` jest <xref:System.Collections.ObjectModel.Collection%601.Count%2A>.  
  
   
  
## Examples  
 Ten przykład kodu pokazuje kod minimalne należy wyprowadzić klasę z kolekcji <xref:System.Collections.ObjectModel.KeyedCollection%602>: zastępowanie <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> metody i zapewniając Konstruktor publiczny, który deleguje do konstruktora klasy bazowej. W przykładzie kodu pokazano również wiele właściwości i metod odziedziczone <xref:System.Collections.ObjectModel.KeyedCollection%602> i <xref:System.Collections.ObjectModel.Collection%601> klasy.  
  
 Przykładowy kod wywołuje zarówno <xref:System.Collections.ObjectModel.KeyedCollection%602.Item%2A?displayProperty=nameWithType> właściwość, która jest tylko do odczytu, a następnie pobiera według klucza, a <xref:System.Collections.ObjectModel.Collection%601.Item%2A?displayProperty=nameWithType> właściwości można ustawić, która pobiera według indeksu. Widoczny jest sposób uzyskiwać dostęp do jego właściwości w przypadku obiektów pochodnych kolekcji mają klucze liczby całkowitej, nie do odróżnienia od liczb całkowitych, użyte do pobierania indeksowanego.  
  
 `SimpleOrder` Klasa jest lista zapotrzebowania bardzo prosty, która zawiera `OrderItem` obiektów, z których każdy reprezentuje elementu wiersza w kolejności. Klucz `OrderItem` można modyfikować, ważną kwestią dla klas, które wynikają z <xref:System.Collections.ObjectModel.KeyedCollection%602>. Aby uzyskać przykładowy kod, który korzysta z kluczami modyfikowalny, zobacz <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection/cs/source.cs#1)]
 [!code-vb[KeyedCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Collections.Generic.KeyNotFoundException">Element z określonym kluczem nie istnieje w kolekcji.</exception>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.SetItem(System.Int32,`1)" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Remove(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (key As TKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Remove(TKey key);" />
      <MemberSignature Language="F#" Value="override this.Remove : 'Key -&gt; bool" Usage="keyedCollection.Remove key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Klucz elementu do usunięcia.</param>
        <summary>Usuwa element z określonym kluczem z <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />.</summary>
        <returns><see langword="true" /> Jeśli element został pomyślnie usunięty; w przeciwnym razie <see langword="false" />.  Ta metoda zwraca też wartość <see langword="false" /> Jeśli <paramref name="key" /> nie zostanie znaleziony w <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klucz elementu jest również usuwana ze słownika wyszukiwania.  
  
 Jeśli liczba elementów został przekroczony próg Tworzenie słownika i <xref:System.Collections.ObjectModel.KeyedCollection%602> jest przy użyciu słownika wyszukiwania, nadal będzie użyć słownika wyszukiwania, mimo że liczba elementów, które jest ponownie od wartości progowej.  
  
> [!NOTE]
>  Aby dostosować zachowanie tej metody, należy zastąpić <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A> metody.  
  
 Ta metoda jest O (`n`) operacji, gdzie `n` jest <xref:System.Collections.ObjectModel.Collection%601.Count%2A>.  
  
   
  
## Examples  
 Ten przykład kodu pokazuje kod minimalne należy wyprowadzić klasę z kolekcji <xref:System.Collections.ObjectModel.KeyedCollection%602>: zastępowanie <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> metody i zapewniając Konstruktor publiczny, który deleguje do konstruktora klasy bazowej. W przykładzie kodu pokazano również wiele właściwości i metod odziedziczone <xref:System.Collections.ObjectModel.KeyedCollection%602> i <xref:System.Collections.ObjectModel.Collection%601> klasy.  
  
 W przykładzie pokazano <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A> metody dziedziczone z <xref:System.Collections.ObjectModel.KeyedCollection%602>, który usuwa element z określonym kluczem, a także <xref:System.Collections.ObjectModel.Collection%601.Remove%2A> i <xref:System.Collections.ObjectModel.Collection%601.RemoveAt%2A> metod odziedziczone <xref:System.Collections.ObjectModel.Collection%601>, którego usunięcie przez obiekt i za pomocą indeksu odpowiednio.  
  
 `SimpleOrder` Klasa jest lista zapotrzebowania bardzo prosty, która zawiera `OrderItem` obiektów, z których każdy reprezentuje elementu wiersza w kolejności. Klucz `OrderItem` można modyfikować, ważną kwestią dla klas, które wynikają z <xref:System.Collections.ObjectModel.KeyedCollection%602>. Aby uzyskać przykładowy kod, który korzysta z kluczami modyfikowalny, zobacz <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection/cs/source.cs#1)]
 [!code-vb[KeyedCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> jest <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.RemoveItem(System.Int32)" />
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.ClearItems" />
      </Docs>
    </Member>
    <Member MemberName="RemoveItem">
      <MemberSignature Language="C#" Value="protected override void RemoveItem (int index);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void RemoveItem(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.RemoveItem(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub RemoveItem (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void RemoveItem(int index);" />
      <MemberSignature Language="F#" Value="override this.RemoveItem : int -&gt; unit" Usage="keyedCollection.RemoveItem index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Indeks elementu do usunięcia.</param>
        <summary>Usuwa element o określonym indeksie <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klucz elementu jest również usuwana ze słownika wyszukiwania.  
  
 Jeśli liczba elementów został przekroczony próg Tworzenie słownika i <xref:System.Collections.ObjectModel.KeyedCollection%602> jest przy użyciu słownika wyszukiwania, nadal będzie użyć słownika wyszukiwania, mimo że liczba elementów, które jest ponownie od wartości progowej.  
  
 Ta metoda jest O (`n`) operacji, gdzie `n` jest <xref:System.Collections.ObjectModel.Collection%601.Count%2A>.  
  
## <a name="notes-for-implementers"></a>Uwagi dotyczące implementacji  
 Przesłonić tę metodę, aby zapewnić zachowanie niestandardowe <xref:System.Collections.ObjectModel.Collection%601.Remove%28%600%29> i <xref:System.Collections.ObjectModel.Collection%601.RemoveAt%28System.Int32%29> metod odziedziczone <xref:System.Collections.ObjectModel.Collection%601> klasy generycznej i <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%28%600%29> metody.  
  
 Wywołania implementacji klasy podstawowej przez tę metodę, aby usunąć element z kolekcji źródłowej i aktualizowanie słownika wyszukiwania.  
  
   
  
## Examples  
 Ta sekcja zawiera dwa przykłady kodu, które pokazują, zastępowanie <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A> metody w celu zapewnienia zachowania niestandardowe do usuwania obiektów z kolekcji. Pierwszy przykład dodaje zdarzenie niestandardowe powiadomienie, a drugi zapewnia obsługę kolekcji obiektów za pomocą tych kluczy.  
  
 Przykład 1  
  
 Poniższy przykład kodu przedstawia sposób przesłonięcia chronionego <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, i <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> metody w celu zapewnienia niestandardowe zachowanie <xref:System.Collections.ObjectModel.Collection%601.Add%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A>, i <xref:System.Collections.ObjectModel.Collection%601.Clear%2A> metod i ustawienie domyślne <xref:System.Collections.ObjectModel.Collection%601.Item%2A> właściwości (indeksatora w języku C#). Niestandardowe zachowanie, które podano w tym przykładzie jest to zdarzenie powiadomienia o nazwie `Changed`, które jest wywoływane na końcu każdego zastąpionych metod.  
  
 Przykład kodu tworzy `SimpleOrder` klasy, która jest pochodną <xref:System.Collections.ObjectModel.KeyedCollection%602> i reprezentuje kolejność prostego formularza. Formularz zawiera `OrderItem` obiekty reprezentujące elementy uporządkowane. Przykład kodu tworzy również `SimpleOrderChangedEventArgs` klasa może zawierać informacje o zdarzeniu i wyliczenia do identyfikowania typu zmiany.  
  
 Przykład kodu demonstruje niestandardowe zachowanie, wywołując właściwości i metody klasy pochodnej w `Main` metody `Demo` klasy.  
  
 Ten przykład kodu używa obiektów za pomocą niezmienialnych kluczy. Aby uzyskać przykładowy kod, który korzysta z kluczami modyfikowalny, zobacz <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection2#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection2/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection2#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection2/cs/source.cs#1)]
 [!code-vb[KeyedCollection2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection2/vb/source.vb#1)]  
  
 Przykład 2  
  
 Poniższy przykład kodu przedstawia sposób przesłonięcia chronionego <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A> metody w celu obsługi mutable kluczy i sposób zastąpienia chronionego <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, i <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> metod w celu zachowania integralności kluczy i Kolekcja.  
  
 Przykład kodu tworzy `MutableKeys` kolekcji, która jest pochodną <xref:System.Collections.ObjectModel.KeyedCollection%602>i `MutableKey` klasy. `MutableKey` Klasa ma Ustawialne `Key` właściwości. Gdy nowy klucz jest przypisywane do właściwości, metody ustawiającej właściwość wywołuje `internal` (`Friend` w języku Visual Basic) `ChangeKey` metody kolekcji, aby sprawdzić, czy nowy klucz spowodowałoby to konflikt z istniejącego klucza. Jeśli tak, jest zgłaszany wyjątek, a nie ulega zmianie wartość właściwości.  
  
 Aby zachować połączenie między `MutableKey` obiektu i `MutableKeys` kolekcji i aby zapobiec obiektu jest wstawiany do dwóch kolekcji `MutableKey` klasa ma `internal` (`Friend` w języku Visual Basic) `Collection`pola. To pole jest obsługiwane przez metody chronione, które zapewniają niestandardowe zachowanie w przypadku dodawania i usuwania elementów z kolekcji, takie jak <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> metody. Pole jest ustawiona, gdy element zostanie dodany do kolekcji i wyczyszczone, gdy element zostanie usunięty.  
  
 [!code-csharp[KeyedCollectionMutable#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollectionMutable/cs/source.cs#1)]
 [!code-vb[KeyedCollectionMutable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollectionMutable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.Remove(`0)" />
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.ClearItems" />
      </Docs>
    </Member>
    <Member MemberName="SetItem">
      <MemberSignature Language="C#" Value="protected override void SetItem (int index, TItem item);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void SetItem(int32 index, !TItem item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.SetItem(System.Int32,`1)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub SetItem (index As Integer, item As TItem)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void SetItem(int index, TItem item);" />
      <MemberSignature Language="F#" Value="override this.SetItem : int * 'Item -&gt; unit" Usage="keyedCollection.SetItem (index, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="TItem" />
      </Parameters>
      <Docs>
        <param name="index">Liczony od zera indeks elementu, który ma zostać zastąpione.</param>
        <param name="item">Nowy element.</param>
        <summary>Zamienia określony element element pod określonym indeksem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Słownik wyszukiwania jest odpowiednio aktualizowana. Oznacza to, że klucz elementu, który jest zastępowany został usunięty ze słownika wyszukiwania i klucza nowy element zostanie dodany.  
  
 Ta metoda jest operacją O(1).  
  
## <a name="notes-for-implementers"></a>Uwagi dotyczące implementacji  
 Przesłonić tę metodę, aby zapewnić zachowanie niestandardowe ustawienia <xref:System.Collections.ObjectModel.Collection%601.Item%2A> właściwość dziedziczona z <xref:System.Collections.ObjectModel.Collection%601> klasy ogólnej.  
  
> [!NOTE]
>  Ta metoda nie ma wpływu na zachowanie <xref:System.Collections.ObjectModel.KeyedCollection%602.Item%2A?displayProperty=nameWithType> właściwość, która jest tylko do odczytu.  
  
 Wywołania implementacji klasy podstawowej przez tę metodę, aby ustawić element w kolekcji źródłowej oraz do aktualizowania słownika wyszukiwania.  
  
   
  
## Examples  
 Ta sekcja zawiera dwa przykłady kodu, które pokazują, zastępowanie <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> metodę, aby zapewnić zachowanie niestandardowe ustawienia <xref:System.Collections.ObjectModel.Collection%601.Item%2A?displayProperty=nameWithType> właściwości. Pierwszy przykład dodaje zdarzenie niestandardowe powiadomienie, a drugi zapewnia obsługę kolekcji obiektów za pomocą tych kluczy.  
  
 Przykład 1  
  
 Poniższy przykład kodu przedstawia sposób przesłonięcia chronionego <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, i <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> metody w celu zapewnienia niestandardowe zachowanie <xref:System.Collections.ObjectModel.Collection%601.Add%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A>, i <xref:System.Collections.ObjectModel.Collection%601.Clear%2A> metod i ustawienie domyślne <xref:System.Collections.ObjectModel.Collection%601.Item%2A> właściwości (indeksatora w języku C#). Niestandardowe zachowanie, które podano w tym przykładzie jest to zdarzenie powiadomienia o nazwie `Changed`, które jest wywoływane na końcu każdego zastąpionych metod.  
  
 Przykład kodu tworzy `SimpleOrder` klasy, która jest pochodną <xref:System.Collections.ObjectModel.KeyedCollection%602> i reprezentuje kolejność prostego formularza. Formularz zawiera `OrderItem` obiekty reprezentujące elementy uporządkowane. Przykład kodu tworzy również `SimpleOrderChangedEventArgs` klasa może zawierać informacje o zdarzeniu i wyliczenia do identyfikowania typu zmiany.  
  
 Przykład kodu demonstruje niestandardowe zachowanie, wywołując właściwości i metody klasy pochodnej w `Main` metody `Demo` klasy.  
  
 Ten przykład kodu używa obiektów za pomocą niezmienialnych kluczy. Aby uzyskać przykładowy kod, który korzysta z kluczami modyfikowalny, zobacz <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>.  
  
 [!code-cpp[KeyedCollection2#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection2/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection2#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection2/cs/source.cs#1)]
 [!code-vb[KeyedCollection2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection2/vb/source.vb#1)]  
  
 Przykład 2  
  
 Poniższy przykład kodu przedstawia sposób przesłonięcia chronionego <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A> metody w celu obsługi mutable kluczy i sposób zastąpienia chronionego <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>, <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>, i <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> metod w celu zachowania integralności kluczy i Kolekcja.  
  
 Przykład kodu tworzy `MutableKeys` kolekcji, która jest pochodną <xref:System.Collections.ObjectModel.KeyedCollection%602>i `MutableKey` klasy. `MutableKey` Klasa ma Ustawialne `Key` właściwości. Gdy nowy klucz jest przypisywane do właściwości, metody ustawiającej właściwość wywołuje `internal` (`Friend` w języku Visual Basic) `ChangeKey` metody kolekcji, aby sprawdzić, czy nowy klucz spowodowałoby to konflikt z istniejącego klucza. Jeśli tak, jest zgłaszany wyjątek, a nie ulega zmianie wartość właściwości.  
  
 Aby zachować połączenie między `MutableKey` obiektu i `MutableKeys` kolekcji i aby zapobiec obiektu jest wstawiany do dwóch kolekcji `MutableKey` klasa ma `internal` (`Friend` w języku Visual Basic) `Collection`pola. To pole jest obsługiwane przez metody chronione, które zapewniają niestandardowe zachowanie w przypadku dodawania i usuwania elementów z kolekcji, takie jak <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> metody. Pole jest ustawiona, gdy element zostanie dodany do kolekcji i wyczyszczone, gdy element zostanie usunięty.  
  
 [!code-csharp[KeyedCollectionMutable#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollectionMutable/cs/source.cs#1)]
 [!code-vb[KeyedCollectionMutable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollectionMutable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ObjectModel.KeyedCollection`2.Item(`0)" />
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.InsertItem(System.Int32,`1)" />
      </Docs>
    </Member>
    <Member MemberName="TryGetValue">
      <MemberSignature Language="C#" Value="public bool TryGetValue (TKey key, out TItem item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetValue(!TKey key, [out] !TItem&amp; item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.TryGetValue(`0,`1@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetValue (key As TKey, ByRef item As TItem) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetValue(TKey key, [Runtime::InteropServices::Out] TItem % item);" />
      <MemberSignature Language="F#" Value="member this.TryGetValue : 'Key *  -&gt; bool" Usage="keyedCollection.TryGetValue (key, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="item" Type="TItem" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <param name="item">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
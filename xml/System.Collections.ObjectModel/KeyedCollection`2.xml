<Type Name="KeyedCollection&lt;TKey,TItem&gt;" FullName="System.Collections.ObjectModel.KeyedCollection&lt;TKey,TItem&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e91f598b6b6c1baa4b3ad266724134e296b516a2" /><Meta Name="ms.sourcegitcommit" Value="cb4d218ffd5a459a5f921fe1d945c682d1e09aca" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/16/2019" /><Meta Name="ms.locfileid" Value="69539785" /></Metadata><TypeSignature Language="C#" Value="public abstract class KeyedCollection&lt;TKey,TItem&gt; : System.Collections.ObjectModel.Collection&lt;TItem&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit KeyedCollection`2&lt;TKey, TItem&gt; extends System.Collections.ObjectModel.Collection`1&lt;!TItem&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Collections.ObjectModel.KeyedCollection`2" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class KeyedCollection(Of TKey, TItem)&#xA;Inherits Collection(Of TItem)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TKey, typename TItem&gt;&#xA;public ref class KeyedCollection abstract : System::Collections::ObjectModel::Collection&lt;TItem&gt;" />
  <TypeSignature Language="F#" Value="type KeyedCollection&lt;'Key, 'Item&gt; = class&#xA;    inherit Collection&lt;'Item&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.ObjectModel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TKey" />
    <TypeParameter Name="TItem" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Collections.ObjectModel.Collection&lt;TItem&gt;</BaseTypeName>
    <BaseTypeArguments>
      <BaseTypeArgument TypeParamName="T">TItem</BaseTypeArgument>
    </BaseTypeArguments>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.Mscorlib_KeyedCollectionDebugView`2))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="TKey">Typ kluczy w kolekcji.</typeparam>
    <typeparam name="TItem">Typ elementów w kolekcji.</typeparam>
    <summary>Dostarcza abstrakcyjną klasę bazową dla kolekcji, której klucze są osadzone w wartościach.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ObjectModel.KeyedCollection%602> Klasa zapewnia zarówno (1) indeksowane pobieranie i poddające się do pobrania, które podejścia do o (1). Jest to typ abstrakcyjny lub bardziej precyzyjnie nieskończony zestaw typów abstrakcyjnych, ponieważ każdy z jego typów ogólnych jest abstrakcyjną klasą bazową. Aby użyć <xref:System.Collections.ObjectModel.KeyedCollection%602>, należy utworzyć typ kolekcji na podstawie odpowiedniego konstruowanego typu.  
  
 Klasa jest hybrydowa między kolekcją opartą <xref:System.Collections.Generic.IList%601> na interfejsie ogólnym i kolekcją opartą <xref:System.Collections.Generic.IDictionary%602> na interfejsie ogólnym. <xref:System.Collections.ObjectModel.KeyedCollection%602> Podobnie jak kolekcje oparte na <xref:System.Collections.Generic.IList%601> interfejsie ogólnym, <xref:System.Collections.ObjectModel.KeyedCollection%602> są indeksowaną listą elementów. Podobnie jak kolekcje oparte na <xref:System.Collections.Generic.IDictionary%602> interfejsie ogólnym, <xref:System.Collections.ObjectModel.KeyedCollection%602> mają klucz skojarzony z każdym elementem.  
  
 W przeciwieństwie do słowników element <xref:System.Collections.ObjectModel.KeyedCollection%602> nie jest parą klucz/wartość; zamiast tego cały element jest wartością, a klucz jest osadzony w wartości.  Na przykład element kolekcji pochodnej od `KeyedCollection\<String,String>` (`KeyedCollection(Of String, String)` w Visual Basic) może być "Jan Nowak potrafisz". gdzie wartość to "Jan Nowak potrafisz". a kluczem jest "Nowak"; lub kolekcja rekordów pracowników zawierających klucze całkowite mogą pochodzić od `KeyedCollection\<int,Employee>`. Metoda abstrakcyjna <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> wyodrębnia klucz z elementu.  
  
 Domyślnie <xref:System.Collections.ObjectModel.KeyedCollection%602> zawiera słownik wyszukiwania, który można uzyskać <xref:System.Collections.ObjectModel.KeyedCollection%602.Dictionary%2A> przy użyciu właściwości.  Gdy element jest dodawany do <xref:System.Collections.ObjectModel.KeyedCollection%602>, klucz elementu jest wyodrębniany raz i zapisywany w słowniku wyszukiwania w celu szybszego wyszukiwania. To zachowanie jest przesłonięte przez określenie progu tworzenia słownika podczas tworzenia <xref:System.Collections.ObjectModel.KeyedCollection%602>. Słownik wyszukiwania jest tworzony po raz pierwszy, gdy liczba elementów przekracza ten próg.  Jeśli określisz wartość-1, słownik wyszukiwania nigdy nie zostanie utworzony.  
  
> [!NOTE]
>  Gdy używany jest wewnętrzny słownik wyszukiwania, zawiera odwołania do wszystkich elementów w kolekcji, jeśli `TItem` jest typem referencyjnym lub kopiami wszystkich elementów w kolekcji, jeśli `TItem` jest typem wartości. W ten sposób używanie słownika wyszukiwania może być nieodpowiednie, `TItem` jeśli jest typem wartości.  
  
 Możesz uzyskać dostęp do elementu według jego indeksu lub klucza przy użyciu <xref:System.Collections.ObjectModel.KeyedCollection%602.Item%2A> właściwości. Można dodawać elementy bez klucza, ale dostęp do tych elementów można następnie uzyskać tylko za pomocą indeksu.  
  
   
  
## Examples  
 Ten rozdział zawiera dwa przykłady kodu. Pierwszy przykład przedstawia kod minimalny wymagany do wygenerowania z <xref:System.Collections.ObjectModel.KeyedCollection%602>i demonstruje wiele metod dziedziczonych. W drugim przykładzie przedstawiono sposób przesłaniania chronionych metod programu <xref:System.Collections.ObjectModel.KeyedCollection%602> w celu zapewnienia zachowania niestandardowego.  
  
 **Przykład 1**  
  
 Ten przykład kodu pokazuje minimalny kod niezbędny do wygenerowania klasy kolekcji <xref:System.Collections.ObjectModel.KeyedCollection%602>z: <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> Zastępowanie metody i dostarczenie konstruktora publicznego, który jest delegatem do konstruktora klasy bazowej. W przykładzie kodu pokazano również wiele właściwości i metod dziedziczonych z <xref:System.Collections.ObjectModel.KeyedCollection%602> klas i. <xref:System.Collections.ObjectModel.Collection%601>  
  
 Klasa jest bardzo prostą listą zapotrzebowania, która `OrderItem` zawiera obiekty, z których każdy reprezentuje element linii w kolejności. `SimpleOrder` Klucz `OrderItem` jest niezmienny, ważnym zagadnieniem dotyczącym klas, które pochodzą <xref:System.Collections.ObjectModel.KeyedCollection%602>z. Aby zapoznać się z przykładem kodu, który używa <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>modyfikowalnych kluczy, zobacz.  
  
 [!code-cpp[KeyedCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection/cs/source.cs#1)]
 [!code-vb[KeyedCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection/VB/source.vb#1)]  
  
 **Przykład 2**  
  
 Poniższy przykład kodu pokazuje <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, jak zastąpić chronione <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A> <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>metody,,, i <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> , aby zapewnić niestandardowe zachowanie dla <xref:System.Collections.ObjectModel.Collection%601.Add%2A> <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A>metod,, i <xref:System.Collections.ObjectModel.Collection%601.Clear%2A> i dla Ustawianie właściwości domyślnej <xref:System.Collections.ObjectModel.Collection%601.Item%2A> (indeksator w programie C#). Zachowanie niestandardowe podane w tym przykładzie jest zdarzeniem powiadomienia o nazwie `Changed`, które jest zgłaszane na końcu każdej z przesłoniętych metod.  
  
 Przykładowy kod tworzy `SimpleOrder` klasę, która dziedziczy z <xref:System.Collections.ObjectModel.KeyedCollection%602> i reprezentuje prosty formularz zamówienia. Formularz Order zawiera `OrderItem` obiekty reprezentujące elementy uporządkowane. W przykładzie kodu tworzona jest `SimpleOrderChangedEventArgs` również Klasa, która zawiera informacje o zdarzeniu, oraz Wyliczenie umożliwiające zidentyfikowanie typu zmiany.  
  
 Przykład kodu demonstruje zachowanie niestandardowe przez wywołanie właściwości i metod klasy pochodnej, w `Main` metodzie `Demo` klasy.  
  
 Ten przykład kodu używa obiektów z niezmiennymi kluczami. Aby zapoznać się z przykładem kodu, który używa <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>modyfikowalnych kluczy, zobacz.  
  
 [!code-cpp[KeyedCollection2#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection2/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection2#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection2/cs/source.cs#1)]
 [!code-vb[KeyedCollection2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection2/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Collections.Specialized.StringDictionary" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected KeyedCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; KeyedCollection();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" /> klasy, która używa domyślnej wartości porównującej równości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utworzony za pomocą tego konstruktora używa domyślnej ogólnej wartości porównującej równości dla typu klucza uzyskanego z <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType>. <xref:System.Collections.ObjectModel.KeyedCollection%602> Aby określić inną ogólną funkcję porównującą równość, użyj <xref:System.Collections.ObjectModel.KeyedCollection%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%29> konstruktora <xref:System.Collections.ObjectModel.KeyedCollection%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%2CSystem.Int32%29> lub konstruktora.  
  
 Domyślnie <xref:System.Collections.ObjectModel.KeyedCollection%602> zawiera słownik wyszukiwania, który jest tworzony podczas dodawania pierwszego elementu. Gdy element jest dodawany do <xref:System.Collections.ObjectModel.KeyedCollection%602>, klucz elementu jest wyodrębniany raz i zapisywany w słowniku wyszukiwania w celu szybszego wyszukiwania. To zachowanie można przesłonić, używając <xref:System.Collections.ObjectModel.KeyedCollection%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%2CSystem.Int32%29> konstruktora i określając próg tworzenia słownika.  
  
> [!NOTE]
>  Ponieważ Klasa jest abstrakcyjna (`MustInherit` w Visual Basic), należy od niej dziedziczyć, aby jej używać. <xref:System.Collections.ObjectModel.KeyedCollection%602> W konstruktorze dla typu pochodnego Wywołaj odpowiedni <xref:System.Collections.ObjectModel.KeyedCollection%602> Konstruktor. Nie trzeba ujawniać funkcji, takich jak porównania równości lub progu tworzenia słownika w konstruktorach.  
  
 Ten konstruktor jest operacją O (1).  
  
   
  
## Examples  
 Ten przykład kodu pokazuje minimalny kod niezbędny do wygenerowania klasy kolekcji <xref:System.Collections.ObjectModel.KeyedCollection%602>z: <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> Zastępowanie metody i dostarczenie konstruktora publicznego, który jest delegatem do konstruktora klasy bazowej. W przykładzie kodu pokazano również wiele właściwości i metod dziedziczonych z <xref:System.Collections.ObjectModel.KeyedCollection%602> klas i. <xref:System.Collections.ObjectModel.Collection%601>  
  
 Klasa jest bardzo prostą listą zapotrzebowania, która `OrderItem` zawiera obiekty, z których każdy reprezentuje element linii w kolejności. `SimpleOrder` Klucz `OrderItem` jest niezmienny, ważnym zagadnieniem dotyczącym klas, które pochodzą <xref:System.Collections.ObjectModel.KeyedCollection%602>z. Aby zapoznać się z przykładem kodu, który używa <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>modyfikowalnych kluczy, zobacz.  
  
 [!code-cpp[KeyedCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection/cs/source.cs#1)]
 [!code-vb[KeyedCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IEqualityComparer`1" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected KeyedCollection (System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEqualityComparer`1&lt;!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (comparer As IEqualityComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; KeyedCollection(System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt; : System.Collections.Generic.IEqualityComparer&lt;'Key&gt; -&gt; System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt;" Usage="new System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt; comparer" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <param name="comparer">Implementacja <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> interfejsu generycznego do użycia podczas porównywania kluczy lub <see langword="null" /> do użycia domyślnej funkcji porównującej równość dla typu klucza uzyskanego z <see cref="P:System.Collections.Generic.EqualityComparer`1.Default" />.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" /> klasy, która używa określonej metody porównującej równości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie <xref:System.Collections.ObjectModel.KeyedCollection%602> zawiera słownik wyszukiwania, który jest tworzony podczas dodawania pierwszego elementu. Gdy element jest dodawany do <xref:System.Collections.ObjectModel.KeyedCollection%602>, klucz elementu jest wyodrębniany raz i zapisywany w słowniku wyszukiwania w celu szybszego wyszukiwania. To zachowanie można przesłonić, używając <xref:System.Collections.ObjectModel.KeyedCollection%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%2CSystem.Int32%29> konstruktora i określając próg tworzenia słownika.  
  
> [!NOTE]
>  Ponieważ Klasa jest abstrakcyjna (`MustInherit` w Visual Basic), należy od niej dziedziczyć, aby jej używać. <xref:System.Collections.ObjectModel.KeyedCollection%602> W konstruktorze dla typu pochodnego Wywołaj odpowiedni <xref:System.Collections.ObjectModel.KeyedCollection%602> Konstruktor. Nie trzeba ujawniać funkcji, takich jak porównania równości lub progu tworzenia słownika w konstruktorach.  
  
 Ten konstruktor jest operacją O (1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IEqualityComparer`1" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected KeyedCollection (System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer, int dictionaryCreationThreshold);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEqualityComparer`1&lt;!TKey&gt; comparer, int32 dictionaryCreationThreshold) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.#ctor(System.Collections.Generic.IEqualityComparer{`0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (comparer As IEqualityComparer(Of TKey), dictionaryCreationThreshold As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; KeyedCollection(System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ comparer, int dictionaryCreationThreshold);" />
      <MemberSignature Language="F#" Value="new System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt; : System.Collections.Generic.IEqualityComparer&lt;'Key&gt; * int -&gt; System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt;" Usage="new System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt; (comparer, dictionaryCreationThreshold)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
        <Parameter Name="dictionaryCreationThreshold" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="comparer">Implementacja <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> interfejsu generycznego do użycia podczas porównywania kluczy lub <see langword="null" /> do użycia domyślnej funkcji porównującej równość dla typu klucza uzyskanego z <see cref="P:System.Collections.Generic.EqualityComparer`1.Default" />.</param>
        <param name="dictionaryCreationThreshold">Liczba elementów, które mogą być przechowywane w kolekcji bez tworzenia słownika wyszukiwania (0 tworzy słownik wyszukiwania po dodaniu pierwszego elementu) lub-1, aby określić, że słownik wyszukiwania nigdy nie został utworzony.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" /> klasy, która używa określonej metody porównującej równość i tworzy słownik wyszukiwania, gdy zostanie przekroczony określony próg.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie <xref:System.Collections.ObjectModel.KeyedCollection%602> zawiera słownik wyszukiwania, który jest tworzony podczas dodawania pierwszego elementu. Gdy element jest dodawany do <xref:System.Collections.ObjectModel.KeyedCollection%602>, klucz elementu jest wyodrębniany raz i zapisywany w słowniku wyszukiwania w celu szybszego wyszukiwania. Ten konstruktor umożliwia przesłonięcie tego zachowania. Określ wartość 0, aby utworzyć słownik po dodaniu pierwszego elementu, 1, aby utworzyć słownik po dodaniu drugiego elementu itd. Jeśli określisz wartość-1, słownik wyszukiwania nigdy nie zostanie utworzony.  
  
 W przypadku bardzo małych kolekcji zwiększenie szybkości pobierania zapewnianej przez słownik wyszukiwania może nie być cenną dodatkową pamięcią wymaganą przez słownik. Ustawienie wartości progowej pozwala określić, kiedy ma być to kompromis.  
  
> [!NOTE]
>  Ponieważ Klasa jest abstrakcyjna (`MustInherit` w Visual Basic), należy od niej dziedziczyć, aby jej używać. <xref:System.Collections.ObjectModel.KeyedCollection%602> W konstruktorze dla typu pochodnego Wywołaj odpowiedni <xref:System.Collections.ObjectModel.KeyedCollection%602> Konstruktor. Nie trzeba ujawniać funkcji, takich jak porównania równości lub progu tworzenia słownika w konstruktorach.  
  
 Ten konstruktor jest operacją O (1).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, jak zastąpić chronione <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A> <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>metody,,, i <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> , aby zapewnić niestandardowe zachowanie dla <xref:System.Collections.ObjectModel.Collection%601.Add%2A> <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A>metod,, i <xref:System.Collections.ObjectModel.Collection%601.Clear%2A> i dla Ustawianie właściwości domyślnej <xref:System.Collections.ObjectModel.Collection%601.Item%2A> (indeksator w programie C#). Zachowanie niestandardowe podane w tym przykładzie jest zdarzeniem powiadomienia o nazwie `Changed`, które jest zgłaszane na końcu każdej z przesłoniętych metod.  
  
 W przykładzie kodu jest używane <xref:System.Collections.ObjectModel.KeyedCollection%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%2CSystem.Int32%29> konstruktora z progiem równym 0, aby słownik wewnętrzny został utworzony przy pierwszym dodawaniu obiektu do kolekcji.  
  
 Przykładowy kod tworzy `SimpleOrder` klasę, która dziedziczy z <xref:System.Collections.ObjectModel.KeyedCollection%602> i reprezentuje prosty formularz zamówienia. Formularz Order zawiera `OrderItem` obiekty reprezentujące elementy uporządkowane. W przykładzie kodu tworzona jest `SimpleOrderChangedEventArgs` również Klasa, która zawiera informacje o zdarzeniu, oraz Wyliczenie umożliwiające zidentyfikowanie typu zmiany.  
  
 Przykład kodu demonstruje zachowanie niestandardowe przez wywołanie właściwości i metod klasy pochodnej, w `Main` metodzie `Demo` klasy.  
  
 Ten przykład kodu używa obiektów z niezmiennymi kluczami. Aby zapoznać się z przykładem kodu, który używa <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>modyfikowalnych kluczy, zobacz.  
  
 [!code-cpp[KeyedCollection2#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection2/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection2#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection2/cs/source.cs#1)]
 [!code-vb[KeyedCollection2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="dictionaryCreationThreshold" />jest mniejsza niż-1.</exception>
        <altmember cref="T:System.Collections.Generic.IEqualityComparer`1" />
      </Docs>
    </Member>
    <Member MemberName="ChangeItemKey">
      <MemberSignature Language="C#" Value="protected void ChangeItemKey (TItem item, TKey newKey);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ChangeItemKey(!TItem item, !TKey newKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.ChangeItemKey(`1,`0)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ChangeItemKey (item As TItem, newKey As TKey)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ChangeItemKey(TItem item, TKey newKey);" />
      <MemberSignature Language="F#" Value="member this.ChangeItemKey : 'Item * 'Key -&gt; unit" Usage="keyedCollection.ChangeItemKey (item, newKey)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="TItem" />
        <Parameter Name="newKey" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="item">Element, dla którego ma zostać zmieniony klucz.</param>
        <param name="newKey">Nowy klucz dla <paramref name="item" />.</param>
        <summary>Zmienia klucz skojarzony z określonym elementem w słowniku wyszukiwania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie modyfikuje klucza osadzonego w `item`programie; po prostu zastępuje klucz zapisany w słowniku wyszukiwania.  W związku z `newKey` tym, jeśli różni się od klucza osadzonego `item`w, nie można `item` uzyskać dostępu przy użyciu klucza zwracanego przez <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A>.  
  
 Ta metoda nie robi nic, <xref:System.Collections.ObjectModel.KeyedCollection%602> Jeśli nie ma słownika wyszukiwania.  
  
 Każdy klucz w a <xref:System.Collections.ObjectModel.KeyedCollection%602> musi być unikatowy. Klucz nie może być `null`.  
  
 Ta metoda jest operacją O(1).  
  
## <a name="notes-for-implementers"></a>Uwagi dotyczące implementacji  
 Przed zmodyfikowaniem klucza osadzonego w elemencie należy wywołać tę metodę, aby zaktualizować klucz w słowniku wyszukiwania. Jeśli wartość progowa tworzenia słownika to-1, wywołanie tej metody nie jest konieczne.  
  
 Nie ujawniaj <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A> metody jako metody publicznej klasy pochodnej. Nieprawidłowe użycie tej metody powoduje, że słownik wyszukiwania nie jest zsynchronizowany z kluczami elementów. Na przykład ustawienie klucza na `null` , a następnie ustawienie go na inną wartość dodaje wiele kluczy dla elementu do słownika wyszukiwania. Udostępnienie tej metody wewnętrznie w celu zezwolenia na modyfikowalne klucze elementów: Po zmianie klucza elementu Ta metoda jest używana do zmiany klucza w słowniku wyszukiwania.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak zastąpić metodę chronioną <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A> , aby obsługiwała klucze mutable i jak zastąpić <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>chronione <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>metody,, i <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> , aby zachować integralność kluczy i kolekcja.  
  
 Przykładowy kod tworzy `MutableKeys` kolekcję, która pochodzi od <xref:System.Collections.ObjectModel.KeyedCollection%602>, i `MutableKey` klasy. Klasa ma właściwość settable `Key`. `MutableKey` Gdy nowy klucz zostanie przypisany do właściwości, Metoda ustawiająca właściwość wywołuje `internal` metodę (`Friend` w Visual Basic) `ChangeKey` kolekcji, aby sprawdzić, czy nowy klucz koliduje z istniejącym kluczem. Jeśli tak jest, zgłaszany jest wyjątek, a wartość właściwości nie zostanie zmieniona.  
  
 Aby zachować połączenie między `MutableKey` obiektem `MutableKeys` a kolekcją i zapobiec wstawieniu obiektu `MutableKey` do dwóch kolekcji `internal` , Klasa ma (`Friend` w Visual Basic) `Collection`pole. To pole jest obsługiwane przez chronione metody, które zapewniają niestandardowe zachowanie podczas dodawania i usuwania elementów z kolekcji, takich jak <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> Metoda. Pole jest ustawiane, gdy element zostanie dodany do kolekcji i wyczyszczony, gdy element zostanie usunięty.  
  
 [!code-csharp[KeyedCollectionMutable#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollectionMutable/cs/source.cs#1)]
 [!code-vb[KeyedCollectionMutable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollectionMutable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="item" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="key" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="item" />nie znaleziono.  
  
—lub— 
 <paramref name="key" />już istnieje w <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />.</exception>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.GetKeyForItem(`1)" />
        <altmember cref="P:System.Collections.ObjectModel.KeyedCollection`2.Item(`0)" />
      </Docs>
    </Member>
    <Member MemberName="ClearItems">
      <MemberSignature Language="C#" Value="protected override void ClearItems ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void ClearItems() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.ClearItems" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub ClearItems ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void ClearItems();" />
      <MemberSignature Language="F#" Value="override this.ClearItems : unit -&gt; unit" Usage="keyedCollection.ClearItems " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa wszystkie elementy z <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku słownika wyszukiwania ta metoda czyści je, ale nie usuwa.  
  
 Jeśli liczba elementów przekroczyła próg tworzenia słownika i <xref:System.Collections.ObjectModel.KeyedCollection%602> używa słownika wyszukiwania, będzie nadal używać słownika wyszukiwania, nawet jeśli liczba elementów jest ponownie objęta progiem.  
  
 Ta metoda jest operacją o`n`(), gdzie `n` is <xref:System.Collections.ObjectModel.Collection%601.Count%2A>.  
  
## <a name="notes-for-implementers"></a>Uwagi dotyczące implementacji  
 Zastąp tę metodę, aby zapewnić dostosowane zachowanie <xref:System.Collections.ObjectModel.Collection%601.Clear%2A> metody dziedziczonej <xref:System.Collections.ObjectModel.Collection%601> z klasy generycznej.  
  
 Wywołaj implementację klasy bazowej tej metody w celu wyczyszczenia źródłowej kolekcji i wyczyszczenia słownika wyszukiwania.  
  
   
  
## Examples  
 Ta sekcja zawiera dwa przykłady kodu, które demonstrują <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A> przesłanianie metody w celu zapewnienia niestandardowego zachowania podczas czyszczenia wszystkich obiektów z kolekcji. Pierwszy przykład dodaje niestandardowe zdarzenie powiadomień, a drugi zapewnia obsługę kolekcji obiektów z modyfikowalnymi kluczami.  
  
 Przykład 1  
  
 Poniższy przykład kodu pokazuje <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, jak zastąpić chronione <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A> <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>metody,,, i <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> , aby zapewnić niestandardowe zachowanie dla <xref:System.Collections.ObjectModel.Collection%601.Add%2A> <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A>metod,, i <xref:System.Collections.ObjectModel.Collection%601.Clear%2A> i dla Ustawianie właściwości domyślnej <xref:System.Collections.ObjectModel.Collection%601.Item%2A> (indeksator w programie C#). Zachowanie niestandardowe podane w tym przykładzie jest zdarzeniem powiadomienia o nazwie `Changed`, które jest zgłaszane na końcu każdej z przesłoniętych metod.  
  
 Przykładowy kod tworzy `SimpleOrder` klasę, która dziedziczy z <xref:System.Collections.ObjectModel.KeyedCollection%602> i reprezentuje prosty formularz zamówienia. Formularz Order zawiera `OrderItem` obiekty reprezentujące elementy uporządkowane. W przykładzie kodu tworzona jest `SimpleOrderChangedEventArgs` również Klasa, która zawiera informacje o zdarzeniu, oraz Wyliczenie umożliwiające zidentyfikowanie typu zmiany.  
  
 Przykład kodu demonstruje zachowanie niestandardowe przez wywołanie właściwości i metod klasy pochodnej, w `Main` metodzie `Demo` klasy.  
  
 Ten przykład kodu używa obiektów z niezmiennymi kluczami. Aby zapoznać się z przykładem kodu, który używa <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>modyfikowalnych kluczy, zobacz.  
  
 [!code-cpp[KeyedCollection2#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection2/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection2#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection2/cs/source.cs#1)]
 [!code-vb[KeyedCollection2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection2/vb/source.vb#1)]  
  
 Przykład 2  
  
 Poniższy przykład kodu pokazuje, jak zastąpić metodę chronioną <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A> , aby obsługiwała klucze mutable i jak zastąpić <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>chronione <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>metody,, i <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> , aby zachować integralność kluczy i kolekcja.  
  
 Przykładowy kod tworzy `MutableKeys` kolekcję, która pochodzi od <xref:System.Collections.ObjectModel.KeyedCollection%602>, i `MutableKey` klasy. Klasa ma właściwość settable `Key`. `MutableKey` Gdy nowy klucz zostanie przypisany do właściwości, Metoda ustawiająca właściwość wywołuje `internal` metodę (`Friend` w Visual Basic) `ChangeKey` kolekcji, aby sprawdzić, czy nowy klucz koliduje z istniejącym kluczem. Jeśli tak jest, zgłaszany jest wyjątek, a wartość właściwości nie zostanie zmieniona.  
  
 Aby zachować połączenie między `MutableKey` obiektem `MutableKeys` a kolekcją i zapobiec wstawieniu obiektu `MutableKey` do dwóch kolekcji `internal` , Klasa ma (`Friend` w Visual Basic) `Collection`pole. To pole jest obsługiwane przez chronione metody, które zapewniają niestandardowe zachowanie podczas dodawania i usuwania elementów z kolekcji, takich jak <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> Metoda. Pole jest ustawiane, gdy element zostanie dodany do kolekcji i wyczyszczony, gdy element zostanie usunięty.  
  
 [!code-csharp[KeyedCollectionMutable#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollectionMutable/cs/source.cs#1)]
 [!code-vb[KeyedCollectionMutable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollectionMutable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.Remove(`0)" />
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.RemoveItem(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Comparer">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEqualityComparer&lt;TKey&gt; Comparer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEqualityComparer`1&lt;!TKey&gt; Comparer" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ObjectModel.KeyedCollection`2.Comparer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Comparer As IEqualityComparer(Of TKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ Comparer { System::Collections::Generic::IEqualityComparer&lt;TKey&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Comparer : System.Collections.Generic.IEqualityComparer&lt;'Key&gt;" Usage="System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt;.Comparer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEqualityComparer&lt;TKey&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ogólną funkcję porównującą równość, która jest używana do określania równości kluczy w kolekcji.</summary>
        <value>Implementacja <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> interfejsu generycznego, który jest używany do określania równości kluczy w kolekcji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.Contains(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (key As TKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(TKey key);" />
      <MemberSignature Language="F#" Value="override this.Contains : 'Key -&gt; bool" Usage="keyedCollection.Contains key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Klucz, który ma zostać zlokalizowany w <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />.</param>
        <summary>Określa, czy kolekcja zawiera element z określonym kluczem.</summary>
        <returns><see langword="true" />Jeśli zawiera element z określonym kluczem; w przeciwnym razie, <see langword="false" />. <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ma słownik wyszukiwania, `key` jest używany do przeszukiwania słownika. <xref:System.Collections.ObjectModel.KeyedCollection%602> Jeśli nie ma słownika wyszukiwania, klucz każdego elementu jest wyodrębniany przy użyciu <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> metody i porównywany z określonym kluczem.  
  
 Ta metoda jest operacją o (1), jeśli <xref:System.Collections.ObjectModel.KeyedCollection%602> ma słownik wyszukiwania; w przeciwnym razie jest to operacja o`n`(), gdzie `n` is <xref:System.Collections.ObjectModel.Collection%601.Count%2A>.  
  
   
  
## Examples  
 Ten przykład kodu pokazuje minimalny kod niezbędny do wygenerowania klasy kolekcji <xref:System.Collections.ObjectModel.KeyedCollection%602>z: <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> Zastępowanie metody i dostarczenie konstruktora publicznego, który jest delegatem do konstruktora klasy bazowej. W przykładzie kodu pokazano również wiele właściwości i metod dziedziczonych z <xref:System.Collections.ObjectModel.KeyedCollection%602> klas i. <xref:System.Collections.ObjectModel.Collection%601>  
  
 Klasa jest bardzo prostą listą zapotrzebowania, która `OrderItem` zawiera obiekty, z których każdy reprezentuje element linii w kolejności. `SimpleOrder` Klucz `OrderItem` jest niezmienny, ważnym zagadnieniem dotyczącym klas, które pochodzą <xref:System.Collections.ObjectModel.KeyedCollection%602>z. Aby zapoznać się z przykładem kodu, który używa <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>modyfikowalnych kluczy, zobacz.  
  
 [!code-cpp[KeyedCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection/cs/source.cs#1)]
 [!code-vb[KeyedCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" />jest <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.GetKeyForItem(`1)" />
      </Docs>
    </Member>
    <Member MemberName="Dictionary">
      <MemberSignature Language="C#" Value="protected System.Collections.Generic.IDictionary&lt;TKey,TItem&gt; Dictionary { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IDictionary`2&lt;!TKey, !TItem&gt; Dictionary" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ObjectModel.KeyedCollection`2.Dictionary" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Dictionary As IDictionary(Of TKey, TItem)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Collections::Generic::IDictionary&lt;TKey, TItem&gt; ^ Dictionary { System::Collections::Generic::IDictionary&lt;TKey, TItem&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Dictionary : System.Collections.Generic.IDictionary&lt;'Key, 'Item&gt;" Usage="System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt;.Dictionary" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;TKey,TItem&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera słownik <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />wyszukiwania.</summary>
        <value>Słownik <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />wyszukiwania, jeśli istnieje; <see langword="null" />w przeciwnym razie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie <xref:System.Collections.ObjectModel.KeyedCollection%602> zawiera słownik wyszukiwania, który jest tworzony podczas dodawania pierwszego elementu. Gdy element jest dodawany do <xref:System.Collections.ObjectModel.KeyedCollection%602>, klucz elementu jest wyodrębniany raz i zapisywany w słowniku wyszukiwania w celu szybszego wyszukiwania. To zachowanie można przesłonić, używając <xref:System.Collections.ObjectModel.KeyedCollection%602.%23ctor%28System.Collections.Generic.IEqualityComparer%7B%600%7D%2CSystem.Int32%29> konstruktora i określając próg tworzenia słownika.  
  
 Pobieranie wartości tej właściwości jest operacją O(1).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak zastąpić metodę chronioną <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A> , aby obsługiwała klucze mutable i jak zastąpić <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>chronione <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>metody,, i <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> , aby zachować integralność kluczy i kolekcja.  
  
 Przykładowy kod tworzy `MutableKeys` kolekcję, która pochodzi od <xref:System.Collections.ObjectModel.KeyedCollection%602>, i `MutableKey` klasy. Klasa ma właściwość settable `Key`. `MutableKey` Gdy nowy klucz zostanie przypisany do właściwości, Metoda ustawiająca właściwość wywołuje `internal` metodę (`Friend` w Visual Basic) `ChangeKey` kolekcji, aby sprawdzić, czy nowy klucz koliduje z istniejącym kluczem. Jeśli tak jest, zgłaszany jest wyjątek, a wartość właściwości nie zostanie zmieniona.  
  
 Aby zachować połączenie między `MutableKey` obiektem `MutableKeys` a kolekcją i zapobiec wstawieniu obiektu `MutableKey` do dwóch kolekcji `internal` , Klasa ma (`Friend` w Visual Basic) `Collection`pole. To pole jest obsługiwane przez chronione metody, które zapewniają niestandardowe zachowanie podczas dodawania i usuwania elementów z kolekcji, takich jak <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> Metoda. Pole jest ustawiane, gdy element zostanie dodany do kolekcji i wyczyszczony, gdy element zostanie usunięty.  
  
 [!code-csharp[KeyedCollectionMutable#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollectionMutable/cs/source.cs#1)]
 [!code-vb[KeyedCollectionMutable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollectionMutable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IDictionary`2" />
      </Docs>
    </Member>
    <Member MemberName="GetKeyForItem">
      <MemberSignature Language="C#" Value="protected abstract TKey GetKeyForItem (TItem item);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance !TKey GetKeyForItem(!TItem item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.GetKeyForItem(`1)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetKeyForItem (item As TItem) As TKey" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract TKey GetKeyForItem(TItem item);" />
      <MemberSignature Language="F#" Value="abstract member GetKeyForItem : 'Item -&gt; 'Key" Usage="keyedCollection.GetKeyForItem item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="TItem" />
      </Parameters>
      <Docs>
        <param name="item">Element, z którego ma zostać wyodrębniony klucz.</param>
        <summary>Po zaimplementowaniu w klasie pochodnej wyodrębnia klucz z określonego elementu.</summary>
        <returns>Klucz dla określonego elementu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli klucz w słowniku wyszukiwania jest inny niż klucz osadzony w `item`, nie można uzyskać dostępu `item` przy użyciu klucza zwracanego przez <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A>.  
  
 Możesz zaimplementować tę metodę, aby zwrócić `null` do kolekcji zawierającej elementy bez kluczy, w takim przypadku można uzyskać dostęp do elementów tylko według ich indeksu. Ta metoda jest operacją O(1).  
  
## <a name="notes-for-implementers"></a>Uwagi dotyczące implementacji  
 Należy zastąpić tę metodę, aby zapewnić słownikowi możliwość wyodrębnienia kluczy z elementów w słowniku.  
  
 Ta metoda jest wywoływana wewnętrznie. Nie jest to konieczne, aby była publiczna.  
  
   
  
## Examples  
 Ten przykład kodu pokazuje minimalny kod niezbędny do wygenerowania klasy kolekcji <xref:System.Collections.ObjectModel.KeyedCollection%602>z: <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> Zastępowanie metody i dostarczenie konstruktora publicznego, który jest delegatem do konstruktora klasy bazowej. W przykładzie kodu pokazano również wiele właściwości i metod dziedziczonych z <xref:System.Collections.ObjectModel.KeyedCollection%602> klas i. <xref:System.Collections.ObjectModel.Collection%601>  
  
 Klasa jest bardzo prostą listą zapotrzebowania, która `OrderItem` zawiera obiekty, z których każdy reprezentuje element linii w kolejności. `SimpleOrder` Klucz `OrderItem` jest niezmienny, ważnym zagadnieniem dotyczącym klas, które pochodzą <xref:System.Collections.ObjectModel.KeyedCollection%602>z. Aby zapoznać się z przykładem kodu, który używa <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>modyfikowalnych kluczy, zobacz.  
  
 [!code-cpp[KeyedCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection/cs/source.cs#1)]
 [!code-vb[KeyedCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.ChangeItemKey(`1,`0)" />
        <altmember cref="P:System.Collections.ObjectModel.KeyedCollection`2.Item(`0)" />
      </Docs>
    </Member>
    <Member MemberName="InsertItem">
      <MemberSignature Language="C#" Value="protected override void InsertItem (int index, TItem item);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void InsertItem(int32 index, !TItem item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.InsertItem(System.Int32,`1)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub InsertItem (index As Integer, item As TItem)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void InsertItem(int index, TItem item);" />
      <MemberSignature Language="F#" Value="override this.InsertItem : int * 'Item -&gt; unit" Usage="keyedCollection.InsertItem (index, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="TItem" />
      </Parameters>
      <Docs>
        <param name="index">Indeks (liczony od zera), <paramref name="item" /> który powinien zostać wstawiony.</param>
        <param name="item">Obiekt do wstawienia.</param>
        <summary>Wstawia element do <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" /> obiektu o określonym indeksie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `index` wartość jest <xref:System.Collections.ObjectModel.Collection%601.Count%2A>równa `item` , zostanie dodana na końcu. <xref:System.Collections.ObjectModel.KeyedCollection%602>  
  
 Ta metoda jest operacją o`n`(), gdzie `n` is <xref:System.Collections.ObjectModel.Collection%601.Count%2A>.  
  
 <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>jest wywoływana przez <xref:System.Collections.ObjectModel.Collection%601.Add%2A> metody i <xref:System.Collections.ObjectModel.Collection%601.Insert%2A> .  
  
## <a name="notes-for-implementers"></a>Uwagi dotyczące implementacji  
 Zastąp tę metodę, aby zapewnić dostosowane zachowanie <xref:System.Collections.ObjectModel.Collection%601.Add%2A> <xref:System.Collections.ObjectModel.Collection%601> metod <xref:System.Collections.ObjectModel.Collection%601.Insert%2A> i dziedziczonych z klasy generycznej.  
  
 Wywołaj implementację klasy bazowej tej metody, aby wstawić element do kolekcji źródłowej i zaktualizować słownik wyszukiwania.  
  
   
  
## Examples  
 Ta sekcja zawiera dwa przykłady kodu, które demonstrują <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> przesłanianie metody w celu zapewnienia niestandardowego zachowania do dodawania lub wstawiania obiektów do kolekcji. Pierwszy przykład dodaje niestandardowe zdarzenie powiadomień, a drugi zapewnia obsługę kolekcji obiektów z modyfikowalnymi kluczami.  
  
 Przykład 1  
  
 Poniższy przykład kodu pokazuje <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, jak zastąpić chronione <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A> <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>metody,,, i <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> , aby zapewnić niestandardowe zachowanie dla <xref:System.Collections.ObjectModel.Collection%601.Add%2A> <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A>metod,, i <xref:System.Collections.ObjectModel.Collection%601.Clear%2A> i dla Ustawianie właściwości domyślnej <xref:System.Collections.ObjectModel.Collection%601.Item%2A> (indeksator w programie C#). Zachowanie niestandardowe podane w tym przykładzie jest zdarzeniem powiadomienia o nazwie `Changed`, które jest zgłaszane na końcu każdej z przesłoniętych metod.  
  
 Przykładowy kod tworzy `SimpleOrder` klasę, która dziedziczy z <xref:System.Collections.ObjectModel.KeyedCollection%602> i reprezentuje prosty formularz zamówienia. Formularz Order zawiera `OrderItem` obiekty reprezentujące elementy uporządkowane. W przykładzie kodu tworzona jest `SimpleOrderChangedEventArgs` również Klasa, która zawiera informacje o zdarzeniu, oraz Wyliczenie umożliwiające zidentyfikowanie typu zmiany.  
  
 Przykład kodu demonstruje zachowanie niestandardowe przez wywołanie właściwości i metod klasy pochodnej, w `Main` metodzie `Demo` klasy.  
  
 Ten przykład kodu używa obiektów z niezmiennymi kluczami. Aby zapoznać się z przykładem kodu, który używa <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>modyfikowalnych kluczy, zobacz.  
  
 [!code-cpp[KeyedCollection2#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection2/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection2#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection2/cs/source.cs#1)]
 [!code-vb[KeyedCollection2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection2/vb/source.vb#1)]  
  
 Przykład 2  
  
 Poniższy przykład kodu pokazuje, jak zastąpić metodę chronioną <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A> , aby obsługiwała klucze mutable i jak zastąpić <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>chronione <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>metody,, i <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> , aby zachować integralność kluczy i kolekcja.  
  
 Przykładowy kod tworzy `MutableKeys` kolekcję, która pochodzi od <xref:System.Collections.ObjectModel.KeyedCollection%602>, i `MutableKey` klasy. Klasa ma właściwość settable `Key`. `MutableKey` Gdy nowy klucz zostanie przypisany do właściwości, Metoda ustawiająca właściwość wywołuje `internal` metodę (`Friend` w Visual Basic) `ChangeKey` kolekcji, aby sprawdzić, czy nowy klucz koliduje z istniejącym kluczem. Jeśli tak jest, zgłaszany jest wyjątek, a wartość właściwości nie zostanie zmieniona.  
  
 Aby zachować połączenie między `MutableKey` obiektem `MutableKeys` a kolekcją i zapobiec wstawieniu obiektu `MutableKey` do dwóch kolekcji `internal` , Klasa ma (`Friend` w Visual Basic) `Collection`pole. To pole jest obsługiwane przez chronione metody, które zapewniają niestandardowe zachowanie podczas dodawania i usuwania elementów z kolekcji, takich jak <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> Metoda. Pole jest ustawiane, gdy element zostanie dodany do kolekcji i wyczyszczony, gdy element zostanie usunięty.  
  
 [!code-csharp[KeyedCollectionMutable#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollectionMutable/cs/source.cs#1)]
 [!code-vb[KeyedCollectionMutable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollectionMutable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />jest mniejsza niż 0.  
  
—lub— 
 <paramref name="index" />jest większa niż <see cref="P:System.Collections.ObjectModel.Collection`1.Count" />.</exception>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.SetItem(System.Int32,`1)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public TItem this[TKey key] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !TItem Item(!TKey)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.ObjectModel.KeyedCollection`2.Item(`0)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(key As TKey) As TItem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TItem default[TKey] { TItem get(TKey key); };" />
      <MemberSignature Language="F#" Value="member this.Item('Key) : 'Item" Usage="System.Collections.ObjectModel.KeyedCollection&lt;'Key, 'Item&gt;.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Klucz elementu do pobrania.</param>
        <summary>Pobiera element z określonym kluczem.</summary>
        <value>Element z określonym kluczem. Jeśli element z określonym kluczem nie zostanie znaleziony, zostanie zgłoszony wyjątek.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zapewnia możliwość dostępu do określonego elementu w kolekcji przy użyciu następującej składni: `myCollection[key]` (`myCollection(key)` w Visual Basic).  
  
> [!NOTE]
>  Ta właściwość jest odrębna względem dziedziczonej <xref:System.Collections.ObjectModel.Collection%601.Item%2A?displayProperty=nameWithType> właściwości, która pobiera i ustawia elementy według indeksu liczbowego. Jeśli `TKey` jednak jest typu <xref:System.Int32>, ta właściwość maskuje dziedziczonej właściwości. W takim przypadku można uzyskać dostęp do dziedziczonej właściwości przez rzutowanie <xref:System.Collections.ObjectModel.KeyedCollection%602> na jego typ podstawowy. Na `KeyedCollection<int, MyType>` przykład C++(`KeyedCollection(Of Integer, MyType)` w `KeyedCollection<int, MyType^>` Visual Basic w programie C++) można rzutować na `Collection<MyType>` (`Collection(Of MyType)` w Visual Basic, `Collection<MyType^>` w).  
  
 Jeśli ma słownik wyszukiwania, `key` jest używany do pobierania elementu ze słownika. <xref:System.Collections.ObjectModel.KeyedCollection%602>  Jeśli nie ma słownika wyszukiwania, klucz każdego elementu jest wyodrębniany przy użyciu <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> metody i porównywany z określonym kluczem.  
  
 Język używa [tego](~/docs/csharp/language-reference/keywords/this.md) słowa kluczowego, aby zdefiniować indeksatory zamiast implementowania <xref:System.Collections.ObjectModel.KeyedCollection%602.Item%2A> właściwości. C# Visual Basic implementuje <xref:System.Collections.ObjectModel.KeyedCollection%602.Item%2A> jako [Właściwość domyślną](~/docs/visual-basic/language-reference/modifiers/default.md), która zapewnia te same funkcje indeksowania.  
  
 Pobieranie wartości tej właściwości <xref:System.Collections.ObjectModel.KeyedCollection%602> jest operacją o (1), jeśli ma słownik wyszukiwania; w przeciwnym razie jest to operacja o (`n`), gdzie `n` is <xref:System.Collections.ObjectModel.Collection%601.Count%2A>.

## Examples  
 Ten przykład kodu pokazuje minimalny kod niezbędny do wygenerowania klasy kolekcji <xref:System.Collections.ObjectModel.KeyedCollection%602>z: <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> Zastępowanie metody i dostarczenie konstruktora publicznego, który jest delegatem do konstruktora klasy bazowej. W przykładzie kodu pokazano również wiele właściwości i metod dziedziczonych z <xref:System.Collections.ObjectModel.KeyedCollection%602> klas i. <xref:System.Collections.ObjectModel.Collection%601>  
  
 Przykładowy kod wywołuje zarówno <xref:System.Collections.ObjectModel.KeyedCollection%602.Item%2A?displayProperty=nameWithType> właściwość, która jest tylko do odczytu, jak i pobiera według klucza, <xref:System.Collections.ObjectModel.Collection%601.Item%2A?displayProperty=nameWithType> i właściwość, która jest metodą settable i pobiera według indeksu. Pokazuje, w jaki sposób uzyskać dostęp do tej ostatniej właściwości, gdy obiekty w kolekcji pochodnej mają klucze całkowite, nieodróżniające od liczb całkowitych używanych do pobierania indeksowanego.  
  
 Klasa jest bardzo prostą listą zapotrzebowania, która `OrderItem` zawiera obiekty, z których każdy reprezentuje element linii w kolejności. `SimpleOrder` Klucz `OrderItem` jest niezmienny, ważnym zagadnieniem dotyczącym klas, które pochodzą <xref:System.Collections.ObjectModel.KeyedCollection%602>z. Aby zapoznać się z przykładem kodu, który używa <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>modyfikowalnych kluczy, zobacz.  
  
 [!code-cpp[KeyedCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection/cs/source.cs#1)]
 [!code-vb[KeyedCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Collections.Generic.KeyNotFoundException">Element z określonym kluczem nie istnieje w kolekcji.</exception>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.SetItem(System.Int32,`1)" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Remove(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (key As TKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Remove(TKey key);" />
      <MemberSignature Language="F#" Value="override this.Remove : 'Key -&gt; bool" Usage="keyedCollection.Remove key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Klucz elementu do usunięcia.</param>
        <summary>Usuwa element z określonym kluczem z <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />.</summary>
        <returns><see langword="true" />Jeśli element został pomyślnie usunięty; w przeciwnym razie. <see langword="false" />  Ta metoda zwraca również <see langword="false" /> wartość <paramref name="key" /> , <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />Jeśli nie została znaleziona w.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klucz elementu zostanie również usunięty z słownika wyszukiwania.  
  
 Jeśli liczba elementów przekroczyła próg tworzenia słownika i <xref:System.Collections.ObjectModel.KeyedCollection%602> używa słownika wyszukiwania, będzie nadal używać słownika wyszukiwania, nawet jeśli liczba elementów jest ponownie objęta progiem.  
  
> [!NOTE]
>  Aby dostosować zachowanie tej metody, Zastąp <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A> metodę.  
  
 Ta metoda jest operacją o`n`(), gdzie `n` is <xref:System.Collections.ObjectModel.Collection%601.Count%2A>.  
  
   
  
## Examples  
 Ten przykład kodu pokazuje minimalny kod niezbędny do wygenerowania klasy kolekcji <xref:System.Collections.ObjectModel.KeyedCollection%602>z: <xref:System.Collections.ObjectModel.KeyedCollection%602.GetKeyForItem%2A> Zastępowanie metody i dostarczenie konstruktora publicznego, który jest delegatem do konstruktora klasy bazowej. W przykładzie kodu pokazano również wiele właściwości i metod dziedziczonych z <xref:System.Collections.ObjectModel.KeyedCollection%602> klas i. <xref:System.Collections.ObjectModel.Collection%601>  
  
 Przykład <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A> ilustruje metodę dziedziczoną z <xref:System.Collections.ObjectModel.Collection%601.Remove%2A> <xref:System.Collections.ObjectModel.KeyedCollection%602>, która usuwa element z określonym kluczem, a także metod i <xref:System.Collections.ObjectModel.Collection%601.RemoveAt%2A> metody dziedziczone z <xref:System.Collections.ObjectModel.Collection%601>, które Usuń odpowiednio przez obiekt i według indeksu.  
  
 Klasa jest bardzo prostą listą zapotrzebowania, która `OrderItem` zawiera obiekty, z których każdy reprezentuje element linii w kolejności. `SimpleOrder` Klucz `OrderItem` jest niezmienny, ważnym zagadnieniem dotyczącym klas, które pochodzą <xref:System.Collections.ObjectModel.KeyedCollection%602>z. Aby zapoznać się z przykładem kodu, który używa <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>modyfikowalnych kluczy, zobacz.  
  
 [!code-cpp[KeyedCollection#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection/cs/source.cs#1)]
 [!code-vb[KeyedCollection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" />jest <see langword="null" />.</exception>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.RemoveItem(System.Int32)" />
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.ClearItems" />
      </Docs>
    </Member>
    <Member MemberName="RemoveItem">
      <MemberSignature Language="C#" Value="protected override void RemoveItem (int index);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void RemoveItem(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.RemoveItem(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub RemoveItem (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void RemoveItem(int index);" />
      <MemberSignature Language="F#" Value="override this.RemoveItem : int -&gt; unit" Usage="keyedCollection.RemoveItem index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Indeks elementu, który ma zostać usunięty.</param>
        <summary>Usuwa element w określonym indeksie <see cref="T:System.Collections.ObjectModel.KeyedCollection`2" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klucz elementu zostanie również usunięty z słownika wyszukiwania.  
  
 Jeśli liczba elementów przekroczyła próg tworzenia słownika i <xref:System.Collections.ObjectModel.KeyedCollection%602> używa słownika wyszukiwania, będzie nadal używać słownika wyszukiwania, nawet jeśli liczba elementów jest ponownie objęta progiem.  
  
 Ta metoda jest operacją o`n`(), gdzie `n` is <xref:System.Collections.ObjectModel.Collection%601.Count%2A>.  
  
## <a name="notes-for-implementers"></a>Uwagi dotyczące implementacji  
 Zastąp tę metodę, aby zapewnić dostosowane zachowanie <xref:System.Collections.ObjectModel.Collection%601.Remove%28%600%29> <xref:System.Collections.ObjectModel.Collection%601> metod <xref:System.Collections.ObjectModel.Collection%601.RemoveAt%28System.Int32%29> i, dziedziczonych z klasy generycznej i <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%28%600%29> metody.  
  
 Wywołaj implementację klasy bazowej tej metody, aby usunąć element z kolekcji źródłowej i zaktualizować słownik wyszukiwania.  
  
   
  
## Examples  
 Ta sekcja zawiera dwa przykłady kodu, które demonstrują <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A> przesłanianie metody w celu zapewnienia niestandardowego zachowania do usuwania obiektów z kolekcji. Pierwszy przykład dodaje niestandardowe zdarzenie powiadomień, a drugi zapewnia obsługę kolekcji obiektów z modyfikowalnymi kluczami.  
  
 Przykład 1  
  
 Poniższy przykład kodu pokazuje <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, jak zastąpić chronione <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A> <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>metody,,, i <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> , aby zapewnić niestandardowe zachowanie dla <xref:System.Collections.ObjectModel.Collection%601.Add%2A> <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A>metod,, i <xref:System.Collections.ObjectModel.Collection%601.Clear%2A> i dla Ustawianie właściwości domyślnej <xref:System.Collections.ObjectModel.Collection%601.Item%2A> (indeksator w programie C#). Zachowanie niestandardowe podane w tym przykładzie jest zdarzeniem powiadomienia o nazwie `Changed`, które jest zgłaszane na końcu każdej z przesłoniętych metod.  
  
 Przykładowy kod tworzy `SimpleOrder` klasę, która dziedziczy z <xref:System.Collections.ObjectModel.KeyedCollection%602> i reprezentuje prosty formularz zamówienia. Formularz Order zawiera `OrderItem` obiekty reprezentujące elementy uporządkowane. W przykładzie kodu tworzona jest `SimpleOrderChangedEventArgs` również Klasa, która zawiera informacje o zdarzeniu, oraz Wyliczenie umożliwiające zidentyfikowanie typu zmiany.  
  
 Przykład kodu demonstruje zachowanie niestandardowe przez wywołanie właściwości i metod klasy pochodnej, w `Main` metodzie `Demo` klasy.  
  
 Ten przykład kodu używa obiektów z niezmiennymi kluczami. Aby zapoznać się z przykładem kodu, który używa <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>modyfikowalnych kluczy, zobacz.  
  
 [!code-cpp[KeyedCollection2#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection2/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection2#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection2/cs/source.cs#1)]
 [!code-vb[KeyedCollection2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection2/vb/source.vb#1)]  
  
 Przykład 2  
  
 Poniższy przykład kodu pokazuje, jak zastąpić metodę chronioną <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A> , aby obsługiwała klucze mutable i jak zastąpić <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>chronione <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>metody,, i <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> , aby zachować integralność kluczy i kolekcja.  
  
 Przykładowy kod tworzy `MutableKeys` kolekcję, która pochodzi od <xref:System.Collections.ObjectModel.KeyedCollection%602>, i `MutableKey` klasy. Klasa ma właściwość settable `Key`. `MutableKey` Gdy nowy klucz zostanie przypisany do właściwości, Metoda ustawiająca właściwość wywołuje `internal` metodę (`Friend` w Visual Basic) `ChangeKey` kolekcji, aby sprawdzić, czy nowy klucz koliduje z istniejącym kluczem. Jeśli tak jest, zgłaszany jest wyjątek, a wartość właściwości nie zostanie zmieniona.  
  
 Aby zachować połączenie między `MutableKey` obiektem `MutableKeys` a kolekcją i zapobiec wstawieniu obiektu `MutableKey` do dwóch kolekcji `internal` , Klasa ma (`Friend` w Visual Basic) `Collection`pole. To pole jest obsługiwane przez chronione metody, które zapewniają niestandardowe zachowanie podczas dodawania i usuwania elementów z kolekcji, takich jak <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> Metoda. Pole jest ustawiane, gdy element zostanie dodany do kolekcji i wyczyszczony, gdy element zostanie usunięty.  
  
 [!code-csharp[KeyedCollectionMutable#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollectionMutable/cs/source.cs#1)]
 [!code-vb[KeyedCollectionMutable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollectionMutable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.Remove(`0)" />
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.ClearItems" />
      </Docs>
    </Member>
    <Member MemberName="SetItem">
      <MemberSignature Language="C#" Value="protected override void SetItem (int index, TItem item);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void SetItem(int32 index, !TItem item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.SetItem(System.Int32,`1)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub SetItem (index As Integer, item As TItem)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void SetItem(int index, TItem item);" />
      <MemberSignature Language="F#" Value="override this.SetItem : int * 'Item -&gt; unit" Usage="keyedCollection.SetItem (index, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="TItem" />
      </Parameters>
      <Docs>
        <param name="index">Indeks (liczony od zera) elementu, który ma zostać zastąpiony.</param>
        <param name="item">Nowy element.</param>
        <summary>Zamienia element w określonym indeksie na określony element.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Słownik wyszukiwania jest odpowiednio aktualizowany. Oznacza to, że klucz elementu, który jest zastępowany, jest usuwany z słownika wyszukiwania, a klucz nowego elementu zostanie dodany.  
  
 Ta metoda jest operacją O(1).  
  
## <a name="notes-for-implementers"></a>Uwagi dotyczące implementacji  
 Zastąp tę metodę, aby zapewnić dostosowane zachowanie dotyczące <xref:System.Collections.ObjectModel.Collection%601.Item%2A> ustawiania właściwości dziedziczonej <xref:System.Collections.ObjectModel.Collection%601> z klasy generycznej.  
  
> [!NOTE]
>  Ta metoda nie wpływa na zachowanie <xref:System.Collections.ObjectModel.KeyedCollection%602.Item%2A?displayProperty=nameWithType> właściwości, która jest tylko do odczytu.  
  
 Wywołaj implementację klasy bazowej tej metody, aby ustawić element w kolekcji źródłowej i zaktualizować słownik wyszukiwania.  
  
   
  
## Examples  
 Ta sekcja zawiera dwa przykłady kodu, które demonstrują <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> przesłanianie metody w celu zapewnienia niestandardowego zachowania <xref:System.Collections.ObjectModel.Collection%601.Item%2A?displayProperty=nameWithType> do ustawiania właściwości. Pierwszy przykład dodaje niestandardowe zdarzenie powiadomień, a drugi zapewnia obsługę kolekcji obiektów z modyfikowalnymi kluczami.  
  
 Przykład 1  
  
 Poniższy przykład kodu pokazuje <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A>, jak zastąpić chronione <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A> <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>metody,,, i <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> , aby zapewnić niestandardowe zachowanie dla <xref:System.Collections.ObjectModel.Collection%601.Add%2A> <xref:System.Collections.ObjectModel.KeyedCollection%602.Remove%2A>metod,, i <xref:System.Collections.ObjectModel.Collection%601.Clear%2A> i dla Ustawianie właściwości domyślnej <xref:System.Collections.ObjectModel.Collection%601.Item%2A> (indeksator w programie C#). Zachowanie niestandardowe podane w tym przykładzie jest zdarzeniem powiadomienia o nazwie `Changed`, które jest zgłaszane na końcu każdej z przesłoniętych metod.  
  
 Przykładowy kod tworzy `SimpleOrder` klasę, która dziedziczy z <xref:System.Collections.ObjectModel.KeyedCollection%602> i reprezentuje prosty formularz zamówienia. Formularz Order zawiera `OrderItem` obiekty reprezentujące elementy uporządkowane. W przykładzie kodu tworzona jest `SimpleOrderChangedEventArgs` również Klasa, która zawiera informacje o zdarzeniu, oraz Wyliczenie umożliwiające zidentyfikowanie typu zmiany.  
  
 Przykład kodu demonstruje zachowanie niestandardowe przez wywołanie właściwości i metod klasy pochodnej, w `Main` metodzie `Demo` klasy.  
  
 Ten przykład kodu używa obiektów z niezmiennymi kluczami. Aby zapoznać się z przykładem kodu, który używa <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A>modyfikowalnych kluczy, zobacz.  
  
 [!code-cpp[KeyedCollection2#1](~/samples/snippets/cpp/VS_Snippets_CLR/KeyedCollection2/cpp/source.cpp#1)]
 [!code-csharp[KeyedCollection2#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollection2/cs/source.cs#1)]
 [!code-vb[KeyedCollection2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollection2/vb/source.vb#1)]  
  
 Przykład 2  
  
 Poniższy przykład kodu pokazuje, jak zastąpić metodę chronioną <xref:System.Collections.ObjectModel.KeyedCollection%602.ChangeItemKey%2A> , aby obsługiwała klucze mutable i jak zastąpić <xref:System.Collections.ObjectModel.KeyedCollection%602.RemoveItem%2A>chronione <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> <xref:System.Collections.ObjectModel.KeyedCollection%602.ClearItems%2A>metody,, i <xref:System.Collections.ObjectModel.KeyedCollection%602.SetItem%2A> , aby zachować integralność kluczy i kolekcja.  
  
 Przykładowy kod tworzy `MutableKeys` kolekcję, która pochodzi od <xref:System.Collections.ObjectModel.KeyedCollection%602>, i `MutableKey` klasy. Klasa ma właściwość settable `Key`. `MutableKey` Gdy nowy klucz zostanie przypisany do właściwości, Metoda ustawiająca właściwość wywołuje `internal` metodę (`Friend` w Visual Basic) `ChangeKey` kolekcji, aby sprawdzić, czy nowy klucz koliduje z istniejącym kluczem. Jeśli tak jest, zgłaszany jest wyjątek, a wartość właściwości nie zostanie zmieniona.  
  
 Aby zachować połączenie między `MutableKey` obiektem `MutableKeys` a kolekcją i zapobiec wstawieniu obiektu `MutableKey` do dwóch kolekcji `internal` , Klasa ma (`Friend` w Visual Basic) `Collection`pole. To pole jest obsługiwane przez chronione metody, które zapewniają niestandardowe zachowanie podczas dodawania i usuwania elementów z kolekcji, takich jak <xref:System.Collections.ObjectModel.KeyedCollection%602.InsertItem%2A> Metoda. Pole jest ustawiane, gdy element zostanie dodany do kolekcji i wyczyszczony, gdy element zostanie usunięty.  
  
 [!code-csharp[KeyedCollectionMutable#1](~/samples/snippets/csharp/VS_Snippets_CLR/KeyedCollectionMutable/cs/source.cs#1)]
 [!code-vb[KeyedCollectionMutable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/KeyedCollectionMutable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Collections.ObjectModel.KeyedCollection`2.Item(`0)" />
        <altmember cref="M:System.Collections.ObjectModel.KeyedCollection`2.InsertItem(System.Int32,`1)" />
      </Docs>
    </Member>
    <Member MemberName="TryGetValue">
      <MemberSignature Language="C#" Value="public bool TryGetValue (TKey key, out TItem item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetValue(!TKey key, [out] !TItem&amp; item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.ObjectModel.KeyedCollection`2.TryGetValue(`0,`1@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetValue (key As TKey, ByRef item As TItem) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetValue(TKey key, [Runtime::InteropServices::Out] TItem % item);" />
      <MemberSignature Language="F#" Value="member this.TryGetValue : 'Key *  -&gt; bool" Usage="keyedCollection.TryGetValue (key, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ObjectModel</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="item" Type="TItem" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <param name="item">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

<Type Name="InPlaceHostingManager" FullName="System.Deployment.Application.InPlaceHostingManager">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="37a2d5acb62923ae574d83fa0e8f1aa751bfbd07" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51866131" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class InPlaceHostingManager : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit InPlaceHostingManager extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Deployment.Application.InPlaceHostingManager" />
  <TypeSignature Language="VB.NET" Value="Public Class InPlaceHostingManager&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class InPlaceHostingManager : IDisposable" />
  <TypeSignature Language="F#" Value="type InPlaceHostingManager = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Deployment</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Instalowanie lub aktualizowanie wdrożenia ClickOnce, na komputerze.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz użyć <xref:System.Deployment.Application.InPlaceHostingManager> do pisania programów tę instalację [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplikacje programistycznie. Na przykład można użyć tej klasy w środowisku kontrolowanym system zarządzania oprogramowania (SMS) lub w sytuacjach wymagających złożonej instalacji, który wykonuje wiele operacji przed instalacją lub po instalacji na komputerze lokalnym. Ogólnie rzecz biorąc należy użyć elementy członkowskie tej klasy w określonej kolejności:  
  
1.  Utwórz nowe wystąpienie klasy <xref:System.Deployment.Application.InPlaceHostingManager>.  
  
2.  Pobieranie pliku manifestu wdrożenia za pomocą <xref:System.Deployment.Application.InPlaceHostingManager.GetManifestAsync%2A>.  
  
3.  Upewnij się, że aplikacja może zostać uruchomiona z odpowiednimi uprawnieniami przy użyciu <xref:System.Deployment.Application.InPlaceHostingManager.AssertApplicationRequirements%2A>.  
  
4.  Pobieranie i instalowanie aplikacji przy użyciu <xref:System.Deployment.Application.InPlaceHostingManager.DownloadApplicationAsync%2A>.  
  
-   Jeśli chcesz wywołać dowolną z tych parametrów poza kolejnością, zgłosi wyjątek.  
  
 <xref:System.Deployment.Application.InPlaceHostingManager> można zainstalować [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplikacji, ale nie można go wykonać. Niektóre metody, w tym klasy, takie jak <xref:System.Deployment.Application.InPlaceHostingManager.Execute%2A>, są zarezerwowane do użytku podczas pobierania aplikacji opartych na programie Windows Presentation Foundation, który działa wewnątrz przeglądarki sieci Web.  
  
 Aby użyć <xref:System.Deployment.Application.InPlaceHostingManager> do pobrania i zainstalowania aplikacji, upewnij się, że certyfikat do podpisywania [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplikacji, w którym planujesz zainstalowanie jest już zainstalowana na komputerach klienckich jako zaufanego wydawcę. Aby uzyskać więcej informacji na temat zaufanych wydawców, zobacz [zaufanych Application Deployment Overview](https://msdn.microsoft.com/library/b24a1702-8fbe-45b1-87a0-9618a0708f1d).  
  
> [!NOTE]
>  Obecnie jest to ograniczenie produktu, który uniemożliwia <xref:System.Deployment.Application.InPlaceHostingManager> prawidłowe działanie podczas debugowania kodu przy użyciu programu Visual Studio. Jeśli debugujesz aplikację w programie Visual Studio przy użyciu klawisza F5 próbka będzie zgłaszają wyjątki tajemniczymi, gdy wywołujesz <xref:System.Deployment.Application.InPlaceHostingManager.DownloadApplicationAsync%2A>. Aby debugować przy użyciu programu Visual Studio, uruchom aplikację bez debugowania, a następnie dołączyć debuger. Alternatywnie można użyć inny debuger, takiego jak WinDbg.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób użycia <xref:System.Deployment.Application.InPlaceHostingManager> zainstalował [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplikacji na komputerze klienckim.  
  
 [!code-csharp[System.Deployment.Application.InPlaceHostingManager#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/CS/Form1.cs#1)]
 [!code-vb[System.Deployment.Application.InPlaceHostingManager#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/VB/Form1.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy nowe wystąpienie klasy <see cref="T:System.Deployment.Application.InPlaceHostingManager" /> pobranie i zainstalowanie określonej aplikacji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InPlaceHostingManager (Uri deploymentManifest);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri deploymentManifest) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.InPlaceHostingManager.#ctor(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (deploymentManifest As Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; InPlaceHostingManager(Uri ^ deploymentManifest);" />
      <MemberSignature Language="F#" Value="new System.Deployment.Application.InPlaceHostingManager : Uri -&gt; System.Deployment.Application.InPlaceHostingManager" Usage="new System.Deployment.Application.InPlaceHostingManager deploymentManifest" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="deploymentManifest" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="deploymentManifest">Uniform Resource Identifier (<see cref="T:System.Uri" />) do [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] manifest wdrożenia aplikacji.</param>
        <summary>Tworzy nowe wystąpienie klasy <see cref="T:System.Deployment.Application.InPlaceHostingManager" /> do pobrania i zainstalowania określona aplikacja hostowana w przeglądarce.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor jest używany, gdy chcesz pobrać aplikacji opartych na programie Windows Presentation Foundation, który znajduje się w przeglądarce sieci Web. Można pobrać opartego na formularzach Windows aplikacji, które zostały wdrożone za pomocą [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)], użyj <xref:System.Deployment.Application.InPlaceHostingManager.%23ctor%2A> konstruktora z `launchInHostProcess` parametr `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="T:System.Deployment.Application.InPlaceHostingManager" /> mogą być używane tylko w Windows XP i nowszych wersjach systemu operacyjnego Windows.</exception>
        <exception cref="T:System.ArgumentNullException">Nie można przekazać <see langword="null" /> dla <paramref name="deploymentManifest" /> argumentu.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="deploymentManifest" /> wykorzystuje schemat URI, który nie jest obsługiwany przez [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)].</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InPlaceHostingManager (Uri deploymentManifest, bool launchInHostProcess);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri deploymentManifest, bool launchInHostProcess) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.InPlaceHostingManager.#ctor(System.Uri,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (deploymentManifest As Uri, launchInHostProcess As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; InPlaceHostingManager(Uri ^ deploymentManifest, bool launchInHostProcess);" />
      <MemberSignature Language="F#" Value="new System.Deployment.Application.InPlaceHostingManager : Uri * bool -&gt; System.Deployment.Application.InPlaceHostingManager" Usage="new System.Deployment.Application.InPlaceHostingManager (deploymentManifest, launchInHostProcess)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="deploymentManifest" Type="System.Uri" />
        <Parameter Name="launchInHostProcess" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="deploymentManifest">Identyfikator URI (Uniform Resource) do manifestu wdrażania aplikacji, która zostanie zainstalowana.</param>
        <param name="launchInHostProcess">Czy ta aplikacja będzie działała w hoście, na przykład przeglądarki sieci Web. Dla aplikacji autonomicznej, ustaw tę wartość na <see langword="false" />.</param>
        <summary>Tworzy nowe wystąpienie klasy <see cref="T:System.Deployment.Application.InPlaceHostingManager" /> pobranie i zainstalowanie określonej aplikacji, który może być oparte na formularzach Windows aplikacji autonomicznej lub z aplikacją hostowaną w przeglądarce sieci Web.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć wystąpienie <xref:System.Deployment.Application.InPlaceHostingManager> dzięki niemu można będzie pobierać opartego na formularzach Windows aplikacje wdrożone za pomocą [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)].  
  
 [!code-csharp[System.Deployment.Application.InPlaceHostingManager#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/CS/Form1.cs#2)]
 [!code-vb[System.Deployment.Application.InPlaceHostingManager#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/VB/Form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="T:System.Deployment.Application.InPlaceHostingManager" /> mogą być używane tylko w Windows XP i nowszych wersjach systemu operacyjnego Windows.</exception>
        <exception cref="T:System.ArgumentNullException">Nie można przekazać <see langword="null" /> dla <paramref name="deploymentManifest" /> argumentu.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="deploymentManifest" /> wykorzystuje schemat URI, który nie jest obsługiwany przez [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)].</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AssertApplicationRequirements">
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Określa, czy aplikacja ClickOnce ma odpowiednie uprawnienia i zależności platformy działające na komputerze lokalnym.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AssertApplicationRequirements">
      <MemberSignature Language="C#" Value="public void AssertApplicationRequirements ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AssertApplicationRequirements() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.InPlaceHostingManager.AssertApplicationRequirements" />
      <MemberSignature Language="VB.NET" Value="Public Sub AssertApplicationRequirements ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AssertApplicationRequirements();" />
      <MemberSignature Language="F#" Value="member this.AssertApplicationRequirements : unit -&gt; unit" Usage="inPlaceHostingManager.AssertApplicationRequirements " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Określa, czy [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplikacja ma odpowiednie uprawnienia i zależności platformy działające na komputerze lokalnym.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy wywołać <xref:System.Deployment.Application.InPlaceHostingManager.AssertApplicationRequirements%2A> po <xref:System.Deployment.Application.InPlaceHostingManager.GetManifestAsync%2A> wróci pomyślnie. Nie należy wywołać <xref:System.Deployment.Application.InPlaceHostingManager.DownloadApplicationAsync%2A> chyba, że należy wywołać <xref:System.Deployment.Application.InPlaceHostingManager.AssertApplicationRequirements%2A>, i zwraca go bez błędów.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Deployment.Application.InPlaceHostingManager.AssertApplicationRequirements%2A>, która wywołuje w treści pomyślny <xref:System.Deployment.Application.InPlaceHostingManager.GetManifestCompleted> programu obsługi zdarzeń.  
  
 [!code-csharp[System.Deployment.Application.InPlaceHostingManager#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/CS/Form1.cs#3)]
 [!code-vb[System.Deployment.Application.InPlaceHostingManager#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/VB/Form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Wywoływane, jeśli ta metoda jest wywoływana przed <see cref="M:System.Deployment.Application.InPlaceHostingManager.GetManifestAsync" /> metody.</exception>
      </Docs>
    </Member>
    <Member MemberName="AssertApplicationRequirements">
      <MemberSignature Language="C#" Value="public void AssertApplicationRequirements (bool grantApplicationTrust);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AssertApplicationRequirements(bool grantApplicationTrust) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.InPlaceHostingManager.AssertApplicationRequirements(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AssertApplicationRequirements (grantApplicationTrust As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AssertApplicationRequirements(bool grantApplicationTrust);" />
      <MemberSignature Language="F#" Value="member this.AssertApplicationRequirements : bool -&gt; unit" Usage="inPlaceHostingManager.AssertApplicationRequirements grantApplicationTrust" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="grantApplicationTrust" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="grantApplicationTrust">Jeśli <see langword="true" />, aplikacja będzie podejmować do podniesienia swoich uprawnień do wymaganego poziomu.</param>
        <summary>Określa, czy [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplikacja ma odpowiednie uprawnienia i zależności platformy działające na komputerze lokalnym.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `grantApplicationTrust` jest `true`, <xref:System.Deployment.Application.InPlaceHostingManager> spowoduje przyznanie aplikacji podwyższony poziom uprawnień, jeśli wymaga ona je. Jest to możliwe tylko wtedy, jeśli <xref:System.Deployment.Application.InPlaceHostingManager> może przyznać te uprawnienia. Na przykład jeśli [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplikacji jest instalowany jako część pakietu większych i Instalator ma udzielone pełne zaufanie <xref:System.Deployment.Application.InPlaceHostingManager> będzie mógł udzielić [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplikacji pełnego zaufania. Jeśli `grantApplicationTrust` jest `false`, aplikacja nie otrzyma żadnych uprawnień.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CancelAsync">
      <MemberSignature Language="C#" Value="public void CancelAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.InPlaceHostingManager.CancelAsync" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelAsync ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelAsync();" />
      <MemberSignature Language="F#" Value="member this.CancelAsync : unit -&gt; unit" Usage="inPlaceHostingManager.CancelAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Anuluje operację pobierania asynchronicznego.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.InPlaceHostingManager.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="inPlaceHostingManager.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszelkie zasoby używane przez <see cref="T:System.Deployment.Application.InPlaceHostingManager" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj <xref:System.Deployment.Application.InPlaceHostingManager.Dispose%2A> po zakończeniu przy użyciu <xref:System.Deployment.Application.InPlaceHostingManager>. <xref:System.Deployment.Application.InPlaceHostingManager.Dispose%2A> Pozostawia metoda <xref:System.Deployment.Application.InPlaceHostingManager> w stanie uniemożliwiającym jego używanie. Po wywołaniu <xref:System.Deployment.Application.InPlaceHostingManager.Dispose%2A>, trzeba zwolnić wszystkie odwołania do <xref:System.Deployment.Application.InPlaceHostingManager> , moduł zbierający elementy bezużyteczne mógł odzyskać pamięć, <xref:System.Deployment.Application.InPlaceHostingManager> zajmowaną przez wystąpienie. Aby uzyskać więcej informacji, zobacz [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) i [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
> [!NOTE]
>  Zawsze wywołuj <xref:System.Deployment.Application.InPlaceHostingManager.Dispose%2A> przed publikacją swoje ostatnie odwołanie do <xref:System.Deployment.Application.InPlaceHostingManager>. W przeciwnym razie zasobów jest przy użyciu nie zostanie zwolniona, dopóki moduł odśmiecania pamięci wywołuje <xref:System.Deployment.Application.InPlaceHostingManager> obiektu `Finalize` metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DownloadApplicationAsync">
      <MemberSignature Language="C#" Value="public void DownloadApplicationAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DownloadApplicationAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.InPlaceHostingManager.DownloadApplicationAsync" />
      <MemberSignature Language="VB.NET" Value="Public Sub DownloadApplicationAsync ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DownloadApplicationAsync();" />
      <MemberSignature Language="F#" Value="member this.DownloadApplicationAsync : unit -&gt; unit" Usage="inPlaceHostingManager.DownloadApplicationAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pliki do pobrania aktualizacji aplikacji w tle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tę metodę należy wywołać po wywołaniu <xref:System.Deployment.Application.InPlaceHostingManager.AssertApplicationRequirements%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Deployment.Application.InPlaceHostingManager.DownloadApplicationAsync%2A>, która wywołuje na końcu pomyślny <xref:System.Deployment.Application.InPlaceHostingManager.GetManifestCompleted> programu obsługi zdarzeń.  
  
 W poniższych przykładach kodu założono, że masz już zdefiniowane i utworzył wystąpienie elementu <xref:System.Deployment.Application.InPlaceHostingManager> o nazwie `iphm`.  
  
 [!code-csharp[System.Deployment.Application.InPlaceHostingManager#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/CS/Form1.cs#3)]
 [!code-vb[System.Deployment.Application.InPlaceHostingManager#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/VB/Form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Wywoływane, jeśli ta metoda jest wywoływana przed <see cref="M:System.Deployment.Application.InPlaceHostingManager.GetManifestAsync" /> i <see cref="M:System.Deployment.Application.InPlaceHostingManager.AssertApplicationRequirements" /> metody.</exception>
      </Docs>
    </Member>
    <Member MemberName="DownloadApplicationCompleted">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Deployment.Application.DownloadApplicationCompletedEventArgs&gt; DownloadApplicationCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Deployment.Application.DownloadApplicationCompletedEventArgs&gt; DownloadApplicationCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Deployment.Application.InPlaceHostingManager.DownloadApplicationCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Event DownloadApplicationCompleted As EventHandler(Of DownloadApplicationCompletedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Deployment::Application::DownloadApplicationCompletedEventArgs ^&gt; ^ DownloadApplicationCompleted;" />
      <MemberSignature Language="F#" Value="member this.DownloadApplicationCompleted : EventHandler&lt;System.Deployment.Application.DownloadApplicationCompletedEventArgs&gt; " Usage="member this.DownloadApplicationCompleted : System.EventHandler&lt;System.Deployment.Application.DownloadApplicationCompletedEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Deployment.Application.DownloadApplicationCompletedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy aplikacja został pobrany na komputer lokalny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli instalujesz aplikację opartego na formularzach Windows należy poinstruować użytkowników, aby uruchomić aplikację. Nie można uruchomić aplikacji opartych na formularzach Windows programowo przy użyciu <xref:System.Deployment.Application.InPlaceHostingManager.Execute%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje obsługi dla <xref:System.Deployment.Application.InPlaceHostingManager.DownloadApplicationCompleted> zdarzeń.  
  
 [!code-csharp[System.Deployment.Application.InPlaceHostingManager#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/CS/Form1.cs#7)]
 [!code-vb[System.Deployment.Application.InPlaceHostingManager#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/VB/Form1.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DownloadProgressChanged">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Deployment.Application.DownloadProgressChangedEventArgs&gt; DownloadProgressChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Deployment.Application.DownloadProgressChangedEventArgs&gt; DownloadProgressChanged" />
      <MemberSignature Language="DocId" Value="E:System.Deployment.Application.InPlaceHostingManager.DownloadProgressChanged" />
      <MemberSignature Language="VB.NET" Value="Public Event DownloadProgressChanged As EventHandler(Of DownloadProgressChangedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Deployment::Application::DownloadProgressChangedEventArgs ^&gt; ^ DownloadProgressChanged;" />
      <MemberSignature Language="F#" Value="member this.DownloadProgressChanged : EventHandler&lt;System.Deployment.Application.DownloadProgressChangedEventArgs&gt; " Usage="member this.DownloadProgressChanged : System.EventHandler&lt;System.Deployment.Application.DownloadProgressChangedEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Deployment.Application.DownloadProgressChangedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy nie nastąpiła zmiana stanu pobierania aplikacji lub manifestu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W aplikacji konsoli zdarzenia są przypisywane do wątków z puli wątków. W związku z tym może zostać wyświetlony postęp aktualizacji zdarzeń poza kolejnością, za pomocą kolejnych zdarzeń, przedstawiający spadek w porównaniu z poprzednim zdarzeń. Nie będą widzieć takie zachowanie w przypadku aplikacji opartych na formularzach Windows, ponieważ zdarzeń w formularzach Windows Forms są przetwarzane sekwencyjnie z kolejki komunikatów w wątku interfejsu użytkownika.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób aktualizacji <xref:System.Windows.Forms.ToolStripProgressBar> zawarty w <xref:System.Windows.Forms.StatusStrip>.  
  
 [!code-csharp[System.Deployment.Application.InPlaceHostingManager#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/CS/Form1.cs#6)]
 [!code-vb[System.Deployment.Application.InPlaceHostingManager#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle Execute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle Execute() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.InPlaceHostingManager.Execute" />
      <MemberSignature Language="VB.NET" Value="Public Function Execute () As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ Execute();" />
      <MemberSignature Language="F#" Value="member this.Execute : unit -&gt; System.Runtime.Remoting.ObjectHandle" Usage="inPlaceHostingManager.Execute " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Uruchamia [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplikacji tylko wtedy, gdy jest to aplikacja na podstawie Windows Presentation Foundation uruchomiony w przeglądarce sieci Web.</summary>
        <returns>
          <see cref="T:System.Runtime.Remoting.ObjectHandle" /> Odpowiadający uruchomionej aplikacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest prawidłowa tylko dla aplikacji Windows Presentation Foundation, która może być hostowana w przeglądarce sieci Web (czyli definiowanie ich manifesty wdrożenia `hostInBrowser` — element XML).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetManifestAsync">
      <MemberSignature Language="C#" Value="public void GetManifestAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GetManifestAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.InPlaceHostingManager.GetManifestAsync" />
      <MemberSignature Language="VB.NET" Value="Public Sub GetManifestAsync ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GetManifestAsync();" />
      <MemberSignature Language="F#" Value="member this.GetManifestAsync : unit -&gt; unit" Usage="inPlaceHostingManager.GetManifestAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pliki do pobrania manifestu wdrażania [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplikacji w tle i zgłasza zdarzenie, gdy operacja zostało ukończone lub wystąpił błąd.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby otrzymać powiadomienie po zakończeniu tego wydarzenia, należy utworzyć program obsługi zdarzeń dla <xref:System.Deployment.Application.InPlaceHostingManager.GetManifestCompleted> zdarzeń. Jeśli to zdarzenie jest wywoływane, a błąd nie jest wskazywany przez <xref:System.Deployment.Application.GetManifestCompletedEventArgs>, należy wywołać następne <xref:System.Deployment.Application.InPlaceHostingManager.AssertApplicationRequirements%2A> Aby sprawdzić, czy aplikacja będzie miała uprawnienia do uruchamiania na komputerze lokalnym.  
  
   
  
## Examples  
 Poniższe przykłady kodu przedstawiają sposób wywołania <xref:System.Deployment.Application.InPlaceHostingManager.GetManifestAsync%2A> metody. Obsługa <xref:System.Deployment.Application.InPlaceHostingManager.GetManifestCompleted> zdarzeń wywołania zwrotnego sprawdza, jeśli pomyślnie ukończono manifestu do pobrania i monituje użytkownika o dodatkowe informacje o aplikacji. Jeśli użytkownik zgadza się kontynuować instalację, program obsługi wyjątku wywołuje <xref:System.Deployment.Application.InPlaceHostingManager.DownloadApplicationAsync%2A>.  
  
 W poniższych przykładach kodu założono, że masz już zdefiniowane i utworzył wystąpienie elementu <xref:System.Deployment.Application.InPlaceHostingManager> o nazwie `iphm`.  
  
 [!code-csharp[System.Deployment.Application.InPlaceHostingManager#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/CS/Form1.cs#3)]
 [!code-vb[System.Deployment.Application.InPlaceHostingManager#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/VB/Form1.vb#3)]  
  
 [!code-csharp[System.Deployment.Application.InPlaceHostingManager#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/CS/Form1.cs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetManifestCompleted">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Deployment.Application.GetManifestCompletedEventArgs&gt; GetManifestCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Deployment.Application.GetManifestCompletedEventArgs&gt; GetManifestCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Deployment.Application.InPlaceHostingManager.GetManifestCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Event GetManifestCompleted As EventHandler(Of GetManifestCompletedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Deployment::Application::GetManifestCompletedEventArgs ^&gt; ^ GetManifestCompleted;" />
      <MemberSignature Language="F#" Value="member this.GetManifestCompleted : EventHandler&lt;System.Deployment.Application.GetManifestCompletedEventArgs&gt; " Usage="member this.GetManifestCompleted : System.EventHandler&lt;System.Deployment.Application.GetManifestCompletedEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Deployment.Application.GetManifestCompletedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy manifest wdrożenia został pobrany na komputerze lokalnym.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> właściwość <xref:System.Deployment.Application.GetManifestCompletedEventArgs> Aby sprawdzić, czy <xref:System.Deployment.Application.InPlaceHostingManager.GetManifestAsync%2A> została ukończona pomyślnie, lub zwróciło błąd. Jeśli <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> ma wartość null, <xref:System.Deployment.Application.InPlaceHostingManager.GetManifestAsync%2A> została ukończona pomyślnie, a może wywołać <xref:System.Deployment.Application.InPlaceHostingManager.AssertApplicationRequirements%2A>.  
  
   
  
## Examples  
 Poniższe przykłady kodu przedstawiają sposób wywołania <xref:System.Deployment.Application.InPlaceHostingManager.GetManifestAsync%2A> metody. Obsługa <xref:System.Deployment.Application.InPlaceHostingManager.GetManifestCompleted> zdarzeń wywołania zwrotnego sprawdza, jeśli pomyślnie ukończono manifestu do pobrania i monituje użytkownika o dodatkowe informacje o aplikacji. Jeśli użytkownik zgadza się kontynuować instalację, program obsługi wyjątku wywołuje <xref:System.Deployment.Application.InPlaceHostingManager.DownloadApplicationAsync%2A>.  
  
 W poniższych przykładach kodu założono, że masz już zdefiniowane i utworzył wystąpienie elementu <xref:System.Deployment.Application.InPlaceHostingManager> o nazwie `iphm`.  
  
 [!code-csharp[System.Deployment.Application.InPlaceHostingManager#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/CS/Form1.cs#2)]
 [!code-vb[System.Deployment.Application.InPlaceHostingManager#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/VB/Form1.vb#2)]  
  
 [!code-csharp[System.Deployment.Application.InPlaceHostingManager#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/CS/Form1.cs#3)]
 [!code-vb[System.Deployment.Application.InPlaceHostingManager#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Deployment.Application.InPlaceHostingManager/VB/Form1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UninstallCustomAddIn">
      <MemberSignature Language="C#" Value="public static void UninstallCustomAddIn (string subscriptionId);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void UninstallCustomAddIn(string subscriptionId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.InPlaceHostingManager.UninstallCustomAddIn(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub UninstallCustomAddIn (subscriptionId As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void UninstallCustomAddIn(System::String ^ subscriptionId);" />
      <MemberSignature Language="F#" Value="static member UninstallCustomAddIn : string -&gt; unit" Usage="System.Deployment.Application.InPlaceHostingManager.UninstallCustomAddIn subscriptionId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subscriptionId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="subscriptionId">Ciąg, który zawiera identyfikator subskrypcji, co oznacza, aby usunąć dodatek.</param>
        <summary>Usuwa wcześniej zainstalowanych składników zdefiniowanych przez użytkownika aplikacji.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="subscriptionId" /> nie jest tożsamością ważnej subskrypcji lub nie zawiera nazwy, token klucza publicznego, architektura procesora i numer wersji.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="subscriptionId" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="UninstallCustomUXApplication">
      <MemberSignature Language="C#" Value="public static void UninstallCustomUXApplication (string subscriptionId);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void UninstallCustomUXApplication(string subscriptionId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.InPlaceHostingManager.UninstallCustomUXApplication(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub UninstallCustomUXApplication (subscriptionId As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void UninstallCustomUXApplication(System::String ^ subscriptionId);" />
      <MemberSignature Language="F#" Value="static member UninstallCustomUXApplication : string -&gt; unit" Usage="System.Deployment.Application.InPlaceHostingManager.UninstallCustomUXApplication subscriptionId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="subscriptionId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="subscriptionId">Ciąg, który zawiera identyfikator subskrypcji, co oznacza [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplikacji do usunięcia.</param>
        <summary>Usuwa [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplikacji, która obejmuje &lt;customUX&gt; elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda powoduje odinstalowanie wcześniej zainstalowanych [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplikacji, która używa `<customUX>` element [ &lt;punktu wejścia&gt; elementu](/visualstudio/deployment/entrypoint-element-clickonce-application).  
  
 Niestandardowych instalatorów, które nie tworzą wpis dla apletu Dodaj lub usuń programy [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplikacji muszą być przechowywane identyfikator subskrypcji znaleziony w <xref:System.Deployment.Application.GetManifestCompletedEventArgs.SubscriptionIdentity%2A> właściwości podczas instalacji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
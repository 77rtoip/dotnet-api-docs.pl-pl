<Type Name="ApplicationDeployment" FullName="System.Deployment.Application.ApplicationDeployment">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="6f9e1fd8a5a955ed0e85469506d05a03f3e7514d" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="08/24/2018" />
    <Meta Name="ms.locfileid" Value="37667650" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class ApplicationDeployment" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ApplicationDeployment extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Deployment.Application.ApplicationDeployment" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ApplicationDeployment" />
  <TypeSignature Language="C++ CLI" Value="public ref class ApplicationDeployment sealed" />
  <TypeSignature Language="F#" Value="type ApplicationDeployment = class" />
  <AssemblyInfo>
    <AssemblyName>System.Deployment</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Programowe obsługuje aktualizacje bieżącego wdrożenia i obsługi na żądanie pobierania plików. Klasa ta nie może być dziedziczona.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można skonfigurować usługi [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplikacji, aby sprawdzać dostępność aktualizacji i zainstalować je automatycznie za pomocą `subscription` elementu manifestu wdrożenia. Niektóre aplikacje muszą jednak bardziej precyzyjną kontrolę nad ich aktualizacji. Możesz programowo instalowanie wymaganych aktualizacji w celu monitowania użytkowników, aby zainstalować aktualizacje opcjonalne własnego uznania. Wyłączenie subskrypcji aktualizacji w pliku manifestu wdrożenia, może potrwać pełną kontrolę nad zasady aktualizacji aplikacji. Alternatywnie, można użyć automatycznego subskrypcji w połączeniu z <xref:System.Deployment.Application.ApplicationDeployment>, co pozwoli [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] okresowo zaktualizować aplikacji, ale używa <xref:System.Deployment.Application.ApplicationDeployment> Aby pobrać aktualizacje krytyczne, wkrótce, po ich wydaniu.  
  
 Możesz sprawdzić, czy wdrożenie ma dostępną aktualizację za pomocą <xref:System.Deployment.Application.ApplicationDeployment.CheckForUpdate%2A> lub <xref:System.Deployment.Application.ApplicationDeployment.CheckForUpdateAsync%2A> metody; Metoda zgłasza druga metoda <xref:System.Deployment.Application.ApplicationDeployment.CheckForUpdateCompleted> zdarzenie na pomyślne zakończenie. <xref:System.Deployment.Application.ApplicationDeployment.CheckForDetailedUpdate%2A> Zwraca ważne informacje o aktualizacji, takie jak jego numer wersji i czy jest wymagana aktualizacja bieżących użytkowników. Jeśli jest dostępna aktualizacja, możesz go zainstalować przy użyciu <xref:System.Deployment.Application.ApplicationDeployment.Update%2A> lub <xref:System.Deployment.Application.ApplicationDeployment.UpdateAsync%2A>; druga metoda zgłasza <xref:System.Deployment.Application.ApplicationDeployment.UpdateCompleted> zdarzeń po zakończeniu instalacji aktualizacji. Dla dużych aktualizacji może odbierać powiadomienia o postępie za pośrednictwem <xref:System.Deployment.Application.ApplicationDeployment.CheckForUpdateProgressChanged> i <xref:System.Deployment.Application.ApplicationDeployment.UpdateProgressChanged> zdarzenia i skorzystaj z informacji w <xref:System.ComponentModel.ProgressChangedEventArgs> do powiadamiania użytkownika stan pobierania.  
  
 Można również użyć <xref:System.Deployment.Application.ApplicationDeployment> pobieranie dużych plików i zestawów na żądanie. Te pliki muszą być oznaczone jako "opcjonalny" w ramach wdrażania, manifest aplikacji, dzięki czemu nie zostaną pobrane podczas instalacji. Możesz pobrać pliki w dowolnym momencie podczas okresu aplikacji przy użyciu <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroup%2A> lub <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupAsync%2A> metody. Możesz pobrać zestawów, zanim zostaną załadowane do pamięci poprzez dostarczenie program obsługi zdarzeń dla <xref:System.AppDomain.AssemblyResolve> zdarzenie na <xref:System.AppDomain> klasy. Aby uzyskać więcej informacji, zobacz [wskazówki: Pobieranie zestawów na żądanie przy użyciu technologii ClickOnce wdrażania interfejsu API przy użyciu narzędzia Projektant](http://msdn.microsoft.com/library/59a0dd5f-1cab-4f2f-b780-0ab7399905d5).  
  
> [!NOTE]
>  Jeśli zaktualizujesz [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplikacji, gdy aplikacja jest uruchomiona, użytkownicy nie otrzymają aktualizacje do czasu wywołania <xref:System.Windows.Forms.Application.Restart%2A> metody <xref:System.Windows.Forms.Application>, co spowoduje zamknięcie bieżącego uruchomionego wystąpienia aplikacji i natychmiastowe ponowne uruchomienie go.  
  
 <xref:System.Deployment.Application.ApplicationDeployment> nie ma publicznego konstruktora; Uzyskaj wystąpienia klasy w ramach [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplikacji za pośrednictwem <xref:System.Deployment.Application.ApplicationDeployment.CurrentDeployment%2A> właściwości. Możesz użyć <xref:System.Deployment.Application.ApplicationDeployment.IsNetworkDeployed%2A> właściwość, aby sprawdzić, czy bieżąca aplikacja jest [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplikacji.  
  
 <xref:System.Deployment.Application.ApplicationDeployment> obsługuje sprawdzanie dostępności aktualizacji i pobrać zaktualizowane pliki asynchronicznie za pomocą nowego [oparte na zdarzeniach asynchronicznych omówienie wzorca](~/docs/standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-overview.md), który udostępnia ukończenia wywołania zwrotne, jako klasę zdarzenia. <xref:System.Deployment.Application.ApplicationDeployment> rozpoczyna się i zarządza wątków i ponownie wywołuje aplikację na poprawne wątku interfejsu użytkownika. Za pomocą tej klasy można zaktualizować bez blokowania aplikacji, dzięki czemu użytkownik może kontynuować pracy podczas instalacji aktualizacji. Jeśli użytkownik należy zatrzymać wszystkie prace, podczas aktualizacji, także synchroniczne metody zamiast tego Rozważ użycie.  
  
> [!NOTE]
>  Wykonywanie asynchronicznych aktualizacji wymaga aplikacji zaimportuj oba <xref:System.Deployment.Application> i <xref:System.ComponentModel> przestrzeni nazw.  
  
   
  
## Examples  
 Poniższy przykład kodu określa się w czasie ładowania aplikacji, czy nowa aktualizacja jest dostępna; Jeśli wymagana aktualizacja jest dostępna, przykładowy kod instaluje aktualizację asynchronicznie. Ten kod należy dodać do formularza, który zawiera <xref:System.Windows.Forms.TextBox> o nazwie `downloadStatus`.  
  
 [!code-cpp[ClickOnceAPI#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ClickOnceAPI/cpp/form1.cpp#1)]
 [!code-csharp[ClickOnceAPI#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#1)]
 [!code-vb[ClickOnceAPI#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceAPI/VB/Form1.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="ActivationUri">
      <MemberSignature Language="C#" Value="public Uri ActivationUri { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri ActivationUri" />
      <MemberSignature Language="DocId" Value="P:System.Deployment.Application.ApplicationDeployment.ActivationUri" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ActivationUri As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ ActivationUri { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ActivationUri : Uri" Usage="System.Deployment.Application.ApplicationDeployment.ActivationUri" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera adres URL używany do uruchomienia pliku manifestu wdrożenia aplikacji.</summary>
        <value>Ciąg o zerowej długości, jeśli <c>TrustUrlParameters</c> właściwość w pliku manifestu wdrożenia jest <see langword="false" />, lub jeśli użytkownik udostępnił UNC, aby otworzyć wdrożenia lub otworzył ją lokalnie. W przeciwnym razie wartość zwracana jest pełny adres URL używany do uruchamiania aplikacji, w tym żadnych parametrów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość będzie działać w pełni zaufany i częściowo zaufanych aplikacji.  
  
   
  
## Examples  
 Poniższy kod przedstawia sposób pobierania parametrów adresu URL za pomocą <xref:System.Deployment.Application.ApplicationDeployment.ActivationUri%2A>i sposobu używania <xref:System.Web.HttpUtility> klasy można bezpiecznie przeanalizować ciągu zapytania. Wiele wystąpień tej samej zmiennej ciągu zapytania i dalszych są skonsolidowane w jeden wpis zwracanego <xref:System.Collections.Specialized.NameValueCollection>.  
  
 [!code-csharp[ClickOnceQueryString#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceQueryString/CS/Form1.cs#1)]
 [!code-vb[ClickOnceQueryString#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceQueryString/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CheckForDetailedUpdate">
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wykonuje tę samą operację jako <see cref="M:System.Deployment.Application.ApplicationDeployment.CheckForUpdate" />, ale zwraca rozszerzone informacje o dostępnej aktualizacji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CheckForDetailedUpdate">
      <MemberSignature Language="C#" Value="public System.Deployment.Application.UpdateCheckInfo CheckForDetailedUpdate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Deployment.Application.UpdateCheckInfo CheckForDetailedUpdate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.ApplicationDeployment.CheckForDetailedUpdate" />
      <MemberSignature Language="VB.NET" Value="Public Function CheckForDetailedUpdate () As UpdateCheckInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Deployment::Application::UpdateCheckInfo ^ CheckForDetailedUpdate();" />
      <MemberSignature Language="F#" Value="member this.CheckForDetailedUpdate : unit -&gt; System.Deployment.Application.UpdateCheckInfo" Usage="applicationDeployment.CheckForDetailedUpdate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Deployment.Application.UpdateCheckInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wykonuje tę samą operację jako <see cref="M:System.Deployment.Application.ApplicationDeployment.CheckForUpdate" />, ale zwraca rozszerzone informacje o dostępnej aktualizacji.</summary>
        <returns>
          <see cref="T:System.Deployment.Application.UpdateCheckInfo" /> Dostępnych aktualizacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Deployment.Application.ApplicationDeployment.CheckForDetailedUpdate%2A> Metoda umożliwia synchroniczne wywołujących uzyskać takie same rozszerzone informacje wywołań asynchronicznych uzyskać za pomocą <xref:System.Deployment.Application.CheckForUpdateCompletedEventArgs> klasy.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Deployment.Application.ApplicationDeployment.CheckForDetailedUpdate%2A> można pobrać informacji na temat najnowszej aktualizacji. Jeśli istnieje aktualizację, jego instaluje je automatycznie tylko wtedy, gdy jest wymagana aktualizacja; w przeciwnym razie użytkownik jest monitowany.  
  
 [!code-cpp[ClickOnceAPI#7](~/samples/snippets/cpp/VS_Snippets_Winforms/ClickOnceAPI/cpp/form1.cpp#7)]
 [!code-csharp[ClickOnceAPI#7](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#7)]
 [!code-vb[ClickOnceAPI#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceAPI/VB/Form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Bieżąca aplikacja albo nie skonfigurowano do obsługi aktualizacji lub inna operacja sprawdzania aktualizacji w toku.</exception>
        <exception cref="T:System.Deployment.Application.DeploymentDownloadException">Nie można pobrać manifestu wdrażania. Wyjątek ten pojawi się w <see cref="P:System.ComponentModel.AsyncCompletedEventArgs.Error" /> właściwość <see cref="E:System.Deployment.Application.ApplicationDeployment.CheckForUpdateCompleted" /> zdarzeń.</exception>
        <exception cref="T:System.Deployment.Application.InvalidDeploymentException">Manifest wdrożenia jest uszkodzony. Przed przystąpieniem do wdrożenia tej aplikacji do użytkowników, należy ponownie wygenerować manifest aplikacji. Wyjątek ten pojawi się w <see cref="P:System.ComponentModel.AsyncCompletedEventArgs.Error" /> właściwość <see cref="E:System.Deployment.Application.ApplicationDeployment.CheckForUpdateCompleted" /> zdarzeń.</exception>
        <permission cref="T:System.Security.PermissionSet">Aby uzyskać pełny dostęp do komputera lokalnego. Powiązane wyliczenie: <see cref="T:System.Security.Permissions.PermissionState" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CheckForDetailedUpdate">
      <MemberSignature Language="C#" Value="public System.Deployment.Application.UpdateCheckInfo CheckForDetailedUpdate (bool persistUpdateCheckResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Deployment.Application.UpdateCheckInfo CheckForDetailedUpdate(bool persistUpdateCheckResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.ApplicationDeployment.CheckForDetailedUpdate(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function CheckForDetailedUpdate (persistUpdateCheckResult As Boolean) As UpdateCheckInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Deployment::Application::UpdateCheckInfo ^ CheckForDetailedUpdate(bool persistUpdateCheckResult);" />
      <MemberSignature Language="F#" Value="member this.CheckForDetailedUpdate : bool -&gt; System.Deployment.Application.UpdateCheckInfo" Usage="applicationDeployment.CheckForDetailedUpdate persistUpdateCheckResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Deployment.Application.UpdateCheckInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="persistUpdateCheckResult" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="persistUpdateCheckResult">Jeśli <see langword="false" />aktualizacji zostaną zastosowane w trybie dyskretnym i okno dialogowe, nie będą wyświetlane.</param>
        <summary>Wykonuje tę samą operację jako <see cref="M:System.Deployment.Application.ApplicationDeployment.CheckForUpdate" />, ale zwraca rozszerzone informacje o dostępnej aktualizacji.</summary>
        <returns>
          <see cref="T:System.Deployment.Application.UpdateCheckInfo" /> Dostępnych aktualizacji.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CheckForUpdate">
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sprawdza, czy <see cref="P:System.Deployment.Application.ApplicationDeployment.UpdateLocation" /> do określenia, czy dostępna jest nowa aktualizacja.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CheckForUpdate">
      <MemberSignature Language="C#" Value="public bool CheckForUpdate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CheckForUpdate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.ApplicationDeployment.CheckForUpdate" />
      <MemberSignature Language="VB.NET" Value="Public Function CheckForUpdate () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CheckForUpdate();" />
      <MemberSignature Language="F#" Value="member this.CheckForUpdate : unit -&gt; bool" Usage="applicationDeployment.CheckForUpdate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sprawdza, czy <see cref="P:System.Deployment.Application.ApplicationDeployment.UpdateLocation" /> do określenia, czy dostępna jest nowa aktualizacja.</summary>
        <returns>
          <see langword="true" /> Jeśli nowa aktualizacja jest dostępna; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Deployment.Application.ApplicationDeployment.CheckForUpdate%2A> Metoda porównuje wersja aktualnie zainstalowanego wdrożenia przy użyciu podanej w pliku manifestu wdrożenia w wersji <xref:System.Deployment.Application.ApplicationDeployment.UpdateLocation%2A>. Jeśli wersja na serwerze różni się od zainstalowanej wersji, zwraca `true`.  
  
 Ta metoda będzie blokować ukończenie wyboru. Aby sprawdzić, czy aktualizację asynchronicznie, należy użyć <xref:System.Deployment.Application.ApplicationDeployment.CheckForUpdateAsync%2A> metody zamiast tego.  
  
> [!NOTE]
>  Jeśli <xref:System.Deployment.Application.ApplicationDeployment.CheckForUpdate%2A> wykrywa, że jest dostępna aktualizacja, a użytkownik nie zdecyduje się na jej instalacji, [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] będzie monitował użytkownika, która jest dostępna aktualizacja, przy następnym uruchomieniu aplikacji. Nie ma możliwości można wyłączyć ten monit. (Jeśli aplikacja jest wymagana aktualizacja [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] zostanie zainstalowany bez monitowania użytkownika.)  
  
   
  
## Examples  
 Poniższy przykład kodu sprawdza o aktualizację aplikacji; Jeśli jest dostępny, instaluje go synchronicznie.  
  
 [!code-cpp[ClickOnceAPI#5](~/samples/snippets/cpp/VS_Snippets_Winforms/ClickOnceAPI/cpp/form1.cpp#5)]
 [!code-csharp[ClickOnceAPI#5](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#5)]
 [!code-vb[ClickOnceAPI#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceAPI/VB/Form1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] natychmiast zgłasza ten wyjątek, jeśli wywołujesz <see cref="M:System.Deployment.Application.ApplicationDeployment.CheckForUpdate" /> metody, gdy aktualizacja jest już w toku.</exception>
        <exception cref="T:System.Deployment.Application.DeploymentDownloadException">Nie można pobrać manifestu wdrażania.</exception>
        <exception cref="T:System.Deployment.Application.InvalidDeploymentException">Manifest wdrożenia jest uszkodzony. Prawdopodobnie konieczne będzie ponowne wdrażanie aplikacji, aby rozwiązać ten problem.</exception>
        <permission cref="T:System.Security.PermissionSet">Aby uzyskać pełny dostęp do komputera lokalnego. Powiązane wyliczenie: <see cref="T:System.Security.Permissions.PermissionState" />.</permission>
        <altmember cref="M:System.Deployment.Application.ApplicationDeployment.CheckForUpdateAsync" />
        <altmember cref="M:System.Deployment.Application.ApplicationDeployment.CheckForDetailedUpdate" />
      </Docs>
    </Member>
    <Member MemberName="CheckForUpdate">
      <MemberSignature Language="C#" Value="public bool CheckForUpdate (bool persistUpdateCheckResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CheckForUpdate(bool persistUpdateCheckResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.ApplicationDeployment.CheckForUpdate(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function CheckForUpdate (persistUpdateCheckResult As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CheckForUpdate(bool persistUpdateCheckResult);" />
      <MemberSignature Language="F#" Value="member this.CheckForUpdate : bool -&gt; bool" Usage="applicationDeployment.CheckForUpdate persistUpdateCheckResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="persistUpdateCheckResult" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="persistUpdateCheckResult">Jeśli <see langword="false" />aktualizacji zostaną zastosowane w trybie dyskretnym i okno dialogowe, nie będą wyświetlane.</param>
        <summary>Sprawdza, czy <see cref="P:System.Deployment.Application.ApplicationDeployment.UpdateLocation" /> do określenia, czy dostępna jest nowa aktualizacja.</summary>
        <returns>
          <see langword="true" /> Jeśli nowa aktualizacja jest dostępna; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckForUpdateAsync">
      <MemberSignature Language="C#" Value="public void CheckForUpdateAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CheckForUpdateAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.ApplicationDeployment.CheckForUpdateAsync" />
      <MemberSignature Language="VB.NET" Value="Public Sub CheckForUpdateAsync ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CheckForUpdateAsync();" />
      <MemberSignature Language="F#" Value="member this.CheckForUpdateAsync : unit -&gt; unit" Usage="applicationDeployment.CheckForUpdateAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sprawdza, czy <see cref="P:System.Deployment.Application.ApplicationDeployment.UpdateLocation" /> asynchronicznie, aby ustalić, czy dostępna jest nowa aktualizacja.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Deployment.Application.ApplicationDeployment.CheckForUpdateAsync%2A> zwraca niezwłocznie i rozpoczyna się w oddzielnym wątku pobrać zaktualizowaną aplikację. Jeśli metoda zakończy się lub zostało anulowane, zgłasza <xref:System.Deployment.Application.ApplicationDeployment.CheckForUpdateCompleted> zdarzeń. Możesz użyć <xref:System.ComponentModel.AsyncCompletedEventArgs> w tej obsługi zdarzeń, aby określić, czy operacja została anulowana lub jeśli wystąpił wyjątek podczas aktualizacji.  
  
 Możesz anulować aktualizację asynchronicznego, wywołując <xref:System.Deployment.Application.ApplicationDeployment.CheckForUpdateAsyncCancel%2A>.  
  
> [!NOTE]
>  Jeśli <xref:System.Deployment.Application.ApplicationDeployment.CheckForUpdate%2A> wykrywa, że jest dostępna aktualizacja, a użytkownik nie zdecyduje się na jej instalacji, [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] będzie monitował użytkownika, która jest dostępna aktualizacja, przy następnym uruchomieniu aplikacji. Nie ma możliwości można wyłączyć ten monit. (Jeśli aplikacja jest wymagana aktualizacja [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] zostanie zainstalowany bez monitowania użytkownika.)  
  
   
  
## Examples  
 Poniższy przykład sprawdza, czy aktualizację asynchronicznie, a następnie instaluje aktualizację, jeśli taka istnieje.  
  
 [!code-cpp[ClickOnceAPI#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ClickOnceAPI/cpp/form1.cpp#1)]
 [!code-csharp[ClickOnceAPI#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#1)]
 [!code-vb[ClickOnceAPI#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceAPI/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] natychmiast zgłasza ten wyjątek, jeśli wywołujesz <see cref="M:System.Deployment.Application.ApplicationDeployment.CheckForUpdateAsync" /> metody, gdy aktualizacja jest już w toku.</exception>
        <exception cref="T:System.Deployment.Application.DeploymentDownloadException">Nie można pobrać manifestu wdrażania. Ten wyjątek, który pojawia się w <see cref="P:System.ComponentModel.AsyncCompletedEventArgs.Error" /> właściwość <see cref="E:System.Deployment.Application.ApplicationDeployment.CheckForUpdateCompleted" /> zdarzeń.</exception>
        <exception cref="T:System.Deployment.Application.InvalidDeploymentException">Manifest wdrożenia jest uszkodzony. Prawdopodobnie konieczne będzie ponowne wdrażanie aplikacji, aby rozwiązać ten problem. Ten wyjątek, który pojawia się w <see cref="P:System.ComponentModel.AsyncCompletedEventArgs.Error" /> właściwość <see cref="E:System.Deployment.Application.ApplicationDeployment.CheckForUpdateCompleted" /> zdarzeń.</exception>
        <permission cref="T:System.Security.PermissionSet">Aby uzyskać pełny dostęp do komputera lokalnego. Powiązane wyliczenie: <see cref="T:System.Security.Permissions.PermissionState" />.</permission>
        <altmember cref="M:System.Deployment.Application.ApplicationDeployment.CheckForUpdate" />
        <altmember cref="M:System.Deployment.Application.ApplicationDeployment.CheckForDetailedUpdate" />
        <altmember cref="M:System.Deployment.Application.ApplicationDeployment.CheckForUpdateAsyncCancel" />
      </Docs>
    </Member>
    <Member MemberName="CheckForUpdateAsyncCancel">
      <MemberSignature Language="C#" Value="public void CheckForUpdateAsyncCancel ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CheckForUpdateAsyncCancel() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.ApplicationDeployment.CheckForUpdateAsyncCancel" />
      <MemberSignature Language="VB.NET" Value="Public Sub CheckForUpdateAsyncCancel ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CheckForUpdateAsyncCancel();" />
      <MemberSignature Language="F#" Value="member this.CheckForUpdateAsyncCancel : unit -&gt; unit" Usage="applicationDeployment.CheckForUpdateAsyncCancel " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Umożliwia anulowanie sprawdzania aktualizacji asynchronicznego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia anulowanie sprawdzania aktualizacji inicjowane za pomocą <xref:System.Deployment.Application.ApplicationDeployment.CheckForUpdateAsync%2A> metody.  
  
 Ta metoda nie spowoduje anulowanie wszelkich aktualizacji tła, która może już być w toku, takich jak uruchomiono aktualizację w ramach subskrypcji. Aby uzyskać więcej informacji o subskrypcjach, zobacz [Wybieranie strategii aktualizacji ClickOnce](http://msdn.microsoft.com/library/d8b6e7bb-4ea0-47f3-91cd-48580bdceccc).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckForUpdateCompleted">
      <MemberSignature Language="C#" Value="public event System.Deployment.Application.CheckForUpdateCompletedEventHandler CheckForUpdateCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Deployment.Application.CheckForUpdateCompletedEventHandler CheckForUpdateCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Deployment.Application.ApplicationDeployment.CheckForUpdateCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event CheckForUpdateCompleted As CheckForUpdateCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Deployment::Application::CheckForUpdateCompletedEventHandler ^ CheckForUpdateCompleted;" />
      <MemberSignature Language="F#" Value="member this.CheckForUpdateCompleted : System.Deployment.Application.CheckForUpdateCompletedEventHandler " Usage="member this.CheckForUpdateCompleted : System.Deployment.Application.CheckForUpdateCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Deployment.Application.CheckForUpdateCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy <see cref="M:System.Deployment.Application.ApplicationDeployment.CheckForUpdateAsync" /> zostało zakończone.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Deployment.Application.CheckForUpdateCompletedEventArgs> Klasy poinformuje, między innymi, wersja aktualizacji, jak duże jest aktualizacji oraz czy jest dostępna aktualizacja, wymagane lub opcjonalne.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Deployment.Application.ApplicationDeployment.CheckForUpdateCompleted> zdecydować, czy należy poprosić użytkownika o zainstalowanie aktualizacji dostępnych aplikacji. Jeśli aktualizacja jest obowiązkowa uaktualniania <xref:System.Deployment.Application.ApplicationDeployment.CheckForUpdateCompleted> program obsługi zdarzeń nie wyświetlać monitu. Przykład wymaga wdrażania aplikacji Windows Forms, która obejmuje <xref:System.Windows.Forms.StatusStrip> kontroli i że zawierają ten formant <xref:System.Windows.Forms.ToolStripStatusLabel> formantu o nazwie `downloadStatus`.  
  
 [!code-cpp[ClickOnceAPI#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ClickOnceAPI/cpp/form1.cpp#1)]
 [!code-csharp[ClickOnceAPI#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#1)]
 [!code-vb[ClickOnceAPI#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceAPI/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckForUpdateProgressChanged">
      <MemberSignature Language="C#" Value="public event System.Deployment.Application.DeploymentProgressChangedEventHandler CheckForUpdateProgressChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Deployment.Application.DeploymentProgressChangedEventHandler CheckForUpdateProgressChanged" />
      <MemberSignature Language="DocId" Value="E:System.Deployment.Application.ApplicationDeployment.CheckForUpdateProgressChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event CheckForUpdateProgressChanged As DeploymentProgressChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Deployment::Application::DeploymentProgressChangedEventHandler ^ CheckForUpdateProgressChanged;" />
      <MemberSignature Language="F#" Value="member this.CheckForUpdateProgressChanged : System.Deployment.Application.DeploymentProgressChangedEventHandler " Usage="member this.CheckForUpdateProgressChanged : System.Deployment.Application.DeploymentProgressChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Deployment.Application.DeploymentProgressChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy aktualizację postępu jest dostępna w <see cref="M:System.Deployment.Application.ApplicationDeployment.CheckForUpdateAsync" /> wywołania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Deployment.Application.ApplicationDeployment.CheckForUpdateProgressChanged> Raporty dotyczące pobierania stanu wdrożenia aplikacji w manifeście. Może to być ważna informacja dla użytkowników, którzy są pobranie wdrożenia przez wolne połączenia sieciowe.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Deployment.Application.ApplicationDeployment.CheckForUpdateProgressChanged> zdarzenie, aby poinformować użytkownika, jaka część pliku manifestu wdrożenia pozostało do pobrania. Przykład wymaga wdrażania aplikacji Windows Forms, która obejmuje <xref:System.Windows.Forms.StatusStrip> kontroli i że zawierają ten formant <xref:System.Windows.Forms.ToolStripStatusLabel> formantu o nazwie `downloadStatus`...  
  
 [!code-cpp[ClickOnceAPI#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ClickOnceAPI/cpp/form1.cpp#1)]
 [!code-csharp[ClickOnceAPI#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#1)]
 [!code-vb[ClickOnceAPI#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceAPI/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentDeployment">
      <MemberSignature Language="C#" Value="public static System.Deployment.Application.ApplicationDeployment CurrentDeployment { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Deployment.Application.ApplicationDeployment CurrentDeployment" />
      <MemberSignature Language="DocId" Value="P:System.Deployment.Application.ApplicationDeployment.CurrentDeployment" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentDeployment As ApplicationDeployment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Deployment::Application::ApplicationDeployment ^ CurrentDeployment { System::Deployment::Application::ApplicationDeployment ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentDeployment : System.Deployment.Application.ApplicationDeployment" Usage="System.Deployment.Application.ApplicationDeployment.CurrentDeployment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Deployment.Application.ApplicationDeployment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zwraca bieżącą <see cref="T:System.Deployment.Application.ApplicationDeployment" /> dla tego wdrożenia.</summary>
        <value>Bieżącego wdrożenia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie można utworzyć wystąpienia elementu <xref:System.Deployment.Application.ApplicationDeployment> bezpośrednio w aplikacji; musi pobrać prawidłowe wystąpienie za pośrednictwem <xref:System.Deployment.Application.ApplicationDeployment.CurrentDeployment%2A> właściwości.  
  
 <xref:System.Deployment.Application.ApplicationDeployment.CurrentDeployment%2A> Właściwość statyczna jest prawidłowy tylko z aplikacji, która została wdrożona przy użyciu [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]. Próbuje wywołać tę właściwość z non -[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplikacji spowoduje zgłoszenie wyjątku. Jeśli tworzysz aplikację, która może lub nie mogą być wdrażane za pomocą [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)], użyj <xref:System.Deployment.Application.ApplicationDeployment.IsNetworkDeployed%2A> właściwość, aby sprawdzić, czy jest bieżącym programem [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplikacji.  
  
   
  
## Examples  
 Poniższy kod pobiera przykład <xref:System.Deployment.Application.ApplicationDeployment.CurrentDeployment%2A> i sprawdza, czy aplikacja została zaktualizowana w ciągu ostatnich trzech dni.  
  
 [!code-cpp[ClickOnceAPI#3](~/samples/snippets/cpp/VS_Snippets_Winforms/ClickOnceAPI/cpp/form1.cpp#3)]
 [!code-csharp[ClickOnceAPI#3](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#3)]
 [!code-vb[ClickOnceAPI#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceAPI/VB/Form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Deployment.Application.InvalidDeploymentException">Próba wywołania tej właściwość statyczną z innej niż[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplikacji.</exception>
        <altmember cref="P:System.Deployment.Application.ApplicationDeployment.IsNetworkDeployed" />
      </Docs>
    </Member>
    <Member MemberName="CurrentVersion">
      <MemberSignature Language="C#" Value="public Version CurrentVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Version CurrentVersion" />
      <MemberSignature Language="DocId" Value="P:System.Deployment.Application.ApplicationDeployment.CurrentVersion" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentVersion As Version" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Version ^ CurrentVersion { Version ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentVersion : Version" Usage="System.Deployment.Application.ApplicationDeployment.CurrentVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wersję wdrażania dla bieżącego wystąpienia uruchomionej aplikacji.</summary>
        <value>Bieżąca wersja wdrożenia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Deployment.Application.ApplicationDeployment.CurrentVersion%2A> będzie się różnić od <xref:System.Deployment.Application.ApplicationDeployment.UpdatedVersion%2A> Jeśli nowa aktualizacja została zainstalowana, ale nie zostały jeszcze wywołana <xref:System.Windows.Forms.Application.Restart%2A>. Jeśli manifest wdrożenia jest skonfigurowany do przeprowadzania automatycznych aktualizacji, można porównać te dwie wartości, aby określić, jeśli należy ponownie uruchomić aplikację.  
  
   
  
## Examples  
 Poniższy przykład kodu przedstawia metodę, która określa, czy [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] został zaktualizowany w aplikacji.  
  
 [!code-cpp[ClickOnceAPI#3](~/samples/snippets/cpp/VS_Snippets_Winforms/ClickOnceAPI/cpp/form1.cpp#3)]
 [!code-csharp[ClickOnceAPI#3](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#3)]
 [!code-vb[ClickOnceAPI#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceAPI/VB/Form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.PermissionSet">Aby uzyskać pełny dostęp do komputera lokalnego. Powiązane wyliczenie: <see cref="T:System.Security.Permissions.PermissionState" />.</permission>
        <altmember cref="P:System.Deployment.Application.ApplicationDeployment.UpdatedVersion" />
      </Docs>
    </Member>
    <Member MemberName="DataDirectory">
      <MemberSignature Language="C#" Value="public string DataDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DataDirectory" />
      <MemberSignature Language="DocId" Value="P:System.Deployment.Application.ApplicationDeployment.DataDirectory" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DataDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DataDirectory { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DataDirectory : string" Usage="System.Deployment.Application.ApplicationDeployment.DataDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ścieżkę do [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] katalog danych.</summary>
        <value>Ciąg zawierający ścieżkę do katalogu danych aplikacji na dysku lokalnym.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DownloadFileGroup">
      <MemberSignature Language="C#" Value="public void DownloadFileGroup (string groupName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DownloadFileGroup(string groupName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.ApplicationDeployment.DownloadFileGroup(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DownloadFileGroup (groupName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DownloadFileGroup(System::String ^ groupName);" />
      <MemberSignature Language="F#" Value="member this.DownloadFileGroup : string -&gt; unit" Usage="applicationDeployment.DownloadFileGroup groupName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="groupName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="groupName">Nazwaną grupę plików do pobrania. Wszystkie pliki oznaczone jako "opcjonalny" w [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplikacja wymaga nazwy grupy.</param>
        <summary>Pobiera zbiór opcjonalne plików na żądanie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] pliki oznaczone jako "opcjonalny" w manifeście aplikacji nie zostaną pobrane podczas aktualizacji lub inicjowania aplikacji. Możesz użyć <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroup%2A> metody do pobierania wszystkich plików, należący do nazwanej grupy na żądanie, dzięki czemu nie zużywają zasobów sieci i miejsca na dysku nie ma pewności, ich wymaga. Na przykład w przypadku niektórych użytkowników może być konieczne użycie pakietu analizy danych, dołączony do aplikacji na podstawie codziennych, podczas gdy inni użytkownicy nigdy nie mogą wywoływać go.  
  
 Aby użyć zestawu zostały pobrane z <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroup%2A>, dołączanie odbiornik zdarzeń do <xref:System.AppDomain.AssemblyResolve> zdarzenie na <xref:System.AppDomain.CurrentDomain%2A>. Aby uzyskać przykład, zobacz =[wskazówki: Pobieranie zestawów na żądanie przy użyciu technologii ClickOnce wdrażania interfejsu API przy użyciu narzędzia Projektant](http://msdn.microsoft.com/library/59a0dd5f-1cab-4f2f-b780-0ab7399905d5).  
  
 Wszystkie pliki zostaną pobrane do [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] pamięci podręcznej aplikacji i są izolowane w związku z tym do bieżącej wersji aplikacji. Załóżmy, że po aplikacji do pobrania grupy plików, użytkownik instaluje nową wersję aplikacji, ale później zostanie przywrócona do poprzedniej wersji aplikacji. Poprzednia wersja nadal działa w tym przypadku kopie plików, które pierwotnie pobrany. Aby uzyskać więcej informacji na temat uzyskiwania dostępu do plików danych, zobacz [Accessing Local and Remote Data in ClickOnce Applications](http://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d).  
  
 <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroup%2A> działa w częściowo zaufanych aplikacji, oznacza to, w dowolnym [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplikacji z ograniczeniami uprawnień. Jednak jeśli użytkownik podejmie próbę ładować zestawy dynamiczne, aplikacja wymaga pełnego zaufania.  
  
 Pobieranie plików danych na żądanie nie jest obecnie obsługiwane.  
  
 Twoja aplikacja nie będzie reagują na dane wejściowe użytkownika do momentu <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroup%2A> metoda zwraca. Jeśli musisz pobrać pliki bez przerywania przepływu pracy użytkownika, użyj <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupAsync%2A> metody zamiast tego.  
  
 Pojedynczy plik nie może pobrać za pomocą samej nazwy pliku. Aby pobrać jeden plik, przypisz mu nazwy grupy w Twojej [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] wdrażania i pobierania grupy przy użyciu tej metody.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób ładowania zestawu na żądanie przez nasłuchiwanie <xref:System.AppDomain.AssemblyResolve> zdarzeń.  
  
 [!code-csharp[ClickOnceOnDemandCmdLine#2](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceOnDemandCmdLine/CS/Form1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="groupName" /> Parametr ma wartość null lub jest pusty.</exception>
        <altmember cref="Overload:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupAsync" />
      </Docs>
    </Member>
    <MemberGroup MemberName="DownloadFileGroupAsync">
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera na żądanie, zbiór opcjonalne plików w tle.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DownloadFileGroupAsync">
      <MemberSignature Language="C#" Value="public void DownloadFileGroupAsync (string groupName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DownloadFileGroupAsync(string groupName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupAsync(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DownloadFileGroupAsync (groupName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DownloadFileGroupAsync(System::String ^ groupName);" />
      <MemberSignature Language="F#" Value="member this.DownloadFileGroupAsync : string -&gt; unit" Usage="applicationDeployment.DownloadFileGroupAsync groupName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="groupName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="groupName">Nazwaną grupę plików do pobrania. Wszystkie pliki oznaczone jako "opcjonalny" w [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplikacja wymaga nazwy grupy.</param>
        <summary>Pobiera na żądanie, zbiór opcjonalne plików w tle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] pliki oznaczone jako "opcjonalny" w manifeście aplikacji nie zostaną pobrane podczas aktualizacji lub inicjowania aplikacji. Możesz użyć <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupAsync%2A> metody do pobierania wszystkich plików, należący do nazwanej grupy na żądanie, dzięki czemu nie zużywają zasobów sieci i miejsca na dysku nie ma pewności, ich wymaga. To podejście sprawdza się nie tylko dla plików statycznych, ale dla zestawów, które aplikacja może być lub może nie wymagać. Na przykład w przypadku niektórych użytkowników może być konieczne użycie pakietu analizy danych, dołączony do aplikacji na podstawie codziennych, podczas gdy inni użytkownicy nigdy nie mogą wywoływać go.  
  
 Aby pobrać zestawów na żądanie, Dołącz odbiornik zdarzeń do <xref:System.AppDomain.AssemblyResolve> zdarzenie na <xref:System.AppDomain.CurrentDomain%2A>. Aby uzyskać przykład, zobacz [wskazówki: Pobieranie zestawów na żądanie przy użyciu interfejsu API wdrożenia ClickOnce](http://msdn.microsoft.com/library/d20e2789-8621-4806-b5b7-841122da1456).  
  
 Wszystkie zestawy są pobierane do [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] pamięci podręcznej aplikacji.  
  
 Wszystkie pliki statyczne są pobierane do [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] katalog danych aplikacji i są izolowane w związku z tym do bieżącej wersji aplikacji. Załóżmy, że po aplikacji do pobrania grupy plików, użytkownik instaluje nową wersję aplikacji, ale później zostanie przywrócona do poprzedniej wersji aplikacji. Poprzednia wersja nadal działa w tym przypadku kopie plików, które pierwotnie pobrany. Aby uzyskać więcej informacji na temat uzyskiwania dostępu do plików statycznych, zobacz [Accessing Local and Remote Data in ClickOnce Applications](http://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d).  
  
 Możesz pobrać wiele grup plików, jednocześnie przy użyciu <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupAsync%2A>. Można wyróżnić się między nimi przy użyciu <xref:System.Deployment.Application.DeploymentProgressChangedEventArgs.Group%2A> właściwość <xref:System.Deployment.Application.DeploymentProgressChangedEventArgs> klasy, który jest przekazywany do <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupProgressChanged> zdarzeń. Jeśli musisz przekazać bardziej złożonych stan, możesz użyć <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupAsync%2A> podawać `state` obiektu.  
  
 <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroup%2A> działa w częściowo zaufanych aplikacji, oznacza to, w dowolnym [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplikacji z ograniczeniami uprawnień. Jednak jeśli ma ładować zestawy dynamiczne, aplikacja wymaga pełnego zaufania.  
  
 Pobieranie plików danych na żądanie nie jest obecnie obsługiwane.  
  
 Pojedynczy plik nie może pobrać za pomocą samej nazwy pliku. Aby pobrać jeden plik, przypisz mu nazwy grupy w Twojej [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] wdrażania i pobierania grupy przy użyciu tej metody.  
  
 Aby anulować pobieranie asynchroniczne, należy wywołać <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupAsyncCancel%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="groupName" /> Parametr ma wartość null lub jest pusty.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można zainicjować pobieranie więcej niż jeden <paramref name="groupName" /> w danym momencie.</exception>
        <altmember cref="M:System.Deployment.Application.ApplicationDeployment.DownloadFileGroup(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="DownloadFileGroupAsync">
      <MemberSignature Language="C#" Value="public void DownloadFileGroupAsync (string groupName, object userState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DownloadFileGroupAsync(string groupName, object userState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupAsync(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DownloadFileGroupAsync (groupName As String, userState As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DownloadFileGroupAsync(System::String ^ groupName, System::Object ^ userState);" />
      <MemberSignature Language="F#" Value="member this.DownloadFileGroupAsync : string * obj -&gt; unit" Usage="applicationDeployment.DownloadFileGroupAsync (groupName, userState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="groupName" Type="System.String" />
        <Parameter Name="userState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="groupName">Nazwaną grupę plików do pobrania. Wszystkie pliki oznaczone jako "opcjonalny" w [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplikacja wymaga nazwy grupy.</param>
        <param name="userState">Dowolny obiekt zawierający informacje o stanie dla operacji asynchronicznej.</param>
        <summary>Pobiera na żądanie, zbiór opcjonalne plików w tle i przekazuje element stanu aplikacji do wywołania zwrotne zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] pliki oznaczone jako "opcjonalny" w manifeście aplikacji nie zostaną pobrane podczas aktualizacji lub inicjowania aplikacji. Możesz użyć <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupAsync%2A> metody do pobierania wszystkich plików, należący do nazwanej grupy na żądanie, dzięki czemu nie zużywają zasobów sieci i miejsca na dysku nie ma pewności, ich wymaga. To podejście sprawdza się nie tylko dla plików statycznych, ale dla zestawów, które aplikacja może być lub może nie wymagać. Na przykład w przypadku niektórych użytkowników może być konieczne użycie pakietu analizy danych, dołączony do aplikacji na podstawie codziennych, podczas gdy inni użytkownicy nigdy nie mogą wywoływać go. Aby pobrać zestawów na żądanie, Dołącz odbiornik zdarzeń do <xref:System.AppDomain.AssemblyResolve> zdarzenie na <xref:System.AppDomain.CurrentDomain%2A>.  
  
 Można pobrać grup wielu plików jednocześnie przy użyciu <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupAsync%2A> metody. Można wyróżnić się między nimi przy użyciu <xref:System.Deployment.Application.DeploymentProgressChangedEventArgs.Group%2A> właściwość <xref:System.Deployment.Application.DeploymentProgressChangedEventArgs> klasy, który jest przekazywany do <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupProgressChanged> zdarzeń. Jeśli musisz przekazać bardziej złożonych stan, możesz użyć  
  
 <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupAsync%2A> Aby przekazać `state` obiektu.  
  
 Wszystkie pliki statyczne są pobierane do [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] katalog danych aplikacji i są izolowane w związku z tym do bieżącej wersji aplikacji. Aby uzyskać więcej informacji na temat uzyskiwania dostępu do plików statycznych, zobacz [Accessing Local and Remote Data in ClickOnce Applications](http://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d). . Załóżmy, że po zakończeniu aplikacja pobiera grupę plików, użytkownik instaluje nową wersję aplikacji, ale nowszych użytkownika zostanie przywrócona do poprzedniej wersji aplikacji. Poprzednia wersja nadal działa w tym przypadku kopie plików, które pierwotnie pobrany.  
  
 <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroup%2A> działa w częściowo zaufanych aplikacji, oznacza to, w dowolnym [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplikacji z ograniczeniami uprawnień. Jednak jeśli ma ładować zestawy dynamiczne, aplikacja wymaga pełnego zaufania.  
  
 Pobieranie plików danych na żądanie nie jest obecnie obsługiwane.  
  
 Aby anulować pobieranie asynchroniczne, należy wywołać <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupAsyncCancel%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="groupName" /> Parametr ma wartość null lub jest pusty.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można zainicjować pobieranie więcej niż jeden <paramref name="groupName" /> w danym momencie.</exception>
        <altmember cref="M:System.Deployment.Application.ApplicationDeployment.DownloadFileGroup(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="DownloadFileGroupAsyncCancel">
      <MemberSignature Language="C#" Value="public void DownloadFileGroupAsyncCancel (string groupName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DownloadFileGroupAsyncCancel(string groupName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupAsyncCancel(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DownloadFileGroupAsyncCancel (groupName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DownloadFileGroupAsyncCancel(System::String ^ groupName);" />
      <MemberSignature Language="F#" Value="member this.DownloadFileGroupAsyncCancel : string -&gt; unit" Usage="applicationDeployment.DownloadFileGroupAsyncCancel groupName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="groupName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="groupName">Nazwaną grupę plików do pobrania. Wszystkie pliki oznaczone jako "opcjonalny" w [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplikacja wymaga nazwy grupy.</param>
        <summary>Anuluje do pobrania i asynchroniczne pliku.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="groupName" /> nie może być <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DownloadFileGroupCompleted">
      <MemberSignature Language="C#" Value="public event System.Deployment.Application.DownloadFileGroupCompletedEventHandler DownloadFileGroupCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Deployment.Application.DownloadFileGroupCompletedEventHandler DownloadFileGroupCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DownloadFileGroupCompleted As DownloadFileGroupCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Deployment::Application::DownloadFileGroupCompletedEventHandler ^ DownloadFileGroupCompleted;" />
      <MemberSignature Language="F#" Value="member this.DownloadFileGroupCompleted : System.Deployment.Application.DownloadFileGroupCompletedEventHandler " Usage="member this.DownloadFileGroupCompleted : System.Deployment.Application.DownloadFileGroupCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Deployment.Application.DownloadFileGroupCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje w wątku głównym aplikacji, po zakończeniu pobierania plików.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupCompleted> Zdarzenie jest wywoływane w wątku głównego aplikacji. Jest wątkowo wywołania formantów formularzy Windows aplikacji bezpośrednio z poziomu tego wywołania zwrotnego.  
  
 Sprawdź <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> właściwość <xref:System.ComponentModel.AsyncCompletedEventArgs> dostarczony do tego wywołania zwrotnego. Jeśli ta właściwość jest `null`, pobierania zakończyło się pomyślnie; Jeśli nie jest `null`, instalacja nie powiodła się i można znaleźć więcej informacji na temat niepowodzenia instalacji za pośrednictwem <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera grupy plików pomocy w tle. Przykład wymaga wdrażania aplikacji Windows Forms, która obejmuje <xref:System.Windows.Forms.StatusStrip> kontroli i że zawierają ten formant <xref:System.Windows.Forms.ToolStripStatusLabel> formantu o nazwie `downloadStatus`...  
  
 [!code-cpp[ClickOnceAPI#8](~/samples/snippets/cpp/VS_Snippets_Winforms/ClickOnceAPI/cpp/form1.cpp#8)]
 [!code-csharp[ClickOnceAPI#8](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#8)]
 [!code-vb[ClickOnceAPI#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceAPI/VB/Form1.vb#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DownloadFileGroupProgressChanged">
      <MemberSignature Language="C#" Value="public event System.Deployment.Application.DeploymentProgressChangedEventHandler DownloadFileGroupProgressChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Deployment.Application.DeploymentProgressChangedEventHandler DownloadFileGroupProgressChanged" />
      <MemberSignature Language="DocId" Value="E:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupProgressChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DownloadFileGroupProgressChanged As DeploymentProgressChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Deployment::Application::DeploymentProgressChangedEventHandler ^ DownloadFileGroupProgressChanged;" />
      <MemberSignature Language="F#" Value="member this.DownloadFileGroupProgressChanged : System.Deployment.Application.DeploymentProgressChangedEventHandler " Usage="member this.DownloadFileGroupProgressChanged : System.Deployment.Application.DeploymentProgressChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Deployment.Application.DeploymentProgressChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy informacje o stanie jest dostępny na inicjowany przez wywołanie operacji pobierania plików <see cref="Overload:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupAsync" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupProgressChanged> Zdarzenie jest wywoływane w wątku głównego aplikacji. Jest wątkowo wywołania formantów formularzy Windows aplikacji bezpośrednio z poziomu tego wywołania zwrotnego.  
  
 Użyj informacji podanych w <xref:System.Deployment.Application.DeploymentProgressChangedEventArgs> do komunikowania się informacje o postępie do użytkowników.  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera grupy plików pomocy w tle. Przykład wymaga wdrażania aplikacji Windows Forms, która obejmuje <xref:System.Windows.Forms.StatusStrip> kontroli i że zawierają ten formant <xref:System.Windows.Forms.ToolStripStatusLabel> formantu o nazwie `downloadStatus`.  
  
 [!code-cpp[ClickOnceAPI#8](~/samples/snippets/cpp/VS_Snippets_Winforms/ClickOnceAPI/cpp/form1.cpp#8)]
 [!code-csharp[ClickOnceAPI#8](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#8)]
 [!code-vb[ClickOnceAPI#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceAPI/VB/Form1.vb#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFileGroupDownloaded">
      <MemberSignature Language="C#" Value="public bool IsFileGroupDownloaded (string groupName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsFileGroupDownloaded(string groupName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.ApplicationDeployment.IsFileGroupDownloaded(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsFileGroupDownloaded (groupName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsFileGroupDownloaded(System::String ^ groupName);" />
      <MemberSignature Language="F#" Value="member this.IsFileGroupDownloaded : string -&gt; bool" Usage="applicationDeployment.IsFileGroupDownloaded groupName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="groupName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="groupName">Nazwaną grupę plików do pobrania. Wszystkie pliki oznaczone jako "opcjonalny" w [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplikacja wymaga nazwy grupy.</param>
        <summary>Sprawdza, czy grupa plików o nazwie został już pobrany na komputerze klienckim.</summary>
        <returns>
          <see langword="true" /> Jeśli grupa plików został już załadowany w bieżącej wersji tej aplikacji; w przeciwnym razie <see langword="false" />. Jeśli po zainstalowaniu nowej wersji aplikacji, a nowa wersja ma nie dodane, usunięte lub zmienione pliki w grupie plików <see cref="M:System.Deployment.Application.ApplicationDeployment.IsFileGroupDownloaded(System.String)" /> zwraca <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Deployment.Application.ApplicationDeployment.IsFileGroupDownloaded%2A> działa w aplikacji częściowo zaufanej bez żadnych wymogów bezpieczeństwa.  
  
 Po zaktualizowaniu aplikacji [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] kopiuje wszystkie pliki danych na żądanie z poprzedniej wersji do katalogu danych nowej wersji. Jeśli pobierzesz nowe wersje tych plików, należy usunąć wszystkie dane, które chcesz zachować ze starej wersji i przenieś go do nowej wersji.  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera wszystkie pliki w `HelpFiles` grupy na dysku.  
  
 [!code-cpp[ClickOnceAPI#8](~/samples/snippets/cpp/VS_Snippets_Winforms/ClickOnceAPI/cpp/form1.cpp#8)]
 [!code-csharp[ClickOnceAPI#8](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#8)]
 [!code-vb[ClickOnceAPI#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceAPI/VB/Form1.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Deployment.Application.InvalidDeploymentException">
          <paramref name="groupName" /> grupy plików nie został zdefiniowany w manifeście aplikacji.</exception>
        <altmember cref="M:System.Deployment.Application.ApplicationDeployment.DownloadFileGroup(System.String)" />
        <altmember cref="Overload:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupAsync" />
      </Docs>
    </Member>
    <Member MemberName="IsFirstRun">
      <MemberSignature Language="C#" Value="public bool IsFirstRun { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFirstRun" />
      <MemberSignature Language="DocId" Value="P:System.Deployment.Application.ApplicationDeployment.IsFirstRun" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFirstRun As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFirstRun { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFirstRun : bool" Usage="System.Deployment.Application.ApplicationDeployment.IsFirstRun" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy jest to tej aplikacji zostało uruchomione na komputerze klienckim po raz pierwszy.</summary>
        <value>
          <see langword="true" /> Jeśli ta wersja aplikacji, nigdy nie został uruchomiony na komputerze klienckim przed; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Deployment.Application.ApplicationDeployment.IsFirstRun%2A> do określenia, czy nie trzeba wykonywać żadnych operacji jednorazowe inicjowanie przy pierwszym uruchomieniu aplikacji.  
  
 Nie należy zakładać, że <xref:System.Deployment.Application.ApplicationDeployment.IsFirstRun%2A> ustawienie `true` wskazuje, że to wystąpienie aplikacji jest pierwszy z nich do wyświetlenia interfejsu użytkownika dla użytkownika. Ze względu na sposób system planuje procesów, może mieć jedno wystąpienie aplikacji, jego <xref:System.Deployment.Application.ApplicationDeployment.IsFirstRun%2A> właściwością `true`, ale inne wystąpienie może być pierwszy do renderowania na ekranie. Wartość tej właściwości jest resetowana po użytkownik uaktualnień z jednej wersji do następnego. Jeśli chcesz wykonać operację, tylko pierwsze czasu dowolną wersję uruchamiania aplikacji, musisz wykonać dodatkowe badanie, takich jak sprawdzanie istnienia plik utworzony po raz pierwszy lub przechowywania, przy użyciu flagi **aplikacji Ustawienia**.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Deployment.Application.ApplicationDeployment.IsFirstRun%2A> zdecydować, czy należy sprawdzić dostępność aktualizacji do grupy plików `HelpFiles`. Jeśli co najmniej jeden z plików zostały zaktualizowane, wywołuje metodę <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroup%2A> uzyskanie nowych wersji.  
  
 [!code-csharp[ClickOnceAPI#9](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#9)]
 [!code-vb[ClickOnceAPI#9](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceAPI/VB/Form1.vb#9)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.PermissionSet">Aby uzyskać pełny dostęp do komputera lokalnego. Powiązane wyliczenie: <see cref="T:System.Security.Permissions.PermissionState" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="IsNetworkDeployed">
      <MemberSignature Language="C#" Value="public static bool IsNetworkDeployed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsNetworkDeployed" />
      <MemberSignature Language="DocId" Value="P:System.Deployment.Application.ApplicationDeployment.IsNetworkDeployed" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IsNetworkDeployed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool IsNetworkDeployed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNetworkDeployed : bool" Usage="System.Deployment.Application.ApplicationDeployment.IsNetworkDeployed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżąca aplikacja jest [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplikacji.</summary>
        <value>
          <see langword="true" /> Jeśli jest to [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplikacji; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli chcesz, aby aplikację można uruchomić zarówno wewnątrz jak i poza [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] wdrażania (na przykład, jeśli chcesz debugować aplikację na komputerze lokalnym przed jego wdrożeniem), testowanie <xref:System.Deployment.Application.ApplicationDeployment.IsNetworkDeployed%2A> przed uzyskaniem dostępu do <xref:System.Deployment.Application.ApplicationDeployment.CurrentDeployment%2A> właściwości.  
  
 <xref:System.Deployment.Application.ApplicationDeployment.IsNetworkDeployed%2A> zwróci `true` niezależnie od tego, czy aplikacja jest zainstalowana lub hostowanego w trybie online i niezależnie od tego, czy została zainstalowana z witryny sieci Web, udziału plików lub dysku CD.  
  
   
  
## Examples  
 Poniższy kod pobiera przykład <xref:System.Deployment.Application.ApplicationDeployment.CurrentDeployment%2A> przy użyciu <xref:System.Deployment.Application.ApplicationDeployment.IsNetworkDeployed%2A> aby najpierw upewnij się, że odwołanie nie `null`.  
  
 [!code-cpp[ClickOnceAPI#2](~/samples/snippets/cpp/VS_Snippets_Winforms/ClickOnceAPI/cpp/form1.cpp#2)]
 [!code-csharp[ClickOnceAPI#2](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.PermissionSet">Aby uzyskać pełny dostęp do komputera lokalnego. Powiązane wyliczenie: <see cref="T:System.Security.Permissions.PermissionState" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="TimeOfLastUpdateCheck">
      <MemberSignature Language="C#" Value="public DateTime TimeOfLastUpdateCheck { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime TimeOfLastUpdateCheck" />
      <MemberSignature Language="DocId" Value="P:System.Deployment.Application.ApplicationDeployment.TimeOfLastUpdateCheck" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TimeOfLastUpdateCheck As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime TimeOfLastUpdateCheck { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.TimeOfLastUpdateCheck : DateTime" Usage="System.Deployment.Application.ApplicationDeployment.TimeOfLastUpdateCheck" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera datę i godzinę [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] ostatnie sprawdzenie dostępności aktualizacji aplikacji.</summary>
        <value>
          <see cref="T:System.DateTime" /> Ostatniego sprawdzenia aktualizacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplikacji można skonfigurować dla aktualizacji subskrypcji. W tym scenariuszu [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] sonduje lokalizacji wdrożenia aplikacji automatycznie odstępach czasu zdefiniowanych w pliku manifestu wdrożenia i określa, czy dostępna jest aktualizacja. <xref:System.Deployment.Application.ApplicationDeployment.TimeOfLastUpdateCheck%2A> Zwraca godzinę ostatniego sprawdzenia aktualizacji niezależnie od tego, czy zostało zainicjowane przez subskrypcję lub przez jawne wyboru przy użyciu <xref:System.Deployment.Application.ApplicationDeployment.CheckForUpdate%2A>, <xref:System.Deployment.Application.ApplicationDeployment.CheckForUpdateAsync%2A>, <xref:System.Deployment.Application.ApplicationDeployment.CheckForDetailedUpdate%2A>, <xref:System.Deployment.Application.ApplicationDeployment.Update%2A>, lub <xref:System.Deployment.Application.ApplicationDeployment.UpdateAsync%2A> metody.  
  
 Jeśli sprawdzanie aktualizacji nie została wykonana, ponieważ aplikacja została zainstalowana, <xref:System.Deployment.Application.ApplicationDeployment.TimeOfLastUpdateCheck%2A> zwraca czas instalacji.  
  
   
  
## Examples  
 Poniższy kod przykład sprawdza, czy [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplikacji została sprawdzona dostępne aktualizacje w ciągu ostatnich trzech dni.  
  
 [!code-cpp[ClickOnceAPI#3](~/samples/snippets/cpp/VS_Snippets_Winforms/ClickOnceAPI/cpp/form1.cpp#3)]
 [!code-csharp[ClickOnceAPI#3](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#3)]
 [!code-vb[ClickOnceAPI#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceAPI/VB/Form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.PermissionSet">Aby uzyskać pełny dostęp do komputera lokalnego. Powiązane wyliczenie: <see cref="T:System.Security.Permissions.PermissionState" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Update">
      <MemberSignature Language="C#" Value="public bool Update ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Update() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.ApplicationDeployment.Update" />
      <MemberSignature Language="VB.NET" Value="Public Function Update () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Update();" />
      <MemberSignature Language="F#" Value="member this.Update : unit -&gt; bool" Usage="applicationDeployment.Update " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Uruchamia synchroniczne pobranie i zainstalowanie najnowszej wersji tej aplikacji.</summary>
        <returns>
          <see langword="true" /> Jeśli aplikacja została zaktualizowana; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplikacja jest uznawana za zaktualizowane po opublikowaniu nowej wersji aplikacji do lokalizacji określonej przez <xref:System.Deployment.Application.ApplicationDeployment.UpdateLocation%2A>, a obecnie numer wersji w manifeście wdrożenia aplikacji jest większy niż numer wersji aplikacji zainstalowana na komputerze użytkownika.  
  
 <xref:System.Deployment.Application.ApplicationDeployment.Update%2A> Blokuje wywołania do momentu aktualizacji została pobrana na komputer kliencki i zainstalowane w [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] pamięci podręcznej; w tym czasie aplikacja nie będzie reagować na działania użytkownika. Jeśli chcesz zachować czas odpowiedzi aplikacji lub wyświetlić raport o postępie podczas pobierania, użyj <xref:System.Deployment.Application.ApplicationDeployment.UpdateAsync%2A> metody zamiast tego.  
  
 <xref:System.Deployment.Application.ApplicationDeployment.Update%2A> pobiera wszystkie pliki, które nie są oznaczane jako "opcjonalny" w manifeście aplikacji. Możesz pobrać pliki opcjonalne na żądanie przy użyciu <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroup%2A> lub <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupAsync%2A> metody.  
  
 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] może już być aplikacja automatycznie aktualizowane po wywołaniu <xref:System.Deployment.Application.ApplicationDeployment.Update%2A> metody; Jeśli tak się stanie, wywołania tej metody spowoduje zgłoszenie <xref:System.InvalidOperationException>.  
  
 Jeśli jeden lub więcej plików zostały zaktualizowane w danym wdrożeniu, ale nie zostały odświeżone manifest aplikacji, zostanie wyświetlony <xref:System.Deployment.Application.InvalidDeploymentException>. Większość czasu ponownego wdrożenia Twojego [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplikacja rozwiązuje ten problem. Wyjątek ten zostanie wysłana, jeśli podpis klucza publicznego w manifeście wdrożenia lub manifest aplikacji jest nieprawidłowy lub nie istnieje.  
  
 Aktualizacja może prosić o wyższym poziomie zaufania, na komputerze lokalnym niż poprzednia wersja aplikacji. Jeśli aplikacja używa wdrażanie zaufanych aplikacji, typowe Menedżer zaufania środowiska uruchomieniowego (języka wspólnego CLR) języka sprawdza, czy manifest wdrożenia, aby ustalić, czy zawiera on licencja zaufania prawidłowe. Jeśli manifest wdrożenia nie zawiera licencję zaufania prawidłowe [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] spowoduje zatrzymanie instalacji i zgłasza <xref:System.Deployment.Application.TrustNotGrantedException>. <xref:System.Deployment.Application.ApplicationDeployment.Update%2A> Metoda nigdy nie wyświetli monit z zapytaniem użytkownika, czy chce udzielić aplikacji uprawnień do uruchomienia.  
  
   
  
## Examples  
 Poniższy przykład kodu sprawdza o aktualizację aplikacji; Jeśli aktualizacja jest dostępna, instaluje go synchronicznie.  
  
 [!code-cpp[ClickOnceAPI#6](~/samples/snippets/cpp/VS_Snippets_Winforms/ClickOnceAPI/cpp/form1.cpp#6)]
 [!code-csharp[ClickOnceAPI#6](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#6)]
 [!code-vb[ClickOnceAPI#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceAPI/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Deployment.Application.TrustNotGrantedException">Komputer lokalny nie udostępni aplikację poziomu uprawnień, który go wymagane do wykonania.</exception>
        <exception cref="T:System.Deployment.Application.InvalidDeploymentException">Twoje [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] wdrożenia jest uszkodzony. Aby uzyskać porady na temat zdiagnozować i rozwiązać ten problem, zobacz [Rozwiązywanie problemów z wdrożeniami ClickOnce](http://msdn.microsoft.com/library/58e90012-f68b-4852-8ae9-58e361cbcc32).</exception>
        <exception cref="T:System.Deployment.Application.DeploymentDownloadException">Nie można pobrać nowe wdrożenie z lokalizacji w sieci.</exception>
        <exception cref="T:System.InvalidOperationException">Aplikacja jest obecnie aktualizowana.</exception>
        <permission cref="T:System.Security.PermissionSet">Aby uzyskać pełny dostęp do komputera lokalnego. Powiązane wyliczenie: <see cref="T:System.Security.Permissions.PermissionState" />.</permission>
        <altmember cref="M:System.Deployment.Application.ApplicationDeployment.UpdateAsync" />
        <altmember cref="M:System.Deployment.Application.ApplicationDeployment.CheckForUpdateAsync" />
        <altmember cref="M:System.Deployment.Application.ApplicationDeployment.CheckForUpdate" />
        <altmember cref="M:System.Deployment.Application.ApplicationDeployment.CheckForDetailedUpdate" />
      </Docs>
    </Member>
    <Member MemberName="UpdateAsync">
      <MemberSignature Language="C#" Value="public void UpdateAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UpdateAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.ApplicationDeployment.UpdateAsync" />
      <MemberSignature Language="VB.NET" Value="Public Sub UpdateAsync ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UpdateAsync();" />
      <MemberSignature Language="F#" Value="member this.UpdateAsync : unit -&gt; unit" Usage="applicationDeployment.UpdateAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Uruchamia asynchroniczne pobranie i zainstalowanie najnowszej wersji tej aplikacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplikacja jest uznawana za zaktualizowane po opublikowaniu nowej wersji aplikacji do lokalizacji określonej przez <xref:System.Deployment.Application.ApplicationDeployment.UpdateLocation%2A>, a obecnie numer wersji w manifeście wdrożenia aplikacji jest większy niż numer wersji aplikacji zainstalowana na komputerze użytkownika.  
  
 Podczas pobierania aktualizacji [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] zgłosi <xref:System.Deployment.Application.ApplicationDeployment.UpdateProgressChanged> program obsługi zdarzeń w wątku głównym aplikacji, informujące o stanie pliki do pobrania. Gdy asynchronicznego aktualizacji zakończy się lub napotka wyjątek, [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] zgłosi <xref:System.Deployment.Application.ApplicationDeployment.UpdateCompleted> zdarzenie na wątku głównego aplikacji. Sprawdź <xref:System.ComponentModel.AsyncCompletedEventArgs> dostarczony do tego zdarzenia w celu ustalenia, czy aktualizacja powiodła się.  
  
 Jeśli <xref:System.Deployment.Application.ApplicationDeployment.UpdateAsync%2A> zgłasza wyjątek, [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] wywołania <xref:System.Deployment.Application.ApplicationDeployment.UpdateCompleted> i ustawia <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> właściwość <xref:System.ComponentModel.AsyncCompletedEventArgs> wyjątek, który został zgłoszony.  
  
 <xref:System.Deployment.Application.ApplicationDeployment.UpdateAsync%2A> pobierze wszystkie pliki we wdrożeniu nie jest oznaczony jako "opcjonalny" w manifeście aplikacji. Możesz pobrać pliki opcjonalne na żądanie przy użyciu <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroup%2A> lub <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupAsync%2A> metody.  
  
 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] może już być aplikacja automatycznie aktualizowane po wywołaniu <xref:System.Deployment.Application.ApplicationDeployment.UpdateAsync%2A> metody; Jeśli tak się stanie, wywołania tej metody spowoduje zgłoszenie <xref:System.InvalidOperationException>.  
  
 Jeśli jeden lub więcej plików zostały zaktualizowane w danym wdrożeniu, ale nie zostały odświeżone manifest aplikacji, zostanie wyświetlony <xref:System.Deployment.Application.InvalidDeploymentException>. W większości przypadków, ponownie skompilować manifest aplikacji rozwiązuje ten problem. Wyjątek ten zostanie wysłana, jeśli podpis klucza publicznego w manifeście wdrożenia lub manifest aplikacji jest nieprawidłowy lub nie istnieje.  
  
 Aktualizacja może prosić o wyższym poziomie zaufania, na komputerze lokalnym niż poprzednia wersja aplikacji. Jeśli aplikacja używa wdrażanie zaufanych aplikacji, typowe Menedżer zaufania środowiska uruchomieniowego (języka wspólnego CLR) języka sprawdza, czy manifest wdrożenia, aby ustalić, czy zawiera on licencja zaufania prawidłowe. Jeśli manifest wdrożenia nie zawiera licencję zaufania prawidłowe [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] spowoduje zatrzymanie instalacji i zgłasza <xref:System.Deployment.Application.TrustNotGrantedException>. <xref:System.Deployment.Application.ApplicationDeployment.UpdateAsync%2A> nigdy nie wyświetli monit z zapytaniem użytkownika, czy chce udzielić aplikacji uprawnień do uruchomienia.  
  
   
  
## Examples  
 Poniższy przykład kodu Określa, czy dostępna jest nowa aktualizacja w czasie ładowania aplikacji; Jeśli wymagana aktualizacja jest dostępna, instaluje aktualizację asynchronicznie. Przykład wymaga wdrażania aplikacji Windows Forms, która obejmuje <xref:System.Windows.Forms.StatusStrip> kontroli i że zawierają ten formant <xref:System.Windows.Forms.ToolStripStatusLabel> formantu o nazwie `downloadStatus`.  
  
 [!code-cpp[ClickOnceAPI#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ClickOnceAPI/cpp/form1.cpp#1)]
 [!code-csharp[ClickOnceAPI#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#1)]
 [!code-vb[ClickOnceAPI#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceAPI/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Deployment.Application.TrustNotGrantedException">Komputer lokalny nie udostępni tę aplikację poziomu uprawnień, który go wymagane do wykonania.</exception>
        <exception cref="T:System.Deployment.Application.InvalidDeploymentException">Twoje [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] wdrożenia jest uszkodzony. Aby uzyskać porady na temat zdiagnozować i rozwiązać ten problem, zobacz [Rozwiązywanie problemów z wdrożeniami ClickOnce](http://msdn.microsoft.com/library/58e90012-f68b-4852-8ae9-58e361cbcc32).</exception>
        <exception cref="T:System.Deployment.Application.DeploymentDownloadException">Nie można pobrać nowe wdrożenie z lokalizacji w sieci.</exception>
        <permission cref="T:System.Security.PermissionSet">Aby uzyskać pełny dostęp do komputera lokalnego. Powiązane wyliczenie: <see cref="T:System.Security.Permissions.PermissionState" />.</permission>
        <altmember cref="E:System.Deployment.Application.ApplicationDeployment.UpdateCompleted" />
      </Docs>
    </Member>
    <Member MemberName="UpdateAsyncCancel">
      <MemberSignature Language="C#" Value="public void UpdateAsyncCancel ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UpdateAsyncCancel() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.ApplicationDeployment.UpdateAsyncCancel" />
      <MemberSignature Language="VB.NET" Value="Public Sub UpdateAsyncCancel ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UpdateAsyncCancel();" />
      <MemberSignature Language="F#" Value="member this.UpdateAsyncCancel : unit -&gt; unit" Usage="applicationDeployment.UpdateAsyncCancel " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Anulowanie asynchroniczne aktualizacji inicjowane przez <see cref="M:System.Deployment.Application.ApplicationDeployment.UpdateAsync" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Deployment.Application.ApplicationDeployment.UpdateAsyncCancel%2A> tylko anuluje aktualizacji inicjowane przez wywołanie <xref:System.Deployment.Application.ApplicationDeployment.UpdateAsync%2A>; Anuluj aktualizację uruchomiona w ramach subskrypcji.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.PermissionSet">Aby uzyskać pełny dostęp do komputera lokalnego. Powiązane wyliczenie: <see cref="T:System.Security.Permissions.PermissionState" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="UpdateCompleted">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.AsyncCompletedEventHandler UpdateCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.AsyncCompletedEventHandler UpdateCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Deployment.Application.ApplicationDeployment.UpdateCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event UpdateCompleted As AsyncCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::AsyncCompletedEventHandler ^ UpdateCompleted;" />
      <MemberSignature Language="F#" Value="member this.UpdateCompleted : System.ComponentModel.AsyncCompletedEventHandler " Usage="member this.UpdateCompleted : System.ComponentModel.AsyncCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.AsyncCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] zakończył uaktualnianie aplikacji w wyniku wywołania <see cref="M:System.Deployment.Application.ApplicationDeployment.UpdateAsync" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Deployment.Application.ApplicationDeployment.UpdateCompleted> Zdarzenie jest wywoływane w wątku głównego aplikacji. Formanty Windows Forms aplikacji bezpośrednio z poziomu tego wywołania zwrotnego może wywołać bez powodowania wyjątek.  
  
 Sprawdź <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> właściwość <xref:System.ComponentModel.AsyncCompletedEventArgs> dostarczony do tego wywołania zwrotnego. Jeśli ta właściwość jest `null`, instalacja zakończyła się pomyślnie; Jeśli nie jest `null`, instalacja nie powiodła się i można znaleźć więcej informacji na temat tego błędu instalacji za pośrednictwem <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> właściwości. Po pobraniu aktualizacji musisz wywołać <xref:System.Windows.Forms.Application.Restart%2A> metody <xref:System.Windows.Forms.Application> do korzystania z nowszej wersji aplikacji.  
  
 Jeśli instalacja aktualizacji została anulowana przez wywołanie <xref:System.Deployment.Application.ApplicationDeployment.UpdateAsyncCancel%2A>, <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> właściwość <xref:System.ComponentModel.AsyncCompletedEventArgs> klasa będzie `true`.  
  
 Aby korzystać z tej obsługi zdarzeń, aplikacji należy zaimportować zarówno <xref:System.Deployment.Application> i <xref:System.ComponentModel> przestrzeni nazw.  
  
   
  
## Examples  
 Poniższy przykład kodu określa się w czasie ładowania aplikacji, czy nowa aktualizacja jest dostępna; Jeśli wymagana aktualizacja jest dostępna, instaluje aktualizację asynchronicznie. Przykład wymaga wdrażania aplikacji Windows Forms, która obejmuje <xref:System.Windows.Forms.StatusStrip> kontroli i że zawierają ten formant <xref:System.Windows.Forms.ToolStripStatusLabel> formantu o nazwie `downloadStatus`.  
  
 [!code-cpp[ClickOnceAPI#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ClickOnceAPI/cpp/form1.cpp#1)]
 [!code-csharp[ClickOnceAPI#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#1)]
 [!code-vb[ClickOnceAPI#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceAPI/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdatedApplicationFullName">
      <MemberSignature Language="C#" Value="public string UpdatedApplicationFullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UpdatedApplicationFullName" />
      <MemberSignature Language="DocId" Value="P:System.Deployment.Application.ApplicationDeployment.UpdatedApplicationFullName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UpdatedApplicationFullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UpdatedApplicationFullName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UpdatedApplicationFullName : string" Usage="System.Deployment.Application.ApplicationDeployment.UpdatedApplicationFullName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera pełną nazwę aplikacji, po jego aktualizacji.</summary>
        <value>A <see cref="T:System.String" /> zawierającą pełną nazwę aplikacji.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdatedVersion">
      <MemberSignature Language="C#" Value="public Version UpdatedVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Version UpdatedVersion" />
      <MemberSignature Language="DocId" Value="P:System.Deployment.Application.ApplicationDeployment.UpdatedVersion" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UpdatedVersion As Version" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Version ^ UpdatedVersion { Version ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UpdatedVersion : Version" Usage="System.Deployment.Application.ApplicationDeployment.UpdatedVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wersję aktualizacji, która została ostatnio pobrana.</summary>
        <value>
          <see cref="T:System.Version" /> Opisujące wersji aktualizacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Deployment.Application.ApplicationDeployment.UpdatedVersion%2A> różni się od <xref:System.Deployment.Application.ApplicationDeployment.CurrentVersion%2A> Jeśli nowa aktualizacja została zainstalowana, ale nie zostały jeszcze wywołana <xref:System.Windows.Forms.Application.Restart%2A> na <xref:System.Windows.Forms.Application>. Jeśli manifest wdrożenia aplikacji jest skonfigurowany do przeprowadzania automatycznych aktualizacji, można porównać te dwie wartości, aby ustalić, czy należy ponownie uruchomić aplikację.  
  
 Jeśli aplikacja nie została zaktualizowana, <xref:System.Deployment.Application.ApplicationDeployment.UpdatedVersion%2A> zwraca taką samą wartość jak <xref:System.Deployment.Application.ApplicationDeployment.CurrentVersion%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu przedstawia metodę, która określa, czy [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] został zaktualizowany w aplikacji.  
  
 [!code-cpp[ClickOnceAPI#4](~/samples/snippets/cpp/VS_Snippets_Winforms/ClickOnceAPI/cpp/form1.cpp#4)]
 [!code-csharp[ClickOnceAPI#4](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#4)]
 [!code-vb[ClickOnceAPI#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceAPI/VB/Form1.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.PermissionSet">Aby uzyskać pełny dostęp do komputera lokalnego. Wyliczenie skojarzone: <see cref="T:System.Security.Permissions.PermissionState" /></permission>
      </Docs>
    </Member>
    <Member MemberName="UpdateLocation">
      <MemberSignature Language="C#" Value="public Uri UpdateLocation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri UpdateLocation" />
      <MemberSignature Language="DocId" Value="P:System.Deployment.Application.ApplicationDeployment.UpdateLocation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UpdateLocation As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ UpdateLocation { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UpdateLocation : Uri" Usage="System.Deployment.Application.ApplicationDeployment.UpdateLocation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera witryny sieci Web lub udziału plików, w którym ta aplikacja aktualizuje się sama.</summary>
        <value>Ścieżka aktualizacji wyrażonej w postaci HTTP, HTTPS lub adres URL pliku; lub jako Windows sieci ścieżka pliku (UNC).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Deployment.Application.ApplicationDeployment.UpdateLocation%2A> może się różnić od witryny sieci Web, używane do pobierania aplikacji początkowo, jeśli wdrożenie aplikacji jest skonfigurowana do używania aktualizacji przekierowania.  
  
 Tę wartość można zmienić tylko w manifeście wdrożenia aplikacji.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.PermissionSet">Aby uzyskać pełny dostęp do komputera lokalnego. Powiązane wyliczenie: <see cref="T:System.Security.Permissions.PermissionState" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="UpdateProgressChanged">
      <MemberSignature Language="C#" Value="public event System.Deployment.Application.DeploymentProgressChangedEventHandler UpdateProgressChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Deployment.Application.DeploymentProgressChangedEventHandler UpdateProgressChanged" />
      <MemberSignature Language="DocId" Value="E:System.Deployment.Application.ApplicationDeployment.UpdateProgressChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event UpdateProgressChanged As DeploymentProgressChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Deployment::Application::DeploymentProgressChangedEventHandler ^ UpdateProgressChanged;" />
      <MemberSignature Language="F#" Value="member this.UpdateProgressChanged : System.Deployment.Application.DeploymentProgressChangedEventHandler " Usage="member this.UpdateProgressChanged : System.Deployment.Application.DeploymentProgressChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Deployment.Application.DeploymentProgressChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] zawiera nowe informacje o stanie dla operacji aktualizacji inicjowane przez wywołanie metody <see cref="M:System.Deployment.Application.ApplicationDeployment.UpdateAsync" /> metody.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Deployment.Application.ApplicationDeployment.UpdateProgressChanged> Zdarzenie jest wywoływane w wątku głównego aplikacji. Formanty Windows Forms aplikacji bezpośrednio z poziomu tego wywołania zwrotnego może wywołać bez powodowania wyjątek.  
  
   
  
## Examples  
 Poniższy przykład kodu określa się w czasie ładowania aplikacji, czy nowa aktualizacja jest dostępna; Jeśli wymagana aktualizacja jest dostępna, instaluje aktualizację asynchronicznie.  
  
 [!code-cpp[ClickOnceAPI#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ClickOnceAPI/cpp/form1.cpp#1)]
 [!code-csharp[ClickOnceAPI#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#1)]
 [!code-vb[ClickOnceAPI#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceAPI/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
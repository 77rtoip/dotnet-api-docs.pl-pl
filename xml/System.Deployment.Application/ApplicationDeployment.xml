<Type Name="ApplicationDeployment" FullName="System.Deployment.Application.ApplicationDeployment">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="cc0a2f81304b418f78fdfbda4bc0eb4102f24a62" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30449601" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class ApplicationDeployment" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ApplicationDeployment extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Deployment.Application.ApplicationDeployment" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ApplicationDeployment" />
  <TypeSignature Language="C++ CLI" Value="public ref class ApplicationDeployment sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Deployment</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Programowo obsługuje aktualizacje bieżącego wdrożenia i obsługi na żądanie pobierania plików. Klasa ta nie może być dziedziczona.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można skonfigurować sieci [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplikacji Sprawdź aktualizacje je i zainstalować automatycznie za pomocą `subscription` element manifestu rozmieszczenia. Niektóre aplikacje muszą mieć jednak bardziej precyzyjną kontrolę nad ich aktualizacji. Możesz instalować wymagane aktualizacje programowo i monitować użytkowników o zainstalowanie aktualizacji opcjonalne ich wygody. Wyłączenie subskrypcji aktualizacji w manifeście rozmieszczenia, można uzyskać pełną kontrolę nad zasady aktualizacji aplikacji. Alternatywnie można użyć automatycznego subskrypcji w połączeniu z <xref:System.Deployment.Application.ApplicationDeployment>, które umożliwia [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] zaktualizować aplikacji, okresowo, ale <xref:System.Deployment.Application.ApplicationDeployment> Aby pobrać aktualizacje krytyczne, wkrótce po ich udostępnieniu.  
  
 Można sprawdzić, czy wdrożenie ma dostępnych aktualizacji za pomocą <xref:System.Deployment.Application.ApplicationDeployment.CheckForUpdate%2A> lub <xref:System.Deployment.Application.ApplicationDeployment.CheckForUpdateAsync%2A> metody; druga metoda zgłasza <xref:System.Deployment.Application.ApplicationDeployment.CheckForUpdateCompleted> zdarzeń na pomyślne zakończenie. <xref:System.Deployment.Application.ApplicationDeployment.CheckForDetailedUpdate%2A> Zwraca ważne informacje o aktualizacji, takich jak numer wersji i czy jest wymagana aktualizacja bieżących użytkowników. Jeśli aktualizacja jest dostępna, można zainstalować go za pomocą <xref:System.Deployment.Application.ApplicationDeployment.Update%2A> lub <xref:System.Deployment.Application.ApplicationDeployment.UpdateAsync%2A>; druga metoda zgłasza <xref:System.Deployment.Application.ApplicationDeployment.UpdateCompleted> zdarzeń po zakończeniu instalacji aktualizacji. Dla dużych aktualizacji, możesz otrzymywać powiadomienia postępu za pośrednictwem <xref:System.Deployment.Application.ApplicationDeployment.CheckForUpdateProgressChanged> i <xref:System.Deployment.Application.ApplicationDeployment.UpdateProgressChanged> zdarzenia i użyć tych informacji w <xref:System.ComponentModel.ProgressChangedEventArgs> do powiadamia użytkownika o stan pobierania.  
  
 Można również użyć <xref:System.Deployment.Application.ApplicationDeployment> pobierania dużych plików i zestawów na żądanie. Te pliki muszą być oznaczone jako "opcjonalna" w manifeście aplikacji wdrożenia, tak, aby nie zostaną pobrane podczas instalacji. Możesz pobrać pliki w dowolnym momencie w okresie aplikacji za pomocą <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroup%2A> lub <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupAsync%2A> metody. Możesz pobrać zestawy przed załadowaniem do pamięci podając programu obsługi zdarzeń dla <xref:System.AppDomain.AssemblyResolve> zdarzenia w <xref:System.AppDomain> klasy. Aby uzyskać więcej informacji, zobacz [wskazówki: Pobieranie zestawów na żądanie z ClickOnce wdrażania interfejsu API przy użyciu narzędzia Projektant](http://msdn.microsoft.com/library/59a0dd5f-1cab-4f2f-b780-0ab7399905d5).  
  
> [!NOTE]
>  Po zaktualizowaniu [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplikacji, gdy aplikacja jest uruchomiona, użytkownik aktualizacje nie będą wyświetlane do czasu wywołania <xref:System.Windows.Forms.Application.Restart%2A> metody <xref:System.Windows.Forms.Application>, co będzie Zamknij bieżące wystąpienie uruchomionych aplikacji i natychmiast ponownie uruchomić go.  
  
 <xref:System.Deployment.Application.ApplicationDeployment> nie ma publicznego konstruktora; Uzyskaj wystąpień klasy w [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplikacji za pośrednictwem <xref:System.Deployment.Application.ApplicationDeployment.CurrentDeployment%2A> właściwości. Możesz użyć <xref:System.Deployment.Application.ApplicationDeployment.IsNetworkDeployed%2A> właściwość, aby sprawdzić, czy bieżąca aplikacja jest [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplikacji.  
  
 <xref:System.Deployment.Application.ApplicationDeployment> obsługuje sprawdzanie dostępności aktualizacji i pobrać zaktualizowane pliki asynchronicznie przy użyciu nowej [oparty na zdarzeniach asynchroniczny wzorzec — Przegląd](~/docs/standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-overview.md), który udostępnia wywołania zwrotne zakończenia jako klasa zdarzenia. <xref:System.Deployment.Application.ApplicationDeployment> Uruchamia zarządza wątki i wywołuje aplikację w wątku interfejsu użytkownika, poprawne. Za pomocą tej klasy można aktualizować bez blokowania aplikacji, dzięki czemu użytkownik może kontynuować pracę w trakcie instalacji aktualizacji. Jeśli użytkownik należy zatrzymać wszystkie wykonywane podczas aktualizacji ma miejsce, rozważ użycie zamiast tego metod synchronicznych.  
  
> [!NOTE]
>  Wykonuje asynchroniczny aktualizacji wymaga aplikacji importowanie zarówno <xref:System.Deployment.Application> i <xref:System.ComponentModel> przestrzeni nazw.  
  
   
  
## Examples  
 Poniższy przykład kodu określa w czasie ładowania aplikacji, czy nowa aktualizacja jest dostępna; Jeśli wymagana aktualizacja jest dostępna, przykładowy kod instaluje aktualizację asynchronicznie. Ten kod powinien zostać dodany do formularza, który zawiera <xref:System.Windows.Forms.TextBox> o nazwie `downloadStatus`.  
  
 [!code-cpp[ClickOnceAPI#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ClickOnceAPI/cpp/form1.cpp#1)]
 [!code-csharp[ClickOnceAPI#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#1)]
 [!code-vb[ClickOnceAPI#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceAPI/VB/Form1.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="ActivationUri">
      <MemberSignature Language="C#" Value="public Uri ActivationUri { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri ActivationUri" />
      <MemberSignature Language="DocId" Value="P:System.Deployment.Application.ApplicationDeployment.ActivationUri" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ActivationUri As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ ActivationUri { Uri ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera adres URL używany do uruchomienia manifest wdrażania aplikacji.</summary>
        <value>Ciąg o zerowej długości, jeśli <c>parametry TrustUrlParameters</c> właściwość w manifeście rozmieszczenia jest <see langword="false" />, lub jeśli użytkownik udostępnił UNC, aby otworzyć wdrożenia lub otworzył ją lokalnie. W przeciwnym razie wartość zwracana jest pełny adres URL używany do uruchomienia aplikacji, w tym żadnych parametrów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość będzie działać w aplikacjach zarówno w pełni zaufany, jak i częściowo zaufany.  
  
   
  
## Examples  
 Poniższy kod przedstawia sposób pobrać parametrów adresu URL za pomocą <xref:System.Deployment.Application.ApplicationDeployment.ActivationUri%2A>i sposobu użycia <xref:System.Web.HttpUtility> klasy można bezpiecznie przeanalizować ciągu zapytania. Wiele wystąpień tej samej zmiennej ciągu zapytania są skonsolidowane w jeden wpis zwróconego elementu <xref:System.Collections.Specialized.NameValueCollection>.  
  
 [!code-csharp[ClickOnceQueryString#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceQueryString/CS/Form1.cs#1)]
 [!code-vb[ClickOnceQueryString#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceQueryString/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CheckForDetailedUpdate">
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wykonuje tę samą operację jako <see cref="M:System.Deployment.Application.ApplicationDeployment.CheckForUpdate" />, ale zwraca rozszerzone informacje o dostępnych aktualizacjach.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CheckForDetailedUpdate">
      <MemberSignature Language="C#" Value="public System.Deployment.Application.UpdateCheckInfo CheckForDetailedUpdate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Deployment.Application.UpdateCheckInfo CheckForDetailedUpdate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.ApplicationDeployment.CheckForDetailedUpdate" />
      <MemberSignature Language="VB.NET" Value="Public Function CheckForDetailedUpdate () As UpdateCheckInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Deployment::Application::UpdateCheckInfo ^ CheckForDetailedUpdate();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Deployment.Application.UpdateCheckInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wykonuje tę samą operację jako <see cref="M:System.Deployment.Application.ApplicationDeployment.CheckForUpdate" />, ale zwraca rozszerzone informacje o dostępnych aktualizacjach.</summary>
        <returns>
          <see cref="T:System.Deployment.Application.UpdateCheckInfo" /> Dostępnych aktualizacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Deployment.Application.ApplicationDeployment.CheckForDetailedUpdate%2A> — Metoda umożliwia synchroniczne wywołań uzyskać takie same rozszerzone informacje o wywołującym asynchroniczne pobieranie przy użyciu <xref:System.Deployment.Application.CheckForUpdateCompletedEventArgs> klasy.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Deployment.Application.ApplicationDeployment.CheckForDetailedUpdate%2A> można pobrać informacji o najnowszych aktualizacji. Jeśli istnieje aktualizacji, instaluje ją automatycznie tylko wtedy, gdy jest to aktualizacja wymagana; w przeciwnym razie użytkownik jest monitowany.  
  
 [!code-cpp[ClickOnceAPI#7](~/samples/snippets/cpp/VS_Snippets_Winforms/ClickOnceAPI/cpp/form1.cpp#7)]
 [!code-csharp[ClickOnceAPI#7](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#7)]
 [!code-vb[ClickOnceAPI#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceAPI/VB/Form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Bieżąca aplikacja nie jest skonfigurowany do obsługi aktualizacji lub istnieje inna operacja sprawdzania aktualizacji w toku.</exception>
        <exception cref="T:System.Deployment.Application.DeploymentDownloadException">Nie można pobrać manifestu wdrożenia. Ten wyjątek zostanie wyświetlony w <see cref="P:System.ComponentModel.AsyncCompletedEventArgs.Error" /> właściwość <see cref="E:System.Deployment.Application.ApplicationDeployment.CheckForUpdateCompleted" /> zdarzeń.</exception>
        <exception cref="T:System.Deployment.Application.InvalidDeploymentException">Manifest rozmieszczenia jest uszkodzony. Przed przystąpieniem do wdrożenia tej aplikacji użytkownikom, należy ponownie wygenerować manifest aplikacji. Ten wyjątek zostanie wyświetlony w <see cref="P:System.ComponentModel.AsyncCompletedEventArgs.Error" /> właściwość <see cref="E:System.Deployment.Application.ApplicationDeployment.CheckForUpdateCompleted" /> zdarzeń.</exception>
        <permission cref="T:System.Security.PermissionSet">Aby uzyskać dostęp do komputera lokalnego. Wyliczenie skojarzone: <see cref="T:System.Security.Permissions.PermissionState" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CheckForDetailedUpdate">
      <MemberSignature Language="C#" Value="public System.Deployment.Application.UpdateCheckInfo CheckForDetailedUpdate (bool persistUpdateCheckResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Deployment.Application.UpdateCheckInfo CheckForDetailedUpdate(bool persistUpdateCheckResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.ApplicationDeployment.CheckForDetailedUpdate(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function CheckForDetailedUpdate (persistUpdateCheckResult As Boolean) As UpdateCheckInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Deployment::Application::UpdateCheckInfo ^ CheckForDetailedUpdate(bool persistUpdateCheckResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Deployment.Application.UpdateCheckInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="persistUpdateCheckResult" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="persistUpdateCheckResult">Jeśli <see langword="false" />aktualizacji zostaną zastosowane w trybie dyskretnym i nie wyświetlane okno dialogowe będzie można.</param>
        <summary>Wykonuje tę samą operację jako <see cref="M:System.Deployment.Application.ApplicationDeployment.CheckForUpdate" />, ale zwraca rozszerzone informacje o dostępnych aktualizacjach.</summary>
        <returns>
          <see cref="T:System.Deployment.Application.UpdateCheckInfo" /> Dostępnych aktualizacji.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CheckForUpdate">
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sprawdza <see cref="P:System.Deployment.Application.ApplicationDeployment.UpdateLocation" /> ustalenie, czy dostępna jest nowa aktualizacja.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CheckForUpdate">
      <MemberSignature Language="C#" Value="public bool CheckForUpdate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CheckForUpdate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.ApplicationDeployment.CheckForUpdate" />
      <MemberSignature Language="VB.NET" Value="Public Function CheckForUpdate () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CheckForUpdate();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sprawdza <see cref="P:System.Deployment.Application.ApplicationDeployment.UpdateLocation" /> ustalenie, czy dostępna jest nowa aktualizacja.</summary>
        <returns>
          <see langword="true" /> Jeśli nowa aktualizacja jest dostępna; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Deployment.Application.ApplicationDeployment.CheckForUpdate%2A> Metoda porównuje w wersji wdrożenia obecnie zainstalowana wersja określona w manifeście rozmieszczenia znaleźć pod adresem <xref:System.Deployment.Application.ApplicationDeployment.UpdateLocation%2A>. Jeśli wersja na serwerze jest inna niż zainstalowana wersja, zwraca `true`.  
  
 Ta metoda będzie blokował dopiero po ukończeniu sprawdzania. Aby sprawdzić dostępność aktualizacji asynchronicznie, użyj <xref:System.Deployment.Application.ApplicationDeployment.CheckForUpdateAsync%2A> metody zamiast tego.  
  
> [!NOTE]
>  Jeśli <xref:System.Deployment.Application.ApplicationDeployment.CheckForUpdate%2A> wykrywa, że aktualizacja jest dostępna, a użytkownik wybierze nie zostanie zainstalowany, [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] monitują użytkownika, która jest dostępna aktualizacja, przy następnym uruchomieniu aplikacji. Nie istnieje sposób, aby wyłączyć to monitowanie. (Jeśli aplikacja jest wymagana aktualizacja [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] zostanie zainstalowany bez monitowania.)  
  
   
  
## Examples  
 Poniższy przykład kodu sprawdza, czy aktualizacji aplikacji. Jeśli jest dostępny, instaluje go synchronicznie.  
  
 [!code-cpp[ClickOnceAPI#5](~/samples/snippets/cpp/VS_Snippets_Winforms/ClickOnceAPI/cpp/form1.cpp#5)]
 [!code-csharp[ClickOnceAPI#5](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#5)]
 [!code-vb[ClickOnceAPI#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceAPI/VB/Form1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] natychmiast zgłasza ten wyjątek, jeśli wywołujesz <see cref="M:System.Deployment.Application.ApplicationDeployment.CheckForUpdate" /> metody, gdy aktualizacja jest już w toku.</exception>
        <exception cref="T:System.Deployment.Application.DeploymentDownloadException">Nie można pobrać manifestu wdrożenia.</exception>
        <exception cref="T:System.Deployment.Application.InvalidDeploymentException">Manifest rozmieszczenia jest uszkodzony. Prawdopodobnie należy ponownie wdrożyć aplikację, aby rozwiązać ten problem.</exception>
        <permission cref="T:System.Security.PermissionSet">Aby uzyskać dostęp do komputera lokalnego. Wyliczenie skojarzone: <see cref="T:System.Security.Permissions.PermissionState" />.</permission>
        <altmember cref="M:System.Deployment.Application.ApplicationDeployment.CheckForUpdateAsync" />
        <altmember cref="M:System.Deployment.Application.ApplicationDeployment.CheckForDetailedUpdate" />
      </Docs>
    </Member>
    <Member MemberName="CheckForUpdate">
      <MemberSignature Language="C#" Value="public bool CheckForUpdate (bool persistUpdateCheckResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CheckForUpdate(bool persistUpdateCheckResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.ApplicationDeployment.CheckForUpdate(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function CheckForUpdate (persistUpdateCheckResult As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CheckForUpdate(bool persistUpdateCheckResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="persistUpdateCheckResult" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="persistUpdateCheckResult">Jeśli <see langword="false" />aktualizacji zostaną zastosowane w trybie dyskretnym i nie wyświetlane okno dialogowe będzie można.</param>
        <summary>Sprawdza <see cref="P:System.Deployment.Application.ApplicationDeployment.UpdateLocation" /> ustalenie, czy dostępna jest nowa aktualizacja.</summary>
        <returns>
          <see langword="true" /> Jeśli nowa aktualizacja jest dostępna; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckForUpdateAsync">
      <MemberSignature Language="C#" Value="public void CheckForUpdateAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CheckForUpdateAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.ApplicationDeployment.CheckForUpdateAsync" />
      <MemberSignature Language="VB.NET" Value="Public Sub CheckForUpdateAsync ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CheckForUpdateAsync();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sprawdza <see cref="P:System.Deployment.Application.ApplicationDeployment.UpdateLocation" /> asynchronicznie w celu określenia, czy dostępna jest nowa aktualizacja.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Deployment.Application.ApplicationDeployment.CheckForUpdateAsync%2A> Zwraca natychmiast i uruchamia oddzielnym wątku pobrać zaktualizowaną aplikację. Gdy metoda kończy lub została anulowana, zgłasza <xref:System.Deployment.Application.ApplicationDeployment.CheckForUpdateCompleted> zdarzeń. Można użyć <xref:System.ComponentModel.AsyncCompletedEventArgs> w tej obsłudze zdarzeń, aby określić, czy operacja została anulowana lub jeśli wystąpił wyjątek podczas aktualizacji.  
  
 Możesz anulować asynchroniczne aktualizacji przez wywołanie metody <xref:System.Deployment.Application.ApplicationDeployment.CheckForUpdateAsyncCancel%2A>.  
  
> [!NOTE]
>  Jeśli <xref:System.Deployment.Application.ApplicationDeployment.CheckForUpdate%2A> wykrywa, że aktualizacja jest dostępna, a użytkownik wybierze nie zostanie zainstalowany, [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] monitują użytkownika, która jest dostępna aktualizacja, przy następnym uruchomieniu aplikacji. Nie istnieje sposób, aby wyłączyć to monitowanie. (Jeśli aplikacja jest wymagana aktualizacja [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] zostanie zainstalowany bez monitowania.)  
  
   
  
## Examples  
 Poniższy przykład asynchronicznie sprawdza aktualizacji i instaluje aktualizację, jeśli taka istnieje.  
  
 [!code-cpp[ClickOnceAPI#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ClickOnceAPI/cpp/form1.cpp#1)]
 [!code-csharp[ClickOnceAPI#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#1)]
 [!code-vb[ClickOnceAPI#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceAPI/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] natychmiast zgłasza ten wyjątek, jeśli wywołujesz <see cref="M:System.Deployment.Application.ApplicationDeployment.CheckForUpdateAsync" /> metody, gdy aktualizacja jest już w toku.</exception>
        <exception cref="T:System.Deployment.Application.DeploymentDownloadException">Nie można pobrać manifestu wdrożenia. Ten wyjątek zostanie wyświetlony w <see cref="P:System.ComponentModel.AsyncCompletedEventArgs.Error" /> właściwość <see cref="E:System.Deployment.Application.ApplicationDeployment.CheckForUpdateCompleted" /> zdarzeń.</exception>
        <exception cref="T:System.Deployment.Application.InvalidDeploymentException">Manifest rozmieszczenia jest uszkodzony. Prawdopodobnie należy ponownie wdrożyć aplikację, aby rozwiązać ten problem. Ten wyjątek zostanie wyświetlony w <see cref="P:System.ComponentModel.AsyncCompletedEventArgs.Error" /> właściwość <see cref="E:System.Deployment.Application.ApplicationDeployment.CheckForUpdateCompleted" /> zdarzeń.</exception>
        <permission cref="T:System.Security.PermissionSet">Aby uzyskać dostęp do komputera lokalnego. Wyliczenie skojarzone: <see cref="T:System.Security.Permissions.PermissionState" />.</permission>
        <altmember cref="M:System.Deployment.Application.ApplicationDeployment.CheckForUpdate" />
        <altmember cref="M:System.Deployment.Application.ApplicationDeployment.CheckForDetailedUpdate" />
        <altmember cref="M:System.Deployment.Application.ApplicationDeployment.CheckForUpdateAsyncCancel" />
      </Docs>
    </Member>
    <Member MemberName="CheckForUpdateAsyncCancel">
      <MemberSignature Language="C#" Value="public void CheckForUpdateAsyncCancel ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CheckForUpdateAsyncCancel() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.ApplicationDeployment.CheckForUpdateAsyncCancel" />
      <MemberSignature Language="VB.NET" Value="Public Sub CheckForUpdateAsyncCancel ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CheckForUpdateAsyncCancel();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Umożliwia anulowanie wyboru asynchroniczne aktualizacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia anulowanie sprawdzania aktualizacji inicjowane z <xref:System.Deployment.Application.ApplicationDeployment.CheckForUpdateAsync%2A> metody.  
  
 Ta metoda nie spowoduje anulowanie wszelkich aktualizacji tła, które mogą już być w toku, takie jak rozpocząć aktualizacji w ramach subskrypcji. Aby uzyskać więcej informacji o subskrypcjach, zobacz [Wybieranie strategii aktualizacji ClickOnce](http://msdn.microsoft.com/library/d8b6e7bb-4ea0-47f3-91cd-48580bdceccc).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckForUpdateCompleted">
      <MemberSignature Language="C#" Value="public event System.Deployment.Application.CheckForUpdateCompletedEventHandler CheckForUpdateCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Deployment.Application.CheckForUpdateCompletedEventHandler CheckForUpdateCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Deployment.Application.ApplicationDeployment.CheckForUpdateCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event CheckForUpdateCompleted As CheckForUpdateCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Deployment::Application::CheckForUpdateCompletedEventHandler ^ CheckForUpdateCompleted;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Deployment.Application.CheckForUpdateCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy <see cref="M:System.Deployment.Application.ApplicationDeployment.CheckForUpdateAsync" /> została ukończona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Deployment.Application.CheckForUpdateCompletedEventArgs> Klasy informuje, między innymi, wersja aktualizacji, jak duże jest aktualizacji oraz czy jest dostępna aktualizacja, wymaganego lub opcjonalnego.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Deployment.Application.ApplicationDeployment.CheckForUpdateCompleted> można zdecydować, czy należy poprosić użytkownika do zainstalowania aktualizacji dostępnych aplikacji. Jeśli aktualizacja jest wymagane uaktualnienie, <xref:System.Deployment.Application.ApplicationDeployment.CheckForUpdateCompleted> program obsługi zdarzeń nie Monituj użytkownika. Przykład wymaga wdrożenie aplikacji formularzy systemu Windows, który zawiera <xref:System.Windows.Forms.StatusStrip> kontroli i czy ten formant zawiera <xref:System.Windows.Forms.ToolStripStatusLabel> formantu o nazwie `downloadStatus`.  
  
 [!code-cpp[ClickOnceAPI#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ClickOnceAPI/cpp/form1.cpp#1)]
 [!code-csharp[ClickOnceAPI#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#1)]
 [!code-vb[ClickOnceAPI#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceAPI/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckForUpdateProgressChanged">
      <MemberSignature Language="C#" Value="public event System.Deployment.Application.DeploymentProgressChangedEventHandler CheckForUpdateProgressChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Deployment.Application.DeploymentProgressChangedEventHandler CheckForUpdateProgressChanged" />
      <MemberSignature Language="DocId" Value="E:System.Deployment.Application.ApplicationDeployment.CheckForUpdateProgressChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event CheckForUpdateProgressChanged As DeploymentProgressChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Deployment::Application::DeploymentProgressChangedEventHandler ^ CheckForUpdateProgressChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Deployment.Application.DeploymentProgressChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy aktualizacja postępu jest dostępna w <see cref="M:System.Deployment.Application.ApplicationDeployment.CheckForUpdateAsync" /> wywołania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Deployment.Application.ApplicationDeployment.CheckForUpdateProgressChanged> Raporty dotyczące pobierania stanu wdrożenia aplikacji manifestu. Może to być istotne informacje dla użytkowników, którzy są pobieranie wdrożenia przez wolne połączenia sieciowe.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Deployment.Application.ApplicationDeployment.CheckForUpdateProgressChanged> zdarzeń w celu poinformowania użytkownika o ile manifestu rozmieszczenia pozostało do pobrania. Przykład wymaga wdrożenie aplikacji formularzy systemu Windows, który zawiera <xref:System.Windows.Forms.StatusStrip> kontroli i czy ten formant zawiera <xref:System.Windows.Forms.ToolStripStatusLabel> formantu o nazwie `downloadStatus`...  
  
 [!code-cpp[ClickOnceAPI#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ClickOnceAPI/cpp/form1.cpp#1)]
 [!code-csharp[ClickOnceAPI#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#1)]
 [!code-vb[ClickOnceAPI#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceAPI/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentDeployment">
      <MemberSignature Language="C#" Value="public static System.Deployment.Application.ApplicationDeployment CurrentDeployment { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Deployment.Application.ApplicationDeployment CurrentDeployment" />
      <MemberSignature Language="DocId" Value="P:System.Deployment.Application.ApplicationDeployment.CurrentDeployment" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentDeployment As ApplicationDeployment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Deployment::Application::ApplicationDeployment ^ CurrentDeployment { System::Deployment::Application::ApplicationDeployment ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Deployment.Application.ApplicationDeployment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zwraca bieżącą <see cref="T:System.Deployment.Application.ApplicationDeployment" /> dla tego wdrożenia.</summary>
        <value>Bieżącego wdrożenia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie można utworzyć wystąpienia <xref:System.Deployment.Application.ApplicationDeployment> bezpośrednio w aplikacji, należy pobrać prawidłowe wystąpienie za pośrednictwem <xref:System.Deployment.Application.ApplicationDeployment.CurrentDeployment%2A> właściwości.  
  
 <xref:System.Deployment.Application.ApplicationDeployment.CurrentDeployment%2A> Właściwość statyczna jest prawidłowy tylko z wewnątrz aplikacji, która została wdrożona przy użyciu [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]. Próby wywołania tej właściwości z inną niż[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplikacji spowoduje zgłoszenie wyjątku. Jeśli tworzysz aplikację, która może lub nie może być wdrożona przy użyciu [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)], użyj <xref:System.Deployment.Application.ApplicationDeployment.IsNetworkDeployed%2A> właściwości, aby sprawdzić, czy bieżący program jest [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplikacji.  
  
   
  
## Examples  
 Poniższy kod pobiera przykład <xref:System.Deployment.Application.ApplicationDeployment.CurrentDeployment%2A> i sprawdza, czy aplikacja została zaktualizowana w ciągu ostatnich trzech dni.  
  
 [!code-cpp[ClickOnceAPI#3](~/samples/snippets/cpp/VS_Snippets_Winforms/ClickOnceAPI/cpp/form1.cpp#3)]
 [!code-csharp[ClickOnceAPI#3](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#3)]
 [!code-vb[ClickOnceAPI#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceAPI/VB/Form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Deployment.Application.InvalidDeploymentException">Próbował wywołać ta właściwość statyczna z innej[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplikacji.</exception>
        <altmember cref="P:System.Deployment.Application.ApplicationDeployment.IsNetworkDeployed" />
      </Docs>
    </Member>
    <Member MemberName="CurrentVersion">
      <MemberSignature Language="C#" Value="public Version CurrentVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Version CurrentVersion" />
      <MemberSignature Language="DocId" Value="P:System.Deployment.Application.ApplicationDeployment.CurrentVersion" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentVersion As Version" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Version ^ CurrentVersion { Version ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wersję wdrożenia dla bieżącego wystąpienia uruchomionej aplikacji.</summary>
        <value>Bieżąca wersja wdrożenia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Deployment.Application.ApplicationDeployment.CurrentVersion%2A> będą się różnić od <xref:System.Deployment.Application.ApplicationDeployment.UpdatedVersion%2A> Jeśli nowa aktualizacja został zainstalowany, ale jeszcze nie wywołano <xref:System.Windows.Forms.Application.Restart%2A>. Jeśli manifest rozmieszczenia jest skonfigurowany do przeprowadzania aktualizacji automatycznych, możesz porównać te dwie wartości, aby określić, czy należy uruchomić ponownie aplikację.  
  
   
  
## Examples  
 Poniższy przykładowy kod definiuje metodę, która określa, czy [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] została zaktualizowana w aplikację.  
  
 [!code-cpp[ClickOnceAPI#3](~/samples/snippets/cpp/VS_Snippets_Winforms/ClickOnceAPI/cpp/form1.cpp#3)]
 [!code-csharp[ClickOnceAPI#3](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#3)]
 [!code-vb[ClickOnceAPI#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceAPI/VB/Form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.PermissionSet">Aby uzyskać dostęp do komputera lokalnego. Wyliczenie skojarzone: <see cref="T:System.Security.Permissions.PermissionState" />.</permission>
        <altmember cref="P:System.Deployment.Application.ApplicationDeployment.UpdatedVersion" />
      </Docs>
    </Member>
    <Member MemberName="DataDirectory">
      <MemberSignature Language="C#" Value="public string DataDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DataDirectory" />
      <MemberSignature Language="DocId" Value="P:System.Deployment.Application.ApplicationDeployment.DataDirectory" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DataDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DataDirectory { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ścieżkę do [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] katalog danych.</summary>
        <value>Ciąg zawierający ścieżkę do katalogu danych aplikacji na dysku lokalnym.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DownloadFileGroup">
      <MemberSignature Language="C#" Value="public void DownloadFileGroup (string groupName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DownloadFileGroup(string groupName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.ApplicationDeployment.DownloadFileGroup(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DownloadFileGroup (groupName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DownloadFileGroup(System::String ^ groupName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="groupName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="groupName">Nazwaną grupę plików do pobrania. Wszystkie pliki oznaczone jako "opcjonalnych" [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplikacji wymagają nazwy grupy.</param>
        <summary>Pobiera zestaw opcjonalne plików na żądanie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] pliki oznaczone jako "opcjonalne" w manifeście aplikacji nie zostaną pobrane podczas aktualizacji lub inicjowania aplikacji. Można użyć <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroup%2A> metodę, aby pobrać wszystkie pliki należące do grupy o nazwie na żądanie, tak aby nie zużywają zasoby sieci i miejsca na dysku nie ma pewności, ich wymaga. Na przykład niektórych użytkowników może być konieczne do użycia dołączony do aplikacji codziennie, podczas gdy inni użytkownicy nigdy nie może wywołać pakietu analizy danych.  
  
 Aby użyć zestawu zostały pobrane z <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroup%2A>, Dołącz odbiornik zdarzeń do <xref:System.AppDomain.AssemblyResolve> zdarzenia w <xref:System.AppDomain.CurrentDomain%2A>. Na przykład zobacz =[wskazówki: Pobieranie zestawów na żądanie z ClickOnce wdrażania interfejsu API przy użyciu narzędzia Projektant](http://msdn.microsoft.com/library/59a0dd5f-1cab-4f2f-b780-0ab7399905d5).  
  
 Wszystkie pliki są pobierane do [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] pamięci podręcznej aplikacji i czy w związku z tym izolowane, ograniczone do bieżącej wersji aplikacji. Załóżmy, że po aplikacja pobiera grupę plików, użytkownik instaluje nową wersję aplikacji, ale później zostanie przywrócony do poprzedniej wersji aplikacji. W takim przypadku poprzednia wersja nadal działa kopie plików, które pierwotnie pobrany. Aby uzyskać więcej informacji na temat uzyskiwania dostępu do plików danych, zobacz [dostęp do lokalnych i zdalnych danych w aplikacjach ClickOnce](http://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d).  
  
 <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroup%2A> działa w częściowo zaufane aplikacje, oznacza to, że w żadnym [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplikacja była uruchomiona z ograniczone uprawnienia. Jednak próba dynamicznie ładowanie zestawów aplikacji wymaga pełnego zaufania.  
  
 Pobieranie plików danych na żądanie nie jest obecnie obsługiwane.  
  
 Aplikacja nie będzie odbierać dane wejściowe użytkownika do <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroup%2A> zwraca metody. Jeśli potrzebujesz do pobierania plików bez zakłócania pracy użytkownika przepływu pracy, użyj <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupAsync%2A> metody zamiast tego.  
  
 Nie można pobrać pojedynczy plik za pomocą samej nazwy pliku. Aby pobrać pojedynczy plik, należy przypisać mu nazwę grupy w Twojej [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] wdrażania i pobierania grupy za pomocą tej metody.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak można załadować zestawu na żądanie przez nasłuchiwanie <xref:System.AppDomain.AssemblyResolve> zdarzeń.  
  
 [!code-csharp[ClickOnceOnDemandCmdLine#2](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceOnDemandCmdLine/CS/Form1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="groupName" /> Parametr ma wartość null lub pusty.</exception>
        <altmember cref="Overload:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupAsync" />
      </Docs>
    </Member>
    <MemberGroup MemberName="DownloadFileGroupAsync">
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobieranie na żądanie, zestawu opcjonalne plików w tle.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DownloadFileGroupAsync">
      <MemberSignature Language="C#" Value="public void DownloadFileGroupAsync (string groupName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DownloadFileGroupAsync(string groupName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupAsync(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DownloadFileGroupAsync (groupName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DownloadFileGroupAsync(System::String ^ groupName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="groupName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="groupName">Nazwaną grupę plików do pobrania. Wszystkie pliki oznaczone jako "opcjonalnych" [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplikacji wymagają nazwy grupy.</param>
        <summary>Pobieranie na żądanie, zestawu opcjonalne plików w tle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] pliki oznaczone jako "opcjonalne" w manifeście aplikacji nie zostaną pobrane podczas aktualizacji lub inicjowania aplikacji. Można użyć <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupAsync%2A> metodę, aby pobrać wszystkie pliki należące do grupy o nazwie na żądanie, tak aby nie zużywają zasoby sieci i miejsca na dysku nie ma pewności, ich wymaga. Ta metoda działa nie tylko pliki statyczne, ale dla zestawów, które aplikacja może lub nie może wymagać. Na przykład niektórych użytkowników może być konieczne do użycia dołączony do aplikacji codziennie, podczas gdy inni użytkownicy nigdy nie może wywołać pakietu analizy danych.  
  
 Aby pobrać zestawów na żądanie, dołączyć odbiornik zdarzeń do <xref:System.AppDomain.AssemblyResolve> zdarzenia <xref:System.AppDomain.CurrentDomain%2A>. Na przykład zobacz [wskazówki: Pobieranie zestawów na żądanie przy użyciu interfejsu API wdrażania ClickOnce](http://msdn.microsoft.com/library/d20e2789-8621-4806-b5b7-841122da1456).  
  
 Wszystkie zestawy są pobierane do [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] pamięci podręcznej aplikacji.  
  
 Wszystkie pliki statyczne są pobierane do [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] katalog danych aplikacji i czy w związku z tym izolowane, ograniczone do bieżącej wersji aplikacji. Załóżmy, że po aplikacja pobiera grupę plików, użytkownik instaluje nową wersję aplikacji, ale później zostanie przywrócony do poprzedniej wersji aplikacji. W takim przypadku poprzednia wersja nadal działa kopie plików, które pierwotnie pobrany. Aby uzyskać więcej informacji na temat uzyskiwania dostępu do plików statycznych zobacz [dostęp do lokalnych i zdalnych danych w aplikacjach ClickOnce](http://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d).  
  
 Możesz pobrać wiele grup plików jednocześnie przy użyciu <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupAsync%2A>. Można wyróżnić między nimi przy użyciu <xref:System.Deployment.Application.DeploymentProgressChangedEventArgs.Group%2A> właściwość <xref:System.Deployment.Application.DeploymentProgressChangedEventArgs> klasy, który jest przekazywany do <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupProgressChanged> zdarzeń. Jeśli musisz przekazać bardziej złożonych stanu, możesz użyć <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupAsync%2A> umożliwia przekazywanie `state` obiektu.  
  
 <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroup%2A> działa w częściowo zaufane aplikacje, oznacza to, że w żadnym [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplikacja była uruchomiona z ograniczone uprawnienia. Jednak jeśli próbujesz załadować zestawów dynamicznie, aplikacja wymaga pełnego zaufania.  
  
 Pobieranie plików danych na żądanie nie jest obecnie obsługiwane.  
  
 Nie można pobrać pojedynczy plik za pomocą samej nazwy pliku. Aby pobrać pojedynczy plik, należy przypisać mu nazwę grupy w Twojej [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] wdrażania i pobierania grupy za pomocą tej metody.  
  
 Aby anulować pobieranie asynchroniczne, należy wywołać <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupAsyncCancel%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="groupName" /> Parametr ma wartość null lub pusty.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można zainicjować pobieranie więcej niż jeden <paramref name="groupName" /> naraz.</exception>
        <altmember cref="M:System.Deployment.Application.ApplicationDeployment.DownloadFileGroup(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="DownloadFileGroupAsync">
      <MemberSignature Language="C#" Value="public void DownloadFileGroupAsync (string groupName, object userState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DownloadFileGroupAsync(string groupName, object userState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupAsync(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DownloadFileGroupAsync (groupName As String, userState As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DownloadFileGroupAsync(System::String ^ groupName, System::Object ^ userState);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="groupName" Type="System.String" />
        <Parameter Name="userState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="groupName">Nazwaną grupę plików do pobrania. Wszystkie pliki oznaczone jako "opcjonalnych" [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplikacji wymagają nazwy grupy.</param>
        <param name="userState">Dowolny obiekt zawierający informacje o stanie dla operacji asynchronicznej.</param>
        <summary>Pobieranie na żądanie, zestawu opcjonalne plików w tle i przekazuje fragment stanu aplikacji do wywołania zwrotne zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] pliki oznaczone jako "opcjonalne" w manifeście aplikacji nie zostaną pobrane podczas aktualizacji lub inicjowania aplikacji. Można użyć <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupAsync%2A> metodę, aby pobrać wszystkie pliki należące do grupy o nazwie na żądanie, tak aby nie zużywają zasoby sieci i miejsca na dysku nie ma pewności, ich wymaga. Ta metoda działa nie tylko pliki statyczne, ale dla zestawów, które aplikacja może lub nie może wymagać. Na przykład niektórych użytkowników może być konieczne do użycia dołączony do aplikacji codziennie, podczas gdy inni użytkownicy nigdy nie może wywołać pakietu analizy danych. Aby pobrać zestawów na żądanie, dołączyć odbiornik zdarzeń do <xref:System.AppDomain.AssemblyResolve> zdarzenia <xref:System.AppDomain.CurrentDomain%2A>.  
  
 Pobierz wiele grup plików jednocześnie za pomocą <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupAsync%2A> metody. Można wyróżnić między nimi przy użyciu <xref:System.Deployment.Application.DeploymentProgressChangedEventArgs.Group%2A> właściwość <xref:System.Deployment.Application.DeploymentProgressChangedEventArgs> klasy, który jest przekazywany do <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupProgressChanged> zdarzeń. Jeśli musisz przekazać bardziej złożonych stanu, możesz użyć  
  
 <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupAsync%2A> Umożliwia przekazywanie `state` obiektu.  
  
 Wszystkie pliki statyczne są pobierane do [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] katalog danych aplikacji i czy w związku z tym izolowane, ograniczone do bieżącej wersji aplikacji. Aby uzyskać więcej informacji na temat uzyskiwania dostępu do plików statycznych zobacz [dostęp do lokalnych i zdalnych danych w aplikacjach ClickOnce](http://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d). . Załóżmy, że po aplikacja pobiera grupę plików, użytkownik instaluje nową wersję aplikacji, ale użytkownika późniejszym zostanie przywrócony do poprzedniej wersji aplikacji. W takim przypadku poprzednia wersja nadal działa kopie plików, które pierwotnie pobrany.  
  
 <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroup%2A> działa w częściowo zaufane aplikacje, oznacza to, że w żadnym [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplikacja była uruchomiona z ograniczone uprawnienia. Jednak jeśli próbujesz załadować zestawów dynamicznie, aplikacja wymaga pełnego zaufania.  
  
 Pobieranie plików danych na żądanie nie jest obecnie obsługiwane.  
  
 Aby anulować pobieranie asynchroniczne, należy wywołać <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupAsyncCancel%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="groupName" /> Parametr ma wartość null lub pusty.</exception>
        <exception cref="T:System.InvalidOperationException">Nie można zainicjować pobieranie więcej niż jeden <paramref name="groupName" /> naraz.</exception>
        <altmember cref="M:System.Deployment.Application.ApplicationDeployment.DownloadFileGroup(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="DownloadFileGroupAsyncCancel">
      <MemberSignature Language="C#" Value="public void DownloadFileGroupAsyncCancel (string groupName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DownloadFileGroupAsyncCancel(string groupName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupAsyncCancel(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DownloadFileGroupAsyncCancel (groupName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DownloadFileGroupAsyncCancel(System::String ^ groupName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="groupName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="groupName">Nazwaną grupę plików do pobrania. Wszystkie pliki oznaczone jako "opcjonalnych" [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplikacji wymagają nazwy grupy.</param>
        <summary>Anuluje pobierania pliku asynchronicznego.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="groupName" /> nie może być <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DownloadFileGroupCompleted">
      <MemberSignature Language="C#" Value="public event System.Deployment.Application.DownloadFileGroupCompletedEventHandler DownloadFileGroupCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Deployment.Application.DownloadFileGroupCompletedEventHandler DownloadFileGroupCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DownloadFileGroupCompleted As DownloadFileGroupCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Deployment::Application::DownloadFileGroupCompletedEventHandler ^ DownloadFileGroupCompleted;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Deployment.Application.DownloadFileGroupCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Po zakończeniu pobierania pliku i występuje w wątku głównego aplikacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupCompleted> Zdarzenie jest wywoływane w wątku głównego aplikacji. Jest wielowątkowość do wywołania formantów formularzy systemu Windows aplikacji bezpośrednio z poziomu tego wywołania zwrotnego.  
  
 Sprawdź <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> właściwość <xref:System.ComponentModel.AsyncCompletedEventArgs> dostarczony do tego wywołania zwrotnego. Jeśli ta właściwość jest `null`, pobierania zakończyło się pomyślnie; Jeśli nie jest `null`, instalacja nie powiodła się i można znaleźć więcej informacji o niepowodzeniu instalacji za pomocą <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera grupy plików pomocy w tle. Przykład wymaga wdrożenie aplikacji formularzy systemu Windows, który zawiera <xref:System.Windows.Forms.StatusStrip> kontroli i czy ten formant zawiera <xref:System.Windows.Forms.ToolStripStatusLabel> formantu o nazwie `downloadStatus`...  
  
 [!code-cpp[ClickOnceAPI#8](~/samples/snippets/cpp/VS_Snippets_Winforms/ClickOnceAPI/cpp/form1.cpp#8)]
 [!code-csharp[ClickOnceAPI#8](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#8)]
 [!code-vb[ClickOnceAPI#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceAPI/VB/Form1.vb#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DownloadFileGroupProgressChanged">
      <MemberSignature Language="C#" Value="public event System.Deployment.Application.DeploymentProgressChangedEventHandler DownloadFileGroupProgressChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Deployment.Application.DeploymentProgressChangedEventHandler DownloadFileGroupProgressChanged" />
      <MemberSignature Language="DocId" Value="E:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupProgressChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DownloadFileGroupProgressChanged As DeploymentProgressChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Deployment::Application::DeploymentProgressChangedEventHandler ^ DownloadFileGroupProgressChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Deployment.Application.DeploymentProgressChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy stan informacji jest dostępnych w operacji pobierania plików inicjowane przez wywołanie do <see cref="Overload:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupAsync" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupProgressChanged> Zdarzenie jest wywoływane w wątku głównego aplikacji. Jest wielowątkowość do wywołania formantów formularzy systemu Windows aplikacji bezpośrednio z poziomu tego wywołania zwrotnego.  
  
 Użyj informacji podanych w <xref:System.Deployment.Application.DeploymentProgressChangedEventArgs> do komunikowania się informacje o postępie dla użytkowników.  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera grupy plików pomocy w tle. Przykład wymaga wdrożenie aplikacji formularzy systemu Windows, który zawiera <xref:System.Windows.Forms.StatusStrip> kontroli i czy ten formant zawiera <xref:System.Windows.Forms.ToolStripStatusLabel> formantu o nazwie `downloadStatus`.  
  
 [!code-cpp[ClickOnceAPI#8](~/samples/snippets/cpp/VS_Snippets_Winforms/ClickOnceAPI/cpp/form1.cpp#8)]
 [!code-csharp[ClickOnceAPI#8](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#8)]
 [!code-vb[ClickOnceAPI#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceAPI/VB/Form1.vb#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFileGroupDownloaded">
      <MemberSignature Language="C#" Value="public bool IsFileGroupDownloaded (string groupName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsFileGroupDownloaded(string groupName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.ApplicationDeployment.IsFileGroupDownloaded(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsFileGroupDownloaded (groupName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsFileGroupDownloaded(System::String ^ groupName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="groupName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="groupName">Nazwaną grupę plików do pobrania. Wszystkie pliki oznaczone jako "opcjonalnych" [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplikacji wymagają nazwy grupy.</param>
        <summary>Sprawdza, czy grupa plików o nazwie została już pobrana do komputera klienckiego.</summary>
        <returns>
          <see langword="true" /> Jeśli grupy plików została już pobrana przez bieżącą wersję tej aplikacji; w przeciwnym razie <see langword="false" />. Jeśli po zainstalowaniu nowej wersji aplikacji i nowa wersja ma nie dodane, usunięte lub zmienione pliki w grupie plików <see cref="M:System.Deployment.Application.ApplicationDeployment.IsFileGroupDownloaded(System.String)" /> zwraca <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Deployment.Application.ApplicationDeployment.IsFileGroupDownloaded%2A> działa w częściowo zaufanych aplikacji bez żadnych żądania kontroli zabezpieczeń.  
  
 Podczas aktualizacji aplikacji, [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] kopiuje wszystkie pliki danych na żądanie z poprzedniej wersji w katalogu danych nowej wersji. Jeśli pobierzesz nowe wersje tych plików, należy usunąć wszystkie dane, które chcesz zachować starszej wersji i przenieś go do nowej wersji.  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera wszystkie pliki w `HelpFiles` grupy na dysku.  
  
 [!code-cpp[ClickOnceAPI#8](~/samples/snippets/cpp/VS_Snippets_Winforms/ClickOnceAPI/cpp/form1.cpp#8)]
 [!code-csharp[ClickOnceAPI#8](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#8)]
 [!code-vb[ClickOnceAPI#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceAPI/VB/Form1.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Deployment.Application.InvalidDeploymentException">
          <paramref name="groupName" /> Grupa plików nie jest zdefiniowany w manifeście aplikacji.</exception>
        <altmember cref="M:System.Deployment.Application.ApplicationDeployment.DownloadFileGroup(System.String)" />
        <altmember cref="Overload:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupAsync" />
      </Docs>
    </Member>
    <Member MemberName="IsFirstRun">
      <MemberSignature Language="C#" Value="public bool IsFirstRun { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFirstRun" />
      <MemberSignature Language="DocId" Value="P:System.Deployment.Application.ApplicationDeployment.IsFirstRun" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFirstRun As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFirstRun { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy podczas pierwszego uruchomienia tej aplikacji na komputerze klienckim.</summary>
        <value>
          <see langword="true" /> Jeśli ta wersja aplikacji nigdy nie został uruchomiony na komputerze klienckim przed; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Deployment.Application.ApplicationDeployment.IsFirstRun%2A> ustalenie, czy trzeba wykonywać żadnych operacji jednorazowe inicjowanie przy pierwszym uruchomieniu aplikacji.  
  
 Nie wolno zakładać, że <xref:System.Deployment.Application.ApplicationDeployment.IsFirstRun%2A> ustawienie `true` wskazuje, że to wystąpienie aplikacji jest pierwsza z nich można wyświetlić interfejs użytkownika dla użytkownika. Ze względu na sposób system planuje procesów może mieć jedno wystąpienie aplikacji jego <xref:System.Deployment.Application.ApplicationDeployment.IsFirstRun%2A> ustawioną właściwość `true`, ale inne wystąpienie może być pierwszym do renderowania na ekranie. Wartość tej właściwości jest resetowany przy każdym uaktualnieniu z jedną wersję do następnego. Jeśli chcesz wykonać operację tylko pierwszego czasu dowolnej wersji aplikacja jest uruchamiana, trzeba będzie wykonać dodatkowy test, takich jak sprawdzanie obecności pliku utworzonego po raz pierwszy lub przechowywania, przy użyciu flagi **aplikacji Ustawienia**.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Deployment.Application.ApplicationDeployment.IsFirstRun%2A> zdecydować, czy należy sprawdzić dostępność aktualizacji do grupy plików `HelpFiles`. Jeśli jeden lub więcej plików zostały zaktualizowane, wywołuje metodę <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroup%2A> uzyskać nowe wersje.  
  
 [!code-csharp[ClickOnceAPI#9](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#9)]
 [!code-vb[ClickOnceAPI#9](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceAPI/VB/Form1.vb#9)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.PermissionSet">Aby uzyskać dostęp do komputera lokalnego. Wyliczenie skojarzone: <see cref="T:System.Security.Permissions.PermissionState" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="IsNetworkDeployed">
      <MemberSignature Language="C#" Value="public static bool IsNetworkDeployed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsNetworkDeployed" />
      <MemberSignature Language="DocId" Value="P:System.Deployment.Application.ApplicationDeployment.IsNetworkDeployed" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IsNetworkDeployed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool IsNetworkDeployed { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy bieżąca aplikacja jest [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplikacji.</summary>
        <value>
          <see langword="true" /> Jeśli jest to [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplikacji; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli chcesz, aby aplikację do uruchamiania zarówno wewnątrz jak i poza [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] wdrożenia (na przykład, jeśli zachodzi konieczność debugowania aplikacji na komputerze lokalnym przed jego wdrożeniem), test <xref:System.Deployment.Application.ApplicationDeployment.IsNetworkDeployed%2A> przed uzyskaniem dostępu do <xref:System.Deployment.Application.ApplicationDeployment.CurrentDeployment%2A> właściwości.  
  
 <xref:System.Deployment.Application.ApplicationDeployment.IsNetworkDeployed%2A> Zwraca `true` niezależnie od tego, czy jest zainstalowany lub aplikacji hostowanej w trybie online i niezależnie od tego, czy został zainstalowany z witryny sieci Web, udziału plików lub dysku CD.  
  
   
  
## Examples  
 Poniższy kod pobiera przykład <xref:System.Deployment.Application.ApplicationDeployment.CurrentDeployment%2A> za pomocą <xref:System.Deployment.Application.ApplicationDeployment.IsNetworkDeployed%2A> aby, najpierw upewnij się, że odwołanie jest `null`.  
  
 [!code-cpp[ClickOnceAPI#2](~/samples/snippets/cpp/VS_Snippets_Winforms/ClickOnceAPI/cpp/form1.cpp#2)]
 [!code-csharp[ClickOnceAPI#2](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.PermissionSet">Aby uzyskać dostęp do komputera lokalnego. Wyliczenie skojarzone: <see cref="T:System.Security.Permissions.PermissionState" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="TimeOfLastUpdateCheck">
      <MemberSignature Language="C#" Value="public DateTime TimeOfLastUpdateCheck { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime TimeOfLastUpdateCheck" />
      <MemberSignature Language="DocId" Value="P:System.Deployment.Application.ApplicationDeployment.TimeOfLastUpdateCheck" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TimeOfLastUpdateCheck As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime TimeOfLastUpdateCheck { DateTime get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera datę i godzinę [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] ostatnie sprawdzanie aktualizacji aplikacji.</summary>
        <value>
          <see cref="T:System.DateTime" /> Ostatniego sprawdzenia dostępności aktualizacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplikacji można skonfigurować dla aktualizacji subskrypcji. W tym scenariuszu [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] sonduje lokalizacja wdrożenia aplikacji automatycznie w odstępach czasu zdefiniowanych w manifeście wdrażania i określa, czy jest dostępna aktualizacja. <xref:System.Deployment.Application.ApplicationDeployment.TimeOfLastUpdateCheck%2A> Zwraca godzinę ostatniego sprawdzenia aktualizacji niezależnie od tego, czy zostało zainicjowane przez subskrypcję lub za pomocą jawnego wyboru <xref:System.Deployment.Application.ApplicationDeployment.CheckForUpdate%2A>, <xref:System.Deployment.Application.ApplicationDeployment.CheckForUpdateAsync%2A>, <xref:System.Deployment.Application.ApplicationDeployment.CheckForDetailedUpdate%2A>, <xref:System.Deployment.Application.ApplicationDeployment.Update%2A>, lub <xref:System.Deployment.Application.ApplicationDeployment.UpdateAsync%2A> metody.  
  
 Jeśli przeprowadzono bez sprawdzania aktualizacji, ponieważ aplikacja została zainstalowana, <xref:System.Deployment.Application.ApplicationDeployment.TimeOfLastUpdateCheck%2A> zwraca czas instalacji.  
  
   
  
## Examples  
 Poniższy kod przykład sprawdza, czy [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplikacji sprawdzeniu dostępności aktualizacji w ciągu ostatnich trzech dni.  
  
 [!code-cpp[ClickOnceAPI#3](~/samples/snippets/cpp/VS_Snippets_Winforms/ClickOnceAPI/cpp/form1.cpp#3)]
 [!code-csharp[ClickOnceAPI#3](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#3)]
 [!code-vb[ClickOnceAPI#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceAPI/VB/Form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.PermissionSet">Aby uzyskać dostęp do komputera lokalnego. Wyliczenie skojarzone: <see cref="T:System.Security.Permissions.PermissionState" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Update">
      <MemberSignature Language="C#" Value="public bool Update ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Update() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.ApplicationDeployment.Update" />
      <MemberSignature Language="VB.NET" Value="Public Function Update () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Update();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Uruchamia synchroniczne pobranie i zainstalowanie najnowszej wersji tej aplikacji.</summary>
        <returns>
          <see langword="true" /> Jeśli aplikacja została zaktualizowana; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplikacja jest uznawany za zaktualizowane po opublikowaniu nowej wersji aplikacji do lokalizacji określonej przez <xref:System.Deployment.Application.ApplicationDeployment.UpdateLocation%2A>, a obecnie numer wersji w manifeście wdrażania aplikacji jest większy niż numer wersji aplikacji zainstalowana na komputerze użytkownika.  
  
 <xref:System.Deployment.Application.ApplicationDeployment.Update%2A> Wywołania zablokuje dopóki aktualizacja została pobrana na komputer kliencki i zainstalowane w [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] pamięci podręcznej; w tym czasie aplikacji nie będzie odbierać użytkownika. Jeśli chcesz zachować czas odpowiedzi aplikacji lub wyświetlić raport postępu podczas pobierania, użyj <xref:System.Deployment.Application.ApplicationDeployment.UpdateAsync%2A> metody zamiast tego.  
  
 <xref:System.Deployment.Application.ApplicationDeployment.Update%2A> pobiera wszystkie pliki, które nie są oznaczone jako "opcjonalne" w manifeście aplikacji. Możesz pobrać pliki opcjonalne na żądanie za pomocą <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroup%2A> lub <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupAsync%2A> metody.  
  
 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] może już być zaktualizować aplikację automatycznie po wywołaniu <xref:System.Deployment.Application.ApplicationDeployment.Update%2A> metody; Jeśli tak się stanie, wywołania tej metody spowoduje zgłoszenie <xref:System.InvalidOperationException>.  
  
 Jeśli co najmniej jeden plik został zaktualizowany w danym wdrożeniu, ale manifest aplikacji nie zostały odświeżone, zostanie wyświetlony <xref:System.Deployment.Application.InvalidDeploymentException>. Większość czasu, ponownego wdrażania z [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplikacji rozwiązuje ten problem. Otrzymasz również ten wyjątek, jeśli podpis klucza publicznego manifestem rozmieszczenia ani manifest aplikacji jest nieprawidłowa lub brakująca.  
  
 Aktualizacja może prosić o wyższym poziomie zaufania na komputerze lokalnym od poprzedniej wersji aplikacji. Jeśli aplikacja używa zaufane wdrożenia aplikacji, typowe Menedżera zaufania środowiska uruchomieniowego (języka wspólnego CLR) języka sprawdza, czy manifest wdrażania, aby określić, czy zawiera on zaufania prawidłową licencję. Jeśli manifest rozmieszczenia nie zawiera licencji prawidłowy zaufania [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] spowoduje zatrzymanie instalacji i zgłasza <xref:System.Deployment.Application.TrustNotGrantedException>. <xref:System.Deployment.Application.ApplicationDeployment.Update%2A> Metody nigdy nie wyświetli monit z zapytaniem użytkownika, czy chcą przyznać uprawnienia aplikacji do uruchamiania.  
  
   
  
## Examples  
 Poniższy przykład kodu sprawdza, czy aktualizacji aplikacji. Jeśli jest dostępna aktualizacja, instaluje go synchronicznie.  
  
 [!code-cpp[ClickOnceAPI#6](~/samples/snippets/cpp/VS_Snippets_Winforms/ClickOnceAPI/cpp/form1.cpp#6)]
 [!code-csharp[ClickOnceAPI#6](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#6)]
 [!code-vb[ClickOnceAPI#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceAPI/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Deployment.Application.TrustNotGrantedException">Komputer lokalny nie przyznała aplikacji poziomu uprawnień, żądana do wykonania.</exception>
        <exception cref="T:System.Deployment.Application.InvalidDeploymentException">Twoje [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] wdrożenia jest uszkodzony. Aby uzyskać porady na temat zdiagnozować i rozwiązać ten problem, zobacz [Rozwiązywanie problemów z wdrożeniami ClickOnce](http://msdn.microsoft.com/library/58e90012-f68b-4852-8ae9-58e361cbcc32).</exception>
        <exception cref="T:System.Deployment.Application.DeploymentDownloadException">Nie można pobrać nowe wdrożenie z lokalizacji w sieci.</exception>
        <exception cref="T:System.InvalidOperationException">Aplikacja jest obecnie aktualizowana.</exception>
        <permission cref="T:System.Security.PermissionSet">Aby uzyskać dostęp do komputera lokalnego. Wyliczenie skojarzone: <see cref="T:System.Security.Permissions.PermissionState" />.</permission>
        <altmember cref="M:System.Deployment.Application.ApplicationDeployment.UpdateAsync" />
        <altmember cref="M:System.Deployment.Application.ApplicationDeployment.CheckForUpdateAsync" />
        <altmember cref="M:System.Deployment.Application.ApplicationDeployment.CheckForUpdate" />
        <altmember cref="M:System.Deployment.Application.ApplicationDeployment.CheckForDetailedUpdate" />
      </Docs>
    </Member>
    <Member MemberName="UpdateAsync">
      <MemberSignature Language="C#" Value="public void UpdateAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UpdateAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.ApplicationDeployment.UpdateAsync" />
      <MemberSignature Language="VB.NET" Value="Public Sub UpdateAsync ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UpdateAsync();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Uruchamia asynchroniczne pobranie i zainstalowanie najnowszej wersji tej aplikacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplikacja jest uznawany za zaktualizowane po opublikowaniu nowej wersji aplikacji do lokalizacji określonej przez <xref:System.Deployment.Application.ApplicationDeployment.UpdateLocation%2A>, a obecnie numer wersji w manifeście wdrażania aplikacji jest większy niż numer wersji aplikacji zainstalowana na komputerze użytkownika.  
  
 Podczas pobierania aktualizacji, [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] zgłosi <xref:System.Deployment.Application.ApplicationDeployment.UpdateProgressChanged> obsługi zdarzeń w wątku głównego aplikacji, aby poinformować Cię o stan pobierania. Podczas aktualizacji asynchroniczne zakończy lub napotkał wyjątek [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] zgłosi <xref:System.Deployment.Application.ApplicationDeployment.UpdateCompleted> zdarzenia w wątku głównego aplikacji. Sprawdź <xref:System.ComponentModel.AsyncCompletedEventArgs> dostarczony do tego zdarzenia w celu określenia, czy aktualizacja zakończyło się pomyślnie.  
  
 Jeśli <xref:System.Deployment.Application.ApplicationDeployment.UpdateAsync%2A> zgłasza wyjątek, [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] wywołania <xref:System.Deployment.Application.ApplicationDeployment.UpdateCompleted> i ustawia <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> właściwość <xref:System.ComponentModel.AsyncCompletedEventArgs> zgłoszony wyjątek.  
  
 <xref:System.Deployment.Application.ApplicationDeployment.UpdateAsync%2A> pobierze wszystkie pliki w danym wdrożeniu nie jest oznaczony jako "opcjonalne" w manifeście aplikacji. Możesz pobrać pliki opcjonalne na żądanie za pomocą <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroup%2A> lub <xref:System.Deployment.Application.ApplicationDeployment.DownloadFileGroupAsync%2A> metody.  
  
 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] może już być zaktualizować aplikację automatycznie po wywołaniu <xref:System.Deployment.Application.ApplicationDeployment.UpdateAsync%2A> metody; Jeśli tak się stanie, wywołania tej metody spowoduje zgłoszenie <xref:System.InvalidOperationException>.  
  
 Jeśli co najmniej jeden plik został zaktualizowany w danym wdrożeniu, ale manifest aplikacji nie zostały odświeżone, zostanie wyświetlony <xref:System.Deployment.Application.InvalidDeploymentException>. W większości przypadków, ponownie skompilować manifest aplikacji rozwiązuje ten problem. Otrzymasz również ten wyjątek, jeśli podpis klucza publicznego manifestem rozmieszczenia ani manifest aplikacji jest nieprawidłowa lub brakująca.  
  
 Aktualizacja może prosić o wyższym poziomie zaufania na komputerze lokalnym od poprzedniej wersji aplikacji. Jeśli aplikacja używa zaufane wdrożenia aplikacji, typowe Menedżera zaufania środowiska uruchomieniowego (języka wspólnego CLR) języka sprawdza, czy manifest wdrażania, aby określić, czy zawiera on zaufania prawidłową licencję. Jeśli manifest rozmieszczenia nie zawiera licencji prawidłowy zaufania [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] spowoduje zatrzymanie instalacji i zgłasza <xref:System.Deployment.Application.TrustNotGrantedException>. <xref:System.Deployment.Application.ApplicationDeployment.UpdateAsync%2A> nigdy nie wyświetli monit z prośbą, jeśli chcą przyznać uprawnienia aplikacji do uruchamiania.  
  
   
  
## Examples  
 Poniższy przykład kodu Określa, czy dostępna jest nowa aktualizacja w czasie ładowania aplikacji. Jeśli wymagana aktualizacja jest dostępna, instaluje aktualizację asynchronicznie. Przykład wymaga wdrożenie aplikacji formularzy systemu Windows, który zawiera <xref:System.Windows.Forms.StatusStrip> kontroli i czy ten formant zawiera <xref:System.Windows.Forms.ToolStripStatusLabel> formantu o nazwie `downloadStatus`.  
  
 [!code-cpp[ClickOnceAPI#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ClickOnceAPI/cpp/form1.cpp#1)]
 [!code-csharp[ClickOnceAPI#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#1)]
 [!code-vb[ClickOnceAPI#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceAPI/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Deployment.Application.TrustNotGrantedException">Komputer lokalny nie przyznała tej aplikacji poziomu uprawnień, żądana do wykonania.</exception>
        <exception cref="T:System.Deployment.Application.InvalidDeploymentException">Twoje [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] wdrożenia jest uszkodzony. Aby uzyskać porady na temat zdiagnozować i rozwiązać ten problem, zobacz [Rozwiązywanie problemów z wdrożeniami ClickOnce](http://msdn.microsoft.com/library/58e90012-f68b-4852-8ae9-58e361cbcc32).</exception>
        <exception cref="T:System.Deployment.Application.DeploymentDownloadException">Nie można pobrać nowe wdrożenie z lokalizacji w sieci.</exception>
        <permission cref="T:System.Security.PermissionSet">Aby uzyskać dostęp do komputera lokalnego. Wyliczenie skojarzone: <see cref="T:System.Security.Permissions.PermissionState" />.</permission>
        <altmember cref="E:System.Deployment.Application.ApplicationDeployment.UpdateCompleted" />
      </Docs>
    </Member>
    <Member MemberName="UpdateAsyncCancel">
      <MemberSignature Language="C#" Value="public void UpdateAsyncCancel ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UpdateAsyncCancel() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Deployment.Application.ApplicationDeployment.UpdateAsyncCancel" />
      <MemberSignature Language="VB.NET" Value="Public Sub UpdateAsyncCancel ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UpdateAsyncCancel();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Umożliwia anulowanie asynchroniczne aktualizacji inicjowane przez <see cref="M:System.Deployment.Application.ApplicationDeployment.UpdateAsync" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Deployment.Application.ApplicationDeployment.UpdateAsyncCancel%2A> tylko anuluje aktualizacji inicjowane przez wywołanie do <xref:System.Deployment.Application.ApplicationDeployment.UpdateAsync%2A>; Anuluj aktualizację uruchomiona w ramach subskrypcji.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.PermissionSet">Aby uzyskać dostęp do komputera lokalnego. Wyliczenie skojarzone: <see cref="T:System.Security.Permissions.PermissionState" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="UpdateCompleted">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.AsyncCompletedEventHandler UpdateCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.AsyncCompletedEventHandler UpdateCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Deployment.Application.ApplicationDeployment.UpdateCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event UpdateCompleted As AsyncCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::AsyncCompletedEventHandler ^ UpdateCompleted;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.AsyncCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] zakończył uaktualnianie aplikacji w wyniku wywołania <see cref="M:System.Deployment.Application.ApplicationDeployment.UpdateAsync" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Deployment.Application.ApplicationDeployment.UpdateCompleted> Zdarzenie jest wywoływane w wątku głównego aplikacji. Formanty formularzy systemu Windows aplikacji bezpośrednio z poziomu tego wywołania zwrotnego może wywołać bez wyzwalania Wystąpił wyjątek.  
  
 Sprawdź <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> właściwość <xref:System.ComponentModel.AsyncCompletedEventArgs> dostarczony do tego wywołania zwrotnego. Jeśli ta właściwość jest `null`, instalacja zakończyła się pomyślnie; Jeśli nie jest `null`, instalacja nie powiodła się i można znaleźć więcej informacji na temat tego błędu instalacji za pomocą <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> właściwości. Po pobraniu aktualizacji, należy wywołać <xref:System.Windows.Forms.Application.Restart%2A> metoda <xref:System.Windows.Forms.Application> w nowszej wersji aplikacji.  
  
 Jeśli instalacja aktualizacji została anulowana przez wywołanie do <xref:System.Deployment.Application.ApplicationDeployment.UpdateAsyncCancel%2A>, <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> właściwość <xref:System.ComponentModel.AsyncCompletedEventArgs> będzie klasy `true`.  
  
 Aby korzystać z tej obsługi zdarzeń, aplikacji należy zaimportować, obu <xref:System.Deployment.Application> i <xref:System.ComponentModel> przestrzeni nazw.  
  
   
  
## Examples  
 Poniższy przykład kodu określa w czasie ładowania aplikacji, czy nowa aktualizacja jest dostępna; Jeśli wymagana aktualizacja jest dostępna, instaluje aktualizację asynchronicznie. Przykład wymaga wdrożenie aplikacji formularzy systemu Windows, który zawiera <xref:System.Windows.Forms.StatusStrip> kontroli i czy ten formant zawiera <xref:System.Windows.Forms.ToolStripStatusLabel> formantu o nazwie `downloadStatus`.  
  
 [!code-cpp[ClickOnceAPI#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ClickOnceAPI/cpp/form1.cpp#1)]
 [!code-csharp[ClickOnceAPI#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#1)]
 [!code-vb[ClickOnceAPI#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceAPI/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdatedApplicationFullName">
      <MemberSignature Language="C#" Value="public string UpdatedApplicationFullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UpdatedApplicationFullName" />
      <MemberSignature Language="DocId" Value="P:System.Deployment.Application.ApplicationDeployment.UpdatedApplicationFullName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UpdatedApplicationFullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UpdatedApplicationFullName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera pełną nazwę aplikacji, po jego aktualizacji.</summary>
        <value>A <see cref="T:System.String" /> zawiera pełną nazwę aplikacji.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdatedVersion">
      <MemberSignature Language="C#" Value="public Version UpdatedVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Version UpdatedVersion" />
      <MemberSignature Language="DocId" Value="P:System.Deployment.Application.ApplicationDeployment.UpdatedVersion" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UpdatedVersion As Version" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Version ^ UpdatedVersion { Version ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wersję aktualizacji, która została ostatnio pobrana.</summary>
        <value>
          <see cref="T:System.Version" /> Opisujące wersji aktualizacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Deployment.Application.ApplicationDeployment.UpdatedVersion%2A> różni się od <xref:System.Deployment.Application.ApplicationDeployment.CurrentVersion%2A> Jeśli nowa aktualizacja został zainstalowany, ale jeszcze nie wywołano <xref:System.Windows.Forms.Application.Restart%2A> na <xref:System.Windows.Forms.Application>. Jeśli manifest wdrażania aplikacji jest skonfigurowany do przeprowadzania aktualizacji automatycznych, możesz porównać te dwie wartości, aby określić, czy należy uruchomić ponownie aplikację.  
  
 Jeśli aplikacja nie została zaktualizowana, <xref:System.Deployment.Application.ApplicationDeployment.UpdatedVersion%2A> zwraca taką samą wartość jak <xref:System.Deployment.Application.ApplicationDeployment.CurrentVersion%2A>.  
  
   
  
## Examples  
 Poniższy przykładowy kod definiuje metodę, która określa, czy [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] została zaktualizowana w aplikację.  
  
 [!code-cpp[ClickOnceAPI#4](~/samples/snippets/cpp/VS_Snippets_Winforms/ClickOnceAPI/cpp/form1.cpp#4)]
 [!code-csharp[ClickOnceAPI#4](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#4)]
 [!code-vb[ClickOnceAPI#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceAPI/VB/Form1.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.PermissionSet">Aby uzyskać dostęp do komputera lokalnego. Wyliczenie skojarzone: <see cref="T:System.Security.Permissions.PermissionState" /></permission>
      </Docs>
    </Member>
    <Member MemberName="UpdateLocation">
      <MemberSignature Language="C#" Value="public Uri UpdateLocation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri UpdateLocation" />
      <MemberSignature Language="DocId" Value="P:System.Deployment.Application.ApplicationDeployment.UpdateLocation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UpdateLocation As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ UpdateLocation { Uri ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera witryny sieci Web lub udziału plików, w którym ta aplikacja aktualizuje się samodzielnie.</summary>
        <value>Ścieżka aktualizacji, wyrażone jako HTTP, HTTPS lub adres URL pliku; lub jako systemu Windows sieci ścieżkę pliku (UNC).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Deployment.Application.ApplicationDeployment.UpdateLocation%2A> może się różnić od witryny sieci Web, używany do pobierania aplikacji początkowo, jeśli wdrożenie aplikacji jest skonfigurowana do używania aktualizacji przekierowania.  
  
 Tę wartość można zmienić tylko w manifeście wdrażania aplikacji.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.PermissionSet">Aby uzyskać dostęp do komputera lokalnego. Wyliczenie skojarzone: <see cref="T:System.Security.Permissions.PermissionState" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="UpdateProgressChanged">
      <MemberSignature Language="C#" Value="public event System.Deployment.Application.DeploymentProgressChangedEventHandler UpdateProgressChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Deployment.Application.DeploymentProgressChangedEventHandler UpdateProgressChanged" />
      <MemberSignature Language="DocId" Value="E:System.Deployment.Application.ApplicationDeployment.UpdateProgressChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event UpdateProgressChanged As DeploymentProgressChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Deployment::Application::DeploymentProgressChangedEventHandler ^ UpdateProgressChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Deployment</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Deployment.Application.DeploymentProgressChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] zawiera nowe informacje o stanie dla operacji aktualizacji inicjowane przez wywołanie metody <see cref="M:System.Deployment.Application.ApplicationDeployment.UpdateAsync" /> — metoda.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Deployment.Application.ApplicationDeployment.UpdateProgressChanged> Zdarzenie jest wywoływane w wątku głównego aplikacji. Formanty formularzy systemu Windows aplikacji bezpośrednio z poziomu tego wywołania zwrotnego może wywołać bez wyzwalania Wystąpił wyjątek.  
  
   
  
## Examples  
 Poniższy przykład kodu określa w czasie ładowania aplikacji, czy nowa aktualizacja jest dostępna; Jeśli wymagana aktualizacja jest dostępna, instaluje aktualizację asynchronicznie.  
  
 [!code-cpp[ClickOnceAPI#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ClickOnceAPI/cpp/form1.cpp#1)]
 [!code-csharp[ClickOnceAPI#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ClickOnceAPI/CS/Form1.cs#1)]
 [!code-vb[ClickOnceAPI#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ClickOnceAPI/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
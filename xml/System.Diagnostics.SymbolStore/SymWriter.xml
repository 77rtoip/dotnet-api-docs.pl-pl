<Type Name="SymWriter" FullName="System.Diagnostics.SymbolStore.SymWriter">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="82172213e41686a6a0f480bfba1818973cb9a9c2" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37664573" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class SymWriter : System.Diagnostics.SymbolStore.SymWriterBase, IDisposable, System.Diagnostics.SymbolStore.ISymbolWriter" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit SymWriter extends System.Diagnostics.SymbolStore.SymWriterBase implements class System.Diagnostics.SymbolStore.ISymbolWriter, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.SymbolStore.SymWriter" />
  <TypeSignature Language="VB.NET" Value="Public Class SymWriter&#xA;Inherits SymWriterBase&#xA;Implements IDisposable, ISymbolWriter" />
  <TypeSignature Language="C++ CLI" Value="public ref class SymWriter : System::Diagnostics::SymbolStore::SymWriterBase, IDisposable, System::Diagnostics::SymbolStore::ISymbolWriter" />
  <TypeSignature Language="F#" Value="type SymWriter = class&#xA;    inherit SymWriterBase&#xA;    interface ISymbolWriter&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>ISymWrapper</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Diagnostics.SymbolStore.SymWriterBase</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-1.1">System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Diagnostics.SymbolStore.ISymbolWriter</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje edytor symboli dla kodu zarządzanego.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.SymbolStore.SymWriter> Klasa dostarcza metody, które definiują dokumentów, punktów sekwencji, leksykalne zakresy i zmienne.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SymWriter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SymWriter();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Diagnostics.SymbolStore.SymWriter" /> klasy.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać możliwość dostępu do kodu niezarządzanego.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SymWriter (bool noUnderlyingWriter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool noUnderlyingWriter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (noUnderlyingWriter As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SymWriter(bool noUnderlyingWriter);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.SymbolStore.SymWriter : bool -&gt; System.Diagnostics.SymbolStore.SymWriter" Usage="new System.Diagnostics.SymbolStore.SymWriter noUnderlyingWriter" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="noUnderlyingWriter" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="noUnderlyingWriter">
          <see langword="true" /> Jeśli podstawowy zapisywania symbol będzie świadczona przez wywołanie metody <see cref="M:System.Diagnostics.SymbolStore.SymWriter.SetUnderlyingWriter(System.IntPtr)" /> metody. <see langword="false" /> Jeśli zamiast tego powinien zostać utworzony domyślny podstawowy moduł zapisujący symboli.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Diagnostics.SymbolStore.SymWriter" /> klasy, określająca, czy do utworzenia podstawowego składnika zapisywania symbolu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="__dtor">
      <MemberSignature Language="C#" Value="public void __dtor ();" />
      <MemberSignature Language="ILAsm" Value=".method public instance void __dtor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.__dtor" />
      <MemberSignature Language="VB.NET" Value="Public Sub __dtor ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void __dtor();" />
      <MemberSignature Language="F#" Value="member this.__dtor : unit -&gt; unit" Usage="symWriter.__dtor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="{dtor}">
      <MemberSignature Language="C#" Value="public void {dtor} ();" />
      <MemberSignature Language="ILAsm" Value=".method public instance void {dtor}() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.{dtor}" />
      <MemberSignature Language="VB.NET" Value="Public Sub {dtor} ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void {dtor}();" />
      <MemberSignature Language="F#" Value="member this.{dtor} : unit -&gt; unit" Usage="symWriter.{dtor} " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit&#xA;override this.Close : unit -&gt; unit" Usage="symWriter.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zamyka <see cref="T:System.Diagnostics.SymbolStore.SymWriter" /> i zatwierdzeń symbole do magazynu symboli.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po tym wywołaniu <xref:System.Diagnostics.SymbolStore.SymWriter> staje się nieprawidłowy dalsze aktualizacje.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloseMethod">
      <MemberSignature Language="C#" Value="public virtual void CloseMethod ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CloseMethod() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.CloseMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub CloseMethod ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CloseMethod();" />
      <MemberSignature Language="F#" Value="abstract member CloseMethod : unit -&gt; unit&#xA;override this.CloseMethod : unit -&gt; unit" Usage="symWriter.CloseMethod " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zamyka bieżącą metodę.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po zamknięciu metody nie można zdefiniować symbol z w metodzie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloseNamespace">
      <MemberSignature Language="C#" Value="public virtual void CloseNamespace ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CloseNamespace() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.CloseNamespace" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub CloseNamespace ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CloseNamespace();" />
      <MemberSignature Language="F#" Value="abstract member CloseNamespace : unit -&gt; unit&#xA;override this.CloseNamespace : unit -&gt; unit" Usage="symWriter.CloseNamespace " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zamyka najnowszych przestrzeni nazw.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CloseScope">
      <MemberSignature Language="C#" Value="public virtual void CloseScope (int endOffset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CloseScope(int32 endOffset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.CloseScope(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub CloseScope (endOffset As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CloseScope(int endOffset);" />
      <MemberSignature Language="F#" Value="abstract member CloseScope : int -&gt; unit&#xA;override this.CloseScope : int -&gt; unit" Usage="symWriter.CloseScope endOffset" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="endOffset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="endOffset">Przesunięcia tylko po ostatniej instrukcji w zakresie języka Pośredniego.</param>
        <summary>Zamyka bieżący zakresie leksykalnym.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po zamknięciu zakresu nie można zdefiniować zmienną z w metodzie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefineDocument">
      <MemberSignature Language="C#" Value="public virtual System.Diagnostics.SymbolStore.ISymbolDocumentWriter DefineDocument (string url, Guid language, Guid languageVendor, Guid documentType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Diagnostics.SymbolStore.ISymbolDocumentWriter DefineDocument(string url, valuetype System.Guid language, valuetype System.Guid languageVendor, valuetype System.Guid documentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.DefineDocument(System.String,System.Guid,System.Guid,System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DefineDocument (url As String, language As Guid, languageVendor As Guid, documentType As Guid) As ISymbolDocumentWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Diagnostics::SymbolStore::ISymbolDocumentWriter ^ DefineDocument(System::String ^ url, Guid language, Guid languageVendor, Guid documentType);" />
      <MemberSignature Language="F#" Value="abstract member DefineDocument : string * Guid * Guid * Guid -&gt; System.Diagnostics.SymbolStore.ISymbolDocumentWriter&#xA;override this.DefineDocument : string * Guid * Guid * Guid -&gt; System.Diagnostics.SymbolStore.ISymbolDocumentWriter" Usage="symWriter.DefineDocument (url, language, languageVendor, documentType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.SymbolStore.ISymbolDocumentWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="language" Type="System.Guid" />
        <Parameter Name="languageVendor" Type="System.Guid" />
        <Parameter Name="documentType" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="url">Adres URL, który identyfikuje dokumentu.</param>
        <param name="language">Język dokumentu. Ten parametr może być <see cref="F:System.Guid.Empty" />.</param>
        <param name="languageVendor">Tożsamość dostawcy języka dokumentu. Ten parametr może być <see cref="F:System.Guid.Empty" />.</param>
        <param name="documentType">Typ dokumentu. Ten parametr może być <see cref="F:System.Guid.Empty" />.</param>
        <summary>Definiuje dokumentu źródłowego.</summary>
        <returns>
          <see cref="T:System.Diagnostics.SymbolStore.ISymbolDocumentWriter" /> Obiekt, który reprezentuje dokument.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefineField">
      <MemberSignature Language="C#" Value="public virtual void DefineField (System.Diagnostics.SymbolStore.SymbolToken parent, string name, System.Reflection.FieldAttributes attributes, byte[] signature, System.Diagnostics.SymbolStore.SymAddressKind addrKind, int addr1, int addr2, int addr3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DefineField(valuetype System.Diagnostics.SymbolStore.SymbolToken parent, string name, valuetype System.Reflection.FieldAttributes attributes, unsigned int8[] signature, valuetype System.Diagnostics.SymbolStore.SymAddressKind addrKind, int32 addr1, int32 addr2, int32 addr3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.DefineField(System.Diagnostics.SymbolStore.SymbolToken,System.String,System.Reflection.FieldAttributes,System.Byte[],System.Diagnostics.SymbolStore.SymAddressKind,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub DefineField (parent As SymbolToken, name As String, attributes As FieldAttributes, signature As Byte(), addrKind As SymAddressKind, addr1 As Integer, addr2 As Integer, addr3 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DefineField(System::Diagnostics::SymbolStore::SymbolToken parent, System::String ^ name, System::Reflection::FieldAttributes attributes, cli::array &lt;System::Byte&gt; ^ signature, System::Diagnostics::SymbolStore::SymAddressKind addrKind, int addr1, int addr2, int addr3);" />
      <MemberSignature Language="F#" Value="abstract member DefineField : System.Diagnostics.SymbolStore.SymbolToken * string * System.Reflection.FieldAttributes * byte[] * System.Diagnostics.SymbolStore.SymAddressKind * int * int * int -&gt; unit&#xA;override this.DefineField : System.Diagnostics.SymbolStore.SymbolToken * string * System.Reflection.FieldAttributes * byte[] * System.Diagnostics.SymbolStore.SymAddressKind * int * int * int -&gt; unit" Usage="symWriter.DefineField (parent, name, attributes, signature, addrKind, addr1, addr2, addr3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parent" Type="System.Diagnostics.SymbolStore.SymbolToken" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
        <Parameter Name="signature" Type="System.Byte[]" />
        <Parameter Name="addrKind" Type="System.Diagnostics.SymbolStore.SymAddressKind" />
        <Parameter Name="addr1" Type="System.Int32" />
        <Parameter Name="addr2" Type="System.Int32" />
        <Parameter Name="addr3" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="parent">Ten parametr nie jest używany.</param>
        <param name="name">Ten parametr nie jest używany.</param>
        <param name="attributes">Ten parametr nie jest używany.</param>
        <param name="signature">Ten parametr nie jest używany.</param>
        <param name="addrKind">Ten parametr nie jest używany.</param>
        <param name="addr1">Ten parametr nie jest używany.</param>
        <param name="addr2">Ten parametr nie jest używany.</param>
        <param name="addr3">Ten parametr nie jest używany.</param>
        <summary>Zgłasza <see cref="T:System.NotSupportedException" /> we wszystkich przypadkach.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">We wszystkich przypadkach.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineGlobalVariable">
      <MemberSignature Language="C#" Value="public virtual void DefineGlobalVariable (string name, System.Reflection.FieldAttributes attributes, byte[] signature, System.Diagnostics.SymbolStore.SymAddressKind addrKind, int addr1, int addr2, int addr3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DefineGlobalVariable(string name, valuetype System.Reflection.FieldAttributes attributes, unsigned int8[] signature, valuetype System.Diagnostics.SymbolStore.SymAddressKind addrKind, int32 addr1, int32 addr2, int32 addr3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.DefineGlobalVariable(System.String,System.Reflection.FieldAttributes,System.Byte[],System.Diagnostics.SymbolStore.SymAddressKind,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub DefineGlobalVariable (name As String, attributes As FieldAttributes, signature As Byte(), addrKind As SymAddressKind, addr1 As Integer, addr2 As Integer, addr3 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DefineGlobalVariable(System::String ^ name, System::Reflection::FieldAttributes attributes, cli::array &lt;System::Byte&gt; ^ signature, System::Diagnostics::SymbolStore::SymAddressKind addrKind, int addr1, int addr2, int addr3);" />
      <MemberSignature Language="F#" Value="abstract member DefineGlobalVariable : string * System.Reflection.FieldAttributes * byte[] * System.Diagnostics.SymbolStore.SymAddressKind * int * int * int -&gt; unit&#xA;override this.DefineGlobalVariable : string * System.Reflection.FieldAttributes * byte[] * System.Diagnostics.SymbolStore.SymAddressKind * int * int * int -&gt; unit" Usage="symWriter.DefineGlobalVariable (name, attributes, signature, addrKind, addr1, addr2, addr3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
        <Parameter Name="signature" Type="System.Byte[]" />
        <Parameter Name="addrKind" Type="System.Diagnostics.SymbolStore.SymAddressKind" />
        <Parameter Name="addr1" Type="System.Int32" />
        <Parameter Name="addr2" Type="System.Int32" />
        <Parameter Name="addr3" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="name">Ten parametr nie jest używany.</param>
        <param name="attributes">Ten parametr nie jest używany.</param>
        <param name="signature">Ten parametr nie jest używany.</param>
        <param name="addrKind">Ten parametr nie jest używany.</param>
        <param name="addr1">Ten parametr nie jest używany.</param>
        <param name="addr2">Ten parametr nie jest używany.</param>
        <param name="addr3">Ten parametr nie jest używany.</param>
        <summary>Zgłasza <see cref="T:System.NotSupportedException" /> we wszystkich przypadkach.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">We wszystkich przypadkach.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineLocalVariable">
      <MemberSignature Language="C#" Value="public virtual void DefineLocalVariable (string name, System.Reflection.FieldAttributes attributes, byte[] signature, System.Diagnostics.SymbolStore.SymAddressKind addrKind, int addr1, int addr2, int addr3, int startOffset, int endOffset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DefineLocalVariable(string name, valuetype System.Reflection.FieldAttributes attributes, unsigned int8[] signature, valuetype System.Diagnostics.SymbolStore.SymAddressKind addrKind, int32 addr1, int32 addr2, int32 addr3, int32 startOffset, int32 endOffset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.DefineLocalVariable(System.String,System.Reflection.FieldAttributes,System.Byte[],System.Diagnostics.SymbolStore.SymAddressKind,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub DefineLocalVariable (name As String, attributes As FieldAttributes, signature As Byte(), addrKind As SymAddressKind, addr1 As Integer, addr2 As Integer, addr3 As Integer, startOffset As Integer, endOffset As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DefineLocalVariable(System::String ^ name, System::Reflection::FieldAttributes attributes, cli::array &lt;System::Byte&gt; ^ signature, System::Diagnostics::SymbolStore::SymAddressKind addrKind, int addr1, int addr2, int addr3, int startOffset, int endOffset);" />
      <MemberSignature Language="F#" Value="abstract member DefineLocalVariable : string * System.Reflection.FieldAttributes * byte[] * System.Diagnostics.SymbolStore.SymAddressKind * int * int * int * int * int -&gt; unit&#xA;override this.DefineLocalVariable : string * System.Reflection.FieldAttributes * byte[] * System.Diagnostics.SymbolStore.SymAddressKind * int * int * int * int * int -&gt; unit" Usage="symWriter.DefineLocalVariable (name, attributes, signature, addrKind, addr1, addr2, addr3, startOffset, endOffset)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
        <Parameter Name="signature" Type="System.Byte[]" />
        <Parameter Name="addrKind" Type="System.Diagnostics.SymbolStore.SymAddressKind" />
        <Parameter Name="addr1" Type="System.Int32" />
        <Parameter Name="addr2" Type="System.Int32" />
        <Parameter Name="addr3" Type="System.Int32" />
        <Parameter Name="startOffset" Type="System.Int32" />
        <Parameter Name="endOffset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="name">Lokalna nazwa zmiennej.</param>
        <param name="attributes">Lokalne atrybuty zmiennej określony za pomocą <see cref="T:System.Reflection.FieldAttributes" /> modułu wyliczającego.</param>
        <param name="signature">Sygnatura lokalna zmienna.</param>
        <param name="addrKind">Typy adres <c>addr1</c>, <c>addr2</c>, i <c>addr3</c> przy użyciu <see cref="T:System.Diagnostics.SymbolStore.SymAddressKind" />.</param>
        <param name="addr1">Pierwszy adres specyfikacji zmiennych lokalnych.</param>
        <param name="addr2">Drugi adres specyfikacji zmiennych lokalnych.</param>
        <param name="addr3">Trzeci adres specyfikacji zmiennych lokalnych.</param>
        <param name="startOffset">Przesunięcie początku dla zmiennej. Jeśli zero, ten parametr jest ignorowany, a zmienna jest zdefiniowana w całym cały zakres. Jeśli wartość jest niezerowa, znajduje się w ramach przesunięcia bieżącego zakresu.</param>
        <param name="endOffset">Przesunięcie zakończenia dla zmiennej. Jeśli zero, ten parametr jest ignorowany, a zmienna jest zdefiniowana w całym cały zakres. Jeśli wartość jest niezerowa, znajduje się w ramach przesunięcia bieżącego zakresu.</param>
        <summary>Definiuje pojedynczą zmienną w bieżącym zakresie leksykalnym.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `startOffset` i `endOffset` parametry są opcjonalne. Jeśli ich wartość wynosi zero, są ignorowane, a zmienna jest zdefiniowana w całym cały zakres. Jeśli ich wartość jest różna od zera, objęte przesunięcia bieżącego zakresu.  
  
 Możesz wywołać <xref:System.Diagnostics.SymbolStore.SymWriter.DefineLocalVariable%2A> wiele razy dla zmiennej o tej samej nazwie, która powtarza się wielokrotnie w różnych zakresach przesunięcia w całym zakresie. (W tym przypadku przesunięcia rozpoczęcia i zakończenia nie może nakładać.)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefineParameter">
      <MemberSignature Language="C#" Value="public virtual void DefineParameter (string name, System.Reflection.ParameterAttributes attributes, int sequence, System.Diagnostics.SymbolStore.SymAddressKind addrKind, int addr1, int addr2, int addr3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DefineParameter(string name, valuetype System.Reflection.ParameterAttributes attributes, int32 sequence, valuetype System.Diagnostics.SymbolStore.SymAddressKind addrKind, int32 addr1, int32 addr2, int32 addr3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.DefineParameter(System.String,System.Reflection.ParameterAttributes,System.Int32,System.Diagnostics.SymbolStore.SymAddressKind,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub DefineParameter (name As String, attributes As ParameterAttributes, sequence As Integer, addrKind As SymAddressKind, addr1 As Integer, addr2 As Integer, addr3 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DefineParameter(System::String ^ name, System::Reflection::ParameterAttributes attributes, int sequence, System::Diagnostics::SymbolStore::SymAddressKind addrKind, int addr1, int addr2, int addr3);" />
      <MemberSignature Language="F#" Value="abstract member DefineParameter : string * System.Reflection.ParameterAttributes * int * System.Diagnostics.SymbolStore.SymAddressKind * int * int * int -&gt; unit&#xA;override this.DefineParameter : string * System.Reflection.ParameterAttributes * int * System.Diagnostics.SymbolStore.SymAddressKind * int * int * int -&gt; unit" Usage="symWriter.DefineParameter (name, attributes, sequence, addrKind, addr1, addr2, addr3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.ParameterAttributes" />
        <Parameter Name="sequence" Type="System.Int32" />
        <Parameter Name="addrKind" Type="System.Diagnostics.SymbolStore.SymAddressKind" />
        <Parameter Name="addr1" Type="System.Int32" />
        <Parameter Name="addr2" Type="System.Int32" />
        <Parameter Name="addr3" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="name">Ten parametr nie jest używany.</param>
        <param name="attributes">Ten parametr nie jest używany.</param>
        <param name="sequence">Ten parametr nie jest używany.</param>
        <param name="addrKind">Ten parametr nie jest używany.</param>
        <param name="addr1">Ten parametr nie jest używany.</param>
        <param name="addr2">Ten parametr nie jest używany.</param>
        <param name="addr3">Ten parametr nie jest używany.</param>
        <summary>Zgłasza <see cref="T:System.NotSupportedException" /> we wszystkich przypadkach.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">We wszystkich przypadkach.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineSequencePoints">
      <MemberSignature Language="C#" Value="public virtual void DefineSequencePoints (System.Diagnostics.SymbolStore.ISymbolDocumentWriter document, int[] offsets, int[] lines, int[] columns, int[] endLines, int[] endColumns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DefineSequencePoints(class System.Diagnostics.SymbolStore.ISymbolDocumentWriter document, int32[] offsets, int32[] lines, int32[] columns, int32[] endLines, int32[] endColumns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.DefineSequencePoints(System.Diagnostics.SymbolStore.ISymbolDocumentWriter,System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub DefineSequencePoints (document As ISymbolDocumentWriter, offsets As Integer(), lines As Integer(), columns As Integer(), endLines As Integer(), endColumns As Integer())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DefineSequencePoints(System::Diagnostics::SymbolStore::ISymbolDocumentWriter ^ document, cli::array &lt;int&gt; ^ offsets, cli::array &lt;int&gt; ^ lines, cli::array &lt;int&gt; ^ columns, cli::array &lt;int&gt; ^ endLines, cli::array &lt;int&gt; ^ endColumns);" />
      <MemberSignature Language="F#" Value="abstract member DefineSequencePoints : System.Diagnostics.SymbolStore.ISymbolDocumentWriter * int[] * int[] * int[] * int[] * int[] -&gt; unit&#xA;override this.DefineSequencePoints : System.Diagnostics.SymbolStore.ISymbolDocumentWriter * int[] * int[] * int[] * int[] * int[] -&gt; unit" Usage="symWriter.DefineSequencePoints (document, offsets, lines, columns, endLines, endColumns)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="document" Type="System.Diagnostics.SymbolStore.ISymbolDocumentWriter" />
        <Parameter Name="offsets" Type="System.Int32[]" />
        <Parameter Name="lines" Type="System.Int32[]" />
        <Parameter Name="columns" Type="System.Int32[]" />
        <Parameter Name="endLines" Type="System.Int32[]" />
        <Parameter Name="endColumns" Type="System.Int32[]" />
      </Parameters>
      <Docs>
        <param name="document">Obiekt dokumentu, dla której są zdefiniowane punktów sekwencji.</param>
        <param name="offsets">Przesunięcie IL punktów sekwencji, mierzony od początku metody.</param>
        <param name="lines">Linia początkowa liczby punktów sekwencji.</param>
        <param name="columns">Począwszy od liczby kolumn punktów sekwencji.</param>
        <param name="endLines">Końcowy numery wierszy punktów sekwencji.</param>
        <param name="endColumns">Końcowej kolumny liczby punktów sekwencji.</param>
        <summary>Definiuje grupę punktów sekwencji w bieżącej metodzie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Punkty sekwencji są używane do mapowania lokalizacji źródłowych plików i przesunięcia IL.  Każdy punkt sekwencji składa się z IL przesunięcie i źródło pliku, określonego regionu rozpoczęcia i zakończenia wiersza i kolumny liczb względem <xref:System.Diagnostics.SymbolStore.ISymbolDocument> obiektu.  Każdy element w określonym indeksie każda tablica odnosi się do punktu w określonej kolejności. Każdy wiersz, a każda kolumna definiuje rozpoczęcia instrukcji wewnątrz metody. Tablice powinny być sortowane w kolejności rosnącej przesunięcia. Przesunięcie jest zawsze przesunięcie od początku metody, w bajtach.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public override sealed void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="symWriter.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia zasoby używane przez bieżące wystąpienie <see cref="T:System.Diagnostics.SymbolStore.SymWriter" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool A_0);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool A_0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (A_0 As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool A_0);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="symWriter.Dispose A_0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptions</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="A_0" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="A_0">
          <see langword="true" /> Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> aby zwolnić tylko niezarządzane zasoby.</param>
        <summary>Wywoływane przez <see cref="M:System.Diagnostics.SymbolStore.SymWriter.Dispose" /> i <see cref="M:System.Diagnostics.SymbolStore.SymWriter.Finalize" /> metody, aby zwolnić zarządzane i niezarządzane zasoby używane przez bieżące wystąpienie <see cref="T:System.Diagnostics.SymbolStore.SymWriter" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana tylko przez publiczny <xref:System.Diagnostics.SymbolStore.SymWriter.Dispose%2A> i <xref:System.Diagnostics.SymbolStore.SymWriter.Finalize%2A> metod; tej metody nie wywołuje bezpośrednio.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~SymWriter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!SymWriter ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="symWriter.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia zasoby niezarządzane, a następnie wykonuje inne operacje oczyszczania przed <see cref="T:System.Diagnostics.SymbolStore.SymWriter" /> jest odzyskiwane przez wyrzucanie elementów bezużytecznych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zastępuje <xref:System.Object.Finalize%2A>. Kod aplikacji nie powinna wywołać tę metodę; obiekt `Finalize` metoda jest wywoływana automatycznie podczas wyrzucania elementów bezużytecznych, chyba że finalizacja przez moduł garbage collector została wyłączona przez wywołanie <xref:System.GC.SuppressFinalize%2A> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetWriter">
      <MemberSignature Language="C#" Value="public ISymUnmanagedWriter* GetWriter ();" />
      <MemberSignature Language="ILAsm" Value=".method public instance ISymUnmanagedWriter* GetWriter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.GetWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ISymUnmanagedWriter* GetWriter();" />
      <MemberSignature Language="F#" Value="member this.GetWriter : unit -&gt; nativeptr&lt;ISymUnmanagedWriter&gt;" Usage="symWriter.GetWriter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>ISymUnmanagedWriter*</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Initialize">
      <MemberSignature Language="C#" Value="public virtual void Initialize (IntPtr emitter, string filename, bool fFullBuild);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Initialize(native int emitter, string filename, bool fFullBuild) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.Initialize(System.IntPtr,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Initialize (emitter As IntPtr, filename As String, fFullBuild As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Initialize(IntPtr emitter, System::String ^ filename, bool fFullBuild);" />
      <MemberSignature Language="F#" Value="abstract member Initialize : nativeint * string * bool -&gt; unit&#xA;override this.Initialize : nativeint * string * bool -&gt; unit" Usage="symWriter.Initialize (emitter, filename, fFullBuild)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="emitter" Type="System.IntPtr" />
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="fFullBuild" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="emitter">Interfejs nadajnika metadanych.</param>
        <param name="filename">Nazwa pliku, dla której symbole debugowania są zapisywane. Niektóre moduły zapisujące wymagają nazwę pliku, podczas gdy inne nie. Jeśli nazwa pliku jest określony dla modułu zapisującego, która nie korzysta z nazw plików, ten parametr jest ignorowany.</param>
        <param name="fFullBuild">
          <see langword="true" /> Wskazuje, że jest to ponownej pełnej kompilacji; <see langword="false" /> wskazuje kompilacji przyrostowej.</param>
        <summary>Ustawia interfejs nadajnika metadanych do skojarzenia z tym składnika zapisywania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.SymbolStore.ISymbolWriter.Initialize%2A> Ustawia również nazwę pliku wyjściowego gdzie symbole debugowania są zapisywane. Ta metoda może być wywołana tylko raz i musi zostać wywołana przed wywołaniem innych metod składnika zapisywania są.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać możliwość dostępu do kodu niezarządzanego.</permission>
      </Docs>
    </Member>
    <Member MemberName="InitWriter">
      <MemberSignature Language="C#" Value="public void InitWriter (bool noUnderlyingWriter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InitWriter(bool noUnderlyingWriter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.InitWriter(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InitWriter (noUnderlyingWriter As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InitWriter(bool noUnderlyingWriter);" />
      <MemberSignature Language="F#" Value="member this.InitWriter : bool -&gt; unit" Usage="symWriter.InitWriter noUnderlyingWriter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="noUnderlyingWriter" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="noUnderlyingWriter">
          <see langword="true" /> Jeśli podstawowy zapisywania symbol będzie świadczona przez wywołanie metody <see cref="M:System.Diagnostics.SymbolStore.SymWriter.SetUnderlyingWriter(System.IntPtr)" /> metody. <see langword="false" /> Jeśli zamiast tego powinien zostać utworzony domyślny podstawowy moduł zapisujący symboli.</param>
        <summary>Inicjuje składnik zapisywania symbolu. Ta metoda nie należy wywoływać bezpośrednio; jest ona wywoływana przez konstruktora.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać możliwość dostępu do kodu niezarządzanego.</permission>
      </Docs>
    </Member>
    <Member MemberName="OpenMethod">
      <MemberSignature Language="C#" Value="public virtual void OpenMethod (System.Diagnostics.SymbolStore.SymbolToken method);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OpenMethod(valuetype System.Diagnostics.SymbolStore.SymbolToken method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.OpenMethod(System.Diagnostics.SymbolStore.SymbolToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub OpenMethod (method As SymbolToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void OpenMethod(System::Diagnostics::SymbolStore::SymbolToken method);" />
      <MemberSignature Language="F#" Value="abstract member OpenMethod : System.Diagnostics.SymbolStore.SymbolToken -&gt; unit&#xA;override this.OpenMethod : System.Diagnostics.SymbolStore.SymbolToken -&gt; unit" Usage="symWriter.OpenMethod method" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Diagnostics.SymbolStore.SymbolToken" />
      </Parameters>
      <Docs>
        <param name="method">Token metadanych dla metody, które ma zostać otwarty.</param>
        <summary>Zostanie otwarty metody, w której chcesz umieścić informacje o symbolach.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Określona metoda staje się bieżącą metodę dla wywołań do definiowania punktów sekwencji, parametry i zakresy leksykalne. Istnieje niejawna zakresie leksykalnym, wokół całej metody. Zamknij metodę, która została wcześniej zamknięta usuwa wszystkie uprzednio zdefiniowany symbole dla metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OpenNamespace">
      <MemberSignature Language="C#" Value="public virtual void OpenNamespace (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OpenNamespace(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.OpenNamespace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub OpenNamespace (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void OpenNamespace(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member OpenNamespace : string -&gt; unit&#xA;override this.OpenNamespace : string -&gt; unit" Usage="symWriter.OpenNamespace name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa nowej przestrzeni nazw.</param>
        <summary>Zostanie otwarty nowy obszar nazw.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tę metodę należy wywołać przed zdefiniowaniem metody lub zmienne, które istnieją w przestrzeni nazw. Przestrzenie nazw mogą być zagnieżdżone.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OpenScope">
      <MemberSignature Language="C#" Value="public virtual int OpenScope (int startOffset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 OpenScope(int32 startOffset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.OpenScope(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function OpenScope (startOffset As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int OpenScope(int startOffset);" />
      <MemberSignature Language="F#" Value="abstract member OpenScope : int -&gt; int&#xA;override this.OpenScope : int -&gt; int" Usage="symWriter.OpenScope startOffset" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startOffset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startOffset">Przesunięcie IL w bajtach od początku metody do pierwszej instrukcji w zakresie leksykalnym.</param>
        <summary>Zostanie otwarty nowy zakres leksykalne w bieżącej metodzie.</summary>
        <returns>Identyfikator nieprzezroczysty zakres, który może być używany z <see cref="M:System.Diagnostics.SymbolStore.SymWriter.SetScopeRange(System.Int32,System.Int32,System.Int32)" /> do definiowania przesunięcia początkową i końcową zakresu w późniejszym czasie. W tym przypadku przesunięcia przekazany do <see cref="M:System.Diagnostics.SymbolStore.SymWriter.OpenScope(System.Int32)" /> i <see cref="M:System.Diagnostics.SymbolStore.SymWriter.CloseScope(System.Int32)" /> są ignorowane. Identyfikator zakresu jest prawidłowy tylko w bieżącej metodzie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten zakres staje się nowy zakres bieżący i są wypychane na stosie zakresów. Zakresy należy tworzą hierarchię. Elementy równorzędne są niedozwolone nakładają się na siebie.  
  
 Zakres identyfikatorów są prawidłowe tylko w bieżącej metodzie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetMethodSourceRange">
      <MemberSignature Language="C#" Value="public virtual void SetMethodSourceRange (System.Diagnostics.SymbolStore.ISymbolDocumentWriter startDoc, int startLine, int startColumn, System.Diagnostics.SymbolStore.ISymbolDocumentWriter endDoc, int endLine, int endColumn);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetMethodSourceRange(class System.Diagnostics.SymbolStore.ISymbolDocumentWriter startDoc, int32 startLine, int32 startColumn, class System.Diagnostics.SymbolStore.ISymbolDocumentWriter endDoc, int32 endLine, int32 endColumn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.SetMethodSourceRange(System.Diagnostics.SymbolStore.ISymbolDocumentWriter,System.Int32,System.Int32,System.Diagnostics.SymbolStore.ISymbolDocumentWriter,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetMethodSourceRange (startDoc As ISymbolDocumentWriter, startLine As Integer, startColumn As Integer, endDoc As ISymbolDocumentWriter, endLine As Integer, endColumn As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetMethodSourceRange(System::Diagnostics::SymbolStore::ISymbolDocumentWriter ^ startDoc, int startLine, int startColumn, System::Diagnostics::SymbolStore::ISymbolDocumentWriter ^ endDoc, int endLine, int endColumn);" />
      <MemberSignature Language="F#" Value="abstract member SetMethodSourceRange : System.Diagnostics.SymbolStore.ISymbolDocumentWriter * int * int * System.Diagnostics.SymbolStore.ISymbolDocumentWriter * int * int -&gt; unit&#xA;override this.SetMethodSourceRange : System.Diagnostics.SymbolStore.ISymbolDocumentWriter * int * int * System.Diagnostics.SymbolStore.ISymbolDocumentWriter * int * int -&gt; unit" Usage="symWriter.SetMethodSourceRange (startDoc, startLine, startColumn, endDoc, endLine, endColumn)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startDoc" Type="System.Diagnostics.SymbolStore.ISymbolDocumentWriter" />
        <Parameter Name="startLine" Type="System.Int32" />
        <Parameter Name="startColumn" Type="System.Int32" />
        <Parameter Name="endDoc" Type="System.Diagnostics.SymbolStore.ISymbolDocumentWriter" />
        <Parameter Name="endLine" Type="System.Int32" />
        <Parameter Name="endColumn" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startDoc">Ten parametr nie jest używany.</param>
        <param name="startLine">Ten parametr nie jest używany.</param>
        <param name="startColumn">Ten parametr nie jest używany.</param>
        <param name="endDoc">Ten parametr nie jest używany.</param>
        <param name="endLine">Ten parametr nie jest używany.</param>
        <param name="endColumn">Ten parametr nie jest używany.</param>
        <summary>Zgłasza <see cref="T:System.NotSupportedException" /> we wszystkich przypadkach.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">We wszystkich przypadkach.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetScopeRange">
      <MemberSignature Language="C#" Value="public virtual void SetScopeRange (int scopeID, int startOffset, int endOffset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetScopeRange(int32 scopeID, int32 startOffset, int32 endOffset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.SetScopeRange(System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetScopeRange (scopeID As Integer, startOffset As Integer, endOffset As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetScopeRange(int scopeID, int startOffset, int endOffset);" />
      <MemberSignature Language="F#" Value="abstract member SetScopeRange : int * int * int -&gt; unit&#xA;override this.SetScopeRange : int * int * int -&gt; unit" Usage="symWriter.SetScopeRange (scopeID, startOffset, endOffset)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scopeID" Type="System.Int32" />
        <Parameter Name="startOffset" Type="System.Int32" />
        <Parameter Name="endOffset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="scopeID">Identyfikator zakresie leksykalnym zwrócone przez <see cref="M:System.Diagnostics.SymbolStore.SymWriter.OpenScope(System.Int32)" /> metody.</param>
        <param name="startOffset">Przesunięcie IL początku zakresie leksykalnym.</param>
        <param name="endOffset">Przesunięcie IL do końca zakresie leksykalnym.</param>
        <summary>Definiuje zakres przesunięcia dla określonego zakresu leksykalne.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSymAttribute">
      <MemberSignature Language="C#" Value="public virtual void SetSymAttribute (System.Diagnostics.SymbolStore.SymbolToken parent, string name, byte[] data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetSymAttribute(valuetype System.Diagnostics.SymbolStore.SymbolToken parent, string name, unsigned int8[] data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.SetSymAttribute(System.Diagnostics.SymbolStore.SymbolToken,System.String,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetSymAttribute (parent As SymbolToken, name As String, data As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetSymAttribute(System::Diagnostics::SymbolStore::SymbolToken parent, System::String ^ name, cli::array &lt;System::Byte&gt; ^ data);" />
      <MemberSignature Language="F#" Value="abstract member SetSymAttribute : System.Diagnostics.SymbolStore.SymbolToken * string * byte[] -&gt; unit&#xA;override this.SetSymAttribute : System.Diagnostics.SymbolStore.SymbolToken * string * byte[] -&gt; unit" Usage="symWriter.SetSymAttribute (parent, name, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parent" Type="System.Diagnostics.SymbolStore.SymbolToken" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="parent">Token metadanych, dla którego jest definiowany atrybut.</param>
        <param name="name">Nazwa atrybutu.</param>
        <param name="data">Wartość atrybutu.</param>
        <summary>Definiuje atrybut, jeśli podana nazwa atrybutu i wartością atrybutu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.SymbolStore.SymWriter.SetSymAttribute%2A> Metoda jest tylko skojarzone z informacji o symbolach, a nie jest atrybutem niestandardowym metadanych.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetUnderlyingWriter">
      <MemberSignature Language="C#" Value="public virtual void SetUnderlyingWriter (IntPtr underlyingWriter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetUnderlyingWriter(native int underlyingWriter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.SetUnderlyingWriter(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetUnderlyingWriter (underlyingWriter As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetUnderlyingWriter(IntPtr underlyingWriter);" />
      <MemberSignature Language="F#" Value="abstract member SetUnderlyingWriter : nativeint -&gt; unit&#xA;override this.SetUnderlyingWriter : nativeint -&gt; unit" Usage="symWriter.SetUnderlyingWriter underlyingWriter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="underlyingWriter" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="underlyingWriter">
          <see cref="T:System.IntPtr" /> Typ wskaźnika do kodu, który jest podstawowym składnika zapisywania.</param>
        <summary>Ustawia bazowego [Interface](~/docs/framework/unmanaged-api/diagnostics/isymunmanagedwriter-interface.md) isymunmanagedwriter — (odpowiadającym niezarządzanym interfejsu API), to zarządzana <see cref="T:System.Diagnostics.SymbolStore.SymWriter" /> używa, aby emitować symbole.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podstawowe [isymunmanagedwriter — interfejs](~/docs/framework/unmanaged-api/diagnostics/isymunmanagedwriter-interface.md) (odpowiadającym niezarządzanym interfejsu API) interfejs reprezentuje edytor symboli dla kodu zarządzanego. Interfejs dostarcza metody do definiowania dokumentów, punktów sekwencji, leksykalne zakresy i zmienne.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać możliwość dostępu do kodu niezarządzanego.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetUserEntryPoint">
      <MemberSignature Language="C#" Value="public virtual void SetUserEntryPoint (System.Diagnostics.SymbolStore.SymbolToken entryMethod);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetUserEntryPoint(valuetype System.Diagnostics.SymbolStore.SymbolToken entryMethod) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.SetUserEntryPoint(System.Diagnostics.SymbolStore.SymbolToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetUserEntryPoint (entryMethod As SymbolToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetUserEntryPoint(System::Diagnostics::SymbolStore::SymbolToken entryMethod);" />
      <MemberSignature Language="F#" Value="abstract member SetUserEntryPoint : System.Diagnostics.SymbolStore.SymbolToken -&gt; unit&#xA;override this.SetUserEntryPoint : System.Diagnostics.SymbolStore.SymbolToken -&gt; unit" Usage="symWriter.SetUserEntryPoint entryMethod" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entryMethod" Type="System.Diagnostics.SymbolStore.SymbolToken" />
      </Parameters>
      <Docs>
        <param name="entryMethod">Token metadanych dla metody, która jest wpis użytkownika punktu.</param>
        <summary>Określa metody zdefiniowane przez użytkownika jako punkt wejścia dla bieżącego modułu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwykle jest to metoda główna.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UsingNamespace">
      <MemberSignature Language="C#" Value="public virtual void UsingNamespace (string fullName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UsingNamespace(string fullName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.SymbolStore.SymWriter.UsingNamespace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub UsingNamespace (fullName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void UsingNamespace(System::String ^ fullName);" />
      <MemberSignature Language="F#" Value="abstract member UsingNamespace : string -&gt; unit&#xA;override this.UsingNamespace : string -&gt; unit" Usage="symWriter.UsingNamespace fullName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>ISymWrapper</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fullName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fullName">W pełni kwalifikowaną nazwę przestrzeni nazw.</param>
        <summary>Określa, że nazwa danego, w pełni kwalifikowaną przestrzeń nazw jest używana w zakresie leksykalnym open.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zamyka bieżący zakres zapobiega ten zakres przy użyciu przestrzeni nazw. Przestrzeń nazw będzie używane we wszystkich zakresach, które dziedziczą z bieżącego zakresu open.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
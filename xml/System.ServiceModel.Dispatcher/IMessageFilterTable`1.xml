<Type Name="IMessageFilterTable&lt;TFilterData&gt;" FullName="System.ServiceModel.Dispatcher.IMessageFilterTable&lt;TFilterData&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="5de1ac8e527bd7e9cac660cabdd00581bedca2b6" />
    <Meta Name="ms.sourcegitcommit" Value="01f28caab7b3f23878dd07b402a8dd48b9478c8c" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="07/19/2018" />
    <Meta Name="ms.locfileid" Value="39139941" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface IMessageFilterTable&lt;TFilterData&gt; : System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter,TFilterData&gt;&gt;, System.Collections.Generic.IDictionary&lt;System.ServiceModel.Dispatcher.MessageFilter,TFilterData&gt;, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter,TFilterData&gt;&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IMessageFilterTable`1&lt;TFilterData&gt; implements class System.Collections.Generic.ICollection`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;class System.ServiceModel.Dispatcher.MessageFilter, !TFilterData&gt;&gt;, class System.Collections.Generic.IDictionary`2&lt;class System.ServiceModel.Dispatcher.MessageFilter, !TFilterData&gt;, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;class System.ServiceModel.Dispatcher.MessageFilter, !TFilterData&gt;&gt;, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.Dispatcher.IMessageFilterTable`1" />
  <TypeSignature Language="VB.NET" Value="Public Interface IMessageFilterTable(Of TFilterData)&#xA;Implements ICollection(Of KeyValuePair(Of MessageFilter, TFilterData)), IDictionary(Of MessageFilter, TFilterData), IEnumerable(Of KeyValuePair(Of MessageFilter, TFilterData))" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TFilterData&gt;&#xA;public interface class IMessageFilterTable : System::Collections::Generic::ICollection&lt;System::Collections::Generic::KeyValuePair&lt;System::ServiceModel::Dispatcher::MessageFilter ^, TFilterData&gt;&gt;, System::Collections::Generic::IDictionary&lt;System::ServiceModel::Dispatcher::MessageFilter ^, TFilterData&gt;, System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::ServiceModel::Dispatcher::MessageFilter ^, TFilterData&gt;&gt;" />
  <TypeSignature Language="F#" Value="type IMessageFilterTable&lt;'FilterData&gt; = interface&#xA;    interface IDictionary&lt;MessageFilter, 'FilterData&gt;&#xA;    interface ICollection&lt;KeyValuePair&lt;MessageFilter, 'FilterData&gt;&gt;&#xA;    interface seq&lt;KeyValuePair&lt;MessageFilter, 'FilterData&gt;&gt;&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TFilterData" />
  </TypeParameters>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter,TFilterData&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IDictionary&lt;System.ServiceModel.Dispatcher.MessageFilter,TFilterData&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter,TFilterData&gt;&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <typeparam name="TFilterData">Typ danych skojarzonych z każdym filtrem w tabeli.</typeparam>
    <summary>
      <see langword="interface" /> Definiuje kontrakt, który muszą implementować tabelę filtru, aby sprawdzić komunikaty o kryteriach kwerendy pochodzące z co najmniej jeden filtr.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tabela filtru jest podstawowym składnikiem aparatu filtru. Jest podstawowym zastosowaniem filtru aparatu w Windows Communication Foundation (WCF) odpowiadający aplikacji logiki do wiadomości, wyszukując wszystkie filtry, które spełniają wiadomość.  
  
 Tabelę filtru pozwala używać wielu filtrów można dopasować względem pojedynczej wiadomości efektywniej niż oddzielnie dopasowane. Tabela Filtr kojarzy filtrowanie danych za pomocą filtrów. Tabela jest kolekcją par klucz wartość, gdy klucz jest <xref:System.ServiceModel.Dispatcher.MessageFilter>, a jego wartość to danych skojarzony filtr. Filtrowanie danych może być żadnych danych tego typu określonego w parametrze ogólny i może służyć do określenia, jakie działania należy podjąć, jeśli komunikat jest dopasowywany przez filtr w tabeli.  
  
 Filtr wpisów tabeli można uzyskać dostęp za pomocą <xref:System.Collections.Generic.IDictionary%602> funkcjonalność, <xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601> dziedziczy.  
  
 Należy zauważyć, że wystąpienie filtru można dodać tylko do danego <xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601> po. Aby dodać wiele wystąpień tego filtru do tej samej tabeli filtru, umożliwia utworzenie dodatkowych wystąpień Konstruktor filtrów.  
  
 Kryteria filtru komunikat, gdy komunikat nie będzie spełniał kryteriów zapytania filtru. Istnieją cztery przeciążone metody dopasowania. Dane zwracane są dane filtru lub <xref:System.ServiceModel.Dispatcher.MessageFilter> same obiekty. To dane są zwracane, czy są dozwolone wiele dopasowań lub odpowiada tylko jeden. W poniższej tabeli przedstawiono te informacje dotyczące poszczególnych przeciążeń.  
  
|Nazwa metody|Dopasowania|Dane zwrócone|  
|-----------------|-------------|-------------------|  
|<xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601.GetMatchingValue%2A>|Single|`FilterData`|  
|<xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601.GetMatchingFilter%2A>|Single|<xref:System.ServiceModel.Dispatcher.MessageFilter>|  
|<xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601.GetMatchingValues%2A>|Wielokrotne|`FilterData`|  
|<xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601.GetMatchingFilters%2A>|Wielokrotne|<xref:System.ServiceModel.Dispatcher.MessageFilter> Obiekty|  
  
 Każda metoda zawiera dwa przeciążenia. Różnica między dwa przeciążenia jest jedno wykorzystuje <xref:System.ServiceModel.Channels.Message> parametru i sprawdź zawartość treści; nie jest dozwolone drugie <xref:System.ServiceModel.Channels.MessageBuffer> parametru i zbadać dowolnej części wiadomości. Jeśli wywołanie metody z parametrem wiadomości, a tabela filtr zawiera filtr, który sprawdza, czy zawartość treści wiadomości, jest zgłaszany wyjątek. Jeśli wiesz, informacje o filtrach w tabeli, wywołanie przeciążenia, które przyjmuje buforu komunikatu.  
  
 Nagłówki komunikatów są automatycznie buforowane i mogą być kontrolowane przez filtr nie są używane. Zniszczone, ale jeśli jednostka ma być kontrolowane przez filtr, a następnie cały komunikat musi być buforowane, ponieważ treść komunikatu Niebuforowane jest wykorzystywana przez zapytanie i jego zawartość.  
  
 Następujące klasy implementacji <xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601>:  
  
-   <xref:System.ServiceModel.Dispatcher.MessageFilterTable%601>  
  
-   <xref:System.ServiceModel.Dispatcher.XPathMessageFilterTable%601>  
  
 ]]></format>
    </remarks>
    <threadsafe>Filtr tabele są wątkowo względem dopasowania działań, ale są nie metodą o bezpiecznych wątkach w odniesieniu do modyfikacji. Wątki, uzyskania dostępu do tabeli filtru, które mają być synchronizowane przez <see cref="T:System.Threading.ReaderWriterLock" /> lub podobne blokowania semantycznego. Ta blokada pozwala wielu odczytów filtru tabeli (na przykład operacja dopasowania) do jednoczesnego uruchamiania, ale aby można było zapisywać do filtru tabeli (np. dodanie filtru), wątek musi czekać blokady na wyłączność.  Wszystkie kompilacji odbywa się po dodaniu filtrów do tabeli. Jeśli wcześniej utworzyć tabelę filtru i nigdy nie można go edytować, blokowanie nie jest wymagane podczas dopasowania.</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName="GetMatchingFilter">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca wartość filtru z tabeli, w której kryteria zapytania są spełnione przez określony komunikat, czy buforowanego wiadomości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda ta jest używana, gdy jeden filtr będzie zgodny komunikat, ale zgodne z filtrem jest wymagana.  
  
 Użyj <xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601.GetMatchingFilter%2A> Jeśli treść nie wymaga zbadania. Użyj <xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601.GetMatchingFilter%2A> Jeśli zawartość treść komunikatu może wymagać badania.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Jeśli więcej niż jeden filtr dopasowuje wartość do wiadomości, <see cref="T:System.ServiceModel.Dispatcher.MultipleFilterMatchesException" /> musi być zgłaszany.</para>
        </block>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMatchingFilter">
      <MemberSignature Language="C#" Value="public bool GetMatchingFilter (System.ServiceModel.Channels.Message message, out System.ServiceModel.Dispatcher.MessageFilter filter);" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GetMatchingFilter(class System.ServiceModel.Channels.Message message, [out] class System.ServiceModel.Dispatcher.MessageFilter&amp; filter) cil managed" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetMatchingFilter(System::ServiceModel::Channels::Message ^ message, [Runtime::InteropServices::Out] System::ServiceModel::Dispatcher::MessageFilter ^ % filter);" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C#" Value="public bool GetMatchingFilter (System.ServiceModel.Channels.Message message, out System.ServiceModel.Dispatcher.MessageFilter result);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GetMatchingFilter(class System.ServiceModel.Channels.Message message, [out] class System.ServiceModel.Dispatcher.MessageFilter&amp; result) cil managed" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.IMessageFilterTable`1.GetMatchingFilter(System.ServiceModel.Channels.Message,System.ServiceModel.Dispatcher.MessageFilter@)" FrameworkAlternate="xamarinmac-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetMatchingFilter(System::ServiceModel::Channels::Message ^ message, [Runtime::InteropServices::Out] System::ServiceModel::Dispatcher::MessageFilter ^ % result);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetMatchingFilter : System.ServiceModel.Channels.Message *  -&gt; bool" Usage="iMessageFilterTable.GetMatchingFilter (message, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.ServiceModel.Channels.Message" Index="0" />
        <Parameter Name="filter" Type="System.ServiceModel.Dispatcher.MessageFilter&amp;" RefType="out" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="result" Type="System.ServiceModel.Dispatcher.MessageFilter&amp;" RefType="out" Index="1" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="message">
          <see cref="T:System.ServiceModel.Channels.Message" /> Do testowania.</param>
        <param name="filter">
          <see langword="out" /> parametr, który przechowuje filtr, który jest spełniony, <c>komunikat</c>. Jeśli nie znaleziono filtru, parametr ma wartość do wartości domyślnej.</param>
        <param name="result">
          <see langword="out" /> parametr, który przechowuje filtr, który jest spełniony, <c>komunikat</c>. Jeśli nie znaleziono filtru, parametr ma wartość do wartości domyślnej.</param>
        <summary>Zwraca wartość wskazującą, czy są spełnione przez określony komunikat kryterium dopasowywania dokładnie jeden filtr w tabeli i zwraca z filtrem w <see langword="out" /> parametru.</summary>
        <returns>
          <see langword="true" /> Jeśli kryterium dopasowywania, co najmniej jeden filtr w tabeli określony przez <paramref name="message" />; <see langword="false" /> Jeśli filtr nie zostanie spełniony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda ta jest używana, gdy jeden filtr będzie zgodny komunikat, ale zgodne z filtrem jest wymagana.  
  
 Jeśli treść wiadomości muszą być kontrolowane przez filtr w tabeli filtru, użyj <xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601.GetMatchingFilter%2A> wersji metody.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Jeśli więcej niż jeden filtr dopasowuje wartość do wiadomości, <see cref="T:System.ServiceModel.Dispatcher.MultipleFilterMatchesException" /> musi być zgłaszany.  Ta wersja ma <see cref="T:System.ServiceModel.Channels.Message" /> i musi zgłosić <see cref="T:System.ServiceModel.Dispatcher.InvalidBodyAccessException" /> przypadku próby Sprawdź treść komunikatu.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetMatchingFilter">
      <MemberSignature Language="C#" Value="public bool GetMatchingFilter (System.ServiceModel.Channels.MessageBuffer messageBuffer, out System.ServiceModel.Dispatcher.MessageFilter filter);" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GetMatchingFilter(class System.ServiceModel.Channels.MessageBuffer messageBuffer, [out] class System.ServiceModel.Dispatcher.MessageFilter&amp; filter) cil managed" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetMatchingFilter(System::ServiceModel::Channels::MessageBuffer ^ messageBuffer, [Runtime::InteropServices::Out] System::ServiceModel::Dispatcher::MessageFilter ^ % filter);" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C#" Value="public bool GetMatchingFilter (System.ServiceModel.Channels.MessageBuffer buffer, out System.ServiceModel.Dispatcher.MessageFilter result);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GetMatchingFilter(class System.ServiceModel.Channels.MessageBuffer buffer, [out] class System.ServiceModel.Dispatcher.MessageFilter&amp; result) cil managed" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.IMessageFilterTable`1.GetMatchingFilter(System.ServiceModel.Channels.MessageBuffer,System.ServiceModel.Dispatcher.MessageFilter@)" FrameworkAlternate="xamarinmac-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMatchingFilter (buffer As MessageBuffer, ByRef result As MessageFilter) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetMatchingFilter(System::ServiceModel::Channels::MessageBuffer ^ buffer, [Runtime::InteropServices::Out] System::ServiceModel::Dispatcher::MessageFilter ^ % result);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetMatchingFilter : System.ServiceModel.Channels.MessageBuffer *  -&gt; bool" Usage="iMessageFilterTable.GetMatchingFilter (buffer, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="messageBuffer" Type="System.ServiceModel.Channels.MessageBuffer" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="buffer" Type="System.ServiceModel.Channels.MessageBuffer" Index="0" FrameworkAlternate="xamarinmac-3.0" />
        <Parameter Name="filter" Type="System.ServiceModel.Dispatcher.MessageFilter&amp;" RefType="out" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="result" Type="System.ServiceModel.Dispatcher.MessageFilter&amp;" RefType="out" Index="1" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="messageBuffer">
          <see cref="T:System.ServiceModel.Channels.MessageBuffer" /> Do testowania.</param>
        <param name="buffer">
          <see cref="T:System.ServiceModel.Channels.MessageBuffer" /> Do testowania.</param>
        <param name="filter">
          <see langword="out" /> parametr, który przechowuje filtr, który jest spełniony, <c>komunikat</c>. Jeśli nie znaleziono filtru, parametr ma wartość do wartości domyślnej.</param>
        <param name="result">
          <see langword="out" /> parametr, który przechowuje filtr, który jest spełniony, <c>komunikat</c>. Jeśli nie znaleziono filtru, parametr ma wartość do wartości domyślnej.</param>
        <summary>Zwraca wartość wskazującą, czy określony komunikat lub buforowanego komunikat i zwraca wartość, które filtrują w spełnieniu kryterium dopasowywania dokładnie jeden filtr tabeli <see langword="out" /> parametru.</summary>
        <returns>
          <see langword="true" /> Jeśli kryterium dopasowywania, co najmniej jeden filtr w tabeli określony przez <paramref name="messageBuffer" />; <see langword="false" /> Jeśli filtr nie zostanie spełniony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest jeden filtr oczekuje się, aby dopasować buforowanych wiadomości, zgodne z filtrem, należy ponownie, gdy treść komunikatu może mieć kontrolę.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMatchingFilters">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dodaje filtry, których kryteria kwerendy są spełnione przez określony komunikat, czy buforowanego wiadomości do kolekcji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj jednej z następujących metod, gdy więcej niż jeden filtr będzie zgodny komunikat, ale pasujące filtry są wymagane. Należy pamiętać, kolekcję, która zawiera filtry nie jest czyszczony przed wyniki zostaną dodane. Pozwala na gromadzenie wszystkie dopasowania dla wielu filtrów tabel w jedną kolekcję.  
  
 Jeśli treść wiadomości muszą być kontrolowane przez filtr w tabeli filtru, buffer, wiadomości i przekazać ją do <xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601.GetMatchingFilters%2A> metody. W przeciwnym razie użyj <xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601.GetMatchingFilters%2A>.  
  
 Dopasowanie <xref:System.ServiceModel.Dispatcher.MessageFilter> obiekty są przechowywane w `results` parametru. Filtr, następnie można odzyskać dane z tabeli filtr, za pomocą tych filtrów, jako klucze przy użyciu metod dostarczonych przez <xref:System.Collections.Generic.IDictionary%602>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMatchingFilters">
      <MemberSignature Language="C#" Value="public bool GetMatchingFilters (System.ServiceModel.Channels.Message message, System.Collections.Generic.ICollection&lt;System.ServiceModel.Dispatcher.MessageFilter&gt; results);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GetMatchingFilters(class System.ServiceModel.Channels.Message message, class System.Collections.Generic.ICollection`1&lt;class System.ServiceModel.Dispatcher.MessageFilter&gt; results) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.IMessageFilterTable`1.GetMatchingFilters(System.ServiceModel.Channels.Message,System.Collections.Generic.ICollection{System.ServiceModel.Dispatcher.MessageFilter})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetMatchingFilters(System::ServiceModel::Channels::Message ^ message, System::Collections::Generic::ICollection&lt;System::ServiceModel::Dispatcher::MessageFilter ^&gt; ^ results);" />
      <MemberSignature Language="F#" Value="abstract member GetMatchingFilters : System.ServiceModel.Channels.Message * System.Collections.Generic.ICollection&lt;System.ServiceModel.Dispatcher.MessageFilter&gt; -&gt; bool" Usage="iMessageFilterTable.GetMatchingFilters (message, results)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.ServiceModel.Channels.Message" />
        <Parameter Name="results" Type="System.Collections.Generic.ICollection&lt;System.ServiceModel.Dispatcher.MessageFilter&gt;" />
      </Parameters>
      <Docs>
        <param name="message">
          <see cref="T:System.ServiceModel.Channels.Message" /> Do testowania.</param>
        <param name="results">Parametr odwołania, która przechowuje <see cref="T:System.ServiceModel.Dispatcher.MessageFilter" /> obiektami spełniającymi podane w <see cref="T:System.Collections.Generic.ICollection`1" /> &lt;filtru&gt;.</param>
        <summary>Zwraca wartość wskazującą, czy są spełnione przez określony komunikat kryterium filtru w tabeli, a pasujące filtry są dodawane do kolekcji.</summary>
        <returns>
          <see langword="true" /> Jeśli kryterium dopasowywania, co najmniej jeden filtr w tabeli określony przez <paramref name="message" />; <see langword="false" /> Jeśli filtr nie zostanie spełniony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody do dopasowania komunikatu oczekuje się, gdy więcej niż jeden filtr, pasujące filtry są wymagane i treść komunikatu nie będzie musiał być kontrolowane.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ta wersja ma <see cref="T:System.ServiceModel.Channels.Message" /> i musi zgłosić <see cref="T:System.ServiceModel.Dispatcher.InvalidBodyAccessException" /> przypadku próby Sprawdź treść komunikatu.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetMatchingFilters">
      <MemberSignature Language="C#" Value="public bool GetMatchingFilters (System.ServiceModel.Channels.MessageBuffer messageBuffer, System.Collections.Generic.ICollection&lt;System.ServiceModel.Dispatcher.MessageFilter&gt; results);" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GetMatchingFilters(class System.ServiceModel.Channels.MessageBuffer messageBuffer, class System.Collections.Generic.ICollection`1&lt;class System.ServiceModel.Dispatcher.MessageFilter&gt; results) cil managed" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetMatchingFilters(System::ServiceModel::Channels::MessageBuffer ^ messageBuffer, System::Collections::Generic::ICollection&lt;System::ServiceModel::Dispatcher::MessageFilter ^&gt; ^ results);" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C#" Value="public bool GetMatchingFilters (System.ServiceModel.Channels.MessageBuffer buffer, System.Collections.Generic.ICollection&lt;System.ServiceModel.Dispatcher.MessageFilter&gt; results);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GetMatchingFilters(class System.ServiceModel.Channels.MessageBuffer buffer, class System.Collections.Generic.ICollection`1&lt;class System.ServiceModel.Dispatcher.MessageFilter&gt; results) cil managed" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.IMessageFilterTable`1.GetMatchingFilters(System.ServiceModel.Channels.MessageBuffer,System.Collections.Generic.ICollection{System.ServiceModel.Dispatcher.MessageFilter})" FrameworkAlternate="xamarinmac-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMatchingFilters (buffer As MessageBuffer, results As ICollection(Of MessageFilter)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetMatchingFilters(System::ServiceModel::Channels::MessageBuffer ^ buffer, System::Collections::Generic::ICollection&lt;System::ServiceModel::Dispatcher::MessageFilter ^&gt; ^ results);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetMatchingFilters : System.ServiceModel.Channels.MessageBuffer * System.Collections.Generic.ICollection&lt;System.ServiceModel.Dispatcher.MessageFilter&gt; -&gt; bool" Usage="iMessageFilterTable.GetMatchingFilters (buffer, results)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="messageBuffer" Type="System.ServiceModel.Channels.MessageBuffer" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="buffer" Type="System.ServiceModel.Channels.MessageBuffer" Index="0" FrameworkAlternate="xamarinmac-3.0" />
        <Parameter Name="results" Type="System.Collections.Generic.ICollection&lt;System.ServiceModel.Dispatcher.MessageFilter&gt;" Index="1" />
      </Parameters>
      <Docs>
        <param name="messageBuffer">
          <see cref="T:System.ServiceModel.Channels.MessageBuffer" /> Do testowania.</param>
        <param name="buffer">
          <see cref="T:System.ServiceModel.Channels.MessageBuffer" /> Do testowania.</param>
        <param name="results">Parametr odwołania, która przechowuje <see cref="T:System.ServiceModel.Dispatcher.MessageFilter" /> obiektami spełniającymi podane w <see cref="T:System.Collections.Generic.ICollection`1" /> &lt;filtru&gt;.</param>
        <summary>Zwraca wartość wskazującą, czy są spełnione przez określony komunikat buforowanego kryterium filtru w tabeli, a pasujące filtry są dodawane do kolekcji.</summary>
        <returns>
          <see langword="true" /> Jeśli kryterium dopasowywania, co najmniej jeden filtr w tabeli określony przez <paramref name="messageBuffer" />; <see langword="false" /> Jeśli filtr nie zostanie spełniony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użycie tej metody, gdy więcej niż jeden filtr powinien pasować buforowanych wiadomości, dopasowywania do wzorca filtrowania jest wymagane, a treść komunikatu może być konieczne można przeprowadzić inspekcji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMatchingValue">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca wartość wskazującą, czy kryterium filtru w tabeli jest spełniony określony komunikat lub buforowanego komunikat i zwraca dane filtru dla filtru, który jest zgodny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy użyć jednej z tych metod, co najwyżej jeden filtr będzie zgodny komunikat, ale należy odzyskać dane filtru zgodne z filtrem. Te metody zwracają wartość logiczna wskazująca, czy zgodne z filtrem zostało znalezione i ustawić `data` odwołać się do parametru do dopasowania filtrowania danych.  
  
 Użyj <xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601.GetMatchingFilter%2A> Jeśli treść komunikatu nie jest kontrolowane przez dowolne filtry w tabeli filtru.  
  
 Jeśli treść komunikatu może być kontrolowane przez filtr w tabeli filtru, buffer, wiadomości i przekazać ją do <xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601.GetMatchingFilter%2A> wersji metody.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Jeśli więcej niż jeden filtr dopasowuje wartość do wiadomości, <see cref="T:System.ServiceModel.Dispatcher.MultipleFilterMatchesException" /> musi być zgłaszany.</para>
        </block>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMatchingValue">
      <MemberSignature Language="C#" Value="public bool GetMatchingValue (System.ServiceModel.Channels.Message message, out TFilterData value);" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GetMatchingValue(class System.ServiceModel.Channels.Message message, [out] !TFilterData&amp; value) cil managed" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetMatchingValue(System::ServiceModel::Channels::Message ^ message, [Runtime::InteropServices::Out] TFilterData % value);" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C#" Value="public bool GetMatchingValue (System.ServiceModel.Channels.Message message, out TFilterData data);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GetMatchingValue(class System.ServiceModel.Channels.Message message, [out] !TFilterData&amp; data) cil managed" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.IMessageFilterTable`1.GetMatchingValue(System.ServiceModel.Channels.Message,`0@)" FrameworkAlternate="xamarinmac-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetMatchingValue(System::ServiceModel::Channels::Message ^ message, [Runtime::InteropServices::Out] TFilterData % data);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetMatchingValue : System.ServiceModel.Channels.Message *  -&gt; bool" Usage="iMessageFilterTable.GetMatchingValue (message, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.ServiceModel.Channels.Message" Index="0" />
        <Parameter Name="value" Type="TFilterData&amp;" RefType="out" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="data" Type="TFilterData&amp;" RefType="out" Index="1" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="message">
          <see cref="T:System.ServiceModel.Channels.Message" /> Do testowania.</param>
        <param name="value">
          <see langword="out" /> parametr, który przechowuje <c>danych filtru</c> odpowiadający <c>komunikat</c>.</param>
        <param name="data">
          <see langword="out" /> parametr, który przechowuje <c>danych filtru</c> odpowiadający <c>komunikat</c>.</param>
        <summary>Zwraca wartość wskazującą, czy kryterium dopasowywania dokładnie jeden filtr w tabeli określony przez określony komunikat i dodaje zgodne dane filtr do kolekcji.</summary>
        <returns>
          <see langword="true" /> Jeśli kryterium dopasowywania dokładnie jeden filtr tabeli określony przez message; <see langword="false" /> Jeśli filtr nie zostanie spełniony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda ta jest używana, gdy jeden filtr będzie zgodny komunikat, ale należy odzyskać dane filtru zgodne z filtrem.  
  
 Ta metoda oczekuje co najwyżej jeden filtr dopasowania. Jeśli więcej niż jeden filtr jest zgodny, <xref:System.ServiceModel.Dispatcher.MultipleFilterMatchesException> musi być zgłaszany.  
  
 Jeśli treść wiadomości muszą być kontrolowane przez filtr w tabeli filtru, buforować wiadomości przy użyciu <xref:System.ServiceModel.Channels.Message.CreateBufferedCopy%2A> i przekazać ją do <xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601.GetMatchingValue%2A> wersji metody.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Jeśli więcej niż jeden filtr dopasowuje wartość do wiadomości, <see cref="T:System.ServiceModel.Dispatcher.MultipleFilterMatchesException" /> musi być zgłaszany.  Trwa to przeciążenie <see cref="T:System.ServiceModel.Channels.Message" /> i musi zgłosić <see cref="T:System.ServiceModel.Dispatcher.InvalidBodyAccessException" /> przypadku próby Sprawdź treść komunikatu.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetMatchingValue">
      <MemberSignature Language="C#" Value="public bool GetMatchingValue (System.ServiceModel.Channels.MessageBuffer messageBuffer, out TFilterData value);" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GetMatchingValue(class System.ServiceModel.Channels.MessageBuffer messageBuffer, [out] !TFilterData&amp; value) cil managed" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetMatchingValue(System::ServiceModel::Channels::MessageBuffer ^ messageBuffer, [Runtime::InteropServices::Out] TFilterData % value);" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C#" Value="public bool GetMatchingValue (System.ServiceModel.Channels.MessageBuffer buffer, out TFilterData data);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GetMatchingValue(class System.ServiceModel.Channels.MessageBuffer buffer, [out] !TFilterData&amp; data) cil managed" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.IMessageFilterTable`1.GetMatchingValue(System.ServiceModel.Channels.MessageBuffer,`0@)" FrameworkAlternate="xamarinmac-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMatchingValue (buffer As MessageBuffer, ByRef data As TFilterData) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetMatchingValue(System::ServiceModel::Channels::MessageBuffer ^ buffer, [Runtime::InteropServices::Out] TFilterData % data);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetMatchingValue : System.ServiceModel.Channels.MessageBuffer *  -&gt; bool" Usage="iMessageFilterTable.GetMatchingValue (buffer, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="messageBuffer" Type="System.ServiceModel.Channels.MessageBuffer" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="buffer" Type="System.ServiceModel.Channels.MessageBuffer" Index="0" FrameworkAlternate="xamarinmac-3.0" />
        <Parameter Name="value" Type="TFilterData&amp;" RefType="out" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="data" Type="TFilterData&amp;" RefType="out" Index="1" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="messageBuffer">
          <see cref="T:System.ServiceModel.Channels.MessageBuffer" /> Do testowania.</param>
        <param name="buffer">
          <see cref="T:System.ServiceModel.Channels.MessageBuffer" /> Do testowania.</param>
        <param name="value">
          <see langword="out" /> parametr, który przechowuje <c>danych filtru</c> odpowiadający <c>messageBuffer</c>.</param>
        <param name="data">
          <see langword="out" /> parametr, który przechowuje <c>danych filtru</c> odpowiadający <c>buforu</c>.</param>
        <summary>Zwraca wartość wskazującą, czy kryterium dopasowywania dokładnie jeden filtr w tabeli określony przez określony komunikat buforowanego i dodaje zgodne dane filtr do kolekcji.</summary>
        <returns>
          <see langword="true" /> Jeśli kryterium dopasowywania dokładnie jeden filtr tabeli określony przez message; <see langword="false" /> Jeśli filtr nie zostanie spełniony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jeden filtr oczekuje się, aby dopasować buforowanych wiadomości, należy odzyskać dane filtru zgodne z filtrem i treść komunikatu może być konieczne można przeprowadzić inspekcji.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Jeśli więcej niż jeden filtr dopasowuje wartość do wiadomości, <see cref="T:System.ServiceModel.Dispatcher.MultipleFilterMatchesException" /> musi być zgłaszany.</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMatchingValues">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dodaje dane filtru filtrów, które odpowiadają określony komunikat lub buforowanych wiadomości do kolekcji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda ta jest używana, gdy więcej niż jeden filtr powinien pasować do wzorca tylko pasujących dane filtru jest wymagana. Te metody zwracają wartość logiczna wskazująca, czy zostały znalezione pasujące filtry i umieścić wszystkie dopasowania filtrować dane w kolekcji.  
  
 Należy pamiętać, kolekcję, która zawiera dane filtru nie jest czyszczony przed wyniki zostaną dodane. Pozwala na gromadzenie wszystkie dopasowania dla wielu filtrów tabel w jedną kolekcję.  
  
 Użyj <xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601.GetMatchingValues%2A> Jeśli zawartość treści komunikatu nie wymagają zbadania. Użyj <xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601.GetMatchingValues%2A> Jeśli zawartość treści komunikatu wymaga zbadania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMatchingValues">
      <MemberSignature Language="C#" Value="public bool GetMatchingValues (System.ServiceModel.Channels.Message message, System.Collections.Generic.ICollection&lt;TFilterData&gt; results);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GetMatchingValues(class System.ServiceModel.Channels.Message message, class System.Collections.Generic.ICollection`1&lt;!TFilterData&gt; results) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.IMessageFilterTable`1.GetMatchingValues(System.ServiceModel.Channels.Message,System.Collections.Generic.ICollection{`0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetMatchingValues(System::ServiceModel::Channels::Message ^ message, System::Collections::Generic::ICollection&lt;TFilterData&gt; ^ results);" />
      <MemberSignature Language="F#" Value="abstract member GetMatchingValues : System.ServiceModel.Channels.Message * System.Collections.Generic.ICollection&lt;'FilterData&gt; -&gt; bool" Usage="iMessageFilterTable.GetMatchingValues (message, results)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.ServiceModel.Channels.Message" />
        <Parameter Name="results" Type="System.Collections.Generic.ICollection&lt;TFilterData&gt;" />
      </Parameters>
      <Docs>
        <param name="message">
          <see cref="T:System.ServiceModel.Channels.Message" /> Do testowania.</param>
        <param name="results">Parametr odwołania, która przechowuje dane filtru pasującego filtrów w kolekcji ogólnych.</param>
        <summary>Zwraca wartość wskazującą, czy kryterium dopasowywania, co najmniej jeden filtr w tabeli określony przez określony komunikat i dodaje <paramref name="FilterData" /> pasującego filtrów w kolekcji.</summary>
        <returns>
          <see langword="true" /> Jeśli kryterium dopasowywania, co najmniej jeden filtr w tabeli określony przez <paramref name="message" />; <see langword="false" /> Jeśli filtr nie zostanie spełniony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda oczekuje co najmniej jeden filtr do dopasowania komunikatu, wymagane są tylko dane filtru i zawartość treści wiadomości nie są badane.  
  
 Filtr danych dopasowywania <xref:System.ServiceModel.Dispatcher.MessageFilter> obiekty są przechowywane w `results` parametru.  
  
 Jeśli treść komunikatu jest kontrolowane przez filtr w tabeli filtru, buffer, wiadomości i przekazać ją do <xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601.GetMatchingValues%2A> wersji metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMatchingValues">
      <MemberSignature Language="C#" Value="public bool GetMatchingValues (System.ServiceModel.Channels.MessageBuffer messageBuffer, System.Collections.Generic.ICollection&lt;TFilterData&gt; results);" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GetMatchingValues(class System.ServiceModel.Channels.MessageBuffer messageBuffer, class System.Collections.Generic.ICollection`1&lt;!TFilterData&gt; results) cil managed" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetMatchingValues(System::ServiceModel::Channels::MessageBuffer ^ messageBuffer, System::Collections::Generic::ICollection&lt;TFilterData&gt; ^ results);" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="C#" Value="public bool GetMatchingValues (System.ServiceModel.Channels.MessageBuffer buffer, System.Collections.Generic.ICollection&lt;TFilterData&gt; results);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GetMatchingValues(class System.ServiceModel.Channels.MessageBuffer buffer, class System.Collections.Generic.ICollection`1&lt;!TFilterData&gt; results) cil managed" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.IMessageFilterTable`1.GetMatchingValues(System.ServiceModel.Channels.MessageBuffer,System.Collections.Generic.ICollection{`0})" FrameworkAlternate="xamarinmac-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.0;netframework-3.5;netframework-4.0" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMatchingValues (buffer As MessageBuffer, results As ICollection(Of TFilterData)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetMatchingValues(System::ServiceModel::Channels::MessageBuffer ^ buffer, System::Collections::Generic::ICollection&lt;TFilterData&gt; ^ results);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetMatchingValues : System.ServiceModel.Channels.MessageBuffer * System.Collections.Generic.ICollection&lt;'FilterData&gt; -&gt; bool" Usage="iMessageFilterTable.GetMatchingValues (buffer, results)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="messageBuffer" Type="System.ServiceModel.Channels.MessageBuffer" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-3.0;netframework-3.5;netframework-4.0" />
        <Parameter Name="buffer" Type="System.ServiceModel.Channels.MessageBuffer" Index="0" FrameworkAlternate="xamarinmac-3.0" />
        <Parameter Name="results" Type="System.Collections.Generic.ICollection&lt;TFilterData&gt;" Index="1" />
      </Parameters>
      <Docs>
        <param name="messageBuffer">
          <see cref="T:System.ServiceModel.Channels.MessageBuffer" /> Do testowania.</param>
        <param name="buffer">
          <see cref="T:System.ServiceModel.Channels.MessageBuffer" /> Do testowania.</param>
        <param name="results">Parametr odwołania, która przechowuje dane filtr zgodnych filtrów w ogólnej metodzie <see cref="T:System.Collections.Generic.ICollection`1" /> &lt; <c>danych filtru</c>&gt;.</param>
        <summary>Zwraca wartość wskazującą, czy określony przez określony komunikat buforowanego kryterium dopasowywania, co najmniej jeden filtr w tabeli i dodaje <paramref name="FilterData" /> pasującego filtrów w kolekcji.</summary>
        <returns>
          <see langword="true" /> Jeśli kryterium dopasowywania, co najmniej jeden filtr w tabeli określony przez <paramref name="messageBuffer" />; <see langword="false" /> Jeśli filtr nie zostanie spełniony.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda oczekuje co najmniej jeden filtr do dopasowania komunikatu buforowanego, wymagane są tylko dane filtru i treść komunikatu może wymagać inspekcji.  
  
 Filtr danych dopasowywania <xref:System.ServiceModel.Dispatcher.MessageFilter> obiekty są przechowywane w `results` parametru.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
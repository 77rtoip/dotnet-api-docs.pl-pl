<Type Name="DataTableReader" FullName="System.Data.DataTableReader">
  <Metadata><Meta Name="ms.openlocfilehash" Value="d96f365684ba6298910d34f1cda3153f7d6f8e88" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58744503" /></Metadata><TypeSignature Language="C#" Value="public sealed class DataTableReader : System.Data.Common.DbDataReader" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit DataTableReader extends System.Data.Common.DbDataReader" />
  <TypeSignature Language="DocId" Value="T:System.Data.DataTableReader" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DataTableReader&#xA;Inherits DbDataReader" />
  <TypeSignature Language="C++ CLI" Value="public ref class DataTableReader sealed : System::Data::Common::DbDataReader" />
  <TypeSignature Language="F#" Value="type DataTableReader = class&#xA;    inherit DbDataReader" />
  <AssemblyInfo>
    <AssemblyName>System.Data</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Data.Common</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Data.Common.DbDataReader</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><see cref="T:System.Data.DataTableReader" /> Uzyskuje zawartość jednego lub więcej <see cref="T:System.Data.DataTable" /> obiektów w postaci jednego lub więcej zestawów wyników tylko do odczytu, tylko do przodu.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTableReader> Działa podobnie jak inne czytnika danych, takich jak <xref:System.Data.SqlClient.SqlDataReader>, chyba że <xref:System.Data.DataTableReader> przewiduje Iterowanie wierszy w <xref:System.Data.DataTable>. Innymi słowy oferuje ona Iterowanie wierszy w pamięci podręcznej. Można modyfikować dane w pamięci podręcznej podczas <xref:System.Data.DataTableReader> jest aktywny, a czytnik również automatycznie obsługuje położenia.  
  
 Po utworzeniu <xref:System.Data.DataTableReader> z <xref:System.Data.DataTable>, wynikowy <xref:System.Data.DataTableReader> obiekt zawiera jeden zestaw wyników z tych samych danych co <xref:System.Data.DataTable> z której została utworzona, z wyjątkiem wszystkich wierszy, które zostały oznaczone jako usunięte. Kolumny są wyświetlane w tej samej kolejności jak w oryginalnym <xref:System.Data.DataTable>. Struktura zwracany wynik jest identyczne w schemat i dane z oryginalnego <xref:System.Data.DataTable>. A <xref:System.Data.DataTableReader> utworzony przez wywołanie metody <xref:System.Data.DataSet.CreateDataReader*> metody <xref:System.Data.DataSet> obiekt zawiera wiele zestawów wyników, jeśli <xref:System.Data.DataSet> zawiera więcej niż jedną tabelą. Wyniki są w tę samą sekwencję co <xref:System.Data.DataTable> obiekty w <xref:System.Data.DataTableCollection> z <xref:System.Data.DataSet> obiektu.  
  
 Zestaw wyników zwrócony zawiera tylko bieżącą wersję każdego <xref:System.Data.DataRow>; zostaną pominięte wiersze, które zostały oznaczone do usunięcia.  
  
 `DataTableReader` Zapewnia stabilnego iteratora, czyli zawartość `DataTableReader` nie są unieważniane, jeśli rozmiar kolekcji źródłowej jest modyfikowana podczas iteracji. Na przykład jeśli jeden lub więcej wierszy w <xref:System.Data.DataTable.Rows%2A> usunięta lub usunąć w trakcie iteracji, bieżącej pozycji w kolekcji `DataTableReader` są odpowiednio przechowywane i nie powoduje unieważnienia iteratora.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Data.DataTableReader" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataTableReader (System.Data.DataTable dataTable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Data.DataTable dataTable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.#ctor(System.Data.DataTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataTableReader(System::Data::DataTable ^ dataTable);" />
      <MemberSignature Language="F#" Value="new System.Data.DataTableReader : System.Data.DataTable -&gt; System.Data.DataTableReader" Usage="new System.Data.DataTableReader dataTable" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dataTable" Type="System.Data.DataTable" />
      </Parameters>
      <Docs>
        <param name="dataTable"><see cref="T:System.Data.DataTable" /> z którego nowy <see cref="T:System.Data.DataTableReader" /> uzyskuje swój zestaw wyników.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Data.DataTableReader" /> klasy przy użyciu danych z podanym <see cref="T:System.Data.DataTable" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataTableReader (System.Data.DataTable[] dataTables);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Data.DataTable[] dataTables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.#ctor(System.Data.DataTable[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dataTables As DataTable())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataTableReader(cli::array &lt;System::Data::DataTable ^&gt; ^ dataTables);" />
      <MemberSignature Language="F#" Value="new System.Data.DataTableReader : System.Data.DataTable[] -&gt; System.Data.DataTableReader" Usage="new System.Data.DataTableReader dataTables" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dataTables" Type="System.Data.DataTable[]" />
      </Parameters>
      <Docs>
        <param name="dataTables">Tablica <see cref="T:System.Data.DataTable" /> obiektów, które dostarcza wyniki dla nowego <see cref="T:System.Data.DataTableReader" /> obiektu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Data.DataTableReader" /> klasy przy użyciu podanej tablicy <see cref="T:System.Data.DataTable" /> obiektów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli musisz utworzyć <xref:System.Data.DataTableReader> na podstawie wszystkie lub podzbiór tabel w określonym <xref:System.Data.DataSet>, wywołaj `DataSet`firmy <xref:System.Data.DataSet.CreateDataReader*> metody. Jeśli chcesz utworzyć nowy <xref:System.Data.DataTableReader> wystąpienia oparte na grupach `DataTable` wystąpień, które nie są inny sposób powiązane, użyć tego konstruktora. Możesz również korzystać z zalet tego konstruktora, aby zmienić kolejność `DataTables` w ramach `DataTableReader`, jeśli ich kolejność w ich źródle `DataSet` nie spełnia Twoich potrzeb.  
  
   
  
## Examples  
 W poniższym przykładzie metoda TestConstructor tworzy dwa <xref:System.Data.DataTable> wystąpień. W celu przedstawienia tej Konstruktor <xref:System.Data.DataTableReader> klasy Przykładowa aplikacja tworzy nową `DataTableReader` na podstawie tablicy, która zawiera dwa `DataTables`i wykonuje prostą operacją, Drukowanie zawartości z pierwszego mało kolumn w konsoli okno. Aby przetestować tę aplikację, Utwórz nową aplikację konsoli i wklej przykładowy kod do nowo utworzony plik.  
  
 [!code-csharp[DataWorks DataTableReader.ctor#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.ctor/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.ctor/VB/source.vb#1)]  
  
 W oknie konsoli zostaną wyświetlone następujące wyniki:  
  
```  
1 Mary  
2 Andy  
3 Peter  
4 Russ  
1 Wireless Network Card  
2 Hard Drive  
3 Monitor  
4 CPU  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Close();" />
      <MemberSignature Language="F#" Value="override this.Close : unit -&gt; unit" Usage="dataTableReader.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zamyka bieżące <see cref="T:System.Data.DataTableReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływanie `Close()` na zamkniętej `DataTableReader` obiektu nie powoduje błąd.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Depth">
      <MemberSignature Language="C#" Value="public override int Depth { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Depth" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTableReader.Depth" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Depth As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Depth { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Depth : int" Usage="System.Data.DataTableReader.Depth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Głębokość zagnieżdżenia bieżącego wiersza <see cref="T:System.Data.DataTableReader" />.</summary>
        <value>Głębokość zagnieżdżenia dla bieżącego wiersza; zawsze zero.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `DataTableReader` nie obsługuje zagnieżdżania. `Depth` Właściwość zawsze zwraca wartość zero.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FieldCount">
      <MemberSignature Language="C#" Value="public override int FieldCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 FieldCount" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTableReader.FieldCount" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property FieldCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int FieldCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.FieldCount : int" Usage="System.Data.DataTableReader.FieldCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zwraca liczbę kolumn w bieżącym wierszu.</summary>
        <value>Gdy nie znajduje się w zestawie prawidłowy wynik 0. w przeciwnym razie z liczbą kolumn w bieżącym wierszu.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Próbowano pobrać liczba pól w zamkniętej <see cref="T:System.Data.DataTableReader" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetBoolean">
      <MemberSignature Language="C#" Value="public override bool GetBoolean (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool GetBoolean(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetBoolean(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBoolean (ordinal As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool GetBoolean(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetBoolean : int -&gt; bool" Usage="dataTableReader.GetBoolean ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Numer porządkowy kolumny liczony od zera.</param>
        <summary>Pobiera wartość określonej kolumny jako <see cref="T:System.Boolean" />.</summary>
        <returns>Wartość określonej kolumny.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Konwersje nie są wykonywane; w związku z tym danych pobranych musi już być atrybut typu wartość logiczna lub zwracała wartość na wartość logiczną, lub generowany jest wyjątek.  
  
 Wywołaj <xref:System.Data.DataTableReader.IsDBNull%2A> czy przed wywołaniem tej metody są wartości null.  
  
   
  
## Examples  
 Poniższy przykład wyświetla zawartość kolumny numerowane 2 w ramach przekazany do <xref:System.Data.DataTableReader>. Jeśli kolumna w określonym wierszu ma wartość null, ten kod wyświetla tekst \<NULL >. Jeśli dane w kolumnie nie jest poprawnego typu, przykład wyświetla komunikat o błędzie dla każdego wiersza.  
  
 [!code-csharp[DataWorks DataTableReader.GetBoolean#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetBoolean/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetBoolean#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetBoolean/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Indeks przekazywane był poza zakresem od 0 do <see cref="P:System.Data.DataTableReader.FieldCount" /> - 1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Próbowano pobrać dane z usuniętego wiersza.</exception>
        <exception cref="T:System.InvalidOperationException">Nastąpiła próba odczytu lub uzyskać dostępu do kolumny w zamkniętej <see cref="T:System.Data.DataTableReader" />.</exception>
        <exception cref="T:System.InvalidCastException">Określona kolumna nie zawiera <see langword="Boolean" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetByte">
      <MemberSignature Language="C#" Value="public override byte GetByte (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8 GetByte(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetByte(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByte (ordinal As Integer) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Byte GetByte(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetByte : int -&gt; byte" Usage="dataTableReader.GetByte ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Numer porządkowy kolumny liczony od zera.</param>
        <summary>Pobiera wartość określonej kolumny w postaci bajtów.</summary>
        <returns>Wartość określonej kolumny.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Konwersje nie są wykonywane; w związku z tym danych pobranych musi być bajtów lub zwracała wartość na bajt.  
  
 Wywołaj <xref:System.Data.DataTableReader.IsDBNull%2A> czy przed wywołaniem tej metody są wartości null.  
  
   
  
## Examples  
 Poniższy przykład wyświetla zawartość kolumny numerowane 2 w ramach przekazany do <xref:System.Data.DataTableReader>. Jeśli kolumna w określonym wierszu ma wartość null, ten kod wyświetla tekst \<NULL >. Jeśli dane w kolumnie nie jest poprawnego typu, przykład wyświetla komunikat o błędzie dla każdego wiersza.  
  
 [!code-csharp[DataWorks DataTableReader.GetByte#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetByte/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetByte#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetByte/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Indeks przekazywane był poza zakresem od 0 do <see cref="P:System.Data.DataTableReader.FieldCount" /> - 1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Próbowano pobrać dane z usuniętego wiersza.</exception>
        <exception cref="T:System.InvalidOperationException">Nastąpiła próba odczytu lub uzyskać dostępu do kolumny w zamkniętej <see langword="DataTableReader" />.</exception>
        <exception cref="T:System.InvalidCastException">Określona kolumna nie zawiera typu byte.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override long GetBytes (int ordinal, long dataIndex, byte[] buffer, int bufferIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 GetBytes(int32 ordinal, int64 dataIndex, unsigned int8[] buffer, int32 bufferIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetBytes(System.Int32,System.Int64,System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (ordinal As Integer, dataIndex As Long, buffer As Byte(), bufferIndex As Integer, length As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long GetBytes(int ordinal, long dataIndex, cli::array &lt;System::Byte&gt; ^ buffer, int bufferIndex, int length);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : int * int64 * byte[] * int * int -&gt; int64" Usage="dataTableReader.GetBytes (ordinal, dataIndex, buffer, bufferIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
        <Parameter Name="dataIndex" Type="System.Int64" />
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="bufferIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Numer porządkowy kolumny liczony od zera.</param>
        <param name="dataIndex">Indeks w obrębie pola, w którym można uruchomić operacji odczytu.</param>
        <param name="buffer">Bufor, do którego można odczytać strumienia bajtów.</param>
        <param name="bufferIndex">Indeks buforu, w którym ma zostać rozpoczęte, umieszczając dane.</param>
        <param name="length">Maksymalna długość do skopiowania w buforze.</param>
        <summary>Odczytuje strumień bajtów, rozpoczynając od przesunięcia określonej kolumny w buforze, w postaci tablicy, rozpoczynając od przesunięcia określonego bufora.</summary>
        <returns>Rzeczywista liczba odczytanych bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetBytes` Zwraca liczbę bajtów dostępnych w tym polu. W większości przypadków jest to dokładnie długość pola. Jednakże, zwrócona liczba może być mniejsza niż wartość true, długość pola Jeśli `GetBytes` został już użyty do uzyskania bajtów z pola. Może to być tak, na przykład, gdy <xref:System.Data.DataTableReader> odczytuje struktury dużych ilości danych do buforu  
  
 W przypadku przekazania buforu, który jest `null` (`Nothing` w języku Visual Basic), `GetBytes` zwraca długość całe pole w bajtach, a nie do pozostałych rozmiaru na podstawie parametru przesunięcia buforu.  
  
 Konwersje nie są wykonywane; w związku z tym danych pobranych już musi być tablicą bajtów lub zwracała wartość do tablicy typu byte.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Data.DataTableReader> na podstawie danych z przykładowej bazy danych AdventureWorks, a następnie zapisuje każdy obraz pobierane do osobnego pliku w folderze C:\. Aby przetestować tę aplikację, Utwórz nową aplikację konsoli odwołują się do zestawu System.Drawing.dll i wkleić przykładowy kod do nowo utworzony plik.  
  
 [!code-csharp[DataWorks DataTableReader.GetBytes#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetBytes/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetBytes#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetBytes/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Indeks przekazywane był poza zakresem od 0 do <see cref="P:System.Data.DataTableReader.FieldCount" /> - 1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Próbowano pobrać dane z usuniętego wiersza.</exception>
        <exception cref="T:System.InvalidOperationException">Nastąpiła próba odczytu lub uzyskać dostępu do kolumny w zamkniętej <see langword="DataTableReader" />.</exception>
        <exception cref="T:System.InvalidCastException">Określona kolumna nie zawiera tablicy bajtów.</exception>
        <altmember cref="M:System.Data.DataTableReader.GetChars(System.Int32,System.Int64,System.Char[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetChar">
      <MemberSignature Language="C#" Value="public override char GetChar (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance char GetChar(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetChar(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetChar (ordinal As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override char GetChar(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetChar : int -&gt; char" Usage="dataTableReader.GetChar ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Numer porządkowy kolumny liczony od zera.</param>
        <summary>Pobiera wartość określonej kolumny w postaci znaku.</summary>
        <returns>Wartość kolumny.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Konwersje nie są wykonywane; w związku z tym danych pobranych musi być zwracała wartość do znaku lub znaków.  
  
 Wywołaj <xref:System.Data.DataTableReader.IsDBNull%2A> czy przed wywołaniem tej metody są wartości null.  
  
   
  
## Examples  
 Poniższy przykład wyświetla zawartość kolumny numerowane 2 w ramach elementu DataTableReader przekazany w. Jeśli kolumna w określonym wierszu ma wartość null, ten kod wyświetla tekst \<NULL >. Jeśli dane w kolumnie nie jest poprawnego typu, przykład wyświetla komunikat o błędzie dla każdego wiersza.  
  
 [!code-csharp[DataWorks DataTableReader.GetChar#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetChar/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetChar#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetChar/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Indeks przekazywane był poza zakresem od 0 do <see cref="P:System.Data.DataTableReader.FieldCount" /> - 1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Próbowano pobrać dane z usuniętego wiersza.</exception>
        <exception cref="T:System.InvalidOperationException">Nastąpiła próba odczytu lub uzyskać dostępu do kolumny w zamkniętej <see langword="DataTableReader" />.</exception>
        <exception cref="T:System.InvalidCastException">Określone pole nie zawiera znaku.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override long GetChars (int ordinal, long dataIndex, char[] buffer, int bufferIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 GetChars(int32 ordinal, int64 dataIndex, char[] buffer, int32 bufferIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetChars(System.Int32,System.Int64,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetChars (ordinal As Integer, dataIndex As Long, buffer As Char(), bufferIndex As Integer, length As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long GetChars(int ordinal, long dataIndex, cli::array &lt;char&gt; ^ buffer, int bufferIndex, int length);" />
      <MemberSignature Language="F#" Value="override this.GetChars : int * int64 * char[] * int * int -&gt; int64" Usage="dataTableReader.GetChars (ordinal, dataIndex, buffer, bufferIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
        <Parameter Name="dataIndex" Type="System.Int64" />
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="bufferIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Numer porządkowy kolumny liczony od zera.</param>
        <param name="dataIndex">Indeks w obrębie pola, w którym można uruchomić operacji odczytu.</param>
        <param name="buffer">Bufor, do którego można odczytać strumienia znaków.</param>
        <param name="bufferIndex">Indeks buforu, w którym ma zostać rozpoczęte, umieszczając dane.</param>
        <param name="length">Maksymalna długość do skopiowania w buforze.</param>
        <summary>Zwraca wartość określonej kolumny w postaci tablicy znaków.</summary>
        <returns>Rzeczywista liczba znaków do odczytu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetChars` Zwraca liczbę znaków, dostępne w tym polu. W większości przypadków jest to dokładnie długość pola. Jednakże, zwrócona liczba może być mniejsza niż wartość true, długość pola Jeśli `GetChars` został już użyty można uzyskać znaki z pola.  
  
 Rzeczywista liczba znaków czytanych może być mniejsza niż żądana długość, jeśli osiągnięty zostanie koniec pola. W przypadku przekazania buforu, który ma wartość null (`Nothing` w języku Visual Basic), `GetChars` zwraca długość całe pole znaków, nie pozostałe rozmiaru na podstawie parametru przesunięcia buforu.  
  
 Konwersje nie są wykonywane; w związku z tym pobranie danych musi być już tablicy znaków lub zwracała wartość do tablicy znaków.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano `GetChars` metody. `TestGetChars` Metoda oczekuje, że przekazane `DataTableReader` wypełnione dwie kolumny danych: Nazwa pliku, w pierwszej kolumnie, a Tablica znaków w ciągu sekundy. Ponadto `TestGetChars` pozwala określić rozmiar buforu, która będzie używana jako odczytuje dane z tablicy znaków w `DataTableReader`. `TestGetChars` Tworzy plik odpowiadający każdego wiersza danych w `DataTableReader`, przy użyciu dostarczonych danych, w pierwszej kolumnie `DataTableReader` jako nazwę pliku.  
  
 Poniższa procedura demonstruje użycie `GetChars` metoda odczytywanie danych przechowywanych w `DataTable` jako tablicę znaków. Dowolny inny typ danych powoduje, że `GetChars` metodę, aby zgłosić `InvalidCastException`.  
  
 [!code-csharp[DataWorks DataTableReader.GetChars#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetChars/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetChars/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Indeks przekazywane był poza zakresem od 0 do <see cref="P:System.Data.DataTableReader.FieldCount" /> - 1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Próbowano pobrać dane z usuniętego wiersza.</exception>
        <exception cref="T:System.InvalidOperationException">Nastąpiła próba odczytu lub uzyskać dostępu do kolumny w zamkniętej <see langword="DataTableReader" />.</exception>
        <exception cref="T:System.InvalidCastException">Określona kolumna nie zawiera tablicy znaków.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetDataTypeName">
      <MemberSignature Language="C#" Value="public override string GetDataTypeName (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetDataTypeName(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetDataTypeName(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetDataTypeName (ordinal As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ GetDataTypeName(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetDataTypeName : int -&gt; string" Usage="dataTableReader.GetDataTypeName ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Numer porządkowy kolumny liczony od zera.</param>
        <summary>Pobiera ciąg reprezentujący typ danych dla określonej kolumny.</summary>
        <returns>Ciąg reprezentujący typ danych kolumny.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTableReader.GetDataTypeName%2A> Metoda zawsze zwraca typ elementu bazowego <xref:System.Data.DataColumn> zamiast typu właściwe dla dostawcy.  
  
   
  
## Examples  
 Następująca aplikacja konsoli Wyświetla listę pola i ich nazwy typ z prostą <xref:System.Data.DataTable>:  
  
 [!code-csharp[DataWorks DataTableReader.GetDataTypeName#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetDataTypeName/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetDataTypeName#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetDataTypeName/VB/source.vb#1)]  
  
 W oknie konsoli zostaną wyświetlone następujące wyniki:  
  
```  
ID: Int32  
Name: String  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Indeks przekazywane był poza zakresem od 0 do <see cref="P:System.Data.DataTableReader.FieldCount" /> - 1.</exception>
        <exception cref="T:System.InvalidOperationException">Nastąpiła próba odczytu lub uzyskać dostępu do kolumny w zamkniętej <see cref="T:System.Data.DataTableReader" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetDateTime">
      <MemberSignature Language="C#" Value="public override DateTime GetDateTime (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.DateTime GetDateTime(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetDateTime(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetDateTime (ordinal As Integer) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override DateTime GetDateTime(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetDateTime : int -&gt; DateTime" Usage="dataTableReader.GetDateTime ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Numer porządkowy kolumny liczony od zera.</param>
        <summary>Pobiera wartość określonej kolumny jako <see cref="T:System.DateTime" /> obiektu.</summary>
        <returns>Wartość określonej kolumny.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Konwersje nie są wykonywane; w związku z tym musi już być danych pobranych <xref:System.DateTime> lub zwracała wartość do `DataTime`.  
  
 Wywołaj <xref:System.Data.DataTableReader.IsDBNull%2A> czy przed wywołaniem tej metody są wartości null.  
  
   
  
## Examples  
 Poniższy przykład wyświetla zawartość kolumny numerowane 2 w ramach przekazany do <xref:System.Data.DataTableReader>. Jeśli kolumna w określonym wierszu ma wartość null, ten kod wyświetla tekst \<NULL >. Jeśli dane w kolumnie nie jest poprawnego typu, przykład wyświetla komunikat o błędzie dla każdego wiersza.  
  
 [!code-csharp[DataWorks DataTableReader.GetDateTime#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetDateTime/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetDateTime#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetDateTime/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Indeks przekazywane był poza zakresem od 0 do <see cref="P:System.Data.DataTableReader.FieldCount" /> - 1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Próbowano pobrać dane z usuniętego wiersza.</exception>
        <exception cref="T:System.InvalidOperationException">Nastąpiła próba odczytu lub uzyskać dostępu do kolumny w zamkniętej <see langword="DataTableReader" />.</exception>
        <exception cref="T:System.InvalidCastException">Określona kolumna nie zawiera wartości daty/godziny.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetDecimal">
      <MemberSignature Language="C#" Value="public override decimal GetDecimal (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Decimal GetDecimal(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetDecimal(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetDecimal (ordinal As Integer) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Decimal GetDecimal(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetDecimal : int -&gt; decimal" Usage="dataTableReader.GetDecimal ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Numer porządkowy kolumny liczony od zera.</param>
        <summary>Pobiera wartość określonej kolumny jako <see cref="T:System.Decimal" />.</summary>
        <returns>Wartość określonej kolumny.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Konwersje nie są wykonywane; w związku z tym musi już być danych pobranych <xref:System.Decimal> lub zwracała wartość do `Decimal`.  
  
 Wywołaj <xref:System.Data.DataTableReader.IsDBNull%2A> czy przed wywołaniem tej metody są wartości null.  
  
   
  
## Examples  
 Poniższy przykład wyświetla zawartość kolumny numerowane 2 w ramach przekazany do <xref:System.Data.DataTableReader>. Jeśli kolumna w określonym wierszu ma wartość null, ten kod wyświetla tekst \<NULL >. Jeśli dane w kolumnie nie jest poprawnego typu, przykład wyświetla komunikat o błędzie dla każdego wiersza.  
  
 [!code-csharp[DataWorks DataTableReader.GetDecimal#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetDecimal/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetDecimal#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetDecimal/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Indeks przekazywane był poza zakresem od 0 do <see cref="P:System.Data.DataTableReader.FieldCount" /> - 1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Próbowano pobrać dane z usuniętego wiersza.</exception>
        <exception cref="T:System.InvalidOperationException">Nastąpiła próba odczytu lub uzyskać dostępu do kolumny w zamkniętej <see langword="DataTableReader" />.</exception>
        <exception cref="T:System.InvalidCastException">Określona kolumna nie zawiera <see langword="Decimal" /> wartość.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetDouble">
      <MemberSignature Language="C#" Value="public override double GetDouble (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance float64 GetDouble(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetDouble(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetDouble (ordinal As Integer) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override double GetDouble(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetDouble : int -&gt; double" Usage="dataTableReader.GetDouble ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Liczony od zera numeru porządkowego kolumny.</param>
        <summary>Pobiera wartość kolumny jako podwójnej precyzji liczbę zmiennoprzecinkową.</summary>
        <returns>Wartość określonej kolumny.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Konwersje nie są wykonywane; w związku z tym danych pobranych musi już być podwójnej precyzji liczb zmiennoprzecinkowych, lub musi być zwracała wartość do podwójnej precyzji liczbę zmiennoprzecinkową.  
  
 Wywołaj <xref:System.Data.DataTableReader.IsDBNull%2A> czy przed wywołaniem tej metody są wartości null.  
  
   
  
## Examples  
 Poniższy przykład wyświetla zawartość kolumny numerowane 2 w ramach przekazany do <xref:System.Data.DataTableReader>. Jeśli kolumna w określonym wierszu ma wartość null, ten kod wyświetla tekst \<NULL >. Jeśli dane w kolumnie nie jest poprawnego typu, przykład wyświetla komunikat o błędzie dla każdego wiersza.  
  
 [!code-csharp[DataWorks DataTableReader.GetDouble#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetDouble/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetDouble#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetDouble/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Indeks przekazywane był poza zakresem od 0 do <see cref="P:System.Data.DataTableReader.FieldCount" /> - 1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Próbowano pobrać dane z usuniętego wiersza.</exception>
        <exception cref="T:System.InvalidOperationException">Nastąpiła próba odczytu lub uzyskać dostępu do kolumny w zamkniętej <see langword="DataTableReader" />.</exception>
        <exception cref="T:System.InvalidCastException">Określona kolumna nie zawiera podwójnej precyzji liczbę zmiennoprzecinkową.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public override System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="override this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="dataTableReader.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca moduł wyliczający, który może służyć do iterowania po kolekcji elementów.</summary>
        <returns><see cref="T:System.Collections.IEnumerator" /> Obiekt, który reprezentuje kolekcję elementów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Moduły wyliczające Zezwalaj tylko do odczytu danych w <xref:System.Data.DataTableReader>. Moduły wyliczające nie można modyfikować kolekcji źródłowej.  
  
 Początkowo moduł wyliczający jest umieszczony przed pierwszym elementem w kolekcji. Co to położenie, wywołanie <xref:System.Collections.IEnumerator.Current%2A> zgłasza wyjątek. W związku z tym, należy wywołać `MoveNext` do wyprzedzeniem modułu wyliczającego do pierwszego elementu kolekcji przed odczytaniem wartości właściwości `Current`.  
  
 `Current` Zwraca <xref:System.Data.Common.DbDataRecord>i zwraca ten sam obiekt, do momentu <xref:System.Collections.IEnumerator.MoveNext%2A> lub <xref:System.Collections.IEnumerator.Reset%2A> jest wywoływana. `MoveNext` Ustawia `Current` do następnego elementu.  
  
 Przechodzi przez koniec kolekcji, moduł wyliczający po określonym położeniem za ostatnim elementem w kolekcji i wywoływania `MoveNext` zwraca wartość false. Jeśli ostatnie wywołanie `MoveNext` zwrócił `false`, wywoływania `Current` zgłasza wyjątek. Ponadto ponieważ <xref:System.Data.DataTableReader> zapewnia dostęp tylko do przodu do swoich danych, wywoływania <xref:System.Collections.IEnumerator.Reset%2A> metoda IEnumerator zgłasza <xref:System.NotSupportedException>.  
  
 <xref:System.Data.DataTableReader> Zapewnia stabilne modułu wyliczającego. Oznacza to, że nawet jeśli występują w danych bazowych usunięcia wiersza lub dodatki moduł wyliczający jest zwracany przez wywołanie <xref:System.Data.DataTableReader.GetEnumerator%2A> jest nadal ważny.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie <xref:System.Data.DataTableReader.GetEnumerator%2A> metody. Dotyczy to również zachowanie modułu wyliczającego wiersze są usuwane z bazowego <xref:System.Data.DataTable> , gdy moduł wyliczający jest aktywny.  
  
 [!code-csharp[DataWorks DataTableReader.GetEnumerator#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetEnumerator/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetEnumerator/VB/source.vb#1)]  
  
 Procedura wyświetla następujący tekst w oknie konsoli:  
  
```  
Peter  
Mary  
Russ  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nastąpiła próba odczytu lub uzyskać dostępu do kolumny w zamkniętej <see cref="T:System.Data.DataTableReader" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFieldType">
      <MemberSignature Language="C#" Value="public override Type GetFieldType (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetFieldType(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetFieldType(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetFieldType (ordinal As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetFieldType(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetFieldType : int -&gt; Type" Usage="dataTableReader.GetFieldType ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Numer porządkowy kolumny liczony od zera.</param>
        <summary>Pobiera <see cref="T:System.Type" /> który jest typem danych obiektu.</summary>
        <returns><see cref="T:System.Type" /> Który jest typem danych obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Wywołaj procedurę, przekazując <xref:System.Data.DataTableReader> wystąpienia, aby wyświetlić listę wszystkich pól i Pełna nazwa dla każdego typu w oknie konsoli.  
  
 [!code-csharp[DataWorks DataTableReader.GetFieldType#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetFieldType/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetFieldType#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetFieldType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Indeks przekazywane był poza zakresem od 0 do <see cref="P:System.Data.DataTableReader.FieldCount" /> - 1.</exception>
        <exception cref="T:System.InvalidOperationException">Nastąpiła próba odczytu lub uzyskać dostępu do kolumny w zamkniętej <see cref="T:System.Data.DataTableReader" /> .</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFloat">
      <MemberSignature Language="C#" Value="public override float GetFloat (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance float32 GetFloat(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetFloat(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetFloat (ordinal As Integer) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override float GetFloat(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetFloat : int -&gt; single" Usage="dataTableReader.GetFloat ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Numer porządkowy kolumny liczony od zera.</param>
        <summary>Pobiera wartość określonej kolumny jako pojedynczej precyzji liczbę zmiennoprzecinkową.</summary>
        <returns>Wartość kolumny.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Konwersje nie są wykonywane; w związku z tym danych pobranych musi już być pojedynczej precyzji liczb zmiennoprzecinkowych, lub musi być zwracała wartość do pojedynczej precyzji liczbę zmiennoprzecinkową.  
  
 Wywołaj <xref:System.Data.DataTableReader.IsDBNull%2A> czy przed wywołaniem tej metody są wartości null.  
  
   
  
## Examples  
 Poniższy przykład wyświetla zawartość kolumny numerowane 2 w ramach przekazany do <xref:System.Data.DataTableReader>. Jeśli kolumna w określonym wierszu ma wartość null, ten kod wyświetla tekst \<NULL >. Jeśli dane w kolumnie nie jest poprawnego typu, przykład wyświetla komunikat o błędzie dla każdego wiersza.  
  
 [!code-csharp[DataWorks DataTableReader.GetFloat#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetFloat/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetFloat#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetFloat/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Indeks przekazywane był poza zakresem od 0 do <see cref="P:System.Data.DataTableReader.FieldCount" /> - 1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Próbowano pobrać dane z usuniętego wiersza.</exception>
        <exception cref="T:System.InvalidOperationException">Nastąpiła próba odczytu lub uzyskać dostępu do kolumny w zamkniętej <see cref="T:System.Data.DataTableReader" />.</exception>
        <exception cref="T:System.InvalidCastException">Określona kolumna nie zawiera pojedynczej precyzji liczbę zmiennoprzecinkową.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetGuid">
      <MemberSignature Language="C#" Value="public override Guid GetGuid (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Guid GetGuid(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetGuid(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetGuid (ordinal As Integer) As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Guid GetGuid(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetGuid : int -&gt; Guid" Usage="dataTableReader.GetGuid ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Numer porządkowy kolumny liczony od zera.</param>
        <summary>Pobiera wartość określonej kolumny jako globalnie unikatowy identyfikator (globalny GUID).</summary>
        <returns>Wartość określonej kolumny.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Konwersje nie są wykonywane; w związku z tym musi już być danych pobranych <xref:System.Guid> lub zwracała wartość do `Guid`.  
  
 Wywołaj <xref:System.Data.DataTableReader.IsDBNull%2A> czy przed wywołaniem tej metody są wartości null.  
  
   
  
## Examples  
 Poniższy przykład wyświetla zawartość kolumny numerowane 2 w ramach elementu DataTableReader przekazany w. Jeśli kolumna w określonym wierszu ma wartość null, ten kod wyświetla tekst \<NULL >. Jeśli dane w kolumnie nie jest poprawnego typu, przykład wyświetla komunikat o błędzie dla każdego wiersza.  
  
 [!code-csharp[DataWorks DataTableReader.GetGuid#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetGuid/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetGuid#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetGuid/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Indeks przekazywane był poza zakresem od 0 do <see cref="P:System.Data.DataTableReader.FieldCount" /> - 1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Próbowano pobrać dane z usuniętego wiersza.</exception>
        <exception cref="T:System.InvalidOperationException">Nastąpiła próba odczytu lub uzyskać dostępu do kolumny w zamkniętej <see cref="T:System.Data.DataTableReader" />.</exception>
        <exception cref="T:System.InvalidCastException">Określona kolumna nie zawiera identyfikatora GUID.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetInt16">
      <MemberSignature Language="C#" Value="public override short GetInt16 (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int16 GetInt16(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetInt16(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetInt16 (ordinal As Integer) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override short GetInt16(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetInt16 : int -&gt; int16" Usage="dataTableReader.GetInt16 ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Liczony od zera numeru kolumny</param>
        <summary>Pobiera wartość określonej kolumny jako całkowita 16-bitowych.</summary>
        <returns>Wartość określonej kolumny.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Konwersje nie są wykonywane; w związku z tym, musi już być danych pobranych <xref:System.Int16> lub zwracała wartość do `Int16`.  
  
 Wywołaj <xref:System.Data.DataTableReader.IsDBNull%2A> czy przed wywołaniem tej metody są wartości null.  
  
   
  
## Examples  
 Poniższy przykład wyświetla zawartość kolumny numerowane 2 w ramach przekazany do <xref:System.Data.DataTableReader>. Jeśli kolumna w określonym wierszu ma wartość null, ten kod wyświetla tekst \<NULL >. Jeśli dane w kolumnie nie jest poprawnego typu, przykład wyświetla komunikat o błędzie dla każdego wiersza.  
  
 [!code-csharp[DataWorks DataTableReader.GetInt16#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetInt16/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetInt16#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetInt16/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Indeks przekazywane był poza zakresem od 0 do <see cref="P:System.Data.DataTableReader.FieldCount" /> - 1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Próbowano pobrać dane z usuniętego wiersza.</exception>
        <exception cref="T:System.InvalidOperationException">Nastąpiła próba odczytu lub uzyskać dostępu do kolumny w zamkniętej <see cref="T:System.Data.DataTableReader" />.</exception>
        <exception cref="T:System.InvalidCastException">Określona kolumna nie zawiera całkowita 16-bitowych.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetInt32">
      <MemberSignature Language="C#" Value="public override int GetInt32 (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetInt32(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetInt32(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetInt32 (ordinal As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetInt32(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetInt32 : int -&gt; int" Usage="dataTableReader.GetInt32 ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Liczony od zera numeru kolumny</param>
        <summary>Pobiera wartość określonej kolumny jako całkowita 32-bitowych.</summary>
        <returns>Wartość określonej kolumny.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Konwersje nie są wykonywane; w związku z tym, musi już być danych pobranych <xref:System.Int32> lub zwracała wartość do `Int32`.  
  
 Wywołaj <xref:System.Data.DataTableReader.IsDBNull%2A> czy przed wywołaniem tej metody są wartości null.  
  
   
  
## Examples  
 Poniższy przykład wyświetla zawartość kolumny numerowane 2 w ramach przekazany do <xref:System.Data.DataTableReader>. Jeśli kolumna w określonym wierszu ma wartość null, ten kod wyświetla tekst \<NULL >. Jeśli dane w kolumnie nie jest poprawnego typu, przykład wyświetla komunikat o błędzie dla każdego wiersza.  
  
 [!code-csharp[DataWorks DataTableReader.GetInt32#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetInt32/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetInt32#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetInt32/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Indeks przekazywane był poza zakresem od 0 do <see cref="P:System.Data.DataTableReader.FieldCount" /> - 1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Próbowano pobrać dane z usuniętego wiersza.</exception>
        <exception cref="T:System.InvalidOperationException">Nastąpiła próba odczytu lub uzyskać dostępu do kolumny w zamkniętej <see cref="T:System.Data.DataTableReader" /> .</exception>
        <exception cref="T:System.InvalidCastException">Określona kolumna nie zawiera wartości 32-bitową.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetInt64">
      <MemberSignature Language="C#" Value="public override long GetInt64 (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 GetInt64(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetInt64(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetInt64 (ordinal As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long GetInt64(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetInt64 : int -&gt; int64" Usage="dataTableReader.GetInt64 ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Liczony od zera numeru kolumny</param>
        <summary>Pobiera wartość określonej kolumny jako całkowita 64-bitowych.</summary>
        <returns>Wartość określonej kolumny.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Konwersje nie są wykonywane; w związku z tym, musi już być danych pobranych <xref:System.Int64> lub zwracała wartość do `Int64`.  
  
 Wywołaj <xref:System.Data.DataTableReader.IsDBNull%2A> czy przed wywołaniem tej metody są wartości null.  
  
   
  
## Examples  
 Poniższy przykład wyświetla zawartość kolumny numerowane 2 w ramach przekazany do <xref:System.Data.DataTableReader>. Jeśli kolumna w określonym wierszu ma wartość null, ten kod wyświetla tekst \<NULL >. Jeśli dane w kolumnie nie jest poprawnego typu, przykład wyświetla komunikat o błędzie dla każdego wiersza.  
  
 [!code-csharp[DataWorks DataTableReader.GetInt64#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetInt64/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetInt64#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetInt64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Indeks przekazywane był poza zakresem od 0 do <see cref="P:System.Data.DataTableReader.FieldCount" /> - 1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Próbowano pobrać dane z usuniętego wiersza.</exception>
        <exception cref="T:System.InvalidOperationException">Nastąpiła próba odczytu lub uzyskać dostępu do kolumny w zamkniętej <see cref="T:System.Data.DataTableReader" /> .</exception>
        <exception cref="T:System.InvalidCastException">Określona kolumna nie zawiera wartości liczby całkowitej ze znakiem 64-bitowych.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public override string GetName (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetName(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetName(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetName (ordinal As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ GetName(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetName : int -&gt; string" Usage="dataTableReader.GetName ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Liczony od zera numeru kolumny</param>
        <summary>Pobiera wartość określonej kolumny jako <see cref="T:System.String" />.</summary>
        <returns>Nazwa określonej kolumny.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetName` i <xref:System.Data.DataTableReader.GetOrdinal%2A> metody zapewnienia odwrotność funkcji. Oznacza to, że wywołanie `GetOrdinal` na wartość zwracaną przez wywołanie `GetName` powinna zwrócić pierwotny parametr przekazywany do `GetName`; to samo dotyczy wywoływanie procedur w kolejności przeciwnej.  
  
   
  
## Examples  
 Prosty przykład zawiera procedury, która wyświetla nazwy wszystkich kolumn w ramach określonych `DataTableReader`i pozycję porządkowego kolumny, w oknie konsoli.  
  
 [!code-csharp[DataWorks DataTableReader.GetName#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetName/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetName#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetName/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Indeks przekazywane był poza zakresem od 0 do <see cref="P:System.Data.DataTableReader.FieldCount" /> - 1.</exception>
        <exception cref="T:System.InvalidOperationException">Nastąpiła próba odczytu lub uzyskać dostępu do kolumny w zamkniętej <see cref="T:System.Data.DataTableReader" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetOrdinal">
      <MemberSignature Language="C#" Value="public override int GetOrdinal (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetOrdinal(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetOrdinal(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetOrdinal (name As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetOrdinal(System::String ^ name);" />
      <MemberSignature Language="F#" Value="override this.GetOrdinal : string -&gt; int" Usage="dataTableReader.GetOrdinal name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa kolumny.</param>
        <summary>Pobiera kolumnę porządkowe, biorąc pod uwagę nazwę kolumny.</summary>
        <returns>Numer porządkowy kolumny liczony od zera.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ponieważ większość metod dostarczonych przez <xref:System.Data.DataTableReader> klasy musi być podana przy użyciu numeru porządkowego kolumny, możesz użyć `GetOrdinal` metodę, która pobierze numer kolumny, biorąc pod uwagę nazwę kolumny.  
  
 `GetOrdinal` najpierw wykonuje wyszukiwanie uwzględniana wielkość liter. Jeśli nie powiedzie się, zostanie przeprowadzona drugi wyszukiwanie bez uwzględniania wielkości liter. Jeśli nie zostanie znaleziony numer kolumny `IndexOutOfRangeException` zgłaszany.  
  
 `GetOrdinal` znaki kana i szerokości jest rozróżniana wielkość liter.  
  
 Ponieważ wyszukiwań na podstawie liczba porządkowa są bardziej efektywne niż wyszukiwania o nazwie, jest nieefektywne wywołać `GetOrdinal` w pętli. Oszczędzaj czas, przez wywołanie metody `GetOrdinal` jeden raz i przypisywanie wyniki do zmiennej całkowitej do użycia w ramach pętli  
  
   
  
## Examples  
 Jeśli masz tylko nazwę kolumny, w takim przypadku nazwa kolumny jest podana, przez użytkownika i należy pobrać informacje z kolumny, procedura podobnie do poniższego umożliwia wyodrębnić wymaganych informacji. W tym przykładzie procedury nazwa kolumny, która przyjmuje i zwraca dane, który znajduje się w tej kolumnie dla bieżącego wiersza w <xref:System.Data.DataTableReader> :  
  
 [!code-csharp[DataWorks DataTableReader.GetOrdinal#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetOrdinal/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetOrdinal#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetOrdinal/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nastąpiła próba odczytu lub uzyskać dostępu do kolumny w zamkniętej <see cref="T:System.Data.DataTableReader" />.</exception>
        <exception cref="T:System.ArgumentException">Określona nazwa nie jest prawidłową nazwę kolumny.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetProviderSpecificFieldType">
      <MemberSignature Language="C#" Value="public override Type GetProviderSpecificFieldType (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetProviderSpecificFieldType(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetProviderSpecificFieldType(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetProviderSpecificFieldType (ordinal As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetProviderSpecificFieldType(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetProviderSpecificFieldType : int -&gt; Type" Usage="dataTableReader.GetProviderSpecificFieldType ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Numer porządkowy kolumny liczony od zera.</param>
        <summary>Pobiera typ określonej kolumny w formacie właściwe dla dostawcy.</summary>
        <returns><see cref="T:System.Type" /> Który jest typem danych obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ponieważ <xref:System.Data.DataTableReader> zawsze zwraca wartość typu przechowywane w ramach bazowego <xref:System.Data.DataColumn>, wartość zwracana przez wywołanie metody <xref:System.Data.DataTableReader.GetProviderSpecificFieldType%2A> metoda zawsze zwraca ten sam typ co typ przechowywane w ramach <xref:System.Data.DataTable>. Podczas pracy z <xref:System.Data.DataTableReader> klasy wywoływania <xref:System.Data.DataTableReader.GetProviderSpecificFieldType%2A> metoda zwraca tego samego typu co wywołanie metody <xref:System.Type.GetType%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Indeks przekazywane był poza zakresem od 0 do <see cref="P:System.Data.DataTableReader.FieldCount" /> - 1.</exception>
        <exception cref="T:System.InvalidOperationException">Nastąpiła próba odczytu lub uzyskać dostępu do kolumny w zamkniętej <see cref="T:System.Data.DataTableReader" />.</exception>
        <altmember cref="M:System.Data.DataTableReader.GetFieldType(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetProviderSpecificValue">
      <MemberSignature Language="C#" Value="public override object GetProviderSpecificValue (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object GetProviderSpecificValue(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetProviderSpecificValue(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetProviderSpecificValue (ordinal As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ GetProviderSpecificValue(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetProviderSpecificValue : int -&gt; obj" Usage="dataTableReader.GetProviderSpecificValue ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Liczony od zera numer kolumny, której wartość jest pobierana.</param>
        <summary>Pobiera wartość określonej kolumny w formacie właściwe dla dostawcy.</summary>
        <returns>Wartość określonej kolumny w formacie właściwe dla dostawcy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ponieważ <xref:System.Data.DataTableReader> zawsze zwraca wartość typu przechowywane w ramach bazowego <xref:System.Data.DataColumn>, wartość zwracana przez wywołanie metody <xref:System.Data.DataTableReader.GetProviderSpecificValue%2A> metoda zawsze zwraca dane z tego samego typu co dane przechowywane w <xref:System.Data.DataTable>. Podczas pracy z <xref:System.Data.DataTableReader> klasy wywoływania <xref:System.Data.DataTableReader.GetProviderSpecificValue%2A> metoda zwróci wartość taka sama wartość i wpisz co wywołanie metody <xref:System.Data.DataTableReader.GetValue%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Indeks przekazywane był poza zakresem od 0 do <see cref="P:System.Data.DataTableReader.FieldCount" /> - 1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Próbowano pobrać dane z usuniętego wiersza.</exception>
        <exception cref="T:System.InvalidOperationException">Nastąpiła próba odczytu lub uzyskać dostępu do kolumny w zamkniętej <see cref="T:System.Data.DataTableReader" /></exception>
        <altmember cref="M:System.Data.DataTableReader.GetValue(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetProviderSpecificValues">
      <MemberSignature Language="C#" Value="public override int GetProviderSpecificValues (object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetProviderSpecificValues(object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetProviderSpecificValues(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetProviderSpecificValues (values As Object()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetProviderSpecificValues(cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="override this.GetProviderSpecificValues : obj[] -&gt; int" Usage="dataTableReader.GetProviderSpecificValues values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="values">Tablica obiektów w celu wprowadzenia informacji o typie dla kolumn w <see cref="T:System.Data.DataTableReader" />.</param>
        <summary>Wypełnia tablicę podane informacje o typie właściwe dla dostawcy dla wszystkich kolumn w <see cref="T:System.Data.DataTableReader" />.</summary>
        <returns>Liczba wartości w kolumnie jest kopiowana do tablicy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ponieważ <xref:System.Data.DataTableReader> zawsze zwraca dane typu przechowywane w ramach bazowego <xref:System.Data.DataColumn>, wartości zwracane przez wywołanie metody <xref:System.Data.DataTableReader.GetProviderSpecificValues%2A> metody zawsze ma te same typy danych są przechowywane w <xref:System.Data.DataTable>. Podczas pracy z <xref:System.Data.DataTableReader> klasy wywoływania <xref:System.Data.DataTableReader.GetProviderSpecificValues%2A> metoda zwraca te same wartości i typy co wywołanie metody <xref:System.Data.DataTableReader.GetValues%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Próbowano pobrać dane z usuniętego wiersza.</exception>
        <exception cref="T:System.InvalidOperationException">Nastąpiła próba odczytu lub uzyskać dostępu do kolumny w zamkniętej <see cref="T:System.Data.DataTableReader" />.</exception>
        <altmember cref="M:System.Data.DataTableReader.GetValues(System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="GetSchemaTable">
      <MemberSignature Language="C#" Value="public override System.Data.DataTable GetSchemaTable ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Data.DataTable GetSchemaTable() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetSchemaTable" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetSchemaTable () As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Data::DataTable ^ GetSchemaTable();" />
      <MemberSignature Language="F#" Value="override this.GetSchemaTable : unit -&gt; System.Data.DataTable" Usage="dataTableReader.GetSchemaTable " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.Data.DataTable" /> opisującą kolumny metadanych <see cref="T:System.Data.DataTableReader" />.</summary>
        <returns>A <see cref="T:System.Data.DataTable" /> opisujący metadanych kolumn.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda GetSchemaTable zwraca metadane dotyczące każdej kolumny w następującej kolejności:  
  
|Kolumna elementu DataReader|Opis|  
|-----------------------|-----------------|  
|NazwaKolumny|Nazwa kolumny w postaci, w jakiej jest wyświetlana w <xref:System.Data.DataTable>.|  
|ColumnOrdinal|Numer kolumny|  
|ColumnSize|-1, jeśli <xref:System.Data.Common.SchemaTableColumn.ColumnSize> (lub <xref:System.Data.DataColumn.MaxLength%2A>) właściwość <xref:System.Data.DataColumn> nie może być określony lub nie jest istotne; w przeciwnym razie 0 lub dodatnia liczba całkowita, która zawiera `MaxLength` wartość.|  
|NumericPrecision|Jeśli typ kolumny jest typu liczbowego, jest to maksymalna dokładność kolumny. Jeśli typ kolumny nie jest typu liczbowego, to jest wartość null.|  
|NumericScale|Jeśli typ danych kolumny zawiera składnik skali, zwraca liczbę cyfr po prawej stronie przecinka dziesiętnego. W przeciwnym razie zwraca wartość null.|  
|DataType|Podstawowy typ kolumny.|  
|ProviderType|Wskazuje typ danych kolumny. Jeśli typ danych kolumny zmienia się wiersz po wierszu, ta wartość jest <xref:System.Object>. Ta kolumna nie może zawierać wartości null.|  
|IsLong|`true` Jeśli typ danych kolumny jest <xref:System.String> i jego <xref:System.Data.DataColumn.MaxLength%2A> właściwość ma wartość -1. W przeciwnym razie `false`.|  
|AllowDBNull|`true` Jeśli ustawiono ograniczenie AllowDbNull na wartość true dla kolumny; w przeciwnym razie `false`.|  
|IsReadOnly|`true` Jeśli nie można zmodyfikować kolumny; w przeciwnym razie `false`.|  
|IsRowVersion|`false`, dla każdej kolumny.|  
|IsUnique|`true`: Żadne dwa wiersze w <xref:System.Data.DataTable> może mieć taką samą wartość w tej kolumnie. `IsUnique` gwarantuje to wartość true, jeśli kolumna reprezentuje klucz przez siebie lub czy istnieje ograniczenie typu UNIKATOWEGO, która ma zastosowanie tylko do tej kolumny. `false`: Kolumna może zawierać zduplikowanych wartości w `DataTable`. Domyślnie ta kolumna jest `false`.|  
|IsKey|`true`: Kolumna jest jednym z zestawów kolumn, razem jednoznacznie identyfikują wiersze, które w <xref:System.Data.DataTable>. Zestaw kolumn z `IsKey` równa `true` musi jednoznacznie identyfikować wiersza w `DataTable`. Nie istnieje wymóg ten zestaw kolumn to minimalny zestaw kolumn. Ten zestaw kolumn może zostać wygenerowany na podstawie `DataTable` klucza podstawowego, unikatowego ograniczenia lub unikatowego indeksu. `false`: Kolumna nie jest wymagany do jednoznacznego identyfikowania wiersza. Ta wartość jest `true` Jeśli kolumna uczestniczy w pojedynczym lub złożony klucz podstawowy. W przeciwnym razie jego wartość wynosi `false`.|  
|IsAutoIncrement|`true`: Kolumna przypisuje wartości do nowych wierszy w przyrostach stały. `false`: Kolumny nie przypisuje wartości do nowych wierszy w przyrostach stały. Domyślnie ta kolumna jest `false`.|  
|BaseCatalogName|Nazwa wykazu w magazynie danych, która zawiera kolumny. `Null` Jeśli nie można ustalić nazwy katalogu podstawowego. Wartością domyślną dla tej kolumny jest `null` wartość.|  
|BaseSchemaName|Ta wartość jest zawsze `Null`.|  
|BaseTableName|Nazwa <xref:System.Data.DataTable>.|  
|BaseColumnName|Nazwa kolumny w <xref:System.Data.DataTable>.|  
|AutoIncrementSeed|Wartość <xref:System.Data.DataTable>firmy <xref:System.Data.DataColumn.AutoIncrementSeed%2A> właściwości.|  
|AutoIncrementStep|Wartość <xref:System.Data.DataTable>firmy <xref:System.Data.DataColumn.AutoIncrementStep%2A> właściwości.|  
|defaultValue|Wartość <xref:System.Data.DataColumn>firmy <xref:System.Data.DataColumn.DefaultValue%2A> właściwości.|  
|Wyrażenie|Ciąg wyrażenia, jeśli bieżąca kolumna jest kolumną wyrażenie, a wszystkie kolumny, używany w wyrażeniu należą do tej samej `T:System.Data.DataTable` zawierający kolumny wyrażenia; w przeciwnym razie `null`.|  
|Mapowanie kolumny|<xref:System.Data.MappingType> Wartość skojarzoną z <xref:System.Data.DataColumn>. Typ może być jednym z `Attribute`, `Element`, `Hidden`, lub `SimpleContent`. Wartość domyślna to `Element`.|  
|BaseTableNamespace|Wartość <xref:System.Data.DataTable>firmy <xref:System.Data.DataTable.Namespace%2A> właściwości.|  
|BaseColumnNamespace|Wartość <xref:System.Data.DataColumn>firmy <xref:System.Data.DataColumn.Namespace%2A> właściwości.|  
  
   
  
## Examples  
 W poniższym przykładzie aplikacja konsoli pobiera informacje o schemacie o określonej kolumny. Przekazać `DisplaySchemaTableInfo` procedury <xref:System.Data.DataTableReader> i liczba całkowita reprezentująca porządkowym kolumny w `DataTableReader`, a procedura generuje informacje o schemacie w oknie konsoli.  
  
 [!code-csharp[DataWorks DataTableReader.GetSchemaTable#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetSchemaTable/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetSchemaTable#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetSchemaTable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Data.DataTableReader" /> Jest zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public override string GetString (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetString(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetString(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetString (ordinal As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ GetString(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetString : int -&gt; string" Usage="dataTableReader.GetString ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Liczony od zera numeru kolumny</param>
        <summary>Pobiera wartość określonej kolumny jako ciąg.</summary>
        <returns>Wartość określonej kolumny.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj <xref:System.Data.DataTableReader.IsDBNull%2A> czy przed wywołaniem tej metody są wartości null.  
  
   
  
## Examples  
 Poniższy przykład wyświetla zawartość kolumny numerowane 2 w ramach przekazany do <xref:System.Data.DataTableReader>. Jeśli kolumna w określonym wierszu ma wartość null, ten kod wyświetla tekst \<NULL >. Jeśli dane w kolumnie odpowiedniego typu, przykład jest wyświetlany komunikat o błędzie dla każdego wiersza.  
  
 [!code-csharp[DataWorks DataTableReader.GetString#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetString/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetString#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetString/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Indeks przekazywane był poza zakresem od 0 do <see cref="P:System.Data.DataTableReader.FieldCount" /> - 1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Próbowano pobrać dane z usuniętego wiersza.</exception>
        <exception cref="T:System.InvalidOperationException">Nastąpiła próba odczytu lub uzyskać dostępu do kolumny w zamkniętej <see cref="T:System.Data.DataTableReader" />.</exception>
        <exception cref="T:System.InvalidCastException">Określona kolumna nie zawiera ciągu.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public override object GetValue (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object GetValue(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetValue(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetValue (ordinal As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ GetValue(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetValue : int -&gt; obj" Usage="dataTableReader.GetValue ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Liczony od zera numeru kolumny</param>
        <summary>Pobiera wartość określonej kolumny w formacie natywnym.</summary>
        <returns>Wartość określonej kolumny. Ta metoda zwraca <see langword="DBNull" /> dla kolumn o wartości null.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mimo że można wywołać <xref:System.Data.DataTableReader.IsDBNull%2A> aby zobaczyć, w przypadku wartości null przed wywołaniem tej metody, nie trzeba to zrobić.  
  
   
  
## Examples  
 Poniższy przykład wykonuje iterację przez wszystkie kolumny w bieżącym wierszu w <xref:System.Data.DataTableReader>, wyświetlanie zawartość poszczególnych kolumn i nazwę kolumny. Ogólnie rzecz biorąc Jeśli jest zgodne z zamiarami użytkownika, do pracy ze wszystkimi kolumnami w wierszu pobierane przez <xref:System.Data.DataTableReader>, należy wziąć pod uwagę przy użyciu <xref:System.Data.DataTableReader.GetValues%2A> metody zamiast tego, ponieważ jest bardziej wydajne.  
  
 [!code-csharp[DataWorks DataTableReader.GetValue#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetValue/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetValue#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetValue/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Indeks przekazywane był poza zakresem od 0 do <see cref="P:System.Data.DataTableReader.FieldCount" /> - 1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Próbowano pobrać dane z usuniętego wiersza.</exception>
        <exception cref="T:System.InvalidOperationException">Nastąpiła próba odczytu lub dostęp do kolumn w zamkniętej <see cref="T:System.Data.DataTableReader" /> .</exception>
      </Docs>
    </Member>
    <Member MemberName="GetValues">
      <MemberSignature Language="C#" Value="public override int GetValues (object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetValues(object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetValues(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetValues (values As Object()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetValues(cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="override this.GetValues : obj[] -&gt; int" Usage="dataTableReader.GetValues values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="values">Tablica <see cref="T:System.Object" /> do którego skopiować wartości w kolumnach z <see cref="T:System.Data.DataTableReader" />.</param>
        <summary>Wypełnia tablicę obiektów przy użyciu wartości w kolumnach bieżącego wiersza.</summary>
        <returns>Liczba wartości w kolumnie jest kopiowana do tablicy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku większości aplikacji ta metoda zapewnia skuteczne do pobierania wszystkich kolumn, zamiast oddzielnie pobierania każdej kolumny. Czy zgodne z zamiarami użytkownika, aby pobrać wszystkie wartości w kolumnach z wiersza w <xref:System.Data.DataTableReader>, `GetValues` metoda zapewnia najbardziej wydajne rozwiązanie.  
  
 Możesz przekazać <xref:System.Object> tablicę, która zawiera mniej niż liczba kolumn, które są zawarte w wynikowego wiersza. Ilość danych `Object` Tablica może przechowywać jest kopiowana do tablicy. Można również przekazać `Object` tablicy, której długość jest większa niż liczba kolumn, które są zawarte w wynikowego wiersza, w którym przypadku elementy tablicy dodatkowe pozostaje bez zmian przez wywołanie metody.  
  
 Ta metoda powoduje `DBNull` w tablicy danych wyjściowych dla kolumn o wartości null.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie tablicy, która ma prawidłowy rozmiar, można odczytać wszystkie wartości z bieżącego wiersza w podanym <xref:System.Data.DataTableReader>. Ponadto w przykładzie pokazano, przy użyciu stałych rozmiarach tablicy, która może być mniejszy lub większy niż liczba dostępnych kolumn.  
  
 [!code-csharp[DataWorks DataTableReader.GetValueObject#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetValueObject/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetValueObject#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetValueObject/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Indeks przekazywane był poza zakresem od 0 do <see cref="P:System.Data.DataTableReader.FieldCount" /> - 1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Próbowano pobrać dane z usuniętego wiersza.</exception>
        <exception cref="T:System.InvalidOperationException">Nastąpiła próba odczytu lub uzyskać dostępu do kolumny w zamkniętej <see cref="T:System.Data.DataTableReader" /> .</exception>
      </Docs>
    </Member>
    <Member MemberName="HasRows">
      <MemberSignature Language="C#" Value="public override bool HasRows { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasRows" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTableReader.HasRows" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property HasRows As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool HasRows { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasRows : bool" Usage="System.Data.DataTableReader.HasRows" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Data.DataTableReader" /> zawiera co najmniej jeden wiersz.</summary>
        <value><see langword="true" /> Jeśli <see cref="T:System.Data.DataTableReader" /> zawiera jeden lub więcej wierszy; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `HasRows` Właściwość zwraca informacje dotyczące bieżącego zestawu wyników. Jeśli <xref:System.Data.DataTableReader> zawiera wynik wielu zestawów, należy sprawdzić wartość `HasRows` właściwość natychmiast, po wywołaniu metody <xref:System.Data.DataTableReader.NextResult%2A> metody w celu ustalenia, czy nowy zestaw wyników zawiera wiersze.  
  
 Użyj `HasRows` właściwości, aby uniknąć konieczności wywołać <xref:System.Data.DataTableReader.Read%2A> metody <xref:System.Data.DataTableReader> , jeśli nie ma żadnych wierszy w ramach bieżącego zestawu wyników.  
  
   
  
## Examples  
 Poniższy przykład wypełnia dwa <xref:System.Data.DataTable> wystąpień z danymi. Pierwszy <xref:System.Data.DataTable> zawiera ona jeden wiersz, a druga nie zawiera wierszy. Przykład tworzy następnie <xref:System.Data.DataTableReader> zawiera zarówno <xref:System.Data.DataTable> obiektów i wywołuje metodę PrintData, aby wyświetlić zawartość poszczególnych usług, sprawdzając wartość <xref:System.Data.DataTableReader.HasRows%2A> właściwości każdego przed jego sprawia, że wywołanie PrintData.  
  
 [!code-csharp[DataWorks DataTableReader.HasRows#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.HasRows/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.HasRows#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.HasRows/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nastąpiła próba można pobrać informacji na temat zamkniętej <see cref="T:System.Data.DataTableReader" />.</exception>
        <altmember cref="M:System.Data.DataTableReader.NextResult" />
        <altmember cref="M:System.Data.DataTableReader.Read" />
      </Docs>
    </Member>
    <Member MemberName="IsClosed">
      <MemberSignature Language="C#" Value="public override bool IsClosed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClosed" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTableReader.IsClosed" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsClosed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsClosed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsClosed : bool" Usage="System.Data.DataTableReader.IsClosed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Data.DataTableReader" /> jest zamknięty.</summary>
        <value><see langword="true" /> Jeśli <see cref="T:System.Data.DataTableReader" /> jest zamknięty; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTableReader.Close%2A> to jedyna metoda i `IsClosed` i <xref:System.Data.DataTableReader.RecordsAffected%2A> to jedyne właściwości, które mogą być udostępniane po <xref:System.Data.DataTableReader> zostało zamknięte.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDBNull">
      <MemberSignature Language="C#" Value="public override bool IsDBNull (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsDBNull(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.IsDBNull(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsDBNull (ordinal As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsDBNull(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.IsDBNull : int -&gt; bool" Usage="dataTableReader.IsDBNull ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Liczony od zera numeru kolumny</param>
        <summary>Pobiera wartość wskazującą, czy kolumna zawiera wartości, nie istnieje lub nie istnieje.</summary>
        <returns><see langword="true" /> Jeśli wartość określona kolumna jest odpowiednikiem <see cref="T:System.DBNull" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołać tę metodę, aby sprawdzić, czy przed wywołaniem metody get wpisane są wartości w kolumnie o wartości null (na przykład <xref:System.Data.DataTableReader.GetByte%2A>, <xref:System.Data.DataTableReader.GetChar%2A>i tak dalej), aby uniknąć zgłaszania błędów.  
  
   
  
## Examples  
 Poniższy przykład wyświetla zawartość kolumny numerowane 2 w ramach przekazany do <xref:System.Data.DataTableReader>. Jeśli kolumna w określonym wierszu ma wartość null, ten kod wyświetla tekst \<NULL >. Jeśli dane w kolumnie odpowiedniego typu, przykład jest wyświetlany komunikat o błędzie dla każdego wiersza.  
  
 [!code-csharp[DataWorks DataTableReader.IsDbNull#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.IsDbNull/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.IsDbNull#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.IsDbNull/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Indeks przekazywane był poza zakresem od 0 do <see cref="P:System.Data.DataTableReader.FieldCount" /> - 1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Próbowano pobrać dane z usuniętego wiersza.</exception>
        <exception cref="T:System.InvalidOperationException">Nastąpiła próba odczytu lub uzyskać dostępu do kolumny w zamkniętej <see cref="T:System.Data.DataTableReader" /> .</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Item">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera wartość określonej kolumny w formacie natywnym.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public override object this[int ordinal] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTableReader.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overrides ReadOnly Property Item(ordinal As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ default[int] { System::Object ^ get(int ordinal); };" />
      <MemberSignature Language="F#" Value="member this.Item(int) : obj" Usage="System.Data.DataTableReader.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Numer porządkowy kolumny liczony od zera.</param>
        <summary>Pobiera wartość określonej kolumny w formacie natywnym danego numeru kolumny.</summary>
        <value>Wartość określonej kolumny w formacie natywnym.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie dla <xref:System.Data.DataTableReader.Item%2A> działa identycznie do <xref:System.Data.DataTableReader.GetValue%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład wyświetla zawartość wszystkich kolumn wszystkich wierszy z podanym <xref:System.Data.DataTableReader>. Kod używa <xref:System.Data.DataTableReader.Item%2A> — metoda (indeksatora w Microsoft C#) można pobrać wartość, która jest zawarta w każdej kolumnie.  
  
 [!code-csharp[DataWorks DataTableReader.Item#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.Item/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.Item#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.Item/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">Indeks przekazywane był poza zakresem od 0 do <see cref="P:System.Data.DataTableReader.FieldCount" /> - 1.</exception>
        <altmember cref="M:System.Data.DataTableReader.GetValue(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public override object this[string name] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTableReader.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overrides ReadOnly Property Item(name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ default[System::String ^] { System::Object ^ get(System::String ^ name); };" />
      <MemberSignature Language="F#" Value="member this.Item(string) : obj" Usage="System.Data.DataTableReader.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa kolumny.</param>
        <summary>Pobiera wartość określonej kolumny w formacie natywnym otrzymuje nazwę kolumny.</summary>
        <value>Wartość określonej kolumny w formacie natywnym.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest rozróżniana wielkość liter wyszukiwanie jest wykonywane jako pierwsze. Jeśli nie powiedzie się, zostanie przeprowadzona drugi wyszukiwanie bez uwzględniania wielkości liter.  
  
 Ta metoda jest znaki kana szerokość nie liter.  
  
 Ta przeciążoną wersję <xref:System.Data.DataTableReader.Item%2A> odnosi się do wywoływania <xref:System.Data.DataTableReader.GetOrdinal%2A> metody, a następnie wywoływania <xref:System.Data.DataTableReader.GetValue%2A> metody.  
  
   
  
## Examples  
 Biorąc pod uwagę <xref:System.Data.DataTableReader> i nazwę kolumny w procedurze GetValueByName zwraca wartość określonej kolumny. Przed wywołaniem tej procedury, należy utworzyć nowy <xref:System.Data.DataTableReader> wystąpienia i wywołanie metody odczytu co najmniej jeden raz umieść wskaźnik wiersza w wierszu danych.  
  
 [!code-csharp[DataWorks DataTableReader.ItemName#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.ItemName/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.ItemName#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.ItemName/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Określona nazwa nie jest prawidłową nazwę kolumny.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Próbowano pobrać dane z usuniętego wiersza.</exception>
        <exception cref="T:System.InvalidOperationException">Nastąpiła próba odczytu lub uzyskać dostępu do kolumny w zamkniętej <see cref="T:System.Data.DataTableReader" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="NextResult">
      <MemberSignature Language="C#" Value="public override bool NextResult ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool NextResult() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.NextResult" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function NextResult () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool NextResult();" />
      <MemberSignature Language="F#" Value="override this.NextResult : unit -&gt; bool" Usage="dataTableReader.NextResult " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Przesuwa <see cref="T:System.Data.DataTableReader" /> do następnego zestawu wyników, jeśli istnieje.</summary>
        <returns><see langword="true" /> Jeśli wystąpił inny zestaw wyników; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Używani do przetwarzania wiele wyników, które mogą być generowane przez utworzenie <xref:System.Data.DataTableReader> za pośrednictwem <xref:System.Data.DataSet> zawierający co najmniej dwie tabele lub tablica, która zawiera co najmniej dwóch <xref:System.Data.DataTable> wystąpień.  
  
 Nowy <xref:System.Data.DataTableReader> jest ustawiony na pierwszego wyniku.  
  
   
  
## Examples  
 W poniższym przykładzie metoda TestConstructor tworzy dwa <xref:System.Data.DataTable> wystąpień. W celu przedstawienia tej Konstruktor <xref:System.Data.DataTableReader> klasy Przykładowa aplikacja tworzy nową `DataTableReader` na podstawie tablicy, która zawiera dwa `DataTables`i wykonuje prostą operacją, Drukowanie zawartości z pierwszego mało kolumn w konsoli okno. Aby przetestować tę aplikację, Utwórz nową aplikację konsoli i wklej przykładowy kod do nowo utworzony plik.  
  
 [!code-csharp[DataWorks DataTableReader.NextResult#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.NextResult/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.NextResult#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.NextResult/VB/source.vb#1)]  
  
 W oknie konsoli zostaną wyświetlone następujące wyniki:  
  
```  
1 Mary  
2 Andy  
3 Peter  
4 Russ  
1 Wireless Network Card  
2 Hard Drive  
3 Monitor  
4 CPU  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nastąpiła próba przejść w ramach zamkniętego <see cref="T:System.Data.DataTableReader" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override bool Read ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Read() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.Read" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Read();" />
      <MemberSignature Language="F#" Value="override this.Read : unit -&gt; bool" Usage="dataTableReader.Read " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Przesuwa <see cref="T:System.Data.DataTableReader" /> do następnego rekordu.</summary>
        <returns><see langword="true" /> Jeśli wystąpił kolejny wiersz do odczytania. w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślne położenie <xref:System.Data.DataTableReader> przed pierwszym rekordzie. W związku z tym, należy wywołać `Read` można rozpocząć uzyskiwanie dostępu do żadnych danych.  
  
   
  
## Examples  
 Procedura PrintColumns w pętli wszystkich wierszy w <xref:System.Data.DataTableReader>, wyświetlanie zawartość każdej kolumny w oknie konsoli.  
  
 [!code-csharp[DataWorks DataTableReader.Read#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.Read/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.Read#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.Read/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nastąpiła próba odczytu lub uzyskać dostępu do kolumny w zamkniętej <see cref="T:System.Data.DataTableReader" /> .</exception>
      </Docs>
    </Member>
    <Member MemberName="RecordsAffected">
      <MemberSignature Language="C#" Value="public override int RecordsAffected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecordsAffected" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTableReader.RecordsAffected" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property RecordsAffected As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int RecordsAffected { int get(); };" />
      <MemberSignature Language="F#" Value="member this.RecordsAffected : int" Usage="System.Data.DataTableReader.RecordsAffected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę wierszy wstawionych, zmieniony lub usunięty przez wykonanie instrukcji SQL.</summary>
        <value><see cref="T:System.Data.DataTableReader" /> Nie obsługuje tej właściwości i zawsze zwraca wartość 0.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="DataTableReader" FullName="System.Data.DataTableReader">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a35db2a0ad5babd0c3ea5fb984c8d43b0fdbc6cf" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36746410" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class DataTableReader : System.Data.Common.DbDataReader" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit DataTableReader extends System.Data.Common.DbDataReader" />
  <TypeSignature Language="DocId" Value="T:System.Data.DataTableReader" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DataTableReader&#xA;Inherits DbDataReader" />
  <TypeSignature Language="C++ CLI" Value="public ref class DataTableReader sealed : System::Data::Common::DbDataReader" />
  <TypeSignature Language="F#" Value="type DataTableReader = class&#xA;    inherit DbDataReader" />
  <AssemblyInfo>
    <AssemblyName>System.Data</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Data.Common</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Data.Common.DbDataReader</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <see cref="T:System.Data.DataTableReader" /> Uzyskuje zawartość jednego lub więcej <see cref="T:System.Data.DataTable" /> obiekty w postaci jednego lub więcej zestawów wyników tylko do odczytu, tylko do przodu.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTableReader> Podobne jak w przypadku innych czytnik danych, takich jak działa <xref:System.Data.SqlClient.SqlDataReader>, ale <xref:System.Data.DataTableReader> przewiduje Iterowanie po wierszy w <xref:System.Data.DataTable>. Innymi słowy zapewnia Iterowanie po wierszy w pamięci podręcznej. Buforowane dane można modyfikować podczas <xref:System.Data.DataTableReader> jest aktywny, a czytnik również automatycznie obsługuje położenia.  
  
 Po utworzeniu <xref:System.Data.DataTableReader> z <xref:System.Data.DataTable>, powstałe w ten sposób <xref:System.Data.DataTableReader> obiekt zawiera jeden zestaw danych o tej samej jako wyników <xref:System.Data.DataTable> z którego został utworzony, z wyjątkiem wszystkie wiersze, które zostały oznaczone jako usunięte. Kolumny pojawiają się w tej samej kolejności jak w oryginalnym <xref:System.Data.DataTable>. Struktura zwrócony wynik jest takie same jak w schemat i dane oryginalne <xref:System.Data.DataTable>. A <xref:System.Data.DataTableReader> utworzony przez wywołanie metody <xref:System.Data.DataSet.CreateDataReader*> metody <xref:System.Data.DataSet> obiekt zawiera wiele zestawów wyników, jeśli <xref:System.Data.DataSet> zawiera więcej niż jedna tabela. Wyniki są w tej samej kolejności jak <xref:System.Data.DataTable> obiekty w <xref:System.Data.DataTableCollection> z <xref:System.Data.DataSet> obiektu.  
  
 Zestaw wyników zwrócony zawiera tylko bieżącą wersję każdego <xref:System.Data.DataRow>; są pomijane wiersze, które są oznaczone do usunięcia.  
  
 `DataTableReader` Zapewnia stabilnego iteratora; oznacza to, że zawartość `DataTableReader` nie zostały unieważnione, jeśli rozmiar kolekcji źródłowej jest modyfikowany podczas iteracji. Na przykład, jeśli jeden lub więcej wierszy w <xref:System.Data.DataTable.Rows%2A> kolekcji zostały usunięte lub usunięte podczas iteracji, bieżącą pozycję w `DataTableReader` są odpowiednio przechowywane i unieważnia iteratora.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Data.DataTableReader" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataTableReader (System.Data.DataTable dataTable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Data.DataTable dataTable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.#ctor(System.Data.DataTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataTableReader(System::Data::DataTable ^ dataTable);" />
      <MemberSignature Language="F#" Value="new System.Data.DataTableReader : System.Data.DataTable -&gt; System.Data.DataTableReader" Usage="new System.Data.DataTableReader dataTable" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dataTable" Type="System.Data.DataTable" />
      </Parameters>
      <Docs>
        <param name="dataTable">
          <see cref="T:System.Data.DataTable" /> z którego nowe <see cref="T:System.Data.DataTableReader" /> uzyskuje jej zestaw wyników.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Data.DataTableReader" /> przy użyciu danych z podane <see cref="T:System.Data.DataTable" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataTableReader (System.Data.DataTable[] dataTables);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Data.DataTable[] dataTables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.#ctor(System.Data.DataTable[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dataTables As DataTable())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataTableReader(cli::array &lt;System::Data::DataTable ^&gt; ^ dataTables);" />
      <MemberSignature Language="F#" Value="new System.Data.DataTableReader : System.Data.DataTable[] -&gt; System.Data.DataTableReader" Usage="new System.Data.DataTableReader dataTables" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dataTables" Type="System.Data.DataTable[]" />
      </Parameters>
      <Docs>
        <param name="dataTables">Tablica <see cref="T:System.Data.DataTable" /> obiektów, które dostarcza wyniki dla nowego <see cref="T:System.Data.DataTableReader" /> obiektu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Data.DataTableReader" /> przy użyciu dostarczonego tablica <see cref="T:System.Data.DataTable" /> obiektów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli musisz utworzyć <xref:System.Data.DataTableReader> na podstawie wszystkie lub podzbiór tabel w ramach określonej <xref:System.Data.DataSet>, wywołaj `DataSet`w <xref:System.Data.DataSet.CreateDataReader*> — metoda. Jeśli chcesz utworzyć nową <xref:System.Data.DataTableReader> wystąpienia na podstawie grupy `DataTable` wystąpień, które nie są w inny sposób powiązane, użyj tego konstruktora. Mogą również czerpać korzyści z tego konstruktora, aby zmienić kolejność `DataTables` w `DataTableReader`, jeśli ich kolejności w swoim źródłem `DataSet` odpowiada Twoim potrzebom.  
  
   
  
## Examples  
 W poniższym przykładzie metoda TestConstructor tworzy dwa <xref:System.Data.DataTable> wystąpień. W celu zaprezentowania tego konstruktora dla <xref:System.Data.DataTableReader> klasy, tworzy nową próbkę `DataTableReader` na podstawie tablicy, która zawiera dwa `DataTables`i wykonuje operację proste Drukowanie zawartości z pierwszego mało kolumn do konsoli okno. W celu przetestowania tej aplikacji, Utwórz nową aplikację konsoli, a następnie wklej przykładowy kod do nowo utworzonego pliku.  
  
 [!code-csharp[DataWorks DataTableReader.ctor#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.ctor/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.ctor/VB/source.vb#1)]  
  
 W oknie konsoli wyświetla następujące wyniki:  
  
```  
1 Mary  
2 Andy  
3 Peter  
4 Russ  
1 Wireless Network Card  
2 Hard Drive  
3 Monitor  
4 CPU  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Close();" />
      <MemberSignature Language="F#" Value="override this.Close : unit -&gt; unit" Usage="dataTableReader.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zamyka bieżące <see cref="T:System.Data.DataTableReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływanie `Close()` na zamkniętej `DataTableReader` obiektu nie wygenerował błąd.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Depth">
      <MemberSignature Language="C#" Value="public override int Depth { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Depth" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTableReader.Depth" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Depth As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Depth { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Depth : int" Usage="System.Data.DataTableReader.Depth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Głębokość zagnieżdżenia bieżącego wiersza <see cref="T:System.Data.DataTableReader" />.</summary>
        <value>Głębokość zagnieżdżenia bieżącego wiersza; zawsze zero.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `DataTableReader` nie obsługuje zagnieżdżenia. `Depth` Właściwość zawsze zwraca wartość zero.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FieldCount">
      <MemberSignature Language="C#" Value="public override int FieldCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 FieldCount" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTableReader.FieldCount" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property FieldCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int FieldCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.FieldCount : int" Usage="System.Data.DataTableReader.FieldCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zwraca liczbę kolumn w bieżącym wierszu.</summary>
        <value>Gdy nie znajduje się w zestawie prawidłowy wynik 0; w przeciwnym razie liczba kolumn w bieżącym wierszu.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Nastąpiła próba pobrania liczba pól w zamkniętej <see cref="T:System.Data.DataTableReader" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetBoolean">
      <MemberSignature Language="C#" Value="public override bool GetBoolean (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool GetBoolean(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetBoolean(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBoolean (ordinal As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool GetBoolean(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetBoolean : int -&gt; bool" Usage="dataTableReader.GetBoolean ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Numer porządkowy kolumny liczony od zera.</param>
        <summary>Pobiera wartość określonej kolumny jako <see cref="T:System.Boolean" />.</summary>
        <returns>Wartość określonej kolumny.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Konwersje nie są wykonywane; w związku z tym dane pobrane musi już być typu Boolean lub taki sam jak wartość logiczną lub zostanie wygenerowany wyjątek.  
  
 Wywołanie <xref:System.Data.DataTableReader.IsDBNull%2A> czy przed wywołaniem tej metody są wartości null.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono zawartości kolumny numerowane 2 w ramach przekazany do <xref:System.Data.DataTableReader>. Jeśli wartość kolumny w obrębie określonego wiersza jest pusta, kod wyświetla tekst \<NULL >. Jeśli dane w kolumnie nie jest poprawny typ, pojawi się komunikat o błędzie dla każdego wiersza.  
  
 [!code-csharp[DataWorks DataTableReader.GetBoolean#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetBoolean/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetBoolean#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetBoolean/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Przekazany Indeks wykraczał poza z zakresu od 0 do <see cref="P:System.Data.DataTableReader.FieldCount" /> - 1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Została podjęta próba pobrania danych z usuniętym wierszu.</exception>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę odczytu lub uzyskać dostępu do kolumny w zamkniętej <see cref="T:System.Data.DataTableReader" />.</exception>
        <exception cref="T:System.InvalidCastException">Określona kolumna nie zawiera <see langword="Boolean" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetByte">
      <MemberSignature Language="C#" Value="public override byte GetByte (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8 GetByte(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetByte(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByte (ordinal As Integer) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Byte GetByte(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetByte : int -&gt; byte" Usage="dataTableReader.GetByte ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Numer porządkowy kolumny liczony od zera.</param>
        <summary>Pobiera wartość określonej kolumny w postaci bajtów.</summary>
        <returns>Wartość określonej kolumny.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Konwersje nie są wykonywane; w związku z tym dane pobrane musi być taki sam jak bajtem lub bajtów.  
  
 Wywołanie <xref:System.Data.DataTableReader.IsDBNull%2A> czy przed wywołaniem tej metody są wartości null.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono zawartości kolumny numerowane 2 w ramach przekazany do <xref:System.Data.DataTableReader>. Jeśli wartość kolumny w obrębie określonego wiersza jest pusta, kod wyświetla tekst \<NULL >. Jeśli dane w kolumnie nie jest poprawny, pojawi się komunikat o błędzie dla każdego wiersza.  
  
 [!code-csharp[DataWorks DataTableReader.GetByte#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetByte/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetByte#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetByte/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Przekazany Indeks wykraczał poza z zakresu od 0 do <see cref="P:System.Data.DataTableReader.FieldCount" /> - 1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Została podjęta próba pobrania danych z usuniętym wierszu.</exception>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę odczytu lub uzyskać dostępu do kolumny w zamkniętej <see langword="DataTableReader" />.</exception>
        <exception cref="T:System.InvalidCastException">Określona kolumna nie zawiera typu byte.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override long GetBytes (int ordinal, long dataIndex, byte[] buffer, int bufferIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 GetBytes(int32 ordinal, int64 dataIndex, unsigned int8[] buffer, int32 bufferIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetBytes(System.Int32,System.Int64,System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (ordinal As Integer, dataIndex As Long, buffer As Byte(), bufferIndex As Integer, length As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long GetBytes(int ordinal, long dataIndex, cli::array &lt;System::Byte&gt; ^ buffer, int bufferIndex, int length);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : int * int64 * byte[] * int * int -&gt; int64" Usage="dataTableReader.GetBytes (ordinal, dataIndex, buffer, bufferIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
        <Parameter Name="dataIndex" Type="System.Int64" />
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="bufferIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Numer porządkowy kolumny liczony od zera.</param>
        <param name="dataIndex">Indeks w polu, w którym można uruchomić operacji odczytu.</param>
        <param name="buffer">Bufor, do której mają być odczytywane w strumieniu bajtów.</param>
        <param name="bufferIndex">Indeks w buforze, od którego należy rozpocząć wprowadzania danych.</param>
        <param name="length">Maksymalna długość ma zostać skopiowany do buforu.</param>
        <summary>Odczytuje strumień bajtów, zaczynając od przesunięcia kolumny określony w buforze w postaci tablicy, zaczynając od przesunięcia określony bufor.</summary>
        <returns>Rzeczywista liczba bajtów odczytanych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetBytes` Zwraca liczby dostępnych bajtów w polu. W większości przypadków jest to dokładnie długość pola. Jednak zwrócona liczba może być mniejsza niż wartość true, długość pola Jeśli `GetBytes` został już użyty do uzyskania bajtów z pola. Może to być sprawa, na przykład, jeśli <xref:System.Data.DataTableReader> odczytuje struktury dużej ilości danych w buforze  
  
 W przypadku przekazania buforu, który jest `null` (`Nothing` w języku Visual Basic), `GetBytes` zwraca długość całe pole w bajtach nie rozmiar pozostałych na podstawie parametru przesunięcia buforu.  
  
 Konwersje nie są wykonywane; w związku z tym dane pobrane już musi być tablica bajtów lub taki sam jak tablicy bajtów.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Data.DataTableReader> na podstawie danych w przykładowej bazy danych AdventureWorks i zapisuje pobrać każdego obrazu do osobnego pliku w folderze C:\. Aby przetestować tę aplikację, Utwórz nową aplikację konsoli odwoływać się do zestawu o System.Drawing.dll i wklej przykładowy kod do nowo utworzonego pliku.  
  
 [!code-csharp[DataWorks DataTableReader.GetBytes#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetBytes/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetBytes#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetBytes/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Przekazany Indeks wykraczał poza z zakresu od 0 do <see cref="P:System.Data.DataTableReader.FieldCount" /> - 1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Została podjęta próba pobrania danych z usuniętym wierszu.</exception>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę odczytu lub uzyskać dostępu do kolumny w zamkniętej <see langword="DataTableReader" />.</exception>
        <exception cref="T:System.InvalidCastException">Określona kolumna nie zawiera tablicy bajtów.</exception>
        <altmember cref="M:System.Data.DataTableReader.GetChars(System.Int32,System.Int64,System.Char[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetChar">
      <MemberSignature Language="C#" Value="public override char GetChar (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance char GetChar(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetChar(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetChar (ordinal As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override char GetChar(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetChar : int -&gt; char" Usage="dataTableReader.GetChar ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Numer porządkowy kolumny liczony od zera.</param>
        <summary>Pobiera wartość określonej kolumny jako znak.</summary>
        <returns>Wartość kolumny.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Konwersje nie są wykonywane; w związku z tym dane pobrane musi być taki sam jak znak lub znak.  
  
 Wywołanie <xref:System.Data.DataTableReader.IsDBNull%2A> czy przed wywołaniem tej metody są wartości null.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono zawartości kolumny numerowane 2 w ramach przekazany element DataTableReader. Jeśli wartość kolumny w obrębie określonego wiersza jest pusta, kod wyświetla tekst \<NULL >. Jeśli dane w kolumnie nie jest poprawny, pojawi się komunikat o błędzie dla każdego wiersza.  
  
 [!code-csharp[DataWorks DataTableReader.GetChar#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetChar/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetChar#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetChar/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Przekazany Indeks wykraczał poza z zakresu od 0 do <see cref="P:System.Data.DataTableReader.FieldCount" /> - 1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Została podjęta próba pobrania danych z usuniętym wierszu.</exception>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę odczytu lub uzyskać dostępu do kolumny w zamkniętej <see langword="DataTableReader" />.</exception>
        <exception cref="T:System.InvalidCastException">Określone pole nie zawiera znaku.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override long GetChars (int ordinal, long dataIndex, char[] buffer, int bufferIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 GetChars(int32 ordinal, int64 dataIndex, char[] buffer, int32 bufferIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetChars(System.Int32,System.Int64,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetChars (ordinal As Integer, dataIndex As Long, buffer As Char(), bufferIndex As Integer, length As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long GetChars(int ordinal, long dataIndex, cli::array &lt;char&gt; ^ buffer, int bufferIndex, int length);" />
      <MemberSignature Language="F#" Value="override this.GetChars : int * int64 * char[] * int * int -&gt; int64" Usage="dataTableReader.GetChars (ordinal, dataIndex, buffer, bufferIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
        <Parameter Name="dataIndex" Type="System.Int64" />
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="bufferIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Numer porządkowy kolumny liczony od zera.</param>
        <param name="dataIndex">Indeks w polu, w którym można uruchomić operacji odczytu.</param>
        <param name="buffer">Bufor, do której mają być odczytywane w strumieniu znaków.</param>
        <param name="bufferIndex">Indeks w buforze, od którego należy rozpocząć wprowadzania danych.</param>
        <param name="length">Maksymalna długość ma zostać skopiowany do buforu.</param>
        <summary>Zwraca wartość określonej kolumny w postaci tablicy znaków.</summary>
        <returns>Rzeczywista liczba znaków do odczytu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetChars` Zwraca liczbę znaków dostępne w tym polu. W większości przypadków jest to dokładnie długość pola. Jednak zwrócona liczba może być mniejsza niż wartość true, długość pola Jeśli `GetChars` został już użyty do uzyskania znaków w polu.  
  
 Rzeczywista liczba znaków do odczytu może być mniejsza niż żądana długość, gdy zostanie osiągnięty koniec pola. W przypadku przekazania buforu, który ma wartość null (`Nothing` w języku Visual Basic), `GetChars` zwraca długość pola całego znaków, nie rozmiar pozostałych na podstawie parametru przesunięcia buforu.  
  
 Konwersje nie są wykonywane; w związku z tym dane mają zostać pobrane już musi być tablicą znak lub taki sam jak tablicy znaków.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano `GetChars` metody. `TestGetChars` Metoda oczekuje do przekazania `DataTableReader` wypełnione dwie kolumny danych: Nazwa pliku, w pierwszej kolumnie i tablicy znaków w ciągu sekundy. Ponadto `TestGetChars` pozwala określić rozmiar buforu, która będzie używana jako odczytuje dane z tablicy znaków w `DataTableReader`. `TestGetChars` Tworzy plik odpowiadający każdego wiersza danych w `DataTableReader`, za pomocą dostarczonych danych w pierwszej kolumnie `DataTableReader` jako nazwę pliku.  
  
 Ta procedura przedstawia użycie `GetChars` metody odczytywanie danych, które były przechowywane w `DataTable` jako tablica znaków. Innego typu danych powoduje, że `GetChars` metodę, aby zgłosić `InvalidCastException`.  
  
 [!code-csharp[DataWorks DataTableReader.GetChars#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetChars/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetChars/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Przekazany Indeks wykraczał poza z zakresu od 0 do <see cref="P:System.Data.DataTableReader.FieldCount" /> - 1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Została podjęta próba pobrania danych z usuniętym wierszu.</exception>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę odczytu lub uzyskać dostępu do kolumny w zamkniętej <see langword="DataTableReader" />.</exception>
        <exception cref="T:System.InvalidCastException">Określona kolumna nie zawiera tablicy znaków.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetDataTypeName">
      <MemberSignature Language="C#" Value="public override string GetDataTypeName (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetDataTypeName(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetDataTypeName(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetDataTypeName (ordinal As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ GetDataTypeName(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetDataTypeName : int -&gt; string" Usage="dataTableReader.GetDataTypeName ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Numer porządkowy kolumny liczony od zera.</param>
        <summary>Pobiera ciąg reprezentujący typ danych dla określonej kolumny.</summary>
        <returns>Ciąg reprezentujący typ danych kolumny.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTableReader.GetDataTypeName%2A> Metoda zawsze zwraca typ podstawowych <xref:System.Data.DataColumn> zamiast typu specyficznego dla dostawcy.  
  
   
  
## Examples  
 Następującej aplikacji konsoli zostanie wyświetlona lista pól i ich nazwy typ z prostą <xref:System.Data.DataTable>:  
  
 [!code-csharp[DataWorks DataTableReader.GetDataTypeName#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetDataTypeName/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetDataTypeName#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetDataTypeName/VB/source.vb#1)]  
  
 W oknie konsoli wyświetla następujące wyniki:  
  
```  
ID: Int32  
Name: String  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Przekazany Indeks wykraczał poza z zakresu od 0 do <see cref="P:System.Data.DataTableReader.FieldCount" /> - 1.</exception>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę odczytu lub uzyskać dostępu do kolumny w zamkniętej <see cref="T:System.Data.DataTableReader" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetDateTime">
      <MemberSignature Language="C#" Value="public override DateTime GetDateTime (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.DateTime GetDateTime(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetDateTime(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetDateTime (ordinal As Integer) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override DateTime GetDateTime(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetDateTime : int -&gt; DateTime" Usage="dataTableReader.GetDateTime ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Numer porządkowy kolumny liczony od zera.</param>
        <summary>Pobiera wartość określonej kolumny jako <see cref="T:System.DateTime" /> obiektu.</summary>
        <returns>Wartość określonej kolumny.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Konwersje nie są wykonywane; w związku z tym dane pobrane musi już być <xref:System.DateTime> lub taki sam jak `DataTime`.  
  
 Wywołanie <xref:System.Data.DataTableReader.IsDBNull%2A> czy przed wywołaniem tej metody są wartości null.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono zawartości kolumny numerowane 2 w ramach przekazany do <xref:System.Data.DataTableReader>. Jeśli wartość kolumny w obrębie określonego wiersza jest pusta, kod wyświetla tekst \<NULL >. Jeśli dane w kolumnie nie jest poprawny, pojawi się komunikat o błędzie dla każdego wiersza.  
  
 [!code-csharp[DataWorks DataTableReader.GetDateTime#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetDateTime/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetDateTime#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetDateTime/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Przekazany Indeks wykraczał poza z zakresu od 0 do <see cref="P:System.Data.DataTableReader.FieldCount" /> - 1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Została podjęta próba pobrania danych z usuniętym wierszu.</exception>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę odczytu lub uzyskać dostępu do kolumny w zamkniętej <see langword="DataTableReader" />.</exception>
        <exception cref="T:System.InvalidCastException">Określona kolumna nie zawiera wartości daty/godziny.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetDecimal">
      <MemberSignature Language="C#" Value="public override decimal GetDecimal (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Decimal GetDecimal(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetDecimal(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetDecimal (ordinal As Integer) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Decimal GetDecimal(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetDecimal : int -&gt; decimal" Usage="dataTableReader.GetDecimal ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Numer porządkowy kolumny liczony od zera.</param>
        <summary>Pobiera wartość określonej kolumny jako <see cref="T:System.Decimal" />.</summary>
        <returns>Wartość określonej kolumny.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Konwersje nie są wykonywane; w związku z tym dane pobrane musi już być <xref:System.Decimal> lub taki sam jak `Decimal`.  
  
 Wywołanie <xref:System.Data.DataTableReader.IsDBNull%2A> czy przed wywołaniem tej metody są wartości null.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono zawartości kolumny numerowane 2 w ramach przekazany do <xref:System.Data.DataTableReader>. Jeśli wartość kolumny w obrębie określonego wiersza jest pusta, kod wyświetla tekst \<NULL >. Jeśli dane w kolumnie nie jest poprawny, pojawi się komunikat o błędzie dla każdego wiersza.  
  
 [!code-csharp[DataWorks DataTableReader.GetDecimal#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetDecimal/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetDecimal#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetDecimal/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Przekazany Indeks wykraczał poza z zakresu od 0 do <see cref="P:System.Data.DataTableReader.FieldCount" /> - 1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Została podjęta próba pobrania danych z usuniętym wierszu.</exception>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę odczytu lub uzyskać dostępu do kolumny w zamkniętej <see langword="DataTableReader" />.</exception>
        <exception cref="T:System.InvalidCastException">Określona kolumna nie zawiera <see langword="Decimal" /> wartość.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetDouble">
      <MemberSignature Language="C#" Value="public override double GetDouble (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance float64 GetDouble(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetDouble(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetDouble (ordinal As Integer) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override double GetDouble(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetDouble : int -&gt; double" Usage="dataTableReader.GetDouble ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Liczony od zera numer kolumny.</param>
        <summary>Pobiera wartość kolumny jako podwójnej precyzji liczba zmiennoprzecinkowa.</summary>
        <returns>Wartość określonej kolumny.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Konwersje nie są wykonywane; w związku z tym dane pobrane musi już być podwójnej precyzji liczba zmiennoprzecinkowa lub musi być taki sam jak podwójnej precyzji liczba zmiennoprzecinkowa.  
  
 Wywołanie <xref:System.Data.DataTableReader.IsDBNull%2A> czy przed wywołaniem tej metody są wartości null.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono zawartości kolumny numerowane 2 w ramach przekazany do <xref:System.Data.DataTableReader>. Jeśli wartość kolumny w obrębie określonego wiersza jest pusta, kod wyświetla tekst \<NULL >. Jeśli dane w kolumnie nie jest poprawny, pojawi się komunikat o błędzie dla każdego wiersza.  
  
 [!code-csharp[DataWorks DataTableReader.GetDouble#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetDouble/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetDouble#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetDouble/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Przekazany Indeks wykraczał poza z zakresu od 0 do <see cref="P:System.Data.DataTableReader.FieldCount" /> - 1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Została podjęta próba pobrania danych z usuniętym wierszu.</exception>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę odczytu lub uzyskać dostępu do kolumny w zamkniętej <see langword="DataTableReader" />.</exception>
        <exception cref="T:System.InvalidCastException">Określona kolumna nie zawiera podwójnej precyzji liczba zmiennoprzecinkowa.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public override System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="override this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="dataTableReader.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca moduł wyliczający, który może służyć do iterowania po kolekcji elementów.</summary>
        <returns>
          <see cref="T:System.Collections.IEnumerator" /> Obiekt, który reprezentuje kolekcji elementów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Moduły wyliczające umożliwiają tylko odczytywanie danych w <xref:System.Data.DataTableReader>. Wyliczenia nie można zmodyfikować kolekcji źródłowej.  
  
 Na początku moduł wyliczający jest umieszczony przed pierwszym elementem w kolekcji. At to pozycja, wywoływania <xref:System.Collections.IEnumerator.Current%2A> zgłasza wyjątek. W związku z tym należy wywołać `MoveNext` można poprawić modułu wyliczającego pierwszy element do kolekcji przed odczytywania wartości `Current`.  
  
 `Current` Zwraca <xref:System.Data.Common.DbDataRecord>i zwraca ten sam obiekt do momentu <xref:System.Collections.IEnumerator.MoveNext%2A> lub <xref:System.Collections.IEnumerator.Reset%2A> jest wywoływana. `MoveNext` Ustawia `Current` do następnego elementu.  
  
 Po zakończeniu kolekcji jest moduł wyliczający jest rozmieszczanych za ostatnim elementem w kolekcji i wywoływania `MoveNext` zwraca wartość false. Jeśli przez ostatnie wywołanie `MoveNext` zwrócił `false`, wywoływania `Current` zgłasza wyjątek. Ponadto ponieważ <xref:System.Data.DataTableReader> umożliwia dostęp tylko do przodu do własnych danych, wywoływania <xref:System.Collections.IEnumerator.Reset%2A> metodę IEnumerator <xref:System.NotSupportedException>.  
  
 <xref:System.Data.DataTableReader> Zapewnia stabilny modułu wyliczającego. Oznacza to, że nawet jeśli usunięcia wiersza i dodawania są wykonywane w ramach danych modułu wyliczającego zwrócony przez wywołanie do <xref:System.Data.DataTableReader.GetEnumerator%2A> jest nadal ważny.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie <xref:System.Data.DataTableReader.GetEnumerator%2A> metody. Dotyczy to również zachowanie modułu wyliczającego wiersze są usuwane z podstawową <xref:System.Data.DataTable> , gdy moduł wyliczający jest aktywny.  
  
 [!code-csharp[DataWorks DataTableReader.GetEnumerator#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetEnumerator/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetEnumerator/VB/source.vb#1)]  
  
 Procedura przedstawia następujący tekst w oknie konsoli:  
  
```  
Peter  
Mary  
Russ  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę odczytu lub uzyskać dostępu do kolumny w zamkniętej <see cref="T:System.Data.DataTableReader" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFieldType">
      <MemberSignature Language="C#" Value="public override Type GetFieldType (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetFieldType(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetFieldType(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetFieldType (ordinal As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetFieldType(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetFieldType : int -&gt; Type" Usage="dataTableReader.GetFieldType ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Numer porządkowy kolumny liczony od zera.</param>
        <summary>Pobiera <see cref="T:System.Type" /> obiektu, który jest typem danych.</summary>
        <returns>
          <see cref="T:System.Type" /> Obiektu, który jest typem danych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Wywołaj procedurę, przekazując <xref:System.Data.DataTableReader> wystąpienia, aby wyświetlić listę wszystkich pól i Pełna nazwa dla każdego typu w oknie konsoli.  
  
 [!code-csharp[DataWorks DataTableReader.GetFieldType#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetFieldType/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetFieldType#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetFieldType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Przekazany Indeks wykraczał poza z zakresu od 0 do <see cref="P:System.Data.DataTableReader.FieldCount" /> - 1.</exception>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę odczytu lub uzyskać dostępu do kolumny w zamkniętej <see cref="T:System.Data.DataTableReader" /> .</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFloat">
      <MemberSignature Language="C#" Value="public override float GetFloat (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance float32 GetFloat(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetFloat(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetFloat (ordinal As Integer) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override float GetFloat(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetFloat : int -&gt; single" Usage="dataTableReader.GetFloat ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Numer porządkowy kolumny liczony od zera.</param>
        <summary>Pobiera wartość określonej kolumny jako pojedynczej precyzji liczba zmiennoprzecinkowa.</summary>
        <returns>Wartość kolumny.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Konwersje nie są wykonywane; w związku z tym dane pobrane musi już być pojedynczej precyzji liczba zmiennoprzecinkowa lub musi pasować do pojedynczej precyzji liczba zmiennoprzecinkowa.  
  
 Wywołanie <xref:System.Data.DataTableReader.IsDBNull%2A> czy przed wywołaniem tej metody są wartości null.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono zawartości kolumny numerowane 2 w ramach przekazany do <xref:System.Data.DataTableReader>. Jeśli wartość kolumny w obrębie określonego wiersza jest pusta, kod wyświetla tekst \<NULL >. Jeśli dane w kolumnie nie jest poprawny, pojawi się komunikat o błędzie dla każdego wiersza.  
  
 [!code-csharp[DataWorks DataTableReader.GetFloat#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetFloat/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetFloat#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetFloat/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Przekazany Indeks wykraczał poza z zakresu od 0 do <see cref="P:System.Data.DataTableReader.FieldCount" /> - 1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Została podjęta próba pobrania danych z usuniętym wierszu.</exception>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę odczytu lub uzyskać dostępu do kolumny w zamkniętej <see cref="T:System.Data.DataTableReader" />.</exception>
        <exception cref="T:System.InvalidCastException">Określona kolumna nie zawiera pojedynczej precyzji liczba zmiennoprzecinkowa.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetGuid">
      <MemberSignature Language="C#" Value="public override Guid GetGuid (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Guid GetGuid(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetGuid(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetGuid (ordinal As Integer) As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Guid GetGuid(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetGuid : int -&gt; Guid" Usage="dataTableReader.GetGuid ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Numer porządkowy kolumny liczony od zera.</param>
        <summary>Pobiera wartość określonej kolumny jako globalnie unikatowy identyfikator (globalny GUID).</summary>
        <returns>Wartość określonej kolumny.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Konwersje nie są wykonywane; w związku z tym dane pobrane musi już być <xref:System.Guid> lub taki sam jak `Guid`.  
  
 Wywołanie <xref:System.Data.DataTableReader.IsDBNull%2A> czy przed wywołaniem tej metody są wartości null.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono zawartości kolumny numerowane 2 w ramach przekazany element DataTableReader. Jeśli wartość kolumny w obrębie określonego wiersza jest pusta, kod wyświetla tekst \<NULL >. Jeśli dane w kolumnie nie jest poprawny, pojawi się komunikat o błędzie dla każdego wiersza.  
  
 [!code-csharp[DataWorks DataTableReader.GetGuid#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetGuid/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetGuid#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetGuid/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Przekazany Indeks wykraczał poza z zakresu od 0 do <see cref="P:System.Data.DataTableReader.FieldCount" /> - 1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Została podjęta próba pobrania danych z usuniętym wierszu.</exception>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę odczytu lub uzyskać dostępu do kolumny w zamkniętej <see cref="T:System.Data.DataTableReader" />.</exception>
        <exception cref="T:System.InvalidCastException">Określona kolumna nie zawiera identyfikatora GUID.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetInt16">
      <MemberSignature Language="C#" Value="public override short GetInt16 (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int16 GetInt16(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetInt16(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetInt16 (ordinal As Integer) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override short GetInt16(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetInt16 : int -&gt; int16" Usage="dataTableReader.GetInt16 ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Liczony od zera kolumny o liczbie porządkowej</param>
        <summary>Pobiera wartość określonej kolumny jako 16-bitową liczbę całkowitą ze znakiem.</summary>
        <returns>Wartość określonej kolumny.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Konwersje nie są wykonywane; w związku z tym dane pobrane musi już być <xref:System.Int16> lub taki sam jak `Int16`.  
  
 Wywołanie <xref:System.Data.DataTableReader.IsDBNull%2A> czy przed wywołaniem tej metody są wartości null.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono zawartości kolumny numerowane 2 w ramach przekazany do <xref:System.Data.DataTableReader>. Jeśli wartość kolumny w obrębie określonego wiersza jest pusta, kod wyświetla tekst \<NULL >. Jeśli dane w kolumnie nie jest poprawny, pojawi się komunikat o błędzie dla każdego wiersza.  
  
 [!code-csharp[DataWorks DataTableReader.GetInt16#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetInt16/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetInt16#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetInt16/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Przekazany Indeks wykraczał poza z zakresu od 0 do <see cref="P:System.Data.DataTableReader.FieldCount" /> - 1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Została podjęta próba pobrania danych z usuniętym wierszu.</exception>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę odczytu lub uzyskać dostępu do kolumny w zamkniętej <see cref="T:System.Data.DataTableReader" />.</exception>
        <exception cref="T:System.InvalidCastException">Określona kolumna nie zawiera 16-bitową liczbę całkowitą ze znakiem.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetInt32">
      <MemberSignature Language="C#" Value="public override int GetInt32 (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetInt32(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetInt32(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetInt32 (ordinal As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetInt32(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetInt32 : int -&gt; int" Usage="dataTableReader.GetInt32 ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Liczony od zera kolumny o liczbie porządkowej</param>
        <summary>Pobiera wartość określonej kolumny jako całkowita 32-bitowych.</summary>
        <returns>Wartość określonej kolumny.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Konwersje nie są wykonywane; w związku z tym dane pobrane musi już być <xref:System.Int32> lub taki sam jak `Int32`.  
  
 Wywołanie <xref:System.Data.DataTableReader.IsDBNull%2A> czy przed wywołaniem tej metody są wartości null.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono zawartości kolumny numerowane 2 w ramach przekazany do <xref:System.Data.DataTableReader>. Jeśli wartość kolumny w obrębie określonego wiersza jest pusta, kod wyświetla tekst \<NULL >. Jeśli dane w kolumnie nie jest poprawny, pojawi się komunikat o błędzie dla każdego wiersza.  
  
 [!code-csharp[DataWorks DataTableReader.GetInt32#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetInt32/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetInt32#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetInt32/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Przekazany Indeks wykraczał poza z zakresu od 0 do <see cref="P:System.Data.DataTableReader.FieldCount" /> - 1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Została podjęta próba pobrania danych z usuniętym wierszu.</exception>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę odczytu lub uzyskać dostępu do kolumny w zamkniętej <see cref="T:System.Data.DataTableReader" /> .</exception>
        <exception cref="T:System.InvalidCastException">Określona kolumna nie zawiera wartości 32-bitowej liczby całkowitej ze znakiem.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetInt64">
      <MemberSignature Language="C#" Value="public override long GetInt64 (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 GetInt64(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetInt64(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetInt64 (ordinal As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long GetInt64(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetInt64 : int -&gt; int64" Usage="dataTableReader.GetInt64 ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Liczony od zera kolumny o liczbie porządkowej</param>
        <summary>Pobiera wartość określonej kolumny jako 64-bitowej podpisanej liczby całkowitej.</summary>
        <returns>Wartość określonej kolumny.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Konwersje nie są wykonywane; w związku z tym dane pobrane musi już być <xref:System.Int64> lub taki sam jak `Int64`.  
  
 Wywołanie <xref:System.Data.DataTableReader.IsDBNull%2A> czy przed wywołaniem tej metody są wartości null.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono zawartości kolumny numerowane 2 w ramach przekazany do <xref:System.Data.DataTableReader>. Jeśli wartość kolumny w obrębie określonego wiersza jest pusta, kod wyświetla tekst \<NULL >. Jeśli dane w kolumnie nie jest poprawny, pojawi się komunikat o błędzie dla każdego wiersza.  
  
 [!code-csharp[DataWorks DataTableReader.GetInt64#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetInt64/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetInt64#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetInt64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Przekazany Indeks wykraczał poza z zakresu od 0 do <see cref="P:System.Data.DataTableReader.FieldCount" /> - 1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Została podjęta próba pobrania danych z usuniętym wierszu.</exception>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę odczytu lub uzyskać dostępu do kolumny w zamkniętej <see cref="T:System.Data.DataTableReader" /> .</exception>
        <exception cref="T:System.InvalidCastException">Określona kolumna nie zawiera wartości 64-bitowej podpisanej liczby całkowitej.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public override string GetName (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetName(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetName(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetName (ordinal As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ GetName(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetName : int -&gt; string" Usage="dataTableReader.GetName ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Liczony od zera kolumny o liczbie porządkowej</param>
        <summary>Pobiera wartość określonej kolumny jako <see cref="T:System.String" />.</summary>
        <returns>Nazwa określonej kolumny.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetName` i <xref:System.Data.DataTableReader.GetOrdinal%2A> metody udostępniają odwrotność funkcji. Oznacza to, że wywołanie `GetOrdinal` na wartość zwracana wywołania `GetName` powinien zwrócić pierwotny parametr przekazany do `GetName`; to samo dotyczy wywoływanie procedur w przeciwną kolejności.  
  
   
  
## Examples  
 Prosty przykład zawiera procedury, która wyświetla nazwy wszystkich kolumn w ramach określonego `DataTableReader`i pozycję liczby porządkowej kolumny, w oknie konsoli.  
  
 [!code-csharp[DataWorks DataTableReader.GetName#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetName/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetName#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetName/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Przekazany Indeks wykraczał poza z zakresu od 0 do <see cref="P:System.Data.DataTableReader.FieldCount" /> - 1.</exception>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę odczytu lub uzyskać dostępu do kolumny w zamkniętej <see cref="T:System.Data.DataTableReader" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetOrdinal">
      <MemberSignature Language="C#" Value="public override int GetOrdinal (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetOrdinal(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetOrdinal(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetOrdinal (name As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetOrdinal(System::String ^ name);" />
      <MemberSignature Language="F#" Value="override this.GetOrdinal : string -&gt; int" Usage="dataTableReader.GetOrdinal name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa kolumny.</param>
        <summary>Pobiera kolumnę porządkowej, otrzymuje nazwę kolumny.</summary>
        <returns>Numer porządkowy kolumny liczony od zera.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ponieważ większość metody dostarczone przez <xref:System.Data.DataTableReader> klasy muszą być z liczby porządkowej kolumny, możesz użyć `GetOrdinal` metoda pobierania numer kolumny otrzymuje nazwę kolumny.  
  
 `GetOrdinal` najpierw przeprowadza wyszukiwanie z uwzględnieniem wielkości liter. Jeśli nie powiedzie się, zostanie przeprowadzona drugi wyszukiwania bez uwzględniania wielkości liter. Jeśli nie zostanie znaleziony numer kolumny `IndexOutOfRangeException` jest generowany.  
  
 `GetOrdinal` szerokość kana jest rozróżniana wielkość liter.  
  
 Ponieważ wyszukiwań na podstawie numer są bardziej efektywne niż nazwanego wyszukiwań, jest nieefektywne wywołać `GetOrdinal` w pętli. Zaoszczędzić czas, przez wywołanie metody `GetOrdinal` jeden raz i przypisywanie wyniki do zmiennej całkowitą do użytku w pętli  
  
   
  
## Examples  
 Jeśli masz tylko nazwę kolumny w takim przypadku nazwa kolumny jest podany, użytkownika i informacje muszą zostać pobrane z kolumny, możesz użyć podobnie do następującej procedury można wyodrębnić wymaganych informacji. W tym przykładzie procedury przyjmuje nazwę kolumny i zwraca dane zawarte w tej kolumnie dla danego wiersza w <xref:System.Data.DataTableReader> :  
  
 [!code-csharp[DataWorks DataTableReader.GetOrdinal#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetOrdinal/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetOrdinal#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetOrdinal/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę odczytu lub uzyskać dostępu do kolumny w zamkniętej <see cref="T:System.Data.DataTableReader" />.</exception>
        <exception cref="T:System.ArgumentException">Określona nazwa nie jest prawidłową nazwę kolumny.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetProviderSpecificFieldType">
      <MemberSignature Language="C#" Value="public override Type GetProviderSpecificFieldType (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetProviderSpecificFieldType(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetProviderSpecificFieldType(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetProviderSpecificFieldType (ordinal As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetProviderSpecificFieldType(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetProviderSpecificFieldType : int -&gt; Type" Usage="dataTableReader.GetProviderSpecificFieldType ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Numer porządkowy kolumny liczony od zera.</param>
        <summary>Pobiera typ dla określonej kolumny w formacie specyficznego dla dostawcy.</summary>
        <returns>
          <see cref="T:System.Type" /> Obiektu, który jest typem danych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ponieważ <xref:System.Data.DataTableReader> zawsze zwraca typ przechowywane w ramach podstawowych <xref:System.Data.DataColumn>, wartość zwracana przez wywołanie metody <xref:System.Data.DataTableReader.GetProviderSpecificFieldType%2A> metoda zawsze zwraca ten sam typ co typ przechowywanych w <xref:System.Data.DataTable>. Podczas pracy z <xref:System.Data.DataTableReader> klasy wywoływania <xref:System.Data.DataTableReader.GetProviderSpecificFieldType%2A> metoda zwraca tego samego typu co wywołanie <xref:System.Type.GetType%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Przekazany Indeks wykraczał poza z zakresu od 0 do <see cref="P:System.Data.DataTableReader.FieldCount" /> - 1.</exception>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę odczytu lub uzyskać dostępu do kolumny w zamkniętej <see cref="T:System.Data.DataTableReader" />.</exception>
        <altmember cref="M:System.Data.DataTableReader.GetFieldType(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetProviderSpecificValue">
      <MemberSignature Language="C#" Value="public override object GetProviderSpecificValue (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object GetProviderSpecificValue(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetProviderSpecificValue(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetProviderSpecificValue (ordinal As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ GetProviderSpecificValue(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetProviderSpecificValue : int -&gt; obj" Usage="dataTableReader.GetProviderSpecificValue ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Liczony od zera numer kolumny, którego wartość jest pobierana.</param>
        <summary>Pobiera wartość określonej kolumny w formacie specyficznego dla dostawcy.</summary>
        <returns>Wartość określonej kolumny w formacie specyficznego dla dostawcy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ponieważ <xref:System.Data.DataTableReader> zawsze zwraca typ przechowywane w ramach podstawowych <xref:System.Data.DataColumn>, wartość zwracana przez wywołanie metody <xref:System.Data.DataTableReader.GetProviderSpecificValue%2A> metoda zawsze zwraca dane jako dane przechowywane w ramach tego samego typu <xref:System.Data.DataTable>. Podczas pracy z <xref:System.Data.DataTableReader> klasy wywoływania <xref:System.Data.DataTableReader.GetProviderSpecificValue%2A> metoda zwraca takie same wartości i wpisz co wywołanie <xref:System.Data.DataTableReader.GetValue%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Przekazany Indeks wykraczał poza z zakresu od 0 do <see cref="P:System.Data.DataTableReader.FieldCount" /> - 1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Została podjęta próba pobrania danych z usuniętym wierszu.</exception>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę odczytu lub uzyskać dostępu do kolumny w zamkniętej <see cref="T:System.Data.DataTableReader" /></exception>
        <altmember cref="M:System.Data.DataTableReader.GetValue(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetProviderSpecificValues">
      <MemberSignature Language="C#" Value="public override int GetProviderSpecificValues (object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetProviderSpecificValues(object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetProviderSpecificValues(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetProviderSpecificValues (values As Object()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetProviderSpecificValues(cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="override this.GetProviderSpecificValues : obj[] -&gt; int" Usage="dataTableReader.GetProviderSpecificValues values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="values">Tablica obiektów w celu wprowadzenia informacji o typie dla kolumn w <see cref="T:System.Data.DataTableReader" />.</param>
        <summary>Wypełnia podanej tablicy przy użyciu informacji o typie specyficznych dla dostawcy dla wszystkich kolumn <see cref="T:System.Data.DataTableReader" />.</summary>
        <returns>Liczba wartości w kolumnie skopiować do tablicy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ponieważ <xref:System.Data.DataTableReader> zawsze zwraca dane typu przechowywane w ramach podstawowych <xref:System.Data.DataColumn>, wartości zwracane przez wywołanie metody <xref:System.Data.DataTableReader.GetProviderSpecificValues%2A> metody jest zawsze z tymi samymi typami jako dane przechowywane w <xref:System.Data.DataTable>. Podczas pracy z <xref:System.Data.DataTableReader> klasy wywoływania <xref:System.Data.DataTableReader.GetProviderSpecificValues%2A> metoda zwraca te same wartości i typy co wywołanie <xref:System.Data.DataTableReader.GetValues%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Została podjęta próba pobrania danych z usuniętym wierszu.</exception>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę odczytu lub uzyskać dostępu do kolumny w zamkniętej <see cref="T:System.Data.DataTableReader" />.</exception>
        <altmember cref="M:System.Data.DataTableReader.GetValues(System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="GetSchemaTable">
      <MemberSignature Language="C#" Value="public override System.Data.DataTable GetSchemaTable ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Data.DataTable GetSchemaTable() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetSchemaTable" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetSchemaTable () As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Data::DataTable ^ GetSchemaTable();" />
      <MemberSignature Language="F#" Value="override this.GetSchemaTable : unit -&gt; System.Data.DataTable" Usage="dataTableReader.GetSchemaTable " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.Data.DataTable" /> opisujący metadane kolumny <see cref="T:System.Data.DataTableReader" />.</summary>
        <returns>A <see cref="T:System.Data.DataTable" /> opisujący metadanych kolumn.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda GetSchemaTable zwraca metadane dotyczące każdej kolumny w następującej kolejności:  
  
|DataReader kolumny|Opis|  
|-----------------------|-----------------|  
|Element ColumnName|Nazwa kolumny, w jakiej jest wyświetlana w <xref:System.Data.DataTable>.|  
|ColumnOrdinal|Numer kolumny|  
|ColumnSize|-1, gdy <xref:System.Data.Common.SchemaTableColumn.ColumnSize> (lub <xref:System.Data.DataColumn.MaxLength%2A>) właściwość <xref:System.Data.DataColumn> nie może być określony lub nie jest istotne; w przeciwnym razie wartość 0 lub dodatnia liczba całkowita, która zawiera `MaxLength` wartość.|  
|NumericPrecision|Jeśli typem kolumny jest typu liczbowego, jest to maksymalna dokładność kolumny. Jeśli typ kolumny nie jest typem danych liczbowych, jest wartość null.|  
|NumericScale|Jeśli typ danych kolumny zawiera składnik skali, zwróć liczba cyfr z prawej strony punktu dziesiętnego. W przeciwnym razie zwraca wartość null.|  
|Typ danych|Podstawowy typ kolumny.|  
|Typ dostawcy|Wskazuje typ danych kolumny. Jeśli typ danych kolumny może być różna wiersz po wierszu, ta wartość jest <xref:System.Object>. Ta kolumna nie może zawierać wartości null.|  
|IsLong|`true` Jeśli typ danych kolumny jest <xref:System.String> i jego <xref:System.Data.DataColumn.MaxLength%2A> właściwość ma wartość -1. w przeciwnym razie `false`.|  
|AllowDBNull|`true` Jeśli ustawiono ograniczenie AllowDbNull na wartość true dla kolumny; w przeciwnym razie `false`.|  
|IsReadOnly|`true` Jeśli kolumna nie może być modyfikowany; w przeciwnym razie `false`.|  
|Atrybut IsRowVersion|`false`, dla każdej kolumny.|  
|IsUnique|`true`: Brak dwa wiersze w <xref:System.Data.DataTable> mogą mieć taką samą wartość w tej kolumnie. `IsUnique` gwarantuje to wartość true, jeśli kolumna reprezentuje klucz przez siebie lub jeśli istnieje ograniczenie typu UNIQUE, która ma zastosowanie tylko do tej kolumny. `false`: Kolumna może zawierać zduplikowanych wartości w `DataTable`. Domyślnie ta kolumna jest `false`.|  
|IsKey|`true`: Kolumna jest jeden zestaw kolumn, które identyfikują razem wiersza w <xref:System.Data.DataTable>. Zestaw kolumn z `IsKey` ustawioną `true` musi jednoznacznie identyfikować wiersza w `DataTable`. Nie jest wymagane czy ten zestaw kolumn jest minimalny zestaw kolumn. Ten zestaw kolumn mogą być generowane z `DataTable` klucza podstawowego, unikatowego ograniczenia lub unikatowego indeksu. `false`: Kolumna nie jest wymagana do jednoznacznego identyfikowania wiersza. Ta wartość jest `true` Jeśli kolumna uczestniczy w jednym lub złożonego klucza podstawowego. W przeciwnym razie jego wartość wynosi `false`.|  
|IsAutoIncrement|`true`: Kolumna przypisuje wartości do nowych wierszy w stałych odstępach. `false`: Kolumna nie przypisywać wartości do nowych wierszy w stałych odstępach. Domyślnie ta kolumna jest `false`.|  
|BaseCatalogName|Nazwa katalogu w magazynie danych, która zawiera kolumny. `Null` Jeśli nie można ustalić nazwy katalogu podstawowego. Wartość domyślna dla tej kolumny jest `null` wartość.|  
|BaseSchemaName|Ta wartość jest zawsze `Null`.|  
|BaseTableName|Nazwa <xref:System.Data.DataTable>.|  
|BaseColumnName|Nazwa kolumny w <xref:System.Data.DataTable>.|  
|AutoIncrementSeed|Wartość <xref:System.Data.DataTable>w <xref:System.Data.DataColumn.AutoIncrementSeed%2A> właściwości.|  
|Elementu AutoIncrementStep|Wartość <xref:System.Data.DataTable>w <xref:System.Data.DataColumn.AutoIncrementStep%2A> właściwości.|  
|Wartość domyślna|Wartość <xref:System.Data.DataColumn>w <xref:System.Data.DataColumn.DefaultValue%2A> właściwości.|  
|Wyrażenie|Ciąg wyrażenia, jeśli bieżąca kolumna jest kolumną wyrażenie i wszystkie kolumny używaną w wyrażeniu muszą należeć do tej samej `T:System.Data.DataTable` zawiera wyrażenie kolumny; w przeciwnym razie `null`.|  
|Mapowanie kolumny|<xref:System.Data.MappingType> Wartość skojarzoną z <xref:System.Data.DataColumn>. Jako typ można określić jedną z `Attribute`, `Element`, `Hidden`, lub `SimpleContent`. Wartość domyślna to `Element`.|  
|BaseTableNamespace|Wartość <xref:System.Data.DataTable>w <xref:System.Data.DataTable.Namespace%2A> właściwości.|  
|BaseColumnNamespace|Wartość <xref:System.Data.DataColumn>w <xref:System.Data.DataColumn.Namespace%2A> właściwości.|  
  
   
  
## Examples  
 W poniższym przykładzie aplikacji konsoli pobiera informacje o schemacie o określonej kolumny. Przekaż `DisplaySchemaTableInfo` procedury <xref:System.Data.DataTableReader> i liczbę całkowitą reprezentującą numerem porządkowym kolumny w obrębie `DataTableReader`, i procedury wyprowadzania informacji o schemacie dla okna konsoli.  
  
 [!code-csharp[DataWorks DataTableReader.GetSchemaTable#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetSchemaTable/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetSchemaTable#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetSchemaTable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Data.DataTableReader" /> Jest zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public override string GetString (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetString(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetString(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetString (ordinal As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ GetString(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetString : int -&gt; string" Usage="dataTableReader.GetString ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Liczony od zera kolumny o liczbie porządkowej</param>
        <summary>Pobiera wartość określonej kolumny jako ciąg.</summary>
        <returns>Wartość określonej kolumny.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie <xref:System.Data.DataTableReader.IsDBNull%2A> czy przed wywołaniem tej metody są wartości null.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono zawartości kolumny numerowane 2 w ramach przekazany do <xref:System.Data.DataTableReader>. Jeśli wartość kolumny w obrębie określonego wiersza jest pusta, kod wyświetla tekst \<NULL >. Jeśli dane w kolumnie poprawny typ, przykładzie wyświetla komunikat o błędzie dla każdego wiersza.  
  
 [!code-csharp[DataWorks DataTableReader.GetString#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetString/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetString#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetString/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Przekazany Indeks wykraczał poza z zakresu od 0 do <see cref="P:System.Data.DataTableReader.FieldCount" /> - 1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Została podjęta próba pobrania danych z usuniętym wierszu.</exception>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę odczytu lub uzyskać dostępu do kolumny w zamkniętej <see cref="T:System.Data.DataTableReader" />.</exception>
        <exception cref="T:System.InvalidCastException">Określona kolumna nie zawiera ciąg.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public override object GetValue (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object GetValue(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetValue(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetValue (ordinal As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ GetValue(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetValue : int -&gt; obj" Usage="dataTableReader.GetValue ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Liczony od zera kolumny o liczbie porządkowej</param>
        <summary>Pobiera wartość określonej kolumny w jego formatu macierzystego.</summary>
        <returns>Wartość określonej kolumny. Ta metoda zwraca <see langword="DBNull" /> dla kolumn o wartości null.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mimo że można wywołać <xref:System.Data.DataTableReader.IsDBNull%2A> w przypadku wartości null przed wywołaniem tej metody, nie masz w tym celu.  
  
   
  
## Examples  
 Poniższy przykład iteruje wszystkie kolumny w bieżącym wierszu w <xref:System.Data.DataTableReader>, wyświetlania zawartości każdej kolumny i nazwę kolumny. Ogólnie rzecz biorąc Jeśli z celem jest praca z wszystkich kolumn w wierszu pobierane przez <xref:System.Data.DataTableReader>, należy rozważyć użycie <xref:System.Data.DataTableReader.GetValues%2A> — metoda, ponieważ jest bardziej wydajne.  
  
 [!code-csharp[DataWorks DataTableReader.GetValue#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetValue/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetValue#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetValue/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Przekazany Indeks wykraczał poza z zakresu od 0 do <see cref="P:System.Data.DataTableReader.FieldCount" /> - 1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Została podjęta próba pobrania danych z usuniętym wierszu.</exception>
        <exception cref="T:System.InvalidOperationException">Nastąpiła próba odczytu ani uzyskiwać dostępu do kolumn w zamkniętej <see cref="T:System.Data.DataTableReader" /> .</exception>
      </Docs>
    </Member>
    <Member MemberName="GetValues">
      <MemberSignature Language="C#" Value="public override int GetValues (object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetValues(object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetValues(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetValues (values As Object()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetValues(cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="override this.GetValues : obj[] -&gt; int" Usage="dataTableReader.GetValues values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="values">Tablica <see cref="T:System.Object" /> do którego można skopiować wartości w kolumnie z <see cref="T:System.Data.DataTableReader" />.</param>
        <summary>Wypełnia tablicę obiektów z wartości w kolumnie bieżącego wiersza.</summary>
        <returns>Liczba wartości w kolumnie skopiować do tablicy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dla większości aplikacji ta metoda zapewnia skuteczne pobierania wszystkich kolumn, zamiast indywidualnie pobieranie każdej kolumny. Jeśli Twoje zamierzeniu można pobrać wszystkich wartości w kolumnie z wiersza w <xref:System.Data.DataTableReader>, `GetValues` metoda zapewnia najbardziej wydajne rozwiązanie.  
  
 Można przekazać <xref:System.Object> tablicy, która zawiera mniej niż liczba kolumn, które są zawarte w wynikowego wiersza. Ilość danych `Object` Tablica może zawierać jest kopiowany do tablicy. Można również przekazać `Object` tablicy, której długość jest większa niż liczba kolumn, które są zawarte w wynikowego wiersza, w których przypadku elementów tablicy dodatkowe pozostaje bez zmian przez wywołanie metody.  
  
 Ta metoda powoduje `DBNull` w tablicy danych wyjściowych dla kolumn o wartości null.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie tablicy, który jest odpowiedni rozmiar, odczytać wszystkie wartości z bieżącego wiersza w podane <xref:System.Data.DataTableReader>. Ponadto w przykładzie pokazano, przy użyciu tablicy stałym rozmiarze, który może być mniejsza lub większa niż liczba dostępnych kolumn.  
  
 [!code-csharp[DataWorks DataTableReader.GetValueObject#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetValueObject/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetValueObject#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetValueObject/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Przekazany Indeks wykraczał poza z zakresu od 0 do <see cref="P:System.Data.DataTableReader.FieldCount" /> - 1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Została podjęta próba pobrania danych z usuniętym wierszu.</exception>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę odczytu lub uzyskać dostępu do kolumny w zamkniętej <see cref="T:System.Data.DataTableReader" /> .</exception>
      </Docs>
    </Member>
    <Member MemberName="HasRows">
      <MemberSignature Language="C#" Value="public override bool HasRows { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasRows" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTableReader.HasRows" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property HasRows As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool HasRows { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasRows : bool" Usage="System.Data.DataTableReader.HasRows" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Data.DataTableReader" /> zawiera co najmniej jeden wiersz.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Data.DataTableReader" /> zawiera jeden lub więcej wierszy; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `HasRows` Właściwość zwraca informacje dotyczące bieżącego zestawu wyników. Jeśli <xref:System.Data.DataTableReader> zawiera wiele wyników zestawów, można sprawdzić wartość `HasRows` właściwości natychmiast po wywołaniu metody <xref:System.Data.DataTableReader.NextResult%2A> metody w celu określenia, czy nowy zestaw wyników zawiera wiersze.  
  
 Użyj `HasRows` właściwości, aby uniknąć konieczności wywołania <xref:System.Data.DataTableReader.Read%2A> metody <xref:System.Data.DataTableReader> , jeśli nie ma żadnych wierszy w bieżącym zestawie wyników.  
  
   
  
## Examples  
 Poniższy przykład wypełnia dwa <xref:System.Data.DataTable> wystąpień z danymi. Pierwszy <xref:System.Data.DataTable> zawiera jeden wiersz, a drugi nie zawiera wierszy. Następnie tworzony <xref:System.Data.DataTableReader> zawiera zarówno <xref:System.Data.DataTable> obiekty i wywołuje metodę PrintData, aby wyświetlić zawartość poszczególnych, wartości <xref:System.Data.DataTableReader.HasRows%2A> właściwości każdego przed powoduje wywołanie PrintData.  
  
 [!code-csharp[DataWorks DataTableReader.HasRows#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.HasRows/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.HasRows#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.HasRows/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę pobrania informacji dotyczących zamkniętej <see cref="T:System.Data.DataTableReader" />.</exception>
        <altmember cref="M:System.Data.DataTableReader.NextResult" />
        <altmember cref="M:System.Data.DataTableReader.Read" />
      </Docs>
    </Member>
    <Member MemberName="IsClosed">
      <MemberSignature Language="C#" Value="public override bool IsClosed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClosed" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTableReader.IsClosed" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsClosed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsClosed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsClosed : bool" Usage="System.Data.DataTableReader.IsClosed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Data.DataTableReader" /> jest zamknięty.</summary>
        <value>Zwraca <see langword="true" /> Jeśli <see cref="T:System.Data.DataTableReader" /> zamknięte, a w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTableReader.Close%2A> jest jedyną metodą i `IsClosed` i <xref:System.Data.DataTableReader.RecordsAffected%2A> są tylko właściwości, które są dostępne po <xref:System.Data.DataTableReader> został zamknięty.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDBNull">
      <MemberSignature Language="C#" Value="public override bool IsDBNull (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsDBNull(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.IsDBNull(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsDBNull (ordinal As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsDBNull(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.IsDBNull : int -&gt; bool" Usage="dataTableReader.IsDBNull ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Liczony od zera kolumny o liczbie porządkowej</param>
        <summary>Pobiera wartość wskazującą, czy kolumna zawiera nieistniejącą lub brak wartości.</summary>
        <returns>
          <see langword="true" /> Jeśli wartość określonej kolumny jest odpowiednikiem <see cref="T:System.DBNull" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tej metody, jeśli istnieją wartości null kolumny przed wywołaniem metody get typu (na przykład <xref:System.Data.DataTableReader.GetByte%2A>, <xref:System.Data.DataTableReader.GetChar%2A>i tak dalej), aby uniknąć zgłaszania błędu.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono zawartości kolumny numerowane 2 w ramach przekazany do <xref:System.Data.DataTableReader>. Jeśli wartość kolumny w obrębie określonego wiersza jest pusta, kod wyświetla tekst \<NULL >. Jeśli dane w kolumnie poprawny typ, przykładzie wyświetla komunikat o błędzie dla każdego wiersza.  
  
 [!code-csharp[DataWorks DataTableReader.IsDbNull#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.IsDbNull/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.IsDbNull#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.IsDbNull/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Przekazany Indeks wykraczał poza z zakresu od 0 do <see cref="P:System.Data.DataTableReader.FieldCount" /> - 1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Została podjęta próba pobrania danych z usuniętym wierszu.</exception>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę odczytu lub uzyskać dostępu do kolumny w zamkniętej <see cref="T:System.Data.DataTableReader" /> .</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Item">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera wartość określonej kolumny w jego formatu macierzystego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public override object this[int ordinal] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTableReader.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overrides ReadOnly Property Item(ordinal As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ default[int] { System::Object ^ get(int ordinal); };" />
      <MemberSignature Language="F#" Value="member this.Item(int) : obj" Usage="System.Data.DataTableReader.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Numer porządkowy kolumny liczony od zera.</param>
        <summary>Pobiera wartość określonej kolumny w formacie native podanej liczby porządkowej kolumny.</summary>
        <value>Wartość określonej kolumny w jego formatu macierzystego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie dla <xref:System.Data.DataTableReader.Item%2A> zachowuje się tak samo do <xref:System.Data.DataTableReader.GetValue%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład wyświetla zawartość wszystkich kolumn wszystkich wierszy z podane <xref:System.Data.DataTableReader>. W kodzie użyto <xref:System.Data.DataTableReader.Item%2A> — metoda (indeksatora, w programie Microsoft C#) można pobrać wartość, która jest zawarta w każdej kolumnie.  
  
 [!code-csharp[DataWorks DataTableReader.Item#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.Item/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.Item#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.Item/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">Przekazany Indeks wykraczał poza z zakresu od 0 do <see cref="P:System.Data.DataTableReader.FieldCount" /> - 1.</exception>
        <altmember cref="M:System.Data.DataTableReader.GetValue(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public override object this[string name] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTableReader.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overrides ReadOnly Property Item(name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ default[System::String ^] { System::Object ^ get(System::String ^ name); };" />
      <MemberSignature Language="F#" Value="member this.Item(string) : obj" Usage="System.Data.DataTableReader.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa kolumny.</param>
        <summary>Pobiera wartość określonej kolumny w formacie native otrzymuje nazwę kolumny.</summary>
        <value>Wartość określonej kolumny w jego formatu macierzystego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Najpierw odbywa się wyszukiwanie z uwzględnieniem wielkości liter. Jeśli nie powiedzie się, zostanie przeprowadzona drugi wyszukiwania bez uwzględniania wielkości liter.  
  
 Ta metoda jest kana szerokość nie liter.  
  
 Ta wersja przeciążone <xref:System.Data.DataTableReader.Item%2A> odpowiada wywołaniem <xref:System.Data.DataTableReader.GetOrdinal%2A> metody, a następnie wywoływania <xref:System.Data.DataTableReader.GetValue%2A> — metoda.  
  
   
  
## Examples  
 Podane <xref:System.Data.DataTableReader> i nazwę kolumny procedury GetValueByName zwraca wartość określonej kolumny. Przed wywołaniem tej procedury, należy utworzyć nowy <xref:System.Data.DataTableReader> wystąpienia i Wywołaj jej metodę odczytu co najmniej jeden raz, aby umieść wskaźnik wiersza w wierszu danych.  
  
 [!code-csharp[DataWorks DataTableReader.ItemName#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.ItemName/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.ItemName#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.ItemName/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Określona nazwa nie jest prawidłową nazwę kolumny.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Została podjęta próba pobrania danych z usuniętym wierszu.</exception>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę odczytu lub uzyskać dostępu do kolumny w zamkniętej <see cref="T:System.Data.DataTableReader" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="NextResult">
      <MemberSignature Language="C#" Value="public override bool NextResult ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool NextResult() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.NextResult" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function NextResult () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool NextResult();" />
      <MemberSignature Language="F#" Value="override this.NextResult : unit -&gt; bool" Usage="dataTableReader.NextResult " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Przesuwa <see cref="T:System.Data.DataTableReader" /> do następnego zestawu wyników, jeśli istnieje.</summary>
        <returns>
          <see langword="true" /> Jeśli wystąpił inny zestaw wyników; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Używane do przetwarzania wiele wyników, które mogą być generowane przez utworzenie <xref:System.Data.DataTableReader> za pośrednictwem <xref:System.Data.DataSet> zawiera co najmniej dwie tabele lub tablicę, która zawiera co najmniej dwóch <xref:System.Data.DataTable> wystąpień.  
  
 Nowy <xref:System.Data.DataTableReader> jest ustawiony na pierwszego wyniku.  
  
   
  
## Examples  
 W poniższym przykładzie metoda TestConstructor tworzy dwa <xref:System.Data.DataTable> wystąpień. W celu zaprezentowania tego konstruktora dla <xref:System.Data.DataTableReader> klasy, tworzy nową próbkę `DataTableReader` na podstawie tablicy, która zawiera dwa `DataTables`i wykonuje operację proste Drukowanie zawartości z pierwszego mało kolumn do konsoli okno. W celu przetestowania tej aplikacji, Utwórz nową aplikację konsoli, a następnie wklej przykładowy kod do nowo utworzonego pliku.  
  
 [!code-csharp[DataWorks DataTableReader.NextResult#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.NextResult/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.NextResult#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.NextResult/VB/source.vb#1)]  
  
 W oknie konsoli wyświetla następujące wyniki:  
  
```  
1 Mary  
2 Andy  
3 Peter  
4 Russ  
1 Wireless Network Card  
2 Hard Drive  
3 Monitor  
4 CPU  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nastąpiła próba do nawigacji w zamkniętej <see cref="T:System.Data.DataTableReader" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override bool Read ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Read() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.Read" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Read();" />
      <MemberSignature Language="F#" Value="override this.Read : unit -&gt; bool" Usage="dataTableReader.Read " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Przesuwa <see cref="T:System.Data.DataTableReader" /> do następnego rekordu.</summary>
        <returns>
          <see langword="true" /> Jeśli nowy wiersz do odczytania. w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To domyślne położenie <xref:System.Data.DataTableReader> przed pierwszy rekord. W związku z tym należy wywołać `Read` można uruchomić podczas uzyskiwania dostępu do żadnych danych.  
  
   
  
## Examples  
 Procedury PrintColumns w pętli wszystkich wierszy w <xref:System.Data.DataTableReader>, wyświetlania zawartości każdej kolumny w oknie konsoli.  
  
 [!code-csharp[DataWorks DataTableReader.Read#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.Read/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.Read#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.Read/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę odczytu lub uzyskać dostępu do kolumny w zamkniętej <see cref="T:System.Data.DataTableReader" /> .</exception>
      </Docs>
    </Member>
    <Member MemberName="RecordsAffected">
      <MemberSignature Language="C#" Value="public override int RecordsAffected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecordsAffected" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTableReader.RecordsAffected" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property RecordsAffected As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int RecordsAffected { int get(); };" />
      <MemberSignature Language="F#" Value="member this.RecordsAffected : int" Usage="System.Data.DataTableReader.RecordsAffected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę wierszy, wstawiania, zmieniony lub usunięty przez wykonanie instrukcji SQL.</summary>
        <value>
          <see cref="T:System.Data.DataTableReader" /> Nie obsługuje tej właściwości oraz zawsze zwraca wartość 0.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
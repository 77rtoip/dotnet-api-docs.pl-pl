<Type Name="DataTableReader" FullName="System.Data.DataTableReader">
  <Metadata><Meta Name="ms.openlocfilehash" Value="f86464005e30acfd4d0dac6af6136d4819e27a1a" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69367661" /></Metadata><TypeSignature Language="C#" Value="public sealed class DataTableReader : System.Data.Common.DbDataReader" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit DataTableReader extends System.Data.Common.DbDataReader" />
  <TypeSignature Language="DocId" Value="T:System.Data.DataTableReader" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DataTableReader&#xA;Inherits DbDataReader" />
  <TypeSignature Language="C++ CLI" Value="public ref class DataTableReader sealed : System::Data::Common::DbDataReader" />
  <TypeSignature Language="F#" Value="type DataTableReader = class&#xA;    inherit DbDataReader" />
  <AssemblyInfo>
    <AssemblyName>System.Data</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Data.Common</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Data.Common.DbDataReader</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Uzyskuje zawartość co najmniej jednego <see cref="T:System.Data.DataTable" /> obiektu w postaci co najmniej jednego zestawu wyników tylko do odczytu. <see cref="T:System.Data.DataTableReader" /></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Działa podobnie jak każdy inny czytnik danych, taki <xref:System.Data.SqlClient.SqlDataReader>jak, z tym wyjątkiem, że <xref:System.Data.DataTableReader> pozwala na iterację wierszy w <xref:System.Data.DataTable>. <xref:System.Data.DataTableReader> Innymi słowy, umożliwia wykonywanie iteracji względem wierszy w pamięci podręcznej. Dane w pamięci podręcznej można modyfikować <xref:System.Data.DataTableReader> , gdy jest aktywny, a czytnik automatycznie utrzymuje swoją pozycję.  
  
 Podczas tworzenia <xref:System.Data.DataTableReader> <xref:System.Data.DataTableReader> z, wynikowy obiekt zawiera jeden zestaw <xref:System.Data.DataTable> wyników z tymi samymi danymi, które zostały utworzone, z wyjątkiem wierszy, które zostały oznaczone jako usunięte. <xref:System.Data.DataTable> Kolumny są wyświetlane w takiej samej kolejności jak w oryginalnym <xref:System.Data.DataTable>. Struktura zwracanego wyniku jest identyczna w schemacie i danych z oryginałem <xref:System.Data.DataTable>. Obiekt, który został utworzony przez <xref:System.Data.DataSet.CreateDataReader*> wywołanie metody <xref:System.Data.DataSet> obiektu zawiera wiele zestawów wyników, jeśli zawiera więcej niż jedną tabelę. <xref:System.Data.DataTableReader> <xref:System.Data.DataSet> Wyniki są w tej samej sekwencji co <xref:System.Data.DataTable> obiekty <xref:System.Data.DataTableCollection> w <xref:System.Data.DataSet> obiekcie.  
  
 Zwrócony zestaw wyników zawiera tylko bieżącą wersję każdego z nich <xref:System.Data.DataRow>. wiersze oznaczone do usunięcia są pomijane.  
  
 Zapewnia stabilny iterator; oznacza to, że zawartość `DataTableReader` nie jest unieważniona, jeśli rozmiar źródłowej kolekcji jest modyfikowany podczas iteracji. `DataTableReader` Na przykład jeśli co najmniej jeden wiersz w <xref:System.Data.DataTable.Rows%2A> kolekcji jest usuwany lub usuwany podczas iteracji, bieżąca pozycja w ramach programu `DataTableReader` jest odpowiednio utrzymywana i nie unieważnia iteratora.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Data.DataTableReader" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataTableReader (System.Data.DataTable dataTable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Data.DataTable dataTable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.#ctor(System.Data.DataTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataTableReader(System::Data::DataTable ^ dataTable);" />
      <MemberSignature Language="F#" Value="new System.Data.DataTableReader : System.Data.DataTable -&gt; System.Data.DataTableReader" Usage="new System.Data.DataTableReader dataTable" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dataTable" Type="System.Data.DataTable" />
      </Parameters>
      <Docs>
        <param name="dataTable">Z którego nowy <see cref="T:System.Data.DataTableReader" /> uzyskuje swój zestaw wyników. <see cref="T:System.Data.DataTable" /></param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Data.DataTableReader" /> klasy przy użyciu danych z <see cref="T:System.Data.DataTable" />podanego elementu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataTableReader (System.Data.DataTable[] dataTables);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Data.DataTable[] dataTables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.#ctor(System.Data.DataTable[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dataTables As DataTable())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataTableReader(cli::array &lt;System::Data::DataTable ^&gt; ^ dataTables);" />
      <MemberSignature Language="F#" Value="new System.Data.DataTableReader : System.Data.DataTable[] -&gt; System.Data.DataTableReader" Usage="new System.Data.DataTableReader dataTables" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dataTables" Type="System.Data.DataTable[]" />
      </Parameters>
      <Docs>
        <param name="dataTables">Tablica <see cref="T:System.Data.DataTable" /> obiektów, która dostarcza wyniki dla nowego <see cref="T:System.Data.DataTableReader" /> obiektu.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Data.DataTableReader" /> klasy za pomocą podanej <see cref="T:System.Data.DataTable" /> tablicy obiektów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli musisz utworzyć <xref:System.Data.DataTableReader> w oparciu o wszystkie lub podzbiór tabel w konkretnym <xref:System.Data.DataSet>, wywołaj `DataSet` <xref:System.Data.DataSet.CreateDataReader*> metodę. Jeśli chcesz utworzyć nowe <xref:System.Data.DataTableReader> wystąpienie na podstawie `DataTable` grupy wystąpień, które nie są powiązane w inny sposób, użyj tego konstruktora. Możesz również skorzystać z tego konstruktora `DataTables` `DataTableReader`, aby zmienić kolejność sortowania w programie, jeśli ich kolejność w ich źródle `DataSet` nie spełnia Twoich potrzeb.  
  
   
  
## Examples  
 W poniższym przykładzie metoda TestConstructor tworzy dwa <xref:System.Data.DataTable> wystąpienia. Aby przedstawić ten Konstruktor dla <xref:System.Data.DataTableReader> klasy, próbka tworzy nowy `DataTableReader` na podstawie tablicy zawierającej te dwa `DataTables`i wykonuje prostą operację, drukując zawartość z pierwszych kilku kolumn w konsoli programu. Dział. Aby przetestować tę aplikację, należy utworzyć nową aplikację konsolową i wkleić przykładowy kod do nowo utworzonego pliku.  
  
 [!code-csharp[DataWorks DataTableReader.ctor#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.ctor/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.ctor/VB/source.vb#1)]  
  
 W oknie konsoli zostaną wyświetlone następujące wyniki:  
  
```  
1 Mary  
2 Andy  
3 Peter  
4 Russ  
1 Wireless Network Card  
2 Hard Drive  
3 Monitor  
4 CPU  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Close();" />
      <MemberSignature Language="F#" Value="override this.Close : unit -&gt; unit" Usage="dataTableReader.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zamyka bieżący <see cref="T:System.Data.DataTableReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie `Close()` na zamkniętym `DataTableReader` obiekcie nie zgłasza błędu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Depth">
      <MemberSignature Language="C#" Value="public override int Depth { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Depth" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTableReader.Depth" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Depth As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Depth { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Depth : int" Usage="System.Data.DataTableReader.Depth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Głębokość zagnieżdżenia dla bieżącego wiersza <see cref="T:System.Data.DataTableReader" />.</summary>
        <value>Głębokość zagnieżdżenia bieżącego wiersza; zawsze zero.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `DataTableReader`nie obsługuje zagnieżdżania. `Depth` Właściwość zawsze zwraca wartość zero.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FieldCount">
      <MemberSignature Language="C#" Value="public override int FieldCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 FieldCount" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTableReader.FieldCount" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property FieldCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int FieldCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.FieldCount : int" Usage="System.Data.DataTableReader.FieldCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zwraca liczbę kolumn w bieżącym wierszu.</summary>
        <value>Gdy nie jest umieszczony w prawidłowym zestawie wyników, 0; w przeciwnym razie liczba kolumn w bieżącym wierszu.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę pobrania liczby pól w zamkniętej <see cref="T:System.Data.DataTableReader" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetBoolean">
      <MemberSignature Language="C#" Value="public override bool GetBoolean (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool GetBoolean(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetBoolean(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBoolean (ordinal As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool GetBoolean(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetBoolean : int -&gt; bool" Usage="dataTableReader.GetBoolean ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Numer porządkowy kolumny liczony od zera.</param>
        <summary>Pobiera wartość określonej kolumny jako <see cref="T:System.Boolean" />.</summary>
        <returns>Wartość określonej kolumny.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie są wykonywane żadne konwersje; w związku z tym pobrane dane muszą już być wartością logiczną lub da do wartości logicznej lub jest generowany wyjątek.  
  
 Wywołaj <xref:System.Data.DataTableReader.IsDBNull%2A> , aby sprawdzić, czy istnieją wartości null przed wywołaniem tej metody.  
  
   
  
## Examples  
 Poniższy przykład wyświetla zawartość kolumny o numerach 2 w przekazaniu <xref:System.Data.DataTableReader>. Jeśli wartość kolumny w określonym wierszu ma wartość null, kod wyświetla tekst \<null >. Jeśli dane w kolumnie nie mają poprawnego typu, w przykładzie zostanie wyświetlony komunikat o błędzie dla każdego wiersza.  
  
 [!code-csharp[DataWorks DataTableReader.GetBoolean#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetBoolean/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetBoolean#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetBoolean/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Przekazano indeks poza zakresem od 0 do <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Podjęto próbę pobrania danych z usuniętego wiersza.</exception>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę odczytu lub uzyskania dostępu do kolumny w zamkniętej <see cref="T:System.Data.DataTableReader" />.</exception>
        <exception cref="T:System.InvalidCastException">Określona kolumna nie zawiera <see langword="Boolean" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetByte">
      <MemberSignature Language="C#" Value="public override byte GetByte (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8 GetByte(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetByte(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetByte (ordinal As Integer) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Byte GetByte(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetByte : int -&gt; byte" Usage="dataTableReader.GetByte ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Numer porządkowy kolumny liczony od zera.</param>
        <summary>Pobiera wartość określonej kolumny jako bajt.</summary>
        <returns>Wartość określonej kolumny.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie są wykonywane żadne konwersje; w związku z tym pobrane dane muszą już być bajtem lub da do bajtu.  
  
 Wywołaj <xref:System.Data.DataTableReader.IsDBNull%2A> , aby sprawdzić, czy istnieją wartości null przed wywołaniem tej metody.  
  
   
  
## Examples  
 Poniższy przykład wyświetla zawartość kolumny o numerach 2 w przekazaniu <xref:System.Data.DataTableReader>. Jeśli wartość kolumny w określonym wierszu ma wartość null, kod wyświetla tekst \<null >. Jeśli dane w kolumnie nie mają poprawnego typu, w przykładzie zostanie wyświetlony komunikat o błędzie dla każdego wiersza.  
  
 [!code-csharp[DataWorks DataTableReader.GetByte#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetByte/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetByte#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetByte/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Przekazano indeks poza zakresem od 0 do <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Podjęto próbę pobrania danych z usuniętego wiersza.</exception>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę odczytu lub uzyskania dostępu do kolumny w zamkniętej <see langword="DataTableReader" />.</exception>
        <exception cref="T:System.InvalidCastException">Określona kolumna nie zawiera bajtu.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override long GetBytes (int ordinal, long dataIndex, byte[] buffer, int bufferIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 GetBytes(int32 ordinal, int64 dataIndex, unsigned int8[] buffer, int32 bufferIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetBytes(System.Int32,System.Int64,System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBytes (ordinal As Integer, dataIndex As Long, buffer As Byte(), bufferIndex As Integer, length As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long GetBytes(int ordinal, long dataIndex, cli::array &lt;System::Byte&gt; ^ buffer, int bufferIndex, int length);" />
      <MemberSignature Language="F#" Value="override this.GetBytes : int * int64 * byte[] * int * int -&gt; int64" Usage="dataTableReader.GetBytes (ordinal, dataIndex, buffer, bufferIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
        <Parameter Name="dataIndex" Type="System.Int64" />
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="bufferIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Numer porządkowy kolumny liczony od zera.</param>
        <param name="dataIndex">Indeks w polu, z którego ma zostać rozpoczęta operacja odczytu.</param>
        <param name="buffer">Bufor, do którego ma zostać odczytany strumień bajtów.</param>
        <param name="bufferIndex">Indeks w buforze, od którego ma zostać rozpoczęte umieszczanie danych.</param>
        <param name="length">Maksymalna długość do skopiowania do buforu.</param>
        <summary>Odczytuje strumień bajtów, zaczynając od określonego przesunięcia kolumny do bufora jako tablicę rozpoczynającą się od określonego przesunięcia buforu.</summary>
        <returns>Rzeczywista liczba odczytanych bajtów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetBytes`Zwraca liczbę dostępnych bajtów w polu. Większość czasu jest dokładną długością pola. Jednak zwracana liczba może być mniejsza niż wartość prawdziwej długości pola, jeśli `GetBytes` została już użyta do uzyskania bajtów z pola. Może to być przypadek, na przykład gdy <xref:System.Data.DataTableReader> odczytuje dużą strukturę danych do buforu  
  
 W przypadku przekazania bufora, który `null` jest`Nothing` (w Visual Basic) `GetBytes` , zwraca długość całego pola w bajtach, a nie pozostały rozmiar na podstawie parametru przesunięcia buforu.  
  
 Nie są wykonywane żadne konwersje; w związku z tym pobrane dane muszą już być tablicą typu Byte lub da do tablicy typu Byte.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Data.DataTableReader> na podstawie danych z przykładowej bazy danych AdventureWorks i zapisuje każdy pobrany obraz do oddzielnego pliku w C:\ system32\drivers\etc. Aby przetestować tę aplikację, należy utworzyć nową aplikację konsolową, odwołać się do zestawu System. Drawing. dll i wkleić przykładowy kod do nowo utworzonego pliku.  
  
 [!code-csharp[DataWorks DataTableReader.GetBytes#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetBytes/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetBytes#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetBytes/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Przekazano indeks poza zakresem od 0 do <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Podjęto próbę pobrania danych z usuniętego wiersza.</exception>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę odczytu lub uzyskania dostępu do kolumny w zamkniętej <see langword="DataTableReader" />.</exception>
        <exception cref="T:System.InvalidCastException">Określona kolumna nie zawiera tablicy bajtów.</exception>
        <altmember cref="M:System.Data.DataTableReader.GetChars(System.Int32,System.Int64,System.Char[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetChar">
      <MemberSignature Language="C#" Value="public override char GetChar (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance char GetChar(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetChar(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetChar (ordinal As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override char GetChar(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetChar : int -&gt; char" Usage="dataTableReader.GetChar ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Numer porządkowy kolumny liczony od zera.</param>
        <summary>Pobiera wartość określonej kolumny jako znak.</summary>
        <returns>Wartość kolumny.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie są wykonywane żadne konwersje; w związku z tym pobrane dane muszą już być znakami lub da do znaku.  
  
 Wywołaj <xref:System.Data.DataTableReader.IsDBNull%2A> , aby sprawdzić, czy istnieją wartości null przed wywołaniem tej metody.  
  
   
  
## Examples  
 Poniższy przykład wyświetla zawartość kolumny o numerach 2 w przekazaniu DataTableReader. Jeśli wartość kolumny w określonym wierszu ma wartość null, kod wyświetla tekst \<null >. Jeśli dane w kolumnie nie mają poprawnego typu, w przykładzie zostanie wyświetlony komunikat o błędzie dla każdego wiersza.  
  
 [!code-csharp[DataWorks DataTableReader.GetChar#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetChar/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetChar#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetChar/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Przekazano indeks poza zakresem od 0 do <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Podjęto próbę pobrania danych z usuniętego wiersza.</exception>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę odczytu lub uzyskania dostępu do kolumny w zamkniętej <see langword="DataTableReader" />.</exception>
        <exception cref="T:System.InvalidCastException">Określone pole nie zawiera znaku.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override long GetChars (int ordinal, long dataIndex, char[] buffer, int bufferIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 GetChars(int32 ordinal, int64 dataIndex, char[] buffer, int32 bufferIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetChars(System.Int32,System.Int64,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetChars (ordinal As Integer, dataIndex As Long, buffer As Char(), bufferIndex As Integer, length As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long GetChars(int ordinal, long dataIndex, cli::array &lt;char&gt; ^ buffer, int bufferIndex, int length);" />
      <MemberSignature Language="F#" Value="override this.GetChars : int * int64 * char[] * int * int -&gt; int64" Usage="dataTableReader.GetChars (ordinal, dataIndex, buffer, bufferIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
        <Parameter Name="dataIndex" Type="System.Int64" />
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="bufferIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Numer porządkowy kolumny liczony od zera.</param>
        <param name="dataIndex">Indeks w polu, z którego ma zostać rozpoczęta operacja odczytu.</param>
        <param name="buffer">Bufor, do którego ma zostać odczytany strumień znaków.</param>
        <param name="bufferIndex">Indeks w buforze, od którego ma zostać rozpoczęte umieszczanie danych.</param>
        <param name="length">Maksymalna długość do skopiowania do buforu.</param>
        <summary>Zwraca wartość określonej kolumny jako tablicę znaków.</summary>
        <returns>Rzeczywista liczba odczytanych znaków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetChars`Zwraca liczbę znaków dostępnych w polu. Większość czasu jest dokładną długością pola. Jednak zwracana liczba może być mniejsza niż wartość prawdziwej długości pola, jeśli `GetChars` została już użyta w celu uzyskania znaków z pola.  
  
 Rzeczywista liczba odczytanych znaków może być mniejsza niż żądana długość, jeśli osiągnięto koniec pola. W przypadku przekazania bufora o wartości null (`Nothing` w Visual Basic `GetChars` ) funkcja zwraca długość całego pola w znakach, a nie pozostały rozmiar na podstawie parametru przesunięcia buforu.  
  
 Nie są wykonywane żadne konwersje; w związku z tym dane, które mają zostać pobrane, muszą już być tablicą znaków lub da do tablicy znaków.  
  
   
  
## Examples  
 Poniższy przykład demonstruje `GetChars` metodę. Metoda oczekuje przekazanie wypełnionej dwóch kolumn danych: nazwa pliku w pierwszej kolumnie i tablica znaków w drugim. `DataTableReader` `TestGetChars` Ponadto program `TestGetChars` pozwala określić rozmiar buforu, który ma być używany podczas odczytywania danych z tablicy znaków `DataTableReader`w. `TestGetChars`tworzy plik odpowiadający każdemu wierszowi danych w `DataTableReader`, przy użyciu dostarczonych danych w pierwszej kolumnie `DataTableReader` jako nazwa pliku.  
  
 Ta procedura demonstruje użycie `GetChars` metody odczytu danych, które były przechowywane `DataTable` w postaci tablicy znaków. Każdy inny typ danych powoduje, że `GetChars` Metoda `InvalidCastException`generuje.  
  
 [!code-csharp[DataWorks DataTableReader.GetChars#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetChars/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetChars/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Przekazano indeks poza zakresem od 0 do <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Podjęto próbę pobrania danych z usuniętego wiersza.</exception>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę odczytu lub uzyskania dostępu do kolumny w zamkniętej <see langword="DataTableReader" />.</exception>
        <exception cref="T:System.InvalidCastException">Określona kolumna nie zawiera tablicy znaków.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetDataTypeName">
      <MemberSignature Language="C#" Value="public override string GetDataTypeName (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetDataTypeName(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetDataTypeName(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetDataTypeName (ordinal As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ GetDataTypeName(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetDataTypeName : int -&gt; string" Usage="dataTableReader.GetDataTypeName ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Numer porządkowy kolumny liczony od zera.</param>
        <summary>Pobiera ciąg reprezentujący typ danych określonej kolumny.</summary>
        <returns>Ciąg reprezentujący typ danych kolumny.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda zawsze zwraca typ bazowego <xref:System.Data.DataColumn> zamiast typu specyficznego dla dostawcy. <xref:System.Data.DataTableReader.GetDataTypeName%2A>  
  
   
  
## Examples  
 Następująca aplikacja konsolowa wyświetla listę pól i ich nazwy typów z prostego <xref:System.Data.DataTable>:  
  
 [!code-csharp[DataWorks DataTableReader.GetDataTypeName#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetDataTypeName/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetDataTypeName#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetDataTypeName/VB/source.vb#1)]  
  
 W oknie konsoli zostaną wyświetlone następujące wyniki:  
  
```  
ID: Int32  
Name: String  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Przekazano indeks poza zakresem od 0 do <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę odczytu lub uzyskania dostępu do kolumny w zamkniętej <see cref="T:System.Data.DataTableReader" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetDateTime">
      <MemberSignature Language="C#" Value="public override DateTime GetDateTime (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.DateTime GetDateTime(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetDateTime(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetDateTime (ordinal As Integer) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override DateTime GetDateTime(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetDateTime : int -&gt; DateTime" Usage="dataTableReader.GetDateTime ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Numer porządkowy kolumny liczony od zera.</param>
        <summary>Pobiera wartość określonej kolumny jako <see cref="T:System.DateTime" /> obiekt.</summary>
        <returns>Wartość określonej kolumny.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie są wykonywane żadne konwersje; w związku z tym pobrane dane muszą być <xref:System.DateTime> już lub da `DataTime`do.  
  
 Wywołaj <xref:System.Data.DataTableReader.IsDBNull%2A> , aby sprawdzić, czy istnieją wartości null przed wywołaniem tej metody.  
  
   
  
## Examples  
 Poniższy przykład wyświetla zawartość kolumny o numerach 2 w przekazaniu <xref:System.Data.DataTableReader>. Jeśli wartość kolumny w określonym wierszu ma wartość null, kod wyświetla tekst \<null >. Jeśli dane w kolumnie nie mają poprawnego typu, w przykładzie zostanie wyświetlony komunikat o błędzie dla każdego wiersza.  
  
 [!code-csharp[DataWorks DataTableReader.GetDateTime#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetDateTime/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetDateTime#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetDateTime/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Przekazano indeks poza zakresem od 0 do <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Podjęto próbę pobrania danych z usuniętego wiersza.</exception>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę odczytu lub uzyskania dostępu do kolumny w zamkniętej <see langword="DataTableReader" />.</exception>
        <exception cref="T:System.InvalidCastException">Określona kolumna nie zawiera wartości typu DateTime.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetDecimal">
      <MemberSignature Language="C#" Value="public override decimal GetDecimal (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Decimal GetDecimal(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetDecimal(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetDecimal (ordinal As Integer) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Decimal GetDecimal(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetDecimal : int -&gt; decimal" Usage="dataTableReader.GetDecimal ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Numer porządkowy kolumny liczony od zera.</param>
        <summary>Pobiera wartość określonej kolumny jako <see cref="T:System.Decimal" />.</summary>
        <returns>Wartość określonej kolumny.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie są wykonywane żadne konwersje; w związku z tym pobrane dane muszą być <xref:System.Decimal> już lub da `Decimal`do.  
  
 Wywołaj <xref:System.Data.DataTableReader.IsDBNull%2A> , aby sprawdzić, czy istnieją wartości null przed wywołaniem tej metody.  
  
   
  
## Examples  
 Poniższy przykład wyświetla zawartość kolumny o numerach 2 w przekazaniu <xref:System.Data.DataTableReader>. Jeśli wartość kolumny w określonym wierszu ma wartość null, kod wyświetla tekst \<null >. Jeśli dane w kolumnie nie mają poprawnego typu, w przykładzie zostanie wyświetlony komunikat o błędzie dla każdego wiersza.  
  
 [!code-csharp[DataWorks DataTableReader.GetDecimal#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetDecimal/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetDecimal#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetDecimal/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Przekazano indeks poza zakresem od 0 do <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Podjęto próbę pobrania danych z usuniętego wiersza.</exception>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę odczytu lub uzyskania dostępu do kolumny w zamkniętej <see langword="DataTableReader" />.</exception>
        <exception cref="T:System.InvalidCastException">Określona kolumna nie zawiera <see langword="Decimal" /> wartości.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetDouble">
      <MemberSignature Language="C#" Value="public override double GetDouble (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance float64 GetDouble(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetDouble(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetDouble (ordinal As Integer) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override double GetDouble(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetDouble : int -&gt; double" Usage="dataTableReader.GetDouble ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Liczba porządkowa kolumny (liczony od zera).</param>
        <summary>Pobiera wartość kolumny jako liczbę zmiennoprzecinkową o podwójnej precyzji.</summary>
        <returns>Wartość określonej kolumny.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie są wykonywane żadne konwersje; w związku z tym pobrane dane muszą już być liczbą zmiennoprzecinkową o podwójnej precyzji lub muszą być da do liczby zmiennoprzecinkowej o podwójnej precyzji.  
  
 Wywołaj <xref:System.Data.DataTableReader.IsDBNull%2A> , aby sprawdzić, czy istnieją wartości null przed wywołaniem tej metody.  
  
   
  
## Examples  
 Poniższy przykład wyświetla zawartość kolumny o numerach 2 w przekazaniu <xref:System.Data.DataTableReader>. Jeśli wartość kolumny w określonym wierszu ma wartość null, kod wyświetla tekst \<null >. Jeśli dane w kolumnie nie mają poprawnego typu, w przykładzie zostanie wyświetlony komunikat o błędzie dla każdego wiersza.  
  
 [!code-csharp[DataWorks DataTableReader.GetDouble#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetDouble/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetDouble#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetDouble/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Przekazano indeks poza zakresem od 0 do <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Podjęto próbę pobrania danych z usuniętego wiersza.</exception>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę odczytu lub uzyskania dostępu do kolumny w zamkniętej <see langword="DataTableReader" />.</exception>
        <exception cref="T:System.InvalidCastException">Określona kolumna nie zawiera liczby zmiennoprzecinkowej o podwójnej precyzji.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public override System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="override this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="dataTableReader.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca moduł wyliczający, który może być używany do iteracji w kolekcji elementów.</summary>
        <returns><see cref="T:System.Collections.IEnumerator" /> Obiekt reprezentujący kolekcję elementów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Moduły wyliczające umożliwiają odczytywanie danych w <xref:System.Data.DataTableReader>. Nie można użyć modułów wyliczających do modyfikacji źródłowej kolekcji.  
  
 Na początku moduł wyliczający jest umieszczony przed pierwszym elementem w kolekcji. W tym miejscu wywołanie <xref:System.Collections.IEnumerator.Current%2A> zgłasza wyjątek. W związku z tym przed `MoveNext` przeczytaniem `Current`wartości parametru należy wywołać metodę wyliczającą do pierwszego elementu kolekcji.  
  
 `Current`zwraca i zwraca ten sam obiekt <xref:System.Collections.IEnumerator.MoveNext%2A> do momentu wywołania albo <xref:System.Collections.IEnumerator.Reset%2A>lub. <xref:System.Data.Common.DbDataRecord> `MoveNext`ustawia `Current` do następnego elementu.  
  
 Po przekazaniu końca kolekcji moduł wyliczający jest umieszczony po ostatnim elemencie w kolekcji, a wywołanie `MoveNext` zwraca wartość false. Jeśli ostatnie wywołanie `MoveNext` zwrócone `false`, wywołanie `Current` zgłasza wyjątek. Ponadto, ponieważ <xref:System.Data.DataTableReader> zapewnia dostęp do danych tylko do przodu, <xref:System.Collections.IEnumerator.Reset%2A> wywołanie metody IEnumerator zgłasza a <xref:System.NotSupportedException>.  
  
 <xref:System.Data.DataTableReader> Zapewnia stabilny moduł wyliczający. Oznacza to, że nawet jeśli operacje usuwania lub dodawania wierszy <xref:System.Data.DataTableReader.GetEnumerator%2A> są wykonywane w ramach danych źródłowych, moduł wyliczający zwracany przez wywołanie jest nadal ważny.  
  
   
  
## Examples  
 Poniższy przykład demonstruje użycie <xref:System.Data.DataTableReader.GetEnumerator%2A> metody. Obejmuje to zachowanie modułu wyliczającego, gdy wiersze są usuwane z bazowego <xref:System.Data.DataTable> , gdy moduł wyliczający jest aktywny.  
  
 [!code-csharp[DataWorks DataTableReader.GetEnumerator#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetEnumerator/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetEnumerator/VB/source.vb#1)]  
  
 Procedura wyświetla następujący tekst w oknie konsoli:  
  
```  
Peter  
Mary  
Russ  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę odczytu lub uzyskania dostępu do kolumny w zamkniętej <see cref="T:System.Data.DataTableReader" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFieldType">
      <MemberSignature Language="C#" Value="public override Type GetFieldType (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetFieldType(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetFieldType(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetFieldType (ordinal As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetFieldType(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetFieldType : int -&gt; Type" Usage="dataTableReader.GetFieldType ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Numer porządkowy kolumny liczony od zera.</param>
        <summary><see cref="T:System.Type" /> Pobiera, który jest typem danych obiektu.</summary>
        <returns><see cref="T:System.Type" /> Jest to typ danych obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Wywołaj poniższą procedurę, przekazując <xref:System.Data.DataTableReader> w wystąpieniu, aby wyświetlić listę wszystkich pól i pełną nazwę każdego typu w oknie konsoli.  
  
 [!code-csharp[DataWorks DataTableReader.GetFieldType#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetFieldType/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetFieldType#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetFieldType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Przekazano indeks poza zakresem od 0 do <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę odczytu lub uzyskania dostępu do kolumny w zamkniętej <see cref="T:System.Data.DataTableReader" /> .</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFloat">
      <MemberSignature Language="C#" Value="public override float GetFloat (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance float32 GetFloat(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetFloat(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetFloat (ordinal As Integer) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override float GetFloat(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetFloat : int -&gt; single" Usage="dataTableReader.GetFloat ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Numer porządkowy kolumny liczony od zera.</param>
        <summary>Pobiera wartość określonej kolumny jako liczbę zmiennoprzecinkową o pojedynczej precyzji.</summary>
        <returns>Wartość kolumny.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie są wykonywane żadne konwersje; w związku z tym pobrane dane muszą już być liczbą zmiennoprzecinkową o pojedynczej precyzji lub muszą być da do liczby zmiennoprzecinkowej o pojedynczej precyzji.  
  
 Wywołaj <xref:System.Data.DataTableReader.IsDBNull%2A> , aby sprawdzić, czy istnieją wartości null przed wywołaniem tej metody.  
  
   
  
## Examples  
 Poniższy przykład wyświetla zawartość kolumny o numerach 2 w przekazaniu <xref:System.Data.DataTableReader>. Jeśli wartość kolumny w określonym wierszu ma wartość null, kod wyświetla tekst \<null >. Jeśli dane w kolumnie nie mają poprawnego typu, w przykładzie zostanie wyświetlony komunikat o błędzie dla każdego wiersza.  
  
 [!code-csharp[DataWorks DataTableReader.GetFloat#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetFloat/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetFloat#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetFloat/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Przekazano indeks poza zakresem od 0 do <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Podjęto próbę pobrania danych z usuniętego wiersza.</exception>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę odczytu lub uzyskania dostępu do kolumny w zamkniętej <see cref="T:System.Data.DataTableReader" />.</exception>
        <exception cref="T:System.InvalidCastException">Określona kolumna nie zawiera liczby zmiennoprzecinkowej o pojedynczej precyzji.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetGuid">
      <MemberSignature Language="C#" Value="public override Guid GetGuid (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Guid GetGuid(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetGuid(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetGuid (ordinal As Integer) As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Guid GetGuid(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetGuid : int -&gt; Guid" Usage="dataTableReader.GetGuid ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Numer porządkowy kolumny liczony od zera.</param>
        <summary>Pobiera wartość określonej kolumny jako unikatowy identyfikator globalny (GUID).</summary>
        <returns>Wartość określonej kolumny.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie są wykonywane żadne konwersje; w związku z tym pobrane dane muszą być <xref:System.Guid> już lub da `Guid`do.  
  
 Wywołaj <xref:System.Data.DataTableReader.IsDBNull%2A> , aby sprawdzić, czy istnieją wartości null przed wywołaniem tej metody.  
  
   
  
## Examples  
 Poniższy przykład wyświetla zawartość kolumny o numerach 2 w przekazaniu DataTableReader. Jeśli wartość kolumny w określonym wierszu ma wartość null, kod wyświetla tekst \<null >. Jeśli dane w kolumnie nie mają poprawnego typu, w przykładzie zostanie wyświetlony komunikat o błędzie dla każdego wiersza.  
  
 [!code-csharp[DataWorks DataTableReader.GetGuid#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetGuid/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetGuid#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetGuid/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Przekazano indeks poza zakresem od 0 do <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Podjęto próbę pobrania danych z usuniętego wiersza.</exception>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę odczytu lub uzyskania dostępu do kolumny w zamkniętej <see cref="T:System.Data.DataTableReader" />.</exception>
        <exception cref="T:System.InvalidCastException">Określona kolumna nie zawiera identyfikatora GUID.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetInt16">
      <MemberSignature Language="C#" Value="public override short GetInt16 (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int16 GetInt16(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetInt16(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetInt16 (ordinal As Integer) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override short GetInt16(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetInt16 : int -&gt; int16" Usage="dataTableReader.GetInt16 ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Numer porządkowy kolumny liczony od zera</param>
        <summary>Pobiera wartość określonej kolumny jako 16-bitową liczbę całkowitą ze znakiem.</summary>
        <returns>Wartość określonej kolumny.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie są wykonywane żadne konwersje; w związku z tym pobrane dane muszą już być <xref:System.Int16> lub da `Int16`do.  
  
 Wywołaj <xref:System.Data.DataTableReader.IsDBNull%2A> , aby sprawdzić, czy istnieją wartości null przed wywołaniem tej metody.  
  
   
  
## Examples  
 Poniższy przykład wyświetla zawartość kolumny o numerach 2 w przekazaniu <xref:System.Data.DataTableReader>. Jeśli wartość kolumny w określonym wierszu ma wartość null, kod wyświetla tekst \<null >. Jeśli dane w kolumnie nie mają poprawnego typu, w przykładzie zostanie wyświetlony komunikat o błędzie dla każdego wiersza.  
  
 [!code-csharp[DataWorks DataTableReader.GetInt16#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetInt16/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetInt16#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetInt16/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Przekazano indeks poza zakresem od 0 do <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Podjęto próbę pobrania danych z usuniętego wiersza.</exception>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę odczytu lub uzyskania dostępu do kolumny w zamkniętej <see cref="T:System.Data.DataTableReader" />.</exception>
        <exception cref="T:System.InvalidCastException">Określona kolumna nie zawiera 16-bitowej podpisanej liczby całkowitej.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetInt32">
      <MemberSignature Language="C#" Value="public override int GetInt32 (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetInt32(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetInt32(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetInt32 (ordinal As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetInt32(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetInt32 : int -&gt; int" Usage="dataTableReader.GetInt32 ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Numer porządkowy kolumny liczony od zera</param>
        <summary>Pobiera wartość określonej kolumny jako 32-bitową liczbę całkowitą ze znakiem.</summary>
        <returns>Wartość określonej kolumny.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie są wykonywane żadne konwersje; w związku z tym pobrane dane muszą już być <xref:System.Int32> lub da `Int32`do.  
  
 Wywołaj <xref:System.Data.DataTableReader.IsDBNull%2A> , aby sprawdzić, czy istnieją wartości null przed wywołaniem tej metody.  
  
   
  
## Examples  
 Poniższy przykład wyświetla zawartość kolumny o numerach 2 w przekazaniu <xref:System.Data.DataTableReader>. Jeśli wartość kolumny w określonym wierszu ma wartość null, kod wyświetla tekst \<null >. Jeśli dane w kolumnie nie mają poprawnego typu, w przykładzie zostanie wyświetlony komunikat o błędzie dla każdego wiersza.  
  
 [!code-csharp[DataWorks DataTableReader.GetInt32#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetInt32/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetInt32#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetInt32/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Przekazano indeks poza zakresem od 0 do <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Podjęto próbę pobrania danych z usuniętego wiersza.</exception>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę odczytu lub uzyskania dostępu do kolumny w zamkniętej <see cref="T:System.Data.DataTableReader" /> .</exception>
        <exception cref="T:System.InvalidCastException">Określona kolumna nie zawiera 32-bitowej podpisanej wartości całkowitej.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetInt64">
      <MemberSignature Language="C#" Value="public override long GetInt64 (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 GetInt64(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetInt64(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetInt64 (ordinal As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long GetInt64(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetInt64 : int -&gt; int64" Usage="dataTableReader.GetInt64 ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Numer porządkowy kolumny liczony od zera</param>
        <summary>Pobiera wartość określonej kolumny jako 64-bitową liczbę całkowitą ze znakiem.</summary>
        <returns>Wartość określonej kolumny.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie są wykonywane żadne konwersje; w związku z tym pobrane dane muszą już być <xref:System.Int64> lub da `Int64`do.  
  
 Wywołaj <xref:System.Data.DataTableReader.IsDBNull%2A> , aby sprawdzić, czy istnieją wartości null przed wywołaniem tej metody.  
  
   
  
## Examples  
 Poniższy przykład wyświetla zawartość kolumny o numerach 2 w przekazaniu <xref:System.Data.DataTableReader>. Jeśli wartość kolumny w określonym wierszu ma wartość null, kod wyświetla tekst \<null >. Jeśli dane w kolumnie nie mają poprawnego typu, w przykładzie zostanie wyświetlony komunikat o błędzie dla każdego wiersza.  
  
 [!code-csharp[DataWorks DataTableReader.GetInt64#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetInt64/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetInt64#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetInt64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Przekazano indeks poza zakresem od 0 do <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Podjęto próbę pobrania danych z usuniętego wiersza.</exception>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę odczytu lub uzyskania dostępu do kolumny w zamkniętej <see cref="T:System.Data.DataTableReader" /> .</exception>
        <exception cref="T:System.InvalidCastException">Określona kolumna nie zawiera 64-bitowej podpisanej wartości całkowitej.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public override string GetName (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetName(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetName(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetName (ordinal As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ GetName(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetName : int -&gt; string" Usage="dataTableReader.GetName ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Numer porządkowy kolumny liczony od zera</param>
        <summary>Pobiera wartość określonej kolumny jako <see cref="T:System.String" />.</summary>
        <returns>Nazwa określonej kolumny.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metody `GetName` i<xref:System.Data.DataTableReader.GetOrdinal%2A> zapewniają funkcję odwrotną. Oznacza to, że `GetOrdinal` wywołanie dla zwracanej wartości wywołania `GetName` powinno zwrócić oryginalny parametr, który przeszedł do `GetName`; taka sama dotyczy wywołania procedur w kolejności odwrotnej.  
  
   
  
## Examples  
 Poniższy prosty przykład zawiera procedurę, która wyświetla listę nazw wszystkich kolumn w określonym `DataTableReader`i pozycji porządkowej kolumny, do okna konsoli.  
  
 [!code-csharp[DataWorks DataTableReader.GetName#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetName/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetName#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetName/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Przekazano indeks poza zakresem od 0 do <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę odczytu lub uzyskania dostępu do kolumny w zamkniętej <see cref="T:System.Data.DataTableReader" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetOrdinal">
      <MemberSignature Language="C#" Value="public override int GetOrdinal (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetOrdinal(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetOrdinal(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetOrdinal (name As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetOrdinal(System::String ^ name);" />
      <MemberSignature Language="F#" Value="override this.GetOrdinal : string -&gt; int" Usage="dataTableReader.GetOrdinal name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa kolumny.</param>
        <summary>Pobiera numer porządkowy kolumny, uwzględniając nazwę kolumny.</summary>
        <returns>Numer porządkowy kolumny liczony od zera.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ponieważ większość metod dostarczonych przez <xref:System.Data.DataTableReader> klasę musi być dostarczana z numerem kolumny liczb porządkowych, można `GetOrdinal` użyć metody do pobrania numeru kolumny, uwzględniając nazwę kolumny.  
  
 `GetOrdinal`wykonuje najpierw wyszukiwanie z uwzględnieniem wielkości liter. Jeśli to się nie powiedzie, zostanie wykonane drugie wyszukiwanie bez uwzględniania wielkości liter. Jeśli nie odnaleziono numeru kolumny, `IndexOutOfRangeException` jest zgłaszany.  
  
 `GetOrdinal`ma nieuwzględnianie szerokości znaków kana.  
  
 Ponieważ wyszukiwania oparte na liczbie porządkowej są wydajniejsze niż nazwane wyszukiwania, nie jest to efektywne w `GetOrdinal` przypadku wywołania wewnątrz pętli. Oszczędzaj czas, `GetOrdinal` wywołując jednokrotnie i przypisując wyniki do zmiennej całkowitej w celu użycia w pętli  
  
   
  
## Examples  
 Jeśli masz tylko nazwę kolumny, w takim przypadku nazwa kolumny jest podana przez użytkownika i musisz pobrać informacje z kolumny, możesz użyć procedury podobnej do poniższego, aby wyodrębnić wymagane informacje. W tym przykładzie procedura akceptuje nazwę kolumny i zwraca dane zawarte w tej kolumnie dla bieżącego wiersza w <xref:System.Data.DataTableReader> :  
  
 [!code-csharp[DataWorks DataTableReader.GetOrdinal#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetOrdinal/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetOrdinal#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetOrdinal/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę odczytu lub uzyskania dostępu do kolumny w zamkniętej <see cref="T:System.Data.DataTableReader" />.</exception>
        <exception cref="T:System.ArgumentException">Podana nazwa nie jest prawidłową nazwą kolumny.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetProviderSpecificFieldType">
      <MemberSignature Language="C#" Value="public override Type GetProviderSpecificFieldType (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetProviderSpecificFieldType(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetProviderSpecificFieldType(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetProviderSpecificFieldType (ordinal As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Type ^ GetProviderSpecificFieldType(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetProviderSpecificFieldType : int -&gt; Type" Usage="dataTableReader.GetProviderSpecificFieldType ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Numer porządkowy kolumny liczony od zera.</param>
        <summary>Pobiera typ określonej kolumny w formacie specyficznym dla dostawcy.</summary>
        <returns><see cref="T:System.Type" /> Jest to typ danych obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ponieważ zawsze zwraca typ przechowywany w źródłowym <xref:System.Data.DataColumn>, <xref:System.Data.DataTableReader.GetProviderSpecificFieldType%2A> wartość zwracana przez wywołanie metody zawsze zwraca ten <xref:System.Data.DataTable>sam typ co typ przechowywany w elemencie. <xref:System.Data.DataTableReader> Podczas pracy z <xref:System.Data.DataTableReader> klasą <xref:System.Data.DataTableReader.GetProviderSpecificFieldType%2A> wywołanie metody zwraca ten <xref:System.Type.GetType%2A> sam typ co wywołanie metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Przekazano indeks poza zakresem od 0 do <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę odczytu lub uzyskania dostępu do kolumny w zamkniętej <see cref="T:System.Data.DataTableReader" />.</exception>
        <altmember cref="M:System.Data.DataTableReader.GetFieldType(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetProviderSpecificValue">
      <MemberSignature Language="C#" Value="public override object GetProviderSpecificValue (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object GetProviderSpecificValue(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetProviderSpecificValue(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetProviderSpecificValue (ordinal As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ GetProviderSpecificValue(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetProviderSpecificValue : int -&gt; obj" Usage="dataTableReader.GetProviderSpecificValue ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Numer kolumny, której wartość jest pobierana od zera.</param>
        <summary>Pobiera wartość określonej kolumny w formacie specyficznym dla dostawcy.</summary>
        <returns>Wartość określonej kolumny w formacie specyficznym dla dostawcy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ponieważ zawsze zwraca typ przechowywany w źródłowym <xref:System.Data.DataColumn>, <xref:System.Data.DataTableReader.GetProviderSpecificValue%2A> wartość zwracana przez wywołanie metody zawsze zwraca dane tego <xref:System.Data.DataTable>samego typu co dane przechowywane w. <xref:System.Data.DataTableReader> Podczas pracy z <xref:System.Data.DataTableReader> klasą <xref:System.Data.DataTableReader.GetProviderSpecificValue%2A> wywołanie metody zwraca tę samą wartość <xref:System.Data.DataTableReader.GetValue%2A> i typ jak wywołanie metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Przekazano indeks poza zakresem od 0 do <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Podjęto próbę pobrania danych z usuniętego wiersza.</exception>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę odczytu lub uzyskania dostępu do kolumny w zamkniętej<see cref="T:System.Data.DataTableReader" /></exception>
        <altmember cref="M:System.Data.DataTableReader.GetValue(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetProviderSpecificValues">
      <MemberSignature Language="C#" Value="public override int GetProviderSpecificValues (object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetProviderSpecificValues(object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetProviderSpecificValues(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetProviderSpecificValues (values As Object()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetProviderSpecificValues(cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="override this.GetProviderSpecificValues : obj[] -&gt; int" Usage="dataTableReader.GetProviderSpecificValues values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="values">Tablica obiektów, które mają być wypełnione informacjami o typie dla kolumn w <see cref="T:System.Data.DataTableReader" />obiekcie.</param>
        <summary>Wypełnia podaną tablicę informacjami o typie specyficznym dla dostawcy dla wszystkich kolumn w <see cref="T:System.Data.DataTableReader" />.</summary>
        <returns>Liczba wartości kolumn kopiowanych do tablicy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ze względu na to <xref:System.Data.DataTableReader> , że zawsze zwraca dane typu przechowywane w źródłowym <xref:System.Data.DataColumn>, <xref:System.Data.DataTableReader.GetProviderSpecificValues%2A> wartości zwracane przez wywołanie metody są zawsze tego <xref:System.Data.DataTable>samego typu co dane przechowywane w. Podczas pracy z <xref:System.Data.DataTableReader> klasą <xref:System.Data.DataTableReader.GetProviderSpecificValues%2A> wywołanie metody zwraca te same wartości <xref:System.Data.DataTableReader.GetValues%2A> i typy co wywołanie metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Podjęto próbę pobrania danych z usuniętego wiersza.</exception>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę odczytu lub uzyskania dostępu do kolumny w zamkniętej <see cref="T:System.Data.DataTableReader" />.</exception>
        <altmember cref="M:System.Data.DataTableReader.GetValues(System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="GetSchemaTable">
      <MemberSignature Language="C#" Value="public override System.Data.DataTable GetSchemaTable ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Data.DataTable GetSchemaTable() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetSchemaTable" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetSchemaTable () As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Data::DataTable ^ GetSchemaTable();" />
      <MemberSignature Language="F#" Value="override this.GetSchemaTable : unit -&gt; System.Data.DataTable" Usage="dataTableReader.GetSchemaTable " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca, który opisuje metadane <see cref="T:System.Data.DataTableReader" />kolumn. <see cref="T:System.Data.DataTable" /></summary>
        <returns>A <see cref="T:System.Data.DataTable" /> który opisuje metadane kolumn.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda getschemaing zwraca metadane dotyczące każdej kolumny w następującej kolejności:  
  
|Element DataReader — kolumna|Opis|  
|-----------------------|-----------------|  
|ColumnName|Nazwa kolumny, która <xref:System.Data.DataTable>pojawia się w.|  
|ColumnOrdinal|Numer porządkowy kolumny.|  
|ColumnSize|<xref:System.Data.Common.SchemaTableColumn.ColumnSize> -1 Jeśli `MaxLength` Właściwość <xref:System.Data.DataColumn.MaxLength%2A>(lub) nie może zostać określona lub nie jest istotna; w przeciwnym razie, 0 lub dodatnia liczba całkowita, która zawiera wartość. <xref:System.Data.DataColumn>|  
|NumericPrecision|Jeśli typ kolumny jest typu liczbowego, jest to maksymalna precyzja kolumny. Jeśli typ kolumny nie jest typem danych liczbowych, jest to wartość null.|  
|NumericScale|Jeśli typ danych kolumny ma składnik skali, Zwróć liczbę cyfr z prawej strony punktu dziesiętnego. W przeciwnym razie Zwróć wartość null.|  
|DataType|Typ podstawowy kolumny.|  
|Typ dostawcy|Wskaźnik typu danych kolumny. Jeśli typ danych kolumny różni się od wiersza do wiersza, ta wartość jest <xref:System.Object>. Ta kolumna nie może zawierać wartości null.|  
|ISLONG|`true`Jeśli typ danych kolumny ma <xref:System.String> <xref:System.Data.DataColumn.MaxLength%2A> wartość-1. W przeciwnym razie. `false`|  
|AllowDBNull|`true`Jeśli ograniczenie AllowDbNull ma wartość true dla kolumny; w przeciwnym razie. `false`|  
|IsReadOnly|`true`Jeśli nie można zmodyfikować kolumny; w `false`przeciwnym razie.|  
|IsRowVersion|`false`dla każdej kolumny.|  
|IsUnique|`true`: W tej kolumnie nie ma <xref:System.Data.DataTable> dwóch wierszy w tej samej wartości. `IsUnique`ma gwarancję, że kolumna reprezentuje sam klucz lub jeśli istnieje ograniczenie typu UNIKATOWEgo, które ma zastosowanie tylko do tej kolumny. `false`: Kolumna może zawierać zduplikowane wartości w `DataTable`. Wartość domyślna tej kolumny to `false`.|  
|IsKey|`true`: Kolumna jest jednym z zestawów kolumn, które razem jednoznacznie identyfikują wiersz w <xref:System.Data.DataTable>. Zestaw kolumn z `true` ustawioną `IsKey` opcją musi jednoznacznie `DataTable`identyfikować wiersz w. Nie istnieje wymóg, że ten zestaw kolumn jest minimalnym zestawem kolumn. Ten zestaw kolumn może zostać wygenerowany na podstawie `DataTable` klucza podstawowego, unikatowego ograniczenia lub unikatowego indeksu. `false`: Kolumna nie jest wymagana do unikatowego identyfikowania wiersza. Ta wartość jest `true` taka, jeśli kolumna uczestniczy w pojedynczym lub złożonym kluczu podstawowym. W przeciwnym razie jego wartość `false`to.|  
|Isautoincrement|`true`: Kolumna przypisuje wartości do nowych wierszy w stałych przyrostach. `false`: Kolumna nie przypisuje wartości do nowych wierszy w stałych przyrostach. Wartość domyślna tej kolumny to `false`.|  
|BaseCatalogName|Nazwa katalogu w magazynie danych, który zawiera kolumnę. `Null`Jeśli nie można ustalić nazwy wykazu podstawowego. Wartością domyślną dla tej kolumny jest `null` wartość.|  
|BaseSchemaName|Ta wartość jest zawsze `Null`.|  
|BaseTableName|Nazwa <xref:System.Data.DataTable>.|  
|BaseColumnName|Nazwa kolumny w <xref:System.Data.DataTable>.|  
|AutoIncrementSeed|<xref:System.Data.DataTable> Wartość<xref:System.Data.DataColumn.AutoIncrementSeed%2A> właściwości.|  
|AutoIncrementStep|<xref:System.Data.DataTable> Wartość<xref:System.Data.DataColumn.AutoIncrementStep%2A> właściwości.|  
|DefaultValue|<xref:System.Data.DataColumn> Wartość<xref:System.Data.DataColumn.DefaultValue%2A> właściwości.|  
|Wyrażenie|Ciąg wyrażenia, jeśli bieżąca kolumna jest kolumną wyrażenia, a wszystkie kolumny używane w wyrażeniu należą do tego samego `T:System.Data.DataTable` , który zawiera kolumnę expression; w przeciwnym razie. `null`|  
|ColumnMapping|Wartość skojarzona z <xref:System.Data.DataColumn>. <xref:System.Data.MappingType> Typ może być jednym `Attribute`z, `Element`, `Hidden`, lub `SimpleContent`. Wartość domyślna to `Element`.|  
|BaseTableNamespace|<xref:System.Data.DataTable> Wartość<xref:System.Data.DataTable.Namespace%2A> właściwości.|  
|BaseColumnNamespace|<xref:System.Data.DataColumn> Wartość<xref:System.Data.DataColumn.Namespace%2A> właściwości.|  
  
   
  
## Examples  
 Poniższy przykład aplikacji konsolowej pobiera informacje o schemacie dla określonej kolumny. Przekaż procedurę a <xref:System.Data.DataTableReader> i liczbę całkowitą reprezentującą pozycję porządkową kolumny w `DataTableReader`, a procedura wyprowadza informacje o schemacie do okna konsoli. `DisplaySchemaTableInfo`  
  
 [!code-csharp[DataWorks DataTableReader.GetSchemaTable#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetSchemaTable/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetSchemaTable#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetSchemaTable/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Data.DataTableReader" /> Jest zamknięty.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public override string GetString (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetString(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetString(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetString (ordinal As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ GetString(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetString : int -&gt; string" Usage="dataTableReader.GetString ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Numer porządkowy kolumny liczony od zera</param>
        <summary>Pobiera wartość określonej kolumny jako ciąg.</summary>
        <returns>Wartość określonej kolumny.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj <xref:System.Data.DataTableReader.IsDBNull%2A> , aby sprawdzić, czy istnieją wartości null przed wywołaniem tej metody.  
  
   
  
## Examples  
 Poniższy przykład wyświetla zawartość kolumny o numerach 2 w przekazaniu <xref:System.Data.DataTableReader>. Jeśli wartość kolumny w określonym wierszu ma wartość null, kod wyświetla tekst \<null >. Jeśli dane w kolumnie poprawnego typu, przykład wyświetla komunikat o błędzie dla każdego wiersza.  
  
 [!code-csharp[DataWorks DataTableReader.GetString#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetString/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetString#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetString/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Przekazano indeks poza zakresem od 0 do <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Podjęto próbę pobrania danych z usuniętego wiersza.</exception>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę odczytu lub uzyskania dostępu do kolumny w zamkniętej <see cref="T:System.Data.DataTableReader" />.</exception>
        <exception cref="T:System.InvalidCastException">Określona kolumna nie zawiera ciągu.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public override object GetValue (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object GetValue(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetValue(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetValue (ordinal As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ GetValue(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.GetValue : int -&gt; obj" Usage="dataTableReader.GetValue ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Numer porządkowy kolumny liczony od zera</param>
        <summary>Pobiera wartość określonej kolumny w formacie natywnym.</summary>
        <returns>Wartość określonej kolumny. Ta metoda zwraca <see langword="DBNull" /> dla kolumn o wartości null.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chociaż można wywołać <xref:System.Data.DataTableReader.IsDBNull%2A> , aby sprawdzić, czy istnieją wartości null przed wywołaniem tej metody, nie trzeba tego robić.  
  
   
  
## Examples  
 Poniższy przykład wykonuje iterację przez wszystkie kolumny w bieżącym wierszu w <xref:System.Data.DataTableReader>, wyświetlając zawartość każdej kolumny i nazwę kolumny. Ogólnie rzecz biorąc, jeśli zamierzasz współpracować ze wszystkimi kolumnami w wierszu pobranym przez <xref:System.Data.DataTableReader>, rozważ <xref:System.Data.DataTableReader.GetValues%2A> użycie metody zamiast tego, ponieważ jest bardziej wydajne.  
  
 [!code-csharp[DataWorks DataTableReader.GetValue#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetValue/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetValue#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetValue/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Przekazano indeks poza zakresem od 0 do <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Podjęto próbę pobrania danych z usuniętego wiersza.</exception>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę odczytu lub dostępu do kolumn w zamkniętym <see cref="T:System.Data.DataTableReader" /> elemencie.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetValues">
      <MemberSignature Language="C#" Value="public override int GetValues (object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetValues(object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.GetValues(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetValues (values As Object()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetValues(cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="override this.GetValues : obj[] -&gt; int" Usage="dataTableReader.GetValues values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="values">Tablica <see cref="T:System.Object" /> , do której mają zostać skopiowane wartości kolumn <see cref="T:System.Data.DataTableReader" />z.</param>
        <summary>Wypełnia tablicę obiektów wartościami kolumn bieżącego wiersza.</summary>
        <returns>Liczba wartości kolumn kopiowanych do tablicy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku większości aplikacji ta metoda zapewnia efektywny sposób pobierania wszystkich kolumn, a nie pobiera poszczególnych kolumn pojedynczo. Jeśli zamierzasz pobrać wszystkie wartości kolumn z wiersza w <xref:System.Data.DataTableReader> `GetValues` , Metoda zapewnia najbardziej wydajne rozwiązanie.  
  
 Można przekazać <xref:System.Object> tablicę zawierającą mniej niż liczbę kolumn zawartych w wierszu wyników. Tylko ilość danych, które mogą `Object` być przechowywane w tablicy, jest kopiowana do tablicy. Możesz również przekazać `Object` tablicę, której długość jest większa niż liczba kolumn, które są zawarte w wierszu, w którym to przypadku dodatkowe elementy tablicy pozostają niezmienione przez wywołanie metody.  
  
 Ta metoda umieszcza `DBNull` tablicę wyjściową dla kolumn o wartości null.  
  
   
  
## Examples  
 Poniższy przykład demonstruje użycie tablicy o odpowiednim rozmiarze, aby odczytać wszystkie wartości z bieżącego wiersza w podanej <xref:System.Data.DataTableReader>tabeli. Ponadto przykład ilustruje użycie tablicy o stałym rozmiarze, która może być mniejsza lub większa niż liczba dostępnych kolumn.  
  
 [!code-csharp[DataWorks DataTableReader.GetValueObject#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetValueObject/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.GetValueObject#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.GetValueObject/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Przekazano indeks poza zakresem od 0 do <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Podjęto próbę pobrania danych z usuniętego wiersza.</exception>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę odczytu lub uzyskania dostępu do kolumny w zamkniętej <see cref="T:System.Data.DataTableReader" /> .</exception>
      </Docs>
    </Member>
    <Member MemberName="HasRows">
      <MemberSignature Language="C#" Value="public override bool HasRows { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasRows" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTableReader.HasRows" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property HasRows As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool HasRows { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasRows : bool" Usage="System.Data.DataTableReader.HasRows" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Data.DataTableReader" /> zawiera jeden lub więcej wierszy.</summary>
        <value><see langword="true" />Jeśli zawiera jeden lub więcej wierszy; w przeciwnym <see langword="false" />razie. <see cref="T:System.Data.DataTableReader" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `HasRows` Właściwość zwraca informacje o bieżącym zestawie wyników. Jeśli zawiera wiele zestawów wyników, można sprawdzić wartość `HasRows` właściwości <xref:System.Data.DataTableReader.NextResult%2A> natychmiast po wywołaniu metody, aby określić, czy nowy zestaw wyników zawiera wiersze. <xref:System.Data.DataTableReader>  
  
 Użyj właściwości, aby uniknąć konieczności <xref:System.Data.DataTableReader.Read%2A> wywołania metody, <xref:System.Data.DataTableReader> Jeśli nie ma wierszy w bieżącym zestawie wyników. `HasRows`  
  
   
  
## Examples  
 Poniższy przykład zapisuje dwa <xref:System.Data.DataTable> wystąpienia z danymi. Pierwszy <xref:System.Data.DataTable> zawiera jeden wiersz, a drugi nie zawiera żadnych wierszy. W przykładzie tworzony jest <xref:System.Data.DataTableReader> program, który zawiera oba <xref:System.Data.DataTable> obiekty, i wywołuje metodę PrintData, aby wyświetlić zawartość każdego z nich, <xref:System.Data.DataTableReader.HasRows%2A> sprawdzając wartość właściwości każdego przed wywołaniem do PrintData.  
  
 [!code-csharp[DataWorks DataTableReader.HasRows#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.HasRows/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.HasRows#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.HasRows/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę pobrania informacji o zamkniętej <see cref="T:System.Data.DataTableReader" />.</exception>
        <altmember cref="M:System.Data.DataTableReader.NextResult" />
        <altmember cref="M:System.Data.DataTableReader.Read" />
      </Docs>
    </Member>
    <Member MemberName="IsClosed">
      <MemberSignature Language="C#" Value="public override bool IsClosed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClosed" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTableReader.IsClosed" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsClosed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsClosed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsClosed : bool" Usage="System.Data.DataTableReader.IsClosed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Data.DataTableReader" /> jest zamknięty.</summary>
        <value><see langword="true" />Jeśli jest zamknięty; w przeciwnym razie <see langword="false" />. <see cref="T:System.Data.DataTableReader" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTableReader.Close%2A>jest jedyną metodą i `IsClosed` <xref:System.Data.DataTableReader.RecordsAffected%2A> są jedynymi właściwościami, do których <xref:System.Data.DataTableReader> można uzyskać dostęp po zamknięciu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDBNull">
      <MemberSignature Language="C#" Value="public override bool IsDBNull (int ordinal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsDBNull(int32 ordinal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.IsDBNull(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsDBNull (ordinal As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsDBNull(int ordinal);" />
      <MemberSignature Language="F#" Value="override this.IsDBNull : int -&gt; bool" Usage="dataTableReader.IsDBNull ordinal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Numer porządkowy kolumny liczony od zera</param>
        <summary>Pobiera wartość wskazującą, czy kolumna zawiera nieistniejące lub brakujące wartości.</summary>
        <returns><see langword="true" />Jeśli określona wartość kolumny jest równa <see cref="T:System.DBNull" />; w przeciwnym razie,. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj tę metodę, aby sprawdzić, czy wartości kolumny mają wartość null przed wywołaniem wpisanych metod get ( <xref:System.Data.DataTableReader.GetByte%2A>na <xref:System.Data.DataTableReader.GetChar%2A>przykład,, i tak dalej), aby uniknąć ponoszenia błędu.  
  
   
  
## Examples  
 Poniższy przykład wyświetla zawartość kolumny o numerach 2 w przekazaniu <xref:System.Data.DataTableReader>. Jeśli wartość kolumny w określonym wierszu ma wartość null, kod wyświetla tekst \<null >. Jeśli dane w kolumnie poprawnego typu, przykład wyświetla komunikat o błędzie dla każdego wiersza.  
  
 [!code-csharp[DataWorks DataTableReader.IsDbNull#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.IsDbNull/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.IsDbNull#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.IsDbNull/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Przekazano indeks poza zakresem od 0 do <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Podjęto próbę pobrania danych z usuniętego wiersza.</exception>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę odczytu lub uzyskania dostępu do kolumny w zamkniętej <see cref="T:System.Data.DataTableReader" /> .</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Item">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera wartość określonej kolumny w formacie natywnym.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public override object this[int ordinal] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTableReader.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overrides ReadOnly Property Item(ordinal As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ default[int] { System::Object ^ get(int ordinal); };" />
      <MemberSignature Language="F#" Value="member this.Item(int) : obj" Usage="System.Data.DataTableReader.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ordinal" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ordinal">Numer porządkowy kolumny liczony od zera.</param>
        <summary>Pobiera wartość określonej kolumny w formacie natywnym, w którym znajduje się numer porządkowy kolumny.</summary>
        <value>Wartość określonej kolumny w formacie natywnym.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To Przeciążenie <xref:System.Data.DataTableReader.Item%2A> zachowuje <xref:System.Data.DataTableReader.GetValue%2A> się identycznie z metodą.  
  
   
  
## Examples  
 Poniższy przykład wyświetla zawartość wszystkich kolumn we wszystkich wierszach z podanego <xref:System.Data.DataTableReader>elementu. Kod używa <xref:System.Data.DataTableReader.Item%2A> metody (indeksator, w firmie Microsoft C#) do pobrania wartości, która jest zawarta w każdej kolumnie.  
  
 [!code-csharp[DataWorks DataTableReader.Item#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.Item/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.Item#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.Item/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">Przekazano indeks poza zakresem od 0 do <see cref="P:System.Data.DataTableReader.FieldCount" /> -1.</exception>
        <altmember cref="M:System.Data.DataTableReader.GetValue(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public override object this[string name] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTableReader.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overrides ReadOnly Property Item(name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ default[System::String ^] { System::Object ^ get(System::String ^ name); };" />
      <MemberSignature Language="F#" Value="member this.Item(string) : obj" Usage="System.Data.DataTableReader.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa kolumny.</param>
        <summary>Pobiera wartość określonej kolumny w formacie natywnym, w którym znajduje się nazwa kolumny.</summary>
        <value>Wartość określonej kolumny w formacie natywnym.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyszukiwanie z uwzględnieniem wielkości liter jest wykonywane jako pierwsze. Jeśli to się nie powiedzie, zostanie wykonane drugie wyszukiwanie bez uwzględniania wielkości liter.  
  
 Ta metoda jest niezależna od szerokości znaków kana.  
  
 Ta przeciążona wersja <xref:System.Data.DataTableReader.Item%2A> odpowiada za <xref:System.Data.DataTableReader.GetOrdinal%2A> wywołanie metody, <xref:System.Data.DataTableReader.GetValue%2A> a następnie wywołanie metody.  
  
   
  
## Examples  
 <xref:System.Data.DataTableReader> Dana a i nazwa kolumny, procedura GetValueByName zwraca wartość określonej kolumny. Przed wywołaniem tej procedury należy utworzyć nowe <xref:System.Data.DataTableReader> wystąpienie i wywołać jego metodę odczytu co najmniej jeden raz, aby ustawić wskaźnik wiersza w wierszu danych.  
  
 [!code-csharp[DataWorks DataTableReader.ItemName#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.ItemName/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.ItemName#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.ItemName/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Podana nazwa nie jest prawidłową nazwą kolumny.</exception>
        <exception cref="T:System.Data.DeletedRowInaccessibleException">Podjęto próbę pobrania danych z usuniętego wiersza.</exception>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę odczytu lub uzyskania dostępu do kolumny w zamkniętej <see cref="T:System.Data.DataTableReader" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="NextResult">
      <MemberSignature Language="C#" Value="public override bool NextResult ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool NextResult() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.NextResult" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function NextResult () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool NextResult();" />
      <MemberSignature Language="F#" Value="override this.NextResult : unit -&gt; bool" Usage="dataTableReader.NextResult " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Data.DataTableReader" /> Przechodzi do następnego zestawu wyników, jeśli istnieje.</summary>
        <returns><see langword="true" />Jeśli istnieje inny zestaw wyników; w <see langword="false" />przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Służy do przetwarzania wielu wyników, które mogą zostać wygenerowane przez <xref:System.Data.DataTableReader> utworzenie w <xref:System.Data.DataSet> przedziale zawierającym co najmniej dwie tabele lub tablicę zawierającą dwa <xref:System.Data.DataTable> lub więcej wystąpień.  
  
 Nowy <xref:System.Data.DataTableReader> element zostanie umieszczony w pierwszym wyniku.  
  
   
  
## Examples  
 W poniższym przykładzie metoda TestConstructor tworzy dwa <xref:System.Data.DataTable> wystąpienia. Aby przedstawić ten Konstruktor dla <xref:System.Data.DataTableReader> klasy, próbka tworzy nowy `DataTableReader` na podstawie tablicy zawierającej te dwa `DataTables`i wykonuje prostą operację, drukując zawartość z pierwszych kilku kolumn w konsoli programu. Dział. Aby przetestować tę aplikację, należy utworzyć nową aplikację konsolową i wkleić przykładowy kod do nowo utworzonego pliku.  
  
 [!code-csharp[DataWorks DataTableReader.NextResult#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.NextResult/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.NextResult#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.NextResult/VB/source.vb#1)]  
  
 W oknie konsoli zostaną wyświetlone następujące wyniki:  
  
```  
1 Mary  
2 Andy  
3 Peter  
4 Russ  
1 Wireless Network Card  
2 Hard Drive  
3 Monitor  
4 CPU  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę przejścia w zamkniętą <see cref="T:System.Data.DataTableReader" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override bool Read ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Read() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTableReader.Read" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Read();" />
      <MemberSignature Language="F#" Value="override this.Read : unit -&gt; bool" Usage="dataTableReader.Read " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Data.DataTableReader" /> Przechodzi do następnego rekordu.</summary>
        <returns><see langword="true" />Jeśli Wystąpił inny wiersz do odczytania; w <see langword="false" />przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pozycja <xref:System.Data.DataTableReader> domyślna jest wcześniejsza niż pierwszy rekord. W związku z tym należy `Read` wywołać, aby rozpocząć uzyskiwanie dostępu do dowolnych danych.  
  
   
  
## Examples  
 Procedura PrintColumns wykonuje pętlę we wszystkich wierszach w <xref:System.Data.DataTableReader>, wyświetlając zawartość każdej kolumny w oknie konsoli.  
  
 [!code-csharp[DataWorks DataTableReader.Read#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableReader.Read/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableReader.Read#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableReader.Read/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Podjęto próbę odczytu lub uzyskania dostępu do kolumny w zamkniętej <see cref="T:System.Data.DataTableReader" /> .</exception>
      </Docs>
    </Member>
    <Member MemberName="RecordsAffected">
      <MemberSignature Language="C#" Value="public override int RecordsAffected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RecordsAffected" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTableReader.RecordsAffected" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property RecordsAffected As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int RecordsAffected { int get(); };" />
      <MemberSignature Language="F#" Value="member this.RecordsAffected : int" Usage="System.Data.DataTableReader.RecordsAffected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę wierszy wstawionych, zmienionych lub usuniętych przez wykonanie instrukcji SQL.</summary>
        <value><see cref="T:System.Data.DataTableReader" /> Program nie obsługuje tej właściwości i zawsze zwraca 0.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

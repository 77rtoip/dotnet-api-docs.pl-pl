<Type Name="DataSet" FullName="System.Data.DataSet">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="5e84607c810b7307a449ac176f00e6a7a789c10a" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36680149" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class DataSet : System.ComponentModel.MarshalByValueComponent, System.ComponentModel.IListSource, System.ComponentModel.ISupportInitialize, System.ComponentModel.ISupportInitializeNotification, System.Runtime.Serialization.ISerializable, System.Xml.Serialization.IXmlSerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit DataSet extends System.ComponentModel.MarshalByValueComponent implements class System.ComponentModel.IListSource, class System.ComponentModel.ISupportInitialize, class System.ComponentModel.ISupportInitializeNotification, class System.Runtime.Serialization.ISerializable, class System.Xml.Serialization.IXmlSerializable" />
  <TypeSignature Language="DocId" Value="T:System.Data.DataSet" />
  <TypeSignature Language="VB.NET" Value="Public Class DataSet&#xA;Inherits MarshalByValueComponent&#xA;Implements IListSource, ISerializable, ISupportInitialize, ISupportInitializeNotification, IXmlSerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class DataSet : System::ComponentModel::MarshalByValueComponent, System::ComponentModel::IListSource, System::ComponentModel::ISupportInitialize, System::ComponentModel::ISupportInitializeNotification, System::Runtime::Serialization::ISerializable, System::Xml::Serialization::IXmlSerializable" />
  <TypeSignature Language="F#" Value="type DataSet = class&#xA;    inherit MarshalByValueComponent&#xA;    interface IListSource&#xA;    interface IXmlSerializable&#xA;    interface ISupportInitializeNotification&#xA;    interface ISerializable&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System.Data</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Data.Common</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.MarshalByValueComponent</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.IListSource</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitializeNotification</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Xml.Serialization.IXmlSerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("DataSetName")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("Microsoft.VSDesigner.Data.VS.DataSetDesigner, Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItem("Microsoft.VSDesigner.Data.VS.DataSetToolboxItem, Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Xml.Serialization.XmlRoot("DataSet")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Xml.Serialization.XmlSchemaProvider("GetDataSetSchema")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje w pamięci podręcznej danych.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet>, Która jest w pamięci podręcznej danych pobrane ze źródła danych jest głównym architektury ADO.NET. <xref:System.Data.DataSet> Składa się z kolekcją <xref:System.Data.DataTable> obiektów, które można powiązać ze sobą z <xref:System.Data.DataRelation> obiektów. Można również wymusić integralności danych w <xref:System.Data.DataSet> za pomocą <xref:System.Data.UniqueConstraint> i <xref:System.Data.ForeignKeyConstraint> obiektów. Aby uzyskać więcej szczegółowych informacji dotyczących pracy z <xref:System.Data.DataSet> obiekty, zobacz [zestawów danych, DataTables i DataViews](~/docs/framework/data/adonet/dataset-datatable-dataview/index.md).  
  
 Podczas gdy <xref:System.Data.DataTable> obiekty zawierają dane, <xref:System.Data.DataRelationCollection> umożliwia poruszać Tabela hierarchii. Tabele są zawarte w <xref:System.Data.DataTableCollection> dostępne za pośrednictwem <xref:System.Data.DataSet.Tables%2A> właściwości. Podczas uzyskiwania dostępu do <xref:System.Data.DataTable> obiektów, należy pamiętać, że są one warunkowo z uwzględnieniem wielkości liter. Na przykład, jeśli jeden <xref:System.Data.DataTable> o nazwie "mydatatable" i drugiego o nazwie "Mydatatable", ciąg używany do wyszukania go tabel jest traktowany jako wielkość liter. Jednak jeśli istnieje "mydatatable" i "Mydatatable" nie ma, ciąg wyszukiwania jest traktowany jako bez uwzględniania wielkości liter. Aby uzyskać więcej informacji na temat pracy z <xref:System.Data.DataTable> obiekty, zobacz [tworzenie DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/creating-a-datatable.md).  
  
 A <xref:System.Data.DataSet> może odczytywać i zapisywać danych i schematu jako dokumentów XML. Dane i schemat można być transport HTTP i używane przez dowolną aplikację na dowolnej platformie, która jest włączone XML. Schemat można zapisać jako schematu XML z <xref:System.Data.DataSet.WriteXmlSchema%2A> metody, a schemat i dane można zapisać przy użyciu <xref:System.Data.DataSet.WriteXml%2A> metody. Aby odczytać dokument XML, która obejmuje zarówno schematu, jak i dane, należy użyć <xref:System.Data.DataSet.ReadXml%2A> metody.  
  
 W typowej implementacji wielowarstwowej kroki związane z tworzeniem i odświeżanie <xref:System.Data.DataSet>, i z kolei aktualizowanie oryginalnych danych:  
  
1.  Tworzenie i wypełnianie każdego <xref:System.Data.DataTable> w <xref:System.Data.DataSet> z danymi ze źródła danych przy użyciu <xref:System.Data.Common.DataAdapter>.  
  
2.  Zmiany danych w poszczególnych <xref:System.Data.DataTable> obiektów przez dodawanie, aktualizowanie lub usuwanie <xref:System.Data.DataRow> obiektów.  
  
3.  Wywołanie <xref:System.Data.DataSet.GetChanges%2A> metodę w celu utworzenia drugiej <xref:System.Data.DataSet> który funkcje tylko zmiany danych.  
  
4.  Wywołanie <xref:System.Data.Common.DataAdapter.Update%2A> metody <xref:System.Data.Common.DataAdapter>, przekazywanie drugi <xref:System.Data.DataSet> jako argument.  
  
5.  Wywołanie <xref:System.Data.DataSet.Merge%2A> sposób scalania zmian od drugiego <xref:System.Data.DataSet> w pierwszym.  
  
6.  Wywołanie <xref:System.Data.DataSet.AcceptChanges%2A> na <xref:System.Data.DataSet>. Alternatywnie wywołania <xref:System.Data.DataSet.RejectChanges%2A> Aby anulować zmiany.  
  
> [!NOTE]
>  <xref:System.Data.DataSet> i <xref:System.Data.DataTable> obiekty dziedziczyć <xref:System.ComponentModel.MarshalByValueComponent>i obsługuje <xref:System.Runtime.Serialization.ISerializable> interfejs dla niego komunikację zdalną. Są to jedyne obiekty ADO.NET, które może zostać wykonana zdalnie.  
  
> [!NOTE]
>  Klasy dziedziczone z <xref:System.Data.DataSet> zostały zakończone przez moduł garbage collector, ponieważ została pominięta finalizator w <xref:System.Data.DataSet>. Klasy pochodne mogą wywoływać <xref:System.GC.ReRegisterForFinalize%2A> metody w jego konstruktora, aby umożliwić klasy, która ma zostać opracowane przez moduł garbage collector.  
  
   
  
## Examples  
 Poniższy przykład składa się z kilku metod, które połączone, Utwórz i wprowadź <xref:System.Data.DataSet> z **Northwind** bazy danych.  
  
 [!code-csharp[Classic WebData DataSet Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Tego typu są bezpieczne dla operacji wielowątkowych odczytu. Wszystkie operacje zapisu należy przeprowadzić synchronizację.</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Data.DataSet" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataSet ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataSet();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Data.DataSet" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta implementacja <xref:System.Data.DataSet> Konstruktor nie przyjmuje żadnych parametrów i tworzy domyślną nazwę "NewDataSet," dla nowego wystąpienia.  
  
 Nazwę <xref:System.Data.DataSet> jest wymagana do zapewnienia, że reprezentację XML <xref:System.Data.DataSet> zawsze ma nazwę dla elementu dokumentu, który jest elementem najwyższego poziomu w definicji schematu.  
  
   
  
## Examples  
 Poniższy przykład tworzy nowy <xref:System.Data.DataSet>i dodaje dwa <xref:System.Data.DataTable> obiektów do niej.  
  
 [!code-vb[Classic WebData DataSet.DataSet Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.DataSet Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Data.DataTableCollection" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataSet (string dataSetName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string dataSetName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dataSetName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataSet(System::String ^ dataSetName);" />
      <MemberSignature Language="F#" Value="new System.Data.DataSet : string -&gt; System.Data.DataSet" Usage="new System.Data.DataSet dataSetName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dataSetName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dataSetName">Nazwa <see cref="T:System.Data.DataSet" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Data.DataSet" /> klasa o podanej nazwie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nazwę <xref:System.Data.DataSet> jest wymagana do zapewnienia, że reprezentację XML <xref:System.Data.DataSet> zawsze ma nazwę element dokumentu, który jest elementem najwyższego poziomu w definicji schematu.  
  
   
  
## Examples  
 Poniższy przykład tworzy nowy <xref:System.Data.DataSet>, do których dwa <xref:System.Data.DataTable> obiekty zostaną dodane.  
  
 [!code-vb[Classic WebData DataSet.DataSet1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.DataSet1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataSet.DataSetName" />
        <altmember cref="T:System.Data.DataTableCollection" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DataSet (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DataSet(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new System.Data.DataSet : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Data.DataSet" Usage="new System.Data.DataSet (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Dane potrzebne do serializacji lub deserializacji obiektu.</param>
        <param name="context">Źródło i miejsce docelowe danego strumieniu serializowanym.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Data.DataSet" /> klasy, która zawiera informacje o danym serializacji i kontekstu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DataSet (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context, bool ConstructSchema);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context, bool ConstructSchema) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext, ConstructSchema As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DataSet(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context, bool ConstructSchema);" />
      <MemberSignature Language="F#" Value="new System.Data.DataSet : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext * bool -&gt; System.Data.DataSet" Usage="new System.Data.DataSet (info, context, ConstructSchema)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
        <Parameter Name="ConstructSchema" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="info">
          <see cref="T:System.Runtime.Serialization.SerializationInfo" /> Obiektu.</param>
        <param name="context">
          <see cref="T:System.Runtime.Serialization.StreamingContext" /> Obiektu.</param>
        <param name="ConstructSchema">Wartość logiczna.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Data.DataSet" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AcceptChanges">
      <MemberSignature Language="C#" Value="public void AcceptChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.AcceptChanges" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcceptChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcceptChanges();" />
      <MemberSignature Language="F#" Value="member this.AcceptChanges : unit -&gt; unit" Usage="dataSet.AcceptChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zatwierdza wszystkie zmiany wprowadzone do tego <see cref="T:System.Data.DataSet" /> od momentu załadowania lub od czasu ostatniego <see cref="M:System.Data.DataSet.AcceptChanges" /> została wywołana.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zarówno <xref:System.Data.DataRow> i <xref:System.Data.DataTable> klasy mają <xref:System.Data.DataSet.AcceptChanges%2A> metody. Wywoływanie <xref:System.Data.DataTable.AcceptChanges%2A> w <xref:System.Data.DataTable> poziomu przyczyny <xref:System.Data.DataRow.AcceptChanges%2A> metody dla każdego <xref:System.Data.DataRow> do wywołania. Podobnie, wywoływania <xref:System.Data.DataSet.AcceptChanges%2A> na <xref:System.Data.DataSet> powoduje, że <xref:System.Data.DataTable.AcceptChanges%2A> ma być wywoływana dla każdej tabeli w ramach <xref:System.Data.DataSet>. W ten sposób masz wiele poziomów, w których można wywołać metody. Wywoływanie <xref:System.Data.DataSet.AcceptChanges%2A> z <xref:System.Data.DataSet> można wywołać metody dla wszystkich obiektów podrzędnych (na przykład tabel i wierszy) z jednego wywołania.  
  
 Podczas wywoływania `AcceptChanges` na `DataSet`oraz <xref:System.Data.DataRow> obiektów nadal w trybie edycji pomyślnie zakończyć ich edycji. <xref:System.Data.DataRow.RowState%2A> Właściwości każdego <xref:System.Data.DataRow> także zmianę; `Added` i `Modified` wierszy stają się `Unchanged`, i `Deleted` wiersze zostaną usunięte.  
  
 Jeśli `DataSet` zawiera <xref:System.Data.ForeignKeyConstraint> obiektów wywoływania `AcceptChanges` metoda powoduje także, że <xref:System.Data.ForeignKeyConstraint.AcceptRejectRule%2A> mają być egzekwowane.  
  
> [!NOTE]
>  `AcceptChanges` i `RejectChanges` dotyczą tylko `DataRow` powiązanych zmian (oznacza to, Dodaj, Usuń, usuwanie i modyfikowanie). Nie mają zastosowania do schematu lub zmian strukturalnych.  
>   
>  Wywołaniem funkcji AcceptChanges nie zreplikuje tych zmian do źródła danych, jeśli zestaw danych został wypełniony przy użyciu element DataAdapter. W takiej sytuacji należy wywołać <xref:System.Data.Common.DataAdapter.Update%2A> zamiast tego. Zobacz [aktualizowanie źródła danych z obiektów DataAdapter](http://msdn.microsoft.com/library/33y2221y.aspx) Aby uzyskać więcej informacji.  
  
   
  
## Examples  
 W poniższym przykładzie dodano <xref:System.Data.DataRow> do <xref:System.Data.DataTable> w <xref:System.Data.DataSet>. <xref:System.Data.DataSet.AcceptChanges%2A> Wywoływana jest metoda następnie <xref:System.Data.DataSet>, które kaskady do wszystkich <xref:System.Data.DataTable> obiektów, które zawiera.  
  
 [!code-csharp[Classic WebData DataSet.AcceptChanges#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.AcceptChanges/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.AcceptChanges#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.AcceptChanges/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="dataSet.BeginInit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rozpoczyna inicjowanie <see cref="T:System.Data.DataSet" /> który jest używany w formularzu lub używany przez inny składnik. Inicjowanie występuje w czasie wykonywania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Środowisku projektowania programu Visual Studio .NET używa tej metody, aby rozpocząć inicjowanie składnik, który jest używany w formularzu lub używany przez inny składnik. <xref:System.Data.DataSet.EndInit%2A> Metoda kończy się inicjowania. Przy użyciu <xref:System.Data.DataSet.BeginInit%2A> i <xref:System.Data.DataSet.EndInit%2A> metody uniemożliwia użycie przed pełnym zainicjowaniem formantu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CaseSensitive">
      <MemberSignature Language="C#" Value="public bool CaseSensitive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CaseSensitive" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.CaseSensitive" />
      <MemberSignature Language="VB.NET" Value="Public Property CaseSensitive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CaseSensitive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CaseSensitive : bool with get, set" Usage="System.Data.DataSet.CaseSensitive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą czy ciągu porównania w <see cref="T:System.Data.DataTable" /> obiektów jest rozróżniana wielkość liter.</summary>
        <value>
          <see langword="true" /> Jeśli porównywania ciągów jest rozróżniana wielkość liter; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.CaseSensitive%2A> Właściwość ma wpływ na sposób sortowanie, wyszukiwanie i filtrowanie operacje są wykonywane na każdym <xref:System.Data.DataTable> obiektów zawartych w <xref:System.Data.DataSet> przy użyciu <xref:System.Data.DataTable.Select%2A> metody.  
  
 Przez ustawienie domyślne <xref:System.Data.DataSet.CaseSensitive%2A> właściwość <xref:System.Data.DataSet> ustawia również <xref:System.Data.DataTable.CaseSensitive%2A> właściwości każdego skojarzone <xref:System.Data.DataTable> na tę samą wartość.  
  
   
  
## Examples  
 W poniższym przykładzie <xref:System.Data.DataSet.CaseSensitive%2A> właściwości.  
  
 [!code-vb[Classic WebData DataSet.CaseSensitive Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.CaseSensitive Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="dataSet.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Czyści <see cref="T:System.Data.DataSet" /> danych przez usunięcie wszystkich wierszy we wszystkich tabelach.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Data.DataSet> jest powiązany z <xref:System.Xml.XmlDataDocument>, wywoływania <xref:System.Data.DataSet.Clear%2A?displayProperty=nameWithType> lub <xref:System.Data.DataTable.Clear%2A?displayProperty=nameWithType> zgłasza <xref:System.NotSupportedException>. Aby tego uniknąć, przechodzenie przez każdej tabeli, usunięcie każdego wiersza, w jednym naraz.  
  
   
  
## Examples  
 Poniższy przykład powoduje wyczyszczenie <xref:System.Data.DataSet> wszystkich wierszy we wszystkich tabelach.  
  
 [!code-csharp[Classic WebData DataSet.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual System.Data.DataSet Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Data.DataSet Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As DataSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Data::DataSet ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; System.Data.DataSet&#xA;override this.Clone : unit -&gt; System.Data.DataSet" Usage="dataSet.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Kopiuje strukturę <see cref="T:System.Data.DataSet" />, łącznie ze wszystkimi <see cref="T:System.Data.DataTable" /> schematów, relacje i ograniczeń. Nie kopiuje danych.</summary>
        <returns>Nowy <see cref="T:System.Data.DataSet" /> z tego samego schematu, ponieważ bieżący <see cref="T:System.Data.DataSet" />, ale żadne dane.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Jeśli podklasy tych klas klonu będzie również tego samego podklasy.  
  
   
  
## Examples  
 Poniższy przykład tworzy Sklonowanie <xref:System.Data.DataSet> schematu obiektu.  
  
 [!code-csharp[Classic WebData DataSet.Clone Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Clone Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Clone Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Clone Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.Copy" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public System.Data.DataSet Copy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataSet Copy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Copy" />
      <MemberSignature Language="VB.NET" Value="Public Function Copy () As DataSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataSet ^ Copy();" />
      <MemberSignature Language="F#" Value="member this.Copy : unit -&gt; System.Data.DataSet" Usage="dataSet.Copy " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Kopiuje strukturę i dane dla tego <see cref="T:System.Data.DataSet" />.</summary>
        <returns>Nowy <see cref="T:System.Data.DataSet" /> z taką samą strukturę (schematy tabeli, relacji i ograniczeń) oraz dane jako to <see cref="T:System.Data.DataSet" />.  
  
 <block subset="none" type="note"><para> Jeśli podklasy tych klas kopia będzie również tego samego podklasy.  </para></block></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Data.DataSet.Copy%2A> metody, aby utworzyć kopię oryginału <xref:System.Data.DataSet>.  
  
 [!code-csharp[Classic WebData DataSet.Copy Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Copy Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Copy Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Copy Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.Clone" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDataReader">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca <see cref="T:System.Data.DataTableReader" /> o jeden wynik na <see cref="T:System.Data.DataTable" />w sekwencji takie same jak tabele są wyświetlane <see cref="P:System.Data.DataSet.Tables" /> kolekcji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby zapewnić kolejność zestawów wyników w zwróconym <xref:System.Data.DataTableReader>, jeśli <xref:System.Data.DataTable> w <xref:System.Data.DataSet> jest pusta, jego będą reprezentowane przez pusty zestaw wyników w w zwróconym `DataTableReader`.  
  
   
  
## Examples  
 W tym przykładzie aplikacji konsoli, tworzy trzy <xref:System.Data.DataTable> wystąpień i dodaje do <xref:System.Data.DataSet>. Przykład wywołania <xref:System.Data.DataSet.CreateDataReader%2A> — metoda i wyświetla zawartość zwracana <xref:System.Data.DataTableReader>. Należy pamiętać, że kolejność wyniku ustawia w `DataTableReader` jest kontrolowany przez inicjowanym z `DataTable` wystąpień przekazywane jako parametry.  
  
> [!NOTE]
>  W tym przykładzie pokazano, jak używać jednej z zastąpionej wersji `CreateDataReader`. Inne przykłady, które mogą być dostępne znajduje się w tematach poszczególnych przeciążenia.  
  
 [!code-csharp[DataWorks DataSet.CreateDataReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.CreateDataReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.CreateDataReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.CreateDataReader/VB/source.vb#1)]  
  
 W przykładzie wyświetlono następujący kod w oknie konsoli:  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDataReader">
      <MemberSignature Language="C#" Value="public System.Data.DataTableReader CreateDataReader ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTableReader CreateDataReader() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.CreateDataReader" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateDataReader () As DataTableReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTableReader ^ CreateDataReader();" />
      <MemberSignature Language="F#" Value="member this.CreateDataReader : unit -&gt; System.Data.DataTableReader" Usage="dataSet.CreateDataReader " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableReader</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.Data.DataTableReader" /> o jeden wynik na <see cref="T:System.Data.DataTable" />w sekwencji takie same jak tabele są wyświetlane <see cref="P:System.Data.DataSet.Tables" /> kolekcji.</summary>
        <returns>A <see cref="T:System.Data.DataTableReader" /> zawierający zestawy wyników, odpowiadający <see cref="T:System.Data.DataTable" /> wystąpień znajdujących się w źródle <see cref="T:System.Data.DataSet" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby zapewnić kolejność zestawów wyników w zwróconym <xref:System.Data.DataTableReader>, jeśli <xref:System.Data.DataTable> w <xref:System.Data.DataSet> jest pusta, jego jest reprezentowana przez pusty zestaw wyników w w zwróconym `DataTableReader`.  
  
   
  
## Examples  
 Poniższy przykład tworzy trzy <xref:System.Data.DataTable> wystąpień i dodaje do <xref:System.Data.DataSet>. Przykład następnie przekazuje wypełniony `DataSet` do procedury, która wywołuje <xref:System.Data.DataSet.CreateDataReader%2A> — metoda i będzie kontynuowane do iteracji zestawów wyników zawartych w <xref:System.Data.DataTableReader>. W przykładzie przedstawiono wyniki w oknie konsoli.  
  
 [!code-csharp[DataWorks DataSet.DataTableReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.DataTableReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.DataTableReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.DataTableReader/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDataReader">
      <MemberSignature Language="C#" Value="public System.Data.DataTableReader CreateDataReader (params System.Data.DataTable[] dataTables);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTableReader CreateDataReader(class System.Data.DataTable[] dataTables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.CreateDataReader(System.Data.DataTable[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateDataReader (ParamArray dataTables As DataTable()) As DataTableReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTableReader ^ CreateDataReader(... cli::array &lt;System::Data::DataTable ^&gt; ^ dataTables);" />
      <MemberSignature Language="F#" Value="member this.CreateDataReader : System.Data.DataTable[] -&gt; System.Data.DataTableReader" Usage="dataSet.CreateDataReader dataTables" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataTables" Type="System.Data.DataTable[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="dataTables">Ustawia tablicy DataTables dostarczanie kolejność wyniku w <see cref="T:System.Data.DataTableReader" />.</param>
        <summary>Zwraca <see cref="T:System.Data.DataTableReader" /> o jeden wynik na <see cref="T:System.Data.DataTable" />.</summary>
        <returns>A <see cref="T:System.Data.DataTableReader" /> zawierający zestawy wyników, odpowiadający <see cref="T:System.Data.DataTable" /> wystąpień znajdujących się w źródle <see cref="T:System.Data.DataSet" />. Zestawy wyników zwróconych znajdują się w kolejności określonej przez <paramref name="dataTables" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W celu zapewnienia, że kolejność wyniku ustawia w zwróconym <xref:System.Data.DataTableReader>, jeśli <xref:System.Data.DataTable> w <xref:System.Data.DataSet> jest pusta, jego jest reprezentowana przez pusty zestaw wyników w w zwróconym `DataTableReader`. Ponieważ ta wersja przeciążone pozwala podać listę `DataTable` wystąpienia jako parametry, można określić kolejność wyświetlania zestawów wyników w zwróconym `DataTableReader`.  
  
   
  
## Examples  
 W tym przykładzie aplikacji konsoli, tworzy trzy <xref:System.Data.DataTable> wystąpień i dodaje do <xref:System.Data.DataSet>. Przykład wywołania <xref:System.Data.DataSet.CreateDataReader%2A> — metoda i wyświetla zawartość zwracana <xref:System.Data.DataTableReader>. Należy pamiętać, że kolejność wyniku ustawia w `DataTableReader` jest kontrolowany przez inicjowanym z `DataTable` wystąpień przekazywane jako parametry. W przykładzie przedstawiono wyniki w oknie konsoli.  
  
 [!code-csharp[DataWorks DataSet.DataTableReaderTables#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.DataTableReaderTables/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.DataTableReaderTables#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.DataTableReaderTables/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataSetName">
      <MemberSignature Language="C#" Value="public string DataSetName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DataSetName" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.DataSetName" />
      <MemberSignature Language="VB.NET" Value="Public Property DataSetName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DataSetName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DataSetName : string with get, set" Usage="System.Data.DataSet.DataSetName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę bieżącego <see cref="T:System.Data.DataSet" />.</summary>
        <value>Nazwa <see cref="T:System.Data.DataSet" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy nowy <xref:System.Data.DataSet> z danym <xref:System.Data.DataSet.DataSetName%2A>.  
  
 [!code-csharp[Classic WebData DataSet.DataSetName Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.DataSetName Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.DataSetName Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.DataSetName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultViewManager">
      <MemberSignature Language="C#" Value="public System.Data.DataViewManager DefaultViewManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataViewManager DefaultViewManager" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.DefaultViewManager" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultViewManager As DataViewManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataViewManager ^ DefaultViewManager { System::Data::DataViewManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultViewManager : System.Data.DataViewManager" Usage="System.Data.DataSet.DefaultViewManager" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataViewManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera niestandardowy widok danych zawartych w <see cref="T:System.Data.DataSet" /> umożliwiają filtrowanie, wyszukiwanie i nawigacja przy użyciu niestandardowego <see cref="T:System.Data.DataViewManager" />.</summary>
        <value>A <see cref="T:System.Data.DataViewManager" /> obiektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataViewManager> Zwrócony przez <xref:System.Data.DataSet.DefaultViewManager%2A> właściwość służy do tworzenia niestandardowych ustawień dla każdego <xref:System.Data.DataTable> w <xref:System.Data.DataSet>.  
  
 Po uzyskaniu <xref:System.Data.DataView> z <xref:System.Data.DataTable>, sortowania, filtrowanie, i <xref:System.Data.DataViewRowState> są skonfigurowane zgodnie z ustawieniami <xref:System.Data.DataSet.DefaultViewManager%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykład pobiera domyślny <xref:System.Data.DataViewManager> dla <xref:System.Data.DataSet>i dodaje <xref:System.Data.DataTable> do <xref:System.Data.DataTableCollection>.  
  
 [!code-vb[Classic WebData DataSet.DefaultViewManager Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.DefaultViewManager Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DetermineSchemaSerializationMode">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Określa <see cref="P:System.Data.DataSet.SchemaSerializationMode" /> dla <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tę metodę można wywołać podczas deserializacji typu <xref:System.Data.DataSet> Aby ustalić jego <xref:System.Data.DataSet.SchemaSerializationMode%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="DetermineSchemaSerializationMode">
      <MemberSignature Language="C#" Value="protected System.Data.SchemaSerializationMode DetermineSchemaSerializationMode (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Data.SchemaSerializationMode DetermineSchemaSerializationMode(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.DetermineSchemaSerializationMode(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Protected Function DetermineSchemaSerializationMode (reader As XmlReader) As SchemaSerializationMode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Data::SchemaSerializationMode DetermineSchemaSerializationMode(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.DetermineSchemaSerializationMode : System.Xml.XmlReader -&gt; System.Data.SchemaSerializationMode" Usage="dataSet.DetermineSchemaSerializationMode reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.SchemaSerializationMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Xml.XmlReader" /> Wystąpienia przekazywaną podczas deserializacji <see cref="T:System.Data.DataSet" />.</param>
        <summary>Określa <see cref="P:System.Data.DataSet.SchemaSerializationMode" /> dla <see cref="T:System.Data.DataSet" />.</summary>
        <returns>
          <see cref="T:System.Data.SchemaSerializationMode" /> Wyliczenie wskazujące, czy informacje o schematu została pominięta z ładunku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tę metodę można wywołać podczas deserializacji typu <xref:System.Data.DataSet> Aby ustalić jego <xref:System.Data.DataSet.SchemaSerializationMode%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DetermineSchemaSerializationMode">
      <MemberSignature Language="C#" Value="protected System.Data.SchemaSerializationMode DetermineSchemaSerializationMode (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Data.SchemaSerializationMode DetermineSchemaSerializationMode(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.DetermineSchemaSerializationMode(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Function DetermineSchemaSerializationMode (info As SerializationInfo, context As StreamingContext) As SchemaSerializationMode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Data::SchemaSerializationMode DetermineSchemaSerializationMode(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="member this.DetermineSchemaSerializationMode : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Data.SchemaSerializationMode" Usage="dataSet.DetermineSchemaSerializationMode (info, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.SchemaSerializationMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">
          <see cref="T:System.Runtime.Serialization.SerializationInfo" /> Który <see langword="DataSet" />na chroniony Konstruktor <see cref="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" /> została wywołana z podczas deserializacji w scenariuszach komunikacji zdalnej.</param>
        <param name="context">
          <see cref="T:System.Runtime.Serialization.StreamingContext" /> Który <see langword="DataSet" />na chroniony Konstruktor <see cref="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" /> została wywołana z podczas deserializacji w scenariuszach komunikacji zdalnej.</param>
        <summary>Określa <see cref="P:System.Data.DataSet.SchemaSerializationMode" /> dla <see cref="T:System.Data.DataSet" />.</summary>
        <returns>
          <see cref="T:System.Data.SchemaSerializationMode" /> Wyliczenie wskazujące, czy informacje o schematu została pominięta z ładunku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tę metodę można wywołać podczas deserializacji typu <xref:System.Data.DataSet> Aby ustalić jego <xref:System.Data.DataSet.SchemaSerializationMode%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="dataSet.EndInit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Kończy się inicjowanie <see cref="T:System.Data.DataSet" /> który jest używany w formularzu lub używany przez inny składnik. Inicjowanie występuje w czasie wykonywania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Środowisku projektowania programu Visual Studio .NET używa tej metody, aby zakończyć inicjowanie składnik, który jest używany w formularzu lub używany przez inny składnik. <xref:System.Data.DataSet.BeginInit%2A> Metoda uruchamia inicjowania. Przy użyciu <xref:System.Data.DataSet.BeginInit%2A> i <xref:System.Data.DataSet.EndInit%2A> metody uniemożliwia użycie przed pełnym zainicjowaniem formantu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnforceConstraints">
      <MemberSignature Language="C#" Value="public bool EnforceConstraints { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnforceConstraints" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.EnforceConstraints" />
      <MemberSignature Language="VB.NET" Value="Public Property EnforceConstraints As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnforceConstraints { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnforceConstraints : bool with get, set" Usage="System.Data.DataSet.EnforceConstraints" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy reguły ograniczeń zostaną wykonane podczas próby żadnej operacji aktualizacji.</summary>
        <value>
          <see langword="true" /> Jeśli zasady są wymuszane; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ograniczenia są ustawione na <xref:System.Data.DataTable> poziom (<xref:System.Data.DataTable.Constraints%2A> właściwości). Aby uzyskać więcej informacji o tworzeniu ograniczeń, zobacz [ograniczenia DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/datatable-constraints.md).  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Data.DataSet> z jednej tabeli, jedną kolumnę pięć wierszy i jeden <xref:System.Data.UniqueConstraint>. <xref:System.Data.DataSet.EnforceConstraints%2A> Właściwość jest ustawiona na `false` i wartości każdego wiersza są ustawiane na tę samą wartość. Gdy <xref:System.Data.DataSet.EnforceConstraints%2A> właściwości jest resetowany do `true`, <xref:System.Data.ConstraintException> jest generowany.  
  
 [!code-csharp[Classic WebData DataSet.EnforceConstraints Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.EnforceConstraints Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.EnforceConstraints Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.EnforceConstraints Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.ConstraintException">Nie można wymusić jedno lub więcej ograniczeń.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExtendedProperties">
      <MemberSignature Language="C#" Value="public System.Data.PropertyCollection ExtendedProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.PropertyCollection ExtendedProperties" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.ExtendedProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExtendedProperties As PropertyCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::PropertyCollection ^ ExtendedProperties { System::Data::PropertyCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExtendedProperties : System.Data.PropertyCollection" Usage="System.Data.DataSet.ExtendedProperties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.PropertyCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję użytkownika informacje związane z <see langword="DataSet" />.</summary>
        <value>A <see cref="T:System.Data.PropertyCollection" /> z wszystkie niestandardowe informacje użytkownika.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.ExtendedProperties%2A> Właściwość umożliwia przechowywania informacji niestandardowych o `DataSet`. Na przykład może przechowywać czas, kiedy należy odświeżyć dane.  
  
 Rozszerzone właściwości musi być typu <xref:System.String> należy je utrwalone po <xref:System.Data.DataSet> jest zapisywany w formacie XML.  
  
   
  
## Examples  
 Poniższy przykład umożliwia dodanie właściwości niestandardowych do <xref:System.Data.PropertyCollection> zwrócony przez <xref:System.Data.DataColumn.ExtendedProperties%2A> właściwości. Drugi przykład pobiera właściwości niestandardowej.  
  
 [!code-csharp[Classic WebData DataColumn.ExtendedProperties Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataColumn.ExtendedProperties Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataColumn.ExtendedProperties Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataColumn.ExtendedProperties Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChanges">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera kopię <see cref="T:System.Data.DataSet" /> zawierający wszystkie zmiany wprowadzone od czasu ostatniego załadowania lub od <see cref="M:System.Data.DataSet.AcceptChanges" /> została wywołana.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChanges">
      <MemberSignature Language="C#" Value="public System.Data.DataSet GetChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataSet GetChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetChanges" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChanges () As DataSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataSet ^ GetChanges();" />
      <MemberSignature Language="F#" Value="member this.GetChanges : unit -&gt; System.Data.DataSet" Usage="dataSet.GetChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera kopię <see cref="T:System.Data.DataSet" /> zawierający wszystkie zmiany wprowadzone od momentu załadowania lub od <see cref="M:System.Data.DataSet.AcceptChanges" /> ostatniego została wywołana.</summary>
        <returns>Zmian z tego <see cref="T:System.Data.DataSet" /> zawierających akcje wykonać na nim i nowszych można scalić w użyciu <see cref="M:System.Data.DataSet.Merge(System.Data.DataSet)" />. Jeśli zostaną znalezione nie zmienionych wierszy, metoda zwraca <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tworzy nowy <xref:System.Data.DataSet> zawierający kopię wszystkich wierszy w oryginalnym <xref:System.Data.DataSet> , która ma oczekujące zmiany. Ograniczenia relacji może spowodować dodatkowe wiersze bez zmian do dodania do nowej <xref:System.Data.DataSet> Jeśli niezmienione wiersze zawierają kluczy podstawowych odpowiadający klucze obce w zmienionych wierszy. Metoda zwraca `null` , jeśli nie ma żadnych wierszy w oryginalnym <xref:System.Data.DataSet> , która ma oczekujące zmiany.  
  
   
  
## Examples  
 Poniższy przykład tworzy prosty <xref:System.Data.DataSet> z jednej tabeli, dwóch kolumn i wierszy dziesięć. Dwie wartości są zmieniane, a jeden wiersz zostanie dodany. Podzbiór zmienionych danych został utworzony za pomocą <xref:System.Data.DataSet.GetChanges%2A> metody. Po uzgodnieniu błędy, kolumna zostanie dodana do podzbioru zmiany schematu. Gdy <xref:System.Data.DataSet.Merge%2A> metoda jest wywoływana z `missingSchemaAction` ustawioną `MissingSchemaAction.Add`, nowej kolumny, która jest dodane do oryginalnej <xref:System.Data.DataSet> schematu obiektu.  
  
 [!code-csharp[Classic WebData DataSet.GetChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.HasChanges" />
      </Docs>
    </Member>
    <Member MemberName="GetChanges">
      <MemberSignature Language="C#" Value="public System.Data.DataSet GetChanges (System.Data.DataRowState rowStates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataSet GetChanges(valuetype System.Data.DataRowState rowStates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetChanges(System.Data.DataRowState)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChanges (rowStates As DataRowState) As DataSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataSet ^ GetChanges(System::Data::DataRowState rowStates);" />
      <MemberSignature Language="F#" Value="member this.GetChanges : System.Data.DataRowState -&gt; System.Data.DataSet" Usage="dataSet.GetChanges rowStates" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rowStates" Type="System.Data.DataRowState" />
      </Parameters>
      <Docs>
        <param name="rowStates">Jeden z <see cref="T:System.Data.DataRowState" /> wartości.</param>
        <summary>Pobiera kopię <see cref="T:System.Data.DataSet" /> zawierający wszystkie zmiany wprowadzone od czasu ostatniego załadowania lub od <see cref="M:System.Data.DataSet.AcceptChanges" /> została wywołana, filtrowane według <see cref="T:System.Data.DataRowState" />.</summary>
        <returns>Filtrowane kopię <see cref="T:System.Data.DataSet" /> zawierających akcje wykonać na nim, a następnie scalenia w użyciu <see cref="M:System.Data.DataSet.Merge(System.Data.DataSet)" />. Jeśli żadne wiersze z żądaną <see cref="T:System.Data.DataRowState" /> zostaną znalezione, metoda zwraca <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.GetChanges%2A> Metoda jest używana do utworzenia drugiej <xref:System.Data.DataSet> obiekt, który zawiera tylko zmiany wprowadzone do oryginalnej. Użyj `rowStates` argumentu, aby określić typ zmiany powinien zawierać nowy obiekt.  
  
 Ta wartość zwracana kopiowania zaprojektowano w celu scalenia w tym oryginalnego <xref:System.Data.DataSet>. Ograniczenia relacji może spowodować wierszy nadrzędnych oznaczone `Unchanged` do uwzględnienia. Jeśli żadne wiersze z żądaną <xref:System.Data.DataRowState> zostaną znalezione, <xref:System.Data.DataSet.GetChanges%2A> metoda zwraca `null`.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Data.DataSet.GetChanges%2A> metodę w celu utworzenia drugiej <xref:System.Data.DataSet> obiektu, który jest następnie używany do aktualizowania źródła danych.  
  
 [!code-csharp[Classic WebData DataSet.GetChanges1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetChanges1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDataSetSchema">
      <MemberSignature Language="C#" Value="public static System.Xml.Schema.XmlSchemaComplexType GetDataSetSchema (System.Xml.Schema.XmlSchemaSet schemaSet);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Schema.XmlSchemaComplexType GetDataSetSchema(class System.Xml.Schema.XmlSchemaSet schemaSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetDataSetSchema(System.Xml.Schema.XmlSchemaSet)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDataSetSchema (schemaSet As XmlSchemaSet) As XmlSchemaComplexType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Schema::XmlSchemaComplexType ^ GetDataSetSchema(System::Xml::Schema::XmlSchemaSet ^ schemaSet);" />
      <MemberSignature Language="F#" Value="static member GetDataSetSchema : System.Xml.Schema.XmlSchemaSet -&gt; System.Xml.Schema.XmlSchemaComplexType" Usage="System.Data.DataSet.GetDataSetSchema schemaSet" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchemaComplexType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="schemaSet" Type="System.Xml.Schema.XmlSchemaSet" />
      </Parameters>
      <Docs>
        <param name="schemaSet">Określony schemat jest ustawiona.</param>
        <summary>Pobiera kopię <see cref="T:System.Xml.Schema.XmlSchemaSet" /> dla zestawu danych.</summary>
        <returns>Kopię <see cref="T:System.Xml.Schema.XmlSchemaSet" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="dataSet.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> przechowuje dane serializowane skojarzone z <see cref="T:System.Data.DataSet" />.</param>
        <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> , która zawiera źródło docelowego serializowanym strumieniu skojarzone z <see cref="T:System.Data.DataSet" />.</param>
        <summary>Wypełnia obiekt informacje serializacji dane potrzebne do serializacji <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" /> Parametr jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSchemaSerializable">
      <MemberSignature Language="C#" Value="protected virtual System.Xml.Schema.XmlSchema GetSchemaSerializable ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xml.Schema.XmlSchema GetSchemaSerializable() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetSchemaSerializable" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetSchemaSerializable () As XmlSchema" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xml::Schema::XmlSchema ^ GetSchemaSerializable();" />
      <MemberSignature Language="F#" Value="abstract member GetSchemaSerializable : unit -&gt; System.Xml.Schema.XmlSchema&#xA;override this.GetSchemaSerializable : unit -&gt; System.Xml.Schema.XmlSchema" Usage="dataSet.GetSchemaSerializable " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchema</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca serializacji <see cref="T:System.Xml.Schema.XmlSchema" /> wystąpienia.</summary>
        <returns>
          <see cref="T:System.Xml.Schema.XmlSchema" /> Wystąpienia.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSerializationData">
      <MemberSignature Language="C#" Value="protected void GetSerializationData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void GetSerializationData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetSerializationData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub GetSerializationData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void GetSerializationData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="member this.GetSerializationData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="dataSet.GetSerializationData (info, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">
          <see cref="T:System.Runtime.Serialization.SerializationInfo" /> Wystąpienia.</param>
        <param name="context">Kontekst strumieniowy.</param>
        <summary>Deserializuje dane w tabeli z pliku binarnego lub strumień XML.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetXml">
      <MemberSignature Language="C#" Value="public string GetXml ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetXml() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetXml" />
      <MemberSignature Language="VB.NET" Value="Public Function GetXml () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetXml();" />
      <MemberSignature Language="F#" Value="member this.GetXml : unit -&gt; string" Usage="dataSet.GetXml " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca reprezentację XML typu danych przechowywanych w <see cref="T:System.Data.DataSet" />.</summary>
        <returns>Ciąg znaków będący reprezentację danych przechowywanych w <see cref="T:System.Data.DataSet" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tej metody jest taki sam jak wywołanie <xref:System.Data.DataSet.WriteXml%2A> z <xref:System.Data.XmlWriteMode> ustawioną <xref:System.Data.XmlWriteMode.IgnoreSchema>.  
  
 <xref:System.Data.DataSet.GetXml%2A> Zwraca kod XML jako ciąg i dlatego wymaga więcej czynności niż <xref:System.Data.DataSet.WriteXml%2A> można zapisać do pliku XML.  
  
 W przypadku tworzenia <xref:System.Data.DataSet> przy użyciu wnioskowania schematu i serializować ją przy użyciu usługi sieci Web lub XML, kolejność kolumn mogą ulec zmianie.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Data.DataSet> i <xref:System.Data.DataTable>, dodaje przykładowych danych, a następnie wyświetla dane w formacie XML.  
  
 [!code-csharp[Classic WebData DataSet.GetXml Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetXml Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetXml Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetXml Example/VB/source.vb#1)]  
  
 W tym przykładzie pokazano, jak zapisać danych do pliku XML z zestawu danych i do odczytu danych do zestawu danych z pliku XML. W tym przykładzie będzie utworzyć jeden zestaw danych z tabel, używa dwa sposoby do wyeksportowania zestawu danych do plików XML (WriteXml i GetXml) i dwa sposoby (ReadXml i InferXmlSchema), aby zaimportować zestaw danych z plików XML.  
  
 Aby skompilować i uruchomić przykładowy, należy utworzyć cztery pliki XML w katalogu próbki. Najpierw utwórz ElementsWithAttributes.xml:  
  
```  
<MySchool>  
  <Course CourseID="C1045" Year="2012"  Title="Calculus" Credits="4" DepartmentID="7">New</Course>  
  <Course CourseID="C1061" Year="2012"  Title="Physics" Credits="4" DepartmentID="1" />  
  <Department DepartmentID="1" Name="Engineering" Budget="350000" StartDate="2007-09-01T00:00:00+08:00" Administrator="2" />  
  <Department DepartmentID="7" Name="Mathematics" Budget="250024" StartDate="2007-09-01T00:00:00+08:00" Administrator="3">Cancelled</Department>  
</MySchool>  
```  
  
 Następnie należy utworzyć ElementsWithChildElementsxml.xml:  
  
```  
<MySchool>  
  <Course>  
    <CourseID>C1045</CourseID>  
    <Year>2012</Year>  
    <Title>Calculus</Title>  
    <Credits>4</Credits>  
    <DepartmentID>7</DepartmentID>  
  </Course>  
  <Course>  
    <CourseID>C1061</CourseID>  
    <Year>2012</Year>  
    <Title>Physics</Title>  
    <Credits>4</Credits>  
    <DepartmentID>1</DepartmentID>  
  </Course>  
  <Course>  
    <CourseID>C2021</CourseID>  
    <Year>2012</Year>  
    <Title>Composition</Title>  
    <Credits>3</Credits>  
    <DepartmentID>2</DepartmentID>  
  </Course>  
  <Course>  
    <CourseID>C2042</CourseID>  
    <Year>2012</Year>  
    <Title>Literature</Title>  
    <Credits>4</Credits>  
    <DepartmentID>2</DepartmentID>  
  </Course>  
  <Department>  
    <DepartmentID>1</DepartmentID>  
    <Name>Engineering</Name>  
    <Budget>350000</Budget>  
    <StartDate>2007-09-01T00:00:00+08:00</StartDate>  
    <Administrator>2</Administrator>  
  </Department>  
  <Department>  
    <DepartmentID>2</DepartmentID>  
    <Name>English</Name>  
    <Budget>120000</Budget>  
    <StartDate>2007-09-01T00:00:00+08:00</StartDate>  
    <Administrator>6</Administrator>  
  </Department>  
  <Department>  
    <DepartmentID>4</DepartmentID>  
    <Name>Economics</Name>  
    <Budget>200000</Budget>  
    <StartDate>2007-09-01T00:00:00+08:00</StartDate>  
    <Administrator>4</Administrator>  
  </Department>  
  <Department>  
    <DepartmentID>7</DepartmentID>  
    <Name>Mathematics</Name>  
    <Budget>250024</Budget>  
    <StartDate>2007-09-01T00:00:00+08:00</StartDate>  
    <Administrator>3</Administrator>  
  </Department>  
</MySchool>  
```  
  
 Teraz utworzyć ElementsWithOnlyAttributes.xml:  
  
```  
<MySchool>  
  <Course CourseID="C1045" Year="2012"  Title="Calculus" Credits="4" DepartmentID="7" />  
  <Course CourseID="C1061" Year="2012"  Title="Physics" Credits="4" DepartmentID="1" />  
  <Department DepartmentID="1" Name="Engineering" Budget="350000" StartDate="2007-09-01T00:00:00+08:00" Administrator="2" />  
  <Department DepartmentID="7" Name="Mathematics" Budget="250024" StartDate="2007-09-01T00:00:00+08:00" Administrator="3" />  
</MySchool>  
```  
  
 I na koniec Utwórz RepeatingElements.xml:  
  
```  
<MySchool>  
  <Course>C1045</Course>  
  <Course>C1061</Course>  
  <Department>Engineering</Department>   
  <Department>Mathematics</Department>  
</MySchool>  
```  
  
 Teraz możesz skompilować i uruchomić następujący kod źródłowy.  [Jak magazyn danych z zestawu danych do pliku XML](https://code.msdn.microsoft.com/How-to-Store-Data-of-7b9710f3) projekty Visual Basic i C# dla tego przykładu.  
  
```  
using System;  
using System.Data;  
using System.IO;  
using System.Text;  
using System.Xml;  
  
// Use WriteXml method to export the dataset.  
static class DataTableHelper {  
   public static void WriteDataSetToXML(DataSet dataset, String xmlFileName) {  
      using (FileStream fsWriterStream = new FileStream(xmlFileName, FileMode.Create)) {  
         using (XmlTextWriter xmlWriter = new XmlTextWriter(fsWriterStream, Encoding.Unicode)) {  
            dataset.WriteXml(xmlWriter, XmlWriteMode.WriteSchema);  
            Console.WriteLine("Write {0} to the File {1}.", dataset.DataSetName, xmlFileName);  
            Console.WriteLine();  
         }  
      }  
   }  
  
   // Use GetXml method to get the XML data of the dataset and then export to the file.  
   public static void GetXMLFromDataSet(DataSet dataset, String xmlFileName) {  
      using (StreamWriter writer = new StreamWriter(xmlFileName)) {  
         writer.WriteLine(dataset.GetXml());  
         Console.WriteLine("Get Xml data from {0} and write to the File {1}.", dataset.DataSetName, xmlFileName);  
         Console.WriteLine();  
      }  
   }  
  
   // Use ReadXml method to import the dataset from the dataset.  
   public static void ReadXmlIntoDataSet(DataSet newDataSet, String xmlFileName) {  
      using (FileStream fsReaderStream = new FileStream(xmlFileName, FileMode.Open)) {  
         using (XmlTextReader xmlReader = new XmlTextReader(fsReaderStream)) {  
            newDataSet.ReadXml(xmlReader, XmlReadMode.ReadSchema);  
         }  
      }  
   }  
  
   // Display the columns and value of DataSet.  
   public static void ShowDataSet(DataSet dataset) {  
      foreach (DataTable table in dataset.Tables) {  
         Console.WriteLine("Table {0}:", table.TableName);  
         ShowDataTable(table);  
      }  
   }  
  
   // Display the columns and value of DataTable.  
   private static void ShowDataTable(DataTable table) {  
      foreach (DataColumn col in table.Columns) {  
         Console.Write("{0,-14}", col.ColumnName);  
      }  
      Console.WriteLine("{0,-14}", "");  
  
      foreach (DataRow row in table.Rows) {  
         if (row.RowState == DataRowState.Deleted) {  
            foreach (DataColumn col in table.Columns) {  
               if (col.DataType.Equals(typeof(DateTime))) {  
                  Console.Write("{0,-14:d}", row[col, DataRowVersion.Original]);  
               }  
               else if (col.DataType.Equals(typeof(Decimal))) {  
                  Console.Write("{0,-14:C}", row[col, DataRowVersion.Original]);  
               }  
               else {  
                  Console.Write("{0,-14}", row[col, DataRowVersion.Original]);  
               }  
            }  
         }  
         else {  
            foreach (DataColumn col in table.Columns) {  
               if (col.DataType.Equals(typeof(DateTime))) {  
                  Console.Write("{0,-14:d}", row[col]);  
               }  
               else if (col.DataType.Equals(typeof(Decimal))) {  
                  Console.Write("{0,-14:C}", row[col]);  
               }  
               else {  
                  Console.Write("{0,-14}", row[col]);  
               }  
            }  
         }  
         Console.WriteLine("{0,-14}", "");  
      }  
   }  
  
   // Display the columns of DataSet.  
   public static void ShowDataSetSchema(DataSet dataSet) {  
      Console.WriteLine("{0} contains the following tables:", dataSet.DataSetName);  
      foreach (DataTable table in dataSet.Tables) {  
         Console.WriteLine("   Table {0} contains the following columns:", table.TableName);  
         ShowDataTableSchema(table);  
      }  
   }  
  
   // Display the columns of DataTable  
   private static void ShowDataTableSchema(DataTable table) {  
      String columnString = "";  
      foreach (DataColumn col in table.Columns) {  
         columnString += col.ColumnName + "   ";  
      }  
      Console.WriteLine(columnString);  
   }  
}  
  
class Program {  
   static void Main(string[] args) {  
      // Create the DataSet  
      DataSet school = new DataSet("MySchool");  
      DataTable course = CreateCourse();  
      DataTable department = CreateDepartment();  
      school.Tables.Add(course);  
      school.Tables.Add(department);  
  
      // Define the constraint between the tables.  
      ForeignKeyConstraint courseDepartFK = new ForeignKeyConstraint("CourseDepartFK", department.Columns["DepartmentID"], course.Columns["DepartmentID"]);  
      courseDepartFK.DeleteRule = Rule.Cascade;  
      courseDepartFK.UpdateRule = Rule.Cascade;  
      courseDepartFK.AcceptRejectRule = AcceptRejectRule.None;  
      course.Constraints.Add(courseDepartFK);  
  
      InsertDepartments(department);  
      InsertCourses(course);  
  
      // Export the dataset to the XML file.  
      Console.WriteLine("Data of the whole DataSet {0}", school.DataSetName);  
      DataTableHelper.ShowDataSet(school);  
  
      String xmlWithSchemaFileName = "WriterXMLWithSchema.xml";  
      String xmlGetDataFileName = "GetXML.xml";  
  
      // Use two ways to export the dataset to the Xml file.  
      DataTableHelper.WriteDataSetToXML(school, xmlWithSchemaFileName);  
      DataTableHelper.GetXMLFromDataSet(school, xmlGetDataFileName);  
  
      // Import the dataset from the XML file.  
      // Use two ways to import the dataset from the Xml file.  
      Console.WriteLine("Read Xml document into a new DataSet:");  
      DataSet newSchool = new DataSet("NewSchool");  
      DataTableHelper.ReadXmlIntoDataSet(newSchool, xmlWithSchemaFileName);  
      DataTableHelper.ShowDataSetSchema(newSchool);  
      Console.WriteLine();  
  
      Console.WriteLine("Infer a schema for a DataSet from an XML document:");  
      InferDataSetSchemaFromXml();  
  
      Console.WriteLine("Press any key to exit.");  
      Console.ReadKey();  
   }  
  
   static DataTable CreateCourse() {  
      DataTable course = new DataTable("Course");  
      DataColumn[] cols ={  
                              new DataColumn("CourseID",typeof(String)),  
                              new DataColumn("Year",typeof(Int32)),  
                              new DataColumn("Title",typeof(String)),  
                              new DataColumn("Credits",typeof(Int32)),  
                              new DataColumn("DepartmentID",typeof(Int32))};  
      course.Columns.AddRange(cols);  
  
      course.PrimaryKey = new DataColumn[] { course.Columns["CourseID"], course.Columns["Year"] };  
  
      return course;  
   }  
  
   static DataTable CreateDepartment() {  
      DataTable department = new DataTable("Department");  
      DataColumn[] cols = {   
                                new DataColumn("DepartmentID", typeof(Int32)),  
                                new DataColumn("Name",typeof(String)),  
                                new DataColumn("Budget",typeof(Decimal)),  
                                new DataColumn("StartDate",typeof(DateTime)),  
                                new DataColumn("Administrator",typeof(Int32))};  
      department.Columns.AddRange(cols);  
  
      department.PrimaryKey = new DataColumn[] { department.Columns["DepartmentID"] };  
  
      return department;  
   }  
  
   static void InsertDepartments(DataTable department) {  
      Object[] rows = {   
                            new Object[]{1,"Engineering",350000.00,new DateTime(2007,9,1),2},  
                            new Object[]{2,"English",120000.00,new DateTime(2007,9,1),6},  
                            new Object[]{4,"Economics",200000.00,new DateTime(2007,9,1),4},  
                            new Object[]{7,"Mathematics",250024.00,new DateTime(2007,9,1),3}};  
  
      foreach (Object[] row in rows) {  
         department.Rows.Add(row);  
      }  
   }  
  
   static void InsertCourses(DataTable course) {  
      Object[] rows ={  
                               new Object[]{"C1045",2012,"Calculus",4,7},  
                               new Object[]{"C1061",2012,"Physics",4,1},  
                               new Object[]{"C2021",2012,"Composition",3,2},  
                               new Object[]{"C2042",2012,"Literature",4,2}};  
  
      foreach (Object[] row in rows) {  
         course.Rows.Add(row);  
      }  
   }  
  
   // Display the results of inferring schema from four types of XML structures  
   private static void InferDataSetSchemaFromXml() {  
      String[] xmlFileNames = {   
  
                                    @"ElementsWithOnlyAttributes.xml",   
                                    @"ElementsWithAttributes.xml",  
                                    @"RepeatingElements.xml",   
                                    @"ElementsWithChildElements.xml" };  
  
      foreach (String xmlFileName in xmlFileNames) {  
         Console.WriteLine("Result of {0}", Path.GetFileNameWithoutExtension(xmlFileName));  
         DataSet newSchool = new DataSet();  
         newSchool.InferXmlSchema(xmlFileName, null);  
         DataTableHelper.ShowDataSetSchema(newSchool);  
         Console.WriteLine();  
      }  
   }  
}  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetXmlSchema">
      <MemberSignature Language="C#" Value="public string GetXmlSchema ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetXmlSchema() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetXmlSchema" />
      <MemberSignature Language="VB.NET" Value="Public Function GetXmlSchema () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetXmlSchema();" />
      <MemberSignature Language="F#" Value="member this.GetXmlSchema : unit -&gt; string" Usage="dataSet.GetXmlSchema " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca schematu XML dla reprezentacji XML dane przechowywane w <see cref="T:System.Data.DataSet" />.</summary>
        <returns>Ciąg znaków schematu XML dla reprezentacji XML dane przechowywane w <see cref="T:System.Data.DataSet" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tej metody jest taki sam jak wywołanie <xref:System.Data.DataSet.WriteXmlSchema%2A>, ale tylko podstawowy schemat jest zapisywany.  
  
 <xref:System.Data.DataSet.GetXmlSchema%2A> Zwraca kod XML jako ciąg i dlatego wymaga więcej czynności niż <xref:System.Data.DataSet.WriteXmlSchema%2A> można zapisać do pliku XML.  
  
 W przypadku tworzenia <xref:System.Data.DataSet> przy użyciu wnioskowania schematu i serializować ją przy użyciu usługi sieci Web lub XML, kolejność kolumn mogą ulec zmianie.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Data.DataSet> i <xref:System.Data.DataTable>, a następnie wyświetla schematu w formacie XML.  
  
 [!code-csharp[Classic WebData DataSet.GetXmlSchema Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetXmlSchema Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetXmlSchema Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetXmlSchema Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="HasChanges">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Data.DataSet" /> wprowadzono zmiany, w tym wiersze, nowe, usunięte lub zmodyfikowane.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="HasChanges">
      <MemberSignature Language="C#" Value="public bool HasChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool HasChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.HasChanges" />
      <MemberSignature Language="VB.NET" Value="Public Function HasChanges () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool HasChanges();" />
      <MemberSignature Language="F#" Value="member this.HasChanges : unit -&gt; bool" Usage="dataSet.HasChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Data.DataSet" /> wprowadzono zmiany, w tym wiersze, nowe, usunięte lub zmodyfikowane.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="T:System.Data.DataSet" /> ma zmian; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Data.DataSet.GetChanges%2A> metodę w celu utworzenia drugiej <xref:System.Data.DataSet> obiekt, który jest następnie używany do aktualizowania źródła danych.  
  
 [!code-csharp[Classic WebData DataSet.HasChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.HasChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.HasChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.HasChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasChanges">
      <MemberSignature Language="C#" Value="public bool HasChanges (System.Data.DataRowState rowStates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool HasChanges(valuetype System.Data.DataRowState rowStates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.HasChanges(System.Data.DataRowState)" />
      <MemberSignature Language="VB.NET" Value="Public Function HasChanges (rowStates As DataRowState) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool HasChanges(System::Data::DataRowState rowStates);" />
      <MemberSignature Language="F#" Value="member this.HasChanges : System.Data.DataRowState -&gt; bool" Usage="dataSet.HasChanges rowStates" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rowStates" Type="System.Data.DataRowState" />
      </Parameters>
      <Docs>
        <param name="rowStates">Jeden z <see cref="T:System.Data.DataRowState" /> wartości.</param>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Data.DataSet" /> zawiera zmiany, w tym nowe, usunięte lub zmodyfikowane wierszy filtrowane według <see cref="T:System.Data.DataRowState" />.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="T:System.Data.DataSet" /> ma zmian; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sprawdź <xref:System.Data.DataSet.HasChanges%2A> właściwość `DataSet` przed wywołaniem <xref:System.Data.DataSet.GetChanges%2A> metody.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Data.DataSet.GetChanges%2A> metodę w celu utworzenia drugiej <xref:System.Data.DataSet> obiektu, który jest następnie używany do aktualizowania źródła danych.  
  
 [!code-csharp[Classic WebData DataSet.GetChanges1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetChanges1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasErrors">
      <MemberSignature Language="C#" Value="public bool HasErrors { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasErrors" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.HasErrors" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasErrors As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasErrors { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasErrors : bool" Usage="System.Data.DataSet.HasErrors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy występują błędy w żadnym z <see cref="T:System.Data.DataTable" /> obiektów w ramach tego <see cref="T:System.Data.DataSet" />.</summary>
        <value>
          <see langword="true" /> Jeśli wszystkie tabela zawiera błąd; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy <xref:System.Data.DataTable> w <xref:System.Data.DataSet> ma również <xref:System.Data.DataTable.HasErrors%2A> właściwości. Użyj `HasErrors` właściwość `DataSet` należy sprawdzić, czy wszystkie tabele ma błędów, przed zaewidencjonowaniem poszczególnych <xref:System.Data.DataTable> obiektów. Jeśli `DataTable` zawiera błędy, <xref:System.Data.DataTable.GetErrors%2A> metoda zwraca tablicę <xref:System.Data.DataRow> obiektów zawierających błędy.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Data.DataSet.HasErrors%2A> umożliwia określenie, czy <xref:System.Data.DataSet> obiektu zawiera błędy. Jeśli tak, błędów dla każdego <xref:System.Data.DataRow> w każdym <xref:System.Data.DataTable> drukowania.  
  
 [!code-csharp[Classic WebData DataSet.HasErrors Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.HasErrors Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.HasErrors Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.HasErrors Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="InferXmlSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zastosowanie schematu XML w celu <see cref="T:System.Data.DataSet" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="InferXmlSchema">
      <MemberSignature Language="C#" Value="public void InferXmlSchema (System.IO.Stream stream, string[] nsArray);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InferXmlSchema(class System.IO.Stream stream, string[] nsArray) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InferXmlSchema(System.IO.Stream,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InferXmlSchema(System::IO::Stream ^ stream, cli::array &lt;System::String ^&gt; ^ nsArray);" />
      <MemberSignature Language="F#" Value="member this.InferXmlSchema : System.IO.Stream * string[] -&gt; unit" Usage="dataSet.InferXmlSchema (stream, nsArray)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="nsArray" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="stream">
          <see langword="Stream" /> z której mają być odczytywane schematu.</param>
        <param name="nsArray">Tablica ciągów identyfikator URI (Uniform Resource) przestrzeni nazw do wykluczenia z wnioskowania schematu.</param>
        <summary>Zastosowanie schematu XML z określonego <see cref="T:System.IO.Stream" /> do <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InferXmlSchema">
      <MemberSignature Language="C#" Value="public void InferXmlSchema (System.IO.TextReader reader, string[] nsArray);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InferXmlSchema(class System.IO.TextReader reader, string[] nsArray) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InferXmlSchema(System.IO.TextReader,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub InferXmlSchema (reader As TextReader, nsArray As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InferXmlSchema(System::IO::TextReader ^ reader, cli::array &lt;System::String ^&gt; ^ nsArray);" />
      <MemberSignature Language="F#" Value="member this.InferXmlSchema : System.IO.TextReader * string[] -&gt; unit" Usage="dataSet.InferXmlSchema (reader, nsArray)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
        <Parameter Name="nsArray" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see langword="TextReader" /> z której mają być odczytywane schematu.</param>
        <param name="nsArray">Tablica ciągów identyfikator URI (Uniform Resource) przestrzeni nazw do wykluczenia z wnioskowania schematu.</param>
        <summary>Zastosowanie schematu XML z określonego <see cref="T:System.IO.TextReader" /> do <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InferXmlSchema">
      <MemberSignature Language="C#" Value="public void InferXmlSchema (string fileName, string[] nsArray);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InferXmlSchema(string fileName, string[] nsArray) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InferXmlSchema(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub InferXmlSchema (fileName As String, nsArray As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InferXmlSchema(System::String ^ fileName, cli::array &lt;System::String ^&gt; ^ nsArray);" />
      <MemberSignature Language="F#" Value="member this.InferXmlSchema : string * string[] -&gt; unit" Usage="dataSet.InferXmlSchema (fileName, nsArray)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="nsArray" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="fileName">Nazwa pliku (łącznie ze ścieżką), z której mają być odczytywane schematu.</param>
        <param name="nsArray">Tablica ciągów identyfikator URI (Uniform Resource) przestrzeni nazw do wykluczenia z wnioskowania schematu.</param>
        <summary>Zastosowanie schematu XML z określonego pliku do <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">
          <see cref="T:System.Security.Permissions.FileIOPermission" /> Nie ustawiono <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania i zapisywania plików. Wyliczenie skojarzone: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="InferXmlSchema">
      <MemberSignature Language="C#" Value="public void InferXmlSchema (System.Xml.XmlReader reader, string[] nsArray);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InferXmlSchema(class System.Xml.XmlReader reader, string[] nsArray) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InferXmlSchema(System.Xml.XmlReader,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub InferXmlSchema (reader As XmlReader, nsArray As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InferXmlSchema(System::Xml::XmlReader ^ reader, cli::array &lt;System::String ^&gt; ^ nsArray);" />
      <MemberSignature Language="F#" Value="member this.InferXmlSchema : System.Xml.XmlReader * string[] -&gt; unit" Usage="dataSet.InferXmlSchema (reader, nsArray)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="nsArray" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see langword="XMLReader" /> z której mają być odczytywane schematu.</param>
        <param name="nsArray">Tablica ciągów identyfikator URI (Uniform Resource) przestrzeni nazw do wykluczenia z wnioskowania schematu.</param>
        <summary>Zastosowanie schematu XML z określonego <see cref="T:System.Xml.XmlReader" /> do <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Initialized">
      <MemberSignature Language="C#" Value="public event EventHandler Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataSet.Initialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Initialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ Initialized;" />
      <MemberSignature Language="F#" Value="member this.Initialized : EventHandler " Usage="member this.Initialized : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po <see cref="T:System.Data.DataSet" /> został zainicjowany.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji, zobacz <xref:System.Data.DataSet.IsInitialized%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializeDerivedDataSet">
      <MemberSignature Language="C#" Value="protected virtual void InitializeDerivedDataSet ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InitializeDerivedDataSet() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InitializeDerivedDataSet" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub InitializeDerivedDataSet ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InitializeDerivedDataSet();" />
      <MemberSignature Language="F#" Value="abstract member InitializeDerivedDataSet : unit -&gt; unit&#xA;override this.InitializeDerivedDataSet : unit -&gt; unit" Usage="dataSet.InitializeDerivedDataSet " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wszystkie dane tabel zestawu danych z pliku binarnego lub strumień XML deserializacji.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBinarySerialized">
      <MemberSignature Language="C#" Value="protected bool IsBinarySerialized (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool IsBinarySerialized(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.IsBinarySerialized(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Function IsBinarySerialized (info As SerializationInfo, context As StreamingContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool IsBinarySerialized(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="member this.IsBinarySerialized : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; bool" Usage="dataSet.IsBinarySerialized (info, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">
          <see cref="T:System.Runtime.Serialization.SerializationInfo" /> Obiektu.</param>
        <param name="context">
          <see cref="T:System.Runtime.Serialization.StreamingContext" /> Obiektu.</param>
        <summary>Sprawdza format serializacji reprezentację <see langword="DataSet" />.</summary>
        <returns>
          <see langword="true" /> Jeśli określony <see cref="T:System.Runtime.Serialization.SerializationInfo" /> reprezentuje <see langword="DataSet" /> serializacji format binarny, <see langword="false" /> inaczej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element członkowski obsługuje infrastrukturę programu .NET Framework i nie jest przeznaczony do użycia bezpośrednio w kodzie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInitialized">
      <MemberSignature Language="C#" Value="public bool IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.IsInitialized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInitialized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitialized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInitialized : bool" Usage="System.Data.DataSet.IsInitialized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Data.DataSet" /> został zainicjowany.</summary>
        <value>
          <see langword="true" /> Aby wskazać składnika została ukończona inicjowania; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwraca stan <xref:System.Data.DataSet> podczas jego jest tworzona, na przykład przez program Visual Studio. <xref:System.Data.DataSet.BeginInit%2A> Metody ustawia ją na `false` i <xref:System.Data.DataSet.EndInit%2A> metody ustawia ją na `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wypełnia <see cref="T:System.Data.DataSet" /> z wartości ze źródłem danych przy użyciu dostarczonego <see cref="T:System.Data.IDataReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.Load%2A> Metoda zapewnia technika do wypełniania pojedynczy <xref:System.Data.DataTable> z danych uzyskanych od <xref:System.Data.IDataReader> wystąpienia. Ta metoda zapewnia te same funkcje, ale można załadować wiele zestawów wyników z `IDataReader` na wiele tabel w ramach `DataSet`.  
  
 Jeśli `DataSet` już zawiera wiersze, dane przychodzące od źródła danych jest scalany z istniejących wierszy.  
  
 `Load` Metoda może być używana w kilka typowych scenariuszy, wszystkie wyśrodkowany wokół pobieranie danych z określonego źródła danych i dodanie go do bieżącego kontenera danych (w tym przypadku `DataSet`). Te scenariusze opisano standardowego użycia dla `DataSet`, opisujący jej aktualizacji i scal zachowanie.  
  
 A `DataSet` synchronizuje lub aktualizuje z pojedynczego podstawowego źródła danych. `DataSet` Śledzi zmiany, dzięki czemu synchronizacji z podstawowego źródła danych. Ponadto `DataSet` może zaakceptować danych pierwotnych z co najmniej jedno źródło danych pomocniczych. `DataSet` Nie jest odpowiedzialny za śledzenia zmian w celu umożliwienia synchronizacji z pomocnicze źródło danych.  
  
 Podana tych dwóch źródeł danych hipotetyczny, użytkownik prawdopodobnie muszą mieć jedną z następujących problemów:  
  
-   Inicjowanie `DataSet` ze źródła danych podstawowych. W tym scenariuszu użytkownik chce zainicjować pustą `DataSet` wartościami z podstawowego źródła danych. Co najmniej jeden DataTable zawartości są modyfikowane. Użytkownik zamierza później propagowanie zmian z powrotem na podstawowego źródła danych.  
  
-   Zachować zmiany, a następnie przeprowadź ponowną synchronizację z podstawowego źródła danych. W tym scenariuszu użytkownik chce przejąć `DataSet` wypełnione w poprzednim scenariuszu i wykonywać synchronizację przyrostową z podstawowego źródła danych, zachowując zmian wprowadzonych w `DataSet`.  
  
-   Źródła danych pierwotnych z pomocniczych źródeł danych. W tym scenariuszu użytkownik chce scalić zmiany z co najmniej jedno źródło danych pomocniczych i Propaguj tych zmian z powrotem na podstawowego źródła danych.  
  
 `Load` Metody umożliwia tych scenariuszy. Ta metoda służy do określenia parametru opcja obciążenia, wskazującą sposób wierszy znajdujących się w <xref:System.Data.DataTable> łączyć z wierszy ładowany. W poniższej tabeli opisano opcje trzy obciążenia pochodzącymi <xref:System.Data.LoadOption> wyliczenia. W każdym przypadku opis wskazuje zachowanie, gdy klucz podstawowy wiersza w danych przychodzących jest zgodna z klucza podstawowego istniejącego wiersza.  
  
|Opcja obciążenia|Opis|  
|-----------------|-----------------|  
|`PreserveChanges` (ustawienie domyślne)|Aktualizuje wartości przychodzących wiersza oryginalnej wersji wiersza.|  
|`OverwriteChanges`|Aktualizuje wersje bieżących i oryginalnych wiersza wartości przychodzących wiersza.|  
|`Upsert`|Aktualizuje wartości wiersza przychodzące bieżącej wersji wiersza.|  
  
 Ogólnie rzecz biorąc `PreserveChanges` i `OverwriteChanges` opcje są przeznaczone dla scenariuszy, w których użytkownik chce synchronizować `DataSet` i jego zmiany z podstawowego źródła danych. `Upsert` Opcja umożliwia agregację zmiany z co najmniej jedno źródło danych pomocniczych.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption, params System.Data.DataTable[] tables);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption, class System.Data.DataTable[] tables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Data::IDataReader ^ reader, System::Data::LoadOption loadOption, ... cli::array &lt;System::Data::DataTable ^&gt; ^ tables);" />
      <MemberSignature Language="F#" Value="member this.Load : System.Data.IDataReader * System.Data.LoadOption * System.Data.DataTable[] -&gt; unit" Usage="dataSet.Load (reader, loadOption, tables)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
        <Parameter Name="tables" Type="System.Data.DataTable[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Data.IDataReader" /> Zapewnia jeden lub więcej zestawów wyników.</param>
        <param name="loadOption">Wartość z zakresu od <see cref="T:System.Data.LoadOption" /> wyliczenia, która wskazuje, jak wierszy znajdujących się w <see cref="T:System.Data.DataTable" /> wystąpień w ramach <see cref="T:System.Data.DataSet" /> zostanie połączona z przychodzącego wierszy, które mają taki sam klucz podstawowy.</param>
        <param name="tables">Tablica <see cref="T:System.Data.DataTable" /> wystąpienia, z którego <see cref="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])" /> metoda pobiera informacje o nazwę i przestrzeń nazw. Każdej z tych tabel musi być członkiem <see cref="T:System.Data.DataTableCollection" /> zawarty w tym <see cref="T:System.Data.DataSet" />.</param>
        <summary>Wypełnia <see cref="T:System.Data.DataSet" /> z wartości ze źródłem danych przy użyciu dostarczonego <see cref="T:System.Data.IDataReader" />, użycie tablicy <see cref="T:System.Data.DataTable" /> instancje, aby podać informacje dotyczące schematu i przestrzeni nazw.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.Load%2A> Metoda zapewnia technika do wypełniania pojedynczy <xref:System.Data.DataTable> z danych uzyskanych od <xref:System.Data.IDataReader> wystąpienia. Ta metoda zapewnia te same funkcje, ale można załadować wiele zestawów wyników z <xref:System.Data.IDataReader> na wiele tabel w ramach <xref:System.Data.DataSet>.  
  
> [!NOTE]
>  Niepowodzenie operacji ładowania <xref:System.InvalidOperationException> ewentualne źródła danych kolumn w przychodzącej `reader` kolumn obliczanych.  
  
 `loadOption` Parametr umożliwia określenie sposobu importowanych danych na interakcję z istniejącymi danymi i może być dowolna z wartości z <xref:System.Data.LoadOption> wyliczenia. Zajrzyj do dokumentacji <xref:System.Data.DataTable> <xref:System.Data.DataTable.Load%2A> metody, aby uzyskać więcej informacji na temat używania tego parametru.  
  
 `tables` Parametr umożliwia określenie tablicę <xref:System.Data.DataTable> wystąpień wskazującą kolejność tabel odpowiadający każdy wynik ustawić załadowany z czytnika. <xref:System.Data.DataSet.Load%2A> Metody wypełnienia każdego dostarczony <xref:System.Data.DataTable> wystąpienia przy użyciu danych z jednego zestawu wyników z czytnik źródła danych. Po każdym zestawu wyników <xref:System.Data.DataSet.Load%2A> metody przechodzi do następnego wyniku, ustaw w czytniku, dopóki nie istnieją już zestawy wyników.  
  
 Schemat rozpoznawanie nazwy dla tej metody jest taka sama jak następuje <xref:System.Data.Common.DbDataAdapter.Fill%2A> metody <xref:System.Data.Common.DbDataAdapter> klasy.  
  
   
  
## Examples  
 Poniższy przykład tworzy nowy <xref:System.Data.DataSet>, dodaje dwa <xref:System.Data.DataTable> wystąpień do <xref:System.Data.DataSet>i następnie wypełnia <xref:System.Data.DataSet> przy użyciu <xref:System.Data.DataSet.Load%2A> metodę pobierania danych z <xref:System.Data.DataTableReader> zawiera dwa zestawy wyników. Ponadto w przykładzie przedstawiono zawartości tabel w oknie konsoli.  
  
 [!code-csharp[DataWorks DataSet.LoadTables#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.LoadTables/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.LoadTables#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.LoadTables/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption, params string[] tables);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption, string[] tables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Data::IDataReader ^ reader, System::Data::LoadOption loadOption, ... cli::array &lt;System::String ^&gt; ^ tables);" />
      <MemberSignature Language="F#" Value="member this.Load : System.Data.IDataReader * System.Data.LoadOption * string[] -&gt; unit" Usage="dataSet.Load (reader, loadOption, tables)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
        <Parameter Name="tables" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Data.IDataReader" /> Zapewnia jeden lub więcej zestawów wyników.</param>
        <param name="loadOption">Wartość z zakresu od <see cref="T:System.Data.LoadOption" /> wyliczenia, która wskazuje, jak wierszy znajdujących się w <see cref="T:System.Data.DataTable" /> wystąpień w ramach <see langword="DataSet" /> zostanie połączona z przychodzącego wierszy, które mają taki sam klucz podstawowy.</param>
        <param name="tables">Tablica ciągów, z którego <see langword="Load" /> metoda pobiera informacje o nazwie tabeli.</param>
        <summary>Wypełnia <see cref="T:System.Data.DataSet" /> z wartości ze źródłem danych przy użyciu dostarczonego <see cref="T:System.Data.IDataReader" />, przy użyciu tablicy ciągów o podanie nazwy dla tabel w <see langword="DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.Load%2A> Metoda zapewnia technika do wypełniania pojedynczy <xref:System.Data.DataTable> z danych uzyskanych od <xref:System.Data.IDataReader> wystąpienia. Ta metoda zapewnia te same funkcje, ale można załadować wiele zestawów wyników z `IDataReader` na wiele tabel w ramach `DataSet`.  
  
> [!NOTE]
>  Niepowodzenie operacji ładowania <xref:System.InvalidOperationException> ewentualne źródła danych kolumn w przychodzącej `reader` kolumn obliczanych.  
  
 `loadOption` Parametr umożliwia określenie sposobu importowanych danych na interakcję z istniejącymi danymi i może być dowolna z wartości z <xref:System.Data.LoadOption> wyliczenia. Zajrzyj do dokumentacji <xref:System.Data.DataTable.Load%2A> metody, aby uzyskać więcej informacji na temat używania tego parametru.  
  
 `tables` Parametr umożliwia określenie tablicę nazw tabel, wskazującą kolejność tabel odpowiadający każdy wynik ustawić załadowany z czytnika. `Load` Metoda próbuje odnaleźć tabeli w ramach `DataSet` odnaleźć pasującego do nazwy w tablicy nazw tabel, w kolejności. Jeśli znaleziono zgodnej tabeli tej tabeli jest załadowana zawartość bieżącego zestawu wyników. Jeśli brak dopasowania tabeli zostanie znaleziony, tabela została utworzona przy użyciu nazwy podanej w tabeli nazw tabel i schematu nowa tabela jest wnioskowana na podstawie zestawu wyników. Po każdym zestawu wyników `Load` metody przechodzi do następnego wyniku, ustaw w czytniku, dopóki nie istnieją już zestawy wyników.  
  
 Domyślny obszar nazw skojarzone z `DataSet`, jeśli istnieje, jest skojarzony z każdym nowo utworzony `DataTable`. Schemat rozpoznawanie nazwy dla tej metody jest taka sama jak następuje <xref:System.Data.Common.DbDataAdapter.Fill%2A> metody <xref:System.Data.Common.DbDataAdapter> klasy.  
  
   
  
## Examples  
 W poniższym przykładzie aplikacji konsoli najpierw tworzy tabele i ładuje dane z czytnika w <xref:System.Data.DataSet>za pomocą `Load` metody. W przykładzie dodano następnie tabele, aby <xref:System.Data.DataSet> i próbuje przeprowadzić wypełnienie danych z tabel <xref:System.Data.DataTableReader>. W tym przykładzie ponieważ parametry przekazywane do `Load` metody wskazuje nazwę tabeli, która nie istnieje, `Load` metoda tworzy nową tabelę odpowiadać nazwie przekazany jako parametr. Po załadowaniu danych przykładzie wyświetla zawartość wszystkich jej tabel w oknie konsoli.  
  
 [!code-csharp[DataWorks DataSet.LoadString#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.LoadString/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.LoadString#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.LoadString/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public virtual void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption, System.Data.FillErrorEventHandler errorHandler, params System.Data.DataTable[] tables);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption, class System.Data.FillErrorEventHandler errorHandler, class System.Data.DataTable[] tables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Load(System::Data::IDataReader ^ reader, System::Data::LoadOption loadOption, System::Data::FillErrorEventHandler ^ errorHandler, ... cli::array &lt;System::Data::DataTable ^&gt; ^ tables);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Data.IDataReader * System.Data.LoadOption * System.Data.FillErrorEventHandler * System.Data.DataTable[] -&gt; unit&#xA;override this.Load : System.Data.IDataReader * System.Data.LoadOption * System.Data.FillErrorEventHandler * System.Data.DataTable[] -&gt; unit" Usage="dataSet.Load (reader, loadOption, errorHandler, tables)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
        <Parameter Name="errorHandler" Type="System.Data.FillErrorEventHandler" />
        <Parameter Name="tables" Type="System.Data.DataTable[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Data.IDataReader" /> Zapewnia jeden lub więcej zestawów wyników.</param>
        <param name="loadOption">Wartość z zakresu od <see cref="T:System.Data.LoadOption" /> wyliczenia, która wskazuje, jak wierszy znajdujących się w <see cref="T:System.Data.DataTable" /> wystąpień w ramach <see cref="T:System.Data.DataSet" /> zostanie połączona z przychodzącego wierszy, które mają taki sam klucz podstawowy.</param>
        <param name="errorHandler">A <see cref="T:System.Data.FillErrorEventHandler" /> delegata do wywołania, gdy wystąpi błąd podczas ładowania danych.</param>
        <param name="tables">Tablica <see cref="T:System.Data.DataTable" /> wystąpienia, z którego <see cref="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])" /> metoda pobiera informacje o nazwę i przestrzeń nazw.</param>
        <summary>Wypełnia <see cref="T:System.Data.DataSet" /> z wartości ze źródłem danych przy użyciu dostarczonego <see cref="T:System.Data.IDataReader" />, użycie tablicy <see cref="T:System.Data.DataTable" /> instancje, aby podać informacje dotyczące schematu i przestrzeni nazw.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.Load%2A> Metoda zapewnia technika do wypełniania pojedynczy <xref:System.Data.DataTable> z danych uzyskanych od <xref:System.Data.IDataReader> wystąpienia. Ta metoda zapewnia te same funkcje, ale można załadować wiele zestawów wyników z <xref:System.Data.IDataReader> na wiele tabel w ramach <xref:System.Data.DataSet>.  
  
> [!NOTE]
>  Niepowodzenie operacji ładowania <xref:System.InvalidOperationException> ewentualne źródła danych kolumn w przychodzącej `reader` kolumn obliczanych.  
  
 `loadOption` Parametr umożliwia określenie sposobu importowanych danych na interakcję z istniejącymi danymi i może być dowolna z wartości z <xref:System.Data.LoadOption> wyliczenia. Zajrzyj do dokumentacji <xref:System.Data.DataTable> <xref:System.Data.DataTable.Load%2A> metody, aby uzyskać więcej informacji na temat używania tego parametru.  
  
 `errorHandler` Parametr jest <xref:System.Data.FillErrorEventHandler> delegata, który odwołuje się do procedury, która jest wywoływana, gdy wystąpi błąd podczas ładowania danych. <xref:System.Data.FillErrorEventArgs> Parametr przekazany do procedury dostarcza właściwości, które umożliwiają pobieranie informacji o błędzie, który wystąpił, bieżący wiersz danych, i <xref:System.Data.DataTable> są wypełnione. Za pomocą mechanizm ten delegat, zamiast prostsze bloku try/catch, służy do określania błędu, obsłużyć sytuację i kontynuować przetwarzanie, jeśli chcesz. <xref:System.Data.FillErrorEventArgs> Parametr dostarcza <xref:System.Data.FillErrorEventArgs.Continue%2A> właściwości: Ustaw tą właściwość na `true` aby wskazać, że zapewnienia obsługi błędów i chcesz kontynuować przetwarzanie; ustaw dla właściwości `false` wskazująca, czy chcesz zatrzymać przetwarzanie. Należy pamiętać, że ustawienie właściwości `false` powoduje, że kod, która wyzwoliła problem do zgłoszenia wyjątku.  
  
 `tables` Parametr umożliwia określenie tablicę <xref:System.Data.DataTable> wystąpień wskazującą kolejność tabel odpowiadający każdy wynik ustawić załadowany z czytnika. <xref:System.Data.DataSet.Load%2A> Metody wypełnienia każdego dostarczony <xref:System.Data.DataTable> wystąpienia przy użyciu danych z jednego zestawu wyników z czytnik źródła danych. Po każdym zestawu wyników <xref:System.Data.DataSet.Load%2A> metody przechodzi do następnego wyniku, ustaw w czytniku, dopóki nie istnieją już zestawy wyników.  
  
 Schemat rozpoznawanie nazwy dla tej metody jest taka sama jak następuje <xref:System.Data.Common.DbDataAdapter.Fill%2A> metody <xref:System.Data.Common.DbDataAdapter> klasy.  
  
   
  
## Examples  
 Poniższy przykład umożliwia dodanie tabeli do <xref:System.Data.DataSet>, a następnie próbuje użyć <xref:System.Data.DataSet.Load%2A> metodę, aby załadować dane z <xref:System.Data.DataTableReader> zawiera niezgodne schematu. Zamiast generują pułapki błąd, w tym przykładzie użyto <xref:System.Data.FillErrorEventHandler> pełnomocnika, aby zbadać i obsługi błędu. Dane wyjściowe są wyświetlane w oknie konsoli.  
  
 [!code-csharp[DataWorks DataSet.Load#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.Load/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.Load#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.Load/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Locale">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo Locale { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo Locale" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Locale" />
      <MemberSignature Language="VB.NET" Value="Public Property Locale As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ Locale { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Locale : System.Globalization.CultureInfo with get, set" Usage="System.Data.DataSet.Locale" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia informacje dotyczące ustawień regionalnych używanych do porównania ciągów wewnątrz tabeli.</summary>
        <value>A <see cref="T:System.Globalization.CultureInfo" /> zawierający dane dotyczące ustawień regionalnych komputera użytkownika. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.Locale%2A> Właściwość określa ustawienia regionalne, sortowanie, których dotyczy.  
  
 Domyślnie ustawienie <xref:System.Data.DataSet.Locale%2A> dla <xref:System.Data.DataSet> ustawia również <xref:System.Data.DataSet.Locale%2A> dla każdego <xref:System.Data.DataTable> obiektu w tym `DataSet` na tę samą wartość.  
  
> [!NOTE]
>  W kolumnach, które zawierają wyrażenia <xref:System.StringComparison.InvariantCulture> jest używany. <xref:System.StringComparison.CurrentCulture> Jest ignorowana.  
  
   
  
## Examples  
 Poniższy przykład pobiera <xref:System.Globalization.CultureInfo> dla <xref:System.Data.DataSet> i drukuje <xref:System.Globalization.CultureInfo.DisplayName%2A> i <xref:System.Globalization.CultureInfo.EnglishName%2A> właściwości.  
  
 [!code-vb[Classic WebData DataSet.Locale Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Locale Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Merge">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Scala określoną <see cref="T:System.Data.DataSet" />, <see cref="T:System.Data.DataTable" />, tablica lub <see cref="T:System.Data.DataRow" /> obiekty do bieżącego <see langword="DataSet" /> lub <see langword="DataTable" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataRow[] rows);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataRow[] rows) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataRow[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Merge (rows As DataRow())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(cli::array &lt;System::Data::DataRow ^&gt; ^ rows);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataRow[] -&gt; unit" Usage="dataSet.Merge rows" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rows" Type="System.Data.DataRow[]" />
      </Parameters>
      <Docs>
        <param name="rows">Tablica <see langword="DataRow" /> obiekty do scalenia do <see langword="DataSet" />.</param>
        <summary>Scala tablicę <see cref="T:System.Data.DataRow" /> obiekty do bieżącego <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.Merge%2A> Metoda jest używana do scalenia dwa <xref:System.Data.DataSet> obiektów, które mają schematów w znacznym stopniu podobne. Scalanie jest zwykle używana w aplikacji klienta do zastosować ostatnie zmiany ze źródła danych w istniejącej <xref:System.Data.DataSet>. Umożliwia to aplikacji klienta odświeżyć <xref:System.Data.DataSet> przy użyciu najnowszych danych ze źródła danych.  
  
 <xref:System.Data.DataSet.Merge%2A> Zazwyczaj wywoływana jest metoda na końcu szereg procedur obejmujących sprawdzanie poprawności zmiany, uzgadnianie błędy aktualizacji źródła danych ze zmianami i na koniec odświeżanie istniejącego <xref:System.Data.DataSet>.  
  
 W aplikacji klienckiej jest często mają jednego przycisku, który użytkownik może kliknąć zbiera dane zmienione, a następnie zweryfikuje go przed wysłaniem go z powrotem do składników warstwy środkowej. W tym scenariuszu <xref:System.Data.DataSet.GetChanges%2A> wywołaniu metody. Metoda zwraca wartość drugiej <xref:System.Data.DataSet> zoptymalizowane pod kątem sprawdzania poprawności i scalania. Drugą <xref:System.Data.DataSet> obiekt zawiera tylko <xref:System.Data.DataTable> i <xref:System.Data.DataRow> obiektów, które zostały zmienione, wynikające z podzbioru oryginalnej <xref:System.Data.DataSet>. Ten podzestaw jest zwykle mniejsze i w związku z tym wydajniej przekazywane z powrotem do składników warstwy środkowej. Składnik warstwy środkowej następnie aktualizuje oryginalne źródło danych zmiany za pomocą procedur składowanych. Warstwy środkowej może wysyłać kopii albo nowy <xref:System.Data.DataSet> zawierającą oryginalnych danych oraz najnowsze dane ze źródła danych (przez ponowne uruchomienie oryginalnego zapytania) lub Wyślij ponownie podzbiór o zmianach, które zostały wprowadzone do niej ze źródła danych. (Na przykład, jeśli źródło danych automatycznie tworzy unikatowe wartości kluczy podstawowych, te wartości można propagowane do aplikacji klienckiej.) W obu przypadkach zwróconego <xref:System.Data.DataSet> mogą być scalone aplikacji klienckiej, oryginalne <xref:System.Data.DataSet> z <xref:System.Data.DataSet.Merge%2A> metody.  
  
 Gdy <xref:System.Data.DataSet.Merge%2A> metoda jest wywoływana, schematów dwa <xref:System.Data.DataSet> obiekty są porównywane, ponieważ jest to możliwe, że schematy mogły zostać zmienione. Na przykład w przypadku business-to-business, nowe kolumny może zostały dodane do schematu XML przez zautomatyzowany proces. Jeśli źródło <xref:System.Data.DataSet> zawiera elementy schematu (dodany <xref:System.Data.DataColumn> obiektów) brakuje w miejscu docelowym, elementy schematu mogą zostać dodane do obiektu docelowego, ustawiając `missingSchemaAction` argument `MissingSchemaAction.Add`. W takim przypadku scalonych <xref:System.Data.DataSet> zawiera dodany schemat i dane.  
  
 Po scaleniu schematów, scalania danych.  
  
 Podczas scalania nowe źródło <xref:System.Data.DataSet> do obiektu docelowego, każde źródło wiersze z <xref:System.Data.DataRowState> wartość `Unchanged`, `Modified`, lub `Deleted` są dopasowywane do docelowego wierszy z tej samej wartości klucza podstawowego. Źródło wiersze z <xref:System.Data.DataRowState> wartość `Added` są dopasowywane do nowych wierszy docelowych z tej samej wartości klucza podstawowego jako nowe wiersze źródła.  
  
 Podczas scalania ograniczenia są wyłączone. Jeśli nie można włączyć ograniczeń na końcu przez scalenie <xref:System.Data.ConstraintException> jest generowana i scalonych danych jest zachowywana, natomiast ograniczenia są wyłączone. W takim przypadku <xref:System.Data.DataSet.EnforceConstraints%2A> właściwość jest ustawiona na `false`, i błąd zaznaczone wszystkie wiersze, które nie są prawidłowe. Błędy muszą zostać rozwiązane przed podjęciem próby zresetowania <xref:System.Data.DataSet.EnforceConstraints%2A> właściwości `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataSet dataSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataSet dataSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataSet ^ dataSet);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataSet -&gt; unit" Usage="dataSet.Merge dataSet" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
      </Parameters>
      <Docs>
        <param name="dataSet">
          <see langword="DataSet" /> Których danych i schemat zostaną scalone.</param>
        <summary>Scala określoną <see cref="T:System.Data.DataSet" /> i jego schemat do bieżącego <see langword="DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.Merge%2A> Metoda jest używana do scalenia dwa <xref:System.Data.DataSet> obiektów, które mają schematów w znacznym stopniu podobne. Scalanie jest zwykle używana w aplikacji klienta do zastosować ostatnie zmiany ze źródła danych w istniejącej <xref:System.Data.DataSet>. Umożliwia to aplikacji klienta odświeżyć <xref:System.Data.DataSet> przy użyciu najnowszych danych ze źródła danych.  
  
 <xref:System.Data.DataSet.Merge%2A> Zazwyczaj wywoływana jest metoda na końcu szereg procedur obejmujących sprawdzanie poprawności zmiany, uzgadnianie błędy aktualizacji źródła danych ze zmianami i na koniec odświeżanie istniejącego <xref:System.Data.DataSet>.  
  
 W aplikacji klienckiej jest często mają jednego przycisku, który użytkownik może kliknąć zbiera dane zmienione, a następnie zweryfikuje go przed wysłaniem go z powrotem do składników warstwy środkowej. W tym scenariuszu <xref:System.Data.DataSet.GetChanges%2A> wywołaniu metody. Metoda zwraca wartość drugiej <xref:System.Data.DataSet> zoptymalizowane pod kątem sprawdzania poprawności i scalania. Drugą <xref:System.Data.DataSet> obiekt zawiera tylko <xref:System.Data.DataTable> i <xref:System.Data.DataRow> obiektów, które zostały zmienione, wynikające z podzbioru oryginalnej <xref:System.Data.DataSet>. Ten podzestaw jest zwykle mniejsze i w związku z tym więcej wydajnie przekazywane z powrotem do składników warstwy środkowej. Składnik warstwy środkowej następnie aktualizuje oryginalne źródło danych zmiany za pomocą procedur składowanych. Warstwy środkowej może wysyłać kopii albo nowy <xref:System.Data.DataSet> zawierającą oryginalnych danych oraz najnowsze dane ze źródła danych (przez ponowne uruchomienie oryginalnego zapytania) lub Wyślij ponownie podzbiór o zmianach, które zostały wprowadzone do niej ze źródła danych. (Na przykład, jeśli źródło danych automatycznie tworzy unikatowe wartości kluczy podstawowych, te wartości można propagowane do aplikacji klienckiej.) W obu przypadkach zwróconego <xref:System.Data.DataSet> mogą być scalone aplikacji klienckiej, oryginalne <xref:System.Data.DataSet> z <xref:System.Data.DataSet.Merge%2A> metody.  
  
 Gdy <xref:System.Data.DataSet.Merge%2A> metoda jest wywoływana, schematów dwa <xref:System.Data.DataSet> obiekty są porównywane, ponieważ jest to możliwe, że schematy mogły zostać zmienione. Na przykład w przypadku business-to-business, nowe kolumny może zostały dodane do schematu XML przez zautomatyzowany proces. Jeśli źródło <xref:System.Data.DataSet> zawiera elementy schematu (dodany <xref:System.Data.DataColumn> obiektów) brakuje w miejscu docelowym, elementy schematu mogą zostać dodane do obiektu docelowego, ustawiając `missingSchemaAction` argument `MissingSchemaAction.Add`. W takim przypadku scalonych <xref:System.Data.DataSet> zawiera dodany schemat i dane.  
  
 Po scaleniu schematów, scalania danych.  
  
 Podczas scalania nowe źródło <xref:System.Data.DataSet> do obiektu docelowego, każde źródło wiersze z <xref:System.Data.DataRowState> wartość `Unchanged`, `Modified`, lub `Deleted` są dopasowywane do docelowego wierszy z tej samej wartości klucza podstawowego. Źródło wiersze z `DataRowState` wartość `Added` są dopasowywane do nowych wierszy docelowych z tej samej wartości klucza podstawowego jako nowe wiersze źródła.  
  
 Podczas scalania ograniczenia są wyłączone. Jeśli nie można włączyć ograniczeń na końcu scalania, <xref:System.Data.ConstraintException> jest generowana i scalonych danych jest zachowywana, natomiast ograniczenia są wyłączone. W takim przypadku <xref:System.Data.DataSet.EnforceConstraints%2A> właściwość jest ustawiona na `false`, i błąd zaznaczone wszystkie wiersze, które nie są prawidłowe. Błędy muszą zostać rozwiązane przed podjęciem próby zresetowania <xref:System.Data.DataSet.EnforceConstraints%2A> właściwości `true`.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Data.DataSet.GetChanges%2A>, aktualizacji i <xref:System.Data.DataSet.Merge%2A> metody <xref:System.Data.DataSet>.  
  
 [!code-csharp[Classic WebData DataSet.Merge Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Merge Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.ConstraintException">Nie można włączyć jedno lub więcej ograniczeń.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="dataSet" /> Jest <see langword="null" />.</exception>
        <altmember cref="T:System.Data.ForeignKeyConstraint" />
        <altmember cref="M:System.Data.DataSet.GetChanges" />
        <altmember cref="T:System.Data.UniqueConstraint" />
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataTable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Merge (table As DataTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataTable ^ table);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataTable -&gt; unit" Usage="dataSet.Merge table" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
      </Parameters>
      <Docs>
        <param name="table">
          <see cref="T:System.Data.DataTable" /> Których danych i schemat zostaną scalone.</param>
        <summary>Scala określoną <see cref="T:System.Data.DataTable" /> i jego schemat do bieżącego <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.Merge%2A> Metoda jest używana do scalenia dwa <xref:System.Data.DataSet> obiektów, które mają schematów w znacznym stopniu podobne. Scalanie jest zwykle używana w aplikacji klienta do zastosować ostatnie zmiany ze źródła danych w istniejącej <xref:System.Data.DataSet>. Umożliwia to aplikacji klienta odświeżyć <xref:System.Data.DataSet> przy użyciu najnowszych danych ze źródła danych.  
  
 <xref:System.Data.DataSet.Merge%2A> Zazwyczaj wywoływana jest metoda na końcu szereg procedur obejmujących sprawdzanie poprawności zmiany, uzgadnianie błędy aktualizacji źródła danych ze zmianami i na koniec odświeżanie istniejącego <xref:System.Data.DataSet>.  
  
 W aplikacji klienckiej jest często mają jednego przycisku, który użytkownik może kliknąć zbiera dane zmienione, a następnie zweryfikuje go przed wysłaniem go z powrotem do składników warstwy środkowej. W tym scenariuszu <xref:System.Data.DataSet.GetChanges%2A> wywołaniu metody. Metoda zwraca wartość drugiej <xref:System.Data.DataSet> zoptymalizowane pod kątem sprawdzania poprawności i scalania. Drugą <xref:System.Data.DataSet> obiekt zawiera tylko <xref:System.Data.DataTable> i <xref:System.Data.DataRow> obiektów, które zostały zmienione, wynikające z podzbioru oryginalnej <xref:System.Data.DataSet>. Ten podzestaw jest zwykle mniejsze i w związku z tym więcej wydajnie przekazywane z powrotem do składników warstwy środkowej. Składnik warstwy środkowej następnie aktualizuje oryginalne źródło danych zmiany za pomocą procedur składowanych. Warstwy środkowej może wysyłać kopii albo nowy <xref:System.Data.DataSet> zawierającą oryginalnych danych oraz najnowsze dane ze źródła danych (przez ponowne uruchomienie oryginalnego zapytania) lub Wyślij ponownie podzbiór o zmianach, które zostały wprowadzone do niej ze źródła danych. (Na przykład, jeśli źródło danych automatycznie tworzy unikatowe wartości kluczy podstawowych, te wartości można propagowane do aplikacji klienckiej.) W obu przypadkach zwróconego <xref:System.Data.DataSet> mogą być scalone aplikacji klienckiej, oryginalne <xref:System.Data.DataSet> z <xref:System.Data.DataSet.Merge%2A> metody.  
  
 Gdy <xref:System.Data.DataSet.Merge%2A> metoda jest wywoływana, schematów dwa <xref:System.Data.DataSet> obiekty są porównywane, ponieważ jest to możliwe, że schematy mogły zostać zmienione. Na przykład w przypadku business-to-business, nowe kolumny może zostały dodane do schematu XML przez zautomatyzowany proces. Jeśli źródło <xref:System.Data.DataSet> zawiera elementy schematu (dodany <xref:System.Data.DataColumn> obiektów) brakuje w miejscu docelowym, elementy schematu mogą zostać dodane do obiektu docelowego, ustawiając `missingSchemaAction` argument `MissingSchemaAction.Add`. W takim przypadku scalonych <xref:System.Data.DataSet> zawiera dodany schemat i dane.  
  
 Po scaleniu schematów, scalania danych.  
  
 Podczas scalania nowe źródło <xref:System.Data.DataSet> do obiektu docelowego, każde źródło wiersze z <xref:System.Data.DataRowState> wartość `Unchanged`, `Modified`, lub `Deleted` są dopasowywane do docelowego wierszy z tej samej wartości klucza podstawowego. Źródło wiersze z `DataRowState` wartość `Added` są dopasowywane do nowych wierszy docelowych z tej samej wartości klucza podstawowego jako nowe wiersze źródła.  
  
 Podczas scalania ograniczenia są wyłączone. Jeśli nie można włączyć ograniczeń na końcu scalania, <xref:System.Data.ConstraintException> jest generowana i scalonych danych jest zachowywana, natomiast ograniczenia są wyłączone. W takim przypadku <xref:System.Data.DataSet.EnforceConstraints%2A> właściwość jest ustawiona na `false`, i błąd zaznaczone wszystkie wiersze, które nie są prawidłowe. Błędy muszą zostać rozwiązane przed podjęciem próby zresetowania <xref:System.Data.DataSet.EnforceConstraints%2A> właściwości `true`.  
  
   
  
## Examples  
 Poniższy przykład tworzy prosty <xref:System.Data.DataSet> z jednej tabeli, dwóch kolumn i wierszy dziesięć. Drugi <xref:System.Data.DataTable> utworzeniu który jest taka sama jak pierwsza. Dwa wiersze są dodawane do drugiej tabeli, która jest następnie scalany <xref:System.Data.DataSet>.  
  
 [!code-csharp[Classic WebData DataSet.Merge3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Merge3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="table" /> Jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataSet dataSet, bool preserveChanges);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataSet dataSet, bool preserveChanges) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataSet ^ dataSet, bool preserveChanges);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataSet * bool -&gt; unit" Usage="dataSet.Merge (dataSet, preserveChanges)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="dataSet">
          <see langword="DataSet" /> Których danych i schemat zostaną scalone.</param>
        <param name="preserveChanges">
          <see langword="true" /> Aby zachować zmiany w bieżącym <see langword="DataSet" />; w przeciwnym razie <see langword="false" />.</param>
        <summary>Scala określoną <see cref="T:System.Data.DataSet" /> i jego schemat do bieżącego <see langword="DataSet" />, zachowując lub odrzucenie zmian w tym <see langword="DataSet" /> zgodnie z danego argumentu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.Merge%2A> Metoda jest używana do scalenia dwa <xref:System.Data.DataSet> obiektów, które mają schematów w znacznym stopniu podobne. Scalanie jest zwykle używana w aplikacji klienta do zastosować ostatnie zmiany ze źródła danych w istniejącej <xref:System.Data.DataSet>. Umożliwia to aplikacji klienta odświeżyć <xref:System.Data.DataSet> przy użyciu najnowszych danych ze źródła danych.  
  
 <xref:System.Data.DataSet.Merge%2A> Zazwyczaj wywoływana jest metoda na końcu szereg procedur obejmujących sprawdzanie poprawności zmiany, uzgadnianie błędy aktualizacji źródła danych ze zmianami i na koniec odświeżanie istniejącego <xref:System.Data.DataSet>.  
  
 W aplikacji klienckiej jest często mają jednego przycisku, który użytkownik może kliknąć zbiera dane zmienione, a następnie zweryfikuje go przed wysłaniem go z powrotem do składników warstwy środkowej. W tym scenariuszu <xref:System.Data.DataSet.GetChanges%2A> wywołaniu metody. Metoda zwraca wartość drugiej <xref:System.Data.DataSet> zoptymalizowane pod kątem sprawdzania poprawności i scalania. Drugą <xref:System.Data.DataSet> obiekt zawiera tylko <xref:System.Data.DataTable> i <xref:System.Data.DataRow> obiektów, które zostały zmienione, wynikające z podzbioru oryginalnej <xref:System.Data.DataSet>. Ten podzestaw jest zwykle mniejsze i w związku z tym więcej wydajnie przekazywane z powrotem do składników warstwy środkowej. Składnik warstwy środkowej następnie aktualizuje oryginalne źródło danych zmiany za pomocą procedur składowanych. Warstwy środkowej może wysyłać kopii albo nowy <xref:System.Data.DataSet> zawierającą oryginalnych danych oraz najnowsze dane ze źródła danych (przez ponowne uruchomienie oryginalnego zapytania) lub Wyślij ponownie podzbiór o zmianach, które zostały wprowadzone do niej ze źródła danych. (Na przykład, jeśli źródło danych automatycznie tworzy unikatowe wartości kluczy podstawowych, te wartości można propagowane do aplikacji klienckiej.) W obu przypadkach zwróconego <xref:System.Data.DataSet> mogą być scalone aplikacji klienckiej, oryginalne <xref:System.Data.DataSet> z <xref:System.Data.DataSet.Merge%2A> metody.  
  
 Gdy <xref:System.Data.DataSet.Merge%2A> metoda jest wywoływana, schematów dwa <xref:System.Data.DataSet> obiekty są porównywane, ponieważ jest to możliwe, że schematy mogły zostać zmienione. Na przykład w przypadku business-to-business, nowe kolumny może zostały dodane do schematu XML przez zautomatyzowany proces. Jeśli źródło <xref:System.Data.DataSet> zawiera elementy schematu (dodany <xref:System.Data.DataColumn> obiektów) brakuje w miejscu docelowym, elementy schematu mogą zostać dodane do obiektu docelowego, ustawiając `missingSchemaAction` argument `MissingSchemaAction.Add`. W takim przypadku scalonych <xref:System.Data.DataSet> zawiera dodany schemat i dane.  
  
 Po scaleniu schematów, scalania danych.  
  
 Podczas scalania nowe źródło <xref:System.Data.DataSet> do obiektu docelowego, każde źródło wiersze z <xref:System.Data.DataRowState> wartość `Unchanged`, `Modified`, lub `Deleted` są dopasowywane do docelowego wierszy z tej samej wartości klucza podstawowego. Źródło wiersze z `DataRowState` wartość `Added` są dopasowywane do nowych wierszy docelowych z tej samej wartości klucza podstawowego jako nowe wiersze źródła.  
  
 Podczas scalania ograniczenia są wyłączone. Jeśli nie można włączyć ograniczeń na końcu scalania, <xref:System.Data.ConstraintException> jest generowana i scalonych danych jest zachowywana, natomiast ograniczenia są wyłączone. W takim przypadku <xref:System.Data.DataSet.EnforceConstraints%2A> właściwość jest ustawiona na `false`, i błąd zaznaczone wszystkie wiersze, które nie są prawidłowe. Błędy muszą zostać rozwiązane przed podjęciem próby zresetowania <xref:System.Data.DataSet.EnforceConstraints%2A> właściwości `true`.  
  
   
  
## Examples  
 Poniższy przykład tworzy prosty <xref:System.Data.DataSet> z jednej tabeli, dwóch kolumn i wierszy dziesięć. Po dodaniu dziesięć wierszy, dwie wartości są zmieniane, i dodaje się jeden wiersz. Podzbiór zmienionych danych został utworzony za pomocą <xref:System.Data.DataSet.GetChanges%2A> metody. Po uzgodnieniu błędy, podzbiór danych jest scalany oryginalnej <xref:System.Data.DataSet>.  
  
 [!code-csharp[Classic WebData DataSet.GetChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Data.ForeignKeyConstraint" />
        <altmember cref="T:System.Data.UniqueConstraint" />
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataRow[] rows, bool preserveChanges, System.Data.MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataRow[] rows, bool preserveChanges, valuetype System.Data.MissingSchemaAction missingSchemaAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(cli::array &lt;System::Data::DataRow ^&gt; ^ rows, bool preserveChanges, System::Data::MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataRow[] * bool * System.Data.MissingSchemaAction -&gt; unit" Usage="dataSet.Merge (rows, preserveChanges, missingSchemaAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rows" Type="System.Data.DataRow[]" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
        <Parameter Name="missingSchemaAction" Type="System.Data.MissingSchemaAction" />
      </Parameters>
      <Docs>
        <param name="rows">Tablica <see cref="T:System.Data.DataRow" /> obiekty do scalenia do <see langword="DataSet" />.</param>
        <param name="preserveChanges">
          <see langword="true" /> Aby zachować zmiany w <see langword="DataSet" />; w przeciwnym razie <see langword="false" />.</param>
        <param name="missingSchemaAction">Jeden z <see cref="T:System.Data.MissingSchemaAction" /> wartości.</param>
        <summary>Scala tablicę <see cref="T:System.Data.DataRow" /> obiekty do bieżącego <see cref="T:System.Data.DataSet" />, zachowując lub odrzucania zmian w <see langword="DataSet" /> i obsługi niezgodne schematu zgodnie z danym argumentów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.Merge%2A> Metoda jest używana do scalenia dwa <xref:System.Data.DataSet> obiektów, które mają schematów w znacznym stopniu podobne. Scalanie jest zwykle używana w aplikacji klienta do zastosować ostatnie zmiany ze źródła danych w istniejącej <xref:System.Data.DataSet>. Umożliwia to aplikacji klienta odświeżyć <xref:System.Data.DataSet> przy użyciu najnowszych danych ze źródła danych.  
  
 <xref:System.Data.DataSet.Merge%2A> Zazwyczaj wywoływana jest metoda na końcu szereg procedur obejmujących sprawdzanie poprawności zmiany, uzgadnianie błędy aktualizacji źródła danych ze zmianami i na koniec odświeżanie istniejącego <xref:System.Data.DataSet>.  
  
 W aplikacji klienckiej jest często mają jednego przycisku, który użytkownik może kliknąć zbiera dane zmienione, a następnie zweryfikuje go przed wysłaniem go z powrotem do składników warstwy środkowej. W tym scenariuszu <xref:System.Data.DataSet.GetChanges%2A> wywołaniu metody. Metoda zwraca wartość drugiej <xref:System.Data.DataSet> zoptymalizowane pod kątem sprawdzania poprawności i scalania. Drugą <xref:System.Data.DataSet> obiekt zawiera tylko <xref:System.Data.DataTable> i <xref:System.Data.DataRow> obiektów, które zostały zmienione, wynikające z podzbioru oryginalnej <xref:System.Data.DataSet>. Ten podzestaw jest zwykle mniejsze i w związku z tym więcej wydajnie przekazywane z powrotem do składników warstwy środkowej. Składnik warstwy środkowej następnie aktualizuje oryginalne źródło danych zmiany za pomocą procedur składowanych. Warstwy środkowej może wysyłać kopii albo nowy <xref:System.Data.DataSet> zawierającą oryginalnych danych oraz najnowsze dane ze źródła danych (przez ponowne uruchomienie oryginalnego zapytania) lub Wyślij ponownie podzbiór o zmianach, które zostały wprowadzone do niej ze źródła danych. (Na przykład, jeśli źródło danych automatycznie tworzy unikatowe wartości kluczy podstawowych, te wartości można propagowane do aplikacji klienckiej.) W obu przypadkach zwróconego <xref:System.Data.DataSet> mogą być scalone aplikacji klienckiej, oryginalne <xref:System.Data.DataSet> z <xref:System.Data.DataSet.Merge%2A> metody.  
  
 Aby ułatwić wyjaśnienie <xref:System.Data.DataSet.Merge%2A> metody używamy "target" oznaczającego bieżącego <xref:System.Data.DataSet>i "source" na sekundę (parametr) nazwa <xref:System.Data.DataSet>. Element docelowy <xref:System.Data.DataSet> jest więc o nazwie, ponieważ jest obiekt, w którym występuje akcję (scalanie). Drugi <xref:System.Data.DataSet> jest nazywany "source", ponieważ zawiera on informacje nie ulega zmianie, ale zamiast tego jest scalany bieżącego <xref:System.Data.DataSet>.  
  
 Gdy <xref:System.Data.DataSet.Merge%2A> metoda jest wywoływana, schematów dwa <xref:System.Data.DataSet> obiekty są porównywane, ponieważ jest to możliwe, że schematy mogły zostać zmienione. Na przykład w przypadku business-to-business, nowe kolumny może zostały dodane do schematu XML przez zautomatyzowany proces. Jeśli źródło <xref:System.Data.DataSet> zawiera elementy schematu (dodany <xref:System.Data.DataColumn> obiektów) brakuje w miejscu docelowym, elementy schematu mogą zostać dodane do obiektu docelowego, ustawiając `missingSchemaAction` argument `MissingSchemaAction.Add`. W takim przypadku scalonych <xref:System.Data.DataSet> zawiera dodany schemat i dane.  
  
 Po scaleniu schematów, scalania danych.  
  
 Podczas scalania nowe źródło <xref:System.Data.DataSet> do obiektu docelowego, każde źródło wiersze z <xref:System.Data.DataRowState> wartość `Unchanged`, `Modified`, lub `Deleted` są dopasowywane do docelowego wierszy z tej samej wartości klucza podstawowego. Źródło wiersze z `DataRowState` wartość `Added` są dopasowywane do nowych wierszy docelowych z tej samej wartości klucza podstawowego jako nowe wiersze źródła.  
  
 Podczas scalania ograniczenia są wyłączone. Jeśli nie można włączyć ograniczeń na końcu scalania, <xref:System.Data.ConstraintException> jest generowana i scalonych danych jest zachowywana, natomiast ograniczenia są wyłączone. W takim przypadku <xref:System.Data.DataSet.EnforceConstraints%2A> właściwość jest ustawiona na `false`, i błąd zaznaczone wszystkie wiersze, które nie są prawidłowe. Błędy muszą zostać rozwiązane przed podjęciem próby zresetowania <xref:System.Data.DataSet.EnforceConstraints%2A> właściwości `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataSet dataSet, bool preserveChanges, System.Data.MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataSet dataSet, bool preserveChanges, valuetype System.Data.MissingSchemaAction missingSchemaAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataSet ^ dataSet, bool preserveChanges, System::Data::MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataSet * bool * System.Data.MissingSchemaAction -&gt; unit" Usage="dataSet.Merge (dataSet, preserveChanges, missingSchemaAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
        <Parameter Name="missingSchemaAction" Type="System.Data.MissingSchemaAction" />
      </Parameters>
      <Docs>
        <param name="dataSet">
          <see langword="DataSet" /> Których danych i schemat zostaną scalone.</param>
        <param name="preserveChanges">
          <see langword="true" /> Aby zachować zmiany w bieżącym <see langword="DataSet" />; w przeciwnym razie <see langword="false" />.</param>
        <param name="missingSchemaAction">Jeden z <see cref="T:System.Data.MissingSchemaAction" /> wartości.</param>
        <summary>Scala określoną <see cref="T:System.Data.DataSet" /> i jego schematu z bieżącym <see langword="DataSet" />, zachowując lub odrzucania zmian w bieżącym <see langword="DataSet" /> i obsługi niezgodne schematu zgodnie z danym argumentów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.Merge%2A> Metoda jest używana do scalenia dwa <xref:System.Data.DataSet> obiektów, które mają schematów w znacznym stopniu podobne. Scalanie jest zwykle używana w aplikacji klienta do zastosować ostatnie zmiany ze źródła danych w istniejącej <xref:System.Data.DataSet>. Umożliwia to aplikacji klienta odświeżyć <xref:System.Data.DataSet> przy użyciu najnowszych danych ze źródła danych.  
  
 <xref:System.Data.DataSet.Merge%2A> Zazwyczaj wywoływana jest metoda na końcu szereg procedur obejmujących sprawdzanie poprawności zmiany, uzgadnianie błędy aktualizacji źródła danych ze zmianami i na koniec odświeżanie istniejącego <xref:System.Data.DataSet>.  
  
 W aplikacji klienckiej jest często mają jednego przycisku, który użytkownik może kliknąć zbiera dane zmienione, a następnie zweryfikuje go przed wysłaniem go z powrotem do składników warstwy środkowej. W tym scenariuszu <xref:System.Data.DataSet.GetChanges%2A> wywołaniu metody. Metoda zwraca wartość drugiej <xref:System.Data.DataSet> zoptymalizowane pod kątem sprawdzania poprawności i scalania. Drugą <xref:System.Data.DataSet> obiekt zawiera tylko <xref:System.Data.DataTable> i <xref:System.Data.DataRow> obiektów, które zostały zmienione, wynikające z podzbioru oryginalnej <xref:System.Data.DataSet>. Ten podzestaw jest zwykle mniejsze i w związku z tym więcej wydajnie przekazywane z powrotem do składników warstwy środkowej. Składnik warstwy środkowej następnie aktualizuje oryginalne źródło danych zmiany za pomocą procedur składowanych. Warstwy środkowej może wysyłać kopii albo nowy <xref:System.Data.DataSet> zawierającą oryginalnych danych oraz najnowsze dane ze źródła danych (przez ponowne uruchomienie oryginalnego zapytania) lub Wyślij ponownie podzbiór o zmianach, które zostały wprowadzone do niej ze źródła danych. (Na przykład, jeśli źródło danych automatycznie tworzy unikatowe wartości kluczy podstawowych, te wartości można propagowane do aplikacji klienckiej.) W obu przypadkach zwróconego <xref:System.Data.DataSet> mogą być scalone aplikacji klienckiej, oryginalne <xref:System.Data.DataSet> z <xref:System.Data.DataSet.Merge%2A> metody.  
  
 Aby ułatwić wyjaśnienie <xref:System.Data.DataSet.Merge%2A> metody używamy "target" oznaczającego bieżącego <xref:System.Data.DataSet>i "source" na sekundę (parametr) nazwa <xref:System.Data.DataSet>. Element docelowy <xref:System.Data.DataSet> jest więc o nazwie, ponieważ jest obiekt, w którym występuje akcję (scalanie). Drugi <xref:System.Data.DataSet> jest nazywany "source", ponieważ zawiera on informacje nie ulega zmianie, ale zamiast tego jest scalany bieżącego <xref:System.Data.DataSet>.  
  
 Gdy <xref:System.Data.DataSet.Merge%2A> metoda jest wywoływana, schematów dwa <xref:System.Data.DataSet> obiekty są porównywane, ponieważ jest to możliwe, że schematy mogły zostać zmienione. Na przykład w przypadku business-to-business, nowe kolumny może zostały dodane do schematu XML przez zautomatyzowany proces. Jeśli źródło <xref:System.Data.DataSet> zawiera elementy schematu (dodany <xref:System.Data.DataColumn> obiektów) brakuje w miejscu docelowym, elementy schematu mogą zostać dodane do obiektu docelowego, ustawiając `missingSchemaAction` argument `MissingSchemaAction.Add`. W takim przypadku scalonych <xref:System.Data.DataSet> zawiera dodany schemat i dane.  
  
 Po scaleniu schematów, scalania danych.  
  
 Podczas scalania nowe źródło <xref:System.Data.DataSet> do obiektu docelowego, każde źródło wiersze z <xref:System.Data.DataRowState> wartość `Unchanged`, `Modified`, lub `Deleted` są dopasowywane do docelowego wierszy z tej samej wartości klucza podstawowego. Źródło wiersze z `DataRowState` wartość `Added` są dopasowywane do nowych wierszy docelowych z tej samej wartości klucza podstawowego jako nowe wiersze źródła.  
  
 Podczas scalania ograniczenia są wyłączone. Jeśli nie można włączyć ograniczeń na końcu scalania, <xref:System.Data.ConstraintException> jest generowana i scalonych danych jest zachowywana, natomiast ograniczenia są wyłączone. W takim przypadku <xref:System.Data.DataSet.EnforceConstraints%2A> właściwość jest ustawiona na `false`, i błąd zaznaczone wszystkie wiersze, które nie są prawidłowe. Błędy muszą zostać rozwiązane przed podjęciem próby zresetowania <xref:System.Data.DataSet.EnforceConstraints%2A> właściwości `true`.  
  
   
  
## Examples  
 Poniższy przykład tworzy prosty <xref:System.Data.DataSet> z jednej tabeli, dwóch kolumn i wierszy dziesięć. Dwie wartości są zmieniane, a jeden wiersz zostanie dodany. Podzbiór zmienionych danych został utworzony za pomocą <xref:System.Data.DataSet.GetChanges%2A> metody. Po uzgodnieniu błędy, kolumna zostanie dodana do podzbioru zmiany schematu. Gdy <xref:System.Data.DataSet.Merge%2A> metoda jest wywoływana z `missingSchemaAction` ustawioną `MissingSchemaAction.Add`, nowej kolumny, która jest dodane do oryginalnej <xref:System.Data.DataSet> schematu obiektu.  
  
 [!code-csharp[Classic WebData DataSet.Merge2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Merge2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="dataSet" /> Jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table, bool preserveChanges, System.Data.MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table, bool preserveChanges, valuetype System.Data.MissingSchemaAction missingSchemaAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataTable ^ table, bool preserveChanges, System::Data::MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataTable * bool * System.Data.MissingSchemaAction -&gt; unit" Usage="dataSet.Merge (table, preserveChanges, missingSchemaAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
        <Parameter Name="missingSchemaAction" Type="System.Data.MissingSchemaAction" />
      </Parameters>
      <Docs>
        <param name="table">
          <see langword="DataTable" /> Których danych i schemat zostaną scalone.</param>
        <param name="preserveChanges">Jeden z <see cref="T:System.Data.MissingSchemaAction" /> wartości.</param>
        <param name="missingSchemaAction">
          <see langword="true" /> Aby zachować zmiany w <see langword="DataSet" />; w przeciwnym razie <see langword="false" />.</param>
        <summary>Scala określoną <see cref="T:System.Data.DataTable" /> i jego schemat do bieżącego <see langword="DataSet" />, zachowując lub odrzucania zmian w <see langword="DataSet" /> i obsługi niezgodne schematu zgodnie z danym argumentów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.Merge%2A> Metoda jest używana do scalenia dwa <xref:System.Data.DataSet> obiektów, które mają schematów w znacznym stopniu podobne. Scalanie jest zwykle używana w aplikacji klienta do zastosować ostatnie zmiany ze źródła danych w istniejącej <xref:System.Data.DataSet>. Umożliwia to aplikacji klienta odświeżyć <xref:System.Data.DataSet> przy użyciu najnowszych danych ze źródła danych.  
  
 <xref:System.Data.DataSet.Merge%2A> Zazwyczaj wywoływana jest metoda na końcu szereg procedur obejmujących sprawdzanie poprawności zmiany, uzgadnianie błędy aktualizacji źródła danych ze zmianami i na koniec odświeżanie istniejącego <xref:System.Data.DataSet>.  
  
 zakres przechowywania aplikacji klienckiej, jest często mają jednego przycisku, który użytkownik może kliknąć zbiera dane zmienione, a następnie zweryfikuje go przed wysłaniem go z powrotem do składników warstwy środkowej. W tym scenariuszu <xref:System.Data.DataSet.GetChanges%2A> wywołaniu metody. Metoda zwraca wartość drugiej <xref:System.Data.DataSet> zoptymalizowane pod kątem sprawdzania poprawności i scalania. Drugą <xref:System.Data.DataSet> obiekt zawiera tylko <xref:System.Data.DataTable> i <xref:System.Data.DataRow> obiektów, które zostały zmienione, wynikające z podzbioru oryginalnej <xref:System.Data.DataSet>. Ten podzestaw jest zwykle mniejsze i w związku z tym więcej wydajnie przekazywane z powrotem do składników warstwy środkowej. Składnik warstwy środkowej następnie aktualizuje oryginalne źródło danych zmiany za pomocą procedur składowanych. Warstwy środkowej może wysyłać kopii albo nowy <xref:System.Data.DataSet> zawierającą oryginalnych danych oraz najnowsze dane ze źródła danych (przez ponowne uruchomienie oryginalnego zapytania) lub Wyślij ponownie podzbiór o zmianach, które zostały wprowadzone do niej ze źródła danych. (Na przykład, jeśli źródło danych automatycznie tworzy unikatowe wartości kluczy podstawowych, te wartości można propagowane do aplikacji klienckiej.) W obu przypadkach zwróconego <xref:System.Data.DataSet> mogą być scalone aplikacji klienckiej, oryginalne <xref:System.Data.DataSet> z <xref:System.Data.DataSet.Merge%2A> metody.  
  
 Gdy <xref:System.Data.DataSet.Merge%2A> metoda jest wywoływana, schematów dwa <xref:System.Data.DataSet> obiekty są porównywane, ponieważ jest to możliwe, że schematy mogły zostać zmienione. Na przykład w przypadku business-to-business, nowe kolumny może zostały dodane do schematu XML przez zautomatyzowany proces. Jeśli źródło <xref:System.Data.DataSet> zawiera elementy schematu (dodany <xref:System.Data.DataColumn> obiektów) brakuje w miejscu docelowym, elementy schematu mogą zostać dodane do obiektu docelowego, ustawiając `missingSchemaAction` argument `MissingSchemaAction.Add`. W takim przypadku scalonych <xref:System.Data.DataSet> zawiera dodany schemat i dane.  
  
 Po scaleniu schematów, scalania danych.  
  
 Podczas scalania nowe źródło <xref:System.Data.DataSet> do obiektu docelowego, każde źródło wiersze z <xref:System.Data.DataRowState> wartość `Unchanged`, `Modified`, lub `Deleted` są dopasowywane do docelowego wierszy z tej samej wartości klucza podstawowego. Źródło wiersze z `DataRowState` wartość `Added` są dopasowywane do nowych wierszy docelowych z tej samej wartości klucza podstawowego jako nowe wiersze źródła.  
  
 Podczas scalania ograniczenia są wyłączone. Jeśli nie można włączyć ograniczeń na końcu scalania, <xref:System.Data.ConstraintException> jest generowana i scalonych danych jest zachowywana, natomiast ograniczenia są wyłączone. W takim przypadku <xref:System.Data.DataSet.EnforceConstraints%2A> właściwość jest ustawiona na `false`, i błąd zaznaczone wszystkie wiersze, które nie są prawidłowe. Błędy muszą zostać rozwiązane przed podjęciem próby zresetowania <xref:System.Data.DataSet.EnforceConstraints%2A> właściwości `true`.  
  
   
  
## Examples  
 Poniższy przykład tworzy prosty <xref:System.Data.DataSet> z jednej tabeli, dwóch kolumn i wierszy dziesięć. Drugi <xref:System.Data.DataTable> utworzeniu czyli niemal identyczny jak pierwszy z tą różnicą, że nowy `DataColumn` zostanie dodany do tabeli. Dwa wiersze są dodawane do drugiej tabeli, która jest następnie scalany <xref:System.Data.DataSet> z `preserveChanges` argument wartość `false`i `missingSchemaAction` argument wartość `MissingSchemaAction.Add`.  
  
 [!code-csharp[Classic WebData DataSet.Merge4 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge4 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Merge4 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge4 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="dataSet" /> Jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MergeFailed">
      <MemberSignature Language="C#" Value="public event System.Data.MergeFailedEventHandler MergeFailed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.MergeFailedEventHandler MergeFailed" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataSet.MergeFailed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MergeFailed As MergeFailedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::MergeFailedEventHandler ^ MergeFailed;" />
      <MemberSignature Language="F#" Value="member this.MergeFailed : System.Data.MergeFailedEventHandler " Usage="member this.MergeFailed : System.Data.MergeFailedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.MergeFailedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy źródłowe i docelowe <see cref="T:System.Data.DataRow" /> mieć tej samej wartości klucza podstawowego, a <see cref="P:System.Data.DataSet.EnforceConstraints" /> jest ustawiona na true.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [NIB: Korzystanie z zdarzenia](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67).  
  
   
  
## Examples  
 W poniższym przykładzie pokazano użycie <xref:System.Data.DataSet.MergeFailed> zdarzeń.  
  
 [!code-csharp[Classic WebData DataSet.MergeFailed Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.MergeFailed Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.MergeFailed Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.MergeFailed Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public string Namespace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Namespace { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string with get, set" Usage="System.Data.DataSet.Namespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia obszar nazw <see cref="T:System.Data.DataSet" />.</summary>
        <value>Przestrzeń nazw <see cref="T:System.Data.DataSet" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.Namespace%2A> Właściwość jest używana podczas odczytywania i zapisywania XML dokumentu do <xref:System.Data.DataSet> przy użyciu <xref:System.Data.DataSet.ReadXml%2A>, <xref:System.Data.DataSet.WriteXml%2A>, <xref:System.Data.DataSet.ReadXmlSchema%2A>, lub <xref:System.Data.DataSet.WriteXmlSchema%2A> metody.  
  
 Przestrzeń nazw dokumentu XML służy do określania zakresu atrybuty i elementy odczytywana do XML <xref:System.Data.DataSet>. Na przykład jeśli <xref:System.Data.DataSet> zawiera schemat z dokumentu z przestrzenią nazw "Moja firma," odczytano i próby odczytania danych tylko z dokumentu z różnych przestrzeni nazw, dane, które nie odpowiadają istniejący schemat zostanie zignorowany.  
  
   
  
## Examples  
 W poniższym przykładzie <xref:System.Data.DataSet.Prefix%2A> przed wywołaniem <xref:System.Data.DataSet.ReadXml%2A> metody.  
  
 [!code-csharp[Classic WebData DataSet.Namespace Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Namespace Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Namespace Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Namespace Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Przestrzeń nazw zawiera już dane.</exception>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnPropertyChanging (System.ComponentModel.PropertyChangedEventArgs pcevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPropertyChanging(class System.ComponentModel.PropertyChangedEventArgs pcevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPropertyChanging (pcevent As PropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPropertyChanging(System::ComponentModel::PropertyChangedEventArgs ^ pcevent);" />
      <MemberSignature Language="F#" Value="abstract member OnPropertyChanging : System.ComponentModel.PropertyChangedEventArgs -&gt; unit&#xA;override this.OnPropertyChanging : System.ComponentModel.PropertyChangedEventArgs -&gt; unit" Usage="dataSet.OnPropertyChanging pcevent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcevent" Type="System.ComponentModel.PropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="pcevent">A <see cref="T:System.ComponentModel.PropertyChangedEventArgs" /> zawierający dane zdarzenia.</param>
        <summary>Zgłasza <see cref="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać ogólne informacje, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>W przypadku przesłaniania <see cref="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" /> w klasie pochodnej, należy wywołać klasy podstawowej <see cref="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" /> metody.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRemoveRelation">
      <MemberSignature Language="C#" Value="protected virtual void OnRemoveRelation (System.Data.DataRelation relation);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRemoveRelation(class System.Data.DataRelation relation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.OnRemoveRelation(System.Data.DataRelation)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRemoveRelation (relation As DataRelation)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRemoveRelation(System::Data::DataRelation ^ relation);" />
      <MemberSignature Language="F#" Value="abstract member OnRemoveRelation : System.Data.DataRelation -&gt; unit&#xA;override this.OnRemoveRelation : System.Data.DataRelation -&gt; unit" Usage="dataSet.OnRemoveRelation relation" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relation" Type="System.Data.DataRelation" />
      </Parameters>
      <Docs>
        <param name="relation">
          <see cref="T:System.Data.DataRelation" /> Usuwana.</param>
        <summary>Występuje, gdy <see cref="T:System.Data.DataRelation" /> obiekt jest usunięty z <see cref="T:System.Data.DataTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda powinna zostać zastąpiona przez podklasy, aby ograniczyć tabel usuwana  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnRemoveTable">
      <MemberSignature Language="C#" Value="protected internal virtual void OnRemoveTable (System.Data.DataTable table);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnRemoveTable(class System.Data.DataTable table) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.OnRemoveTable(System.Data.DataTable)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnRemoveTable (table As DataTable)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnRemoveTable(System::Data::DataTable ^ table);" />
      <MemberSignature Language="F#" Value="abstract member OnRemoveTable : System.Data.DataTable -&gt; unit&#xA;override this.OnRemoveTable : System.Data.DataTable -&gt; unit" Usage="dataSet.OnRemoveTable table" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
      </Parameters>
      <Docs>
        <param name="table">
          <see cref="T:System.Data.DataTable" /> Usuwana.</param>
        <summary>Występuje, gdy <see cref="T:System.Data.DataTable" /> zostanie usunięty z <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może zostać zastąpiona przez podklasy ograniczyć tabele przed usunięciem.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono klasę pochodzącą od <xref:System.Data.DataSet> z <xref:System.Data.DataSet.OnRemoveTable%2A> przesłonięcia metody.  
  
 [!code-csharp[Classic WebData DataSet.OnRemoveTable Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.OnRemoveTable Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.OnRemoveTable Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.OnRemoveTable Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix">
      <MemberSignature Language="C#" Value="public string Prefix { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Prefix" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Prefix" />
      <MemberSignature Language="VB.NET" Value="Public Property Prefix As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Prefix { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Prefix : string with get, set" Usage="System.Data.DataSet.Prefix" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia XML prefiks tego aliasów przestrzeni nazw <see cref="T:System.Data.DataSet" />.</summary>
        <value>Prefiks XML <see cref="T:System.Data.DataSet" /> przestrzeni nazw.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.Prefix%2A> Właściwość jest używana w dokumencie XML, aby zidentyfikować elementy, które należą do przestrzeni nazw <xref:System.Data.DataSet> obiektu (jak ustawione przez <xref:System.Data.DataSet.Namespace%2A> właściwości).  
  
   
  
## Examples  
 W poniższym przykładzie <xref:System.Data.DataSet.Prefix%2A> przed wywołaniem <xref:System.Data.DataSet.ReadXml%2A> metody.  
  
 [!code-csharp[Classic WebData DataSet.Namespace Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Namespace Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Namespace Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Namespace Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RaisePropertyChanging">
      <MemberSignature Language="C#" Value="protected internal void RaisePropertyChanging (string name);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void RaisePropertyChanging(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.RaisePropertyChanging(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub RaisePropertyChanging (name As String)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void RaisePropertyChanging(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.RaisePropertyChanging : string -&gt; unit" Usage="dataSet.RaisePropertyChanging name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa właściwości, która ma zostać zmieniona.</param>
        <summary>Wysyła powiadomienie, że określony <see cref="T:System.Data.DataSet" /> właściwość ma zostać zmieniona.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadXml">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Odczytuje XML: schemat i dane do <see cref="T:System.Data.DataSet" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.IO.Stream -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Obiekt, który jest pochodną <see cref="T:System.IO.Stream" />.</param>
        <summary>Odczytuje XML: schemat i dane do <see cref="T:System.Data.DataSet" /> przy użyciu określonego <see cref="T:System.IO.Stream" />.</summary>
        <returns>
          <see cref="T:System.Data.XmlReadMode" /> Używany do odczytu danych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.ReadXml%2A> Metoda zapewnia sposób odczytać tylko dane lub zarówno danych i schematu do <xref:System.Data.DataSet> z dokumentu XML, podczas gdy <xref:System.Data.DataSet.ReadXmlSchema%2A> metoda odczytuje tylko schemat. Aby odczytać zarówno danych, jak i schematu, użyj jednej z `ReadXML` przeciążeń, które zawiera `mode` parametru i ustaw dla niego wartość `ReadSchema`.  
  
 Należy pamiętać, że to samo dotyczy dla <xref:System.Data.DataSet.WriteXml%2A> i <xref:System.Data.DataSet.WriteXmlSchema%2A> metod, odpowiednio. Można zapisać danych XML lub schemat i dane z `DataSet`, użyj `WriteXml` metody. Aby zapisać tylko schemat, należy użyć `WriteXmlSchema` metody.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Zostanie wygenerowany, jeśli typ kolumny w `DataRow` trwa od zapisu lub odczytu implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> i nie implementuje <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Jeśli określono schemat w tekście, schematu w wierszu służy do rozszerzania istniejącej struktury relacyjne przed załadowaniem danych. Jeśli występują konflikty (na przykład tej samej kolumny w tej samej tabeli zdefiniowane przy użyciu różnych typów danych) jest wyjątek.  
  
 Jeśli schemat nie-line jest określony, struktura relacyjnej został rozszerzony za pośrednictwem wnioskowania odpowiednio do potrzeb zgodnie ze struktury dokumentu XML. Jeśli schemat nie może zostać rozszerzony za pomocą wnioskowania, aby udostępnić wszystkie dane, jest wyjątek.  
  
> [!NOTE]
>  `DataSet` Nie wiąże — element XML z odpowiadającymi mu dostawcami `DataColumn` lub `DataTable` po prawidłowe znaki XML, takich jak ("_") są anulowane w serializacji XML. `DataSet` Się tylko specjalne niedozwolone znaki XML w nazwach elementów XML i dlatego tylko zajmowane są takie same. Gdy będą miały zmienione znaczenie prawidłowe znaki w nazwie elementu XML, element jest ignorowany podczas przetwarzania.  
  
 Jeśli schemat XML <xref:System.Data.DataSet> obejmuje `targetNamespace`, nie można odczytać danych i wyjątków mogą wystąpić podczas wywoływania metody <xref:System.Data.DataSet.ReadXml%2A> załadować <xref:System.Data.DataSet> XML, który zawiera elementy, bez kwalifikacji przestrzeni nazw. Aby odczytać niekwalifikowane elementy, ustaw `elementFormDefault` równa "kwalifikowana" schematów XML, jak pokazano w poniższym przykładzie.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  Jeśli schemat dla Twojego <xref:System.Data.DataSet> zawiera elementy z tej samej nazwy, ale innego typu, w tej samej przestrzeni nazw, jest zgłaszany wyjątek podczas próby odczytu schematu do <xref:System.Data.DataSet> z <xref:System.Data.DataSet.ReadXml%2A> , określając `XmlReadMode.ReadSchema`. Ten wyjątek nie występuje, jeśli używasz .NET Framework w wersji 1.0.  
  
   
  
## Examples  
 Poniższy przykład tworzy najpierw prostą <xref:System.Data.DataSet> z jednym <xref:System.Data.DataTable>, dwóch kolumn i wierszy dziesięć. <xref:System.Data.DataSet> Schemat i dane są zapisywane na dysku, wywołując <xref:System.Data.DataSet.WriteXml%2A> metody. Drugi <xref:System.Data.DataSet> jest tworzony i <xref:System.Data.DataSet.ReadXml%2A> metoda jest używana do wypełnienie schemat i dane.  
  
 [!code-csharp[Classic WebData DataSet.ReadXml1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)" />
        <altmember cref="M:System.Data.DataSet.WriteXml(System.IO.Stream)" />
        <altmember cref="M:System.Data.DataSet.WriteXmlSchema(System.IO.Stream)" />
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.TextReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.TextReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As TextReader) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::TextReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.IO.TextReader -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see langword="TextReader" /> z której mają być odczytywane schemat i dane.</param>
        <summary>Odczytuje XML: schemat i dane do <see cref="T:System.Data.DataSet" /> przy użyciu określonego <see cref="T:System.IO.TextReader" />.</summary>
        <returns>
          <see cref="T:System.Data.XmlReadMode" /> Używany do odczytu danych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.ReadXml%2A> Metoda zapewnia sposób odczytać tylko dane lub zarówno danych i schematu do <xref:System.Data.DataSet> z dokumentu XML, podczas gdy <xref:System.Data.DataSet.ReadXmlSchema%2A> metoda odczytuje tylko schemat. Aby odczytać zarówno danych, jak i schematu, użyj jednej z `ReadXML` przeciążeń, które zawiera `mode` parametru i ustaw dla niego wartość `ReadSchema`.  
  
 Należy pamiętać, że to samo dotyczy dla <xref:System.Data.DataSet.WriteXml%2A> i <xref:System.Data.DataSet.WriteXmlSchema%2A> metod, odpowiednio. Można zapisać danych XML lub schemat i dane z `DataSet`, użyj `WriteXml` metody. Aby zapisać tylko schemat, należy użyć `WriteXmlSchema` metody.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Zostanie wygenerowany, jeśli typ kolumny w `DataRow` trwa od zapisu lub odczytu implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> i nie implementuje <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Jeśli określono schemat w tekście, schematu w wierszu służy do rozszerzania istniejącej struktury relacyjne przed załadowaniem danych. Jeśli występują konflikty (na przykład tej samej kolumny w tej samej tabeli zdefiniowane przy użyciu różnych typów danych) jest wyjątek.  
  
 Jeśli schemat nie-line jest określony, struktura relacyjnej został rozszerzony za pośrednictwem wnioskowania odpowiednio do potrzeb zgodnie ze struktury dokumentu XML. Jeśli schemat nie może zostać rozszerzony za pomocą wnioskowania, aby udostępnić wszystkie dane, jest wyjątek.  
  
> [!NOTE]
>  `DataSet` Nie wiąże — element XML z odpowiadającymi mu dostawcami `DataColumn` lub `DataTable` po prawidłowe znaki XML, takich jak ("_") są anulowane w serializacji XML. `DataSet` Się tylko specjalne niedozwolone znaki XML w nazwach elementów XML i dlatego tylko zajmowane są takie same. Gdy będą miały zmienione znaczenie prawidłowe znaki w nazwie elementu XML, element jest ignorowany podczas przetwarzania.  
  
 Jeśli schemat XML <xref:System.Data.DataSet> obejmuje `targetNamespace`, nie można odczytać danych i wyjątków mogą wystąpić podczas wywoływania metody <xref:System.Data.DataSet.ReadXml%2A> załadować <xref:System.Data.DataSet> XML, który zawiera elementy, bez kwalifikacji przestrzeni nazw. Aby odczytać niekwalifikowane elementy, ustaw `elementFormDefault` równa "kwalifikowana" schematów XML, jak pokazano w poniższym przykładzie.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
 Klasy, które dziedziczą z <xref:System.IO.TextReader> obejmują klasy <xref:System.IO.StreamReader> i <xref:System.IO.StringReader> klasy.  
  
> [!NOTE]
>  Jeśli schemat dla Twojego <xref:System.Data.DataSet> zawiera elementy z tej samej nazwy, ale innego typu, w tej samej przestrzeni nazw, jest zgłaszany wyjątek podczas próby odczytu schematu do <xref:System.Data.DataSet> z <xref:System.Data.DataSet.ReadXml%2A> , określając `XmlReadMode.ReadSchema`. Ten wyjątek nie występuje, jeśli używasz .NET Framework w wersji 1.0.  
  
   
  
## Examples  
 Poniższy przykład tworzy najpierw prostą <xref:System.Data.DataSet> z jednym <xref:System.Data.DataTable>, dwóch kolumn i wierszy dziesięć. <xref:System.Data.DataSet> Schemat i dane są zapisywane na dysku, wywołując <xref:System.Data.DataSet.WriteXml%2A> metody. Drugi <xref:System.Data.DataSet> jest tworzony i <xref:System.Data.DataSet.ReadXml%2A> metoda jest używana do wypełnienie schemat i dane.  
  
 [!code-csharp[Classic WebData DataSet.ReadXml2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (fileName As String) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : string -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nazwa (włącznie ze ścieżką) z której mają być odczytywane.</param>
        <summary>Odczytuje XML: schemat i dane do <see cref="T:System.Data.DataSet" /> przy użyciu określonego pliku.</summary>
        <returns>
          <see langword="XmlReadMode" /> Używany do odczytu danych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.ReadXml%2A> Metoda zapewnia sposób odczytać tylko dane lub zarówno danych i schematu do <xref:System.Data.DataSet> z dokumentu XML, podczas gdy <xref:System.Data.DataSet.ReadXmlSchema%2A> metoda odczytuje tylko schemat. Aby odczytać zarówno danych, jak i schematu, użyj jednej z `ReadXML` przeciążeń, które zawiera `mode` parametru i ustaw dla niego wartość `ReadSchema`.  
  
 Należy pamiętać, że to samo dotyczy dla <xref:System.Data.DataSet.WriteXml%2A> i <xref:System.Data.DataSet.WriteXmlSchema%2A> metod, odpowiednio. Można zapisać danych XML lub schemat i dane z `DataSet`, użyj `WriteXml` metody. Aby zapisać tylko schemat, należy użyć `WriteXmlSchema` metody.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Zostanie wygenerowany, jeśli typ kolumny w `DataRow` trwa od zapisu lub odczytu implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> i nie implementuje <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Jeśli określono schemat w tekście, schematu w wierszu służy do rozszerzania istniejącej struktury relacyjne przed załadowaniem danych. Jeśli występują konflikty (na przykład tej samej kolumny w tej samej tabeli zdefiniowane przy użyciu różnych typów danych) jest wyjątek.  
  
 Jeśli schemat nie-line jest określony, struktura relacyjnej został rozszerzony za pośrednictwem wnioskowania odpowiednio do potrzeb zgodnie ze struktury dokumentu XML. Jeśli schemat nie może zostać rozszerzony za pomocą wnioskowania, aby udostępnić wszystkie dane, jest wyjątek.  
  
> [!NOTE]
>  `DataSet` Nie wiąże — element XML z odpowiadającymi mu dostawcami `DataColumn` lub `DataTable` po prawidłowe znaki XML, takich jak ("_") są anulowane w serializacji XML. `DataSet` Się tylko specjalne niedozwolone znaki XML w nazwach elementów XML i dlatego tylko zajmowane są takie same. Gdy będą miały zmienione znaczenie prawidłowe znaki w nazwie elementu XML, element jest ignorowany podczas przetwarzania.  
  
 Jeśli schemat XML <xref:System.Data.DataSet> obejmuje `targetNamespace`, nie można odczytać danych i wyjątków mogą wystąpić podczas wywoływania metody <xref:System.Data.DataSet.ReadXml%2A> załadować <xref:System.Data.DataSet> XML, który zawiera elementy, bez kwalifikacji przestrzeni nazw. Aby odczytać niekwalifikowane elementy, ustaw `elementFormDefault` równa "kwalifikowana" schematów XML, jak pokazano w poniższym przykładzie.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  Jeśli schemat dla Twojego <xref:System.Data.DataSet> zawiera elementy z tej samej nazwy, ale innego typu, w tej samej przestrzeni nazw, jest zgłaszany wyjątek podczas próby odczytu schematu do <xref:System.Data.DataSet> z <xref:System.Data.DataSet.ReadXml%2A> , określając `XmlReadMode.ReadSchema`. Ten wyjątek nie występuje, jeśli używasz .NET Framework w wersji 1.0.  
  
   
  
## Examples  
 Poniższy przykład tworzy najpierw prostą <xref:System.Data.DataSet> z jednym <xref:System.Data.DataTable>, dwóch kolumn i wierszy dziesięć. <xref:System.Data.DataSet> Schemat i dane są zapisywane na dysku, wywołując <xref:System.Data.DataSet.WriteXml%2A> metody. Drugi <xref:System.Data.DataSet> jest tworzony i <xref:System.Data.DataSet.ReadXml%2A> metoda jest używana do wypełnienie schemat i dane.  
  
 [!code-csharp[Classic WebData DataSet.ReadXml3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <see cref="T:System.Security.Permissions.FileIOPermission" /> Nie ustawiono <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania i zapisywania plików. Wyliczenie skojarzone: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As XmlReader) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.Xml.XmlReader -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Xml.XmlReader" /> z której mają być odczytywane.</param>
        <summary>Odczytuje XML: schemat i dane do <see cref="T:System.Data.DataSet" /> przy użyciu określonego <see cref="T:System.Xml.XmlReader" />.</summary>
        <returns>
          <see langword="XmlReadMode" /> Używany do odczytu danych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.ReadXml%2A> Metoda zapewnia sposób odczytać tylko dane lub zarówno danych i schematu do <xref:System.Data.DataSet> z dokumentu XML, podczas gdy <xref:System.Data.DataSet.ReadXmlSchema%2A> metoda odczytuje tylko schemat. Aby odczytać zarówno danych, jak i schematu, użyj jednej z `ReadXML` przeciążeń, które zawiera `mode` parametru i ustaw dla niego wartość `ReadSchema`.  
  
 Należy pamiętać, że to samo dotyczy dla <xref:System.Data.DataSet.WriteXml%2A> i <xref:System.Data.DataSet.WriteXmlSchema%2A> metod, odpowiednio. Można zapisać danych XML lub schemat i dane z `DataSet`, użyj `WriteXml` metody. Aby zapisać tylko schemat, należy użyć `WriteXmlSchema` metody.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Zostanie wygenerowany, jeśli typ kolumny w `DataRow` trwa od zapisu lub odczytu implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> i nie implementuje <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Jeśli określono schemat w tekście, schematu w wierszu służy do rozszerzania istniejącej struktury relacyjne przed załadowaniem danych. Jeśli występują konflikty (na przykład tej samej kolumny w tej samej tabeli zdefiniowane przy użyciu różnych typów danych) jest wyjątek.  
  
 Jeśli schemat nie-line jest określony, struktura relacyjnej został rozszerzony za pośrednictwem wnioskowania odpowiednio do potrzeb zgodnie ze struktury dokumentu XML. Jeśli schemat nie może zostać rozszerzony za pomocą wnioskowania, aby udostępnić wszystkie dane, jest wyjątek.  
  
> [!NOTE]
>  `DataSet` Nie wiąże — element XML z odpowiadającymi mu dostawcami `DataColumn` lub `DataTable` po prawidłowe znaki XML, takich jak ("_") są anulowane w serializacji XML. `DataSet` Się tylko specjalne niedozwolone znaki XML w nazwach elementów XML i dlatego tylko zajmowane są takie same. Gdy będą miały zmienione znaczenie prawidłowe znaki w nazwie elementu XML, element jest ignorowany podczas przetwarzania.  
  
 Jeśli schemat XML <xref:System.Data.DataSet> obejmuje `targetNamespace`, nie można odczytać danych i wyjątków mogą wystąpić podczas wywoływania metody <xref:System.Data.DataSet.ReadXml%2A> załadować <xref:System.Data.DataSet> XML, który zawiera elementy, bez kwalifikacji przestrzeni nazw. Aby odczytać niekwalifikowane elementy, ustaw `elementFormDefault` równa "kwalifikowana" schematów XML, jak pokazano w poniższym przykładzie.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
 <xref:System.Xml.XmlTextReader?displayProperty=nameWithType> dziedziczy <xref:System.Xml.XmlReader>.  
  
> [!NOTE]
>  Jeśli schemat dla Twojego <xref:System.Data.DataSet> zawiera elementy z tej samej nazwy, ale innego typu, w tej samej przestrzeni nazw, jest zgłaszany wyjątek podczas próby odczytu schematu do <xref:System.Data.DataSet> z <xref:System.Data.DataSet.ReadXml%2A> , określając `XmlReadMode.ReadSchema`. Ten wyjątek nie występuje, jeśli używasz .NET Framework w wersji 1.0.  
  
   
  
## Examples  
 Poniższy przykład tworzy najpierw prostą <xref:System.Data.DataSet> z jednym <xref:System.Data.DataTable>, dwóch kolumn i wierszy dziesięć. <xref:System.Data.DataSet> Schemat i dane są zapisywane na dysku, wywołując <xref:System.Data.DataSet.WriteXml%2A> metody. Drugi <xref:System.Data.DataSet> jest tworzony i <xref:System.Data.DataSet.ReadXml%2A> metoda jest używana do wypełnienie schemat i dane.  
  
 [!code-csharp[Classic WebData DataSet.ReadXml Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.Stream stream, System.Data.XmlReadMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.Stream stream, valuetype System.Data.XmlReadMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.IO.Stream,System.Data.XmlReadMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::Stream ^ stream, System::Data::XmlReadMode mode);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.IO.Stream * System.Data.XmlReadMode -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml (stream, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="mode" Type="System.Data.XmlReadMode" />
      </Parameters>
      <Docs>
        <param name="stream">
          <see cref="T:System.IO.Stream" /> z której mają być odczytywane.</param>
        <param name="mode">Jeden z <see cref="T:System.Data.XmlReadMode" /> wartości.</param>
        <summary>Odczytuje XML: schemat i dane do <see cref="T:System.Data.DataSet" /> przy użyciu określonego <see cref="T:System.IO.Stream" /> i <see cref="T:System.Data.XmlReadMode" />.</summary>
        <returns>
          <see langword="XmlReadMode" /> Używany do odczytu danych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.ReadXml%2A> Metoda zapewnia sposób odczytać tylko dane lub zarówno danych i schematu do <xref:System.Data.DataSet> z dokumentu XML, podczas gdy <xref:System.Data.DataSet.ReadXmlSchema%2A> metoda odczytuje tylko schemat. Aby odczytać zarówno danych, jak i schematu, użyj jednej z `ReadXML` przeciążeń, które zawiera `mode` parametru i ustaw dla niego wartość `ReadSchema`.  
  
 Dotyczy to także <xref:System.Data.DataSet.WriteXml%2A> i <xref:System.Data.DataSet.WriteXmlSchema%2A> metod, odpowiednio. Można zapisać danych XML lub schemat i dane z `DataSet`, użyj `WriteXml` metody. Aby zapisać tylko schemat, należy użyć `WriteXmlSchema` metody.  
  
> [!NOTE]
>  Jeśli używasz <xref:System.Data.DataSet.ReadXml%2A> i <xref:System.Data.XmlReadMode> do `Diffgram`, zawartość elementu docelowego `DataSet` i oryginalny `DataSet` mogą się różnić z powodu jak wygenerowanych i przetwarzane elementu diffgram. Aby uzyskać więcej informacji o DataSets, zobacz [DataSets](~/docs/framework/data/adonet/dataset-datatable-dataview/diffgrams.md).  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Zostanie wygenerowany, jeśli typ kolumny w `DataRow` trwa od zapisu lub odczytu implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> i nie implementuje <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Jeśli określono schemat w tekście, schematu w wierszu służy do rozszerzania istniejącej struktury relacyjne przed załadowaniem danych. Jeśli występują konflikty (na przykład tej samej kolumny w tej samej tabeli zdefiniowane przy użyciu różnych typów danych) jest wyjątek.  
  
 Jeśli schemat nie-line jest określony, struktura relacyjnej został rozszerzony za pośrednictwem wnioskowania odpowiednio do potrzeb zgodnie ze struktury dokumentu XML. Jeśli schemat nie może zostać rozszerzony za pomocą wnioskowania, aby udostępnić wszystkie dane, jest wyjątek.  
  
> [!NOTE]
>  `DataSet` Nie wiąże — element XML z odpowiadającymi mu dostawcami `DataColumn` lub `DataTable` po prawidłowe znaki XML, takich jak ("_") są anulowane w serializacji XML. `DataSet` Się tylko specjalne niedozwolone znaki XML w nazwach elementów XML i dlatego tylko zajmowane są takie same. Gdy będą miały zmienione znaczenie prawidłowe znaki w nazwie elementu XML, element jest ignorowany podczas przetwarzania.  
  
 Jeśli schemat XML <xref:System.Data.DataSet> obejmuje `targetNamespace`, nie można odczytać danych i wyjątków mogą wystąpić podczas wywoływania metody <xref:System.Data.DataSet.ReadXml%2A> załadować <xref:System.Data.DataSet> XML, który zawiera elementy, bez kwalifikacji przestrzeni nazw. Aby odczytać niekwalifikowane elementy, ustaw `elementFormDefault` równa "kwalifikowana" schematów XML, jak pokazano w poniższym przykładzie.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  Jeśli schemat dla Twojego <xref:System.Data.DataSet> zawiera elementy z tej samej nazwy, ale innego typu, w tej samej przestrzeni nazw, jest zgłaszany wyjątek podczas próby odczytu schematu do <xref:System.Data.DataSet> z <xref:System.Data.DataSet.ReadXml%2A> , określając `XmlReadMode.ReadSchema`. Ten wyjątek nie występuje, jeśli używasz .NET Framework w wersji 1.0.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.TextReader reader, System.Data.XmlReadMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.TextReader reader, valuetype System.Data.XmlReadMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.IO.TextReader,System.Data.XmlReadMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As TextReader, mode As XmlReadMode) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::TextReader ^ reader, System::Data::XmlReadMode mode);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.IO.TextReader * System.Data.XmlReadMode -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml (reader, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
        <Parameter Name="mode" Type="System.Data.XmlReadMode" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.IO.TextReader" /> z której mają być odczytywane.</param>
        <param name="mode">Jeden z <see cref="T:System.Data.XmlReadMode" /> wartości.</param>
        <summary>Odczytuje XML: schemat i dane do <see cref="T:System.Data.DataSet" /> przy użyciu określonego <see cref="T:System.IO.TextReader" /> i <see cref="T:System.Data.XmlReadMode" />.</summary>
        <returns>
          <see langword="XmlReadMode" /> Używany do odczytu danych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.ReadXml%2A> Metoda zapewnia sposób odczytać tylko dane lub zarówno danych i schematu do <xref:System.Data.DataSet> z dokumentu XML, podczas gdy <xref:System.Data.DataSet.ReadXmlSchema%2A> metoda odczytuje tylko schemat. Aby odczytać zarówno danych, jak i schematu, użyj jednej z `ReadXML` przeciążeń, które zawiera `mode` parametru i ustaw dla niego wartość `ReadSchema`.  
  
 Należy pamiętać, że to samo dotyczy dla <xref:System.Data.DataSet.WriteXml%2A> i <xref:System.Data.DataSet.WriteXmlSchema%2A> metod, odpowiednio. Można zapisać danych XML lub schemat i dane z `DataSet`, użyj `WriteXml` metody. Aby zapisać tylko schemat, należy użyć `WriteXmlSchema` metody.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Zostanie wygenerowany, jeśli typ kolumny w `DataRow` trwa od zapisu lub odczytu implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> i nie implementuje <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Jeśli określono schemat w tekście, schematu w wierszu służy do rozszerzania istniejącej struktury relacyjne przed załadowaniem danych. Jeśli występują konflikty (na przykład tej samej kolumny w tej samej tabeli zdefiniowane przy użyciu różnych typów danych) jest wyjątek.  
  
 Jeśli schemat nie-line jest określony, struktura relacyjnej został rozszerzony za pośrednictwem wnioskowania odpowiednio do potrzeb zgodnie ze struktury dokumentu XML. Jeśli schemat nie może zostać rozszerzony za pomocą wnioskowania, aby udostępnić wszystkie dane, jest wyjątek.  
  
> [!NOTE]
>  `DataSet` Nie wiąże — element XML z odpowiadającymi mu dostawcami `DataColumn` lub `DataTable` po prawidłowe znaki XML, takich jak ("_") są anulowane w serializacji XML. `DataSet` Się tylko specjalne niedozwolone znaki XML w nazwach elementów XML i dlatego tylko zajmowane są takie same. Gdy będą miały zmienione znaczenie prawidłowe znaki w nazwie elementu XML, element jest ignorowany podczas przetwarzania.  
  
 Jeśli schemat XML <xref:System.Data.DataSet> obejmuje `targetNamespace`, nie można odczytać danych i wyjątków mogą wystąpić podczas wywoływania metody <xref:System.Data.DataSet.ReadXml%2A> załadować <xref:System.Data.DataSet> XML, który zawiera elementy, bez kwalifikacji przestrzeni nazw. Aby odczytać niekwalifikowane elementy, ustaw `elementFormDefault` równa "kwalifikowana" schematów XML, jak pokazano w poniższym przykładzie.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  Jeśli schemat dla Twojego <xref:System.Data.DataSet> zawiera elementy z tej samej nazwy, ale innego typu, w tej samej przestrzeni nazw, jest zgłaszany wyjątek podczas próby odczytu schematu do <xref:System.Data.DataSet> z <xref:System.Data.DataSet.ReadXml%2A> , określając `XmlReadMode.ReadSchema`. Ten wyjątek nie występuje, jeśli używasz .NET Framework w wersji 1.0.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (string fileName, System.Data.XmlReadMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(string fileName, valuetype System.Data.XmlReadMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.String,System.Data.XmlReadMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (fileName As String, mode As XmlReadMode) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::String ^ fileName, System::Data::XmlReadMode mode);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : string * System.Data.XmlReadMode -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml (fileName, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="mode" Type="System.Data.XmlReadMode" />
      </Parameters>
      <Docs>
        <param name="fileName">Nazwa (włącznie ze ścieżką) z której mają być odczytywane.</param>
        <param name="mode">Jeden z <see cref="T:System.Data.XmlReadMode" /> wartości.</param>
        <summary>Odczytuje XML: schemat i dane do <see cref="T:System.Data.DataSet" /> przy użyciu określonego pliku i <see cref="T:System.Data.XmlReadMode" />.</summary>
        <returns>
          <see langword="XmlReadMode" /> Używany do odczytu danych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.ReadXml%2A> Metoda zapewnia sposób odczytać tylko dane lub zarówno danych i schematu do <xref:System.Data.DataSet> z dokumentu XML, podczas gdy <xref:System.Data.DataSet.ReadXmlSchema%2A> metoda odczytuje tylko schemat. Aby odczytać zarówno danych, jak i schematu, użyj jednej z `ReadXML` przeciążeń, które zawiera `mode` parametru i ustaw dla niego wartość `ReadSchema`.  
  
 Należy pamiętać, że to samo dotyczy dla <xref:System.Data.DataSet.WriteXml%2A> i <xref:System.Data.DataSet.WriteXmlSchema%2A> metod, odpowiednio. Można zapisać danych XML lub schemat i dane z `DataSet`, użyj `WriteXml` metody. Aby zapisać tylko schemat, należy użyć `WriteXmlSchema` metody.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Zostanie wygenerowany, jeśli typ kolumny w `DataRow` trwa od zapisu lub odczytu implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> i nie implementuje <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Jeśli określono schemat w tekście, schematu w wierszu służy do rozszerzania istniejącej struktury relacyjne przed załadowaniem danych. Jeśli występują konflikty (na przykład tej samej kolumny w tej samej tabeli zdefiniowane przy użyciu różnych typów danych) jest wyjątek.  
  
 Jeśli schemat nie-line jest określony, struktura relacyjnej został rozszerzony za pośrednictwem wnioskowania odpowiednio do potrzeb zgodnie ze struktury dokumentu XML. Jeśli schemat nie może zostać rozszerzony za pomocą wnioskowania, aby udostępnić wszystkie dane, jest wyjątek.  
  
> [!NOTE]
>  `DataSet` Nie wiąże — element XML z odpowiadającymi mu dostawcami `DataColumn` lub `DataTable` po prawidłowe znaki XML, takich jak ("_") są anulowane w serializacji XML. `DataSet` Się tylko specjalne niedozwolone znaki XML w nazwach elementów XML i dlatego tylko zajmowane są takie same. Gdy będą miały zmienione znaczenie prawidłowe znaki w nazwie elementu XML, element jest ignorowany podczas przetwarzania.  
  
 Jeśli schemat XML <xref:System.Data.DataSet> obejmuje `targetNamespace`, nie można odczytać danych i wyjątków mogą wystąpić podczas wywoływania metody <xref:System.Data.DataSet.ReadXml%2A> załadować <xref:System.Data.DataSet> XML, który zawiera elementy, bez kwalifikacji przestrzeni nazw. Aby odczytać niekwalifikowane elementy, ustaw `elementFormDefault` równa "kwalifikowana" schematów XML, jak pokazano w poniższym przykładzie.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  Jeśli schemat dla Twojego <xref:System.Data.DataSet> zawiera elementy z tej samej nazwy, ale innego typu, w tej samej przestrzeni nazw, jest zgłaszany wyjątek podczas próby odczytu schematu do <xref:System.Data.DataSet> z <xref:System.Data.DataSet.ReadXml%2A> , określając `XmlReadMode.ReadSchema`. Ten wyjątek nie występuje, jeśli używasz .NET Framework w wersji 1.0.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <see cref="T:System.Security.Permissions.FileIOPermission" /> Nie ustawiono <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania i zapisywania plików. Wyliczenie skojarzone: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.Xml.XmlReader reader, System.Data.XmlReadMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.Xml.XmlReader reader, valuetype System.Data.XmlReadMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader,System.Data.XmlReadMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As XmlReader, mode As XmlReadMode) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::Xml::XmlReader ^ reader, System::Data::XmlReadMode mode);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.Xml.XmlReader * System.Data.XmlReadMode -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml (reader, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="mode" Type="System.Data.XmlReadMode" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Xml.XmlReader" /> z której mają być odczytywane.</param>
        <param name="mode">Jeden z <see cref="T:System.Data.XmlReadMode" /> wartości.</param>
        <summary>Odczytuje XML: schemat i dane do <see cref="T:System.Data.DataSet" /> przy użyciu określonego <see cref="T:System.Xml.XmlReader" /> i <see cref="T:System.Data.XmlReadMode" />.</summary>
        <returns>
          <see langword="XmlReadMode" /> Używany do odczytu danych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.ReadXml%2A> Metoda zapewnia sposób odczytać tylko dane lub zarówno danych i schematu do <xref:System.Data.DataSet> z dokumentu XML, podczas gdy <xref:System.Data.DataSet.ReadXmlSchema%2A> metoda odczytuje tylko schemat. Aby odczytać zarówno danych, jak i schematu, użyj jednej z `ReadXML` przeciążeń, które zawiera `mode` parametru i ustaw dla niego wartość `ReadSchema`.  
  
 Należy pamiętać, że to samo dotyczy dla <xref:System.Data.DataSet.WriteXml%2A> i <xref:System.Data.DataSet.WriteXmlSchema%2A> metod, odpowiednio. Można zapisać danych XML lub schemat i dane z `DataSet`, użyj `WriteXml` metody. Aby zapisać tylko schemat, należy użyć `WriteXmlSchema` metody.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Zostanie wygenerowany, jeśli typ kolumny w `DataRow` trwa od zapisu lub odczytu implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> i nie implementuje <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Jeśli określono schemat w tekście, schematu w wierszu służy do rozszerzania istniejącej struktury relacyjne przed załadowaniem danych. Jeśli występują konflikty (na przykład tej samej kolumny w tej samej tabeli zdefiniowane przy użyciu różnych typów danych) jest wyjątek.  
  
 Jeśli schemat nie-line jest określony, struktura relacyjnej został rozszerzony za pośrednictwem wnioskowania odpowiednio do potrzeb zgodnie ze struktury dokumentu XML. Jeśli schemat nie może zostać rozszerzony za pomocą wnioskowania, aby udostępnić wszystkie dane, jest wyjątek.  
  
> [!NOTE]
>  `DataSet` Nie wiąże — element XML z odpowiadającymi mu dostawcami `DataColumn` lub `DataTable` po prawidłowe znaki XML, takich jak ("_") są anulowane w serializacji XML. `DataSet` Się tylko specjalne niedozwolone znaki XML w nazwach elementów XML i dlatego tylko zajmowane są takie same. Gdy będą miały zmienione znaczenie prawidłowe znaki w nazwie elementu XML, element jest ignorowany podczas przetwarzania.  
  
 Jeśli schemat XML <xref:System.Data.DataSet> obejmuje `targetNamespace`, nie można odczytać danych i wyjątków mogą wystąpić podczas wywoływania metody <xref:System.Data.DataSet.ReadXml%2A> załadować <xref:System.Data.DataSet> XML, który zawiera elementy, bez kwalifikacji przestrzeni nazw. Aby odczytać niekwalifikowane elementy, ustaw `elementFormDefault` równa "kwalifikowana" schematów XML, jak pokazano w poniższym przykładzie.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  Jeśli schemat dla Twojego <xref:System.Data.DataSet> zawiera elementy z tej samej nazwy, ale innego typu, w tej samej przestrzeni nazw, jest zgłaszany wyjątek podczas próby odczytu schematu do <xref:System.Data.DataSet> z <xref:System.Data.DataSet.ReadXml%2A> , określając `XmlReadMode.ReadSchema`. Ten wyjątek nie występuje, jeśli używasz .NET Framework w wersji 1.0.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadXmlSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Odczytuje schematu XML w <see cref="T:System.Data.DataSet" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSchema(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : System.IO.Stream -&gt; unit" Usage="dataSet.ReadXmlSchema stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">
          <see cref="T:System.IO.Stream" /> z której mają być odczytywane.</param>
        <summary>Odczytuje schematu XML z określonego <see cref="T:System.IO.Stream" /> do <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Data.DataSet.ReadXmlSchema%2A> metodę w celu utworzenia schematu <xref:System.Data.DataSet>. Schemat zawiera definicji tabeli, relacji i ograniczenia. Aby zapisać schemat dokumentu XML, użyj <xref:System.Data.DataSet.WriteXmlSchema%2A> metody.  
  
 Schemat XML jest zapisywany przy użyciu standardu XSD.  
  
> [!NOTE]
>  Jeśli msdata:DataType i typy xs:type nie są zgodne, może spowodować uszkodzenie danych. Nie zostanie wygenerowany wyjątek.  
  
 <xref:System.Data.DataSet.ReadXmlSchema%2A> Zazwyczaj wywoływana jest metoda przed wywołaniem <xref:System.Data.DataSet.ReadXml%2A> metodę, która jest używany do wypełniania <xref:System.Data.DataSet>.  
  
 Klasy, które pochodzą z <xref:System.IO.Stream> obejmują klasy <xref:System.IO.BufferedStream>, <xref:System.IO.FileStream>, <xref:System.IO.MemoryStream>, i <xref:System.Net.Sockets.NetworkStream>.  
  
> [!NOTE]
>  Jeśli schemat dla Twojego <xref:System.Data.DataSet> zawiera elementy z tej samej nazwy, ale innego typu, w tej samej przestrzeni nazw, jest zwracany wyjątek, podczas próby odczytu schematu do <xref:System.Data.DataSet> z <xref:System.Data.DataSet.ReadXmlSchema%2A>. Ten wyjątek nie występuje, jeśli używasz .NET Framework w wersji 1.0.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.IO.FileStream> do odczytu schematu XML z obiektu, a następnie wywołuje <xref:System.Data.DataSet.ReadXmlSchema%2A> metody z obiektem.  
  
 [!code-csharp[Classic WebData DataSet.ReadXmlSchema1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXmlSchema1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.IO.TextReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.IO.TextReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSchema(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (reader As TextReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::IO::TextReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : System.IO.TextReader -&gt; unit" Usage="dataSet.ReadXmlSchema reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.IO.TextReader" /> z której mają być odczytywane.</param>
        <summary>Odczytuje schematu XML z określonego <see cref="T:System.IO.TextReader" /> do <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Data.DataSet.ReadXmlSchema%2A> metodę w celu utworzenia schematu <xref:System.Data.DataSet>. Schemat zawiera definicji tabeli, relacji i ograniczenia. Aby zapisać schemat dokumentu XML, użyj <xref:System.Data.DataSet.WriteXmlSchema%2A> metody.  
  
 Schemat XML jest zapisywany przy użyciu standardu XSD.  
  
> [!NOTE]
>  Jeśli msdata:DataType i typy xs:type nie są zgodne, może spowodować uszkodzenie danych. Nie zostanie wygenerowany wyjątek.  
  
 <xref:System.Data.DataSet.ReadXmlSchema%2A> Zazwyczaj wywoływana jest metoda przed wywołaniem <xref:System.Data.DataSet.ReadXml%2A> metodę, która jest używany do wypełniania <xref:System.Data.DataSet>.  
  
 Klasy, które dziedziczą z <xref:System.IO.TextReader> obejmują klasy <xref:System.IO.StreamReader> i <xref:System.IO.StringReader> klasy.  
  
> [!NOTE]
>  Jeśli schemat dla Twojego <xref:System.Data.DataSet> zawiera elementy z tej samej nazwy, ale innego typu, w tej samej przestrzeni nazw, jest zwracany wyjątek, podczas próby odczytu schematu do <xref:System.Data.DataSet> z <xref:System.Data.DataSet.ReadXmlSchema%2A>. Ten wyjątek nie występuje, jeśli używasz .NET Framework w wersji 1.0.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.IO.StreamReader> obiekt odczytać schematu z, a następnie wywołuje <xref:System.Data.DataSet.ReadXmlSchema%2A> metody z obiektem.  
  
 [!code-csharp[Classic WebData DataSet.ReadXmlSchema2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXmlSchema2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSchema(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : string -&gt; unit" Usage="dataSet.ReadXmlSchema fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Plik Nazwa (włącznie ze ścieżką), z której mają być odczytywane.</param>
        <summary>Odczytuje schematu XML z określonego pliku do <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Data.DataSet.ReadXmlSchema%2A> metodę w celu utworzenia schematu <xref:System.Data.DataSet>. Schemat zawiera definicji tabeli, relacji i ograniczenia. Aby zapisać schemat dokumentu XML, użyj <xref:System.Data.DataSet.WriteXmlSchema%2A> metody.  
  
 Schemat XML jest zapisywany przy użyciu standardu XSD.  
  
> [!NOTE]
>  Jeśli msdata:DataType i typy xs:type nie są zgodne, może spowodować uszkodzenie danych. Nie zostanie wygenerowany wyjątek.  
  
 <xref:System.Data.DataSet.ReadXmlSchema%2A> Zazwyczaj wywoływana jest metoda przed wywołaniem <xref:System.Data.DataSet.ReadXml%2A> metodę, która jest używany do wypełniania <xref:System.Data.DataSet>.  
  
> [!NOTE]
>  Jeśli schemat dla Twojego <xref:System.Data.DataSet> zawiera elementy z tej samej nazwy, ale innego typu, w tej samej przestrzeni nazw, jest zgłaszany wyjątek podczas próby odczytu schematu do <xref:System.Data.DataSet> z <xref:System.Data.DataSet.ReadXmlSchema%2A>. Ten wyjątek nie występuje, jeśli używasz .NET Framework w wersji 1.0.  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataSet.ReadXmlSchema3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXmlSchema3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <see cref="T:System.Security.Permissions.FileIOPermission" /> Nie ustawiono <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania i zapisywania plików. Wyliczenie skojarzone: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (reader As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : System.Xml.XmlReader -&gt; unit" Usage="dataSet.ReadXmlSchema reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Xml.XmlReader" /> z której mają być odczytywane.</param>
        <summary>Odczytuje schematu XML z określonego <see cref="T:System.Xml.XmlReader" /> do <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Data.DataSet.ReadXmlSchema%2A> metodę w celu utworzenia schematu <xref:System.Data.DataSet>. Schemat zawiera definicji tabeli, relacji i ograniczenia.  
  
 Schemat XML jest zapisywany przy użyciu standardu XSD.  
  
> [!NOTE]
>  Jeśli msdata:DataType i typy xs:type nie są zgodne, może spowodować uszkodzenie danych. Nie zostanie wygenerowany wyjątek.  
  
 <xref:System.Data.DataSet.ReadXmlSchema%2A> Zazwyczaj wywoływana jest metoda przed wywołaniem <xref:System.Data.DataSet.ReadXml%2A> metodę, która jest używany do wypełniania <xref:System.Data.DataSet>.  
  
 <xref:System.Xml.XmlReader?displayProperty=nameWithType> Klasa jest abstrakcyjna. Klasa, która dziedziczy `XmlReader` jest <xref:System.Xml.XmlTextReader?displayProperty=nameWithType> klasy.  
  
> [!NOTE]
>  Jeśli schemat dla Twojego <xref:System.Data.DataSet> zawiera elementy z tej samej nazwy, ale innego typu, w tej samej przestrzeni nazw, jest zwracany wyjątek, podczas próby odczytu schematu do <xref:System.Data.DataSet> z <xref:System.Data.DataSet.ReadXmlSchema%2A>. Ten wyjątek nie występuje, jeśli używasz .NET Framework w wersji 1.0.  
  
   
  
## Examples  
 Poniższy przykład tworzy nowy <xref:System.Data.DataSet> i <xref:System.IO.FileStream?displayProperty=nameWithType> obiektu. <xref:System.IO.FileStream> Obiektów utworzonych za pomocą ścieżki do pliku i nazwa pliku jest używany do tworzenia <xref:System.Xml.XmlTextReader?displayProperty=nameWithType> przekazanego jako argument <xref:System.Data.DataSet.ReadXmlSchema%2A> metody.  
  
 [!code-csharp[Classic WebData DataSet.ReadXmlSchema Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXmlSchema Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSerializable">
      <MemberSignature Language="C#" Value="protected virtual void ReadXmlSerializable (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ReadXmlSerializable(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSerializable(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ReadXmlSerializable (reader As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ReadXmlSerializable(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member ReadXmlSerializable : System.Xml.XmlReader -&gt; unit&#xA;override this.ReadXmlSerializable : System.Xml.XmlReader -&gt; unit" Usage="dataSet.ReadXmlSerializable reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Podany czytnik XML.</param>
        <summary>Ignoruje atrybuty i zwraca pusty zestaw danych.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RejectChanges">
      <MemberSignature Language="C#" Value="public virtual void RejectChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RejectChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.RejectChanges" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RejectChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RejectChanges();" />
      <MemberSignature Language="F#" Value="abstract member RejectChanges : unit -&gt; unit&#xA;override this.RejectChanges : unit -&gt; unit" Usage="dataSet.RejectChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wycofuje wszystkie zmiany wprowadzone do <see cref="T:System.Data.DataSet" /> od czasu jej utworzenia lub od czasu ostatniego <see cref="M:System.Data.DataSet.AcceptChanges" /> została wywołana.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie <xref:System.Data.DataSet.RejectChanges%2A?displayProperty=nameWithType> do wywołania <xref:System.Data.DataTable.RejectChanges%2A?displayProperty=nameWithType> metody na wszystkich <xref:System.Data.DataTable> obiekty zawarte <xref:System.Data.DataSet>.  
  
 <xref:System.Data.DataRow> obiekty zawarte <xref:System.Data.DataSet> każdego można ustawić w trybie edycji przez wywołanie <xref:System.Data.DataRow.BeginEdit%2A?displayProperty=nameWithType> metody. Po wywołaniu <xref:System.Data.DataRow.EndEdit%2A?displayProperty=nameWithType> metody, można odrzucić zmiany wywołując <xref:System.Data.DataTable.RejectChanges%2A?displayProperty=nameWithType> na <xref:System.Data.DataTable> do której <xref:System.Data.DataRow> obiekty należeć.  
  
 Gdy <xref:System.Data.DataTable.RejectChanges%2A?displayProperty=nameWithType> metoda jest wywoływana, wszystkie wiersze nadal w trybie edycji Anuluj ich edycji. Nowe wiersze zostaną usunięte. Zmodyfikowane i usuniętych wierszy wrócić do pierwotnego stanu (`DataRowState.Unchanged`).  
  
 Metoda AcceptChanges i RejectChanges dotyczą tylko <xref:System.Data.DataRow> zmian dotyczących (to znaczy `Add`, `Remove`, `Delete`, i `Modify`). Nie mają zastosowania do schematu lub zmian strukturalnych.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono klasę pochodzącą od <xref:System.Data.DataSet> klasy. <xref:System.Data.DataSet.RejectChanges%2A> Zdarzenie jest wywoływane w obrębie funkcji.  
  
 [!code-csharp[Classic WebData DataSet.RejectChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.RejectChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.RejectChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.RejectChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Relations">
      <MemberSignature Language="C#" Value="public System.Data.DataRelationCollection Relations { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataRelationCollection Relations" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Relations" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Relations As DataRelationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataRelationCollection ^ Relations { System::Data::DataRelationCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Relations : System.Data.DataRelationCollection" Usage="System.Data.DataSet.Relations" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRelationCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobierz kolekcję relacji, które tabele i Zezwól nawigacji z elementu nadrzędnego tabel dla tabel podrzędnych.</summary>
        <value>A <see cref="T:System.Data.DataRelationCollection" /> zawierający kolekcję <see cref="T:System.Data.DataRelation" /> obiektów. Zwracany jest pustą kolekcję, jeśli nie <see cref="T:System.Data.DataRelation" /> istnieją obiekty.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład wyświetla nazwę kolumny wszystkie tabele podrzędne za pośrednictwem <xref:System.Data.DataSet.Relations%2A> właściwości.  
  
 [!code-vb[Classic WebData DataSet.Relations Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Relations Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemotingFormat">
      <MemberSignature Language="C#" Value="public System.Data.SerializationFormat RemotingFormat { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.SerializationFormat RemotingFormat" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.RemotingFormat" />
      <MemberSignature Language="VB.NET" Value="Public Property RemotingFormat As SerializationFormat" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::SerializationFormat RemotingFormat { System::Data::SerializationFormat get(); void set(System::Data::SerializationFormat value); };" />
      <MemberSignature Language="F#" Value="member this.RemotingFormat : System.Data.SerializationFormat with get, set" Usage="System.Data.DataSet.RemotingFormat" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.SerializationFormat</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Data.SerializationFormat" /> dla <see cref="T:System.Data.DataSet" /> używane podczas komunikacji zdalnej.</summary>
        <value>A <see cref="T:System.Data.SerializationFormat" /> obiektu.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public virtual void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberSignature Language="F#" Value="abstract member Reset : unit -&gt; unit&#xA;override this.Reset : unit -&gt; unit" Usage="dataSet.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Czyści wszystkie tabele i usuwa wszystkie relacje, ograniczeń obcego i tabel z <see cref="T:System.Data.DataSet" />. Podklasy powinny zastępować <see cref="M:System.Data.DataSet.Reset" /> do przywrócenia <see cref="T:System.Data.DataSet" /> do stanu pierwotnego.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SchemaSerializationMode">
      <MemberSignature Language="C#" Value="public virtual System.Data.SchemaSerializationMode SchemaSerializationMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.SchemaSerializationMode SchemaSerializationMode" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.SchemaSerializationMode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property SchemaSerializationMode As SchemaSerializationMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Data::SchemaSerializationMode SchemaSerializationMode { System::Data::SchemaSerializationMode get(); void set(System::Data::SchemaSerializationMode value); };" />
      <MemberSignature Language="F#" Value="member this.SchemaSerializationMode : System.Data.SchemaSerializationMode with get, set" Usage="System.Data.DataSet.SchemaSerializationMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.SchemaSerializationMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Data.SchemaSerializationMode" /> dla <see cref="T:System.Data.DataSet" />.</summary>
        <value>Pobiera lub ustawia <see cref="T:System.Data.SchemaSerializationMode" /> dla <see cref="T:System.Data.DataSet" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Data.DataSet> serializuje dane schematu i wystąpienia domyślnie w usługach sieci Web i scenariusze komunikacji zdalnej. Ustawienie <xref:System.Data.DataSet.SchemaSerializationMode%2A> właściwość typu `DataSet` do <xref:System.Data.SchemaSerializationMode.ExcludeSchema> powoduje, że informacje o schemacie mają być wykluczone z ładunku serializacji.  
  
 <xref:System.Data.SchemaSerializationMode.ExcludeSchema> jest obsługiwana tylko dla typu `DataSet`. Aby uzyskać wyrażeniami bez typu `DataSet` tej właściwości można ustawić tylko <xref:System.Data.SchemaSerializationMode.IncludeSchema>.  
  
 <xref:System.Data.SchemaSerializationMode.ExcludeSchema> należy używać tylko w przypadkach, gdy wpisany informacji o schemacie podstawowych `DataTables`, `DataRelations` i `Constraints` nie został zmodyfikowany. Jeśli zmiany informacji o schemacie wystąpił, pełną powinny być serializowane z <xref:System.Data.SchemaSerializationMode.IncludeSchema>.  
  
 <xref:System.Data.SchemaSerializationMode.ExcludeSchema> jest obsługiwana w wersji 2.0, .NET Framework lub nowszej.  
  
 Gdy <xref:System.Data.SchemaSerializationMode.ExcludeSchema> ustawiono tylko najwyższego poziomu czasu wykonywania właściwości na <xref:System.Data.DataSet> są serializowane. Ponadto są one serializowane tylko wtedy, gdy wystąpią różni się od wartości domyślne. Żadna z `Tables`, `Relations` lub `Constraints` są serializowane. Właściwości serializacji środowiska uruchomieniowego obejmują <xref:System.Data.DataSet.DataSetName%2A>, <xref:System.Data.DataSet.Namespace%2A>, <xref:System.Data.DataSet.Prefix%2A>, <xref:System.Data.DataSet.Locale%2A>, <xref:System.Data.DataSet.EnforceConstraints%2A>, i <xref:System.Data.DataSet.CaseSensitive%2A>. Te właściwości są serializowane, aby upewnić się, że runtime ogólną integralność danych jest zachowywana.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeRelations">
      <MemberSignature Language="C#" Value="protected virtual bool ShouldSerializeRelations ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ShouldSerializeRelations() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ShouldSerializeRelations" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ShouldSerializeRelations () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ShouldSerializeRelations();" />
      <MemberSignature Language="F#" Value="abstract member ShouldSerializeRelations : unit -&gt; bool&#xA;override this.ShouldSerializeRelations : unit -&gt; bool" Usage="dataSet.ShouldSerializeRelations " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="P:System.Data.DataSet.Relations" /> powinien zostać utrwalony właściwości.</summary>
        <returns>
          <see langword="true" /> Jeśli wartość właściwości została zmieniona z domyślnego; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwykle ta metoda albo w przypadku tworzenia projektanta dla <xref:System.Data.DataSet>, lub tworzenia własnych Dołączanie formantu <xref:System.Data.DataSet>.  
  
   
  
## Examples  
 W poniższych przykładach pokazano klasę pochodzącą od <xref:System.Data.DataSet> klasy. <xref:System.Data.DataSet.Reset%2A> i <xref:System.Data.DataSet.ShouldSerializeRelations%2A> metody są wywoływane w obrębie funkcji w klasie pochodnej.  
  
 [!code-csharp[Classic WebData DataSet.ShouldSerializeRelations Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ShouldSerializeRelations Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ShouldSerializeRelations Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ShouldSerializeRelations Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTables">
      <MemberSignature Language="C#" Value="protected virtual bool ShouldSerializeTables ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ShouldSerializeTables() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ShouldSerializeTables" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ShouldSerializeTables () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ShouldSerializeTables();" />
      <MemberSignature Language="F#" Value="abstract member ShouldSerializeTables : unit -&gt; bool&#xA;override this.ShouldSerializeTables : unit -&gt; bool" Usage="dataSet.ShouldSerializeTables " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="P:System.Data.DataSet.Tables" /> powinien zostać utrwalony właściwości.</summary>
        <returns>
          <see langword="true" /> Jeśli wartość właściwości została zmieniona z domyślnego; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwykle ta metoda tylko wtedy, gdy tworzysz albo projektanta dla <xref:System.Data.DataSet>, lub tworzenia własnych Dołączanie formantu <xref:System.Data.DataSet>.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono klasę pochodzącą od <xref:System.Data.DataSet> klasy. <xref:System.Data.DataSet.ShouldSerializeTables%2A> Metoda jest wywoływana z wewnątrz funkcji w klasie pochodnej.  
  
 [!code-csharp[Classic WebData DataSet.ShouldSerializeTables Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ShouldSerializeTables Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ShouldSerializeTables Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ShouldSerializeTables Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Site" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Site : System.ComponentModel.ISite with get, set" Usage="System.Data.DataSet.Site" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.ComponentModel.ISite" /> dla <see cref="T:System.Data.DataSet" />.</summary>
        <value>
          <see cref="T:System.ComponentModel.ISite" /> Dla <see cref="T:System.Data.DataSet" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Powiązania witryny <xref:System.ComponentModel.Component> do <xref:System.ComponentModel.Container> i umożliwić komunikację między nimi, a także umożliwiają kontener, aby zarządzać jego składniki.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.ContainsListCollection">
      <MemberSignature Language="C#" Value="bool System.ComponentModel.IListSource.ContainsListCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.ComponentModel.IListSource.ContainsListCollection" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.System#ComponentModel#IListSource#ContainsListCollection" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ContainsListCollection As Boolean Implements IListSource.ContainsListCollection" />
      <MemberSignature Language="C++ CLI" Value="property bool System.ComponentModel.IListSource.ContainsListCollection { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Data.DataSet.System.ComponentModel.IListSource.ContainsListCollection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="P:System.ComponentModel.IListSource.ContainsListCollection" />.</summary>
        <value>Opis tego elementu członkowskiego, zobacz <see cref="P:System.ComponentModel.IListSource.ContainsListCollection" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Data.DataSet> wystąpienia jest rzutowane na <xref:System.ComponentModel.IListSource> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.GetList">
      <MemberSignature Language="C#" Value="System.Collections.IList IListSource.GetList ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IList System.ComponentModel.IListSource.GetList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.System#ComponentModel#IListSource#GetList" />
      <MemberSignature Language="VB.NET" Value="Function GetList () As IList Implements IListSource.GetList" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IList ^ System.ComponentModel.IListSource.GetList() = System::ComponentModel::IListSource::GetList;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="M:System.ComponentModel.IListSource.GetList" />.</summary>
        <returns>Opis tego elementu członkowskiego, zobacz <see cref="M:System.ComponentModel.IListSource.GetList" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Data.DataSet> wystąpienia jest rzutowane na <xref:System.ComponentModel.IListSource> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.GetSchema">
      <MemberSignature Language="C#" Value="System.Xml.Schema.XmlSchema IXmlSerializable.GetSchema ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Xml.Schema.XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#GetSchema" />
      <MemberSignature Language="VB.NET" Value="Function GetSchema () As XmlSchema Implements IXmlSerializable.GetSchema" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Xml::Schema::XmlSchema ^ System.Xml.Serialization.IXmlSerializable.GetSchema() = System::Xml::Serialization::IXmlSerializable::GetSchema;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.GetSchema</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchema</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" />.</summary>
        <returns>Opis tego elementu członkowskiego, zobacz <see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Data.DataSet> wystąpienia jest rzutowane na <xref:System.Xml.Serialization.IXmlSerializable> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.ReadXml">
      <MemberSignature Language="C#" Value="void IXmlSerializable.ReadXml (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Xml.Serialization.IXmlSerializable.ReadXml(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Sub ReadXml (reader As XmlReader) Implements IXmlSerializable.ReadXml" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Xml.Serialization.IXmlSerializable.ReadXml(System::Xml::XmlReader ^ reader) = System::Xml::Serialization::IXmlSerializable::ReadXml;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">A <see cref="T:System.Xml.XmlReader" />.</param>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Data.DataSet> wystąpienia jest rzutowane na <xref:System.Xml.Serialization.IXmlSerializable> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.WriteXml">
      <MemberSignature Language="C#" Value="void IXmlSerializable.WriteXml (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Xml.Serialization.IXmlSerializable.WriteXml(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Sub WriteXml (writer As XmlWriter) Implements IXmlSerializable.WriteXml" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Xml.Serialization.IXmlSerializable.WriteXml(System::Xml::XmlWriter ^ writer) = System::Xml::Serialization::IXmlSerializable::WriteXml;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">A <see cref="T:System.Xml.XmlWriter" />.</param>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Data.DataSet> wystąpienia jest rzutowane na <xref:System.Xml.Serialization.IXmlSerializable> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tables">
      <MemberSignature Language="C#" Value="public System.Data.DataTableCollection Tables { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataTableCollection Tables" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Tables" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Tables As DataTableCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataTableCollection ^ Tables { System::Data::DataTableCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Tables : System.Data.DataTableCollection" Usage="System.Data.DataSet.Tables" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataTableCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję w tabelach zawartych w <see cref="T:System.Data.DataSet" />.</summary>
        <value>
          <see cref="T:System.Data.DataTableCollection" /> Zawarty w tym <see cref="T:System.Data.DataSet" />. Zwracany jest pustą kolekcję, jeśli nie <see cref="T:System.Data.DataTable" /> istnieją obiekty.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby dodać tabele do kolekcji, użyj <xref:System.Data.DataTableCollection.Add%2A> metody <xref:System.Data.DataTableCollection>. Aby usunąć tabel, użyj <xref:System.Data.DataTableCollection.Remove%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład zwraca <xref:System.Data.DataSet> obiektu <xref:System.Data.DataTableCollection>i wyświetla kolumnami i wierszami w każdej tabeli.  
  
 [!code-csharp[Classic WebData DataSet.Tables Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Tables Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Tables Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Tables Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteXml">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapisuje dane XML i opcjonalnie schematu z <see cref="T:System.Data.DataSet" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.Stream -&gt; unit" Usage="dataSet.WriteXml stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">A <see cref="T:System.IO.Stream" /> obiekt używany do zapisywania do pliku.</param>
        <summary>Zapisuje bieżące dane dla <see cref="T:System.Data.DataSet" /> przy użyciu określonego <see cref="T:System.IO.Stream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `WriteXml` Metoda zapewnia sposób można zapisać tylko dane lub zarówno danych i schemat z <xref:System.Data.DataSet> do dokumentu XML, podczas gdy <xref:System.Data.DataSet.WriteXmlSchema%2A> metoda zapisuje tylko schemat. Aby napisać zarówno danych, jak i schematu, użyj jednego z przeciążeń, które obejmuje `mode` parametru i ustaw dla niego wartość `WriteSchema`.  
  
 Należy pamiętać, że to samo dotyczy dla <xref:System.Data.DataSet.ReadXml%2A> i <xref:System.Data.DataSet.ReadXmlSchema%2A> metod, odpowiednio. Mają być odczytywane dane XML lub schemat i dane do `DataSet`, użyj `ReadXml` metody. Aby odczytać tylko schemat, należy użyć `ReadXmlSchema` metody.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Zostanie wygenerowany, jeśli typ kolumny w `DataRow` trwa od zapisu lub odczytu implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> i nie implementuje <xref:System.Xml.Serialization.IXmlSerializable>.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.IO.FileStream?displayProperty=nameWithType> obiektu. Obiekt jest następnie używana <xref:System.Data.DataSet.WriteXml%2A> metodę, aby zapisać dokument XML.  
  
 [!code-csharp[Classic WebData DataSet.WriteXml Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXml Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.TextWriter -&gt; unit" Usage="dataSet.WriteXml writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.IO.TextWriter" /> Obiektu z jakim zostanie zapisane.</param>
        <summary>Zapisuje bieżące dane dla <see cref="T:System.Data.DataSet" /> przy użyciu określonego <see cref="T:System.IO.TextWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `WriteXml` Metoda zapewnia sposób można zapisać tylko dane lub zarówno danych i schemat z <xref:System.Data.DataSet> do dokumentu XML, podczas gdy <xref:System.Data.DataSet.WriteXmlSchema%2A> metoda zapisuje tylko schemat. Aby napisać zarówno danych, jak i schematu, użyj jednego z przeciążeń, które obejmuje `mode` parametru i ustaw dla niego wartość `WriteSchema`.  
  
 Należy pamiętać, że to samo dotyczy dla <xref:System.Data.DataSet.ReadXml%2A> i <xref:System.Data.DataSet.ReadXmlSchema%2A> metod, odpowiednio. Mają być odczytywane dane XML lub schemat i dane do `DataSet`, użyj `ReadXml` metody. Aby odczytać tylko schemat, należy użyć `ReadXmlSchema` metody.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Zostanie wygenerowany, jeśli typ kolumny w `DataRow` trwa od zapisu lub odczytu implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> i nie implementuje <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : string -&gt; unit" Usage="dataSet.WriteXml fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Plik Nazwa (włącznie ze ścieżką), z którym chcesz zapisać.</param>
        <summary>Zapisuje bieżące dane dla <see cref="T:System.Data.DataSet" /> do określonego pliku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `WriteXml` Metoda zapewnia sposób można zapisać tylko dane lub zarówno danych i schemat z <xref:System.Data.DataSet> do dokumentu XML, podczas gdy <xref:System.Data.DataSet.WriteXmlSchema%2A> metoda zapisuje tylko schemat. Aby napisać zarówno danych, jak i schematu, użyj jednego z przeciążeń, które obejmuje `mode` parametru i ustaw dla niego wartość `WriteSchema`.  
  
 Należy pamiętać, że to samo dotyczy dla <xref:System.Data.DataSet.ReadXml%2A> i <xref:System.Data.DataSet.ReadXmlSchema%2A> metod, odpowiednio. Mają być odczytywane dane XML lub schemat i dane do `DataSet`, użyj `ReadXml` metody. Aby odczytać tylko schemat, należy użyć `ReadXmlSchema` metody.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Zostanie wygenerowany, jeśli typ kolumny w `DataRow` trwa od zapisu lub odczytu implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> i nie implementuje <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <see cref="T:System.Security.Permissions.FileIOPermission" /> Nie ustawiono <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania i zapisywania plików. Wyliczenie skojarzone: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.Xml.XmlWriter -&gt; unit" Usage="dataSet.WriteXml writer" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.Xml.XmlWriter" /> z jakim zostanie zapisane.</param>
        <summary>Zapisuje bieżące dane dla <see cref="T:System.Data.DataSet" /> do określonego <see cref="T:System.Xml.XmlWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `WriteXml` Metoda zapewnia sposób można zapisać tylko dane lub zarówno danych i schemat z <xref:System.Data.DataSet> do dokumentu XML, podczas gdy <xref:System.Data.DataSet.WriteXmlSchema%2A> metoda zapisuje tylko schemat. Aby napisać zarówno danych, jak i schematu, użyj jednego z przeciążeń, które obejmuje `mode` parametru i ustaw dla niego wartość `WriteSchema`.  
  
 Należy pamiętać, że to samo dotyczy dla <xref:System.Data.DataSet.ReadXml%2A> i <xref:System.Data.DataSet.ReadXmlSchema%2A> metod, odpowiednio. Mają być odczytywane dane XML lub schemat i dane do `DataSet`, użyj `ReadXml` metody. Aby odczytać tylko schemat, należy użyć `ReadXmlSchema` metody.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Zostanie wygenerowany, jeśli typ kolumny w `DataRow` trwa od zapisu lub odczytu implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> i nie implementuje <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.Stream * System.Data.XmlWriteMode -&gt; unit" Usage="dataSet.WriteXml (stream, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="stream">A <see cref="T:System.IO.Stream" /> obiekt używany do zapisywania do pliku.</param>
        <param name="mode">Jeden z <see cref="T:System.Data.XmlWriteMode" /> wartości.</param>
        <summary>Zapisuje bieżące dane i opcjonalnie schematu dla <see cref="T:System.Data.DataSet" /> przy użyciu określonego <see cref="T:System.IO.Stream" /> i <see cref="T:System.Data.XmlWriteMode" />. Aby napisać schemat, należy ustawić wartość <paramref name="mode" /> parametr <see langword="WriteSchema" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `WriteXml` Metoda zapewnia sposób można zapisać tylko dane lub zarówno danych i schemat z <xref:System.Data.DataSet> do dokumentu XML, podczas gdy <xref:System.Data.DataSet.WriteXmlSchema%2A> metoda zapisuje tylko schemat. Aby napisać zarówno dane i schemat, należy ustawić `mode` parametr `WriteSchema`.  
  
 Należy pamiętać, że to samo dotyczy dla <xref:System.Data.DataSet.ReadXml%2A> i <xref:System.Data.DataSet.ReadXmlSchema%2A> metod, odpowiednio. Mają być odczytywane dane XML lub schemat i dane do `DataSet`, użyj `ReadXml` metody. Aby odczytać tylko schemat, należy użyć `ReadXmlSchema` metody.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Zostanie wygenerowany, jeśli typ kolumny w `DataRow` trwa od zapisu lub odczytu implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> i nie implementuje <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.TextWriter * System.Data.XmlWriteMode -&gt; unit" Usage="dataSet.WriteXml (writer, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="writer">A <see cref="T:System.IO.TextWriter" /> obiekt używany do zapisywania dokumentu.</param>
        <param name="mode">Jeden z <see cref="T:System.Data.XmlWriteMode" /> wartości.</param>
        <summary>Zapisuje bieżące dane i opcjonalnie schematu dla <see cref="T:System.Data.DataSet" /> przy użyciu określonego <see cref="T:System.IO.TextWriter" /> i <see cref="T:System.Data.XmlWriteMode" />. Aby napisać schemat, należy ustawić wartość <paramref name="mode" /> parametr <see langword="WriteSchema" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `WriteXml` Metoda zapewnia sposób można zapisać tylko dane lub zarówno danych i schemat z <xref:System.Data.DataSet> do dokumentu XML, podczas gdy <xref:System.Data.DataSet.WriteXmlSchema%2A> metoda zapisuje tylko schemat. Aby napisać zarówno dane i schemat, należy ustawić `mode` parametr `WriteSchema`.  
  
 Należy pamiętać, że to samo dotyczy dla <xref:System.Data.DataSet.ReadXml%2A> i <xref:System.Data.DataSet.ReadXmlSchema%2A> metod, odpowiednio. Mają być odczytywane dane XML lub schemat i dane do `DataSet`, użyj `ReadXml` metody. Aby odczytać tylko schemat, należy użyć `ReadXmlSchema` metody.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Zostanie wygenerowany, jeśli typ kolumny w `DataRow` trwa od zapisu lub odczytu implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> i nie implementuje <xref:System.Xml.Serialization.IXmlSerializable>.  
  
   
  
## Examples  
 Poniższy przykład tworzy najpierw prostą <xref:System.Data.DataSet> z jednym <xref:System.Data.DataTable>, dwóch kolumn i wierszy dziesięć. <xref:System.Data.DataSet> Schemat i dane są zapisywane na dysku, wywołując <xref:System.Data.DataSet.WriteXml%2A> metody. Drugi <xref:System.Data.DataSet> jest tworzony i <xref:System.Data.DataSet.ReadXml%2A> metoda jest używana do wypełnienie schemat i dane.  
  
 [!code-csharp[Classic WebData DataSet.ReadXml2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.String,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : string * System.Data.XmlWriteMode -&gt; unit" Usage="dataSet.WriteXml (fileName, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="fileName">Plik Nazwa (włącznie ze ścieżką), z którym chcesz zapisać.</param>
        <param name="mode">Jeden z <see cref="T:System.Data.XmlWriteMode" /> wartości.</param>
        <summary>Zapisuje bieżące dane i opcjonalnie schematu dla <see cref="T:System.Data.DataSet" /> do określonego pliku przy użyciu określonego <see cref="T:System.Data.XmlWriteMode" />. Aby napisać schemat, należy ustawić wartość <paramref name="mode" /> parametr <see langword="WriteSchema" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `WriteXml` Metoda zapewnia sposób można zapisać tylko dane lub zarówno danych i schemat z <xref:System.Data.DataSet> do dokumentu XML, podczas gdy <xref:System.Data.DataSet.WriteXmlSchema%2A> metoda zapisuje tylko schemat. Aby napisać zarówno dane i schemat, należy ustawić `mode` parametr `WriteSchema`.  
  
 Należy pamiętać, że to samo dotyczy dla <xref:System.Data.DataSet.ReadXml%2A> i <xref:System.Data.DataSet.ReadXmlSchema%2A> metod, odpowiednio. Mają być odczytywane dane XML lub schemat i dane do `DataSet`, użyj `ReadXml` metody. Aby odczytać tylko schemat, należy użyć `ReadXmlSchema` metody.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Zostanie wygenerowany, jeśli typ kolumny w `DataRow` trwa od zapisu lub odczytu implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> i nie implementuje <xref:System.Xml.Serialization.IXmlSerializable>.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Data.DataSet.WriteXml%2A> metodę, aby zapisać dokument XML.  
  
 [!code-csharp[Classic WebData DataSet.WriteXml7 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml7 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXml7 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml7 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <see cref="T:System.Security.Permissions.FileIOPermission" /> Nie ustawiono <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania i zapisywania plików. Wyliczenie skojarzone: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.Xml.XmlWriter * System.Data.XmlWriteMode -&gt; unit" Usage="dataSet.WriteXml (writer, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.Xml.XmlWriter" /> z jakim zostanie zapisane.</param>
        <param name="mode">Jeden z <see cref="T:System.Data.XmlWriteMode" /> wartości.</param>
        <summary>Zapisuje bieżące dane i opcjonalnie schematu dla <see cref="T:System.Data.DataSet" /> przy użyciu określonego <see cref="T:System.Xml.XmlWriter" /> i <see cref="T:System.Data.XmlWriteMode" />. Aby napisać schemat, należy ustawić wartość <paramref name="mode" /> parametr <see langword="WriteSchema" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `WriteXml` Metoda zapewnia sposób można zapisać tylko dane lub zarówno danych i schemat z <xref:System.Data.DataSet> do dokumentu XML, podczas gdy <xref:System.Data.DataSet.WriteXmlSchema%2A> metoda zapisuje tylko schemat. Aby napisać zarówno dane i schemat, należy ustawić `mode` parametr `WriteSchema`.  
  
 Należy pamiętać, że to samo dotyczy dla <xref:System.Data.DataSet.ReadXml%2A> i <xref:System.Data.DataSet.ReadXmlSchema%2A> metod, odpowiednio. Mają być odczytywane dane XML lub schemat i dane do `DataSet`, użyj `ReadXml` metody. Aby odczytać tylko schemat, należy użyć `ReadXmlSchema` metody.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Zostanie wygenerowany, jeśli typ kolumny w `DataRow` trwa od zapisu lub odczytu implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> i nie implementuje <xref:System.Xml.Serialization.IXmlSerializable>.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.IO.FileStream?displayProperty=nameWithType> obiekt, który służy do tworzenia nowego <xref:System.Xml.XmlTextWriter>. <xref:System.Xml.XmlTextWriter> Obiekt jest używany z <xref:System.Data.DataSet.WriteXml%2A> metodę, aby zapisać dokument XML.  
  
 [!code-csharp[Classic WebData DataSet.WriteXml6 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml6 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXml6 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml6 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteXmlSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapisuje <see cref="T:System.Data.DataSet" /> struktury jako schematu XML.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.Stream -&gt; unit" Usage="dataSet.WriteXmlSchema stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">A <see cref="T:System.IO.Stream" /> obiekt używany do zapisywania do pliku.</param>
        <summary>Zapisuje <see cref="T:System.Data.DataSet" /> struktury jako schematu XML do określonego <see cref="T:System.IO.Stream" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Data.DataSet.WriteXmlSchema%2A> metodę, aby zapisać schematu <xref:System.Data.DataSet> do dokumentu XML. Schemat zawiera definicji tabeli, relacji i ograniczenia. Aby zapisać schemat dokumentu XML, użyj <xref:System.Data.DataSet.WriteXmlSchema%2A> metody.  
  
 Schemat XML jest zapisywany przy użyciu standardu XSD.  
  
 Aby zapisać dane dokumentu XML, użyj <xref:System.Data.DataSet.WriteXml%2A> metody.  
  
 Klasy, które pochodzą z <xref:System.IO.Stream> obejmują klasy <xref:System.IO.BufferedStream>, <xref:System.IO.FileStream>, <xref:System.IO.MemoryStream>, i <xref:System.Net.Sockets.NetworkStream>.  
  
   
  
## Examples  
 Poniższy przykład tworzy nowy <xref:System.IO.FileStream> obiekt, który jest przekazywany do <xref:System.Data.DataSet.WriteXmlSchema%2A> metodę, aby zapisać schematu na dysku.  
  
 [!code-csharp[Classic WebData DataSet.WriteXmlSchema Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXmlSchema Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.TextWriter -&gt; unit" Usage="dataSet.WriteXmlSchema writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.IO.TextWriter" /> Obiektu z jakim zostanie zapisane.</param>
        <summary>Zapisuje <see cref="T:System.Data.DataSet" /> struktury jako schematu XML do określonego <see cref="T:System.IO.TextWriter" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Data.DataSet.WriteXmlSchema%2A> metodę, aby zapisać schematu <xref:System.Data.DataSet> do dokumentu XML. Schemat zawiera definicji tabeli, relacji i ograniczenia. Aby zapisać schemat dokumentu XML, użyj <xref:System.Data.DataSet.WriteXmlSchema%2A> metody.  
  
 Schemat XML jest zapisywany przy użyciu standardu XSD.  
  
 Aby zapisać dane dokumentu XML, użyj <xref:System.Data.DataSet.WriteXml%2A> metody.  
  
 Klasy pochodną od <xref:System.IO.TextWriter?displayProperty=nameWithType> obejmują klasy <xref:System.Web.HttpWriter?displayProperty=nameWithType>, <xref:System.CodeDom.Compiler.IndentedTextWriter?displayProperty=nameWithType>, <xref:System.Web.UI.HtmlTextWriter?displayProperty=nameWithType>, <xref:System.IO.StreamWriter?displayProperty=nameWithType>, i <xref:System.IO.StringWriter?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Text.StringBuilder?displayProperty=nameWithType> obiekt, który jest używany do tworzenia nowego <xref:System.IO.StringWriter?displayProperty=nameWithType>. <xref:System.IO.StringWriter> Jest przekazywana do <xref:System.Data.DataSet.WriteXmlSchema%2A> — metoda i wynikowy ciąg jest wypisywane w oknie konsoli.  
  
 [!code-csharp[Classic WebData DataSet.WriteXmlSchema1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXmlSchema1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : string -&gt; unit" Usage="dataSet.WriteXmlSchema fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Plik Nazwa (włącznie ze ścieżką), z którym chcesz zapisać.</param>
        <summary>Zapisuje <see cref="T:System.Data.DataSet" /> struktury jako schematu XML w pliku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Data.DataSet.WriteXmlSchema%2A> metodę, aby zapisać schematu <xref:System.Data.DataSet> do dokumentu XML. Schemat zawiera definicji tabeli, relacji i ograniczenia. Aby zapisać schemat dokumentu XML, użyj <xref:System.Data.DataSet.WriteXmlSchema%2A> metody.  
  
 Schemat XML jest zapisywany przy użyciu standardu XSD.  
  
 Aby zapisać dane dokumentu XML, użyj <xref:System.Data.DataSet.WriteXml%2A> metody.  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataSet.WriteXmlSchema3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXmlSchema3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <see cref="T:System.Security.Permissions.FileIOPermission" /> Nie ustawiono <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania i zapisywania plików. Wyliczenie skojarzone: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.Xml.XmlWriter -&gt; unit" Usage="dataSet.WriteXmlSchema writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.Xml.XmlWriter" /> Do zapisu.</param>
        <summary>Zapisuje <see cref="T:System.Data.DataSet" /> struktury jako schematu XML do <see cref="T:System.Xml.XmlWriter" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Data.DataSet.WriteXmlSchema%2A> metodę, aby zapisać schematu <xref:System.Data.DataSet> do dokumentu XML. Schemat zawiera definicji tabeli, relacji i ograniczenia. Aby zapisać schemat dokumentu XML, użyj <xref:System.Data.DataSet.WriteXmlSchema%2A> metody.  
  
 Schemat XML jest zapisywany przy użyciu standardu XSD.  
  
 Aby zapisać dane dokumentu XML, użyj <xref:System.Data.DataSet.WriteXml%2A> metody.  
  
 Jedna klasa, która dziedziczy <xref:System.Xml.XmlWriter?displayProperty=nameWithType> jest klasa <xref:System.Xml.XmlTextWriter> klasy.  
  
   
  
## Examples  
 Poniższy przykład tworzy nową <xref:System.IO.FileStream?displayProperty=nameWithType> obiektu z określoną ścieżką. <xref:System.IO.FileStream> Obiekt jest używany do tworzenia <xref:System.Xml.XmlTextWriter> obiektu. <xref:System.Data.DataSet.WriteXmlSchema%2A> Następnie wywoływana jest metoda o <xref:System.Xml.XmlTextWriter> obiektu do zapisania schematu na dysku.  
  
 [!code-csharp[Classic WebData DataSet.WriteXmlSchema2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXmlSchema2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.Stream stream, Converter&lt;Type,string&gt; multipleTargetConverter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.Stream stream, class System.Converter`2&lt;class System.Type, string&gt; multipleTargetConverter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.IO.Stream,System.Converter{System.Type,System.String})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::Stream ^ stream, Converter&lt;Type ^, System::String ^&gt; ^ multipleTargetConverter);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.Stream * Converter&lt;Type, string&gt; -&gt; unit" Usage="dataSet.WriteXmlSchema (stream, multipleTargetConverter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="multipleTargetConverter" Type="System.Converter&lt;System.Type,System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="stream">A <see cref="T:System.IO.Stream" /> obiektu do zapisu.</param>
        <param name="multipleTargetConverter">Delegat służący do konwertowania <see cref="T:System.Type" /> na ciąg.</param>
        <summary>Zapisuje <see cref="T:System.Data.DataSet" /> struktury jako schematu XML do określonego <see cref="T:System.IO.Stream" /> obiektu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.TextWriter writer, Converter&lt;Type,string&gt; multipleTargetConverter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.TextWriter writer, class System.Converter`2&lt;class System.Type, string&gt; multipleTargetConverter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.IO.TextWriter,System.Converter{System.Type,System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As TextWriter, multipleTargetConverter As Converter(Of Type, String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::TextWriter ^ writer, Converter&lt;Type ^, System::String ^&gt; ^ multipleTargetConverter);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.TextWriter * Converter&lt;Type, string&gt; -&gt; unit" Usage="dataSet.WriteXmlSchema (writer, multipleTargetConverter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="multipleTargetConverter" Type="System.Converter&lt;System.Type,System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="writer">A <see cref="T:System.IO.TextWriter" /> obiektu do zapisu.</param>
        <param name="multipleTargetConverter">Delegat służący do konwertowania <see cref="T:System.Type" /> na ciąg.</param>
        <summary>Zapisuje <see cref="T:System.Data.DataSet" /> struktury jako schematu XML do określonego <see cref="T:System.IO.TextWriter" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (string fileName, Converter&lt;Type,string&gt; multipleTargetConverter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(string fileName, class System.Converter`2&lt;class System.Type, string&gt; multipleTargetConverter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.String,System.Converter{System.Type,System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (fileName As String, multipleTargetConverter As Converter(Of Type, String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::String ^ fileName, Converter&lt;Type ^, System::String ^&gt; ^ multipleTargetConverter);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : string * Converter&lt;Type, string&gt; -&gt; unit" Usage="dataSet.WriteXmlSchema (fileName, multipleTargetConverter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="multipleTargetConverter" Type="System.Converter&lt;System.Type,System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="fileName">Nazwa pliku do zapisu.</param>
        <param name="multipleTargetConverter">Delegat służący do konwertowania <see cref="T:System.Type" /> na ciąg.</param>
        <summary>Zapisuje <see cref="T:System.Data.DataSet" /> struktury jako schematu XML w pliku.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.Xml.XmlWriter writer, Converter&lt;Type,string&gt; multipleTargetConverter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.Xml.XmlWriter writer, class System.Converter`2&lt;class System.Type, string&gt; multipleTargetConverter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter,System.Converter{System.Type,System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As XmlWriter, multipleTargetConverter As Converter(Of Type, String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::Xml::XmlWriter ^ writer, Converter&lt;Type ^, System::String ^&gt; ^ multipleTargetConverter);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.Xml.XmlWriter * Converter&lt;Type, string&gt; -&gt; unit" Usage="dataSet.WriteXmlSchema (writer, multipleTargetConverter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="multipleTargetConverter" Type="System.Converter&lt;System.Type,System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="writer">A <see cref="T:System.Xml.XmlWriter" /> obiektu do zapisu.</param>
        <param name="multipleTargetConverter">Delegat służący do konwertowania <see cref="T:System.Type" /> na ciąg.</param>
        <summary>Zapisuje <see cref="T:System.Data.DataSet" /> struktury jako schematu XML do określonego <see cref="T:System.Xml.XmlWriter" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
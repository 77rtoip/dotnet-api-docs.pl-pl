<Type Name="DataSet" FullName="System.Data.DataSet">
  <Metadata><Meta Name="ms.openlocfilehash" Value="fa19182fecd7bf633bdddbbf351028807ddf3175" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69122489" /></Metadata><TypeSignature Language="C#" Value="public class DataSet : System.ComponentModel.MarshalByValueComponent, System.ComponentModel.IListSource, System.ComponentModel.ISupportInitializeNotification, System.Runtime.Serialization.ISerializable, System.Xml.Serialization.IXmlSerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit DataSet extends System.ComponentModel.MarshalByValueComponent implements class System.ComponentModel.IListSource, class System.ComponentModel.ISupportInitialize, class System.ComponentModel.ISupportInitializeNotification, class System.Runtime.Serialization.ISerializable, class System.Xml.Serialization.IXmlSerializable" />
  <TypeSignature Language="DocId" Value="T:System.Data.DataSet" />
  <TypeSignature Language="VB.NET" Value="Public Class DataSet&#xA;Inherits MarshalByValueComponent&#xA;Implements IListSource, ISerializable, ISupportInitializeNotification, IXmlSerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class DataSet : System::ComponentModel::MarshalByValueComponent, System::ComponentModel::IListSource, System::ComponentModel::ISupportInitializeNotification, System::Runtime::Serialization::ISerializable, System::Xml::Serialization::IXmlSerializable" />
  <TypeSignature Language="F#" Value="type DataSet = class&#xA;    inherit MarshalByValueComponent&#xA;    interface IListSource&#xA;    interface IXmlSerializable&#xA;    interface ISupportInitializeNotification&#xA;    interface ISerializable&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System.Data</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Data.Common</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.MarshalByValueComponent</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.IListSource</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitializeNotification</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Xml.Serialization.IXmlSerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
      <AttributeName>System.ComponentModel.DefaultProperty("DataSetName")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VSDesigner.Data.VS.DataSetDesigner, Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.ComponentModel.ToolboxItem("Microsoft.VSDesigner.Data.VS.DataSetToolboxItem, Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-3.0">
      <AttributeName>System.Xml.Serialization.XmlRoot("DataSet")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
      <AttributeName>System.Xml.Serialization.XmlSchemaProvider("GetDataSetSchema")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.0;netstandard-2.1">
      <AttributeName>System.ComponentModel.ToolboxItem("Microsoft.VSDesigner.Data.VS.DataSetToolboxItem, Microsoft.VSDesigner, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VSDesigner.Data.VS.DataSetDesigner, Microsoft.VSDesigner, Version=7.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.ToolboxItem("Microsoft.VSDesigner.Data.VS.DataSetToolboxItem, Microsoft.VSDesigner, Version=7.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VSDesigner.Data.VS.DataSetDesigner, Microsoft.VSDesigner, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.ToolboxItem("Microsoft.VSDesigner.Data.VS.DataSetToolboxItem, Microsoft.VSDesigner, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VSDesigner.Data.VS.DataSetDesigner, Microsoft.VSDesigner, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VSDesigner.Data.VS.DataSetDesigner, Microsoft.VSDesigner, Version=9.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
      <AttributeName>System.ComponentModel.ToolboxItem("Microsoft.VSDesigner.Data.VS.DataSetToolboxItem, Microsoft.VSDesigner, Version=9.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje pamięć podręczną danych.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet>, Który jest pamięcią podręczną danych pobieraną ze źródła danych, jest głównym składnikiem architektury ADO.NET. Składa się z <xref:System.Data.DataTable> kolekcji obiektów, które można powiązać ze sobą za pomocą <xref:System.Data.DataRelation> obiektów. <xref:System.Data.DataSet> Możesz również wymusić integralność <xref:System.Data.DataSet> danych przy <xref:System.Data.UniqueConstraint> użyciu obiektów i <xref:System.Data.ForeignKeyConstraint> . Aby uzyskać więcej informacji na temat <xref:System.Data.DataSet> pracy z obiektami, zobacz [zestawy danych, DataTables i](~/docs/framework/data/adonet/dataset-datatable-dataview/index.md)DataViews.  
  
 Obiekty, które zawierają dane, umożliwiająnawigowaniemimohierarchiitabeli.<xref:System.Data.DataRelationCollection> <xref:System.Data.DataTable> Tabele są zawarte w <xref:System.Data.DataTableCollection> dostępie <xref:System.Data.DataSet.Tables%2A> za pomocą właściwości. Podczas uzyskiwania <xref:System.Data.DataTable> dostępu do obiektów należy zauważyć, że są warunkowe uwzględnianie wielkości liter. Na przykład, jeśli jeden <xref:System.Data.DataTable> z nich nosi nazwę "webtables", a drugi o nazwie "webtablee", ciąg używany do wyszukiwania jednej z tabel jest traktowany jako uwzględniający wielkość liter. Jeśli jednak "istnieje" i "nie jest", to ciąg wyszukiwania jest traktowany jako nieuwzględniający wielkości liter. Aby uzyskać więcej informacji na temat <xref:System.Data.DataTable> pracy z obiektami, zobacz [Tworzenie elementu DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/creating-a-datatable.md).  
  
 <xref:System.Data.DataSet> Może odczytywać i zapisywać dane oraz schemat jako dokumenty XML. Dane i schemat mogą następnie być transportowane przez protokół HTTP i używane przez dowolną aplikację na dowolnej platformie, która jest włączona w formacie XML. Możesz zapisać schemat jako schemat XML przy <xref:System.Data.DataSet.WriteXmlSchema%2A> użyciu metody, a zarówno schematu, jak i danych można zapisać <xref:System.Data.DataSet.WriteXml%2A> przy użyciu metody. Aby odczytać dokument XML, który zawiera schemat i dane, użyj <xref:System.Data.DataSet.ReadXml%2A> metody.  
  
 W typowej implementacji wielu warstw, kroki służące do tworzenia i odświeżania <xref:System.Data.DataSet>oryginalnych danych są następujące:  
  
1.  Kompiluj i Wypełnij każdą <xref:System.Data.DataTable> z danych <xref:System.Data.DataSet> w obszarze z danymi ze źródła danych przy <xref:System.Data.Common.DataAdapter>użyciu.  
  
2.  Zmień dane w poszczególnych <xref:System.Data.DataTable> obiektach przez dodawanie, aktualizowanie lub usuwanie <xref:System.Data.DataRow> obiektów.  
  
3.  Wywołaj <xref:System.Data.DataSet> metodę, aby utworzyć sekundę, która zawiera tylko zmiany w danych. <xref:System.Data.DataSet.GetChanges%2A>  
  
4.  Wywołaj <xref:System.Data.Common.DataAdapter> <xref:System.Data.DataSet> metodę, przekazując drugą jako argument. <xref:System.Data.Common.DataAdapter.Update%2A>  
  
5.  Wywołaj <xref:System.Data.DataSet> metodę, aby scalić zmiany od drugiej do pierwszej. <xref:System.Data.DataSet.Merge%2A>  
  
6.  Wywołaj przy użyciu. <xref:System.Data.DataSet> <xref:System.Data.DataSet.AcceptChanges%2A> Alternatywnie można wywołać <xref:System.Data.DataSet.RejectChanges%2A> , aby anulować zmiany.  
  
> [!NOTE]
>  Obiekty <xref:System.Data.DataSet> i <xref:System.ComponentModel.MarshalByValueComponent> dziedziczą<xref:System.Runtime.Serialization.ISerializable> z i obsługują interfejs na potrzeby komunikacji zdalnej. <xref:System.Data.DataTable> Są to jedyne ADO.NET obiekty, które można zdalnie.  
  
> [!NOTE]
>  Klasy dziedziczone z <xref:System.Data.DataSet> nie są finalizowane przez moduł wyrzucania elementów bezużytecznych, ponieważ finalizator został pominięty w. <xref:System.Data.DataSet> Klasa pochodna może wywoływać <xref:System.GC.ReRegisterForFinalize%2A> metodę w konstruktorze, aby umożliwić końcową klasę przez moduł wyrzucania elementów bezużytecznych.  
  
   
  
## Examples  
 Poniższy przykład składa się z kilku metod, które łączą, tworzą i <xref:System.Data.DataSet> wypełniają z bazy danych **Northwind** .  
  
 [!code-csharp[Classic WebData DataSet Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Ten typ jest bezpieczny dla wielowątkowych operacji odczytu. Należy zsynchronizować wszystkie operacje zapisu.</threadsafe>
    <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Data.DataSet" /> klasy.</summary>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataSet ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataSet();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Data.DataSet" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta implementacja <xref:System.Data.DataSet> konstruktora nie przyjmuje żadnych parametrów i tworzy nazwę domyślną "NewDataSet" dla nowego wystąpienia.  
  
 Nazwa <xref:System.Data.DataSet> jest wymagana, aby upewnić się, że reprezentacja <xref:System.Data.DataSet> XML zawsze ma nazwę elementu dokumentu, który jest elementem najwyższego poziomu w definicji schematu.  
  
   
  
## Examples  
 Poniższy przykład tworzy nowe <xref:System.Data.DataSet>i dodaje do niego dwa <xref:System.Data.DataTable> obiekty.  
  
 [!code-vb[Classic WebData DataSet.DataSet Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.DataSet Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Data.DataTableCollection" />
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataSet (string dataSetName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string dataSetName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dataSetName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataSet(System::String ^ dataSetName);" />
      <MemberSignature Language="F#" Value="new System.Data.DataSet : string -&gt; System.Data.DataSet" Usage="new System.Data.DataSet dataSetName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dataSetName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dataSetName">Nazwa <see cref="T:System.Data.DataSet" />.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Data.DataSet" /> klasy o podaną nazwę.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nazwa <xref:System.Data.DataSet> jest wymagana, aby upewnić się, że reprezentacja <xref:System.Data.DataSet> XML zawsze ma nazwę elementu dokumentu, który jest elementem najwyższego poziomu w definicji schematu.  
  
   
  
## Examples  
 Poniższy przykład tworzy nowy <xref:System.Data.DataSet>, do którego dodawane są dwa <xref:System.Data.DataTable> obiekty.  
  
 [!code-vb[Classic WebData DataSet.DataSet1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.DataSet1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataSet.DataSetName" />
        <altmember cref="T:System.Data.DataTableCollection" />
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DataSet (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DataSet(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new System.Data.DataSet : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Data.DataSet" Usage="new System.Data.DataSet (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Dane, które są konieczne do serializacji lub deserializacji obiektu.</param>
        <param name="context">Źródło i miejsce docelowe danego serializowanego strumienia.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Data.DataSet" /> klasy, która ma dane serializacji i kontekst.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
[!INCLUDE [untrusted-data-instance-note](~/includes/untrusted-data-instance-note.md)]
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DataSet (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context, bool ConstructSchema);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context, bool ConstructSchema) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext, ConstructSchema As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DataSet(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context, bool ConstructSchema);" />
      <MemberSignature Language="F#" Value="new System.Data.DataSet : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext * bool -&gt; System.Data.DataSet" Usage="new System.Data.DataSet (info, context, ConstructSchema)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ConstructSchema" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="info"><see cref="T:System.Runtime.Serialization.SerializationInfo" /> Obiekt.</param>
        <param name="context"><see cref="T:System.Runtime.Serialization.StreamingContext" /> Obiekt.</param>
        <param name="ConstructSchema">Wartość logiczna.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Data.DataSet" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
[!INCLUDE [untrusted-data-instance-note](~/includes/untrusted-data-instance-note.md)]
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AcceptChanges">
      <MemberSignature Language="C#" Value="public void AcceptChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.AcceptChanges" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcceptChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcceptChanges();" />
      <MemberSignature Language="F#" Value="member this.AcceptChanges : unit -&gt; unit" Usage="dataSet.AcceptChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zatwierdza wszystkie zmiany wprowadzone w tym <see cref="T:System.Data.DataSet" /> momencie od momentu załadowania lub od momentu <see cref="M:System.Data.DataSet.AcceptChanges" /> ostatniego wywołania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataRow> Klasy i <xref:System.Data.DataTable> mają metody.<xref:System.Data.DataSet.AcceptChanges%2A> Wywołanie <xref:System.Data.DataTable.AcceptChanges%2A> <xref:System.Data.DataRow.AcceptChanges%2A> na poziomie powoduje, że metoda dla każdej <xref:System.Data.DataRow> z nich zostanie wywołana. <xref:System.Data.DataTable> Analogicznie, <xref:System.Data.DataSet.AcceptChanges%2A> wywoływanie dla <xref:System.Data.DataSet> przyczyn <xref:System.Data.DataTable.AcceptChanges%2A> , <xref:System.Data.DataSet>które mają być wywoływane dla każdej tabeli w obrębie. W ten sposób masz wiele poziomów, na których można wywołać metodę. <xref:System.Data.DataSet.AcceptChanges%2A> Wywołanie<xref:System.Data.DataSet> elementu umożliwia wywołanie metody na wszystkich obiektach podrzędnych (na przykład tabelach i wierszach) przy użyciu jednego wywołania.  
  
 Po wywołaniu `AcceptChanges` `DataSet`w programie wszelkie <xref:System.Data.DataRow> obiekty nadal w trybie edycji kończą się pomyślnie. Właściwość <xref:System.Data.DataRow.RowState%2A> każdego z nich <xref:System.Data.DataRow> również zmienia się; `Added` i wiersze`Modified` staną`Unchanged`się usunięte`Deleted` .  
  
 `DataSet` Jeśli zawiera <xref:System.Data.ForeignKeyConstraint> obiekty`AcceptChanges` , wywoływanie metody również powoduje <xref:System.Data.ForeignKeyConstraint.AcceptRejectRule%2A> wymuszone.  
  
> [!NOTE]
>  `AcceptChanges`i `RejectChanges` mają zastosowanie tylko `DataRow` do powiązanych zmian (to jest, Dodawanie, usuwanie, usuwanie i modyfikowanie). Nie mają zastosowania do zmian schematu lub strukturalnego.  
>   
>  Wywołanie metody AcceptChanges nie spowoduje replikowania tych zmian z powrotem do źródła danych, jeśli zestaw danych został wypełniony przy użyciu elementu DataAdapter. W takiej sytuacji zamiast tego <xref:System.Data.Common.DataAdapter.Update%2A> należy wywołać metodę. Aby uzyskać więcej informacji, zobacz [Aktualizowanie źródeł danych za pomocą adapterów](~/docs/framework/data/adonet/updating-data-sources-with-dataadapters.md) .  
  
   
  
## Examples  
 Poniższy przykład dodaje <xref:System.Data.DataRow> <xref:System.Data.DataTable> do. <xref:System.Data.DataSet> Metoda jest następnie wywoływana <xref:System.Data.DataSet>w, która jest kaskadowo do wszystkich <xref:System.Data.DataTable> obiektów, które zawiera. <xref:System.Data.DataSet.AcceptChanges%2A>  
  
 [!code-csharp[Classic WebData DataSet.AcceptChanges#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.AcceptChanges/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.AcceptChanges#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.AcceptChanges/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="dataSet.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rozpoczyna inicjalizację <see cref="T:System.Data.DataSet" /> , która jest używana w formularzu lub używana przez inny składnik. Inicjalizacja występuje w czasie wykonywania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Środowisko projektowe .NET programu Visual Studio używa tej metody do uruchamiania inicjowania składnika, który jest używany w formularzu lub używany przez inny składnik. <xref:System.Data.DataSet.EndInit%2A> Metoda przerywa inicjalizację. Użycie metod <xref:System.Data.DataSet.EndInit%2A> i uniemożliwia użycie kontrolki przed jej pełnym zainicjowaniem. <xref:System.Data.DataSet.BeginInit%2A>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="CaseSensitive">
      <MemberSignature Language="C#" Value="public bool CaseSensitive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CaseSensitive" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.CaseSensitive" />
      <MemberSignature Language="VB.NET" Value="Public Property CaseSensitive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CaseSensitive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CaseSensitive : bool with get, set" Usage="System.Data.DataSet.CaseSensitive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetCaseSensitiveDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy Porównywanie ciągów <see cref="T:System.Data.DataTable" /> w obiektach jest rozróżniana wielkość liter.</summary>
        <value><see langword="true" />Jeśli w porównaniach ciągów jest rozróżniana wielkość liter; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość wpływa na to, jak operacje sortowania, wyszukiwania i filtrowania są wykonywane dla <xref:System.Data.DataTable> każdego obiektu zawartego <xref:System.Data.DataSet> w obiekcie podczas <xref:System.Data.DataTable.Select%2A> korzystania z metody. <xref:System.Data.DataSet.CaseSensitive%2A>  
  
 Domyślnie ustawienie <xref:System.Data.DataSet.CaseSensitive%2A> właściwości dla elementu <xref:System.Data.DataSet> ustawia <xref:System.Data.DataTable.CaseSensitive%2A> również właściwość każdej skojarzonej <xref:System.Data.DataTable> z tą samą wartością.  
  
   
  
## Examples  
 Poniższy przykład umożliwia przełączenie <xref:System.Data.DataSet.CaseSensitive%2A> właściwości.  
  
 [!code-vb[Classic WebData DataSet.CaseSensitive Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.CaseSensitive Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="dataSet.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Data.DataSet" /> Czyści wszystkie dane, usuwając wszystkie wiersze ze wszystkich tabel.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.XmlDataDocument> <xref:System.Data.DataSet.Clear%2A?displayProperty=nameWithType> <xref:System.Data.DataTable.Clear%2A?displayProperty=nameWithType> Jeśli jest powiązany z<xref:System.NotSupportedException>, wywołujący lub podnosi. <xref:System.Data.DataSet> Aby uniknąć tej sytuacji, przechodzą każdą tabelę, usuwając każdy wiersz pojedynczo.  
  
   
  
## Examples  
 Poniższy przykład czyści <xref:System.Data.DataSet> wszystkie wiersze we wszystkich tabelach.  
  
 [!code-csharp[Classic WebData DataSet.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual System.Data.DataSet Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Data.DataSet Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As DataSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Data::DataSet ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; System.Data.DataSet&#xA;override this.Clone : unit -&gt; System.Data.DataSet" Usage="dataSet.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Kopiuje strukturę <see cref="T:System.Data.DataSet" />, w tym wszystkie <see cref="T:System.Data.DataTable" /> schematy, relacje i ograniczenia. Nie kopiuje żadnych danych.</summary>
        <returns>Nowy <see cref="T:System.Data.DataSet" /> z tym samym schematem, który jest <see cref="T:System.Data.DataSet" />bieżącym, ale nie ma żadnych danych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Jeśli te klasy zostały podklasy, klon będzie również mieć te same podklasy.  
  
   
  
## Examples  
 Poniższy przykład tworzy klon <xref:System.Data.DataSet> schematu obiektu.  
  
 [!code-csharp[Classic WebData DataSet.Clone Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Clone Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Clone Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Clone Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.Copy" />
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public System.Data.DataSet Copy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataSet Copy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Copy" />
      <MemberSignature Language="VB.NET" Value="Public Function Copy () As DataSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataSet ^ Copy();" />
      <MemberSignature Language="F#" Value="member this.Copy : unit -&gt; System.Data.DataSet" Usage="dataSet.Copy " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Kopiuje zarówno strukturę, jak i dane <see cref="T:System.Data.DataSet" />.</summary>
        <returns>Nowe <see cref="T:System.Data.DataSet" /> z tą samą strukturą (schematy tabeli, relacje i ograniczenia) i dane w ten <see cref="T:System.Data.DataSet" />sposób.  
  
 <block subset="none" type="note"><para>  
 Jeśli te klasy zostały podklasy, kopia będzie również mieć te same podklasy.  
  
</para></block></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie zastosowano <xref:System.Data.DataSet.Copy%2A> metodę, aby utworzyć kopię oryginału <xref:System.Data.DataSet>.  
  
 [!code-csharp[Classic WebData DataSet.Copy Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Copy Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Copy Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Copy Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.Clone" />
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDataReader">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca z jednym zestawem wyników na <see cref="T:System.Data.DataTable" />, w tej samej kolejności, w jakiej tabele są wyświetlane <see cref="P:System.Data.DataSet.Tables" /> w kolekcji. <see cref="T:System.Data.DataTableReader" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W celu zapewnienia kolejności zestawów <xref:System.Data.DataTableReader>wyników w zwracanej wartości, jeśli element <xref:System.Data.DataTable> <xref:System.Data.DataSet> jest pusty, będzie reprezentowany przez pusty zestaw wyników w zwracanym `DataTableReader`elemencie.  
  
   
  
## Examples  
 W tym przykładzie Aplikacja konsolowa tworzy trzy <xref:System.Data.DataTable> wystąpienia i dodaje <xref:System.Data.DataSet>je do. Przykład wywołuje <xref:System.Data.DataSet.CreateDataReader%2A> metodę i wyświetla zawartość zwróconych <xref:System.Data.DataTableReader>wartości. Należy zauważyć, że kolejność zestawów wyników w `DataTableReader` elemencie jest kontrolowana przez kolejność `DataTable` wystąpień przesłanych jako parametry.  
  
> [!NOTE]
>  Ten przykład pokazuje, jak używać jednej ze przeciążonych wersji programu `CreateDataReader`. Inne przykłady, które mogą być dostępne, można znaleźć w tematach dotyczących poszczególnych przeciążeń.  
  
 [!code-csharp[DataWorks DataSet.CreateDataReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.CreateDataReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.CreateDataReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.CreateDataReader/VB/source.vb#1)]  
  
 W przykładzie przedstawiono następujący kod w oknie konsoli:  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDataReader">
      <MemberSignature Language="C#" Value="public System.Data.DataTableReader CreateDataReader ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTableReader CreateDataReader() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.CreateDataReader" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateDataReader () As DataTableReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTableReader ^ CreateDataReader();" />
      <MemberSignature Language="F#" Value="member this.CreateDataReader : unit -&gt; System.Data.DataTableReader" Usage="dataSet.CreateDataReader " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableReader</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca z jednym zestawem wyników na <see cref="T:System.Data.DataTable" />, w tej samej kolejności, w jakiej tabele są wyświetlane <see cref="P:System.Data.DataSet.Tables" /> w kolekcji. <see cref="T:System.Data.DataTableReader" /></summary>
        <returns>Zawierający jeden lub więcej zestawów wyników odpowiadających <see cref="T:System.Data.DataTable" /> wystąpieniu zawartym w źródle <see cref="T:System.Data.DataSet" />. <see cref="T:System.Data.DataTableReader" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W celu zapewnienia kolejności zestawów <xref:System.Data.DataTableReader>wyników w zwracanej wartości, jeśli element <xref:System.Data.DataTable> w <xref:System.Data.DataSet> jest pusty, jest reprezentowany przez pusty zestaw wyników w zwracanym `DataTableReader`elemencie.  
  
   
  
## Examples  
 Poniższy przykład tworzy trzy <xref:System.Data.DataTable> wystąpienia i dodaje każdy <xref:System.Data.DataSet>do. Następnie przykład przekazuje wypełniony `DataSet` do procedury, która <xref:System.Data.DataSet.CreateDataReader%2A> wywołuje metodę, i przechodzi do iteracji przez wszystkie zestawy <xref:System.Data.DataTableReader>wyników zawarte w. Przykład wyświetla wyniki w oknie konsoli.  
  
 [!code-csharp[DataWorks DataSet.DataTableReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.DataTableReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.DataTableReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.DataTableReader/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="CreateDataReader">
      <MemberSignature Language="C#" Value="public System.Data.DataTableReader CreateDataReader (params System.Data.DataTable[] dataTables);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTableReader CreateDataReader(class System.Data.DataTable[] dataTables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.CreateDataReader(System.Data.DataTable[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateDataReader (ParamArray dataTables As DataTable()) As DataTableReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTableReader ^ CreateDataReader(... cli::array &lt;System::Data::DataTable ^&gt; ^ dataTables);" />
      <MemberSignature Language="F#" Value="member this.CreateDataReader : System.Data.DataTable[] -&gt; System.Data.DataTableReader" Usage="dataSet.CreateDataReader dataTables" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataTables" Type="System.Data.DataTable[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-2.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="dataTables">Tablica tabeli danych dostarczająca kolejność zestawów wyników do zwrócenia w <see cref="T:System.Data.DataTableReader" />.</param>
        <summary>Zwraca z jednym zestawem wyników na <see cref="T:System.Data.DataTable" />. <see cref="T:System.Data.DataTableReader" /></summary>
        <returns>Zawierający jeden lub więcej zestawów wyników odpowiadających <see cref="T:System.Data.DataTable" /> wystąpieniu zawartym w źródle <see cref="T:System.Data.DataSet" />. <see cref="T:System.Data.DataTableReader" /> Zwracane zestawy wyników są w kolejności określonej przez <paramref name="dataTables" /> parametr.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W celu <xref:System.Data.DataTableReader>upewnienia się, że kolejność zestawów wyników w zwracanym <xref:System.Data.DataTable> <xref:System.Data.DataSet> elemencie jest pusta, jest reprezentowana przez pusty zestaw wyników w zwracanym `DataTableReader`elemencie. Ponieważ ta przeciążona wersja umożliwia dostarczenie listy `DataTable` wystąpień jako parametrów, można określić kolejność, w jakiej zestawy wyników pojawiają się w zwracanej `DataTableReader`wartości.  
  
   
  
## Examples  
 W tym przykładzie Aplikacja konsolowa tworzy trzy <xref:System.Data.DataTable> wystąpienia i dodaje <xref:System.Data.DataSet>je do. Przykład wywołuje <xref:System.Data.DataSet.CreateDataReader%2A> metodę i wyświetla zawartość zwróconych <xref:System.Data.DataTableReader>wartości. Należy zauważyć, że kolejność zestawów wyników w `DataTableReader` elemencie jest kontrolowana przez kolejność `DataTable` wystąpień przesłanych jako parametry. Przykład wyświetla wyniki w oknie konsoli.  
  
 [!code-csharp[DataWorks DataSet.DataTableReaderTables#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.DataTableReaderTables/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.DataTableReaderTables#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.DataTableReaderTables/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="DataSetName">
      <MemberSignature Language="C#" Value="public string DataSetName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DataSetName" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.DataSetName" />
      <MemberSignature Language="VB.NET" Value="Public Property DataSetName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DataSetName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DataSetName : string with get, set" Usage="System.Data.DataSet.DataSetName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetDataSetNameDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę bieżącego <see cref="T:System.Data.DataSet" />elementu.</summary>
        <value>Nazwa <see cref="T:System.Data.DataSet" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy nową <xref:System.Data.DataSet> z danym. <xref:System.Data.DataSet.DataSetName%2A>  
  
 [!code-csharp[Classic WebData DataSet.DataSetName Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.DataSetName Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.DataSetName Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.DataSetName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="DefaultViewManager">
      <MemberSignature Language="C#" Value="public System.Data.DataViewManager DefaultViewManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataViewManager DefaultViewManager" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.DefaultViewManager" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultViewManager As DataViewManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataViewManager ^ DefaultViewManager { System::Data::DataViewManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultViewManager : System.Data.DataViewManager" Usage="System.Data.DataSet.DefaultViewManager" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetDefaultViewDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataViewManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera niestandardowy widok danych zawartych w elemencie, <see cref="T:System.Data.DataSet" /> który umożliwia filtrowanie, wyszukiwanie i Nawigowanie przy użyciu niestandardowych. <see cref="T:System.Data.DataViewManager" /></summary>
        <value>Element <see cref="T:System.Data.DataViewManager" /> obiektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość <xref:System.Data.DataViewManager> zwracana <xref:System.Data.DataTable> <xref:System.Data.DataSet>przez Właściwość pozwala na tworzenie niestandardowych ustawień dla każdego w. <xref:System.Data.DataSet.DefaultViewManager%2A>  
  
 <xref:System.Data.DataView> Gdy uzyskujesz <xref:System.Data.DataTable>od, porządek sortowania, filtrowanie i <xref:System.Data.DataViewRowState> są <xref:System.Data.DataSet.DefaultViewManager%2A> skonfigurowane zgodnie z ustawieniami we właściwości.  
  
   
  
## Examples  
 Poniższy <xref:System.Data.DataViewManager> przykład pobiera wartość domyślną <xref:System.Data.DataSet>dla <xref:System.Data.DataTable> i dodaje do. <xref:System.Data.DataTableCollection>  
  
 [!code-vb[Classic WebData DataSet.DefaultViewManager Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.DefaultViewManager Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="DetermineSchemaSerializationMode">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Określa dla a <see cref="T:System.Data.DataSet" />. <see cref="P:System.Data.DataSet.SchemaSerializationMode" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może być wywoływana podczas deserializacji określonego typu <xref:System.Data.DataSet> w celu określenia jego. <xref:System.Data.DataSet.SchemaSerializationMode%2A>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="DetermineSchemaSerializationMode">
      <MemberSignature Language="C#" Value="protected System.Data.SchemaSerializationMode DetermineSchemaSerializationMode (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Data.SchemaSerializationMode DetermineSchemaSerializationMode(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.DetermineSchemaSerializationMode(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Protected Function DetermineSchemaSerializationMode (reader As XmlReader) As SchemaSerializationMode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Data::SchemaSerializationMode DetermineSchemaSerializationMode(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.DetermineSchemaSerializationMode : System.Xml.XmlReader -&gt; System.Data.SchemaSerializationMode" Usage="dataSet.DetermineSchemaSerializationMode reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.SchemaSerializationMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="reader">Wystąpienie, które jest przesyłane podczas deserializacji <see cref="T:System.Data.DataSet" />. <see cref="T:System.Xml.XmlReader" /></param>
        <summary>Określa dla a <see cref="T:System.Data.DataSet" />. <see cref="P:System.Data.DataSet.SchemaSerializationMode" /></summary>
        <returns>Wyliczenie <see cref="T:System.Data.SchemaSerializationMode" /> wskazujące, czy informacje o schemacie zostały pominięte w ładunku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może być wywoływana podczas deserializacji określonego typu <xref:System.Data.DataSet> w celu określenia jego. <xref:System.Data.DataSet.SchemaSerializationMode%2A>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="DetermineSchemaSerializationMode">
      <MemberSignature Language="C#" Value="protected System.Data.SchemaSerializationMode DetermineSchemaSerializationMode (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Data.SchemaSerializationMode DetermineSchemaSerializationMode(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.DetermineSchemaSerializationMode(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Function DetermineSchemaSerializationMode (info As SerializationInfo, context As StreamingContext) As SchemaSerializationMode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Data::SchemaSerializationMode DetermineSchemaSerializationMode(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="member this.DetermineSchemaSerializationMode : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Data.SchemaSerializationMode" Usage="dataSet.DetermineSchemaSerializationMode (info, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.SchemaSerializationMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="info">Chroniony Konstruktor jestwywoływanypodczasdeserializacjiwscenariuszachkomunikacjizdalnej.<see cref="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" /> <see cref="T:System.Runtime.Serialization.SerializationInfo" /> <see langword="DataSet" /></param>
        <param name="context">Chroniony Konstruktor jestwywoływanypodczasdeserializacjiwscenariuszachkomunikacjizdalnej.<see cref="M:System.Data.DataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" /> <see cref="T:System.Runtime.Serialization.StreamingContext" /> <see langword="DataSet" /></param>
        <summary>Określa dla a <see cref="T:System.Data.DataSet" />. <see cref="P:System.Data.DataSet.SchemaSerializationMode" /></summary>
        <returns>Wyliczenie <see cref="T:System.Data.SchemaSerializationMode" /> wskazujące, czy informacje o schemacie zostały pominięte w ładunku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może być wywoływana podczas deserializacji określonego typu <xref:System.Data.DataSet> w celu określenia jego. <xref:System.Data.DataSet.SchemaSerializationMode%2A>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="dataSet.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zamyka inicjalizację <see cref="T:System.Data.DataSet" /> , która jest używana w formularzu lub używana przez inny składnik. Inicjalizacja występuje w czasie wykonywania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Środowisko projektowe .NET programu Visual Studio korzysta z tej metody, aby zakończyć inicjalizację składnika, który jest używany w formularzu lub używany przez inny składnik. <xref:System.Data.DataSet.BeginInit%2A> Metoda uruchamia inicjalizację. Użycie metod <xref:System.Data.DataSet.EndInit%2A> i uniemożliwia użycie kontrolki przed jej pełnym zainicjowaniem. <xref:System.Data.DataSet.BeginInit%2A>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="EnforceConstraints">
      <MemberSignature Language="C#" Value="public bool EnforceConstraints { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnforceConstraints" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.EnforceConstraints" />
      <MemberSignature Language="VB.NET" Value="Public Property EnforceConstraints As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnforceConstraints { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnforceConstraints : bool with get, set" Usage="System.Data.DataSet.EnforceConstraints" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetEnforceConstraintsDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy reguły ograniczeń są przestrzegane podczas próby wykonania jakiejkolwiek operacji aktualizacji.</summary>
        <value><see langword="true" />Jeśli są wymuszane reguły; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ograniczenia są ustawiane na <xref:System.Data.DataTable> poziomie (<xref:System.Data.DataTable.Constraints%2A> właściwości). Aby uzyskać więcej informacji na temat tworzenia ograniczeń, zobacz temat [ograniczenia DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/datatable-constraints.md).  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Data.DataSet> jedną tabelę z jedną kolumną, pięć wierszy i jeden <xref:System.Data.UniqueConstraint>. Właściwość jest ustawiona na `false` , a wartości każdego wiersza mają ustawioną taką samą wartość. <xref:System.Data.DataSet.EnforceConstraints%2A> Gdy właściwość zostanie zresetowana do `true`, <xref:System.Data.ConstraintException> jest generowana. <xref:System.Data.DataSet.EnforceConstraints%2A>  
  
 [!code-csharp[Classic WebData DataSet.EnforceConstraints Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.EnforceConstraints Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.EnforceConstraints Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.EnforceConstraints Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.ConstraintException">Nie można wymusić co najmniej jednego ograniczenia.</exception>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ExtendedProperties">
      <MemberSignature Language="C#" Value="public System.Data.PropertyCollection ExtendedProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.PropertyCollection ExtendedProperties" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.ExtendedProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExtendedProperties As PropertyCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::PropertyCollection ^ ExtendedProperties { System::Data::PropertyCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExtendedProperties : System.Data.PropertyCollection" Usage="System.Data.DataSet.ExtendedProperties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("ExtendedPropertiesDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.PropertyCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję dostosowanych informacji o użytkowniku skojarzonych <see langword="DataSet" />z.</summary>
        <value>A <see cref="T:System.Data.PropertyCollection" /> ze wszystkimi informacjami o użytkowniku niestandardowym.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość umożliwia przechowywanie niestandardowych informacji `DataSet`przy użyciu. <xref:System.Data.DataSet.ExtendedProperties%2A> Można na przykład przechowywać czas, w którym dane powinny być odświeżane.  
  
 Właściwości rozszerzone muszą być typu <xref:System.String> , jeśli mają być utrwalane, <xref:System.Data.DataSet> gdy jest zapisywana jako XML.  
  
   
  
## Examples  
 Poniższy przykład dodaje właściwość niestandardową do <xref:System.Data.PropertyCollection> zwracanych <xref:System.Data.DataColumn.ExtendedProperties%2A> przez właściwość. Drugi przykład pobiera właściwość niestandardową.  
  
 [!code-csharp[Classic WebData DataColumn.ExtendedProperties Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataColumn.ExtendedProperties Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataColumn.ExtendedProperties Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataColumn.ExtendedProperties Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChanges">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera kopię <see cref="T:System.Data.DataSet" /> zawierającą wszystkie zmiany wprowadzone do niego od momentu ostatniego załadowania lub od momentu <see cref="M:System.Data.DataSet.AcceptChanges" /> wywołania.</summary>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChanges">
      <MemberSignature Language="C#" Value="public System.Data.DataSet GetChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataSet GetChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetChanges" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChanges () As DataSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataSet ^ GetChanges();" />
      <MemberSignature Language="F#" Value="member this.GetChanges : unit -&gt; System.Data.DataSet" Usage="dataSet.GetChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera kopię <see cref="T:System.Data.DataSet" /> , która zawiera wszystkie zmiany dokonane od momentu załadowania lub od momentu <see cref="M:System.Data.DataSet.AcceptChanges" /> ostatniego wywołania.</summary>
        <returns>Kopia zmian z tego <see cref="T:System.Data.DataSet" /> elementu, które mogą wykonywać na nim akcje i później zostać scalone z powrotem przy użyciu. <see cref="M:System.Data.DataSet.Merge(System.Data.DataSet)" /> Jeśli nie zostaną znalezione żadne zmienione wiersze, metoda zwraca <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tworzy nowy <xref:System.Data.DataSet> , który zawiera kopię wszystkich wierszy w oryginalnym <xref:System.Data.DataSet> , które mają oczekujące zmiany. Ograniczenia relacji mogą spowodować dodanie dodatkowych niezmienionych wierszy do nowego <xref:System.Data.DataSet> , jeśli niezmienione wiersze zawierają klucze podstawowe odpowiadające kluczom obcym w zmienionych wierszach. Metoda zwraca `null` , jeśli w oryginalnym <xref:System.Data.DataSet> nie ma wierszy, które mają oczekujące zmiany.  
  
   
  
## Examples  
 Poniższy przykład tworzy prostą <xref:System.Data.DataSet> z jedną tabelą, dwiema kolumnami i dziesięciu wierszami. Dwie wartości są zmieniane i zostanie dodany jeden wiersz. Podzestaw zmienionych danych jest tworzony przy użyciu <xref:System.Data.DataSet.GetChanges%2A> metody. Po rozpoczęciu uzgadniania błędów nowa kolumna zostanie dodana do podzestawu, zmieniając schemat. Gdy metoda jest wywoływana `missingSchemaAction` z ustawionym na `MissingSchemaAction.Add`, Nowa kolumna zostanie dodana do schematu oryginalnego <xref:System.Data.DataSet> obiektu. <xref:System.Data.DataSet.Merge%2A>  
  
 [!code-csharp[Classic WebData DataSet.GetChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.HasChanges" />
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetChanges">
      <MemberSignature Language="C#" Value="public System.Data.DataSet GetChanges (System.Data.DataRowState rowStates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataSet GetChanges(valuetype System.Data.DataRowState rowStates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetChanges(System.Data.DataRowState)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChanges (rowStates As DataRowState) As DataSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataSet ^ GetChanges(System::Data::DataRowState rowStates);" />
      <MemberSignature Language="F#" Value="member this.GetChanges : System.Data.DataRowState -&gt; System.Data.DataSet" Usage="dataSet.GetChanges rowStates" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rowStates" Type="System.Data.DataRowState" />
      </Parameters>
      <Docs>
        <param name="rowStates">Jedna z <see cref="T:System.Data.DataRowState" /> wartości.</param>
        <summary>Pobiera kopię <see cref="T:System.Data.DataSet" /> zawierającą wszystkie zmiany wprowadzone do niego od momentu ostatniego załadowania lub od momentu <see cref="M:System.Data.DataSet.AcceptChanges" /> wywołania, przefiltrowany <see cref="T:System.Data.DataRowState" />przez.</summary>
        <returns>Odfiltrowana kopia <see cref="T:System.Data.DataSet" /> , która może mieć wykonane akcje, a następnie ponownie scalona przy użyciu <see cref="M:System.Data.DataSet.Merge(System.Data.DataSet)" />. Jeśli nie zostaną znalezione żadne wiersze <see cref="T:System.Data.DataRowState" /> żądane, metoda zwraca. <see langword="null" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda jest używana do tworzenia drugiego <xref:System.Data.DataSet> obiektu, który zawiera tylko zmiany wprowadzone do oryginału. <xref:System.Data.DataSet.GetChanges%2A> Użyj argumentu `rowStates` , aby określić typ zmian, jakie powinien zawierać nowy obiekt.  
  
 Ta zwrócona kopia została zaprojektowana tak, aby była scalana z powrotem do tego oryginału <xref:System.Data.DataSet>. Ograniczenia relacji mogą spowodować uwzględnienie wierszy `Unchanged` nadrzędnych. Jeśli nie zostaną znalezione żadne wiersze <xref:System.Data.DataRowState> żądane <xref:System.Data.DataSet.GetChanges%2A> , metoda zwraca `null`.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Data.DataSet.GetChanges%2A> metody, aby utworzyć drugi <xref:System.Data.DataSet> obiekt, który jest następnie używany do aktualizowania źródła danych.  
  
 [!code-csharp[Classic WebData DataSet.GetChanges1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetChanges1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetDataSetSchema">
      <MemberSignature Language="C#" Value="public static System.Xml.Schema.XmlSchemaComplexType GetDataSetSchema (System.Xml.Schema.XmlSchemaSet schemaSet);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Schema.XmlSchemaComplexType GetDataSetSchema(class System.Xml.Schema.XmlSchemaSet schemaSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetDataSetSchema(System.Xml.Schema.XmlSchemaSet)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDataSetSchema (schemaSet As XmlSchemaSet) As XmlSchemaComplexType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Schema::XmlSchemaComplexType ^ GetDataSetSchema(System::Xml::Schema::XmlSchemaSet ^ schemaSet);" />
      <MemberSignature Language="F#" Value="static member GetDataSetSchema : System.Xml.Schema.XmlSchemaSet -&gt; System.Xml.Schema.XmlSchemaComplexType" Usage="System.Data.DataSet.GetDataSetSchema schemaSet" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchemaComplexType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="schemaSet" Type="System.Xml.Schema.XmlSchemaSet" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="schemaSet">Określony zestaw schematów.</param>
        <summary>Pobiera kopię <see cref="T:System.Xml.Schema.XmlSchemaSet" /> zestawu danych.</summary>
        <returns>Kopia <see cref="T:System.Xml.Schema.XmlSchemaSet" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="dataSet.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> , który przechowuje serializowane dane skojarzone <see cref="T:System.Data.DataSet" />z.</param>
        <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> , który zawiera źródło i miejsce docelowe serializowanego strumienia skojarzonego <see cref="T:System.Data.DataSet" />z.</param>
        <summary>Wypełnia obiekt informacji serializacji danymi wymaganymi do serializacji <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="info" /></exception>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetSchemaSerializable">
      <MemberSignature Language="C#" Value="protected virtual System.Xml.Schema.XmlSchema GetSchemaSerializable ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xml.Schema.XmlSchema GetSchemaSerializable() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetSchemaSerializable" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetSchemaSerializable () As XmlSchema" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xml::Schema::XmlSchema ^ GetSchemaSerializable();" />
      <MemberSignature Language="F#" Value="abstract member GetSchemaSerializable : unit -&gt; System.Xml.Schema.XmlSchema&#xA;override this.GetSchemaSerializable : unit -&gt; System.Xml.Schema.XmlSchema" Usage="dataSet.GetSchemaSerializable " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchema</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wystąpienie możliwe <see cref="T:System.Xml.Schema.XmlSchema" /> do serializacji.</summary>
        <returns><see cref="T:System.Xml.Schema.XmlSchema" /> Wystąpienie.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSerializationData">
      <MemberSignature Language="C#" Value="protected void GetSerializationData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void GetSerializationData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetSerializationData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub GetSerializationData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void GetSerializationData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="member this.GetSerializationData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="dataSet.GetSerializationData (info, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info"><see cref="T:System.Runtime.Serialization.SerializationInfo" /> Wystąpienie.</param>
        <param name="context">Kontekst strumieniowy.</param>
        <summary>Deserializacji dane tabeli ze strumienia binarnego lub XML.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetXml">
      <MemberSignature Language="C#" Value="public string GetXml ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetXml() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetXml" />
      <MemberSignature Language="VB.NET" Value="Public Function GetXml () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetXml();" />
      <MemberSignature Language="F#" Value="member this.GetXml : unit -&gt; string" Usage="dataSet.GetXml " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca reprezentację XML danych przechowywanych w <see cref="T:System.Data.DataSet" />.</summary>
        <returns>Ciąg, który jest reprezentacją danych przechowywanych w <see cref="T:System.Data.DataSet" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tej metody jest identyczne z <xref:System.Data.DataSet.WriteXml%2A> wywołaniem <xref:System.Data.XmlWriteMode> z ustawionym na <xref:System.Data.XmlWriteMode.IgnoreSchema>.  
  
 <xref:System.Data.DataSet.GetXml%2A>zwraca XML jako ciąg i w związku z tym wymaga większego obciążenia <xref:System.Data.DataSet.WriteXml%2A> niż do zapisu XML do pliku.  
  
 W przypadku kompilacji <xref:System.Data.DataSet> przy użyciu wnioskowania schematu i serializacji go przy użyciu usług XML lub Web, kolejność kolumn może ulec zmianie.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Data.DataSet> i <xref:System.Data.DataTable>, dodaje przykładowe dane, a następnie wyświetla dane w formacie XML.  
  
 [!code-csharp[Classic WebData DataSet.GetXml Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetXml Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetXml Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetXml Example/VB/source.vb#1)]  
  
 Ten przykład ilustruje sposób zapisywania danych w pliku XML z zestawu danych i odczytywania danych do zestawu danych z pliku XML. Ten przykład spowoduje utworzenie jednego zestawu danych z dwiema tabelami, użycie dwóch sposobów eksportowania zestawu danych do plików XML (WriteXml i GetXml —), a następnie użycie dwóch metod (ReadXml i InferXmlSchema) do zaimportowania zestawu danych z plików XML.  
  
 Przed skompilowaniem i uruchomieniem przykładu należy utworzyć cztery pliki XML w przykładowym katalogu. Najpierw utwórz ElementsWithAttributes. XML:  
  
```xml  
<MySchool>  
  <Course CourseID="C1045" Year="2012"  Title="Calculus" Credits="4" DepartmentID="7">New</Course>  
  <Course CourseID="C1061" Year="2012"  Title="Physics" Credits="4" DepartmentID="1" />  
  <Department DepartmentID="1" Name="Engineering" Budget="350000" StartDate="2007-09-01T00:00:00+08:00" Administrator="2" />  
  <Department DepartmentID="7" Name="Mathematics" Budget="250024" StartDate="2007-09-01T00:00:00+08:00" Administrator="3">Cancelled</Department>  
</MySchool>  
```  
  
 Następnie utwórz ElementsWithChildElementsxml. XML:  
  
```xml  
<MySchool>  
  <Course>  
    <CourseID>C1045</CourseID>  
    <Year>2012</Year>  
    <Title>Calculus</Title>  
    <Credits>4</Credits>  
    <DepartmentID>7</DepartmentID>  
  </Course>  
  <Course>  
    <CourseID>C1061</CourseID>  
    <Year>2012</Year>  
    <Title>Physics</Title>  
    <Credits>4</Credits>  
    <DepartmentID>1</DepartmentID>  
  </Course>  
  <Course>  
    <CourseID>C2021</CourseID>  
    <Year>2012</Year>  
    <Title>Composition</Title>  
    <Credits>3</Credits>  
    <DepartmentID>2</DepartmentID>  
  </Course>  
  <Course>  
    <CourseID>C2042</CourseID>  
    <Year>2012</Year>  
    <Title>Literature</Title>  
    <Credits>4</Credits>  
    <DepartmentID>2</DepartmentID>  
  </Course>  
  <Department>  
    <DepartmentID>1</DepartmentID>  
    <Name>Engineering</Name>  
    <Budget>350000</Budget>  
    <StartDate>2007-09-01T00:00:00+08:00</StartDate>  
    <Administrator>2</Administrator>  
  </Department>  
  <Department>  
    <DepartmentID>2</DepartmentID>  
    <Name>English</Name>  
    <Budget>120000</Budget>  
    <StartDate>2007-09-01T00:00:00+08:00</StartDate>  
    <Administrator>6</Administrator>  
  </Department>  
  <Department>  
    <DepartmentID>4</DepartmentID>  
    <Name>Economics</Name>  
    <Budget>200000</Budget>  
    <StartDate>2007-09-01T00:00:00+08:00</StartDate>  
    <Administrator>4</Administrator>  
  </Department>  
  <Department>  
    <DepartmentID>7</DepartmentID>  
    <Name>Mathematics</Name>  
    <Budget>250024</Budget>  
    <StartDate>2007-09-01T00:00:00+08:00</StartDate>  
    <Administrator>3</Administrator>  
  </Department>  
</MySchool>  
```  
  
 Teraz Utwórz ElementsWithOnlyAttributes. XML:  
  
```xml
<MySchool>  
  <Course CourseID="C1045" Year="2012"  Title="Calculus" Credits="4" DepartmentID="7" />  
  <Course CourseID="C1061" Year="2012"  Title="Physics" Credits="4" DepartmentID="1" />  
  <Department DepartmentID="1" Name="Engineering" Budget="350000" StartDate="2007-09-01T00:00:00+08:00" Administrator="2" />  
  <Department DepartmentID="7" Name="Mathematics" Budget="250024" StartDate="2007-09-01T00:00:00+08:00" Administrator="3" />  
</MySchool>  
```  
  
 A wreszcie Utwórz RepeatingElements. XML:  
  
```xml
<MySchool>  
  <Course>C1045</Course>  
  <Course>C1061</Course>  
  <Department>Engineering</Department>   
  <Department>Mathematics</Department>  
</MySchool>  
```  
  
 Teraz można skompilować i uruchomić następujący kod źródłowy.  [Sposób przechowywania danych zestawu danych w pliku XML](https://code.msdn.microsoft.com/How-to-Store-Data-of-7b9710f3) ma Visual Basic i C# projekty dla tego przykładu.  
  
```csharp
using System;  
using System.Data;  
using System.IO;  
using System.Text;  
using System.Xml;  
  
// Use WriteXml method to export the dataset.  
static class DataTableHelper {  
   public static void WriteDataSetToXML(DataSet dataset, String xmlFileName) {  
      using (FileStream fsWriterStream = new FileStream(xmlFileName, FileMode.Create)) {  
         using (XmlTextWriter xmlWriter = new XmlTextWriter(fsWriterStream, Encoding.Unicode)) {  
            dataset.WriteXml(xmlWriter, XmlWriteMode.WriteSchema);  
            Console.WriteLine("Write {0} to the File {1}.", dataset.DataSetName, xmlFileName);  
            Console.WriteLine();  
         }  
      }  
   }  
  
   // Use GetXml method to get the XML data of the dataset and then export to the file.  
   public static void GetXMLFromDataSet(DataSet dataset, String xmlFileName) {  
      using (StreamWriter writer = new StreamWriter(xmlFileName)) {  
         writer.WriteLine(dataset.GetXml());  
         Console.WriteLine("Get Xml data from {0} and write to the File {1}.", dataset.DataSetName, xmlFileName);  
         Console.WriteLine();  
      }  
   }  
  
   // Use ReadXml method to import the dataset from the dataset.  
   public static void ReadXmlIntoDataSet(DataSet newDataSet, String xmlFileName) {  
      using (FileStream fsReaderStream = new FileStream(xmlFileName, FileMode.Open)) {  
         using (XmlTextReader xmlReader = new XmlTextReader(fsReaderStream)) {  
            newDataSet.ReadXml(xmlReader, XmlReadMode.ReadSchema);  
         }  
      }  
   }  
  
   // Display the columns and value of DataSet.  
   public static void ShowDataSet(DataSet dataset) {  
      foreach (DataTable table in dataset.Tables) {  
         Console.WriteLine("Table {0}:", table.TableName);  
         ShowDataTable(table);  
      }  
   }  
  
   // Display the columns and value of DataTable.  
   private static void ShowDataTable(DataTable table) {  
      foreach (DataColumn col in table.Columns) {  
         Console.Write("{0,-14}", col.ColumnName);  
      }  
      Console.WriteLine("{0,-14}", "");  
  
      foreach (DataRow row in table.Rows) {  
         if (row.RowState == DataRowState.Deleted) {  
            foreach (DataColumn col in table.Columns) {  
               if (col.DataType.Equals(typeof(DateTime))) {  
                  Console.Write("{0,-14:d}", row[col, DataRowVersion.Original]);  
               }  
               else if (col.DataType.Equals(typeof(Decimal))) {  
                  Console.Write("{0,-14:C}", row[col, DataRowVersion.Original]);  
               }  
               else {  
                  Console.Write("{0,-14}", row[col, DataRowVersion.Original]);  
               }  
            }  
         }  
         else {  
            foreach (DataColumn col in table.Columns) {  
               if (col.DataType.Equals(typeof(DateTime))) {  
                  Console.Write("{0,-14:d}", row[col]);  
               }  
               else if (col.DataType.Equals(typeof(Decimal))) {  
                  Console.Write("{0,-14:C}", row[col]);  
               }  
               else {  
                  Console.Write("{0,-14}", row[col]);  
               }  
            }  
         }  
         Console.WriteLine("{0,-14}", "");  
      }  
   }  
  
   // Display the columns of DataSet.  
   public static void ShowDataSetSchema(DataSet dataSet) {  
      Console.WriteLine("{0} contains the following tables:", dataSet.DataSetName);  
      foreach (DataTable table in dataSet.Tables) {  
         Console.WriteLine("   Table {0} contains the following columns:", table.TableName);  
         ShowDataTableSchema(table);  
      }  
   }  
  
   // Display the columns of DataTable  
   private static void ShowDataTableSchema(DataTable table) {  
      String columnString = "";  
      foreach (DataColumn col in table.Columns) {  
         columnString += col.ColumnName + "   ";  
      }  
      Console.WriteLine(columnString);  
   }  
}  
  
class Program {  
   static void Main(string[] args) {  
      // Create the DataSet  
      DataSet school = new DataSet("MySchool");  
      DataTable course = CreateCourse();  
      DataTable department = CreateDepartment();  
      school.Tables.Add(course);  
      school.Tables.Add(department);  
  
      // Define the constraint between the tables.  
      ForeignKeyConstraint courseDepartFK = new ForeignKeyConstraint("CourseDepartFK", department.Columns["DepartmentID"], course.Columns["DepartmentID"]);  
      courseDepartFK.DeleteRule = Rule.Cascade;  
      courseDepartFK.UpdateRule = Rule.Cascade;  
      courseDepartFK.AcceptRejectRule = AcceptRejectRule.None;  
      course.Constraints.Add(courseDepartFK);  
  
      InsertDepartments(department);  
      InsertCourses(course);  
  
      // Export the dataset to the XML file.  
      Console.WriteLine("Data of the whole DataSet {0}", school.DataSetName);  
      DataTableHelper.ShowDataSet(school);  
  
      String xmlWithSchemaFileName = "WriterXMLWithSchema.xml";  
      String xmlGetDataFileName = "GetXML.xml";  
  
      // Use two ways to export the dataset to the Xml file.  
      DataTableHelper.WriteDataSetToXML(school, xmlWithSchemaFileName);  
      DataTableHelper.GetXMLFromDataSet(school, xmlGetDataFileName);  
  
      // Import the dataset from the XML file.  
      // Use two ways to import the dataset from the Xml file.  
      Console.WriteLine("Read Xml document into a new DataSet:");  
      DataSet newSchool = new DataSet("NewSchool");  
      DataTableHelper.ReadXmlIntoDataSet(newSchool, xmlWithSchemaFileName);  
      DataTableHelper.ShowDataSetSchema(newSchool);  
      Console.WriteLine();  
  
      Console.WriteLine("Infer a schema for a DataSet from an XML document:");  
      InferDataSetSchemaFromXml();  
  
      Console.WriteLine("Press any key to exit.");  
      Console.ReadKey();  
   }  
  
   static DataTable CreateCourse() {  
      DataTable course = new DataTable("Course");  
      DataColumn[] cols ={  
                              new DataColumn("CourseID",typeof(String)),  
                              new DataColumn("Year",typeof(Int32)),  
                              new DataColumn("Title",typeof(String)),  
                              new DataColumn("Credits",typeof(Int32)),  
                              new DataColumn("DepartmentID",typeof(Int32))};  
      course.Columns.AddRange(cols);  
  
      course.PrimaryKey = new DataColumn[] { course.Columns["CourseID"], course.Columns["Year"] };  
  
      return course;  
   }  
  
   static DataTable CreateDepartment() {  
      DataTable department = new DataTable("Department");  
      DataColumn[] cols = {   
                                new DataColumn("DepartmentID", typeof(Int32)),  
                                new DataColumn("Name",typeof(String)),  
                                new DataColumn("Budget",typeof(Decimal)),  
                                new DataColumn("StartDate",typeof(DateTime)),  
                                new DataColumn("Administrator",typeof(Int32))};  
      department.Columns.AddRange(cols);  
  
      department.PrimaryKey = new DataColumn[] { department.Columns["DepartmentID"] };  
  
      return department;  
   }  
  
   static void InsertDepartments(DataTable department) {  
      Object[] rows = {   
                            new Object[]{1,"Engineering",350000.00,new DateTime(2007,9,1),2},  
                            new Object[]{2,"English",120000.00,new DateTime(2007,9,1),6},  
                            new Object[]{4,"Economics",200000.00,new DateTime(2007,9,1),4},  
                            new Object[]{7,"Mathematics",250024.00,new DateTime(2007,9,1),3}};  
  
      foreach (Object[] row in rows) {  
         department.Rows.Add(row);  
      }  
   }  
  
   static void InsertCourses(DataTable course) {  
      Object[] rows ={  
                               new Object[]{"C1045",2012,"Calculus",4,7},  
                               new Object[]{"C1061",2012,"Physics",4,1},  
                               new Object[]{"C2021",2012,"Composition",3,2},  
                               new Object[]{"C2042",2012,"Literature",4,2}};  
  
      foreach (Object[] row in rows) {  
         course.Rows.Add(row);  
      }  
   }  
  
   // Display the results of inferring schema from four types of XML structures  
   private static void InferDataSetSchemaFromXml() {  
      String[] xmlFileNames = {   
  
                                    @"ElementsWithOnlyAttributes.xml",   
                                    @"ElementsWithAttributes.xml",  
                                    @"RepeatingElements.xml",   
                                    @"ElementsWithChildElements.xml" };  
  
      foreach (String xmlFileName in xmlFileNames) {  
         Console.WriteLine("Result of {0}", Path.GetFileNameWithoutExtension(xmlFileName));  
         DataSet newSchool = new DataSet();  
         newSchool.InferXmlSchema(xmlFileName, null);  
         DataTableHelper.ShowDataSetSchema(newSchool);  
         Console.WriteLine();  
      }  
   }  
}  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="GetXmlSchema">
      <MemberSignature Language="C#" Value="public string GetXmlSchema ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetXmlSchema() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.GetXmlSchema" />
      <MemberSignature Language="VB.NET" Value="Public Function GetXmlSchema () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetXmlSchema();" />
      <MemberSignature Language="F#" Value="member this.GetXmlSchema : unit -&gt; string" Usage="dataSet.GetXmlSchema " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca schemat XML przedstawiający reprezentację XML danych przechowywanych w <see cref="T:System.Data.DataSet" />.</summary>
        <returns>Ciąg, który jest schematem XML dla reprezentacji danych w formacie XML przechowywanym <see cref="T:System.Data.DataSet" />w.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tej metody jest identyczne z wywołaniem <xref:System.Data.DataSet.WriteXmlSchema%2A>, z tą różnicą, że jest zapisywana tylko schemat podstawowy.  
  
 <xref:System.Data.DataSet.GetXmlSchema%2A>zwraca XML jako ciąg i w związku z tym wymaga większego obciążenia <xref:System.Data.DataSet.WriteXmlSchema%2A> niż do zapisu XML do pliku.  
  
 W przypadku kompilacji <xref:System.Data.DataSet> przy użyciu wnioskowania schematu i serializacji go przy użyciu usług XML lub Web, kolejność kolumn może ulec zmianie.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Data.DataSet> i <xref:System.Data.DataTable>, a następnie wyświetla schemat w formacie XML.  
  
 [!code-csharp[Classic WebData DataSet.GetXmlSchema Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetXmlSchema Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetXmlSchema Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetXmlSchema Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="HasChanges">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Data.DataSet" /> zawiera ona zmiany, w tym nowe, usunięte lub zmodyfikowane wiersze.</summary>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="HasChanges">
      <MemberSignature Language="C#" Value="public bool HasChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool HasChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.HasChanges" />
      <MemberSignature Language="VB.NET" Value="Public Function HasChanges () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool HasChanges();" />
      <MemberSignature Language="F#" Value="member this.HasChanges : unit -&gt; bool" Usage="dataSet.HasChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Data.DataSet" /> zawiera ona zmiany, w tym nowe, usunięte lub zmodyfikowane wiersze.</summary>
        <returns><see langword="true" />Jeśli ma zmiany; w przeciwnym razie <see langword="false" />. <see cref="T:System.Data.DataSet" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Data.DataSet.GetChanges%2A> metody, aby utworzyć drugi <xref:System.Data.DataSet> obiekt, który jest następnie używany do aktualizacji źródła danych.  
  
 [!code-csharp[Classic WebData DataSet.HasChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.HasChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.HasChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.HasChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="HasChanges">
      <MemberSignature Language="C#" Value="public bool HasChanges (System.Data.DataRowState rowStates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool HasChanges(valuetype System.Data.DataRowState rowStates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.HasChanges(System.Data.DataRowState)" />
      <MemberSignature Language="VB.NET" Value="Public Function HasChanges (rowStates As DataRowState) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool HasChanges(System::Data::DataRowState rowStates);" />
      <MemberSignature Language="F#" Value="member this.HasChanges : System.Data.DataRowState -&gt; bool" Usage="dataSet.HasChanges rowStates" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rowStates" Type="System.Data.DataRowState" />
      </Parameters>
      <Docs>
        <param name="rowStates">Jedna z <see cref="T:System.Data.DataRowState" /> wartości.</param>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Data.DataSet" /> zawiera zmiany, w tym nowe, usunięte lub zmodyfikowane wiersze, filtrowane według. <see cref="T:System.Data.DataRowState" /></summary>
        <returns><see langword="true" />Jeśli ma zmiany; w przeciwnym razie <see langword="false" />. <see cref="T:System.Data.DataSet" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `DataSet` Przed wywołaniem metody<xref:System.Data.DataSet.GetChanges%2A> zapoznaj się z właściwością. <xref:System.Data.DataSet.HasChanges%2A>  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Data.DataSet.GetChanges%2A> metody, aby utworzyć drugi <xref:System.Data.DataSet> obiekt, który jest następnie używany do aktualizowania źródła danych.  
  
 [!code-csharp[Classic WebData DataSet.GetChanges1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetChanges1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="HasErrors">
      <MemberSignature Language="C#" Value="public bool HasErrors { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasErrors" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.HasErrors" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasErrors As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasErrors { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasErrors : bool" Usage="System.Data.DataSet.HasErrors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetHasErrorsDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy występują błędy w żadnym z <see cref="T:System.Data.DataTable" /> obiektów w tym <see cref="T:System.Data.DataSet" />elemencie.</summary>
        <value><see langword="true" />Jeśli dowolna tabela zawiera błąd; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każda <xref:System.Data.DataTable> znich<xref:System.Data.DataTable.HasErrors%2A> ma również właściwość. <xref:System.Data.DataSet> `HasErrors` Użyj właściwości `DataSet` pierwszej, aby określić, czy którakolwiek tabela zawiera błędy, przed sprawdzeniem pojedynczych <xref:System.Data.DataTable> obiektów. Jeśli występuje błąd <xref:System.Data.DataTable.GetErrors%2A> ,<xref:System.Data.DataRow> Metoda zwraca tablicę obiektów zawierających błędy. `DataTable`  
  
   
  
## Examples  
 Poniższy przykład używa właściwości, <xref:System.Data.DataSet.HasErrors%2A> aby określić, <xref:System.Data.DataSet> czy obiekt zawiera błędy. W takim przypadku <xref:System.Data.DataRow> zostanąwydrukowanebłędydlakażdegoznich.<xref:System.Data.DataTable>  
  
 [!code-csharp[Classic WebData DataSet.HasErrors Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.HasErrors Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.HasErrors Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.HasErrors Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="InferXmlSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Stosuje schemat XML do <see cref="T:System.Data.DataSet" />.</summary>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="InferXmlSchema">
      <MemberSignature Language="C#" Value="public void InferXmlSchema (System.IO.Stream stream, string[] nsArray);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InferXmlSchema(class System.IO.Stream stream, string[] nsArray) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InferXmlSchema(System.IO.Stream,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InferXmlSchema(System::IO::Stream ^ stream, cli::array &lt;System::String ^&gt; ^ nsArray);" />
      <MemberSignature Language="F#" Value="member this.InferXmlSchema : System.IO.Stream * string[] -&gt; unit" Usage="dataSet.InferXmlSchema (stream, nsArray)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="nsArray" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="stream">, <see langword="Stream" /> Z którego ma zostać odczytany schemat.</param>
        <param name="nsArray">Tablica ciągów nazw Uniform Resource Identifier (URI), które mają zostać wykluczone z wnioskowania schematu.</param>
        <summary>Stosuje schemat XML od określonego <see cref="T:System.IO.Stream" /> <see cref="T:System.Data.DataSet" />do.</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="InferXmlSchema">
      <MemberSignature Language="C#" Value="public void InferXmlSchema (System.IO.TextReader reader, string[] nsArray);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InferXmlSchema(class System.IO.TextReader reader, string[] nsArray) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InferXmlSchema(System.IO.TextReader,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub InferXmlSchema (reader As TextReader, nsArray As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InferXmlSchema(System::IO::TextReader ^ reader, cli::array &lt;System::String ^&gt; ^ nsArray);" />
      <MemberSignature Language="F#" Value="member this.InferXmlSchema : System.IO.TextReader * string[] -&gt; unit" Usage="dataSet.InferXmlSchema (reader, nsArray)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
        <Parameter Name="nsArray" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="reader">, <see langword="TextReader" /> Z którego ma zostać odczytany schemat.</param>
        <param name="nsArray">Tablica ciągów nazw Uniform Resource Identifier (URI), które mają zostać wykluczone z wnioskowania schematu.</param>
        <summary>Stosuje schemat XML od określonego <see cref="T:System.IO.TextReader" /> <see cref="T:System.Data.DataSet" />do.</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="InferXmlSchema">
      <MemberSignature Language="C#" Value="public void InferXmlSchema (string fileName, string[] nsArray);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InferXmlSchema(string fileName, string[] nsArray) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InferXmlSchema(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub InferXmlSchema (fileName As String, nsArray As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InferXmlSchema(System::String ^ fileName, cli::array &lt;System::String ^&gt; ^ nsArray);" />
      <MemberSignature Language="F#" Value="member this.InferXmlSchema : string * string[] -&gt; unit" Usage="dataSet.InferXmlSchema (fileName, nsArray)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="nsArray" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="fileName">Nazwa pliku (łącznie z ścieżką), z którego ma zostać odczytany schemat.</param>
        <param name="nsArray">Tablica ciągów nazw Uniform Resource Identifier (URI), które mają zostać wykluczone z wnioskowania schematu.</param>
        <summary>Stosuje schemat XML z określonego pliku do <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException"><see cref="T:System.Security.Permissions.FileIOPermission" />nie jest ustawiona na <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Odczytywanie i zapisywanie plików. Powiązane wartość typu wyliczeniowego: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" />.</permission>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="InferXmlSchema">
      <MemberSignature Language="C#" Value="public void InferXmlSchema (System.Xml.XmlReader reader, string[] nsArray);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InferXmlSchema(class System.Xml.XmlReader reader, string[] nsArray) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InferXmlSchema(System.Xml.XmlReader,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub InferXmlSchema (reader As XmlReader, nsArray As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InferXmlSchema(System::Xml::XmlReader ^ reader, cli::array &lt;System::String ^&gt; ^ nsArray);" />
      <MemberSignature Language="F#" Value="member this.InferXmlSchema : System.Xml.XmlReader * string[] -&gt; unit" Usage="dataSet.InferXmlSchema (reader, nsArray)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="nsArray" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="reader">, <see langword="XMLReader" /> Z którego ma zostać odczytany schemat.</param>
        <param name="nsArray">Tablica ciągów nazw Uniform Resource Identifier (URI), które mają zostać wykluczone z wnioskowania schematu.</param>
        <summary>Stosuje schemat XML od określonego <see cref="T:System.Xml.XmlReader" /> <see cref="T:System.Data.DataSet" />do.</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Initialized">
      <MemberSignature Language="C#" Value="public event EventHandler Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataSet.Initialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Initialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ Initialized;" />
      <MemberSignature Language="F#" Value="member this.Initialized : EventHandler " Usage="member this.Initialized : System.EventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.ComponentModel.ISupportInitializeNotification.Initialized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po <see cref="T:System.Data.DataSet" /> zainicjowaniu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji, zobacz <xref:System.Data.DataSet.IsInitialized%2A>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="InitializeDerivedDataSet">
      <MemberSignature Language="C#" Value="protected virtual void InitializeDerivedDataSet ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InitializeDerivedDataSet() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.InitializeDerivedDataSet" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub InitializeDerivedDataSet ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InitializeDerivedDataSet();" />
      <MemberSignature Language="F#" Value="abstract member InitializeDerivedDataSet : unit -&gt; unit&#xA;override this.InitializeDerivedDataSet : unit -&gt; unit" Usage="dataSet.InitializeDerivedDataSet " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Deserializować wszystkie dane tabel z pliku binarnego lub strumienia XML.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBinarySerialized">
      <MemberSignature Language="C#" Value="protected bool IsBinarySerialized (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool IsBinarySerialized(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.IsBinarySerialized(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Function IsBinarySerialized (info As SerializationInfo, context As StreamingContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool IsBinarySerialized(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="member this.IsBinarySerialized : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; bool" Usage="dataSet.IsBinarySerialized (info, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="info"><see cref="T:System.Runtime.Serialization.SerializationInfo" /> Obiekt.</param>
        <param name="context"><see cref="T:System.Runtime.Serialization.StreamingContext" /> Obiekt.</param>
        <summary>Sprawdza format serializowanej reprezentacji <see langword="DataSet" />.</summary>
        <returns><see langword="true" />Jeśli określony <see cref="T:System.Runtime.Serialization.SerializationInfo" /> <see langword="DataSet" /> reprezentuje serializowany w formacie binarnym, <see langword="false" /> w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element członkowski obsługuje infrastrukturę programu .NET Framework i nie jest przeznaczony do użycia bezpośrednio w kodzie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInitialized">
      <MemberSignature Language="C#" Value="public bool IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.IsInitialized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInitialized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitialized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInitialized : bool" Usage="System.Data.DataSet.IsInitialized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.ISupportInitializeNotification.IsInitialized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Data.DataSet" /> jest zainicjowany.</summary>
        <value><see langword="true" />Aby wskazać, że składnik został zakończony inicjalizacją; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwraca stan <xref:System.Data.DataSet> podczas konstruowania, na przykład przez program Visual Studio. Metoda ustawia ją na `false` i <xref:System.Data.DataSet.EndInit%2A> Metoda ustawia ją na `true`. <xref:System.Data.DataSet.BeginInit%2A>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wypełnia wartości <see cref="T:System.Data.DataSet" /> wartościami ze źródła danych przy użyciu dostarczonego <see cref="T:System.Data.IDataReader" />elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda zawiera technikę wypełniania pojedynczego <xref:System.Data.DataTable> z <xref:System.Data.IDataReader> danymi pobieranymi z wystąpienia. <xref:System.Data.DataTable.Load%2A> Ta metoda zapewnia te same funkcje, ale umożliwia załadowanie wielu zestawów wyników z `IDataReader` do wielu tabel `DataSet`w obrębie.  
  
 Jeśli zawiera `DataSet` już wiersze, dane przychodzące ze źródła danych zostaną scalone z istniejącymi wierszami.  
  
 Metoda może być używana w kilku typowych scenariuszach, w których wszystkie wyśrodkowane są pobieranie danych z określonego źródła danych i dodawanie ich do bieżącego kontenera danych (w tym przypadku `DataSet`). `Load` W tych scenariuszach opisano standardowe użycie programu `DataSet`, opisujące jego zachowanie aktualizacji i scalania.  
  
 `DataSet` Synchronizuje lub aktualizuje z jednym podstawowym źródłem danych. Ścieżki `DataSet` są zmieniane, co pozwala na synchronizację z podstawowym źródłem danych. Ponadto program `DataSet` może akceptować dane przyrostowe z jednego lub większej liczby pomocniczych źródeł danych. `DataSet` Nie odpowiada za śledzenie zmian w celu umożliwienia synchronizacji z pomocniczym źródłem danych.  
  
 Mając te dwa hipotetyczne źródła danych, użytkownik może wymagać jednego z następujących zachowań:  
  
-   Zainicjuj `DataSet` z podstawowego źródła danych. W tym scenariuszu użytkownik chce zainicjować pustą `DataSet` wartość z poziomu podstawowego źródła danych. Co najmniej jedna zawartość elementu DataTable jest modyfikowana. Później użytkownik zamierza propagować zmiany z powrotem do podstawowego źródła danych.  
  
-   Zachowaj zmiany i zsynchronizuj je ponownie z podstawowym źródłem danych. W tym scenariuszu użytkownik chce wykonać `DataSet` wypełnienie w poprzednim scenariuszu i przeprowadzić synchronizację przyrostową z podstawowym źródłem danych, zachowując modyfikacje wprowadzone `DataSet`w.  
  
-   Przyrostowe źródło danych z pomocniczych źródeł danych. W tym scenariuszu użytkownik chce scalić zmiany z jednego lub kilku dodatkowych źródeł danych i propagować te zmiany z powrotem do podstawowego źródła danych.  
  
 `Load` Metoda wykonuje wszystkie te scenariusze. Ta metoda pozwala określić parametr opcji ładowania wskazujący sposób, w <xref:System.Data.DataTable> jaki wiersze już łączą się z ładowanymi wierszami. W poniższej tabeli opisano trzy opcje ładowania dostarczone przez <xref:System.Data.LoadOption> Wyliczenie. W każdym przypadku opis wskazuje zachowanie, gdy klucz podstawowy wiersza w danych przychodzących jest zgodny z kluczem podstawowym istniejącego wiersza.  
  
|Opcja ładowania|Opis|  
|-----------------|-----------------|  
|`PreserveChanges`wartooć|Aktualizuje oryginalną wersję wiersza za pomocą wartości wiersza przychodzącego.|  
|`OverwriteChanges`|Aktualizuje bieżące i oryginalne wersje wiersza za pomocą wartości wiersza przychodzącego.|  
|`Upsert`|Aktualizuje bieżącą wersję wiersza za pomocą wartości wiersza przychodzącego.|  
  
 Ogólnie rzecz biorąc, `PreserveChanges` opcje `OverwriteChanges` i są przeznaczone dla scenariuszy, w których użytkownik musi zsynchronizować te `DataSet` zmiany z podstawowym źródłem danych. `Upsert` Opcja ułatwia agregowanie zmian z jednego lub większej liczby pomocniczych źródeł danych.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption, params System.Data.DataTable[] tables);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption, class System.Data.DataTable[] tables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Data::IDataReader ^ reader, System::Data::LoadOption loadOption, ... cli::array &lt;System::Data::DataTable ^&gt; ^ tables);" />
      <MemberSignature Language="F#" Value="member this.Load : System.Data.IDataReader * System.Data.LoadOption * System.Data.DataTable[] -&gt; unit" Usage="dataSet.Load (reader, loadOption, tables)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="tables" Type="System.Data.DataTable[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-2.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="reader"><see cref="T:System.Data.IDataReader" /> Zawiera co najmniej jeden zestaw wyników.</param>
        <param name="loadOption">Wartość z <see cref="T:System.Data.LoadOption" /> wyliczenia, która wskazuje, jak wiersze znajdujące się <see cref="T:System.Data.DataTable" /> już w wystąpieniach w obrębie <see cref="T:System.Data.DataSet" /> zostaną połączone z przychodzącymi wierszami, które mają ten sam klucz podstawowy.</param>
        <param name="tables">Tablica <see cref="T:System.Data.DataTable" /> wystąpień, z <see cref="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.DataTable[])" /> której Metoda pobiera nazwy i informacje o przestrzeni nazw. Każda z tych tabel musi być członkiem <see cref="T:System.Data.DataTableCollection" /> zawartego w tym <see cref="T:System.Data.DataSet" />elemencie.</param>
        <summary>Wypełnia wartości wartościami ze źródła danych przy użyciu dostarczonej <see cref="T:System.Data.IDataReader" />tablicy <see cref="T:System.Data.DataTable" /> wystąpień, aby podać informacje o schemacie i przestrzeni nazw. <see cref="T:System.Data.DataSet" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda zawiera technikę wypełniania pojedynczego <xref:System.Data.DataTable> z <xref:System.Data.IDataReader> danymi pobieranymi z wystąpienia. <xref:System.Data.DataTable.Load%2A> Ta metoda zapewnia te same funkcje, ale umożliwia załadowanie wielu zestawów wyników z <xref:System.Data.IDataReader> do wielu tabel <xref:System.Data.DataSet>w obrębie.  
  
> [!NOTE]
>  Operacja ładowania zakończy się niepowodzeniem <xref:System.InvalidOperationException> z komunikatem o ewentualnej liczbie kolumn danych `reader` źródłowych w przychodzących kolumnach.  
  
 Parametr pozwala określić sposób, w jaki dane importowane mają współdziałać z istniejącymi danymi i mogą być dowolnymi wartościami <xref:System.Data.LoadOption> z wyliczenia. `loadOption` Zapoznaj się z dokumentacją <xref:System.Data.DataTable> metody, <xref:System.Data.DataTable.Load%2A> Aby uzyskać więcej informacji na temat używania tego parametru.  
  
 Parametr umożliwia określenie <xref:System.Data.DataTable> tablicy wystąpień, wskazując kolejność tabel odpowiadających każdemu zestawowi wyników załadowanemu z czytnika. `tables` Metoda wypełnia każde dostarczone <xref:System.Data.DataTable> wystąpienie danymi z jednego zestawu wyników z czytnika danych źródłowych. <xref:System.Data.DataSet.Load%2A> Po każdym zestawie <xref:System.Data.DataSet.Load%2A> wyników Metoda przechodzi do następnego zestawu wyników w ramach czytnika, dopóki nie będzie więcej zestawów wyników.  
  
 Schemat rozpoznawania nazw dla tej metody jest taki sam, jak następują <xref:System.Data.Common.DbDataAdapter.Fill%2A> metody <xref:System.Data.Common.DbDataAdapter> klasy.  
  
   
  
## Examples  
 Poniższy przykład <xref:System.Data.DataSet>tworzy nowy, dodaje dwa <xref:System.Data.DataTable> wystąpienia do <xref:System.Data.DataSet>, a następnie wypełnia <xref:System.Data.DataSet> przy użyciu <xref:System.Data.DataSet.Load%2A> metody, pobierając dane z <xref:System.Data.DataTableReader> , który zawiera dwa zestawy wyników. Na koniec przykład wyświetla zawartość tabel w oknie konsoli.  
  
 [!code-csharp[DataWorks DataSet.LoadTables#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.LoadTables/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.LoadTables#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.LoadTables/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption, params string[] tables);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption, string[] tables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Data::IDataReader ^ reader, System::Data::LoadOption loadOption, ... cli::array &lt;System::String ^&gt; ^ tables);" />
      <MemberSignature Language="F#" Value="member this.Load : System.Data.IDataReader * System.Data.LoadOption * string[] -&gt; unit" Usage="dataSet.Load (reader, loadOption, tables)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="tables" Type="System.String[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-2.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="reader"><see cref="T:System.Data.IDataReader" /> Zawiera co najmniej jeden zestaw wyników.</param>
        <param name="loadOption">Wartość z <see cref="T:System.Data.LoadOption" /> wyliczenia, która wskazuje, jak wiersze znajdujące się <see cref="T:System.Data.DataTable" /> już w wystąpieniach w obrębie <see langword="DataSet" /> zostaną połączone z przychodzącymi wierszami, które mają ten sam klucz podstawowy.</param>
        <param name="tables">Tablica ciągów, z której <see langword="Load" /> Metoda pobiera informacje o nazwie tabeli.</param>
        <summary>Wypełnia wartości wartościami ze źródła danych przy użyciu dostarczonej <see cref="T:System.Data.IDataReader" />tablicy ciągów, aby podać nazwy tabel w <see langword="DataSet" />. <see cref="T:System.Data.DataSet" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda zawiera technikę wypełniania pojedynczego <xref:System.Data.DataTable> z <xref:System.Data.IDataReader> danymi pobieranymi z wystąpienia. <xref:System.Data.DataTable.Load%2A> Ta metoda zapewnia te same funkcje, ale umożliwia załadowanie wielu zestawów wyników z `IDataReader` do wielu tabel `DataSet`w obrębie.  
  
> [!NOTE]
>  Operacja ładowania zakończy się niepowodzeniem <xref:System.InvalidOperationException> z komunikatem o ewentualnej liczbie kolumn danych `reader` źródłowych w przychodzących kolumnach.  
  
 Parametr pozwala określić sposób, w jaki dane importowane mają współdziałać z istniejącymi danymi i mogą być dowolnymi wartościami <xref:System.Data.LoadOption> z wyliczenia. `loadOption` Zapoznaj się z dokumentacją <xref:System.Data.DataTable.Load%2A> metody, aby uzyskać więcej informacji na temat używania tego parametru.  
  
 `tables` Parametr pozwala określić tablicę nazw tabel, wskazując kolejność tabel odpowiadających każdemu zestawowi wyników załadowanemu z czytnika. Metoda próbuje znaleźć tabelę `DataSet` w zgodnej z nazwą znalezioną w tablicy nazw tabel w odpowiedniej kolejności. `Load` W przypadku znalezienia zgodnej tabeli zostanie ona załadowana z zawartością bieżącego zestawu wyników. Jeśli nie odnaleziono zgodnej tabeli, tabela zostanie utworzona przy użyciu nazwy podanej w tablicy nazw tabel, a schemat nowej tabeli zostanie wywnioskowany na podstawie zestawu wyników. Po każdym zestawie `Load` wyników Metoda przechodzi do następnego zestawu wyników w ramach czytnika, dopóki nie będzie więcej zestawów wyników.  
  
 Domyślna przestrzeń nazw skojarzona `DataSet`z, jeśli istnieje, jest skojarzona z każdym `DataTable`nowo utworzonym. Schemat rozpoznawania nazw dla tej metody jest taki sam, jak następują <xref:System.Data.Common.DbDataAdapter.Fill%2A> metody <xref:System.Data.Common.DbDataAdapter> klasy.  
  
   
  
## Examples  
 Poniższy przykład aplikacji konsolowej najpierw tworzy tabele i ładuje dane z czytnika do <xref:System.Data.DataSet>, `Load` przy użyciu metody. Przykład dodaje tabele do <xref:System.Data.DataSet> a i próbuje wypełnić tabele danymi <xref:System.Data.DataTableReader>z. W tym przykładzie, ponieważ parametry przesłane do `Load` metody wskazują nazwę tabeli, która nie istnieje `Load` , metoda tworzy nową tabelę do dopasowania do nazwy przekazaną jako parametr. Po załadowaniu danych przykład wyświetla zawartość wszystkich tabel w oknie konsoli.  
  
 [!code-csharp[DataWorks DataSet.LoadString#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.LoadString/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.LoadString#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.LoadString/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public virtual void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption, System.Data.FillErrorEventHandler errorHandler, params System.Data.DataTable[] tables);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption, class System.Data.FillErrorEventHandler errorHandler, class System.Data.DataTable[] tables) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Load(System::Data::IDataReader ^ reader, System::Data::LoadOption loadOption, System::Data::FillErrorEventHandler ^ errorHandler, ... cli::array &lt;System::Data::DataTable ^&gt; ^ tables);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Data.IDataReader * System.Data.LoadOption * System.Data.FillErrorEventHandler * System.Data.DataTable[] -&gt; unit&#xA;override this.Load : System.Data.IDataReader * System.Data.LoadOption * System.Data.FillErrorEventHandler * System.Data.DataTable[] -&gt; unit" Usage="dataSet.Load (reader, loadOption, errorHandler, tables)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="errorHandler" Type="System.Data.FillErrorEventHandler" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="tables" Type="System.Data.DataTable[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-2.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="reader"><see cref="T:System.Data.IDataReader" /> Zawiera co najmniej jeden zestaw wyników.</param>
        <param name="loadOption">Wartość z <see cref="T:System.Data.LoadOption" /> wyliczenia, która wskazuje, jak wiersze znajdujące się <see cref="T:System.Data.DataTable" /> już w wystąpieniach w obrębie <see cref="T:System.Data.DataSet" /> zostaną połączone z przychodzącymi wierszami, które mają ten sam klucz podstawowy.</param>
        <param name="errorHandler"><see cref="T:System.Data.FillErrorEventHandler" /> Delegat do wywołania, gdy wystąpi błąd podczas ładowania danych.</param>
        <param name="tables">Tablica <see cref="T:System.Data.DataTable" /> wystąpień, z <see cref="M:System.Data.DataSet.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler,System.Data.DataTable[])" /> której Metoda pobiera nazwy i informacje o przestrzeni nazw.</param>
        <summary>Wypełnia wartości wartościami ze źródła danych przy użyciu dostarczonej <see cref="T:System.Data.IDataReader" />tablicy <see cref="T:System.Data.DataTable" /> wystąpień, aby podać informacje o schemacie i przestrzeni nazw. <see cref="T:System.Data.DataSet" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda zawiera technikę wypełniania pojedynczego <xref:System.Data.DataTable> z <xref:System.Data.IDataReader> danymi pobieranymi z wystąpienia. <xref:System.Data.DataTable.Load%2A> Ta metoda zapewnia te same funkcje, ale umożliwia załadowanie wielu zestawów wyników z <xref:System.Data.IDataReader> do wielu tabel <xref:System.Data.DataSet>w obrębie.  
  
> [!NOTE]
>  Operacja ładowania zakończy się niepowodzeniem <xref:System.InvalidOperationException> z komunikatem o ewentualnej liczbie kolumn danych `reader` źródłowych w przychodzących kolumnach.  
  
 Parametr pozwala określić sposób, w jaki dane importowane mają współdziałać z istniejącymi danymi i mogą być dowolnymi wartościami <xref:System.Data.LoadOption> z wyliczenia. `loadOption` Zapoznaj się z dokumentacją <xref:System.Data.DataTable> metody, <xref:System.Data.DataTable.Load%2A> Aby uzyskać więcej informacji na temat używania tego parametru.  
  
 `errorHandler` Parametr<xref:System.Data.FillErrorEventHandler> jest delegatem, który odwołuje się do procedury, która jest wywoływana, gdy wystąpi błąd podczas ładowania danych. Parametr przesłany do procedury zawiera właściwości, które umożliwiają pobranie informacji o błędzie, który wystąpił, bieżący wiersz danych <xref:System.Data.DataTable> i wypełnienie. <xref:System.Data.FillErrorEventArgs> Dzięki temu mechanizmowi delegata, a nie prostszym blokiem try/catch, można określić błąd, obsłużyć sytuację i kontynuować przetwarzanie, jeśli chcesz. Parametr dostarcza właściwość: Ustaw tę właściwość na `true` , aby wskazać, że błąd został obsłużony i chcesz kontynuować przetwarzanie; ustaw właściwość na `false` , aby wskazać, że chcesz zatrzymać przetwarzanie. <xref:System.Data.FillErrorEventArgs.Continue%2A> <xref:System.Data.FillErrorEventArgs> Należy pamiętać, że ustawienie właściwości `false` powoduje, że kod, który wyzwolił problem, zgłosić wyjątek.  
  
 Parametr umożliwia określenie <xref:System.Data.DataTable> tablicy wystąpień, wskazując kolejność tabel odpowiadających każdemu zestawowi wyników załadowanemu z czytnika. `tables` Metoda wypełnia każde dostarczone <xref:System.Data.DataTable> wystąpienie danymi z jednego zestawu wyników z czytnika danych źródłowych. <xref:System.Data.DataSet.Load%2A> Po każdym zestawie <xref:System.Data.DataSet.Load%2A> wyników Metoda przechodzi do następnego zestawu wyników w ramach czytnika, dopóki nie będzie więcej zestawów wyników.  
  
 Schemat rozpoznawania nazw dla tej metody jest taki sam, jak następują <xref:System.Data.Common.DbDataAdapter.Fill%2A> metody <xref:System.Data.Common.DbDataAdapter> klasy.  
  
   
  
## Examples  
 Poniższy przykład dodaje tabelę do <xref:System.Data.DataSet>, a następnie próbuje <xref:System.Data.DataSet.Load%2A> użyć metody do ładowania danych z programu <xref:System.Data.DataTableReader> zawierającego niezgodny schemat. Zamiast zalewkowania błędu, w tym przykładzie używa <xref:System.Data.FillErrorEventHandler> delegata do zbadania i obsłużenia błędu. Dane wyjściowe są wyświetlane w oknie konsoli.  
  
 [!code-csharp[DataWorks DataSet.Load#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.Load/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.Load#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.Load/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Locale">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo Locale { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo Locale" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Locale" />
      <MemberSignature Language="VB.NET" Value="Public Property Locale As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ Locale { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Locale : System.Globalization.CultureInfo with get, set" Usage="System.Data.DataSet.Locale" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetLocaleDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia informacje o ustawieniach regionalnych używane do porównywania ciągów w tabeli.</summary>
        <value>A <see cref="T:System.Globalization.CultureInfo" /> , który zawiera dane dotyczące ustawień regionalnych komputera użytkownika. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.Locale%2A> Właściwość określa ustawienia regionalne, dla których ma zastosowanie sortowanie.  
  
 <xref:System.Data.DataSet.Locale%2A> Domyślnie ustawienie `DataSet` dla elementu <xref:System.Data.DataSet> ustawia <xref:System.Data.DataSet.Locale%2A> również dla każdego <xref:System.Data.DataTable> obiektu w tej samej wartości.  
  
> [!NOTE]
>  W kolumnach zawierających wyrażenia <xref:System.StringComparison.InvariantCulture> jest używana. Wartość <xref:System.StringComparison.CurrentCulture> jest ignorowana.  
  
   
  
## Examples  
 Poniższy <xref:System.Globalization.CultureInfo> przykład pobiera <xref:System.Data.DataSet> i drukuje <xref:System.Globalization.CultureInfo.DisplayName%2A> właściwości i <xref:System.Globalization.CultureInfo.EnglishName%2A> .  
  
 [!code-vb[Classic WebData DataSet.Locale Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Locale Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Merge">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Data.DataSet" />Scala określony <see langword="DataTable" />, <see cref="T:System.Data.DataTable" />lub tablicę <see cref="T:System.Data.DataRow" /> obiektów w bieżącym <see langword="DataSet" /> lub.</summary>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataRow[] rows);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataRow[] rows) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataRow[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Merge (rows As DataRow())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(cli::array &lt;System::Data::DataRow ^&gt; ^ rows);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataRow[] -&gt; unit" Usage="dataSet.Merge rows" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rows" Type="System.Data.DataRow[]" />
      </Parameters>
      <Docs>
        <param name="rows">Tablica <see langword="DataRow" /> obiektów do scalenia z <see langword="DataSet" />.</param>
        <summary>Scala tablicę <see cref="T:System.Data.DataRow" /> obiektów w bieżącym <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda służy do scalania dwóch <xref:System.Data.DataSet> obiektów, które mają bardzo podobne schematy. <xref:System.Data.DataSet.Merge%2A> Scalanie jest zwykle używane w aplikacji klienckiej w celu uwzględnienia najnowszych zmian ze źródła danych w istniejącym <xref:System.Data.DataSet>. Dzięki temu aplikacja kliencka może odświeżyć <xref:System.Data.DataSet> najnowsze dane ze źródła danych.  
  
 Metoda jest zwykle wywoływana na końcu serii procedur, które obejmują sprawdzanie poprawności zmian, uzgadnianie błędów, aktualizowanie źródła danych ze zmianami i odświeżanie istniejących <xref:System.Data.DataSet>. <xref:System.Data.DataSet.Merge%2A>  
  
 W aplikacji klienckiej często istnieje pojedynczy przycisk, który użytkownik może kliknąć, który zbiera zmienione dane i weryfikuje je przed wysłaniem ich z powrotem do składnika warstwy środkowej. W tym scenariuszu <xref:System.Data.DataSet.GetChanges%2A> Metoda jest wywoływana po raz pierwszy. Ta metoda zwraca sekundę <xref:System.Data.DataSet> zoptymalizowane pod kątem walidacji i scalania. Ten drugi <xref:System.Data.DataSet> obiekt zawiera <xref:System.Data.DataTable> tylko obiekty i <xref:System.Data.DataRow> , które zostały zmienione, co spowodowało powstanie podzestawu oryginału <xref:System.Data.DataSet>. Ten podzbiór jest zwykle mniejszy i w ten sposób bardziej wydajnie przeszedł z powrotem do składnika warstwy środkowej. Składnik warstwy środkowej aktualizuje oryginalne źródło danych zmianami za pomocą procedur składowanych. Warstwa środkowa może następnie wysłać do tyłu nową <xref:System.Data.DataSet> , która zawiera oryginalne dane, oraz najnowsze dane ze źródła danych (przez ponowne uruchomienie oryginalnego zapytania) lub może wysłać do niego wszystkie zmiany, które zostały wprowadzone w tym źródle danych. (Na przykład, jeśli źródło danych automatycznie tworzy unikatowe wartości klucza podstawowego, te wartości mogą być propagowane z powrotem do aplikacji klienta). W obu przypadkach zwrócone <xref:System.Data.DataSet> mogą zostać scalone z powrotem do oryginalnej <xref:System.Data.DataSet> aplikacji klienckiej za pomocą <xref:System.Data.DataSet.Merge%2A> metody.  
  
 Gdy metoda jest wywoływana, schematy dwóch <xref:System.Data.DataSet> obiektów są porównywane, ponieważ możliwe jest, że schematy zostały zmienione. <xref:System.Data.DataSet.Merge%2A> Na przykład w scenariuszu między firmami nowe kolumny mogły zostać dodane do schematu XML przez proces zautomatyzowany. Jeśli źródło <xref:System.Data.DataSet> zawiera elementy schematu (dodane <xref:System.Data.DataColumn> obiekty), które nie znajdują się w elemencie docelowym, elementy schematu można dodać do elementu docelowego przez ustawienie `missingSchemaAction` argumentu na `MissingSchemaAction.Add`. W takim przypadku scalone <xref:System.Data.DataSet> zawiera dodany schemat i dane.  
  
 Po scaleniu schematów dane są scalane.  
  
 Podczas scalania <xref:System.Data.DataSet> nowego źródła w miejscu docelowym wszystkie wiersze źródłowe <xref:System.Data.DataRowState> o wartości `Unchanged`, `Modified`lub `Deleted` są dopasowywane do wierszy docelowych z tymi samymi wartościami klucza podstawowego. Wiersze źródłowe z <xref:System.Data.DataRowState> `Added` wartością są dopasowywane do nowych wierszy docelowych z tymi samymi wartościami klucza podstawowego, co nowe wiersze źródłowe.  
  
 Podczas scalania ograniczenia są wyłączone. Jeśli nie można włączyć żadnych ograniczeń na końcu scalania, <xref:System.Data.ConstraintException> zostanie wygenerowana, a scalone dane zostaną zachowane, gdy ograniczenia są wyłączone. W tym przypadku <xref:System.Data.DataSet.EnforceConstraints%2A> właściwość jest ustawiona na `false`, a wszystkie wiersze, które są nieprawidłowe, są oznaczone jako błąd. Przed próbą zresetowania <xref:System.Data.DataSet.EnforceConstraints%2A> właściwości do `true`programu należy rozwiązać błędy.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataSet dataSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataSet dataSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataSet ^ dataSet);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataSet -&gt; unit" Usage="dataSet.Merge dataSet" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
      </Parameters>
      <Docs>
        <param name="dataSet">, <see langword="DataSet" /> Których dane i schematy zostaną scalone.</param>
        <summary>Scala określony <see cref="T:System.Data.DataSet" /> i jego schemat w bieżącym <see langword="DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda służy do scalania dwóch <xref:System.Data.DataSet> obiektów, które mają bardzo podobne schematy. <xref:System.Data.DataSet.Merge%2A> Scalanie jest zwykle używane w aplikacji klienckiej w celu uwzględnienia najnowszych zmian ze źródła danych w istniejącym <xref:System.Data.DataSet>. Dzięki temu aplikacja kliencka może odświeżyć <xref:System.Data.DataSet> najnowsze dane ze źródła danych.  
  
 Metoda jest zwykle wywoływana na końcu serii procedur, które obejmują sprawdzanie poprawności zmian, uzgadnianie błędów, aktualizowanie źródła danych ze zmianami i odświeżanie istniejących <xref:System.Data.DataSet>. <xref:System.Data.DataSet.Merge%2A>  
  
 W aplikacji klienckiej często istnieje pojedynczy przycisk, który użytkownik może kliknąć, który zbiera zmienione dane i weryfikuje je przed wysłaniem ich z powrotem do składnika warstwy środkowej. W tym scenariuszu <xref:System.Data.DataSet.GetChanges%2A> Metoda jest wywoływana po raz pierwszy. Ta metoda zwraca sekundę <xref:System.Data.DataSet> zoptymalizowane pod kątem walidacji i scalania. Ten drugi <xref:System.Data.DataSet> obiekt zawiera <xref:System.Data.DataTable> tylko obiekty i <xref:System.Data.DataRow> , które zostały zmienione, co spowodowało powstanie podzestawu oryginału <xref:System.Data.DataSet>. Ten podzbiór jest zwykle mniejszy i w ten sposób bardziej wydajnie przeszedł z powrotem do składnika warstwy środkowej. Składnik warstwy środkowej aktualizuje oryginalne źródło danych zmianami za pomocą procedur składowanych. Warstwa środkowa może następnie wysłać do tyłu nową <xref:System.Data.DataSet> , która zawiera oryginalne dane, oraz najnowsze dane ze źródła danych (przez ponowne uruchomienie oryginalnego zapytania) lub może wysłać do niego wszystkie zmiany, które zostały wprowadzone w tym źródle danych. (Na przykład, jeśli źródło danych automatycznie tworzy unikatowe wartości klucza podstawowego, te wartości mogą być propagowane z powrotem do aplikacji klienta). W obu przypadkach zwrócone <xref:System.Data.DataSet> mogą zostać scalone z powrotem do oryginalnej <xref:System.Data.DataSet> aplikacji klienckiej za pomocą <xref:System.Data.DataSet.Merge%2A> metody.  
  
 Gdy metoda jest wywoływana, schematy dwóch <xref:System.Data.DataSet> obiektów są porównywane, ponieważ możliwe jest, że schematy zostały zmienione. <xref:System.Data.DataSet.Merge%2A> Na przykład w scenariuszu między firmami nowe kolumny mogły zostać dodane do schematu XML przez proces zautomatyzowany. Jeśli źródło <xref:System.Data.DataSet> zawiera elementy schematu (dodane <xref:System.Data.DataColumn> obiekty), które nie znajdują się w elemencie docelowym, elementy schematu można dodać do elementu docelowego przez ustawienie `missingSchemaAction` argumentu na `MissingSchemaAction.Add`. W takim przypadku scalone <xref:System.Data.DataSet> zawiera dodany schemat i dane.  
  
 Po scaleniu schematów dane są scalane.  
  
 Podczas scalania <xref:System.Data.DataSet> nowego źródła w miejscu docelowym wszystkie wiersze źródłowe <xref:System.Data.DataRowState> o wartości `Unchanged`, `Modified`lub `Deleted` są dopasowywane do wierszy docelowych z tymi samymi wartościami klucza podstawowego. Wiersze źródłowe z `DataRowState` `Added` wartością są dopasowywane do nowych wierszy docelowych z tymi samymi wartościami klucza podstawowego, co nowe wiersze źródłowe.  
  
 Podczas scalania ograniczenia są wyłączone. Jeśli nie można włączyć żadnych ograniczeń na końcu scalania, <xref:System.Data.ConstraintException> zostanie wygenerowane i scalone dane zostaną zachowane, gdy ograniczenia są wyłączone. W tym przypadku <xref:System.Data.DataSet.EnforceConstraints%2A> właściwość jest ustawiona na `false`, a wszystkie wiersze, które są nieprawidłowe, są oznaczone jako błąd. Przed próbą zresetowania <xref:System.Data.DataSet.EnforceConstraints%2A> właściwości do `true`programu należy rozwiązać błędy.  
  
   
  
## Examples  
 W poniższym przykładzie zastosowano <xref:System.Data.DataSet.GetChanges%2A>metody <xref:System.Data.DataSet>, Update i <xref:System.Data.DataSet.Merge%2A> .  
  
 [!code-csharp[Classic WebData DataSet.Merge Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Merge Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.ConstraintException">Nie można włączyć co najmniej jednego ograniczenia.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="dataSet" /> Ma<see langword="null" />wartość.</exception>
        <altmember cref="T:System.Data.ForeignKeyConstraint" />
        <altmember cref="M:System.Data.DataSet.GetChanges" />
        <altmember cref="T:System.Data.UniqueConstraint" />
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataTable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Merge (table As DataTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataTable ^ table);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataTable -&gt; unit" Usage="dataSet.Merge table" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
      </Parameters>
      <Docs>
        <param name="table">, <see cref="T:System.Data.DataTable" /> Których dane i schematy zostaną scalone.</param>
        <summary>Scala określony <see cref="T:System.Data.DataTable" /> i jego schemat w bieżącym <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda służy do scalania dwóch <xref:System.Data.DataSet> obiektów, które mają bardzo podobne schematy. <xref:System.Data.DataSet.Merge%2A> Scalanie jest zwykle używane w aplikacji klienckiej w celu uwzględnienia najnowszych zmian ze źródła danych w istniejącym <xref:System.Data.DataSet>. Dzięki temu aplikacja kliencka może odświeżyć <xref:System.Data.DataSet> najnowsze dane ze źródła danych.  
  
 Metoda jest zwykle wywoływana na końcu serii procedur, które obejmują sprawdzanie poprawności zmian, uzgadnianie błędów, aktualizowanie źródła danych ze zmianami i odświeżanie istniejących <xref:System.Data.DataSet>. <xref:System.Data.DataSet.Merge%2A>  
  
 W aplikacji klienckiej często istnieje pojedynczy przycisk, który użytkownik może kliknąć, który zbiera zmienione dane i weryfikuje je przed wysłaniem ich z powrotem do składnika warstwy środkowej. W tym scenariuszu <xref:System.Data.DataSet.GetChanges%2A> Metoda jest wywoływana po raz pierwszy. Ta metoda zwraca sekundę <xref:System.Data.DataSet> zoptymalizowane pod kątem walidacji i scalania. Ten drugi <xref:System.Data.DataSet> obiekt zawiera <xref:System.Data.DataTable> tylko obiekty i <xref:System.Data.DataRow> , które zostały zmienione, co spowodowało powstanie podzestawu oryginału <xref:System.Data.DataSet>. Ten podzbiór jest zwykle mniejszy i w ten sposób bardziej wydajnie przeszedł z powrotem do składnika warstwy środkowej. Składnik warstwy środkowej aktualizuje oryginalne źródło danych zmianami za pomocą procedur składowanych. Warstwa środkowa może następnie wysłać do tyłu nową <xref:System.Data.DataSet> , która zawiera oryginalne dane, oraz najnowsze dane ze źródła danych (przez ponowne uruchomienie oryginalnego zapytania) lub może wysłać do niego wszystkie zmiany, które zostały wprowadzone w tym źródle danych. (Na przykład, jeśli źródło danych automatycznie tworzy unikatowe wartości klucza podstawowego, te wartości mogą być propagowane z powrotem do aplikacji klienta). W obu przypadkach zwrócone <xref:System.Data.DataSet> mogą zostać scalone z powrotem do oryginalnej <xref:System.Data.DataSet> aplikacji klienckiej za pomocą <xref:System.Data.DataSet.Merge%2A> metody.  
  
 Gdy metoda jest wywoływana, schematy dwóch <xref:System.Data.DataSet> obiektów są porównywane, ponieważ możliwe jest, że schematy zostały zmienione. <xref:System.Data.DataSet.Merge%2A> Na przykład w scenariuszu między firmami nowe kolumny mogły zostać dodane do schematu XML przez proces zautomatyzowany. Jeśli źródło <xref:System.Data.DataSet> zawiera elementy schematu (dodane <xref:System.Data.DataColumn> obiekty), które nie znajdują się w elemencie docelowym, elementy schematu można dodać do elementu docelowego przez ustawienie `missingSchemaAction` argumentu na `MissingSchemaAction.Add`. W takim przypadku scalone <xref:System.Data.DataSet> zawiera dodany schemat i dane.  
  
 Po scaleniu schematów dane są scalane.  
  
 Podczas scalania <xref:System.Data.DataSet> nowego źródła w miejscu docelowym wszystkie wiersze źródłowe <xref:System.Data.DataRowState> o wartości `Unchanged`, `Modified`lub `Deleted` są dopasowywane do wierszy docelowych z tymi samymi wartościami klucza podstawowego. Wiersze źródłowe z `DataRowState` `Added` wartością są dopasowywane do nowych wierszy docelowych z tymi samymi wartościami klucza podstawowego, co nowe wiersze źródłowe.  
  
 Podczas scalania ograniczenia są wyłączone. Jeśli nie można włączyć żadnych ograniczeń na końcu scalania, <xref:System.Data.ConstraintException> zostanie wygenerowane i scalone dane zostaną zachowane, gdy ograniczenia są wyłączone. W tym przypadku <xref:System.Data.DataSet.EnforceConstraints%2A> właściwość jest ustawiona na `false`, a wszystkie wiersze, które są nieprawidłowe, są oznaczone jako błąd. Przed próbą zresetowania <xref:System.Data.DataSet.EnforceConstraints%2A> właściwości do `true`programu należy rozwiązać błędy.  
  
   
  
## Examples  
 Poniższy przykład tworzy prostą <xref:System.Data.DataSet> z jedną tabelą, dwiema kolumnami i dziesięciu wierszami. Zostanie utworzona <xref:System.Data.DataTable> sekunda, która jest identyczna z pierwszym. Do drugiej tabeli dodawane są dwa wiersze, które następnie są scalane w <xref:System.Data.DataSet>.  
  
 [!code-csharp[Classic WebData DataSet.Merge3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Merge3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="table" /> Ma<see langword="null" />wartość.</exception>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataSet dataSet, bool preserveChanges);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataSet dataSet, bool preserveChanges) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataSet ^ dataSet, bool preserveChanges);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataSet * bool -&gt; unit" Usage="dataSet.Merge (dataSet, preserveChanges)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="dataSet">, <see langword="DataSet" /> Których dane i schematy zostaną scalone.</param>
        <param name="preserveChanges"><see langword="true" />Aby zachować zmiany w bieżącym <see langword="DataSet" />; <see langword="false" />w przeciwnym razie.</param>
        <summary>Scala określony <see cref="T:System.Data.DataSet" /> i jego schemat z bieżącym <see langword="DataSet" />, zachowując lub odrzucając zmiany w tym <see langword="DataSet" /> zakresie zgodnie z podanym argumentem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda służy do scalania dwóch <xref:System.Data.DataSet> obiektów, które mają bardzo podobne schematy. <xref:System.Data.DataSet.Merge%2A> Scalanie jest zwykle używane w aplikacji klienckiej w celu uwzględnienia najnowszych zmian ze źródła danych w istniejącym <xref:System.Data.DataSet>. Dzięki temu aplikacja kliencka może odświeżyć <xref:System.Data.DataSet> najnowsze dane ze źródła danych.  
  
 Metoda jest zwykle wywoływana na końcu serii procedur, które obejmują sprawdzanie poprawności zmian, uzgadnianie błędów, aktualizowanie źródła danych ze zmianami i odświeżanie istniejących <xref:System.Data.DataSet>. <xref:System.Data.DataSet.Merge%2A>  
  
 W aplikacji klienckiej często istnieje pojedynczy przycisk, który użytkownik może kliknąć, który zbiera zmienione dane i weryfikuje je przed wysłaniem ich z powrotem do składnika warstwy środkowej. W tym scenariuszu <xref:System.Data.DataSet.GetChanges%2A> Metoda jest wywoływana po raz pierwszy. Ta metoda zwraca sekundę <xref:System.Data.DataSet> zoptymalizowane pod kątem walidacji i scalania. Ten drugi <xref:System.Data.DataSet> obiekt zawiera <xref:System.Data.DataTable> tylko obiekty i <xref:System.Data.DataRow> , które zostały zmienione, co spowodowało powstanie podzestawu oryginału <xref:System.Data.DataSet>. Ten podzbiór jest zwykle mniejszy i w ten sposób bardziej wydajnie przeszedł z powrotem do składnika warstwy środkowej. Składnik warstwy środkowej aktualizuje oryginalne źródło danych zmianami za pomocą procedur składowanych. Warstwa środkowa może następnie wysłać do tyłu nową <xref:System.Data.DataSet> , która zawiera oryginalne dane, oraz najnowsze dane ze źródła danych (przez ponowne uruchomienie oryginalnego zapytania) lub może wysłać do niego wszystkie zmiany, które zostały wprowadzone w tym źródle danych. (Na przykład, jeśli źródło danych automatycznie tworzy unikatowe wartości klucza podstawowego, te wartości mogą być propagowane z powrotem do aplikacji klienta). W obu przypadkach zwrócone <xref:System.Data.DataSet> mogą zostać scalone z powrotem do oryginalnej <xref:System.Data.DataSet> aplikacji klienckiej za pomocą <xref:System.Data.DataSet.Merge%2A> metody.  
  
 Gdy metoda jest wywoływana, schematy dwóch <xref:System.Data.DataSet> obiektów są porównywane, ponieważ możliwe jest, że schematy zostały zmienione. <xref:System.Data.DataSet.Merge%2A> Na przykład w scenariuszu między firmami nowe kolumny mogły zostać dodane do schematu XML przez proces zautomatyzowany. Jeśli źródło <xref:System.Data.DataSet> zawiera elementy schematu (dodane <xref:System.Data.DataColumn> obiekty), które nie znajdują się w elemencie docelowym, elementy schematu można dodać do elementu docelowego przez ustawienie `missingSchemaAction` argumentu na `MissingSchemaAction.Add`. W takim przypadku scalone <xref:System.Data.DataSet> zawiera dodany schemat i dane.  
  
 Po scaleniu schematów dane są scalane.  
  
 Podczas scalania <xref:System.Data.DataSet> nowego źródła w miejscu docelowym wszystkie wiersze źródłowe <xref:System.Data.DataRowState> o wartości `Unchanged`, `Modified`lub `Deleted` są dopasowywane do wierszy docelowych z tymi samymi wartościami klucza podstawowego. Wiersze źródłowe z `DataRowState` `Added` wartością są dopasowywane do nowych wierszy docelowych z tymi samymi wartościami klucza podstawowego, co nowe wiersze źródłowe.  
  
 Podczas scalania ograniczenia są wyłączone. Jeśli nie można włączyć żadnych ograniczeń na końcu scalania, <xref:System.Data.ConstraintException> zostanie wygenerowane i scalone dane zostaną zachowane, gdy ograniczenia są wyłączone. W tym przypadku <xref:System.Data.DataSet.EnforceConstraints%2A> właściwość jest ustawiona na `false`, a wszystkie wiersze, które są nieprawidłowe, są oznaczone jako błąd. Przed próbą zresetowania <xref:System.Data.DataSet.EnforceConstraints%2A> właściwości do `true`programu należy rozwiązać błędy.  
  
   
  
## Examples  
 Poniższy przykład tworzy prostą <xref:System.Data.DataSet> z jedną tabelą, dwiema kolumnami i dziesięciu wierszami. Po dodaniu dziesięciu wierszy są zmieniane dwie wartości i zostanie dodany jeden wiersz. Podzestaw zmienionych danych jest tworzony przy użyciu <xref:System.Data.DataSet.GetChanges%2A> metody. Po rozpoczęciu błędów dane podzestawu są scalane z <xref:System.Data.DataSet>oryginałem.  
  
 [!code-csharp[Classic WebData DataSet.GetChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.GetChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.GetChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Data.ForeignKeyConstraint" />
        <altmember cref="T:System.Data.UniqueConstraint" />
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataRow[] rows, bool preserveChanges, System.Data.MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataRow[] rows, bool preserveChanges, valuetype System.Data.MissingSchemaAction missingSchemaAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataRow[],System.Boolean,System.Data.MissingSchemaAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(cli::array &lt;System::Data::DataRow ^&gt; ^ rows, bool preserveChanges, System::Data::MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataRow[] * bool * System.Data.MissingSchemaAction -&gt; unit" Usage="dataSet.Merge (rows, preserveChanges, missingSchemaAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rows" Type="System.Data.DataRow[]" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
        <Parameter Name="missingSchemaAction" Type="System.Data.MissingSchemaAction" />
      </Parameters>
      <Docs>
        <param name="rows">Tablica <see cref="T:System.Data.DataRow" /> obiektów do scalenia z <see langword="DataSet" />.</param>
        <param name="preserveChanges"><see langword="true" />Aby zachować zmiany w <see langword="DataSet" />; w <see langword="false" />przeciwnym razie.</param>
        <param name="missingSchemaAction">Jedna z <see cref="T:System.Data.MissingSchemaAction" /> wartości.</param>
        <summary>Scala tablicę <see cref="T:System.Data.DataRow" /> obiektów w bieżące <see cref="T:System.Data.DataSet" />, zachowywanie lub <see langword="DataSet" /> odrzucanie zmian w i obsługa niezgodnego schematu zgodnie z podanymi argumentami.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda służy do scalania dwóch <xref:System.Data.DataSet> obiektów, które mają bardzo podobne schematy. <xref:System.Data.DataSet.Merge%2A> Scalanie jest zwykle używane w aplikacji klienckiej w celu uwzględnienia najnowszych zmian ze źródła danych w istniejącym <xref:System.Data.DataSet>. Dzięki temu aplikacja kliencka może odświeżyć <xref:System.Data.DataSet> najnowsze dane ze źródła danych.  
  
 Metoda jest zwykle wywoływana na końcu serii procedur, które obejmują sprawdzanie poprawności zmian, uzgadnianie błędów, aktualizowanie źródła danych ze zmianami i odświeżanie istniejących <xref:System.Data.DataSet>. <xref:System.Data.DataSet.Merge%2A>  
  
 W aplikacji klienckiej często istnieje pojedynczy przycisk, który użytkownik może kliknąć, który zbiera zmienione dane i weryfikuje je przed wysłaniem ich z powrotem do składnika warstwy środkowej. W tym scenariuszu <xref:System.Data.DataSet.GetChanges%2A> Metoda jest wywoływana po raz pierwszy. Ta metoda zwraca sekundę <xref:System.Data.DataSet> zoptymalizowane pod kątem walidacji i scalania. Ten drugi <xref:System.Data.DataSet> obiekt zawiera <xref:System.Data.DataTable> tylko obiekty i <xref:System.Data.DataRow> , które zostały zmienione, co spowodowało powstanie podzestawu oryginału <xref:System.Data.DataSet>. Ten podzbiór jest zwykle mniejszy i w ten sposób bardziej wydajnie przeszedł z powrotem do składnika warstwy środkowej. Składnik warstwy środkowej aktualizuje oryginalne źródło danych zmianami za pomocą procedur składowanych. Warstwa środkowa może następnie wysłać do tyłu nową <xref:System.Data.DataSet> , która zawiera oryginalne dane, oraz najnowsze dane ze źródła danych (przez ponowne uruchomienie oryginalnego zapytania) lub może wysłać do niego wszystkie zmiany, które zostały wprowadzone w tym źródle danych. (Na przykład, jeśli źródło danych automatycznie tworzy unikatowe wartości klucza podstawowego, te wartości mogą być propagowane z powrotem do aplikacji klienta). W obu przypadkach zwrócone <xref:System.Data.DataSet> mogą zostać scalone z powrotem do oryginalnej <xref:System.Data.DataSet> aplikacji klienckiej za pomocą <xref:System.Data.DataSet.Merge%2A> metody.  
  
 Aby ułatwić wyjaśnienie <xref:System.Data.DataSet.Merge%2A> metody, używamy "target", aby wyznaczać bieżącą <xref:System.Data.DataSet>, i "source", aby nazwać sekundę (parametr <xref:System.Data.DataSet>). Obiekt docelowy <xref:System.Data.DataSet> jest tak nazwany, ponieważ jest obiektem, na którym występuje akcja (Scalanie). Druga <xref:System.Data.DataSet> jest nazywana "źródłem", ponieważ zawarte w nim informacje nie zmieniają się, ale zamiast tego są scalane do <xref:System.Data.DataSet>bieżącego.  
  
 Gdy metoda jest wywoływana, schematy dwóch <xref:System.Data.DataSet> obiektów są porównywane, ponieważ możliwe jest, że schematy zostały zmienione. <xref:System.Data.DataSet.Merge%2A> Na przykład w scenariuszu między firmami nowe kolumny mogły zostać dodane do schematu XML przez proces zautomatyzowany. Jeśli źródło <xref:System.Data.DataSet> zawiera elementy schematu (dodane <xref:System.Data.DataColumn> obiekty), które nie znajdują się w elemencie docelowym, elementy schematu można dodać do elementu docelowego przez ustawienie `missingSchemaAction` argumentu na `MissingSchemaAction.Add`. W takim przypadku scalone <xref:System.Data.DataSet> zawiera dodany schemat i dane.  
  
 Po scaleniu schematów dane są scalane.  
  
 Podczas scalania <xref:System.Data.DataSet> nowego źródła w miejscu docelowym wszystkie wiersze źródłowe <xref:System.Data.DataRowState> o wartości `Unchanged`, `Modified`lub `Deleted` są dopasowywane do wierszy docelowych z tymi samymi wartościami klucza podstawowego. Wiersze źródłowe z `DataRowState` `Added` wartością są dopasowywane do nowych wierszy docelowych z tymi samymi wartościami klucza podstawowego, co nowe wiersze źródłowe.  
  
 Podczas scalania ograniczenia są wyłączone. Jeśli nie można włączyć żadnych ograniczeń na końcu scalania, <xref:System.Data.ConstraintException> zostanie wygenerowane i scalone dane zostaną zachowane, gdy ograniczenia są wyłączone. W tym przypadku <xref:System.Data.DataSet.EnforceConstraints%2A> właściwość jest ustawiona na `false`, a wszystkie wiersze, które są nieprawidłowe, są oznaczone jako błąd. Przed próbą zresetowania <xref:System.Data.DataSet.EnforceConstraints%2A> właściwości do `true`programu należy rozwiązać błędy.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataSet dataSet, bool preserveChanges, System.Data.MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataSet dataSet, bool preserveChanges, valuetype System.Data.MissingSchemaAction missingSchemaAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataSet,System.Boolean,System.Data.MissingSchemaAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataSet ^ dataSet, bool preserveChanges, System::Data::MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataSet * bool * System.Data.MissingSchemaAction -&gt; unit" Usage="dataSet.Merge (dataSet, preserveChanges, missingSchemaAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
        <Parameter Name="missingSchemaAction" Type="System.Data.MissingSchemaAction" />
      </Parameters>
      <Docs>
        <param name="dataSet">, <see langword="DataSet" /> Których dane i schematy zostaną scalone.</param>
        <param name="preserveChanges"><see langword="true" />Aby zachować zmiany w bieżącym <see langword="DataSet" />; <see langword="false" />w przeciwnym razie.</param>
        <param name="missingSchemaAction">Jedna z <see cref="T:System.Data.MissingSchemaAction" /> wartości.</param>
        <summary>Scala określony <see cref="T:System.Data.DataSet" /> i jego schemat z bieżącym <see langword="DataSet" />, zachowywaniem lub odrzucaniem zmian w bieżącym <see langword="DataSet" /> i obsługującym niezgodny schemat zgodnie z podanymi argumentami.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda służy do scalania dwóch <xref:System.Data.DataSet> obiektów, które mają bardzo podobne schematy. <xref:System.Data.DataSet.Merge%2A> Scalanie jest zwykle używane w aplikacji klienckiej w celu uwzględnienia najnowszych zmian ze źródła danych w istniejącym <xref:System.Data.DataSet>. Dzięki temu aplikacja kliencka może odświeżyć <xref:System.Data.DataSet> najnowsze dane ze źródła danych.  
  
 Metoda jest zwykle wywoływana na końcu serii procedur, które obejmują sprawdzanie poprawności zmian, uzgadnianie błędów, aktualizowanie źródła danych ze zmianami i odświeżanie istniejących <xref:System.Data.DataSet>. <xref:System.Data.DataSet.Merge%2A>  
  
 W aplikacji klienckiej często istnieje pojedynczy przycisk, który użytkownik może kliknąć, który zbiera zmienione dane i weryfikuje je przed wysłaniem ich z powrotem do składnika warstwy środkowej. W tym scenariuszu <xref:System.Data.DataSet.GetChanges%2A> Metoda jest wywoływana po raz pierwszy. Ta metoda zwraca sekundę <xref:System.Data.DataSet> zoptymalizowane pod kątem walidacji i scalania. Ten drugi <xref:System.Data.DataSet> obiekt zawiera <xref:System.Data.DataTable> tylko obiekty i <xref:System.Data.DataRow> , które zostały zmienione, co spowodowało powstanie podzestawu oryginału <xref:System.Data.DataSet>. Ten podzbiór jest zwykle mniejszy i w ten sposób bardziej wydajnie przeszedł z powrotem do składnika warstwy środkowej. Składnik warstwy środkowej aktualizuje oryginalne źródło danych zmianami za pomocą procedur składowanych. Warstwa środkowa może następnie wysłać do tyłu nową <xref:System.Data.DataSet> , która zawiera oryginalne dane, oraz najnowsze dane ze źródła danych (przez ponowne uruchomienie oryginalnego zapytania) lub może wysłać do niego wszystkie zmiany, które zostały wprowadzone w tym źródle danych. (Na przykład, jeśli źródło danych automatycznie tworzy unikatowe wartości klucza podstawowego, te wartości mogą być propagowane z powrotem do aplikacji klienta). W obu przypadkach zwrócone <xref:System.Data.DataSet> mogą zostać scalone z powrotem do oryginalnej <xref:System.Data.DataSet> aplikacji klienckiej za pomocą <xref:System.Data.DataSet.Merge%2A> metody.  
  
 Aby ułatwić wyjaśnienie <xref:System.Data.DataSet.Merge%2A> metody, używamy "target", aby wyznaczać bieżącą <xref:System.Data.DataSet>, i "source", aby nazwać sekundę (parametr <xref:System.Data.DataSet>). Obiekt docelowy <xref:System.Data.DataSet> jest tak nazwany, ponieważ jest obiektem, na którym występuje akcja (Scalanie). Druga <xref:System.Data.DataSet> jest nazywana "źródłem", ponieważ zawarte w nim informacje nie zmieniają się, ale zamiast tego są scalane do <xref:System.Data.DataSet>bieżącego.  
  
 Gdy metoda jest wywoływana, schematy dwóch <xref:System.Data.DataSet> obiektów są porównywane, ponieważ możliwe jest, że schematy zostały zmienione. <xref:System.Data.DataSet.Merge%2A> Na przykład w scenariuszu między firmami nowe kolumny mogły zostać dodane do schematu XML przez proces zautomatyzowany. Jeśli źródło <xref:System.Data.DataSet> zawiera elementy schematu (dodane <xref:System.Data.DataColumn> obiekty), które nie znajdują się w elemencie docelowym, elementy schematu można dodać do elementu docelowego przez ustawienie `missingSchemaAction` argumentu na `MissingSchemaAction.Add`. W takim przypadku scalone <xref:System.Data.DataSet> zawiera dodany schemat i dane.  
  
 Po scaleniu schematów dane są scalane.  
  
 Podczas scalania <xref:System.Data.DataSet> nowego źródła w miejscu docelowym wszystkie wiersze źródłowe <xref:System.Data.DataRowState> o wartości `Unchanged`, `Modified`lub `Deleted` są dopasowywane do wierszy docelowych z tymi samymi wartościami klucza podstawowego. Wiersze źródłowe z `DataRowState` `Added` wartością są dopasowywane do nowych wierszy docelowych z tymi samymi wartościami klucza podstawowego, co nowe wiersze źródłowe.  
  
 Podczas scalania ograniczenia są wyłączone. Jeśli nie można włączyć żadnych ograniczeń na końcu scalania, <xref:System.Data.ConstraintException> zostanie wygenerowane i scalone dane zostaną zachowane, gdy ograniczenia są wyłączone. W tym przypadku <xref:System.Data.DataSet.EnforceConstraints%2A> właściwość jest ustawiona na `false`, a wszystkie wiersze, które są nieprawidłowe, są oznaczone jako błąd. Przed próbą zresetowania <xref:System.Data.DataSet.EnforceConstraints%2A> właściwości do `true`programu należy rozwiązać błędy.  
  
   
  
## Examples  
 Poniższy przykład tworzy prostą <xref:System.Data.DataSet> z jedną tabelą, dwiema kolumnami i dziesięciu wierszami. Dwie wartości są zmieniane i zostanie dodany jeden wiersz. Podzestaw zmienionych danych jest tworzony przy użyciu <xref:System.Data.DataSet.GetChanges%2A> metody. Po rozpoczęciu uzgadniania błędów nowa kolumna zostanie dodana do podzestawu, zmieniając schemat. Gdy metoda jest wywoływana `missingSchemaAction` z ustawionym na `MissingSchemaAction.Add`, Nowa kolumna zostanie dodana do schematu oryginalnego <xref:System.Data.DataSet> obiektu. <xref:System.Data.DataSet.Merge%2A>  
  
 [!code-csharp[Classic WebData DataSet.Merge2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Merge2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="dataSet" /> Ma<see langword="null" />wartość.</exception>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table, bool preserveChanges, System.Data.MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table, bool preserveChanges, valuetype System.Data.MissingSchemaAction missingSchemaAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataTable ^ table, bool preserveChanges, System::Data::MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataTable * bool * System.Data.MissingSchemaAction -&gt; unit" Usage="dataSet.Merge (table, preserveChanges, missingSchemaAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
        <Parameter Name="missingSchemaAction" Type="System.Data.MissingSchemaAction" />
      </Parameters>
      <Docs>
        <param name="table">, <see langword="DataTable" /> Których dane i schematy zostaną scalone.</param>
        <param name="preserveChanges">Jedna z <see cref="T:System.Data.MissingSchemaAction" /> wartości.</param>
        <param name="missingSchemaAction"><see langword="true" />Aby zachować zmiany w <see langword="DataSet" />; w <see langword="false" />przeciwnym razie.</param>
        <summary>Scala określony <see cref="T:System.Data.DataTable" /> i jego schemat do bieżącego <see langword="DataSet" />, zachowywania lub <see langword="DataSet" /> odrzucania zmian w i obsługi niezgodnego schematu zgodnie z podanymi argumentami.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda służy do scalania dwóch <xref:System.Data.DataSet> obiektów, które mają bardzo podobne schematy. <xref:System.Data.DataSet.Merge%2A> Scalanie jest zwykle używane w aplikacji klienckiej w celu uwzględnienia najnowszych zmian ze źródła danych w istniejącym <xref:System.Data.DataSet>. Dzięki temu aplikacja kliencka może odświeżyć <xref:System.Data.DataSet> najnowsze dane ze źródła danych.  
  
 Metoda jest zwykle wywoływana na końcu serii procedur, które obejmują sprawdzanie poprawności zmian, uzgadnianie błędów, aktualizowanie źródła danych ze zmianami i odświeżanie istniejących <xref:System.Data.DataSet>. <xref:System.Data.DataSet.Merge%2A>  
  
 Aplikacja kliencka, często ma jeden przycisk, który użytkownik może kliknąć, który zbiera zmienione dane i weryfikuje je przed wysłaniem ich z powrotem do składnika warstwy środkowej. W tym scenariuszu <xref:System.Data.DataSet.GetChanges%2A> Metoda jest wywoływana po raz pierwszy. Ta metoda zwraca sekundę <xref:System.Data.DataSet> zoptymalizowane pod kątem walidacji i scalania. Ten drugi <xref:System.Data.DataSet> obiekt zawiera <xref:System.Data.DataTable> tylko obiekty i <xref:System.Data.DataRow> , które zostały zmienione, co spowodowało powstanie podzestawu oryginału <xref:System.Data.DataSet>. Ten podzbiór jest zwykle mniejszy i w ten sposób bardziej wydajnie przeszedł z powrotem do składnika warstwy środkowej. Składnik warstwy środkowej aktualizuje oryginalne źródło danych zmianami za pomocą procedur składowanych. Warstwa środkowa może następnie wysłać do tyłu nową <xref:System.Data.DataSet> , która zawiera oryginalne dane, oraz najnowsze dane ze źródła danych (przez ponowne uruchomienie oryginalnego zapytania) lub może wysłać do niego wszystkie zmiany, które zostały wprowadzone w tym źródle danych. (Na przykład, jeśli źródło danych automatycznie tworzy unikatowe wartości klucza podstawowego, te wartości mogą być propagowane z powrotem do aplikacji klienta). W obu przypadkach zwrócone <xref:System.Data.DataSet> mogą zostać scalone z powrotem do oryginalnej <xref:System.Data.DataSet> aplikacji klienckiej za pomocą <xref:System.Data.DataSet.Merge%2A> metody.  
  
 Gdy metoda jest wywoływana, schematy dwóch <xref:System.Data.DataSet> obiektów są porównywane, ponieważ możliwe jest, że schematy zostały zmienione. <xref:System.Data.DataSet.Merge%2A> Na przykład w scenariuszu między firmami nowe kolumny mogły zostać dodane do schematu XML przez proces zautomatyzowany. Jeśli źródło <xref:System.Data.DataSet> zawiera elementy schematu (dodane <xref:System.Data.DataColumn> obiekty), które nie znajdują się w elemencie docelowym, elementy schematu można dodać do elementu docelowego przez ustawienie `missingSchemaAction` argumentu na `MissingSchemaAction.Add`. W takim przypadku scalone <xref:System.Data.DataSet> zawiera dodany schemat i dane.  
  
 Po scaleniu schematów dane są scalane.  
  
 Podczas scalania <xref:System.Data.DataSet> nowego źródła w miejscu docelowym wszystkie wiersze źródłowe <xref:System.Data.DataRowState> o wartości `Unchanged`, `Modified`lub `Deleted` są dopasowywane do wierszy docelowych z tymi samymi wartościami klucza podstawowego. Wiersze źródłowe z `DataRowState` `Added` wartością są dopasowywane do nowych wierszy docelowych z tymi samymi wartościami klucza podstawowego, co nowe wiersze źródłowe.  
  
 Podczas scalania ograniczenia są wyłączone. Jeśli nie można włączyć żadnych ograniczeń na końcu scalania, <xref:System.Data.ConstraintException> zostanie wygenerowane i scalone dane zostaną zachowane, gdy ograniczenia są wyłączone. W tym przypadku <xref:System.Data.DataSet.EnforceConstraints%2A> właściwość jest ustawiona na `false`, a wszystkie wiersze, które są nieprawidłowe, są oznaczone jako błąd. Przed próbą zresetowania <xref:System.Data.DataSet.EnforceConstraints%2A> właściwości do `true`programu należy rozwiązać błędy.  
  
   
  
## Examples  
 Poniższy przykład tworzy prostą <xref:System.Data.DataSet> z jedną tabelą, dwiema kolumnami i dziesięciu wierszami. Zostanie utworzona <xref:System.Data.DataTable> druga, która jest niemal identyczna z pierwszym, z tą różnicą, że do tabeli zostanie dodany nowy. `DataColumn` Do drugiej tabeli są dodawane dwa wiersze, które następnie są scalane w <xref:System.Data.DataSet> `preserveChanges` z argumentem `missingSchemaAction` ustawionym na `false`, a argumentem ustawionym `MissingSchemaAction.Add`na.  
  
 [!code-csharp[Classic WebData DataSet.Merge4 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge4 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Merge4 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Merge4 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="dataSet" /> Ma<see langword="null" />wartość.</exception>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="MergeFailed">
      <MemberSignature Language="C#" Value="public event System.Data.MergeFailedEventHandler MergeFailed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.MergeFailedEventHandler MergeFailed" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataSet.MergeFailed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MergeFailed As MergeFailedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::MergeFailedEventHandler ^ MergeFailed;" />
      <MemberSignature Language="F#" Value="member this.MergeFailed : System.Data.MergeFailedEventHandler " Usage="member this.MergeFailed : System.Data.MergeFailedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetMergeFailedDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.MergeFailedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy element docelowy i <see cref="T:System.Data.DataRow" /> Źródło mają tę samą wartość klucza podstawowego i <see cref="P:System.Data.DataSet.EnforceConstraints" /> ma ustawioną wartość true.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji o sposobie obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład demonstruje użycie <xref:System.Data.DataSet.MergeFailed> zdarzenia.  
  
 [!code-csharp[Classic WebData DataSet.MergeFailed Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.MergeFailed Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.MergeFailed Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.MergeFailed Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public string Namespace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Namespace { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string with get, set" Usage="System.Data.DataSet.Namespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetNamespaceDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia przestrzeń nazw <see cref="T:System.Data.DataSet" />.</summary>
        <value>Przestrzeń nazw <see cref="T:System.Data.DataSet" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataSet.WriteXml%2A> <xref:System.Data.DataSet.ReadXml%2A> <xref:System.Data.DataSet> <xref:System.Data.DataSet.WriteXmlSchema%2A> <xref:System.Data.DataSet.ReadXmlSchema%2A>Właściwość jest używana podczas odczytywania i pisania dokumentu XML przy użyciu metod,, i. <xref:System.Data.DataSet.Namespace%2A>  
  
 Przestrzeń nazw dokumentu XML jest używana do określania zakresu atrybutów XML i elementów podczas odczytu do <xref:System.Data.DataSet>. Na przykład jeśli element <xref:System.Data.DataSet> zawiera schemat, który został odczytany z dokumentu z przestrzenią nazw "Moja firma" i podjęto próbę odczytu danych tylko z dokumentu z inną przestrzenią nazw, wszelkie dane, które nie odpowiadają istniejącemu schematowi, zostaną zignorowane.  
  
   
  
## Examples  
 Poniższy przykład ustawia <xref:System.Data.DataSet.Prefix%2A> przed <xref:System.Data.DataSet.ReadXml%2A> wywołaniem metody.  
  
 [!code-csharp[Classic WebData DataSet.Namespace Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Namespace Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Namespace Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Namespace Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Przestrzeń nazw ma już dane.</exception>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnPropertyChanging (System.ComponentModel.PropertyChangedEventArgs pcevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPropertyChanging(class System.ComponentModel.PropertyChangedEventArgs pcevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPropertyChanging (pcevent As PropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPropertyChanging(System::ComponentModel::PropertyChangedEventArgs ^ pcevent);" />
      <MemberSignature Language="F#" Value="abstract member OnPropertyChanging : System.ComponentModel.PropertyChangedEventArgs -&gt; unit&#xA;override this.OnPropertyChanging : System.ComponentModel.PropertyChangedEventArgs -&gt; unit" Usage="dataSet.OnPropertyChanging pcevent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcevent" Type="System.ComponentModel.PropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="pcevent">A <see cref="T:System.ComponentModel.PropertyChangedEventArgs" /> , który zawiera dane zdarzenia.</param>
        <summary><see cref="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby zapoznać się z omówieniem, zobacz temat [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" /> w klasie pochodnej, należy wywołać <see cref="M:System.Data.DataSet.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" /> metodę klasy bazowej.</para></block>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="OnRemoveRelation">
      <MemberSignature Language="C#" Value="protected virtual void OnRemoveRelation (System.Data.DataRelation relation);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRemoveRelation(class System.Data.DataRelation relation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.OnRemoveRelation(System.Data.DataRelation)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRemoveRelation (relation As DataRelation)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRemoveRelation(System::Data::DataRelation ^ relation);" />
      <MemberSignature Language="F#" Value="abstract member OnRemoveRelation : System.Data.DataRelation -&gt; unit&#xA;override this.OnRemoveRelation : System.Data.DataRelation -&gt; unit" Usage="dataSet.OnRemoveRelation relation" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relation" Type="System.Data.DataRelation" />
      </Parameters>
      <Docs>
        <param name="relation"><see cref="T:System.Data.DataRelation" /> Trwa usuwanie.</param>
        <summary>Występuje, <see cref="T:System.Data.DataRelation" /> gdy obiekt zostanie usunięty <see cref="T:System.Data.DataTable" />z.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda powinna zostać przesłonięta przez podklasy w celu ograniczenia usuniętych tabel  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="OnRemoveTable">
      <MemberSignature Language="C#" Value="protected internal virtual void OnRemoveTable (System.Data.DataTable table);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnRemoveTable(class System.Data.DataTable table) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.OnRemoveTable(System.Data.DataTable)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnRemoveTable (table As DataTable)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnRemoveTable(System::Data::DataTable ^ table);" />
      <MemberSignature Language="F#" Value="abstract member OnRemoveTable : System.Data.DataTable -&gt; unit&#xA;override this.OnRemoveTable : System.Data.DataTable -&gt; unit" Usage="dataSet.OnRemoveTable table" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
      </Parameters>
      <Docs>
        <param name="table"><see cref="T:System.Data.DataTable" /> Trwa usuwanie.</param>
        <summary>Występuje, <see cref="T:System.Data.DataTable" /> gdy zostanie usunięty <see cref="T:System.Data.DataSet" />z.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może zostać przesłonięta przez podklasy w celu ograniczenia usunięcia tabel.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano klasę pochodną <xref:System.Data.DataSet> <xref:System.Data.DataSet.OnRemoveTable%2A> przy użyciu metody zastąpionej.  
  
 [!code-csharp[Classic WebData DataSet.OnRemoveTable Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.OnRemoveTable Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.OnRemoveTable Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.OnRemoveTable Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Prefix">
      <MemberSignature Language="C#" Value="public string Prefix { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Prefix" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Prefix" />
      <MemberSignature Language="VB.NET" Value="Public Property Prefix As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Prefix { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Prefix : string with get, set" Usage="System.Data.DataSet.Prefix" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetPrefixDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia prefiks XML, który aliasuje przestrzeń nazw <see cref="T:System.Data.DataSet" />.</summary>
        <value>Prefiks XML dla <see cref="T:System.Data.DataSet" /> przestrzeni nazw.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość jest używana w całym dokumencie XML do identyfikowania elementów, które należą do przestrzeni nazw <xref:System.Data.DataSet> obiektu (zgodnie z <xref:System.Data.DataSet.Namespace%2A> właściwością). <xref:System.Data.DataSet.Prefix%2A>  
  
   
  
## Examples  
 Poniższy przykład ustawia <xref:System.Data.DataSet.Prefix%2A> przed <xref:System.Data.DataSet.ReadXml%2A> wywołaniem metody.  
  
 [!code-csharp[Classic WebData DataSet.Namespace Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Namespace Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Namespace Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Namespace Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="RaisePropertyChanging">
      <MemberSignature Language="C#" Value="protected internal void RaisePropertyChanging (string name);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void RaisePropertyChanging(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.RaisePropertyChanging(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub RaisePropertyChanging (name As String)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void RaisePropertyChanging(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.RaisePropertyChanging : string -&gt; unit" Usage="dataSet.RaisePropertyChanging name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nazwa właściwości, która ma zostać zmieniona.</param>
        <summary>Wysyła powiadomienie o zmianie określonej <see cref="T:System.Data.DataSet" /> właściwości.</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadXml">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Odczytuje schemat XML i dane do <see cref="T:System.Data.DataSet" />.</summary>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.IO.Stream -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Obiekt, który pochodzi od <see cref="T:System.IO.Stream" />.</param>
        <summary>Odczytuje schemat XML i dane do <see cref="T:System.Data.DataSet" /> przy użyciu określonego <see cref="T:System.IO.Stream" />elementu.</summary>
        <returns><see cref="T:System.Data.XmlReadMode" /> Używane do odczytywania danych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda pozwala odczytać tylko dane lub dane i schemat <xref:System.Data.DataSet> do z dokumentu <xref:System.Data.DataSet.ReadXmlSchema%2A> XML, natomiast Metoda odczytuje tylko schemat. <xref:System.Data.DataSet.ReadXml%2A> Aby odczytać zarówno dane, jak i schemat, użyj jednego `ReadXML` z przeciążeń `mode` zawierających parametr i ustaw jego wartość na `ReadSchema`.  
  
 Należy zauważyć, że ta sama wartość <xref:System.Data.DataSet.WriteXml%2A> dotyczy metod i. <xref:System.Data.DataSet.WriteXmlSchema%2A> Aby zapisać dane XML lub schemat i dane z `DataSet`, `WriteXml` Użyj metody. Aby zapisać tylko schemat, użyj `WriteXmlSchema` metody.  
  
> [!NOTE]
>  Zostanie zgłoszony, jeśli typ kolumny `DataRow` w trakcie odczytu lub zapisu do implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> i nie implementuje <xref:System.Xml.Serialization.IXmlSerializable>. <xref:System.InvalidOperationException>  
  
 Jeśli jest określony schemat w wierszu, schemat wbudowany jest używany do rozbudowy istniejącej struktury relacyjnej przed załadowaniem danych. Jeśli wystąpią konflikty (na przykład ta sama kolumna w tej samej tabeli zdefiniowanej przy użyciu różnych typów danych), zgłaszany jest wyjątek.  
  
 Jeśli nie zostanie określony żaden schemat w wierszu, struktura relacyjna zostanie przedłużona w miarę potrzeb, zgodnie ze strukturą dokumentu XML. Jeśli schematu nie można rozszerzyć za pomocą wnioskowania w celu udostępnienia wszystkich danych, zostanie zgłoszony wyjątek.  
  
> [!NOTE]
>  Nie kojarzy elementu XML z odpowiadającym mu `DataColumn` lub, `DataTable` gdy prawne znaki XML, takie jak ("_"), są wyprowadzane w serializowanym kodzie XML. `DataSet` `DataSet` Sama sama wyprowadza tylko niedozwolone znaki XML w nazwach elementów XML i w związku z tym może korzystać tylko z tego samego. Gdy znaki prawne w nazwie elementu XML są wyprowadzane, element jest ignorowany podczas przetwarzania.  
  
 Jeśli schemat XML dotyczący <xref:System.Data.DataSet> `targetNamespace`dołączania, dane mogą nie być odczytywane i mogą wystąpić wyjątki <xref:System.Data.DataSet> podczas wywoływania <xref:System.Data.DataSet.ReadXml%2A> pliku XML, który zawiera elementy bez kwalifikującej się przestrzeni nazw. Aby odczytać niekwalifikowane elementy, ustaw `elementFormDefault` wartość "kwalifikowana" w schemacie XML, jak pokazano w poniższym przykładzie.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  Jeśli schemat <xref:System.Data.DataSet> zawiera elementy o tej samej nazwie, ale inny typ, w tej samej przestrzeni nazw, wyjątek jest zgłaszany podczas próby odczytu schematu <xref:System.Data.DataSet> do elementu with <xref:System.Data.DataSet.ReadXml%2A> , określając `XmlReadMode.ReadSchema`. Ten wyjątek nie występuje, jeśli używasz .NET Framework w wersji 1,0.  
  
   
  
## Examples  
 Poniższy przykład tworzy najpierw prostą <xref:System.Data.DataSet> z jedną <xref:System.Data.DataTable>, dwie kolumną i dziesięciu wierszami. Schemat i dane są zapisywane na dysku przez <xref:System.Data.DataSet.WriteXml%2A> wywołanie metody. <xref:System.Data.DataSet> Zostanie utworzona <xref:System.Data.DataSet> sekunda <xref:System.Data.DataSet.ReadXml%2A> , a metoda zostanie użyta do wypełnienia jej schematem i danymi.  
  
 [!code-csharp[Classic WebData DataSet.ReadXml1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)" />
        <altmember cref="M:System.Data.DataSet.WriteXml(System.IO.Stream)" />
        <altmember cref="M:System.Data.DataSet.WriteXmlSchema(System.IO.Stream)" />
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.TextReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.TextReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As TextReader) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::TextReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.IO.TextReader -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="reader">, <see langword="TextReader" /> Z którego ma zostać odczytany schemat i dane.</param>
        <summary>Odczytuje schemat XML i dane do <see cref="T:System.Data.DataSet" /> przy użyciu określonego <see cref="T:System.IO.TextReader" />elementu.</summary>
        <returns><see cref="T:System.Data.XmlReadMode" /> Używane do odczytywania danych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda pozwala odczytać tylko dane lub dane i schemat <xref:System.Data.DataSet> do z dokumentu <xref:System.Data.DataSet.ReadXmlSchema%2A> XML, natomiast Metoda odczytuje tylko schemat. <xref:System.Data.DataSet.ReadXml%2A> Aby odczytać zarówno dane, jak i schemat, użyj jednego `ReadXML` z przeciążeń `mode` zawierających parametr i ustaw jego wartość na `ReadSchema`.  
  
 Należy zauważyć, że ta sama wartość <xref:System.Data.DataSet.WriteXml%2A> dotyczy metod i. <xref:System.Data.DataSet.WriteXmlSchema%2A> Aby zapisać dane XML lub schemat i dane z `DataSet`, `WriteXml` Użyj metody. Aby zapisać tylko schemat, użyj `WriteXmlSchema` metody.  
  
> [!NOTE]
>  Zostanie zgłoszony, jeśli typ kolumny `DataRow` w trakcie odczytu lub zapisu do implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> i nie implementuje <xref:System.Xml.Serialization.IXmlSerializable>. <xref:System.InvalidOperationException>  
  
 Jeśli jest określony schemat w wierszu, schemat wbudowany jest używany do rozbudowy istniejącej struktury relacyjnej przed załadowaniem danych. Jeśli wystąpią konflikty (na przykład ta sama kolumna w tej samej tabeli zdefiniowanej przy użyciu różnych typów danych), zgłaszany jest wyjątek.  
  
 Jeśli nie zostanie określony żaden schemat w wierszu, struktura relacyjna zostanie przedłużona w miarę potrzeb, zgodnie ze strukturą dokumentu XML. Jeśli schematu nie można rozszerzyć za pomocą wnioskowania w celu udostępnienia wszystkich danych, zostanie zgłoszony wyjątek.  
  
> [!NOTE]
>  Nie kojarzy elementu XML z odpowiadającym mu `DataColumn` lub, `DataTable` gdy prawne znaki XML, takie jak ("_"), są wyprowadzane w serializowanym kodzie XML. `DataSet` `DataSet` Sama sama wyprowadza tylko niedozwolone znaki XML w nazwach elementów XML i w związku z tym może korzystać tylko z tego samego. Gdy znaki prawne w nazwie elementu XML są wyprowadzane, element jest ignorowany podczas przetwarzania.  
  
 Jeśli schemat XML dotyczący <xref:System.Data.DataSet> `targetNamespace`dołączania, dane mogą nie być odczytywane i mogą wystąpić wyjątki <xref:System.Data.DataSet> podczas wywoływania <xref:System.Data.DataSet.ReadXml%2A> pliku XML, który zawiera elementy bez kwalifikującej się przestrzeni nazw. Aby odczytać niekwalifikowane elementy, ustaw `elementFormDefault` wartość "kwalifikowana" w schemacie XML, jak pokazano w poniższym przykładzie.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
 Klasy, które dziedziczą <xref:System.IO.TextReader> z klasy, <xref:System.IO.StreamReader> obejmują <xref:System.IO.StringReader> klasy i.  
  
> [!NOTE]
>  Jeśli schemat <xref:System.Data.DataSet> zawiera elementy o tej samej nazwie, ale inny typ, w tej samej przestrzeni nazw, wyjątek jest zgłaszany podczas próby odczytu schematu <xref:System.Data.DataSet> do elementu with <xref:System.Data.DataSet.ReadXml%2A> , określając `XmlReadMode.ReadSchema`. Ten wyjątek nie występuje, jeśli używasz .NET Framework w wersji 1,0.  
  
   
  
## Examples  
 Poniższy przykład tworzy najpierw prostą <xref:System.Data.DataSet> z jedną <xref:System.Data.DataTable>, dwie kolumną i dziesięciu wierszami. Schemat i dane są zapisywane na dysku przez <xref:System.Data.DataSet.WriteXml%2A> wywołanie metody. <xref:System.Data.DataSet> Zostanie utworzona <xref:System.Data.DataSet> sekunda <xref:System.Data.DataSet.ReadXml%2A> , a metoda zostanie użyta do wypełnienia jej schematem i danymi.  
  
 [!code-csharp[Classic WebData DataSet.ReadXml2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (fileName As String) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : string -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nazwa pliku (wraz z ścieżką), z którego ma zostać odczytana.</param>
        <summary>Odczytuje schemat XML i dane do <see cref="T:System.Data.DataSet" /> przy użyciu określonego pliku.</summary>
        <returns><see langword="XmlReadMode" /> Używane do odczytywania danych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda pozwala odczytać tylko dane lub dane i schemat <xref:System.Data.DataSet> do z dokumentu <xref:System.Data.DataSet.ReadXmlSchema%2A> XML, natomiast Metoda odczytuje tylko schemat. <xref:System.Data.DataSet.ReadXml%2A> Aby odczytać zarówno dane, jak i schemat, użyj jednego `ReadXML` z przeciążeń `mode` zawierających parametr i ustaw jego wartość na `ReadSchema`.  
  
 Należy zauważyć, że ta sama wartość <xref:System.Data.DataSet.WriteXml%2A> dotyczy metod i. <xref:System.Data.DataSet.WriteXmlSchema%2A> Aby zapisać dane XML lub schemat i dane z `DataSet`, `WriteXml` Użyj metody. Aby zapisać tylko schemat, użyj `WriteXmlSchema` metody.  
  
> [!NOTE]
>  Zostanie zgłoszony, jeśli typ kolumny `DataRow` w trakcie odczytu lub zapisu do implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> i nie implementuje <xref:System.Xml.Serialization.IXmlSerializable>. <xref:System.InvalidOperationException>  
  
 Jeśli jest określony schemat w wierszu, schemat wbudowany jest używany do rozbudowy istniejącej struktury relacyjnej przed załadowaniem danych. Jeśli wystąpią konflikty (na przykład ta sama kolumna w tej samej tabeli zdefiniowanej przy użyciu różnych typów danych), zgłaszany jest wyjątek.  
  
 Jeśli nie zostanie określony żaden schemat w wierszu, struktura relacyjna zostanie przedłużona w miarę potrzeb, zgodnie ze strukturą dokumentu XML. Jeśli schematu nie można rozszerzyć za pomocą wnioskowania w celu udostępnienia wszystkich danych, zostanie zgłoszony wyjątek.  
  
> [!NOTE]
>  Nie kojarzy elementu XML z odpowiadającym mu `DataColumn` lub, `DataTable` gdy prawne znaki XML, takie jak ("_"), są wyprowadzane w serializowanym kodzie XML. `DataSet` `DataSet` Sama sama wyprowadza tylko niedozwolone znaki XML w nazwach elementów XML i w związku z tym może korzystać tylko z tego samego. Gdy znaki prawne w nazwie elementu XML są wyprowadzane, element jest ignorowany podczas przetwarzania.  
  
 Jeśli schemat XML <xref:System.Data.DataSet> dla programu `targetNamespace`zawiera, dane mogą nie być odczytywane i mogą wystąpić wyjątki <xref:System.Data.DataSet> podczas wywoływania <xref:System.Data.DataSet.ReadXml%2A> pliku XML, który zawiera elementy bez kwalifikującej się przestrzeni nazw. Aby odczytać niekwalifikowane elementy, ustaw `elementFormDefault` wartość "kwalifikowana" w schemacie XML, jak pokazano w poniższym przykładzie.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  Jeśli schemat <xref:System.Data.DataSet> zawiera elementy o tej samej nazwie, ale inny typ, w tej samej przestrzeni nazw, wyjątek jest zgłaszany podczas próby odczytu schematu <xref:System.Data.DataSet> do elementu with <xref:System.Data.DataSet.ReadXml%2A> , określając `XmlReadMode.ReadSchema`. Ten wyjątek nie występuje, jeśli używasz .NET Framework w wersji 1,0.  
  
   
  
## Examples  
 Poniższy przykład tworzy najpierw prostą <xref:System.Data.DataSet> z jedną <xref:System.Data.DataTable>, dwie kolumną i dziesięciu wierszami. Schemat i dane są zapisywane na dysku przez <xref:System.Data.DataSet.WriteXml%2A> wywołanie metody. <xref:System.Data.DataSet> Zostanie utworzona <xref:System.Data.DataSet> sekunda <xref:System.Data.DataSet.ReadXml%2A> , a metoda zostanie użyta do wypełnienia jej schematem i danymi.  
  
 [!code-csharp[Classic WebData DataSet.ReadXml3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><see cref="T:System.Security.Permissions.FileIOPermission" />nie jest ustawiona na <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">odczytywanie i zapisywanie plików. Skojarzone Wyliczenie:<see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As XmlReader) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.Xml.XmlReader -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">, <see cref="T:System.Xml.XmlReader" /> Z którego ma zostać odczytana.</param>
        <summary>Odczytuje schemat XML i dane do <see cref="T:System.Data.DataSet" /> przy użyciu określonego <see cref="T:System.Xml.XmlReader" />elementu.</summary>
        <returns><see langword="XmlReadMode" /> Używane do odczytywania danych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda pozwala odczytać tylko dane lub dane i schemat <xref:System.Data.DataSet> do z dokumentu <xref:System.Data.DataSet.ReadXmlSchema%2A> XML, natomiast Metoda odczytuje tylko schemat. <xref:System.Data.DataSet.ReadXml%2A> Aby odczytać zarówno dane, jak i schemat, użyj jednego `ReadXML` z przeciążeń `mode` zawierających parametr i ustaw jego wartość na `ReadSchema`.  
  
 Należy zauważyć, że ta sama wartość <xref:System.Data.DataSet.WriteXml%2A> dotyczy metod i. <xref:System.Data.DataSet.WriteXmlSchema%2A> Aby zapisać dane XML lub schemat i dane z `DataSet`, `WriteXml` Użyj metody. Aby zapisać tylko schemat, użyj `WriteXmlSchema` metody.  
  
> [!NOTE]
>  Zostanie zgłoszony, jeśli typ kolumny `DataRow` w trakcie odczytu lub zapisu do implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> i nie implementuje <xref:System.Xml.Serialization.IXmlSerializable>. <xref:System.InvalidOperationException>  
  
 Jeśli jest określony schemat w wierszu, schemat wbudowany jest używany do rozbudowy istniejącej struktury relacyjnej przed załadowaniem danych. Jeśli wystąpią konflikty (na przykład ta sama kolumna w tej samej tabeli zdefiniowanej przy użyciu różnych typów danych), zgłaszany jest wyjątek.  
  
 Jeśli nie zostanie określony żaden schemat w wierszu, struktura relacyjna zostanie przedłużona w miarę potrzeb, zgodnie ze strukturą dokumentu XML. Jeśli schematu nie można rozszerzyć za pomocą wnioskowania w celu udostępnienia wszystkich danych, zostanie zgłoszony wyjątek.  
  
> [!NOTE]
>  Nie kojarzy elementu XML z odpowiadającym mu `DataColumn` lub, `DataTable` gdy prawne znaki XML, takie jak ("_"), są wyprowadzane w serializowanym kodzie XML. `DataSet` `DataSet` Sama sama wyprowadza tylko niedozwolone znaki XML w nazwach elementów XML i w związku z tym może korzystać tylko z tego samego. Gdy znaki prawne w nazwie elementu XML są wyprowadzane, element jest ignorowany podczas przetwarzania.  
  
 Jeśli schemat XML <xref:System.Data.DataSet> dla programu `targetNamespace`zawiera, dane mogą nie być odczytywane i mogą wystąpić wyjątki <xref:System.Data.DataSet> podczas wywoływania <xref:System.Data.DataSet.ReadXml%2A> pliku XML, który zawiera elementy bez kwalifikującej się przestrzeni nazw. Aby odczytać niekwalifikowane elementy, ustaw `elementFormDefault` wartość "kwalifikowana" w schemacie XML, jak pokazano w poniższym przykładzie.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
 <xref:System.Xml.XmlTextReader?displayProperty=nameWithType>dziedziczy z <xref:System.Xml.XmlReader>.  
  
> [!NOTE]
>  Jeśli schemat <xref:System.Data.DataSet> zawiera elementy o tej samej nazwie, ale inny typ, w tej samej przestrzeni nazw, wyjątek jest zgłaszany podczas próby odczytu schematu <xref:System.Data.DataSet> do elementu with <xref:System.Data.DataSet.ReadXml%2A> , określając `XmlReadMode.ReadSchema`. Ten wyjątek nie występuje, jeśli używasz .NET Framework w wersji 1,0.  
  
   
  
## Examples  
 Poniższy przykład tworzy najpierw prostą <xref:System.Data.DataSet> z jedną <xref:System.Data.DataTable>, dwie kolumną i dziesięciu wierszami. Schemat i dane są zapisywane na dysku przez <xref:System.Data.DataSet.WriteXml%2A> wywołanie metody. <xref:System.Data.DataSet> Zostanie utworzona <xref:System.Data.DataSet> sekunda <xref:System.Data.DataSet.ReadXml%2A> , a metoda zostanie użyta do wypełnienia jej schematem i danymi.  
  
 [!code-csharp[Classic WebData DataSet.ReadXml Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.Stream stream, System.Data.XmlReadMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.Stream stream, valuetype System.Data.XmlReadMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.IO.Stream,System.Data.XmlReadMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::Stream ^ stream, System::Data::XmlReadMode mode);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.IO.Stream * System.Data.XmlReadMode -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml (stream, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="mode" Type="System.Data.XmlReadMode" />
      </Parameters>
      <Docs>
        <param name="stream">, <see cref="T:System.IO.Stream" /> Z którego ma zostać odczytana.</param>
        <param name="mode">Jedna z <see cref="T:System.Data.XmlReadMode" /> wartości.</param>
        <summary>Odczytuje schemat XML i dane do <see cref="T:System.Data.DataSet" /> przy użyciu określonych <see cref="T:System.IO.Stream" /> i <see cref="T:System.Data.XmlReadMode" />.</summary>
        <returns><see langword="XmlReadMode" /> Używane do odczytywania danych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda pozwala odczytać tylko dane lub dane i schemat <xref:System.Data.DataSet> do z dokumentu <xref:System.Data.DataSet.ReadXmlSchema%2A> XML, natomiast Metoda odczytuje tylko schemat. <xref:System.Data.DataSet.ReadXml%2A> Aby odczytać zarówno dane, jak i schemat, użyj jednego `ReadXML` z przeciążeń `mode` zawierających parametr i ustaw jego wartość na `ReadSchema`.  
  
 Ta sama wartość <xref:System.Data.DataSet.WriteXml%2A> dotyczy metod i <xref:System.Data.DataSet.WriteXmlSchema%2A> . Aby zapisać dane XML lub schemat i dane z `DataSet`, `WriteXml` Użyj metody. Aby zapisać tylko schemat, użyj `WriteXmlSchema` metody.  
  
> [!NOTE]
>  `Diffgram` `DataSet` `DataSet` Jeśli używasz <xref:System.Data.XmlReadMode> i ustawisz na, zawartość elementu docelowego i oryginał mogą się różnić z powodu sposobu generowania i przetwarzania w formacie DiffGram. <xref:System.Data.DataSet.ReadXml%2A> Aby uzyskać więcej informacji na temat DiffGrams, zobacz [DiffGrams](~/docs/framework/data/adonet/dataset-datatable-dataview/diffgrams.md).  
  
> [!NOTE]
>  Zostanie zgłoszony, jeśli typ kolumny `DataRow` w trakcie odczytu lub zapisu do implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> i nie implementuje <xref:System.Xml.Serialization.IXmlSerializable>. <xref:System.InvalidOperationException>  
  
 Jeśli jest określony schemat w wierszu, schemat wbudowany jest używany do rozbudowy istniejącej struktury relacyjnej przed załadowaniem danych. Jeśli wystąpią konflikty (na przykład ta sama kolumna w tej samej tabeli zdefiniowanej przy użyciu różnych typów danych), zgłaszany jest wyjątek.  
  
 Jeśli nie zostanie określony żaden schemat w wierszu, struktura relacyjna zostanie przedłużona w miarę potrzeb, zgodnie ze strukturą dokumentu XML. Jeśli schematu nie można rozszerzyć za pomocą wnioskowania w celu udostępnienia wszystkich danych, zostanie zgłoszony wyjątek.  
  
> [!NOTE]
>  Nie kojarzy elementu XML z odpowiadającym mu `DataColumn` lub, `DataTable` gdy prawne znaki XML, takie jak ("_"), są wyprowadzane w serializowanym kodzie XML. `DataSet` `DataSet` Sama sama wyprowadza tylko niedozwolone znaki XML w nazwach elementów XML i w związku z tym może korzystać tylko z tego samego. Gdy znaki prawne w nazwie elementu XML są wyprowadzane, element jest ignorowany podczas przetwarzania.  
  
 Jeśli schemat XML dotyczący <xref:System.Data.DataSet> `targetNamespace`dołączania, dane mogą nie być odczytywane i mogą wystąpić wyjątki <xref:System.Data.DataSet> podczas wywoływania <xref:System.Data.DataSet.ReadXml%2A> pliku XML, który zawiera elementy bez kwalifikującej się przestrzeni nazw. Aby odczytać niekwalifikowane elementy, ustaw `elementFormDefault` wartość "kwalifikowana" w schemacie XML, jak pokazano w poniższym przykładzie.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  Jeśli schemat <xref:System.Data.DataSet> zawiera elementy o tej samej nazwie, ale inny typ, w tej samej przestrzeni nazw, wyjątek jest zgłaszany podczas próby odczytu schematu <xref:System.Data.DataSet> do elementu with <xref:System.Data.DataSet.ReadXml%2A> , określając `XmlReadMode.ReadSchema`. Ten wyjątek nie występuje, jeśli używasz .NET Framework w wersji 1,0.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.TextReader reader, System.Data.XmlReadMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.TextReader reader, valuetype System.Data.XmlReadMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.IO.TextReader,System.Data.XmlReadMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As TextReader, mode As XmlReadMode) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::TextReader ^ reader, System::Data::XmlReadMode mode);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.IO.TextReader * System.Data.XmlReadMode -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml (reader, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
        <Parameter Name="mode" Type="System.Data.XmlReadMode" />
      </Parameters>
      <Docs>
        <param name="reader">, <see cref="T:System.IO.TextReader" /> Z którego ma zostać odczytana.</param>
        <param name="mode">Jedna z <see cref="T:System.Data.XmlReadMode" /> wartości.</param>
        <summary>Odczytuje schemat XML i dane do <see cref="T:System.Data.DataSet" /> przy użyciu określonych <see cref="T:System.IO.TextReader" /> i <see cref="T:System.Data.XmlReadMode" />.</summary>
        <returns><see langword="XmlReadMode" /> Używane do odczytywania danych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda pozwala odczytać tylko dane lub dane i schemat <xref:System.Data.DataSet> do z dokumentu <xref:System.Data.DataSet.ReadXmlSchema%2A> XML, natomiast Metoda odczytuje tylko schemat. <xref:System.Data.DataSet.ReadXml%2A> Aby odczytać zarówno dane, jak i schemat, użyj jednego `ReadXML` z przeciążeń `mode` zawierających parametr i ustaw jego wartość na `ReadSchema`.  
  
 Należy zauważyć, że ta sama wartość <xref:System.Data.DataSet.WriteXml%2A> dotyczy metod i. <xref:System.Data.DataSet.WriteXmlSchema%2A> Aby zapisać dane XML lub schemat i dane z `DataSet`, `WriteXml` Użyj metody. Aby zapisać tylko schemat, użyj `WriteXmlSchema` metody.  
  
> [!NOTE]
>  Zostanie zgłoszony, jeśli typ kolumny `DataRow` w trakcie odczytu lub zapisu do implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> i nie implementuje <xref:System.Xml.Serialization.IXmlSerializable>. <xref:System.InvalidOperationException>  
  
 Jeśli jest określony schemat w wierszu, schemat wbudowany jest używany do rozbudowy istniejącej struktury relacyjnej przed załadowaniem danych. Jeśli wystąpią konflikty (na przykład ta sama kolumna w tej samej tabeli zdefiniowanej przy użyciu różnych typów danych), zgłaszany jest wyjątek.  
  
 Jeśli nie zostanie określony żaden schemat w wierszu, struktura relacyjna zostanie przedłużona w miarę potrzeb, zgodnie ze strukturą dokumentu XML. Jeśli schematu nie można rozszerzyć za pomocą wnioskowania w celu udostępnienia wszystkich danych, zostanie zgłoszony wyjątek.  
  
> [!NOTE]
>  Nie kojarzy elementu XML z odpowiadającym mu `DataColumn` lub, `DataTable` gdy prawne znaki XML, takie jak ("_"), są wyprowadzane w serializowanym kodzie XML. `DataSet` `DataSet` Sama sama wyprowadza tylko niedozwolone znaki XML w nazwach elementów XML i w związku z tym może korzystać tylko z tego samego. Gdy znaki prawne w nazwie elementu XML są wyprowadzane, element jest ignorowany podczas przetwarzania.  
  
 Jeśli schemat XML dotyczący <xref:System.Data.DataSet> `targetNamespace`dołączania, dane mogą nie być odczytywane i mogą wystąpić wyjątki <xref:System.Data.DataSet> podczas wywoływania <xref:System.Data.DataSet.ReadXml%2A> pliku XML, który zawiera elementy bez kwalifikującej się przestrzeni nazw. Aby odczytać niekwalifikowane elementy, ustaw `elementFormDefault` wartość "kwalifikowana" w schemacie XML, jak pokazano w poniższym przykładzie.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  Jeśli schemat <xref:System.Data.DataSet> zawiera elementy o tej samej nazwie, ale inny typ, w tej samej przestrzeni nazw, wyjątek jest zgłaszany podczas próby odczytu schematu <xref:System.Data.DataSet> do elementu with <xref:System.Data.DataSet.ReadXml%2A> , określając `XmlReadMode.ReadSchema`. Ten wyjątek nie występuje, jeśli używasz .NET Framework w wersji 1,0.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (string fileName, System.Data.XmlReadMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(string fileName, valuetype System.Data.XmlReadMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.String,System.Data.XmlReadMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (fileName As String, mode As XmlReadMode) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::String ^ fileName, System::Data::XmlReadMode mode);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : string * System.Data.XmlReadMode -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml (fileName, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="mode" Type="System.Data.XmlReadMode" />
      </Parameters>
      <Docs>
        <param name="fileName">Nazwa pliku (wraz z ścieżką), z którego ma zostać odczytana.</param>
        <param name="mode">Jedna z <see cref="T:System.Data.XmlReadMode" /> wartości.</param>
        <summary>Odczytuje schemat XML i dane do <see cref="T:System.Data.DataSet" /> przy użyciu określonego pliku i. <see cref="T:System.Data.XmlReadMode" /></summary>
        <returns><see langword="XmlReadMode" /> Używane do odczytywania danych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda pozwala odczytać tylko dane lub dane i schemat <xref:System.Data.DataSet> do z dokumentu <xref:System.Data.DataSet.ReadXmlSchema%2A> XML, natomiast Metoda odczytuje tylko schemat. <xref:System.Data.DataSet.ReadXml%2A> Aby odczytać zarówno dane, jak i schemat, użyj jednego `ReadXML` z przeciążeń `mode` zawierających parametr i ustaw jego wartość na `ReadSchema`.  
  
 Należy zauważyć, że ta sama wartość <xref:System.Data.DataSet.WriteXml%2A> dotyczy metod i. <xref:System.Data.DataSet.WriteXmlSchema%2A> Aby zapisać dane XML lub schemat i dane z `DataSet`, `WriteXml` Użyj metody. Aby zapisać tylko schemat, użyj `WriteXmlSchema` metody.  
  
> [!NOTE]
>  Zostanie zgłoszony, jeśli typ kolumny `DataRow` w trakcie odczytu lub zapisu do implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> i nie implementuje <xref:System.Xml.Serialization.IXmlSerializable>. <xref:System.InvalidOperationException>  
  
 Jeśli jest określony schemat w wierszu, schemat wbudowany jest używany do rozbudowy istniejącej struktury relacyjnej przed załadowaniem danych. Jeśli wystąpią konflikty (na przykład ta sama kolumna w tej samej tabeli zdefiniowanej przy użyciu różnych typów danych), zgłaszany jest wyjątek.  
  
 Jeśli nie zostanie określony żaden schemat w wierszu, struktura relacyjna zostanie przedłużona w miarę potrzeb, zgodnie ze strukturą dokumentu XML. Jeśli schematu nie można rozszerzyć za pomocą wnioskowania w celu udostępnienia wszystkich danych, zostanie zgłoszony wyjątek.  
  
> [!NOTE]
>  Nie kojarzy elementu XML z odpowiadającym mu `DataColumn` lub, `DataTable` gdy prawne znaki XML, takie jak ("_"), są wyprowadzane w serializowanym kodzie XML. `DataSet` `DataSet` Sama sama wyprowadza tylko niedozwolone znaki XML w nazwach elementów XML i w związku z tym może korzystać tylko z tego samego. Gdy znaki prawne w nazwie elementu XML są wyprowadzane, element jest ignorowany podczas przetwarzania.  
  
 Jeśli schemat XML <xref:System.Data.DataSet> dla programu `targetNamespace`zawiera, dane mogą nie być odczytywane i mogą wystąpić wyjątki <xref:System.Data.DataSet> podczas wywoływania <xref:System.Data.DataSet.ReadXml%2A> pliku XML, który zawiera elementy bez kwalifikującej się przestrzeni nazw. Aby odczytać niekwalifikowane elementy, ustaw `elementFormDefault` wartość "kwalifikowana" w schemacie XML, jak pokazano w poniższym przykładzie.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  Jeśli schemat <xref:System.Data.DataSet> zawiera elementy o tej samej nazwie, ale inny typ, w tej samej przestrzeni nazw, wyjątek jest zgłaszany podczas próby odczytu schematu <xref:System.Data.DataSet> do elementu with <xref:System.Data.DataSet.ReadXml%2A> , określając `XmlReadMode.ReadSchema`. Ten wyjątek nie występuje, jeśli używasz .NET Framework w wersji 1,0.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><see cref="T:System.Security.Permissions.FileIOPermission" />nie jest ustawiona na <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">odczytywanie i zapisywanie plików. Skojarzone Wyliczenie:<see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.Xml.XmlReader reader, System.Data.XmlReadMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.Xml.XmlReader reader, valuetype System.Data.XmlReadMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXml(System.Xml.XmlReader,System.Data.XmlReadMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As XmlReader, mode As XmlReadMode) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::Xml::XmlReader ^ reader, System::Data::XmlReadMode mode);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.Xml.XmlReader * System.Data.XmlReadMode -&gt; System.Data.XmlReadMode" Usage="dataSet.ReadXml (reader, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="mode" Type="System.Data.XmlReadMode" />
      </Parameters>
      <Docs>
        <param name="reader">, <see cref="T:System.Xml.XmlReader" /> Z którego ma zostać odczytana.</param>
        <param name="mode">Jedna z <see cref="T:System.Data.XmlReadMode" /> wartości.</param>
        <summary>Odczytuje schemat XML i dane do <see cref="T:System.Data.DataSet" /> przy użyciu określonych <see cref="T:System.Xml.XmlReader" /> i <see cref="T:System.Data.XmlReadMode" />.</summary>
        <returns><see langword="XmlReadMode" /> Używane do odczytywania danych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda pozwala odczytać tylko dane lub dane i schemat <xref:System.Data.DataSet> do z dokumentu <xref:System.Data.DataSet.ReadXmlSchema%2A> XML, natomiast Metoda odczytuje tylko schemat. <xref:System.Data.DataSet.ReadXml%2A> Aby odczytać zarówno dane, jak i schemat, użyj jednego `ReadXML` z przeciążeń `mode` zawierających parametr i ustaw jego wartość na `ReadSchema`.  
  
 Należy zauważyć, że ta sama wartość <xref:System.Data.DataSet.WriteXml%2A> dotyczy metod i. <xref:System.Data.DataSet.WriteXmlSchema%2A> Aby zapisać dane XML lub schemat i dane z `DataSet`, `WriteXml` Użyj metody. Aby zapisać tylko schemat, użyj `WriteXmlSchema` metody.  
  
> [!NOTE]
>  Zostanie zgłoszony, jeśli typ kolumny `DataRow` w trakcie odczytu lub zapisu do implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> i nie implementuje <xref:System.Xml.Serialization.IXmlSerializable>. <xref:System.InvalidOperationException>  
  
 Jeśli jest określony schemat w wierszu, schemat wbudowany jest używany do rozbudowy istniejącej struktury relacyjnej przed załadowaniem danych. Jeśli wystąpią konflikty (na przykład ta sama kolumna w tej samej tabeli zdefiniowanej przy użyciu różnych typów danych), zgłaszany jest wyjątek.  
  
 Jeśli nie zostanie określony żaden schemat w wierszu, struktura relacyjna zostanie przedłużona w miarę potrzeb, zgodnie ze strukturą dokumentu XML. Jeśli schematu nie można rozszerzyć za pomocą wnioskowania w celu udostępnienia wszystkich danych, zostanie zgłoszony wyjątek.  
  
> [!NOTE]
>  Nie kojarzy elementu XML z odpowiadającym mu `DataColumn` lub, `DataTable` gdy prawne znaki XML, takie jak ("_"), są wyprowadzane w serializowanym kodzie XML. `DataSet` `DataSet` Sama sama wyprowadza tylko niedozwolone znaki XML w nazwach elementów XML i w związku z tym może korzystać tylko z tego samego. Gdy znaki prawne w nazwie elementu XML są wyprowadzane, element jest ignorowany podczas przetwarzania.  
  
 Jeśli schemat XML <xref:System.Data.DataSet> dla programu `targetNamespace`zawiera, dane mogą nie być odczytywane i mogą wystąpić wyjątki <xref:System.Data.DataSet> podczas wywoływania <xref:System.Data.DataSet.ReadXml%2A> pliku XML, który zawiera elementy bez kwalifikującej się przestrzeni nazw. Aby odczytać niekwalifikowane elementy, ustaw `elementFormDefault` wartość "kwalifikowana" w schemacie XML, jak pokazano w poniższym przykładzie.  
  
```  
<xsd:schema id="MyDataSet"   
   elementFormDefault="qualified"   
   targetNamespace="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns="http://www.tempuri.org/MyDataSet.xsd"   
   xmlns:xsd="http://www.w3.org/2001/XMLSchema"   
   xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
</xsd:schema>  
```  
  
> [!NOTE]
>  Jeśli schemat <xref:System.Data.DataSet> zawiera elementy o tej samej nazwie, ale inny typ, w tej samej przestrzeni nazw, wyjątek jest zgłaszany podczas próby odczytu schematu <xref:System.Data.DataSet> do elementu with <xref:System.Data.DataSet.ReadXml%2A> , określając `XmlReadMode.ReadSchema`. Ten wyjątek nie występuje, jeśli używasz .NET Framework w wersji 1,0.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadXmlSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Odczytuje schemat XML do <see cref="T:System.Data.DataSet" />.</summary>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSchema(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : System.IO.Stream -&gt; unit" Usage="dataSet.ReadXmlSchema stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">, <see cref="T:System.IO.Stream" /> Z którego ma zostać odczytana.</param>
        <summary>Odczytuje schemat XML z określonego <see cref="T:System.IO.Stream" /> <see cref="T:System.Data.DataSet" />w.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj metody, aby utworzyć schemat <xref:System.Data.DataSet>dla. <xref:System.Data.DataSet.ReadXmlSchema%2A> Schemat zawiera definicje tabel, relacji i ograniczeń. Aby napisać schemat do dokumentu XML, użyj <xref:System.Data.DataSet.WriteXmlSchema%2A> metody.  
  
 Schemat XML jest zapisywana przy użyciu standardu XSD.  
  
> [!NOTE]
>  Uszkodzenie danych może wystąpić, jeśli typy msdata: DataType i xs: Type nie pasują do siebie. Nie zostanie zgłoszony żaden wyjątek.  
  
 Metoda jest zazwyczaj wywoływana przed <xref:System.Data.DataSet.ReadXml%2A> wywołaniem metody, która <xref:System.Data.DataSet>jest używana do wypełniania. <xref:System.Data.DataSet.ReadXmlSchema%2A>  
  
 Klasy pochodne <xref:System.IO.Stream> od klasy obejmują <xref:System.IO.FileStream> <xref:System.IO.BufferedStream>,, <xref:System.IO.MemoryStream>, i <xref:System.Net.Sockets.NetworkStream>.  
  
> [!NOTE]
>  Jeśli schemat <xref:System.Data.DataSet> zawiera elementy o tej samej nazwie, ale inny typ, w tej samej przestrzeni nazw, wyjątek jest zgłaszany podczas próby odczytania schematu <xref:System.Data.DataSet> w programie <xref:System.Data.DataSet.ReadXmlSchema%2A>. Ten wyjątek nie występuje, jeśli używasz .NET Framework w wersji 1,0.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.IO.FileStream> obiekt odczytujący schemat XML z i <xref:System.Data.DataSet.ReadXmlSchema%2A> wywołuje metodę z obiektem.  
  
 [!code-csharp[Classic WebData DataSet.ReadXmlSchema1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXmlSchema1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.IO.TextReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.IO.TextReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSchema(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (reader As TextReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::IO::TextReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : System.IO.TextReader -&gt; unit" Usage="dataSet.ReadXmlSchema reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="reader">, <see cref="T:System.IO.TextReader" /> Z którego ma zostać odczytana.</param>
        <summary>Odczytuje schemat XML z określonego <see cref="T:System.IO.TextReader" /> <see cref="T:System.Data.DataSet" />w.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj metody, aby utworzyć schemat <xref:System.Data.DataSet>dla. <xref:System.Data.DataSet.ReadXmlSchema%2A> Schemat zawiera definicje tabel, relacji i ograniczeń. Aby napisać schemat do dokumentu XML, użyj <xref:System.Data.DataSet.WriteXmlSchema%2A> metody.  
  
 Schemat XML jest zapisywana przy użyciu standardu XSD.  
  
> [!NOTE]
>  Uszkodzenie danych może wystąpić, jeśli typy msdata: DataType i xs: Type nie pasują do siebie. Nie zostanie zgłoszony żaden wyjątek.  
  
 Metoda jest zazwyczaj wywoływana przed <xref:System.Data.DataSet.ReadXml%2A> wywołaniem metody, która <xref:System.Data.DataSet>jest używana do wypełniania. <xref:System.Data.DataSet.ReadXmlSchema%2A>  
  
 Klasy, które dziedziczą <xref:System.IO.TextReader> z klasy, <xref:System.IO.StreamReader> obejmują <xref:System.IO.StringReader> klasy i.  
  
> [!NOTE]
>  Jeśli schemat <xref:System.Data.DataSet> zawiera elementy o tej samej nazwie, ale inny typ, w tej samej przestrzeni nazw, wyjątek jest zgłaszany podczas próby odczytania schematu <xref:System.Data.DataSet> w programie <xref:System.Data.DataSet.ReadXmlSchema%2A>. Ten wyjątek nie występuje, jeśli używasz .NET Framework w wersji 1,0.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.IO.StreamReader> obiekt odczytujący schemat z i <xref:System.Data.DataSet.ReadXmlSchema%2A> wywołuje metodę z obiektem.  
  
 [!code-csharp[Classic WebData DataSet.ReadXmlSchema2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXmlSchema2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSchema(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : string -&gt; unit" Usage="dataSet.ReadXmlSchema fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nazwa pliku (wraz z ścieżką), z którego ma zostać odczytana.</param>
        <summary>Odczytuje schemat XML z określonego pliku do <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj metody, aby utworzyć schemat <xref:System.Data.DataSet>dla. <xref:System.Data.DataSet.ReadXmlSchema%2A> Schemat zawiera definicje tabel, relacji i ograniczeń. Aby napisać schemat do dokumentu XML, użyj <xref:System.Data.DataSet.WriteXmlSchema%2A> metody.  
  
 Schemat XML jest zapisywana przy użyciu standardu XSD.  
  
> [!NOTE]
>  Uszkodzenie danych może wystąpić, jeśli typy msdata: DataType i xs: Type nie pasują do siebie. Nie zostanie zgłoszony żaden wyjątek.  
  
 Metoda jest zazwyczaj wywoływana przed <xref:System.Data.DataSet.ReadXml%2A> wywołaniem metody, która <xref:System.Data.DataSet>jest używana do wypełniania. <xref:System.Data.DataSet.ReadXmlSchema%2A>  
  
> [!NOTE]
>  Jeśli schemat <xref:System.Data.DataSet> zawiera elementy o tej samej nazwie, ale inny typ, w tej samej przestrzeni nazw, wyjątek jest zgłaszany podczas próby odczytania schematu <xref:System.Data.DataSet> w programie <xref:System.Data.DataSet.ReadXmlSchema%2A>. Ten wyjątek nie występuje, jeśli używasz .NET Framework w wersji 1,0.  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataSet.ReadXmlSchema3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXmlSchema3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><see cref="T:System.Security.Permissions.FileIOPermission" />nie jest ustawiona na <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">odczytywanie i zapisywanie plików. Skojarzone Wyliczenie:<see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (reader As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : System.Xml.XmlReader -&gt; unit" Usage="dataSet.ReadXmlSchema reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">, <see cref="T:System.Xml.XmlReader" /> Z którego ma zostać odczytana.</param>
        <summary>Odczytuje schemat XML z określonego <see cref="T:System.Xml.XmlReader" /> <see cref="T:System.Data.DataSet" />w.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj metody, aby utworzyć schemat <xref:System.Data.DataSet>dla. <xref:System.Data.DataSet.ReadXmlSchema%2A> Schemat zawiera definicje tabel, relacji i ograniczeń.  
  
 Schemat XML jest zapisywana przy użyciu standardu XSD.  
  
> [!NOTE]
>  Uszkodzenie danych może wystąpić, jeśli typy msdata: DataType i xs: Type nie pasują do siebie. Nie zostanie zgłoszony żaden wyjątek.  
  
 Metoda jest zazwyczaj wywoływana przed <xref:System.Data.DataSet.ReadXml%2A> wywołaniem metody, która <xref:System.Data.DataSet>jest używana do wypełniania. <xref:System.Data.DataSet.ReadXmlSchema%2A>  
  
 <xref:System.Xml.XmlReader?displayProperty=nameWithType> Klasa jest abstrakcyjna. Klasa, która dziedziczy z `XmlReader` <xref:System.Xml.XmlTextReader?displayProperty=nameWithType> klasy, jest klasą.  
  
> [!NOTE]
>  Jeśli schemat <xref:System.Data.DataSet> zawiera elementy o tej samej nazwie, ale inny typ, w tej samej przestrzeni nazw, wyjątek jest zgłaszany podczas próby odczytania schematu <xref:System.Data.DataSet> w programie <xref:System.Data.DataSet.ReadXmlSchema%2A>. Ten wyjątek nie występuje, jeśli używasz .NET Framework w wersji 1,0.  
  
   
  
## Examples  
 Poniższy przykład tworzy nowy <xref:System.Data.DataSet> obiekt i. <xref:System.IO.FileStream?displayProperty=nameWithType> Obiekt utworzony przy użyciu ścieżki pliku i nazwy pliku jest używany do <xref:System.Xml.XmlTextReader?displayProperty=nameWithType> utworzenia, która jest przenoszona <xref:System.Data.DataSet.ReadXmlSchema%2A> jako argument do metody. <xref:System.IO.FileStream>  
  
 [!code-csharp[Classic WebData DataSet.ReadXmlSchema Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXmlSchema Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXmlSchema Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSerializable">
      <MemberSignature Language="C#" Value="protected virtual void ReadXmlSerializable (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ReadXmlSerializable(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ReadXmlSerializable(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ReadXmlSerializable (reader As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ReadXmlSerializable(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member ReadXmlSerializable : System.Xml.XmlReader -&gt; unit&#xA;override this.ReadXmlSerializable : System.Xml.XmlReader -&gt; unit" Usage="dataSet.ReadXmlSerializable reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Określony czytnik XML.</param>
        <summary>Ignoruje atrybuty i zwraca pusty zestaw danych.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RejectChanges">
      <MemberSignature Language="C#" Value="public virtual void RejectChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RejectChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.RejectChanges" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RejectChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RejectChanges();" />
      <MemberSignature Language="F#" Value="abstract member RejectChanges : unit -&gt; unit&#xA;override this.RejectChanges : unit -&gt; unit" Usage="dataSet.RejectChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wycofuje wszystkie zmiany wprowadzone do <see cref="T:System.Data.DataSet" /> momentu utworzenia lub od czasu <see cref="M:System.Data.DataSet.AcceptChanges" /> ostatniego wywołania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj <xref:System.Data.DataTable.RejectChanges%2A?displayProperty=nameWithType> metodę w <xref:System.Data.DataTable> <xref:System.Data.DataSet>celu wywołania metody dla wszystkich obiektów zawartych w. <xref:System.Data.DataSet.RejectChanges%2A?displayProperty=nameWithType>  
  
 <xref:System.Data.DataRow>obiekty zawarte w każdym <xref:System.Data.DataSet> z nich można ustawić w trybie edycji przez <xref:System.Data.DataRow.BeginEdit%2A?displayProperty=nameWithType> wywołanie metody. Po wywołaniu <xref:System.Data.DataRow.EndEdit%2A?displayProperty=nameWithType> metody zmiany mogą zostać odrzucone przez <xref:System.Data.DataTable.RejectChanges%2A?displayProperty=nameWithType> wywołanie <xref:System.Data.DataTable> <xref:System.Data.DataRow> obiektu, do którego należą obiekty.  
  
 Gdy wywoływana jest metoda, wszystkie wiersze nadal w trybie edycji anulują zmiany. <xref:System.Data.DataTable.RejectChanges%2A?displayProperty=nameWithType> Nowe wiersze są usuwane. Zmodyfikowane i usunięte wiersze zwracają zwrot do oryginalnego stanu (`DataRowState.Unchanged`).  
  
 Metody AcceptChanges i RejectChanges mają zastosowanie tylko <xref:System.Data.DataRow> do powiązanych zmian ( `Delete` `Add` `Remove`takich jak,,, i `Modify`). Nie mają zastosowania do zmian schematu lub strukturalnego.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano klasę pochodną <xref:System.Data.DataSet> klasy. <xref:System.Data.DataSet.RejectChanges%2A> Zdarzenie jest wywoływane z poziomu funkcji.  
  
 [!code-csharp[Classic WebData DataSet.RejectChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.RejectChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.RejectChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.RejectChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Relations">
      <MemberSignature Language="C#" Value="public System.Data.DataRelationCollection Relations { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataRelationCollection Relations" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Relations" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Relations As DataRelationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataRelationCollection ^ Relations { System::Data::DataRelationCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Relations : System.Data.DataRelationCollection" Usage="System.Data.DataSet.Relations" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetRelationsDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRelationCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję relacji łączących tabele i zezwalającą na nawigowanie z tabel nadrzędnych do tabel podrzędnych.</summary>
        <value>A <see cref="T:System.Data.DataRelationCollection" /> , który zawiera <see cref="T:System.Data.DataRelation" /> kolekcję obiektów. Pusta kolekcja jest zwracana, jeśli nie <see cref="T:System.Data.DataRelation" /> istnieją żadne obiekty.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład wyświetla nazwę kolumny wszystkich tabel podrzędnych za pomocą <xref:System.Data.DataSet.Relations%2A> właściwości.  
  
 [!code-vb[Classic WebData DataSet.Relations Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Relations Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="RemotingFormat">
      <MemberSignature Language="C#" Value="public System.Data.SerializationFormat RemotingFormat { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.SerializationFormat RemotingFormat" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.RemotingFormat" />
      <MemberSignature Language="VB.NET" Value="Public Property RemotingFormat As SerializationFormat" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::SerializationFormat RemotingFormat { System::Data::SerializationFormat get(); void set(System::Data::SerializationFormat value); };" />
      <MemberSignature Language="F#" Value="member this.RemotingFormat : System.Data.SerializationFormat with get, set" Usage="System.Data.DataSet.RemotingFormat" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.SerializationFormat</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość <see cref="T:System.Data.SerializationFormat" /> <see cref="T:System.Data.DataSet" /> dla używanego podczas komunikacji zdalnej.</summary>
        <value>Element <see cref="T:System.Data.SerializationFormat" /> obiektu.</value>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public virtual void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberSignature Language="F#" Value="abstract member Reset : unit -&gt; unit&#xA;override this.Reset : unit -&gt; unit" Usage="dataSet.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Czyści wszystkie tabele i usuwa wszystkie relacje, ograniczenia obce i tabele z <see cref="T:System.Data.DataSet" />. Podklasy powinny przesłonić <see cref="M:System.Data.DataSet.Reset" /> , aby <see cref="T:System.Data.DataSet" /> przywrócić pierwotny stan.</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="SchemaSerializationMode">
      <MemberSignature Language="C#" Value="public virtual System.Data.SchemaSerializationMode SchemaSerializationMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.SchemaSerializationMode SchemaSerializationMode" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.SchemaSerializationMode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property SchemaSerializationMode As SchemaSerializationMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Data::SchemaSerializationMode SchemaSerializationMode { System::Data::SchemaSerializationMode get(); void set(System::Data::SchemaSerializationMode value); };" />
      <MemberSignature Language="F#" Value="member this.SchemaSerializationMode : System.Data.SchemaSerializationMode with get, set" Usage="System.Data.DataSet.SchemaSerializationMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.SchemaSerializationMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Data.SchemaSerializationMode" /> <see cref="T:System.Data.DataSet" />dla elementu.</summary>
        <value>A <see cref="T:System.Data.SchemaSerializationMode" /> dla a <see cref="T:System.Data.DataSet" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie <xref:System.Data.DataSet> serializować dane schematu i wystąpienia w usługach sieci Web i scenariuszach komunikacji zdalnej. Ustawienie właściwości typu na powoduje, <xref:System.Data.SchemaSerializationMode.ExcludeSchema> że informacje o schemacie mają być wykluczone z ładunku serializacji. `DataSet` <xref:System.Data.DataSet.SchemaSerializationMode%2A>  
  
 <xref:System.Data.SchemaSerializationMode.ExcludeSchema>jest obsługiwana tylko dla danego typu `DataSet`. Dla tej właściwości można ustawić tylko wartość <xref:System.Data.SchemaSerializationMode.IncludeSchema>. `DataSet`  
  
 <xref:System.Data.SchemaSerializationMode.ExcludeSchema>powinny być używane tylko w przypadkach, w których informacje o schemacie określonego `DataTables` `DataRelations` typu i `Constraints` nie zostały zmodyfikowane. Jeśli modyfikacje wystąpiły, pełne informacje o schemacie <xref:System.Data.SchemaSerializationMode.IncludeSchema>powinny być serializowane z.  
  
 <xref:System.Data.SchemaSerializationMode.ExcludeSchema>jest obsługiwany w wersji 2,0 .NET Framework lub nowszej.  
  
 Gdy <xref:System.Data.SchemaSerializationMode.ExcludeSchema> jest ustawiony, tylko właściwości środowiska uruchomieniowego najwyższego poziomu <xref:System.Data.DataSet> występujące w programie są serializowane. Ponadto są one serializowane tylko wtedy, gdy się różnią od wartości domyślnych. Żadna z `Tables` `Relations` lub niejestserializowana.`Constraints` Serializowane właściwości środowiska uruchomieniowego <xref:System.Data.DataSet.Namespace%2A>obejmują <xref:System.Data.DataSet.Prefix%2A> <xref:System.Data.DataSet.DataSetName%2A>, <xref:System.Data.DataSet.Locale%2A>, <xref:System.Data.DataSet.EnforceConstraints%2A>,, <xref:System.Data.DataSet.CaseSensitive%2A>, i. Te właściwości są serializowane, aby upewnić się, że ogólna integralność danych środowiska uruchomieniowego jest zachowywana.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeRelations">
      <MemberSignature Language="C#" Value="protected virtual bool ShouldSerializeRelations ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ShouldSerializeRelations() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ShouldSerializeRelations" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ShouldSerializeRelations () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ShouldSerializeRelations();" />
      <MemberSignature Language="F#" Value="abstract member ShouldSerializeRelations : unit -&gt; bool&#xA;override this.ShouldSerializeRelations : unit -&gt; bool" Usage="dataSet.ShouldSerializeRelations " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="P:System.Data.DataSet.Relations" /> właściwość powinna być utrwalona.</summary>
        <returns><see langword="true" />Jeśli wartość właściwości została zmieniona z domyślną; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest używana zazwyczaj w przypadku tworzenia projektanta dla <xref:System.Data.DataSet>lub tworzenia własnej kontrolki zawierającej. <xref:System.Data.DataSet>  
  
   
  
## Examples  
 Poniższe przykłady przedstawiają klasę pochodną <xref:System.Data.DataSet> klasy. Metody <xref:System.Data.DataSet.Reset%2A> i<xref:System.Data.DataSet.ShouldSerializeRelations%2A> są wywoływane z poziomu funkcji w klasie pochodnej.  
  
 [!code-csharp[Classic WebData DataSet.ShouldSerializeRelations Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ShouldSerializeRelations Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ShouldSerializeRelations Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ShouldSerializeRelations Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTables">
      <MemberSignature Language="C#" Value="protected virtual bool ShouldSerializeTables ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ShouldSerializeTables() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.ShouldSerializeTables" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ShouldSerializeTables () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ShouldSerializeTables();" />
      <MemberSignature Language="F#" Value="abstract member ShouldSerializeTables : unit -&gt; bool&#xA;override this.ShouldSerializeTables : unit -&gt; bool" Usage="dataSet.ShouldSerializeTables " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="P:System.Data.DataSet.Tables" /> właściwość powinna być utrwalona.</summary>
        <returns><see langword="true" />Jeśli wartość właściwości została zmieniona z domyślną; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest zazwyczaj używana tylko <xref:System.Data.DataSet>w przypadku tworzenia projektanta dla lub tworzenia własnej kontrolki zawierającej. <xref:System.Data.DataSet>  
  
   
  
## Examples  
 W poniższym przykładzie pokazano klasę pochodną <xref:System.Data.DataSet> klasy. <xref:System.Data.DataSet.ShouldSerializeTables%2A> Metoda jest wywoływana z poziomu funkcji w klasie pochodnej.  
  
 [!code-csharp[Classic WebData DataSet.ShouldSerializeTables Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ShouldSerializeTables Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ShouldSerializeTables Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ShouldSerializeTables Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Site" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Site : System.ComponentModel.ISite with get, set" Usage="System.Data.DataSet.Site" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.ComponentModel.ISite" /> <see cref="T:System.Data.DataSet" />dla elementu.</summary>
        <value><see cref="T:System.ComponentModel.ISite" /> Dla .<see cref="T:System.Data.DataSet" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lokacje są <xref:System.ComponentModel.Component> powiązane <xref:System.ComponentModel.Container> z i umożliwiają komunikację między nimi, a także umożliwiają kontenerowi zarządzanie jego składnikami.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.ContainsListCollection">
      <MemberSignature Language="C#" Value="bool System.ComponentModel.IListSource.ContainsListCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.ComponentModel.IListSource.ContainsListCollection" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.System#ComponentModel#IListSource#ContainsListCollection" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ContainsListCollection As Boolean Implements IListSource.ContainsListCollection" />
      <MemberSignature Language="C++ CLI" Value="property bool System::ComponentModel::IListSource::ContainsListCollection { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.ComponentModel.IListSource.ContainsListCollection" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.IListSource.ContainsListCollection</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="P:System.ComponentModel.IListSource.ContainsListCollection" />Zobacz.</summary>
        <value>Aby uzyskać opis tego elementu członkowskiego, <see cref="P:System.ComponentModel.IListSource.ContainsListCollection" />Zobacz.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Data.DataSet> gdy wystąpienie jest rzutowane <xref:System.ComponentModel.IListSource> do interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.GetList">
      <MemberSignature Language="C#" Value="System.Collections.IList IListSource.GetList ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IList System.ComponentModel.IListSource.GetList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.System#ComponentModel#IListSource#GetList" />
      <MemberSignature Language="VB.NET" Value="Function GetList () As IList Implements IListSource.GetList" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IList ^ System.ComponentModel.IListSource.GetList() = System::ComponentModel::IListSource::GetList;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.IListSource.GetList</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.ComponentModel.IListSource.GetList" />Zobacz.</summary>
        <returns>Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.ComponentModel.IListSource.GetList" />Zobacz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Data.DataSet> gdy wystąpienie jest rzutowane <xref:System.ComponentModel.IListSource> do interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netframework-1.1" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netframework-1.1" />
      </Parameters>
      <Docs>
        <param name="info"><see cref="T:System.Runtime.Serialization.SerializationInfo" /> Do wypełnienia danymi.</param>
        <param name="context">Miejsce docelowe (zobacz <see cref="T:System.Runtime.Serialization.StreamingContext" />) dla tej serializacji.</param>
        <summary>Wypełnia obiekt informacji serializacji danymi wymaganymi do serializacji <see cref="T:System.Data.DataSet" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.GetSchema">
      <MemberSignature Language="C#" Value="System.Xml.Schema.XmlSchema IXmlSerializable.GetSchema ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Xml.Schema.XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#GetSchema" />
      <MemberSignature Language="VB.NET" Value="Function GetSchema () As XmlSchema Implements IXmlSerializable.GetSchema" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Xml::Schema::XmlSchema ^ System.Xml.Serialization.IXmlSerializable.GetSchema() = System::Xml::Serialization::IXmlSerializable::GetSchema;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.GetSchema</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchema</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" />Zobacz.</summary>
        <returns>Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" />Zobacz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Data.DataSet> gdy wystąpienie jest rzutowane <xref:System.Xml.Serialization.IXmlSerializable> do interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.ReadXml">
      <MemberSignature Language="C#" Value="void IXmlSerializable.ReadXml (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Xml.Serialization.IXmlSerializable.ReadXml(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Sub ReadXml (reader As XmlReader) Implements IXmlSerializable.ReadXml" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Xml.Serialization.IXmlSerializable.ReadXml(System::Xml::XmlReader ^ reader) = System::Xml::Serialization::IXmlSerializable::ReadXml;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">A <see cref="T:System.Xml.XmlReader" />.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" />Zobacz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Data.DataSet> gdy wystąpienie jest rzutowane <xref:System.Xml.Serialization.IXmlSerializable> do interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.WriteXml">
      <MemberSignature Language="C#" Value="void IXmlSerializable.WriteXml (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Xml.Serialization.IXmlSerializable.WriteXml(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Sub WriteXml (writer As XmlWriter) Implements IXmlSerializable.WriteXml" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Xml.Serialization.IXmlSerializable.WriteXml(System::Xml::XmlWriter ^ writer) = System::Xml::Serialization::IXmlSerializable::WriteXml;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">A <see cref="T:System.Xml.XmlWriter" />.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" />Zobacz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Data.DataSet> gdy wystąpienie jest rzutowane <xref:System.Xml.Serialization.IXmlSerializable> do interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tables">
      <MemberSignature Language="C#" Value="public System.Data.DataTableCollection Tables { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataTableCollection Tables" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataSet.Tables" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Tables As DataTableCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataTableCollection ^ Tables { System::Data::DataTableCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Tables : System.Data.DataTableCollection" Usage="System.Data.DataSet.Tables" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataSetTablesDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataTableCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję tabel znajdujących się w <see cref="T:System.Data.DataSet" />.</summary>
        <value>Zawarte <see cref="T:System.Data.DataTableCollection" /> w tym <see cref="T:System.Data.DataSet" />obszarze. Pusta kolekcja jest zwracana, jeśli nie <see cref="T:System.Data.DataTable" /> istnieją żadne obiekty.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby dodać tabele do kolekcji, użyj <xref:System.Data.DataTableCollection.Add%2A> metody. <xref:System.Data.DataTableCollection> Aby usunąć tabele, użyj <xref:System.Data.DataTableCollection.Remove%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład zwraca <xref:System.Data.DataSet> <xref:System.Data.DataTableCollection>obiekt i drukuje kolumny i wiersze w każdej tabeli.  
  
 [!code-csharp[Classic WebData DataSet.Tables Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.Tables Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.Tables Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.Tables Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteXml">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapisuje dane XML i opcjonalnie schemat z <see cref="T:System.Data.DataSet" />.</summary>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.Stream -&gt; unit" Usage="dataSet.WriteXml stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream"><see cref="T:System.IO.Stream" /> Obiekt używany do zapisu w pliku.</param>
        <summary>Zapisuje bieżące dane <see cref="T:System.Data.DataSet" /> za pomocą określonego <see cref="T:System.IO.Stream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda umożliwia zapisanie tylko danych lub zarówno danych, jak i schematu <xref:System.Data.DataSet> z do dokumentu <xref:System.Data.DataSet.WriteXmlSchema%2A> XML, podczas gdy metoda zapisuje tylko schemat. `WriteXml` Aby zapisać dane i schemat, użyj jednego z przeciążeń zawierających `mode` parametr i ustaw jego wartość na. `WriteSchema`  
  
 Należy zauważyć, że ta sama wartość <xref:System.Data.DataSet.ReadXml%2A> dotyczy metod i. <xref:System.Data.DataSet.ReadXmlSchema%2A> Aby odczytać dane XML lub schemat i dane do `DataSet`, `ReadXml` Użyj metody. Aby odczytać tylko schemat, użyj `ReadXmlSchema` metody.  
  
> [!NOTE]
>  Zostanie zgłoszony, jeśli typ kolumny `DataRow` w trakcie odczytu lub zapisu do implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> i nie implementuje <xref:System.Xml.Serialization.IXmlSerializable>. <xref:System.InvalidOperationException>  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.IO.FileStream?displayProperty=nameWithType> obiekt. Obiekt jest następnie używany z <xref:System.Data.DataSet.WriteXml%2A> metodą do pisania dokumentu XML.  
  
 [!code-csharp[Classic WebData DataSet.WriteXml Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXml Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.TextWriter -&gt; unit" Usage="dataSet.WriteXml writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Obiekt <see cref="T:System.IO.TextWriter" /> , z którego ma zostać zapisany.</param>
        <summary>Zapisuje bieżące dane <see cref="T:System.Data.DataSet" /> za pomocą określonego <see cref="T:System.IO.TextWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda umożliwia zapisanie tylko danych lub zarówno danych, jak i schematu <xref:System.Data.DataSet> z do dokumentu <xref:System.Data.DataSet.WriteXmlSchema%2A> XML, podczas gdy metoda zapisuje tylko schemat. `WriteXml` Aby zapisać dane i schemat, użyj jednego z przeciążeń zawierających `mode` parametr i ustaw jego wartość na. `WriteSchema`  
  
 Należy zauważyć, że ta sama wartość <xref:System.Data.DataSet.ReadXml%2A> dotyczy metod i. <xref:System.Data.DataSet.ReadXmlSchema%2A> Aby odczytać dane XML lub schemat i dane do `DataSet`, `ReadXml` Użyj metody. Aby odczytać tylko schemat, użyj `ReadXmlSchema` metody.  
  
> [!NOTE]
>  Zostanie zgłoszony, jeśli typ kolumny `DataRow` w trakcie odczytu lub zapisu do implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> i nie implementuje <xref:System.Xml.Serialization.IXmlSerializable>. <xref:System.InvalidOperationException>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : string -&gt; unit" Usage="dataSet.WriteXml fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nazwa pliku (wraz z ścieżką), do którego ma zostać zapisany.</param>
        <summary>Zapisuje bieżące dane dla <see cref="T:System.Data.DataSet" /> określonego pliku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda umożliwia zapisanie tylko danych lub zarówno danych, jak i schematu <xref:System.Data.DataSet> z do dokumentu <xref:System.Data.DataSet.WriteXmlSchema%2A> XML, podczas gdy metoda zapisuje tylko schemat. `WriteXml` Aby zapisać dane i schemat, użyj jednego z przeciążeń zawierających `mode` parametr i ustaw jego wartość na. `WriteSchema`  
  
 Należy zauważyć, że ta sama wartość <xref:System.Data.DataSet.ReadXml%2A> dotyczy metod i. <xref:System.Data.DataSet.ReadXmlSchema%2A> Aby odczytać dane XML lub schemat i dane do `DataSet`, `ReadXml` Użyj metody. Aby odczytać tylko schemat, użyj `ReadXmlSchema` metody.  
  
> [!NOTE]
>  Zostanie zgłoszony, jeśli typ kolumny `DataRow` w trakcie odczytu lub zapisu do implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> i nie implementuje <xref:System.Xml.Serialization.IXmlSerializable>. <xref:System.InvalidOperationException>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><see cref="T:System.Security.Permissions.FileIOPermission" />nie jest ustawiona na <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">odczytywanie i zapisywanie plików. Skojarzone Wyliczenie:<see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.Xml.XmlWriter -&gt; unit" Usage="dataSet.WriteXml writer" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">, <see cref="T:System.Xml.XmlWriter" /> Przy użyciu którego ma zostać zapisany.</param>
        <summary>Zapisuje bieżące dane dla określonego <see cref="T:System.Data.DataSet" /> <see cref="T:System.Xml.XmlWriter" />elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda umożliwia zapisanie tylko danych lub zarówno danych, jak i schematu <xref:System.Data.DataSet> z do dokumentu <xref:System.Data.DataSet.WriteXmlSchema%2A> XML, podczas gdy metoda zapisuje tylko schemat. `WriteXml` Aby zapisać dane i schemat, użyj jednego z przeciążeń zawierających `mode` parametr i ustaw jego wartość na. `WriteSchema`  
  
 Należy zauważyć, że ta sama wartość <xref:System.Data.DataSet.ReadXml%2A> dotyczy metod i. <xref:System.Data.DataSet.ReadXmlSchema%2A> Aby odczytać dane XML lub schemat i dane do `DataSet`, `ReadXml` Użyj metody. Aby odczytać tylko schemat, użyj `ReadXmlSchema` metody.  
  
> [!NOTE]
>  Zostanie zgłoszony, jeśli typ kolumny `DataRow` w trakcie odczytu lub zapisu do implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> i nie implementuje <xref:System.Xml.Serialization.IXmlSerializable>. <xref:System.InvalidOperationException>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.Stream * System.Data.XmlWriteMode -&gt; unit" Usage="dataSet.WriteXml (stream, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="stream"><see cref="T:System.IO.Stream" /> Obiekt używany do zapisu w pliku.</param>
        <param name="mode">Jedna z <see cref="T:System.Data.XmlWriteMode" /> wartości.</param>
        <summary>Zapisuje bieżące dane i opcjonalnie schemat <see cref="T:System.Data.DataSet" /> przy użyciu określonych <see cref="T:System.IO.Stream" /> i <see cref="T:System.Data.XmlWriteMode" />. Aby zapisać schemat, ustaw wartość <paramref name="mode" /> parametru na. <see langword="WriteSchema" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda umożliwia zapisanie tylko danych lub zarówno danych, jak i schematu <xref:System.Data.DataSet> z do dokumentu <xref:System.Data.DataSet.WriteXmlSchema%2A> XML, podczas gdy metoda zapisuje tylko schemat. `WriteXml` Aby zapisać dane i schemat, ustaw `mode` parametr na. `WriteSchema`  
  
 Należy zauważyć, że ta sama wartość <xref:System.Data.DataSet.ReadXml%2A> dotyczy metod i. <xref:System.Data.DataSet.ReadXmlSchema%2A> Aby odczytać dane XML lub schemat i dane do `DataSet`, `ReadXml` Użyj metody. Aby odczytać tylko schemat, użyj `ReadXmlSchema` metody.  
  
> [!NOTE]
>  Zostanie zgłoszony, jeśli typ kolumny `DataRow` w trakcie odczytu lub zapisu do implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> i nie implementuje <xref:System.Xml.Serialization.IXmlSerializable>. <xref:System.InvalidOperationException>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.TextWriter * System.Data.XmlWriteMode -&gt; unit" Usage="dataSet.WriteXml (writer, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="writer"><see cref="T:System.IO.TextWriter" /> Obiekt używany do pisania dokumentu.</param>
        <param name="mode">Jedna z <see cref="T:System.Data.XmlWriteMode" /> wartości.</param>
        <summary>Zapisuje bieżące dane i opcjonalnie schemat <see cref="T:System.Data.DataSet" /> przy użyciu określonych <see cref="T:System.IO.TextWriter" /> i <see cref="T:System.Data.XmlWriteMode" />. Aby zapisać schemat, ustaw wartość <paramref name="mode" /> parametru na. <see langword="WriteSchema" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda umożliwia zapisanie tylko danych lub zarówno danych, jak i schematu <xref:System.Data.DataSet> z do dokumentu <xref:System.Data.DataSet.WriteXmlSchema%2A> XML, podczas gdy metoda zapisuje tylko schemat. `WriteXml` Aby zapisać dane i schemat, ustaw `mode` parametr na. `WriteSchema`  
  
 Należy zauważyć, że ta sama wartość <xref:System.Data.DataSet.ReadXml%2A> dotyczy metod i. <xref:System.Data.DataSet.ReadXmlSchema%2A> Aby odczytać dane XML lub schemat i dane do `DataSet`, `ReadXml` Użyj metody. Aby odczytać tylko schemat, użyj `ReadXmlSchema` metody.  
  
> [!NOTE]
>  Zostanie zgłoszony, jeśli typ kolumny `DataRow` w trakcie odczytu lub zapisu do implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> i nie implementuje <xref:System.Xml.Serialization.IXmlSerializable>. <xref:System.InvalidOperationException>  
  
   
  
## Examples  
 Poniższy przykład tworzy najpierw prostą <xref:System.Data.DataSet> z jedną <xref:System.Data.DataTable>, dwie kolumną i dziesięciu wierszami. Schemat i dane są zapisywane na dysku przez <xref:System.Data.DataSet.WriteXml%2A> wywołanie metody. <xref:System.Data.DataSet> Zostanie utworzona <xref:System.Data.DataSet> sekunda <xref:System.Data.DataSet.ReadXml%2A> , a metoda zostanie użyta do wypełnienia jej schematem i danymi.  
  
 [!code-csharp[Classic WebData DataSet.ReadXml2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.ReadXml2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.ReadXml2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.String,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : string * System.Data.XmlWriteMode -&gt; unit" Usage="dataSet.WriteXml (fileName, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="fileName">Nazwa pliku (wraz z ścieżką), do którego ma zostać zapisany.</param>
        <param name="mode">Jedna z <see cref="T:System.Data.XmlWriteMode" /> wartości.</param>
        <summary>Zapisuje bieżące dane i opcjonalnie schemat dla <see cref="T:System.Data.DataSet" /> określonego pliku przy użyciu określonego. <see cref="T:System.Data.XmlWriteMode" /> Aby zapisać schemat, ustaw wartość <paramref name="mode" /> parametru na. <see langword="WriteSchema" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda umożliwia zapisanie tylko danych lub zarówno danych, jak i schematu <xref:System.Data.DataSet> z do dokumentu <xref:System.Data.DataSet.WriteXmlSchema%2A> XML, podczas gdy metoda zapisuje tylko schemat. `WriteXml` Aby zapisać dane i schemat, ustaw `mode` parametr na. `WriteSchema`  
  
 Należy zauważyć, że ta sama wartość <xref:System.Data.DataSet.ReadXml%2A> dotyczy metod i. <xref:System.Data.DataSet.ReadXmlSchema%2A> Aby odczytać dane XML lub schemat i dane do `DataSet`, `ReadXml` Użyj metody. Aby odczytać tylko schemat, użyj `ReadXmlSchema` metody.  
  
> [!NOTE]
>  Zostanie zgłoszony, jeśli typ kolumny `DataRow` w trakcie odczytu lub zapisu do implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> i nie implementuje <xref:System.Xml.Serialization.IXmlSerializable>. <xref:System.InvalidOperationException>  
  
   
  
## Examples  
 Poniższy przykład używa <xref:System.Data.DataSet.WriteXml%2A> metody do pisania dokumentu XML.  
  
 [!code-csharp[Classic WebData DataSet.WriteXml7 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml7 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXml7 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml7 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><see cref="T:System.Security.Permissions.FileIOPermission" />nie jest ustawiona na <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">odczytywanie i zapisywanie plików. Skojarzone Wyliczenie:<see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.Xml.XmlWriter * System.Data.XmlWriteMode -&gt; unit" Usage="dataSet.WriteXml (writer, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="writer">, <see cref="T:System.Xml.XmlWriter" /> Przy użyciu którego ma zostać zapisany.</param>
        <param name="mode">Jedna z <see cref="T:System.Data.XmlWriteMode" /> wartości.</param>
        <summary>Zapisuje bieżące dane i opcjonalnie schemat <see cref="T:System.Data.DataSet" /> przy użyciu określonych <see cref="T:System.Xml.XmlWriter" /> i <see cref="T:System.Data.XmlWriteMode" />. Aby zapisać schemat, ustaw wartość <paramref name="mode" /> parametru na. <see langword="WriteSchema" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda umożliwia zapisanie tylko danych lub zarówno danych, jak i schematu <xref:System.Data.DataSet> z do dokumentu <xref:System.Data.DataSet.WriteXmlSchema%2A> XML, podczas gdy metoda zapisuje tylko schemat. `WriteXml` Aby zapisać dane i schemat, ustaw `mode` parametr na. `WriteSchema`  
  
 Należy zauważyć, że ta sama wartość <xref:System.Data.DataSet.ReadXml%2A> dotyczy metod i. <xref:System.Data.DataSet.ReadXmlSchema%2A> Aby odczytać dane XML lub schemat i dane do `DataSet`, `ReadXml` Użyj metody. Aby odczytać tylko schemat, użyj `ReadXmlSchema` metody.  
  
> [!NOTE]
>  Zostanie zgłoszony, jeśli typ kolumny `DataRow` w trakcie odczytu lub zapisu do implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> i nie implementuje <xref:System.Xml.Serialization.IXmlSerializable>. <xref:System.InvalidOperationException>  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.IO.FileStream?displayProperty=nameWithType> obiekt, który jest używany do utworzenia nowego <xref:System.Xml.XmlTextWriter>. Obiekt jest używany <xref:System.Data.DataSet.WriteXml%2A> z metodą do pisania dokumentu XML. <xref:System.Xml.XmlTextWriter>  
  
 [!code-csharp[Classic WebData DataSet.WriteXml6 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml6 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXml6 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXml6 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteXmlSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Data.DataSet" /> Zapisuje strukturę jako schemat XML.</summary>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.Stream -&gt; unit" Usage="dataSet.WriteXmlSchema stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream"><see cref="T:System.IO.Stream" /> Obiekt używany do zapisu w pliku.</param>
        <summary>Zapisuje strukturę jako schemat XML do określonego <see cref="T:System.IO.Stream" /> obiektu. <see cref="T:System.Data.DataSet" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj metody <xref:System.Data.DataSet.WriteXmlSchema%2A> , aby zapisać schemat <xref:System.Data.DataSet> dla dokumentu w formacie XML. Schemat zawiera definicje tabel, relacji i ograniczeń. Aby napisać schemat do dokumentu XML, użyj <xref:System.Data.DataSet.WriteXmlSchema%2A> metody.  
  
 Schemat XML jest zapisywana przy użyciu standardu XSD.  
  
 Aby zapisać dane w dokumencie XML, użyj <xref:System.Data.DataSet.WriteXml%2A> metody.  
  
 Klasy pochodne <xref:System.IO.Stream> od klasy obejmują <xref:System.IO.FileStream> <xref:System.IO.BufferedStream>,, <xref:System.IO.MemoryStream>, i <xref:System.Net.Sockets.NetworkStream>.  
  
   
  
## Examples  
 Poniższy przykład tworzy nowy <xref:System.IO.FileStream> obiekt, który jest przesyłany <xref:System.Data.DataSet.WriteXmlSchema%2A> do metody, aby zapisać schemat na dysku.  
  
 [!code-csharp[Classic WebData DataSet.WriteXmlSchema Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXmlSchema Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.TextWriter -&gt; unit" Usage="dataSet.WriteXmlSchema writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Obiekt <see cref="T:System.IO.TextWriter" /> , z którego ma zostać zapisany.</param>
        <summary>Zapisuje strukturę jako schemat XML do określonego <see cref="T:System.IO.TextWriter" /> obiektu. <see cref="T:System.Data.DataSet" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj metody <xref:System.Data.DataSet.WriteXmlSchema%2A> , aby zapisać schemat <xref:System.Data.DataSet> dla dokumentu w formacie XML. Schemat zawiera definicje tabel, relacji i ograniczeń. Aby napisać schemat do dokumentu XML, użyj <xref:System.Data.DataSet.WriteXmlSchema%2A> metody.  
  
 Schemat XML jest zapisywana przy użyciu standardu XSD.  
  
 Aby zapisać dane w dokumencie XML, użyj <xref:System.Data.DataSet.WriteXml%2A> metody.  
  
 <xref:System.IO.TextWriter?displayProperty=nameWithType> Klasy pochodne od klasy <xref:System.Web.HttpWriter?displayProperty=nameWithType>obejmują, <xref:System.CodeDom.Compiler.IndentedTextWriter?displayProperty=nameWithType> <xref:System.Web.UI.HtmlTextWriter?displayProperty=nameWithType>, ,<xref:System.IO.StreamWriter?displayProperty=nameWithType>, i <xref:System.IO.StringWriter?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Text.StringBuilder?displayProperty=nameWithType> obiekt do, który jest używany do utworzenia nowego <xref:System.IO.StringWriter?displayProperty=nameWithType>. Jest przenoszona do metody, a wynikowy ciąg jest drukowany w oknie konsoli. <xref:System.Data.DataSet.WriteXmlSchema%2A> <xref:System.IO.StringWriter>  
  
 [!code-csharp[Classic WebData DataSet.WriteXmlSchema1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXmlSchema1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : string -&gt; unit" Usage="dataSet.WriteXmlSchema fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nazwa pliku (wraz z ścieżką), do którego ma zostać zapisany.</param>
        <summary><see cref="T:System.Data.DataSet" /> Zapisuje strukturę jako schemat XML w pliku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj metody <xref:System.Data.DataSet.WriteXmlSchema%2A> , aby zapisać schemat <xref:System.Data.DataSet> dla dokumentu w formacie XML. Schemat zawiera definicje tabel, relacji i ograniczeń. Aby napisać schemat do dokumentu XML, użyj <xref:System.Data.DataSet.WriteXmlSchema%2A> metody.  
  
 Schemat XML jest zapisywana przy użyciu standardu XSD.  
  
 Aby zapisać dane w dokumencie XML, użyj <xref:System.Data.DataSet.WriteXml%2A> metody.  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataSet.WriteXmlSchema3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXmlSchema3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><see cref="T:System.Security.Permissions.FileIOPermission" />nie jest ustawiona na <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">odczytywanie i zapisywanie plików. Skojarzone Wyliczenie:<see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.Xml.XmlWriter -&gt; unit" Usage="dataSet.WriteXmlSchema writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer"><see cref="T:System.Xml.XmlWriter" /> Do zapisu.</param>
        <summary>Zapisuje strukturę jako schemat XML <see cref="T:System.Xml.XmlWriter" /> do obiektu. <see cref="T:System.Data.DataSet" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj metody <xref:System.Data.DataSet.WriteXmlSchema%2A> , aby zapisać schemat <xref:System.Data.DataSet> dla dokumentu w formacie XML. Schemat zawiera definicje tabel, relacji i ograniczeń. Aby napisać schemat do dokumentu XML, użyj <xref:System.Data.DataSet.WriteXmlSchema%2A> metody.  
  
 Schemat XML jest zapisywana przy użyciu standardu XSD.  
  
 Aby zapisać dane w dokumencie XML, użyj <xref:System.Data.DataSet.WriteXml%2A> metody.  
  
 Jedna klasa, która dziedziczy z <xref:System.Xml.XmlWriter?displayProperty=nameWithType> klasy, <xref:System.Xml.XmlTextWriter> jest klasą.  
  
   
  
## Examples  
 Poniższy przykład tworzy nowy <xref:System.IO.FileStream?displayProperty=nameWithType> obiekt z określoną ścieżką. Obiekt jest używany do <xref:System.Xml.XmlTextWriter> tworzenia obiektu. <xref:System.IO.FileStream> Metoda jest następnie wywoływana <xref:System.Xml.XmlTextWriter> z obiektem, aby zapisać schemat na dysku. <xref:System.Data.DataSet.WriteXmlSchema%2A>  
  
 [!code-csharp[Classic WebData DataSet.WriteXmlSchema2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataSet.WriteXmlSchema2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataSet.WriteXmlSchema2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/data/adonet/dataset-datatable-dataview/index.md">Używanie zestawów danych w ADO.NET</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.Stream stream, Converter&lt;Type,string&gt; multipleTargetConverter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.Stream stream, class System.Converter`2&lt;class System.Type, string&gt; multipleTargetConverter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.IO.Stream,System.Converter{System.Type,System.String})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::Stream ^ stream, Converter&lt;Type ^, System::String ^&gt; ^ multipleTargetConverter);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.Stream * Converter&lt;Type, string&gt; -&gt; unit" Usage="dataSet.WriteXmlSchema (stream, multipleTargetConverter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="multipleTargetConverter" Type="System.Converter&lt;System.Type,System.String&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="stream"><see cref="T:System.IO.Stream" /> Obiekt do zapisu.</param>
        <param name="multipleTargetConverter">Delegat używany do przekonwertowania <see cref="T:System.Type" /> na ciąg.</param>
        <summary>Zapisuje strukturę jako schemat XML do określonego <see cref="T:System.IO.Stream" /> obiektu. <see cref="T:System.Data.DataSet" /></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.TextWriter writer, Converter&lt;Type,string&gt; multipleTargetConverter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.TextWriter writer, class System.Converter`2&lt;class System.Type, string&gt; multipleTargetConverter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.IO.TextWriter,System.Converter{System.Type,System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As TextWriter, multipleTargetConverter As Converter(Of Type, String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::TextWriter ^ writer, Converter&lt;Type ^, System::String ^&gt; ^ multipleTargetConverter);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.TextWriter * Converter&lt;Type, string&gt; -&gt; unit" Usage="dataSet.WriteXmlSchema (writer, multipleTargetConverter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="multipleTargetConverter" Type="System.Converter&lt;System.Type,System.String&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="writer"><see cref="T:System.IO.TextWriter" /> Obiekt do zapisu.</param>
        <param name="multipleTargetConverter">Delegat używany do przekonwertowania <see cref="T:System.Type" /> na ciąg.</param>
        <summary>Zapisuje strukturę jako schemat XML do określonego <see cref="T:System.IO.TextWriter" />. <see cref="T:System.Data.DataSet" /></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (string fileName, Converter&lt;Type,string&gt; multipleTargetConverter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(string fileName, class System.Converter`2&lt;class System.Type, string&gt; multipleTargetConverter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.String,System.Converter{System.Type,System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (fileName As String, multipleTargetConverter As Converter(Of Type, String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::String ^ fileName, Converter&lt;Type ^, System::String ^&gt; ^ multipleTargetConverter);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : string * Converter&lt;Type, string&gt; -&gt; unit" Usage="dataSet.WriteXmlSchema (fileName, multipleTargetConverter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="multipleTargetConverter" Type="System.Converter&lt;System.Type,System.String&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="fileName">Nazwa pliku do zapisu.</param>
        <param name="multipleTargetConverter">Delegat używany do przekonwertowania <see cref="T:System.Type" /> na ciąg.</param>
        <summary><see cref="T:System.Data.DataSet" /> Zapisuje strukturę jako schemat XML w pliku.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.Xml.XmlWriter writer, Converter&lt;Type,string&gt; multipleTargetConverter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.Xml.XmlWriter writer, class System.Converter`2&lt;class System.Type, string&gt; multipleTargetConverter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataSet.WriteXmlSchema(System.Xml.XmlWriter,System.Converter{System.Type,System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As XmlWriter, multipleTargetConverter As Converter(Of Type, String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::Xml::XmlWriter ^ writer, Converter&lt;Type ^, System::String ^&gt; ^ multipleTargetConverter);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.Xml.XmlWriter * Converter&lt;Type, string&gt; -&gt; unit" Usage="dataSet.WriteXmlSchema (writer, multipleTargetConverter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="multipleTargetConverter" Type="System.Converter&lt;System.Type,System.String&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="writer"><see cref="T:System.Xml.XmlWriter" /> Obiekt do zapisu.</param>
        <param name="multipleTargetConverter">Delegat używany do przekonwertowania <see cref="T:System.Type" /> na ciąg.</param>
        <summary>Zapisuje strukturę jako schemat XML do określonego <see cref="T:System.Xml.XmlWriter" />. <see cref="T:System.Data.DataSet" /></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

<Type Name="IDataAdapter" FullName="System.Data.IDataAdapter">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="4877f267408f77d2e2104534ad5ebe7e397b5b13" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30449352" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface IDataAdapter" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IDataAdapter" />
  <TypeSignature Language="DocId" Value="T:System.Data.IDataAdapter" />
  <TypeSignature Language="VB.NET" Value="Public Interface IDataAdapter" />
  <TypeSignature Language="C++ CLI" Value="public interface class IDataAdapter" />
  <AssemblyInfo>
    <AssemblyName>System.Data</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Data.Common</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Docs>
    <summary>Umożliwia obiekt, aby zaimplementować element DataAdapter i reprezentuje zestaw metod i działania związane z właściwości mapowania, które są używane do wypełnienia i aktualizowania <see cref="T:System.Data.DataSet" /> i zaktualizować źródła danych.  
  
 <see cref="T:System.Data.IDbDataAdapter" /> wystąpienia są dla źródeł danych, które są (lub podobne) relacyjnych baz danych za pomocą polecenia tekstowy (na przykład Transact-SQL), podczas gdy <see cref="T:System.Data.IDataAdapter" /> wystąpień może można użyć dowolnego typu źródła danych.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.IDataAdapter> Interfejs umożliwiający dziedziczące klasy do zaimplementowania klasy element DataAdapter, który reprezentuje mostek między źródłem danych a <xref:System.Data.DataSet>. Aby uzyskać więcej informacji na temat klas element DataAdapter, zobacz [wypełnianie zestawu danych z element DataAdapter](~/docs/framework/data/adonet/populating-a-dataset-from-a-dataadapter.md).  
  
 Aplikacja nie tworzy wystąpienie <xref:System.Data.IDataAdapter> interfejsu bezpośrednio, ale implementuje wystąpienia klasy, która dziedziczy <xref:System.Data.IDataAdapter>.  
  
 Klasy, które dziedziczą <xref:System.Data.IDataAdapter> musi implementować dziedziczone elementy członkowskie i zwykle określają dodatkowe elementy członkowskie Dodawanie funkcji specyficznych dla dostawcy. Na przykład <xref:System.Data.IDataAdapter> interfejs definiuje <xref:System.Data.IDataAdapter.Fill%2A> metody pobierającej <xref:System.Data.DataSet> jako parametr. Z kolei <xref:System.Data.OleDb.OleDbDataAdapter> klasa dziedziczy <xref:System.Data.Common.DbDataAdapter.Fill%2A> — metoda i definiuje również dwie dodatkowe przeciążeń <xref:System.Data.OleDb.OleDbDataAdapter.Fill%2A> metody prowadzące obiektu zestawu rekordów ADO jako parametr.  
  
   
  
## Examples  
 W poniższym przykładzie użyto klas pochodnych <xref:System.Data.SqlClient.SqlCommand>, <xref:System.Data.SqlClient.SqlDataAdapter>, i <xref:System.Data.SqlClient.SqlConnection>, aby wybrać rekordy z bazy danych. Wypełniony <xref:System.Data.DataSet> jest następnie zwracany. Aby to zrobić, metoda jest przekazywana zainicjowane <xref:System.Data.DataSet>, ciąg połączenia i ciągu zapytania, który jest instrukcji języka Transact-SQL SELECT.  
  
 [!code-csharp[Classic WebData SqlDataAdapter Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData SqlDataAdapter Example/CS/source.cs#1)]
 [!code-vb[Classic WebData SqlDataAdapter Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData SqlDataAdapter Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>Do podwyższenie poziomu spójności między dostawcy danych .NET Framework, nazwa klasy dziedziczące w formularzu <paramref name="Prv" /> element DataAdapter gdzie <paramref name="Prv" /> jest prefiksem uniform na wszystkie klasy w określonej przestrzeni nazw dostawcy danych .NET Framework. Na przykład <paramref name="Sql" /> jest prefiks <see cref="T:System.Data.SqlClient.SqlDataAdapter" /> klasy w <see langword="System.Data.SqlClient" /> przestrzeni nazw.  
  
 Przy dziedziczeniu z <see cref="T:System.Data.IDataAdapter" /> interfejsu, należy zaimplementować następujących konstruktorów:  
  
 <list type="table"><listheader><term> Element  
  
 </term><description> Opis elementu  
  
 </description></listheader><item><term> PrvDataAdapter()  
  
 </term><description> Inicjuje nowe wystąpienie klasy PrvDataAdapter.  
  
 </description></item><item><term> PrvDataAdapter (PrvCommand selectCommand)  
  
 </term><description> Inicjuje nowe wystąpienie klasy PrvDataAdapter przy użyciu określonej w instrukcji SQL SELECT.  
  
 </description></item><item><term> PrvDataAdapter (selectCommandText ciąg, ciąg selectConnectionString)  
  
 </term><description> Inicjuje nowe wystąpienie klasy PrvDataAdapter za pomocą instrukcji SQL SELECT i parametrów połączenia.  
  
 </description></item><item><term> PrvDataAdapter (ciąg selectCommandText, PrvConnection selectConnection)  
  
 </term><description> Inicjuje nowe wystąpienie klasy PrvDataAdapter za pomocą instrukcji SQL SELECT i obiektu PrvConnection.  
  
 </description></item></list></para>
    </block>
  </Docs>
  <Members>
    <Member MemberName="Fill">
      <MemberSignature Language="C#" Value="public int Fill (System.Data.DataSet dataSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Fill(class System.Data.DataSet dataSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.IDataAdapter.Fill(System.Data.DataSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Fill(System::Data::DataSet ^ dataSet);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
      </Parameters>
      <Docs>
        <param name="dataSet">A <see cref="T:System.Data.DataSet" /> umożliwia wypełnienie rekordów i w razie potrzeby schematu.</param>
        <summary>Dodaje lub aktualizuje wierszy w <see cref="T:System.Data.DataSet" /> do odpowiadają źródła danych przy użyciu <see cref="T:System.Data.DataSet" /> nazwy i tworzy <see cref="T:System.Data.DataTable" /> o nazwie "Tabela".</summary>
        <returns>Liczba wierszy pomyślnie dodane do lub odświeżenia w <see cref="T:System.Data.DataSet" />. Nie zawiera wierszy objętych instrukcji, które niezwracanie wierszy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.IDataAdapter.Fill%2A> pobiera wierszy ze źródła danych przy użyciu instrukcji SELECT określonego przez skojarzony <xref:System.Data.IDbDataAdapter.SelectCommand%2A> właściwości. Obiekt połączenia skojarzony z instrukcją SELECT musi być prawidłowy, ale nie musi być otwarty. Jeśli połączenie jest zamknięte przed <xref:System.Data.IDataAdapter.Fill%2A> jest wywoływana, jest otwarta do pobierania danych, następnie zamknięte. Jeśli połączenie jest otwarte przed <xref:System.Data.IDataAdapter.Fill%2A> jest wywoływana, pozostaje otwarty.  
  
 <xref:System.Data.IDataAdapter.Fill%2A> Operacji następnie dodaje wiersze do miejsca docelowego <xref:System.Data.DataTable> obiekty w <xref:System.Data.DataSet>, tworzenie <xref:System.Data.DataTable> obiekty, jeśli nie już istnieją. Podczas tworzenia <xref:System.Data.DataTable> obiektów, <xref:System.Data.IDataAdapter.Fill%2A> operacji zwykle tworzy tylko metadane nazwy kolumny. Jednak jeśli <xref:System.Data.IDataAdapter.MissingSchemaAction%2A> właściwość jest ustawiona na `AddWithKey`, również są tworzone odpowiednie klucze podstawowe i ograniczeń.  
  
 Jeśli `SelectCommand` zwraca wyniki OUTER JOIN `DataAdapter` nie ustawia <xref:System.Data.DataTable.PrimaryKey%2A> wartość powstałe w ten sposób <xref:System.Data.DataTable>. Zdefiniuj jawnie klucz podstawowy, aby upewnić się, że zduplikowane wiersze są rozpoznawane poprawnie. Aby uzyskać więcej informacji, zobacz [Definiowanie kluczy podstawowych](~/docs/framework/data/adonet/dataset-datatable-dataview/defining-primary-keys.md).  
  
 Jeśli <xref:System.Data.IDataAdapter> napotka zduplikowane kolumny podczas wypełniania <xref:System.Data.DataTable>, generuje nazw dla kolejnych kolumn, za pomocą wzorca "nazwakolumny1", "nazwakolumny2", "columnname3" i tak dalej. Jeśli dane przychodzące zawiera kolumny bez nazwy, są umieszczane <xref:System.Data.DataSet> zgodnie ze wzorcem "Kolumna1", "Column2" i tak dalej. Jeśli wiele zestawów wyników są dodawane do <xref:System.Data.DataSet>, każdy zestaw wyników jest umieszczany w osobnej tabeli. Zestawy wyników dodatkowe są nazywane przez dołączenie wartości całkowitych na wartości do nazwy określonej tabeli (na przykład "Tabela", "Tabela1", "Tabela2" i tak dalej). Aplikacje należy zachować ostrożność podczas przy użyciu nazwy kolumn i tabel, aby upewnić się, że nie występują konflikty z tych wzorców nazewnictwa.  
  
 Po instrukcji SELECT, która jest używana do wypełniania <xref:System.Data.DataSet> zwraca wiele wyników, takich jak partii instrukcji SQL, jeśli jeden z wyników zawiera błąd, wszystkie kolejne wyniki są pominięty i nie zostały dodane do <xref:System.Data.DataSet>.  
  
 Można użyć <xref:System.Data.IDataAdapter.Fill%2A> metody wiele razy w tym samym <xref:System.Data.DataTable>. Jeśli klucz podstawowy istnieje, przychodzących wierszy są scalane z pasujących wierszy, które już istnieją. Jeśli klucz podstawowy istnieje, przychodzących wierszy są dołączane do <xref:System.Data.DataTable>.  
  
> [!NOTE]
>  Podczas przetwarzania wsadowego instrukcji SQL, które zwracają wiele wartości, implementacja <xref:System.Data.IDataAdapter.Fill%2A> i <xref:System.Data.IDataAdapter.FillSchema%2A> dostawcy danych .NET Framework pobiera informacje o schemacie dla pierwszego wyniku.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.IDataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType)" />
      </Docs>
    </Member>
    <Member MemberName="FillSchema">
      <MemberSignature Language="C#" Value="public System.Data.DataTable[] FillSchema (System.Data.DataSet dataSet, System.Data.SchemaType schemaType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Data.DataTable[] FillSchema(class System.Data.DataSet dataSet, valuetype System.Data.SchemaType schemaType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.IDataAdapter.FillSchema(System.Data.DataSet,System.Data.SchemaType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataTable ^&gt; ^ FillSchema(System::Data::DataSet ^ dataSet, System::Data::SchemaType schemaType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
        <Parameter Name="schemaType" Type="System.Data.SchemaType" />
      </Parameters>
      <Docs>
        <param name="dataSet">
          <see cref="T:System.Data.DataSet" /> Do wypełnienia ze schematem ze źródła danych.</param>
        <param name="schemaType">Jeden z <see cref="T:System.Data.SchemaType" /> wartości.</param>
        <summary>Dodaje <see cref="T:System.Data.DataTable" /> o nazwie "Tabela" do określonego <see cref="T:System.Data.DataSet" /> i konfiguruje schemat do dopasowania w źródle danych, na podstawie której określony <see cref="T:System.Data.SchemaType" />.</summary>
        <returns>Tablica <see cref="T:System.Data.DataTable" /> obiektów, które zawierają informacje o schemacie zwracane ze źródła danych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.IDataAdapter.FillSchema%2A> Metoda pobiera schemat z źródła danych przy użyciu <xref:System.Data.IDbDataAdapter.SelectCommand%2A>. Obiekt połączenia skojarzony z <xref:System.Data.IDbDataAdapter.SelectCommand%2A> musi być prawidłowy, ale nie musi być otwarty. Jeśli połączenie jest zamknięte przed <xref:System.Data.IDataAdapter.FillSchema%2A> jest wywoływana, jest otwarta do pobierania danych, następnie zamknięte. Jeśli połączenie jest otwarte przed <xref:System.Data.IDataAdapter.FillSchema%2A> jest wywoływana, pozostaje otwarty.  
  
 A <xref:System.Data.IDataAdapter.FillSchema%2A> dodaje operacji <xref:System.Data.DataTable> do miejsca docelowego <xref:System.Data.DataSet>. Następnie dodaje kolumny <xref:System.Data.DataColumnCollection> z <xref:System.Data.DataTable> i konfiguruje następujące opcje <xref:System.Data.DataColumn> właściwości, jeśli istnieją w źródle danych:  
  
-   <xref:System.Data.DataColumn.AllowDBNull%2A>  
  
-   <xref:System.Data.DataColumn.AutoIncrement%2A>. Należy ustawić <xref:System.Data.DataColumn.AutoIncrementStep%2A> i <xref:System.Data.DataColumn.AutoIncrementSeed%2A> osobno.  
  
-   <xref:System.Data.DataColumn.MaxLength%2A>  
  
-   <xref:System.Data.DataColumn.ReadOnly%2A>  
  
-   <xref:System.Data.DataColumn.Unique%2A>  
  
 <xref:System.Data.IDataAdapter.FillSchema%2A> konfiguruje również <xref:System.Data.DataTable.PrimaryKey%2A> i <xref:System.Data.DataTable.Constraints%2A> właściwości zgodnie z następującymi zasadami:  
  
-   Jeśli jeden lub więcej kolumn klucza podstawowego są zwracane przez <xref:System.Data.IDbDataAdapter.SelectCommand%2A>, są używane jako kolumny klucza podstawowego dla <xref:System.Data.DataTable>.  
  
-   Jeśli są zwracane nie kolumn klucza podstawowego, ale są unikatowe kolumny, unikatowe kolumny są używane jako klucz podstawowy, jeśli wszystkie unikatowe kolumny mają wartości null. Jeśli dowolnej kolumny dopuszczają wartości null, <xref:System.Data.UniqueConstraint> jest dodawany do <xref:System.Data.ConstraintCollection>, ale <xref:System.Data.DataTable.PrimaryKey%2A> nie ustawiono właściwości.  
  
-   Jeśli zarówno kolumn klucza podstawowego, jak i unikatowe kolumny są zwracane, kolumny klucza podstawowego są używane jako kolumny klucza podstawowego dla <xref:System.Data.DataTable>.  
  
 Należy pamiętać, że klucze podstawowe i ograniczenia unique są dodawane do <xref:System.Data.ConstraintCollection> zgodnie z poprzednich zasad, ale także inne ograniczenia typów nie zostaną dodane.  
  
 Jeśli klastrowany unikatowy indeks jest zdefiniowany w kolumnie lub kolumny w tabeli programu SQL Server i ograniczenia klucza podstawowego została zdefiniowana osobny zestaw kolumn, będzie zwracana nazwy kolumn w indeksu klastrowanego. Aby zwrócić nazwę lub nazwy kolumn klucza podstawowego, należy użyć wskazówki zapytania z instrukcji SELECT, która określa nazwę indeksu klucza podstawowego. Aby uzyskać więcej informacji na temat określania wskazówki zapytania, zobacz [wskazówki zapytania (Transact-SQL)](http://msdn.microsoft.com/library/ms181714.aspx).  
  
 Jeśli <xref:System.Data.IDataAdapter> napotka zduplikowane kolumny podczas wypełniania <xref:System.Data.DataTable>, generuje nazw dla kolejnych kolumn, za pomocą wzorca "nazwakolumny1", "nazwakolumny2", "columnname3" i tak dalej. Jeśli dane przychodzące zawiera kolumny bez nazwy, są umieszczane <xref:System.Data.DataSet> zgodnie ze wzorcem "Kolumna1", "Column2" i tak dalej. Jeśli wiele zestawów wyników są dodawane do <xref:System.Data.DataSet>, każdy zestaw wyników jest umieszczany w osobnej tabeli. Zestawy wyników dodatkowe są nazywane przez dołączenie wartości całkowitych na wartości do nazwy określonej tabeli (na przykład "Tabela", "Tabela1", "Tabela2" i tak dalej). Aplikacje należy zachować ostrożność podczas przy użyciu nazwy kolumn i tabel, aby upewnić się, że nie występują konflikty z tych wzorców nazewnictwa.  
  
 <xref:System.Data.IDataAdapter.FillSchema%2A> zwraca żadnych wierszy. Użyj <xref:System.Data.IDataAdapter.Fill%2A> metody w celu dodania wierszy do <xref:System.Data.DataTable>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.IDataAdapter.Fill(System.Data.DataSet)" />
      </Docs>
    </Member>
    <Member MemberName="GetFillParameters">
      <MemberSignature Language="C#" Value="public System.Data.IDataParameter[] GetFillParameters ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Data.IDataParameter[] GetFillParameters() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.IDataAdapter.GetFillParameters" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFillParameters () As IDataParameter()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::IDataParameter ^&gt; ^ GetFillParameters();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.IDataParameter[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera parametry ustawione przez użytkownika podczas wykonywania instrukcji SQL SELECT.</summary>
        <returns>Tablica <see cref="T:System.Data.IDataParameter" /> obiektów, które zawiera parametry ustawiony przez użytkownika.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
```  
private static void GetParameters(String connectiongString) {  
           using (SqlConnection conn = new SqlConnection(connectiongString)) {  
              String queryString = "Select [CourseID],[Title],[Credits] from [MySchool].[dbo].[Course] where [Year]=@Year and [Credits]>=@Credits";   
              SqlParameter year = new SqlParameter("@Year", 2012);   
              SqlParameter credits = new SqlParameter("@Credits", SqlDbType.Int, 4, "Credits");   
              credits.Value = 4; SqlCommand command = new SqlCommand(queryString, conn);   
              command.Parameters.Add(year);   
              command.Parameters.Add(credits);   
              IDbDataAdapter mySchool = new SqlDataAdapter(command);   
              IDataParameter[] parameters = mySchool.GetFillParameters();  
              Console.WriteLine("{0,-15}{1,-15}{2,-15}{3,-15}{4,-15}", "ParameterName", "SourceColumn", "Direction", "DbType", "Value");   
              foreach (IDataParameter parameter in parameters) {   
                 Console.WriteLine("{0,-15}{1,-15}{2,-15}{3,-15}{4,-15}", parameter.ParameterName, parameter.SourceColumn, parameter.Direction, parameter.DbType, parameter.Value);   
              }  
           }  
        }  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MissingMappingAction">
      <MemberSignature Language="C#" Value="public System.Data.MissingMappingAction MissingMappingAction { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.MissingMappingAction MissingMappingAction" />
      <MemberSignature Language="DocId" Value="P:System.Data.IDataAdapter.MissingMappingAction" />
      <MemberSignature Language="VB.NET" Value="Public Property MissingMappingAction As MissingMappingAction" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::MissingMappingAction MissingMappingAction { System::Data::MissingMappingAction get(); void set(System::Data::MissingMappingAction value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.MissingMappingAction</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wskazuje lub określa, czy źródło Niemapowane tabele lub kolumny są przekazywane z ich nazwy źródła celu filtrowane lub Zgłoś błąd.</summary>
        <value>Jeden z <see cref="T:System.Data.MissingMappingAction" /> wartości. Wartość domyślna to <see langword="Passthrough" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.IDataAdapter.TableMappings%2A> Właściwość zapewnia wzorca mapowanie między zwróconych rekordów i <xref:System.Data.DataSet>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Podana wartość nie jest jednym z <see cref="T:System.Data.MissingMappingAction" /> wartości.</exception>
        <altmember cref="P:System.Data.IDataAdapter.MissingSchemaAction" />
      </Docs>
    </Member>
    <Member MemberName="MissingSchemaAction">
      <MemberSignature Language="C#" Value="public System.Data.MissingSchemaAction MissingSchemaAction { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.MissingSchemaAction MissingSchemaAction" />
      <MemberSignature Language="DocId" Value="P:System.Data.IDataAdapter.MissingSchemaAction" />
      <MemberSignature Language="VB.NET" Value="Public Property MissingSchemaAction As MissingSchemaAction" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::MissingSchemaAction MissingSchemaAction { System::Data::MissingSchemaAction get(); void set(System::Data::MissingSchemaAction value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.MissingSchemaAction</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wskazuje lub określa, czy Brak źródła tabel, kolumn i ich relacji zostaną dodane do schematu zestawu danych, ignorowanie, lub spowodować wystąpienie błędu wygenerowany.</summary>
        <value>Jeden z <see cref="T:System.Data.MissingSchemaAction" /> wartości. Wartość domyślna to <see langword="Add" />.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Podana wartość nie jest jednym z <see cref="T:System.Data.MissingSchemaAction" /> wartości.</exception>
        <altmember cref="P:System.Data.Common.DataAdapter.MissingMappingAction" />
      </Docs>
    </Member>
    <Member MemberName="TableMappings">
      <MemberSignature Language="C#" Value="public System.Data.ITableMappingCollection TableMappings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.ITableMappingCollection TableMappings" />
      <MemberSignature Language="DocId" Value="P:System.Data.IDataAdapter.TableMappings" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TableMappings As ITableMappingCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::ITableMappingCollection ^ TableMappings { System::Data::ITableMappingCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.ITableMappingCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wskazuje, jak tabela źródłowa jest zamapowana do tabeli dataset.</summary>
        <value>Kolekcja, która zapewnia wzorca mapowanie między zwróconych rekordów i <see cref="T:System.Data.DataSet" />. Wartość domyślna to pustej kolekcji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.IDataAdapter> Używa tylko mapowania dla tabeli źródłowej o nazwie "Tabela". Wszystkie wybierz instrukcje INSERT, DELETE i UPDATE zwracający dane musi to zrobić przy użyciu nazw kolumn spójne. Zwrócony w rekordach nazwy kolumn muszą być unikatowe, w przeciwnym razie kolumny o takich samych nazwach zastępowania poprzednie dane. Na <xref:System.Data.IDataAdapter.Update%2A>, tylko tabeli zamapowane do tabeli źródłowej o nazwie "Tabeli" będzie mieć jego zmiany uzgodnione.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Update">
      <MemberSignature Language="C#" Value="public int Update (System.Data.DataSet dataSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Update(class System.Data.DataSet dataSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.IDataAdapter.Update(System.Data.DataSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Update(System::Data::DataSet ^ dataSet);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSet" Type="System.Data.DataSet" />
      </Parameters>
      <Docs>
        <param name="dataSet">
          <see cref="T:System.Data.DataSet" /> Używana do aktualizowania źródła danych.</param>
        <summary>Wywołuje odpowiednie instrukcje INSERT, UPDATE lub DELETE dla każdego wstawienia, aktualizacji lub usunięcia wiersza w określonej <see cref="T:System.Data.DataSet" /> z <see cref="T:System.Data.DataTable" /> o nazwie "Tabela".</summary>
        <returns>Liczba pomyślnie zaktualizowanych z <see cref="T:System.Data.DataSet" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy aplikacja wywołuje <xref:System.Data.IDataAdapter.Update%2A> metody <xref:System.Data.IDataAdapter> sprawdza <xref:System.Data.DataRow.RowState%2A> właściwości i wykonuje wymaganych instrukcji INSERT, UPDATE lub DELETE wielokrotnie powtarzane dla każdego wiersza, na podstawie kolejności indeksów skonfigurowane w <xref:System.Data.DataSet>. Na przykład <xref:System.Data.IDataAdapter.Update%2A> mogą wykonać z powodu kolejność wierszy w instrukcji DELETE, a następnie za pomocą instrukcji INSERT, a następnie inne instrukcji DELETE, <xref:System.Data.DataTable>.  
  
 Należy pamiętać, że oświadczenia te nie są wykonywane jako przetwarzania wsadowego; Każdy wiersz jest aktualizowana pojedynczo. Aplikacja może wywołać <xref:System.Data.DataSet.GetChanges%2A> metodę, jeśli musi sterowania sekwencją typów instrukcji (na przykład wstawia przed aktualizacji). Aby uzyskać więcej informacji, zobacz [aktualizowanie źródła danych z obiektów DataAdapter](~/docs/framework/data/adonet/updating-data-sources-with-dataadapters.md).  
  
 Jeśli nie zostały określone instrukcji INSERT, UPDATE lub DELETE, <xref:System.Data.Common.DataAdapter.Update%2A> metoda generuje wyjątek. Można jednak utworzyć <xref:System.Data.SqlClient.SqlCommandBuilder> lub <xref:System.Data.OleDb.OleDbCommandBuilder> obiekt, aby automatycznie wygenerować instrukcji SQL aktualizacje pojedynczej tabeli, jeśli ustawisz `SelectCommand` właściwości dostawcy danych .NET Framework. Następnie żadnych dodatkowych instrukcji SQL, które nie zostały ustawione są generowane przez CommandBuilder. Tę logikę generowania wymaga informacji o kolumnie klucza znajdować się w <xref:System.Data.DataSet>. Aby uzyskać więcej informacji, zobacz [generowania poleceń CommandBuilders](~/docs/framework/data/adonet/generating-commands-with-commandbuilders.md).  
  
 <xref:System.Data.Common.DataAdapter.Update%2A> Metoda pobiera wiersze z tabeli umieszczone w pierwszym mapowania przed wykonaniem operacji aktualizacji. <xref:System.Data.Common.DataAdapter.Update%2A> Następnie aktualizuje wiersza przy użyciu wartości <xref:System.Data.IDbCommand.UpdatedRowSource%2A> właściwości. Dodatkowe wiersze zwracane są ignorowane.  
  
 Po załadowaniu danych do <xref:System.Data.DataSet>, <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> zdarzenia, dzięki czemu użytkownik do sprawdzenia uzgodniony <xref:System.Data.DataSet> wiersza i wszystkie dane wyjściowe Parametry zwracane przez polecenie. Po wierszu aktualizacji pomyślnie, zmiany w tym wierszu są akceptowane.  
  
 Korzystając z <xref:System.Data.IDataAdapter.Update%2A>, kolejność wykonywania jest następujący:  
  
1.  Wartości w <xref:System.Data.DataRow> zostaną przeniesione do wartości parametrów.  
  
2.  <xref:System.Data.Common.DbDataAdapter.OnRowUpdating%2A> Zdarzenia.  
  
3.  Wykonuje polecenia.  
  
4.  Jeśli polecenie ma ustawioną wartość `FirstReturnedRecord`, a następnie pierwszy zwrócony wynik jest umieszczany <xref:System.Data.DataRow>.  
  
5.  W przypadku parametrów wyjściowych są umieszczane <xref:System.Data.DataRow>.  
  
6.  <xref:System.Data.Common.DbDataAdapter.OnRowUpdated%2A> Zdarzenia.  
  
7.  <xref:System.Data.DataRow.AcceptChanges%2A> jest wywoływana.  
  
 Każde polecenie skojarzone z <xref:System.Data.IDataAdapter> zwykle ma kolekcję parametrów skojarzonych z nim. Parametry są zamapowane do bieżącego wiersza za pośrednictwem `SourceColumn` i `SourceVersion` właściwości dostawcy danych .NET Framework `Parameter` klasy. `SourceColumn` odwołuje się do <xref:System.Data.DataTable> kolumny który <xref:System.Data.IDataAdapter> odwołania do uzyskania wartości parametrów dla bieżącego wiersza.  
  
 `SourceColumn` odwołuje się do nazwy kolumny Niemapowane przed mapowań tabeli zostały zastosowane. Jeśli `SourceColumn` odwołuje się do nieistniejącej kolumny akcję wykonywaną zależy od jednego z następujących <xref:System.Data.MissingMappingAction> wartości.  
  
|Wartość wyliczenia|Działań|  
|-----------------------|------------------|  
|`MissingMappingAction.Passthrough`|Użyj nazwy kolumn źródła i nazwy tabeli w <xref:System.Data.DataSet> Jeśli mapowanie nie jest obecny.|  
|`MissingMappingAction.Ignore`|A <xref:System.SystemException> jest generowany. Mapowania jawnie ustawione, brakuje mapowania parametru wejściowego zazwyczaj przyczyną jest błąd.|  
|`MissingMappingAction.Error`|A <xref:System.SystemException> jest generowany.|  
  
 `SourceColumn` Właściwości są również używane do mapowania wartości dla danych wyjściowych lub parametry wejścia/wyjścia z powrotem do `DataSet`. Wyjątek jest generowany, gdy odwołuje się do nieistniejącej kolumny.  
  
 `SourceVersion` Właściwości dostawcy danych .NET Framework `Parameter` klasy określa, czy użyć `Original`, `Current`, lub `Proposed` wersja wartości kolumny. Ta funkcja jest często używany do uwzględnienia oryginalnych wartości w klauzuli WHERE instrukcji UPDATE, aby wyszukać naruszeń optymistycznej współbieżności.  
  
> [!NOTE]
>  Jeśli wystąpi błąd podczas aktualizowania wiersza, jest zgłaszany wyjątek i wykonywania aktualizacji nie jest już obsługiwana. Aby kontynuować operację aktualizacji bez generowania wyjątków, gdy wystąpi błąd, ustaw <xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A> właściwości `true` przed wywołaniem <xref:System.Data.Common.DbDataAdapter.Update%2A>. Mogą również odpowiadać błędów na podstawie na wiersz, w ramach `RowUpdated` zdarzeń element DataAdapter. Aby kontynuować operację aktualizacji bez generowania wyjątku `RowUpdated` zdarzeń, ustaw <xref:System.Data.Common.RowUpdatedEventArgs.Status%2A> właściwość <xref:System.Data.Common.RowUpdatedEventArgs> do <xref:System.Data.UpdateStatus.Continue>.  
  
   
  
## Examples  
 W poniższym przykładzie użyto klasy pochodnej <xref:System.Data.OleDb.OleDbDataAdapter>, do <xref:System.Data.Common.DataAdapter.Update%2A> źródła danych. W tym przykładzie przyjęto założenie, że utworzono <xref:System.Data.OleDb.OleDbDataAdapter> i <xref:System.Data.DataSet>.  
  
 [!code-csharp[Classic WebData DataAdapter.IDataAdapter.Update Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataAdapter.IDataAdapter.Update Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataAdapter.IDataAdapter.Update Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataAdapter.IDataAdapter.Update Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.DBConcurrencyException">Próba wykonania instrukcji INSERT, UPDATE lub DELETE spowodowała zero zmodyfikowanych rekordów.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
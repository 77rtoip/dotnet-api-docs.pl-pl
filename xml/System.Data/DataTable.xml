<Type Name="DataTable" FullName="System.Data.DataTable">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="300369f702f863e5f202e1c54c0a83eb9edf7782" />
    <Meta Name="ms.sourcegitcommit" Value="d40b35262cbc997b79bf76da3a39ccf59b738efc" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="12/05/2018" />
    <Meta Name="ms.locfileid" Value="52918438" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class DataTable : System.ComponentModel.MarshalByValueComponent, System.ComponentModel.IListSource, System.ComponentModel.ISupportInitialize, System.ComponentModel.ISupportInitializeNotification, System.Runtime.Serialization.ISerializable, System.Xml.Serialization.IXmlSerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit DataTable extends System.ComponentModel.MarshalByValueComponent implements class System.ComponentModel.IListSource, class System.ComponentModel.ISupportInitialize, class System.ComponentModel.ISupportInitializeNotification, class System.Runtime.Serialization.ISerializable, class System.Xml.Serialization.IXmlSerializable" />
  <TypeSignature Language="DocId" Value="T:System.Data.DataTable" />
  <TypeSignature Language="VB.NET" Value="Public Class DataTable&#xA;Inherits MarshalByValueComponent&#xA;Implements IListSource, ISerializable, ISupportInitialize, ISupportInitializeNotification, IXmlSerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class DataTable : System::ComponentModel::MarshalByValueComponent, System::ComponentModel::IListSource, System::ComponentModel::ISupportInitialize, System::ComponentModel::ISupportInitializeNotification, System::Runtime::Serialization::ISerializable, System::Xml::Serialization::IXmlSerializable" />
  <TypeSignature Language="F#" Value="type DataTable = class&#xA;    inherit MarshalByValueComponent&#xA;    interface IListSource&#xA;    interface ISupportInitializeNotification&#xA;    interface ISerializable&#xA;    interface IXmlSerializable&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System.Data.Common</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Data</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.MarshalByValueComponent</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.IListSource</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitializeNotification</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Xml.Serialization.IXmlSerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
      <AttributeName>System.ComponentModel.DefaultEvent("RowChanging")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
      <AttributeName>System.ComponentModel.DefaultProperty("TableName")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
      <AttributeName>System.ComponentModel.DesignTimeVisible(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.DataTableEditor, Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
      <AttributeName>System.ComponentModel.ToolboxItem(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
      <AttributeName>System.Xml.Serialization.XmlSchemaProvider("GetDataTableSchema")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.DataTableEditor, Microsoft.VSDesigner, Version=7.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.DataTableEditor, Microsoft.VSDesigner, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.DataTableEditor, Microsoft.VSDesigner, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
      <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.DataTableEditor, Microsoft.VSDesigner, Version=9.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.5.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje jedną tabelę danych w pamięci.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable> Jest obiektem centralnej w bibliotece programu ADO.NET. Inne obiekty, które używają <xref:System.Data.DataTable> obejmują <xref:System.Data.DataSet> i <xref:System.Data.DataView>.  
  
 Podczas uzyskiwania dostępu do <xref:System.Data.DataTable> obiektów, należy pamiętać, że są one warunkowo z uwzględnieniem wielkości liter. Na przykład, jeśli taki <xref:System.Data.DataTable> nosi nazwę "mydatatable" i innego nosi nazwę "Mydatatable", ciąg używany do wyszukiwania dla jednej z tabel, jest traktowany jako wielkość liter. Jednak jeśli "Mydatatable" nie istnieje "mydatatable", ciąg wyszukiwania jest traktowany bez uwzględniania wielkości liter. A <xref:System.Data.DataSet> może zawierać dwóch <xref:System.Data.DataTable> obiekty, które mają taki sam <xref:System.Data.DataTable.TableName%2A> wartości właściwości, ale o różnych <xref:System.Data.DataTable.Namespace%2A> wartości właściwości. Aby uzyskać więcej informacji na temat pracy z usługą <xref:System.Data.DataTable> obiekty, zobacz [Tworzenie elementu DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/creating-a-datatable.md).  
  
 Jeśli tworzysz <xref:System.Data.DataTable> programowo, należy najpierw zdefiniować jego schemat, dodając <xref:System.Data.DataColumn> obiekty do <xref:System.Data.DataColumnCollection> (dostępne za pośrednictwem <xref:System.Data.DataTable.Columns%2A> właściwości). Aby uzyskać więcej informacji o dodawaniu <xref:System.Data.DataColumn> obiekty, zobacz [Dodawanie kolumn do DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/adding-columns-to-a-datatable.md).  
  
 Aby dodać wiersze do <xref:System.Data.DataTable>, należy najpierw użyć <xref:System.Data.DataTable.NewRow%2A> metodę, aby zwrócić nowe <xref:System.Data.DataRow> obiektu. <xref:System.Data.DataTable.NewRow%2A> Metoda zwraca wiersz ze schematem <xref:System.Data.DataTable>, ponieważ jest on zdefiniowany w tabeli <xref:System.Data.DataColumnCollection>. Maksymalna liczba wierszy, które <xref:System.Data.DataTable> można magazyn jest 16,777,216. Aby uzyskać więcej informacji, zobacz [Dodawanie danych do elementu DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/adding-data-to-a-datatable.md).  
  
 <xref:System.Data.DataTable> Również zawiera zbiór <xref:System.Data.Constraint> obiektów, które mogą służyć do zapewnienia integralności danych. Aby uzyskać więcej informacji, zobacz [ograniczenia elementu DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/datatable-constraints.md).  
  
 Istnieje wiele <xref:System.Data.DataTable> zdarzenia, które może służyć do określenia, kiedy zmiany zostały wprowadzone do tabeli. Obejmują one <xref:System.Data.DataTable.RowChanged>, <xref:System.Data.DataTable.RowChanging>, <xref:System.Data.DataTable.RowDeleting>, i <xref:System.Data.DataTable.RowDeleted>. Aby uzyskać więcej informacji o zdarzeniach, które mogą być używane z <xref:System.Data.DataTable>, zobacz [Obsługa zdarzeń elementu DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md).  
  
 Jeśli wystąpienie <xref:System.Data.DataTable> zostanie utworzony, niektóre z odczytu/zapisu właściwości są ustawione na wartości początkowe. Aby uzyskać listę tych wartości, zobacz <xref:System.Data.DataTable.%23ctor%2A?displayProperty=nameWithType> Konstruktor tematu.  
  
> [!NOTE]
>  <xref:System.Data.DataSet> i <xref:System.Data.DataTable> obiekty dziedziczyć <xref:System.ComponentModel.MarshalByValueComponent>i obsługuje <xref:System.Runtime.Serialization.ISerializable> interfejs do komunikacji zdalnej w programie .NET Framework. Są to jedyne obiekty ADO.NET, używanych do komunikacji zdalnej w programie .NET Framework.  
  
   
  
## Examples  
 Poniższy przykład tworzy dwie <xref:System.Data.DataTable> obiektów i jeden <xref:System.Data.DataRelation> obiektu i dodaje nowe obiekty <xref:System.Data.DataSet>. Tabele są następnie wyświetlane w <xref:System.Windows.Forms.DataGridView> kontroli.  
  
 [!code-csharp[Classic WebData DataTable Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable Example/VB/source.vb#1)]  
  
 W tym przykładzie pokazano, jak ręczne tworzenie elementu DataTable przy użyciu określonego schematu definicji:  
  
-   Utwórz wiele DataTable i zdefiniuj kolumn początkowych.  
  
-   Tworzenie ograniczenia tabeli.  
  
-   Wstaw wartości i wyświetlania w tabelach.  
  
-   Tworzenie kolumn wyrażeń i wyświetlania w tabelach.  
  
 Projekty języka C# i Visual Basic z tego przykładu kodu można znaleźć na [Developer Code Samples](https://code.msdn.microsoft.com/How-to-create-DataTable-7abb4914).  
  
 [!code-csharp[Classic WebData DataTable Example2#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/classic webdata datatable example2/cs/source.cs#1)]
 [!code-vb[Classic WebData DataTable Example2#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/classic webdata datatable example2/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Ten typ jest bezpieczne dla operacji wielowątkowych odczytu. Należy zsynchronizować wszystkie operacje zapisu.</threadsafe>
    <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Data.DataTable" /> klasy.</summary>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataTable ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataTable();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Data.DataTable" /> klasy bez argumentów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Konstruktor ustawia wartość początkową dla wszystkich właściwości <xref:System.Data.DataTable> obiektu. W poniższej tabeli przedstawiono właściwości i ich wartości domyślne. Jeśli wystąpienie <xref:System.Data.DataTable> zostanie utworzony, następujące właściwości są ustawione na wartości początkowe odczytu/zapisu.  
  
|Właściwość|Wartość domyślna|  
|--------------|-------------------|  
|**CaseSensitive**|Taka sama jak nadrzędnego <xref:System.Data.DataSet>, jeśli należy do jednego. W przeciwnym razie `false`.|  
|**DisplayExpression**|Pusty ciąg ("")|  
|**Wersja regionalna**|Taka sama jak nadrzędnego <xref:System.Data.DataSet> obiektu <xref:System.Globalization.CultureInfo> (zwrócone przez <xref:System.Data.DataSet.Locale%2A> właściwość); Jeśli istnieje Brak elementu nadrzędnego, wartością domyślną jest bieżący system <xref:System.Globalization.CultureInfo>.|  
|**MinimumCapacity**|50 wierszy.|  
  
 Możesz zmienić wartość dla każdego z tych właściwości, za pośrednictwem oddzielne wywołania do właściwości.  
  
   
  
## Examples  
 Poniższy przykład tworzy nowy <xref:System.Data.DataTable> z <xref:System.Data.DataColumn> i <xref:System.Data.DataRow>i wyświetla go w <xref:System.Windows.Forms.DataGridView> kontroli.  
  
 [!code-csharp[Classic WebData DataTable.DataTable Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.DataTable Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.DataTable Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.DataTable Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataTable (string tableName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string tableName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (tableName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataTable(System::String ^ tableName);" />
      <MemberSignature Language="F#" Value="new System.Data.DataTable : string -&gt; System.Data.DataTable" Usage="new System.Data.DataTable tableName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="tableName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="tableName">Nazwa do nadania w tabeli. Jeśli <paramref name="tableName" /> jest <see langword="null" /> lub pustym ciągiem, zostanie podana nazwa domyślna, po dodaniu do <see cref="T:System.Data.DataTableCollection" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Data.DataTable" /> klasy o nazwie określonej tabeli.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy <xref:System.Data.DataTable> i wyświetla go w <xref:System.Windows.Forms.DataGridView> kontroli.  
  
 [!code-csharp[Classic WebData DataTable.DataTable1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.DataTable1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.DataTable1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.DataTable1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DataTable (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DataTable(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new System.Data.DataTable : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Data.DataTable" Usage="new System.Data.DataTable (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Dane potrzebne do serializacji lub deserializacji obiektu.</param>
        <param name="context">Źródło i miejsce docelowe danego strumienia serializacji.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Data.DataTable" /> klasy <see cref="T:System.Runtime.Serialization.SerializationInfo" /> i <see cref="T:System.Runtime.Serialization.StreamingContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta implementacja <xref:System.Data.DataTable> konstruktora jest wymagany dla <xref:System.Runtime.Serialization.ISerializable>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataTable (string tableName, string tableNamespace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string tableName, string tableNamespace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (tableName As String, tableNamespace As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataTable(System::String ^ tableName, System::String ^ tableNamespace);" />
      <MemberSignature Language="F#" Value="new System.Data.DataTable : string * string -&gt; System.Data.DataTable" Usage="new System.Data.DataTable (tableName, tableNamespace)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="tableName" Type="System.String" />
        <Parameter Name="tableNamespace" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="tableName">Nazwa do nadania w tabeli. Jeśli <paramref name="tableName" /> jest <see langword="null" /> lub pustym ciągiem, zostanie podana nazwa domyślna, po dodaniu do <see cref="T:System.Data.DataTableCollection" />.</param>
        <param name="tableNamespace">Przestrzeń nazw dla Reprezentacja XML danych przechowywanych w <see langword="DataTable" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Data.DataTable" /> przy użyciu nazwy określonej tabeli i przestrzeni nazw.</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="AcceptChanges">
      <MemberSignature Language="C#" Value="public void AcceptChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.AcceptChanges" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcceptChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcceptChanges();" />
      <MemberSignature Language="F#" Value="member this.AcceptChanges : unit -&gt; unit" Usage="dataTable.AcceptChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zatwierdza wszystkie zmiany wprowadzone do tej tabeli od czasu ostatniego <see cref="M:System.Data.DataTable.AcceptChanges" /> została wywołana.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Data.DataTable.AcceptChanges%2A> jest wywoływana, dowolny <xref:System.Data.DataRow> obiekt nadal w trybie edycji kończy się pomyślnie jego zmian. <xref:System.Data.DataRowState> Zmienia także: wszystkie `Added` i `Modified` wierszy stają się `Unchanged`, i `Deleted` wiersze zostaną usunięte.  
  
 <xref:System.Data.DataTable.AcceptChanges%2A> Wywoływana jest metoda ogólnie <xref:System.Data.DataTable> po użytkownik podejmie próbę aktualizacji <xref:System.Data.DataSet> przy użyciu <xref:System.Data.Common.DbDataAdapter.Update%2A?displayProperty=nameWithType> metody.  
  
   
  
## Examples  
 Następujący przykład sprawdza każdej tabeli błędów. Jeśli błędy tabeli może być uzgodnione (przez przekazanie jej do niezdefiniowanej funkcji), <xref:System.Data.DataTable.AcceptChanges%2A> jest wywołany; w przeciwnym razie <xref:System.Data.DataTable.RejectChanges%2A> jest wywoływana.  
  
 [!code-csharp[Classic WebData DataTable.AcceptChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.AcceptChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.AcceptChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.AcceptChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public virtual void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="dataTable.BeginInit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rozpoczyna się inicjowanie <see cref="T:System.Data.DataTable" /> który jest używany w formularzu lub używany przez inny składnik. Inicjowanie odbywa się w czasie wykonywania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Środowisku projektowym programu Visual Studio .NET używa tej metody, aby rozpocząć inicjowanie składnik, który jest używany w formularzu lub używany przez inny składnik. <xref:System.Data.DataTable.EndInit%2A> Metoda kończy się inicjowanie. Za pomocą <xref:System.Data.DataTable.BeginInit%2A> i <xref:System.Data.DataTable.EndInit%2A> metody zapobiega używana przed pełnym zainicjowaniem formantu.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="BeginLoadData">
      <MemberSignature Language="C#" Value="public void BeginLoadData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginLoadData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.BeginLoadData" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginLoadData ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginLoadData();" />
      <MemberSignature Language="F#" Value="member this.BeginLoadData : unit -&gt; unit" Usage="dataTable.BeginLoadData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Powoduje wyłączenie powiadomień, konserwacja indeksu i ograniczenia podczas ładowania danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Data.DataTable.BeginLoadData%2A> w połączeniu z <xref:System.Data.DataTable.LoadDataRow%2A> i <xref:System.Data.DataTable.EndLoadData%2A>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="CaseSensitive">
      <MemberSignature Language="C#" Value="public bool CaseSensitive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CaseSensitive" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.CaseSensitive" />
      <MemberSignature Language="VB.NET" Value="Public Property CaseSensitive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CaseSensitive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CaseSensitive : bool with get, set" Usage="System.Data.DataTable.CaseSensitive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableCaseSensitiveDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wskazuje, czy w tabeli w porównaniach ciągów jest rozróżniana wielkość liter.</summary>
        <value>
          <see langword="true" /> Jeśli wynikiem porównania jest uwzględniana wielkość liter; w przeciwnym razie <see langword="false" />. Wartość domyślna jest równa nadrzędnej <see cref="T:System.Data.DataSet" /> obiektu <see cref="P:System.Data.DataSet.CaseSensitive" /> właściwości lub <see langword="false" /> Jeśli <see cref="T:System.Data.DataTable" /> został utworzony, niezależnie od <see cref="T:System.Data.DataSet" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.CaseSensitive%2A> Właściwość ma wpływ na porównań ciągów, sortowanie, wyszukiwanie i filtrowanie.  
  
   
  
## Examples  
 Poniższy przykład wywołuje <xref:System.Data.DataTable.Select%2A> metodę dwa razy na <xref:System.Data.DataTable>. Po raz pierwszy, <xref:System.Data.DataTable.CaseSensitive%2A> właściwość jest ustawiona na `false`, drugi, aby `true`.  
  
 [!code-csharp[Classic WebData DataTable.CaseSensitive Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.CaseSensitive Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.CaseSensitive Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.CaseSensitive Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataTable.Select" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="ChildRelations">
      <MemberSignature Language="C#" Value="public System.Data.DataRelationCollection ChildRelations { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataRelationCollection ChildRelations" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.ChildRelations" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ChildRelations As DataRelationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataRelationCollection ^ ChildRelations { System::Data::DataRelationCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ChildRelations : System.Data.DataRelationCollection" Usage="System.Data.DataTable.ChildRelations" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableChildRelationsDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRelationCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję podrzędnych relacji między deweloperami rozwiązań to <see cref="T:System.Data.DataTable" />.</summary>
        <value>Element <see cref="T:System.Data.DataRelationCollection" /> zawierający relacje podrzędne dla tabeli. Pusta kolekcja jest zwracany, jeśli nie <see cref="T:System.Data.DataRelation" /> istnieją obiekty.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Data.DataRelation> definiuje relację między dwiema tabelami. Zazwyczaj dwie tabele są połączone za pośrednictwem pojedynczego pola, które zawiera te same dane. Na przykład tabelę, która zawiera dane adresów może mieć jedno pole zawierające kody, które reprezentują kraje/regiony. Drugą tabelę, która zawiera dane, kraj/region będzie mieć jedno pole, który zawiera kod, który identyfikuje kraj/region, i jest ten kod, który jest wstawiany do odpowiednich pól w pierwszej tabeli. A <xref:System.Data.DataRelation>, następnie zawiera co najmniej cztery rodzajów informacji: (1) Nazwa pierwszej tabeli, (2 Nazwa kolumny w pierwszej tabeli, (3) nazwa drugiej tabeli i (4) Nazwa kolumny w drugiej tabeli.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Data.DataTable.ChildRelations%2A> właściwości, aby powrócić do każdego elementu podrzędnego <xref:System.Data.DataRelation> w <xref:System.Data.DataTable>. Każda relacja jest następnie używana jako argument w <xref:System.Data.DataRow.GetChildRows%2A> metody <xref:System.Data.DataRow> aby zwracało tablicę wierszy. Wartość każdej kolumny w tym wierszu jest następnie wydrukowany.  
  
 [!code-csharp[Classic WebData DataTable.ChildRelations Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ChildRelations Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ChildRelations Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ChildRelations Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.ParentRelations" />
        <altmember cref="M:System.Data.DataRow.GetParentRows(System.String)" />
        <altmember cref="M:System.Data.DataRow.GetChildRows(System.String)" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="dataTable.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Czyści <see cref="T:System.Data.DataTable" /> wszystkich danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszystkie wiersze we wszystkich tabelach są usuwane. Wyjątek jest generowany, jeśli tabela zawiera wszystkie relacje wymuszone podrzędnych, powodujące wiersze podrzędne być oddzielone.  
  
 Jeśli <xref:System.Data.DataSet> jest powiązany z <xref:System.Xml.XmlDataDocument>, wywoływania <xref:System.Data.DataSet.Clear%2A?displayProperty=nameWithType> lub <xref:System.Data.DataTable.Clear%2A?displayProperty=nameWithType> zgłasza <xref:System.NotSupportedException>. Aby uniknąć tej sytuacji, przechodzić każdej tabeli, usuwanie każdego wiersza, jeden w danym momencie. Kiedy używasz <xref:System.Data.DataTable.NewRow%2A> do tworzenia nowych wierszy, wiersze muszą zostać przetworzone przed wywołaniem <xref:System.Data.DataTable.Clear%2A>.  
  
   
  
## Examples  
 Poniższy przykład czyści wszystkie dane w tabeli.  
  
 [!code-csharp[Classic WebData DataTable.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Praca ze zdarzeniami DataTable</related>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual System.Data.DataTable Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Data.DataTable Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Data::DataTable ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; System.Data.DataTable&#xA;override this.Clone : unit -&gt; System.Data.DataTable" Usage="dataTable.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Klony struktury <see cref="T:System.Data.DataTable" />, łącznie ze wszystkimi <see cref="T:System.Data.DataTable" /> schematów i ograniczenia.</summary>
        <returns>Nowy <see cref="T:System.Data.DataTable" /> przy użyciu tego samego schematu jako bieżący <see cref="T:System.Data.DataTable" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli zostały uzyskane w ramach tych zajęć, klonowania będą się również z tych samych klas pochodnych.  
  
 Klonowania tworzy nową <xref:System.Data.DataTable> z taką samą strukturę co oryginalny <xref:System.Data.DataTable>, ale nie kopiuje wszystkie dane (nowy <xref:System.Data.DataTable> nie będzie zawierać `DataRows`). Aby skopiować struktury i danych do nowego <xref:System.Data.DataTable>, użyj <xref:System.Data.DataTable.Copy%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak zaktualizować strukturę i ograniczenia w tabeli docelowej po wykonaniu DataTable.Clone. Klasa ClonedDataTable zwróci tabelę docelową i zawiera wszystkie aktualizowanie zdarzenia. Po klona zmiany struktury efektów w tabeli źródłowej nie zostaną odzwierciedlone w tabeli docelowej. W szczególności w tym przykładzie wykonują następujące czynności:  
  
-   Zaktualizuj zmiany kolumny w tabeli źródłowej.  
  
-   Zaktualizuj zmiany UniqueConstraint w tabeli źródłowej.  
  
-   Zaktualizuj zmiany ForeignKeyConstraint w tabeli źródłowej.  
  
 Projekty języka C# i Visual Basic z tego przykładu kodu można znaleźć na [Developer Code Samples](https://code.msdn.microsoft.com/site/search?f%5B0%5D.Type=SearchText&f%5B0%5D.Value=How%20to%20automically%20update%20the%20structure%20of%20a%20cloned%20DataTable).  
  
```csharp  
using System;  
using System.Linq;  
using System.Data;  
using System.ComponentModel;  
  
class Program {  
   static void Main(string[] args) {  
      DataTable courses = NewCourseDataTable();  
      Console.WriteLine("This is the source table:");  
      WriteDataTable(courses);  
  
      ClonedDataTable clonedResult = new ClonedDataTable(courses);  
      DataTable clonedCourses = clonedResult.DestinationTable;  
      Console.WriteLine("This is the destination table:");  
      WriteDataTable(clonedCourses);  
  
      // Add the events of updating column collection into the source table.  
      clonedResult.UpdateAddedColumn();  
      clonedResult.UpdateDeletedColumn();  
      // Add a DataColumn in source table.  
      DataColumn columnCreidts = new DataColumn("Credits", typeof(Int32));  
      courses.Columns.Add(columnCreidts);  
      Console.WriteLine("After add a column in source table, it's the result in the destination:");  
      WriteDataTable(clonedCourses);  
  
      // Add the event of updating UniqueConstraint into the source table.  
      clonedResult.UpdateUniqueConstraint();  
  
      // Add the unique constraint in source table.  
      UniqueConstraint uniqueConstraint = new UniqueConstraint(courses.Columns["CourseId"]);  
      courses.Constraints.Add(uniqueConstraint);  
  
      Console.WriteLine(@"If we add the unique constraint in source table and then insert the duplicate   
rows into the destination table, we will get the following error:");  
      InsertDuplicateData(clonedCourses);  
      Console.WriteLine();  
  
      // Add the event of updating ForeignKeyConstraint into the source table.  
      clonedResult.UpdateForeignKeyConstraint();  
  
      // Add the ForeignKeyConstraint into the source table.  
      DataTable deparments = NewDeparmentDataTable();  
      DataSet dataset = new DataSet();  
  
      dataset.Tables.Add(courses);  
      dataset.Tables.Add(clonedCourses);  
      dataset.Tables.Add(deparments);  
  
      ForeignKeyConstraint foreignKey = new ForeignKeyConstraint(deparments.Columns["DepartmentId"], courses.Columns["DepartmentId"]);  
      courses.Constraints.Add(foreignKey);  
  
      Console.WriteLine(@"If we add the foreign key constraint in source table and then insert a row   
without the parent  into the destination table, we will get the following error:");  
      InsertNoParentRow(clonedCourses);  
      Console.WriteLine();  
  
      Console.WriteLine("Please press any key to exit...");  
      Console.ReadKey();  
   }  
  
   static private DataTable NewCourseDataTable() {  
      DataTable newTable = new DataTable();  
  
      DataColumn[] columns ={   
                                      new DataColumn("CourseId", typeof(String)),  
                                      new DataColumn("CourseName",typeof(String)),                                        
                                      new DataColumn("DepartmentId", typeof(Int32))  
                                  };  
  
      newTable.Columns.AddRange(columns);  
  
      newTable.Rows.Add("C1045", "Calculus", 7);  
      newTable.Rows.Add("C1061", "Physics", 1);  
      newTable.Rows.Add("C2021", "Composition", 2);  
      newTable.Rows.Add("C2042", "Literature", 2);  
  
      return newTable;  
   }  
  
   static private DataTable NewDeparmentDataTable() {  
      DataTable newTable = new DataTable();  
  
      DataColumn[] columns ={   
                                      new DataColumn("DepartmentId", typeof(Int32)),  
                                      new DataColumn("Name",typeof(String)),  
                                  };  
  
      newTable.Columns.AddRange(columns);  
  
      newTable.Rows.Add(1, "Engineering");  
      newTable.Rows.Add(2, "English");  
      newTable.Rows.Add(4, "Economics");  
      newTable.Rows.Add(7, "Mathematics");  
  
      return newTable;  
   }  
  
   static private void WriteDataTable(DataTable table) {  
      if (table == null)  
         return;  
  
      foreach (DataColumn column in table.Columns) {  
         Console.Write("{0,-15}", column.ColumnName);  
      }  
      Console.WriteLine();  
  
      foreach (DataRow row in table.Rows) {  
         for (int i = 0; i < table.Columns.Count; i++)  
            Console.Write("{0,-15}", row[i].ToString());  
         Console.WriteLine();  
      }  
  
      Console.WriteLine();  
   }  
  
   static private void InsertDuplicateData(DataTable table) {  
      try {  
         table.Rows.Add("C1045", "Calculus", 7);  
         table.Rows.Add("C1045", "Calculus", 7);  
      } catch (Exception e) {  
         Console.WriteLine("\"" + e.Message + "\"");  
      }  
   }  
  
   private static void InsertNoParentRow(DataTable table) {  
      try {  
         table.Rows.Add("C1061", "Physics", 11);  
      } catch (Exception e) {  
         Console.WriteLine("\"" + e.Message + "\"");  
      }  
   }  
}  
  
public class ClonedDataTable {  
   private DataTable sourceTable;  
   private DataTable destinationTable;  
  
   public ClonedDataTable(DataTable source) {  
      sourceTable = source;  
      // set the cloned result  
      destinationTable = sourceTable.Clone();  
   }  
  
   public void UpdateAddedColumn() {  
      sourceTable.Columns.CollectionChanged += new CollectionChangeEventHandler(ColumnAdded);  
   }  
  
   public void UpdateDeletedColumn() {  
      sourceTable.Columns.CollectionChanged += new CollectionChangeEventHandler(ColumnDeleted);  
   }  
  
   public void UpdateUniqueConstraint() {  
      sourceTable.Constraints.CollectionChanged += new CollectionChangeEventHandler(UniqueConstraint_Changed);  
   }  
  
   public void UpdateForeignKeyConstraint() {  
      sourceTable.Constraints.CollectionChanged += new CollectionChangeEventHandler(ForeignKeyConstraint_Changed);  
   }  
  
   // After the source table adds a column, the method will add the same column in the destination table.  
   void ColumnAdded(object sender, System.ComponentModel.CollectionChangeEventArgs e) {  
      if (e.Action == CollectionChangeAction.Add) {  
         DataColumn column = e.Element as DataColumn;  
  
         if (column != null) {  
            DataColumn newColumn = new DataColumn(column.ColumnName, column.DataType, column.Expression, column.ColumnMapping);  
  
            if (!destinationTable.Columns.Contains(newColumn.ColumnName))  
               destinationTable.Columns.Add(newColumn);  
         }  
      }  
   }  
  
   // After the source table deletes a column, the method will delete the same column in the destination table.  
   void ColumnDeleted(object sender, CollectionChangeEventArgs e) {  
      if (e.Action == CollectionChangeAction.Remove) {  
         DataColumn column = e.Element as DataColumn;  
  
         if (column != null)  
            if (destinationTable.Columns.Contains(column.ColumnName))  
               destinationTable.Columns.Remove(column.ColumnName);  
      }  
   }  
  
   // After the source table changes the UniqueConstraint, this method changes the same UniqueConstraint in destination table.        
   void UniqueConstraint_Changed(object sender, CollectionChangeEventArgs e) {  
      UniqueConstraint constraint = e.Element as UniqueConstraint;  
  
      if (constraint == null)  
         return;  
  
      String constraintName = constraint.ConstraintName;  
  
      if (e.Action == CollectionChangeAction.Add) {  
         DataColumn[] columns = new DataColumn[constraint.Columns.Count()];  
         Boolean isPrimaryKey = constraint.IsPrimaryKey;  
  
         // Get the columns used in new constraint from the destiantion table.  
         for (Int32 i = 0; i < constraint.Columns.Count(); i++) {  
            String columnName = constraint.Columns[i].ColumnName;  
  
            if (destinationTable.Columns.Contains(columnName))  
               columns[i] = destinationTable.Columns[columnName];  
            else  
               return;  
         }  
  
         UniqueConstraint newConstraint = new UniqueConstraint(constraintName, columns, isPrimaryKey);  
  
         if (!destinationTable.Constraints.Contains(constraintName))  
            destinationTable.Constraints.Add(newConstraint);  
  
      } else if (e.Action == CollectionChangeAction.Remove)  
         if (destinationTable.Constraints.Contains(constraintName))  
            destinationTable.Constraints.Remove(constraintName);  
   }  
  
   // After the source table changes the ForeignKeyConstraint, this method changes    
   // the same ForeignKeyConstraint in the destination table.  
   void ForeignKeyConstraint_Changed(object sender, CollectionChangeEventArgs e) {  
      ForeignKeyConstraint constraint = e.Element as ForeignKeyConstraint;  
  
      if (constraint == null)  
         return;  
  
      // If the source and destination are not in the same DataSet, don't change the ForeignKeyConstraint.  
      if (sourceTable.DataSet != destinationTable.DataSet)  
         return;  
  
      String constraintName = constraint.ConstraintName;  
  
      if (e.Action == CollectionChangeAction.Add) {  
         DataColumn[] columns = new DataColumn[constraint.Columns.Count()];  
         DataColumn[] parentColumns = constraint.RelatedColumns;  
  
         // Get the columns used in new constraint from the destination table.  
         for (int i = 0; i < constraint.Columns.Count(); i++) {  
            String columnName = constraint.Columns[i].ColumnName;  
  
            if (destinationTable.Columns.Contains(columnName))  
               columns[i] = destinationTable.Columns[columnName];  
            else  
               return;  
         }  
  
         ForeignKeyConstraint newConstraint = new ForeignKeyConstraint(constraintName, parentColumns, columns);  
         newConstraint.AcceptRejectRule = constraint.AcceptRejectRule;  
         newConstraint.DeleteRule = constraint.DeleteRule;  
         newConstraint.UpdateRule = constraint.UpdateRule;  
  
         if (!destinationTable.Constraints.Contains(constraintName))  
            destinationTable.Constraints.Add(newConstraint);  
      } else if (e.Action == CollectionChangeAction.Remove)  
         if (destinationTable.Constraints.Contains(constraintName))  
            destinationTable.Constraints.Remove(constraintName);  
   }  
  
   // return the destination table.  
   public DataTable DestinationTable {  
      get { return destinationTable; }  
   }  
}  
```  
  
 Ten przykład pokazuje jak modyfikowanie danych w elemencie DataTable i zaktualizować źródło danych.  
  
 Najpierw utwórz bazę danych:  
  
```  
USE [master]  
GO  
  
CREATE DATABASE [MySchool]   
  
GO  
  
USE [MySchool]  
GO  
  
SET ANSI_NULLS ON  
GO  
SET QUOTED_IDENTIFIER ON  
GO  
CREATE TABLE [dbo].[Course]([CourseID] [nvarchar](10) NOT NULL,  
[Year] [smallint] NOT NULL,  
[Title] [nvarchar](100) NOT NULL,  
[Credits] [int] NOT NULL,  
[DepartmentID] [int] NOT NULL,  
 CONSTRAINT [PK_Course] PRIMARY KEY CLUSTERED   
(  
[CourseID] ASC,  
[Year] ASC  
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]) ON [PRIMARY]  
  
GO  
  
SET ANSI_NULLS ON  
GO  
SET QUOTED_IDENTIFIER ON  
GO  
CREATE TABLE [dbo].[Department]([DepartmentID] [int] IDENTITY(1,1) NOT NULL,  
[Name] [nvarchar](50) NOT NULL,  
[Budget] [money] NOT NULL,  
[StartDate] [datetime] NOT NULL,  
[Administrator] [int] NULL,  
 CONSTRAINT [PK_Department] PRIMARY KEY CLUSTERED   
(  
[DepartmentID] ASC  
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]) ON [PRIMARY]  
  
GO  
  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C1045', 2012, N'Calculus', 4, 7)  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C1061', 2012, N'Physics', 4, 1)  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C2021', 2012, N'Composition', 3, 2)  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C2042', 2012, N'Literature', 4, 2)  
  
SET IDENTITY_INSERT [dbo].[Department] ON   
  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (1, N'Engineering', 350000.0000, CAST(0x0000999C00000000 AS DateTime), 2)  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (2, N'English', 120000.0000, CAST(0x0000999C00000000 AS DateTime), 6)  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (4, N'Economics', 200000.0000, CAST(0x0000999C00000000 AS DateTime), 4)  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (7, N'Mathematics', 250024.0000, CAST(0x0000999C00000000 AS DateTime), 3)  
SET IDENTITY_INSERT [dbo].[Department] OFF  
  
ALTER TABLE [dbo].[Course]  WITH CHECK ADD  CONSTRAINT [FK_Course_Department] FOREIGN KEY([DepartmentID])  
REFERENCES [dbo].[Department] ([DepartmentID])  
GO  
ALTER TABLE [dbo].[Course] CHECK CONSTRAINT [FK_Course_Department]  
GO  
```  
  
 Można teraz kompilowanie i uruchamianie aplikacji przykładowej. [Jak modyfikować dane w tabeli DataTable i przeprowadź aktualizację do źródła danych](https://code.msdn.microsoft.com/How-to-modify-data-in-c68d35f4) ma projektów Visual Basic i C# tego przykładu.  
  
```csharp  
using System;  
using System.Data;  
using System.Data.SqlClient;  
  
class Program {  
   static void Main(string[] args) {  
  
   string MySchoolConnectionString = "Data Source=(local);Initial Catalog=MySchool;Integrated Security=True";  
  
      // Get Data  
      String selectString =  
       @"Select [CourseID],[Year],[Title],[Credits],[DepartmentID] From [dbo].[Course];  
               Select [DepartmentID],[Name],[Budget],[StartDate],[Administrator] From [dbo].[Department] ";  
  
      DataSet dataSet = new DataSet();  
      DataTable course = dataSet.Tables.Add("Course");  
      DataTable department = dataSet.Tables.Add("Department");  
  
      Console.WriteLine("Get data from database:");  
      GetDataTables(MySchoolConnectionString, selectString, dataSet, course, department);  
      Console.WriteLine();  
  
      // Use DataTable Edits to edit the data  
      String updateString =  
              @"Update [dbo].[Course] Set [Credits]=@Credits Where [CourseID]=@CourseID;";  
  
      course.ColumnChanged += OnColumnChanged;  
  
      // Set the Credits of first row is negative value, and set the Credits of second row is plus.  
      ChangeCredits(course, course.Rows[0], -1);  
      ChangeCredits(course, course.Rows[1], 11);  
  
      UpdateDataTables(MySchoolConnectionString, updateString, dataSet, "Course",  
          new SqlParameter("@CourseID", SqlDbType.NVarChar, 10, "CourseID"),  
          new SqlParameter("@Credits", SqlDbType.Int, 4, "Credits"));  
      Console.WriteLine("Only the Credits of second row is changed.");  
      ShowDataTable(course);  
      Console.WriteLine();  
  
      // Delete and Remove from DataTable  
      // Create the foreign key constraint, and set the DeleteRule with Cascade.  
      ForeignKeyConstraint courseDepartFK = new ForeignKeyConstraint("CourseDepartFK", department.Columns["DepartmentID"], course.Columns["DepartmentID"]);  
      courseDepartFK.DeleteRule = Rule.Cascade;  
      courseDepartFK.UpdateRule = Rule.Cascade;  
      courseDepartFK.AcceptRejectRule = AcceptRejectRule.None;  
      course.Constraints.Add(courseDepartFK);  
  
      String deleteString = @"Delete From [dbo].[Course] Where [CourseID]=@CourseID;";  
  
      department.Rows[0].Delete();  
      Console.WriteLine("If One row in Department table is deleted, the related rows in Course table will also be deleted.");  
      Console.WriteLine("Department DataTable:");  
      ShowDataTable(department);  
      Console.WriteLine();  
      Console.WriteLine("Course DataTable:");  
      ShowDataTable(course);  
      Console.WriteLine();  
      // Update the delete operation  
      DeleteDataTables(MySchoolConnectionString, deleteString, dataSet, "Course",  
          new SqlParameter("@CourseID", SqlDbType.NVarChar, 10, "CourseID"));  
      Console.WriteLine("After delete operation:");  
      Console.WriteLine("Course DataTable:");  
      ShowDataTable(course);  
      Console.WriteLine();  
  
      course.Rows.RemoveAt(0);  
      Console.WriteLine("Now we remove one row from Course:");  
      ShowDataTable(course);  
      DeleteDataTables(MySchoolConnectionString, deleteString, dataSet, "Course",  
          new SqlParameter("@CourseID", SqlDbType.NVarChar, 10, "CourseID"));  
   }  
  
   // Use SqlDataAdapter to get data.  
   private static void GetDataTables(String connectionString, String selectString,  
       DataSet dataSet, params DataTable[] tables) {  
      using (SqlDataAdapter adapter = new SqlDataAdapter()) {  
         adapter.SelectCommand = new SqlCommand(selectString);  
         adapter.SelectCommand.Connection = new SqlConnection(connectionString);  
  
         adapter.Fill(0, 0, tables);  
  
         foreach (DataTable table in dataSet.Tables) {  
            Console.WriteLine("Data in {0}:", table.TableName);  
            ShowDataTable(table);  
            Console.WriteLine();  
         }  
      }  
   }  
  
   // Use SqlDataAdapter to update the updata operation.  
   private static void UpdateDataTables(String connectionString, String updateString,  
       DataSet dataSet, String tableName, params SqlParameter[] parameters) {  
      using (SqlDataAdapter adapter = new SqlDataAdapter()) {  
         adapter.UpdateCommand = new SqlCommand(updateString);  
         adapter.UpdateCommand.Parameters.AddRange(parameters);  
         adapter.UpdateCommand.Connection = new SqlConnection(connectionString);  
  
         adapter.Update(dataSet, tableName);  
      }  
   }  
  
   // Use SqlDataAdapter to update delete operation.  
   private static void DeleteDataTables(String connectionString, String deleteString,  
       DataSet dataSet, String tableName, params SqlParameter[] parameters) {  
      using (SqlDataAdapter adapter = new SqlDataAdapter()) {  
         adapter.DeleteCommand = new SqlCommand(deleteString);  
         adapter.DeleteCommand.Parameters.AddRange(parameters);  
         adapter.DeleteCommand.Connection = new SqlConnection(connectionString);  
  
         adapter.Update(dataSet, tableName);  
      }  
   }  
  
   // Use DataTable Edits to modify the data.  
   private static void ChangeCredits(DataTable table, DataRow row, Int32 credits) {  
      row.BeginEdit();  
      Console.WriteLine("We change row {0}", table.Rows.IndexOf(row));  
      row["Credits"] = credits;  
      row.EndEdit();  
   }  
  
   // The method will be invoked when the value in DataTable is changed.  
   private static void OnColumnChanged(Object sender, DataColumnChangeEventArgs args) {  
      Int32 credits = 0;  
      // If Credits is changed and the value is negative, we'll cancel the edit.  
      if ((args.Column.ColumnName == "Credits") &&  
          (!Int32.TryParse(args.ProposedValue.ToString(), out credits) || credits < 0)) {  
         Console.WriteLine("The value of Credits is invalid. Edit canceled.");  
         args.Row.CancelEdit();  
      }  
   }  
  
   // Display the column and value of DataTable.  
   private static void ShowDataTable(DataTable table) {  
      foreach (DataColumn col in table.Columns) {  
         Console.Write("{0,-14}", col.ColumnName);  
      }  
      Console.WriteLine("{0,-14}", "RowState");  
  
      foreach (DataRow row in table.Rows) {  
         if (row.RowState == DataRowState.Deleted) {  
            foreach (DataColumn col in table.Columns) {  
               if (col.DataType.Equals(typeof(DateTime)))  
                  Console.Write("{0,-14:d}", row[col, DataRowVersion.Original]);  
               else if (col.DataType.Equals(typeof(Decimal)))  
                  Console.Write("{0,-14:C}", row[col, DataRowVersion.Original]);  
               else  
                  Console.Write("{0,-14}", row[col, DataRowVersion.Original]);  
            }  
         }  
         else {  
            foreach (DataColumn col in table.Columns) {  
               if (col.DataType.Equals(typeof(DateTime)))  
                  Console.Write("{0,-14:d}", row[col]);  
               else if (col.DataType.Equals(typeof(Decimal)))  
                  Console.Write("{0,-14:C}", row[col]);  
               else  
                  Console.Write("{0,-14}", row[col]);  
            }  
         }  
         Console.WriteLine("{0,-14}", row.RowState);  
      }  
   }  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataTable.Copy" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="ColumnChanged">
      <MemberSignature Language="C#" Value="public event System.Data.DataColumnChangeEventHandler ColumnChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataColumnChangeEventHandler ColumnChanged" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.ColumnChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ColumnChanged As DataColumnChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataColumnChangeEventHandler ^ ColumnChanged;" />
      <MemberSignature Language="F#" Value="member this.ColumnChanged : System.Data.DataColumnChangeEventHandler " Usage="member this.ColumnChanged : System.Data.DataColumnChangeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableColumnChangedDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataColumnChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po zmianie wartości w określonym <see cref="T:System.Data.DataColumn" /> w <see cref="T:System.Data.DataRow" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji, zobacz [Obsługa zdarzeń elementu DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md).  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.ColumnChanged Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ColumnChanged Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ColumnChanged Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ColumnChanged Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Data.DataColumnChangeEventHandler" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="ColumnChanging">
      <MemberSignature Language="C#" Value="public event System.Data.DataColumnChangeEventHandler ColumnChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataColumnChangeEventHandler ColumnChanging" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.ColumnChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ColumnChanging As DataColumnChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataColumnChangeEventHandler ^ ColumnChanging;" />
      <MemberSignature Language="F#" Value="member this.ColumnChanging : System.Data.DataColumnChangeEventHandler " Usage="member this.ColumnChanging : System.Data.DataColumnChangeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableColumnChangingDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataColumnChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po zmianie wartości w określonym <see cref="T:System.Data.DataColumn" /> w <see cref="T:System.Data.DataRow" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji, zobacz [Obsługa zdarzeń elementu DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md).  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.ColumnChanging Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ColumnChanging Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ColumnChanging Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ColumnChanging Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="Columns">
      <MemberSignature Language="C#" Value="public System.Data.DataColumnCollection Columns { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataColumnCollection Columns" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Columns" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Columns As DataColumnCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataColumnCollection ^ Columns { System::Data::DataColumnCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Columns : System.Data.DataColumnCollection" Usage="System.Data.DataTable.Columns" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableColumnsDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataColumnCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję kolumn, które należą do tej tabeli.</summary>
        <value>A <see cref="T:System.Data.DataColumnCollection" /> zawierający kolekcję <see cref="T:System.Data.DataColumn" /> obiektów dla tabeli. Pusta kolekcja jest zwracany, jeśli nie <see cref="T:System.Data.DataColumn" /> istnieją obiekty.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataColumnCollection> Określa schemat tabeli przez zdefiniowanie typu danych każdej kolumny.  
  
   
  
## Examples  
 Poniższy przykład drukuje każda wartość każdego wiersza w tabeli przy użyciu <xref:System.Data.DataTable.Columns%2A> właściwości.  
  
 [!code-csharp[Classic WebData DataTable.Columns Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Columns Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Columns Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Columns Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="Compute">
      <MemberSignature Language="C#" Value="public object Compute (string expression, string filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Compute(string expression, string filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Compute(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Compute (expression As String, filter As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Compute(System::String ^ expression, System::String ^ filter);" />
      <MemberSignature Language="F#" Value="member this.Compute : string * string -&gt; obj" Usage="dataTable.Compute (expression, filter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.String" />
        <Parameter Name="filter" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression">Wyrażenie do obliczenia.</param>
        <param name="filter">Filtr do ograniczenia liczby wierszy, które wyrażenie do oceny.</param>
        <summary>Oblicza danego wyrażenia względem bieżącego wierszy, zaliczonych kryteria filtrowania.</summary>
        <returns>
          <see cref="T:System.Object" />, Ustaw na wynik obliczeń. Jeśli wyrażenie ma wartość null, wartość zwracana będzie <see cref="F:System.DBNull.Value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `expression` Parametr wymaga funkcji agregującej. Na przykład Oto prawne wyrażenie:  
  
 `Count(Quantity)`  
  
 Jednak nie jest to wyrażenie:  
  
 `Sum (Quantity * UnitPrice)`  
  
 Jeśli konieczne jest wykonanie operacji na dwóch lub większej liczby kolumn, należy utworzyć <xref:System.Data.DataColumn>, ustaw jego <xref:System.Data.DataColumn.Expression%2A> właściwość odpowiednie wyrażenie, a wyrażenie agregujące w wynikowej kolumnie. W takiej sytuacji danego <xref:System.Data.DataColumn> o nazwie "łącznie", a <xref:System.Data.DataColumn.Expression%2A> właściwość jest ustawiona na to:  
  
 `"Quantity * UnitPrice"`  
  
 Argument wyrażenia dla <xref:System.Data.DataTable.Compute%2A> metoda następnie będzie wyglądać następująco:  
  
 `Sum(total)`  
  
 Drugi parametr `filter`, określa wiersze, które są używane w wyrażeniu. Na przykład jeśli tabela zawiera kolumnę daty o nazwie "colDate", można ograniczyć wiersze z następującego wyrażenia:  
  
 `colDate > 1/1/99 AND colDate < 17/1/99`  
  
 Dla zasad dotyczących tworzenia wyrażeń dla obu parametrów, zobacz <xref:System.Data.DataColumn.Expression%2A?displayProperty=nameWithType> właściwości.  
  
   
  
## Examples  
 Poniższy przykład sumuje wartości kolumny o nazwie "Łącznie", sprzedawcy, których numer identyfikacyjny jest pięć.  
  
 [!code-csharp[Classic WebData DataTable.Compute Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Compute Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Compute Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Compute Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="Constraints">
      <MemberSignature Language="C#" Value="public System.Data.ConstraintCollection Constraints { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.ConstraintCollection Constraints" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Constraints" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Constraints As ConstraintCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::ConstraintCollection ^ Constraints { System::Data::ConstraintCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Constraints : System.Data.ConstraintCollection" Usage="System.Data.DataTable.Constraints" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableConstraintsDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.ConstraintCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję ograniczenia obsługiwanego przez tę tabelę.</summary>
        <value>A <see cref="T:System.Data.ConstraintCollection" /> zawierający kolekcję <see cref="T:System.Data.Constraint" /> obiektów dla tabeli. Pusta kolekcja jest zwracany, jeśli nie <see cref="T:System.Data.Constraint" /> istnieją obiekty.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Data.ForeignKeyConstraint> ogranicza akcję wykonywaną, gdy usunięte lub zaktualizowane wartości w kolumnie (lub kolumny). Takie ograniczenie jest przeznaczona do użycia z kolumny klucza podstawowego. W relacji nadrzędny/podrzędny między dwiema tabelami usuwając wartość z tabeli nadrzędnej mogą wpływać na wiersze podrzędne w jednej z następujących sposobów.  
  
-   Podrzędne, które wiersze mogą być również usuwane (Akcja kaskadowych).  
  
-   Wartości w kolumnie podrzędnej (lub kolumny) może być równa wartości null.  
  
-   Wartości w kolumnie podrzędnej (lub kolumny) można ustawić wartości domyślne.  
  
-   Mogą być generowane wyjątek.  
  
 A <xref:System.Data.UniqueConstraint> stanie się aktywny, podczas próby ustaw wartość klucza podstawowego z wartością nie jest unikatowa.  
  
   
  
## Examples  
 W poniższym przykładzie dodano <xref:System.Data.ForeignKeyConstraint> kolekcji ograniczeń.  
  
 [!code-csharp[Classic WebData DataTable.Constraints Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Constraints Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Constraints Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Constraints Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public System.Data.DataTable Copy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTable Copy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Copy" />
      <MemberSignature Language="VB.NET" Value="Public Function Copy () As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTable ^ Copy();" />
      <MemberSignature Language="F#" Value="member this.Copy : unit -&gt; System.Data.DataTable" Usage="dataTable.Copy " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Kopiuje struktury i danych w tym <see cref="T:System.Data.DataTable" />.</summary>
        <returns>Nowy <see cref="T:System.Data.DataTable" /> z taką samą strukturę (schematy tabeli i ograniczenia) oraz dane ponieważ <see cref="T:System.Data.DataTable" />.  
  
Jeśli zostały uzyskane w ramach tych zajęć, kopia będzie się również z tych samych klas pochodnych.  
  
 <see cref="M:System.Data.DataTable.Copy" /> Tworzy nową <see cref="T:System.Data.DataTable" /> o tej samej struktury i danych, co oryginalny <see cref="T:System.Data.DataTable" />. Aby skopiować struktury do nowego <see cref="T:System.Data.DataTable" />, ale nie dane <see cref="M:System.Data.DataTable.Clone" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Data.DataTable.Copy%2A> metodę, aby utworzyć kopię oryginału <xref:System.Data.DataTable>. Nazwa przestrzeni nazw nie są zachowywane, jeśli jest dziedziczone z nadrzędnego <xref:System.Data.DataTable> lub <xref:System.Data.DataSet>.  
  
 [!code-csharp[Classic WebData DataTable.Copy Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Copy Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Copy Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Copy Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataView.ToTable" />
        <altmember cref="M:System.Data.DataTable.Clone" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="CreateDataReader">
      <MemberSignature Language="C#" Value="public System.Data.DataTableReader CreateDataReader ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTableReader CreateDataReader() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.CreateDataReader" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateDataReader () As DataTableReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTableReader ^ CreateDataReader();" />
      <MemberSignature Language="F#" Value="member this.CreateDataReader : unit -&gt; System.Data.DataTableReader" Usage="dataTable.CreateDataReader " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableReader</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.Data.DataTableReader" /> odpowiadający danych w ramach tej <see cref="T:System.Data.DataTable" />.</summary>
        <returns>A <see cref="T:System.Data.DataTableReader" /> zawierających jeden zestaw wyników, odpowiadający źródła <see cref="T:System.Data.DataTable" /> wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Tworzy następujące aplikację konsolową <xref:System.Data.DataTable> wystąpienia. Następnie przykład przekazuje wypełniony <xref:System.Data.DataTable> do procedury, która wywołuje <xref:System.Data.DataTable.CreateDataReader%2A> metody, która wykonuje iterację przez wyniki zawartych w <xref:System.Data.DataTableReader>.  
  
 [!code-csharp[DataWorks DataTable.CreateDataReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.CreateDataReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.CreateDataReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.CreateDataReader/VB/source.vb#1)]  
  
 W przykładzie są wyświetlane następujące dane wyjściowe w oknie konsoli:  
  
 `1 Mary`  
  
 `2 Andy`  
  
 `3 Peter`  
  
 `4 Russ`  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.CreateDataReader" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="protected virtual System.Data.DataTable CreateInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Data.DataTable CreateInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.CreateInstance" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateInstance () As DataTable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Data::DataTable ^ CreateInstance();" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : unit -&gt; System.Data.DataTable&#xA;override this.CreateInstance : unit -&gt; System.Data.DataTable" Usage="dataTable.CreateInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy nowe wystąpienie klasy <see cref="T:System.Data.DataTable" />.</summary>
        <returns>Nowe wyrażenie.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DataSet">
      <MemberSignature Language="C#" Value="public System.Data.DataSet DataSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataSet DataSet" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.DataSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DataSet As DataSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataSet ^ DataSet { System::Data::DataSet ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DataSet : System.Data.DataSet" Usage="System.Data.DataTable.DataSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableDataSetDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Data.DataSet" /> do którego należy ta tabela.</summary>
        <value>
          <see cref="T:System.Data.DataSet" /> Do którego należy ta tabela.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli formant jest powiązany z danymi do <xref:System.Data.DataTable>, a dla tabeli <xref:System.Data.DataSet>, można uzyskać do <xref:System.Data.DataSet> za pośrednictwem tej właściwości.  
  
   
  
## Examples  
 Poniższy przykład zwraca element nadrzędny <xref:System.Data.DataSet> danej tabeli za pomocą <xref:System.Data.DataTable.DataSet%2A> właściwości.  
  
 [!code-csharp[Classic WebData DataTable.DataSet Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.DataSet Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.DataSet Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.DataSet Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="DefaultView">
      <MemberSignature Language="C#" Value="public System.Data.DataView DefaultView { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataView DefaultView" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.DefaultView" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultView As DataView" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataView ^ DefaultView { System::Data::DataView ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultView : System.Data.DataView" Usage="System.Data.DataTable.DefaultView" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableDefaultViewDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera dostosowany widok tabeli, która może obejmować widoku filtrowanego znajdującego się lub pozycja kursora.</summary>
        <value>
          <see cref="T:System.Data.DataView" /> Skojarzone z <see cref="T:System.Data.DataTable" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.DefaultView%2A> Właściwość zwraca <xref:System.Data.DataView> można użyć do sortowania, filtrowania i wyszukiwania <xref:System.Data.DataTable>.  
  
   
  
## Examples  
 W poniższym przykładzie ustawiono właściwość <xref:System.Data.DataTable> obiektu <xref:System.Data.DataView> za pośrednictwem <xref:System.Data.DataTable.DefaultView%2A> właściwości. W przykładzie pokazano również powiązanie <xref:System.Windows.Forms.DataGridView> kontrolę <xref:System.Data.DataTable> o nazwie "Dostawcy", które zawiera kolumnę o nazwie "CompanyName".  
  
 [!code-csharp[Classic WebData DataTable.DefaultView Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.DefaultView Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.DefaultView Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.DefaultView Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="DisplayExpression">
      <MemberSignature Language="C#" Value="public string DisplayExpression { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DisplayExpression" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.DisplayExpression" />
      <MemberSignature Language="VB.NET" Value="Public Property DisplayExpression As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DisplayExpression { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DisplayExpression : string with get, set" Usage="System.Data.DataTable.DisplayExpression" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableDisplayExpressionDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wyrażenie zwracające wartość używana do reprezentowania tej tabeli w interfejsie użytkownika. <see langword="DisplayExpression" /> Właściwość pozwala wyświetlić nazwę tej tabeli w interfejsie użytkownika.</summary>
        <value>Ciąg wyświetlany.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Data.DataColumn.Expression" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public virtual void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="dataTable.EndInit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Kończy się inicjowanie <see cref="T:System.Data.DataTable" /> który jest używany w formularzu lub używany przez inny składnik. Inicjowanie odbywa się w czasie wykonywania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Środowisko projektowania programu Visual Studio .NET używa tej metody, aby zakończyć inicjowanie składnik, który jest używany w formularzu lub używany przez inny składnik. <xref:System.Data.DataTable.BeginInit%2A> Metoda uruchamia inicjowania. Za pomocą <xref:System.Data.DataTable.BeginInit%2A> i <xref:System.Data.DataTable.EndInit%2A> metody zapobiega używana przed pełnym zainicjowaniem formantu.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="EndLoadData">
      <MemberSignature Language="C#" Value="public void EndLoadData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndLoadData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.EndLoadData" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndLoadData ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndLoadData();" />
      <MemberSignature Language="F#" Value="member this.EndLoadData : unit -&gt; unit" Usage="dataTable.EndLoadData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Włącza powiadomienia, konserwacja indeksu i ograniczeń po załadowaniu danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Data.DataTable.EndLoadData%2A> w połączeniu z <xref:System.Data.DataTable.LoadDataRow%2A> i <xref:System.Data.DataTable.BeginLoadData%2A>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="ExtendedProperties">
      <MemberSignature Language="C#" Value="public System.Data.PropertyCollection ExtendedProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.PropertyCollection ExtendedProperties" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.ExtendedProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExtendedProperties As PropertyCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::PropertyCollection ^ ExtendedProperties { System::Data::PropertyCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExtendedProperties : System.Data.PropertyCollection" Usage="System.Data.DataTable.ExtendedProperties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("ExtendedPropertiesDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.PropertyCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję informacji użytkownika.</summary>
        <value>Element <see cref="T:System.Data.PropertyCollection" /> zawierający informacje o użytkowniku niestandardowych.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Data.DataTable.ExtendedProperties%2A> Dodawanie niestandardowych informacji do <xref:System.Data.DataTable>. Dodaj informacje o `Add` metody. Pobieranie informacji z `Item` metody.  
  
 Właściwości rozszerzone musi być typu <xref:System.String>. Właściwości, które nie mają wartości typu String nie są zachowywane podczas <xref:System.Data.DataTable> jest zapisywane w formacie XML.  
  
   
  
## Examples  
 Poniższy przykład dodaje wartość sygnatury czasowej do <xref:System.Data.DataTable> za pośrednictwem <xref:System.Data.DataTable.ExtendedProperties%2A> właściwości.  
  
 [!code-csharp[Classic WebData DataTable.ExtendedProperties Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ExtendedProperties Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ExtendedProperties Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ExtendedProperties Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="fInitInProgress">
      <MemberSignature Language="C#" Value="protected internal bool fInitInProgress;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly bool fInitInProgress" />
      <MemberSignature Language="DocId" Value="F:System.Data.DataTable.fInitInProgress" />
      <MemberSignature Language="VB.NET" Value="Protected Friend fInitInProgress As Boolean " />
      <MemberSignature Language="C++ CLI" Value="protected public: bool fInitInProgress;" />
      <MemberSignature Language="F#" Value="val mutable fInitInProgress : bool" Usage="System.Data.DataTable.fInitInProgress" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Sprawdza, czy Inicjalizacja jest w toku. Inicjowanie odbywa się w czasie wykonywania.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChanges">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera kopię <see cref="T:System.Data.DataTable" /> zawierający wszystkie zmiany wprowadzone od czasu ostatniego załadowania lub od <see cref="M:System.Data.DataTable.AcceptChanges" /> została wywołana.</summary>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Praca ze zdarzeniami DataTable</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChanges">
      <MemberSignature Language="C#" Value="public System.Data.DataTable GetChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTable GetChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetChanges" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChanges () As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTable ^ GetChanges();" />
      <MemberSignature Language="F#" Value="member this.GetChanges : unit -&gt; System.Data.DataTable" Usage="dataTable.GetChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera kopię <see cref="T:System.Data.DataTable" /> zawierający wszystkie zmiany wprowadzone od momentu załadowania lub <see cref="M:System.Data.DataTable.AcceptChanges" /> ostatnio została wywołana.</summary>
        <returns>Kopiowanie zmian z tego <see cref="T:System.Data.DataTable" />, lub <see langword="null" /> Jeśli żadne zmiany nie zostaną znalezione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tworzy nową <xref:System.Data.DataSet> zawierający kopię wszystkich wierszy w oryginalnym <xref:System.Data.DataSet> , które mają oczekujące zmiany. Ograniczenia relacji może spowodować, że dodatkowe wiersze bez zmian do dodania do nowej <xref:System.Data.DataSet> Jeśli niezmienione wiersze zawierają klucze podstawowe odpowiadający klucze obce w zmienionych wierszy. Metoda ta zwraca `null` (`Nothing` w języku Visual Basic), jeśli nie ma żadnych wierszy w oryginalnym <xref:System.Data.DataSet> z oczekującymi zmianami.  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.GetChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.GetChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.GetChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.GetChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Praca ze zdarzeniami DataTable</related>
      </Docs>
    </Member>
    <Member MemberName="GetChanges">
      <MemberSignature Language="C#" Value="public System.Data.DataTable GetChanges (System.Data.DataRowState rowStates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTable GetChanges(valuetype System.Data.DataRowState rowStates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetChanges(System.Data.DataRowState)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChanges (rowStates As DataRowState) As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTable ^ GetChanges(System::Data::DataRowState rowStates);" />
      <MemberSignature Language="F#" Value="member this.GetChanges : System.Data.DataRowState -&gt; System.Data.DataTable" Usage="dataTable.GetChanges rowStates" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rowStates" Type="System.Data.DataRowState" />
      </Parameters>
      <Docs>
        <param name="rowStates">Jedną z <see cref="T:System.Data.DataRowState" /> wartości.</param>
        <summary>Pobiera kopię <see cref="T:System.Data.DataTable" /> zawierający wszystkie zmiany wprowadzone od czasu ostatniego załadowania lub od <see cref="M:System.Data.DataTable.AcceptChanges" /> była wywoływana, przefiltrowane przez <see cref="T:System.Data.DataRowState" />.</summary>
        <returns>Filtrowane kopię <see cref="T:System.Data.DataTable" /> mają akcje wykonywane na nim, a później można scalić w <see cref="T:System.Data.DataTable" /> przy użyciu <see cref="M:System.Data.DataSet.Merge(System.Data.DataSet)" />. Jeśli nie wiersze żądaną <see cref="T:System.Data.DataRowState" /> zostaną znalezione, metoda zwraca <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.GetChanges%2A> Metoda jest używana w celu utworzenia drugiej <xref:System.Data.DataTable> obiekt, który zawiera tylko zmiany wprowadzone do oryginalnego. Użyj `rowStates` argumentu, aby określić typ zmiany powinien zawierać nowy obiekt.  
  
 Ograniczenia relacji może spowodować wierszy nadrzędnych bez zmian do uwzględnienia.  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.GetChanges1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.GetChanges1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.GetChanges1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.GetChanges1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Praca ze zdarzeniami DataTable</related>
      </Docs>
    </Member>
    <Member MemberName="GetDataTableSchema">
      <MemberSignature Language="C#" Value="public static System.Xml.Schema.XmlSchemaComplexType GetDataTableSchema (System.Xml.Schema.XmlSchemaSet schemaSet);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Schema.XmlSchemaComplexType GetDataTableSchema(class System.Xml.Schema.XmlSchemaSet schemaSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetDataTableSchema(System.Xml.Schema.XmlSchemaSet)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDataTableSchema (schemaSet As XmlSchemaSet) As XmlSchemaComplexType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Schema::XmlSchemaComplexType ^ GetDataTableSchema(System::Xml::Schema::XmlSchemaSet ^ schemaSet);" />
      <MemberSignature Language="F#" Value="static member GetDataTableSchema : System.Xml.Schema.XmlSchemaSet -&gt; System.Xml.Schema.XmlSchemaComplexType" Usage="System.Data.DataTable.GetDataTableSchema schemaSet" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchemaComplexType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="schemaSet" Type="System.Xml.Schema.XmlSchemaSet" />
      </Parameters>
      <Docs>
        <param name="schemaSet">
          <see cref="T:System.Xml.Schema.XmlSchemaSet" /> Wystąpienia.</param>
        <summary>Ta metoda zwraca <see cref="T:System.Xml.Schema.XmlSchemaSet" /> zawierające sieci Web Services Description Language (WSDL), który opisuje <see cref="T:System.Data.DataTable" /> dla usług sieci Web.</summary>
        <returns>
          <see cref="T:System.Xml.Schema.XmlSchemaSet" /> Wystąpienia.</returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="GetErrors">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] GetErrors ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] GetErrors() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetErrors" />
      <MemberSignature Language="VB.NET" Value="Public Function GetErrors () As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ GetErrors();" />
      <MemberSignature Language="F#" Value="member this.GetErrors : unit -&gt; System.Data.DataRow[]" Usage="dataTable.GetErrors " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera tablicę elementów <see cref="T:System.Data.DataRow" /> obiektów, które zawierają błędy.</summary>
        <returns>Tablica <see cref="T:System.Data.DataRow" /> obiekty, które mają błędy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwraca listę wszystkich <xref:System.Data.DataRow> obiektów, które mają <xref:System.Data.DataRow.RowError%2A> zestawu. Na przykład, mogą wystąpić błędy podczas wywoływania <xref:System.Data.Common.DataAdapter.Update%2A> z <xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A> równa `true`. Nie wywołać <xref:System.Data.DataTable.AcceptChanges%2A> na <xref:System.Data.DataTable> dopiero po przeprowadzeniu Usuń wszystkie błędy i ponownie prześlij <xref:System.Data.DataSet> aktualizacji.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Data.DataTable.GetErrors%2A> metodę, aby zwrócić tablicę <xref:System.Data.DataRow> obiekty, które mają błędy.  
  
 [!code-csharp[Classic WebData DataTable.GetErrors Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.GetErrors Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.GetErrors Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.GetErrors Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.HasErrors" />
        <altmember cref="P:System.Data.DataRow.RowError" />
        <altmember cref="M:System.Data.DataRow.SetColumnError(System.Int32,System.String)" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">DataTable (ADO.NET)</related>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="dataTable.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> obiekt, który przechowuje serializowane dane skojarzone z <see cref="T:System.Data.DataTable" />.</param>
        <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> obiekt, który zawiera źródłowe i docelowe serializowanym strumieniu skojarzone z <see cref="T:System.Data.DataTable" />.</param>
        <summary>Wypełnia obiekt informacji o serializacji dane potrzebne do serializacji <see cref="T:System.Data.DataTable" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" /> Parametr to odwołanie o wartości null (<see langword="Nothing" /> w języku Visual Basic).</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="GetRowType">
      <MemberSignature Language="C#" Value="protected virtual Type GetRowType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Type GetRowType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetRowType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetRowType () As Type" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Type ^ GetRowType();" />
      <MemberSignature Language="F#" Value="abstract member GetRowType : unit -&gt; Type&#xA;override this.GetRowType : unit -&gt; Type" Usage="dataTable.GetRowType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera typ wiersza.</summary>
        <returns>Zwraca typ <see cref="T:System.Data.DataRow" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSchema">
      <MemberSignature Language="C#" Value="protected virtual System.Xml.Schema.XmlSchema GetSchema ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xml.Schema.XmlSchema GetSchema() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetSchema" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetSchema () As XmlSchema" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xml::Schema::XmlSchema ^ GetSchema();" />
      <MemberSignature Language="F#" Value="abstract member GetSchema : unit -&gt; System.Xml.Schema.XmlSchema&#xA;override this.GetSchema : unit -&gt; System.Xml.Schema.XmlSchema" Usage="dataTable.GetSchema " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.GetSchema</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchema</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" />.</summary>
        <returns>
          <see cref="T:System.Xml.Schema.XmlSchema" /> Opisujący reprezentację XML obiektu, który jest wytwarzany przez <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" /> metody, które są używane przez <see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" /> metody.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasErrors">
      <MemberSignature Language="C#" Value="public bool HasErrors { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasErrors" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.HasErrors" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasErrors As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasErrors { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasErrors : bool" Usage="System.Data.DataTable.HasErrors" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableHasErrorsDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy istnieją błędy w dowolnych wierszach we wszystkich tabelach <see cref="T:System.Data.DataSet" /> do której należy tabeli.</summary>
        <value>
          <see langword="true" /> Jeśli występują błędy; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy użytkownik pracuje na zestawie danych zawartych w <xref:System.Data.DataTable>, można oznaczyć każdej zmiany z powodu błędu, jeśli zmiana powoduje, że niektóre niepowodzenia weryfikacji. Można oznaczyć całą <xref:System.Data.DataRow> z komunikatu błędu za pomocą <xref:System.Data.DataRow.RowError%2A> właściwości. Można również ustawić błędów dotyczących poszczególnych kolumn wiersz mający <xref:System.Data.DataRow.SetColumnError%2A> metody.  
  
 Przed zaktualizowaniem źródła danych z <xref:System.Data.DataSet>, zaleca się, że należy najpierw wywołać <xref:System.Data.DataSet.GetChanges%2A> metody w elemencie docelowym <xref:System.Data.DataSet>. Metoda nie powoduje <xref:System.Data.DataSet> zawierający tylko zmiany wprowadzone w oryginalnej. Przed wysłaniem <xref:System.Data.DataSet> ze źródłem danych w celu zaktualizowania Sprawdź <xref:System.Data.DataTable.HasErrors%2A> właściwości każdej tabeli, aby zobaczyć, jeśli błędy zostały dołączone do wierszy lub kolumn w wiersze.  
  
 Po uzgodnieniu każdego błędu, usuń błędy występujące w <xref:System.Data.DataRow.ClearErrors%2A> metody `DataRow`.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Data.DataTable.HasErrors%2A> właściwość do sprawdzenia, czy tabela zawiera błędy.  
  
 [!code-csharp[Classic WebData DataTable.HasErrors Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.HasErrors Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.HasErrors Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.HasErrors Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataTable.GetErrors" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="ImportRow">
      <MemberSignature Language="C#" Value="public void ImportRow (System.Data.DataRow row);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ImportRow(class System.Data.DataRow row) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ImportRow(System.Data.DataRow)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ImportRow (row As DataRow)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ImportRow(System::Data::DataRow ^ row);" />
      <MemberSignature Language="F#" Value="member this.ImportRow : System.Data.DataRow -&gt; unit" Usage="dataTable.ImportRow row" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="row" Type="System.Data.DataRow" />
      </Parameters>
      <Docs>
        <param name="row">
          <see cref="T:System.Data.DataRow" /> Do zaimportowania.</param>
        <summary>Kopiuje <see cref="T:System.Data.DataRow" /> do <see cref="T:System.Data.DataTable" />, zachowując wszystkie ustawienia właściwości, oryginalnym i bieżącym wartości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływanie <xref:System.Data.DataTable.NewRow%2A> dodaje wiersz do tabeli za pomocą istniejący schemat tabeli, ale z wartościami domyślnymi dla wiersza, a następnie ustawia <xref:System.Data.DataRowState> do `Detached`. Wywoływanie <xref:System.Data.DataTable.ImportRow%2A> zachowuje istniejące <xref:System.Data.DataRowState> wraz z innymi wartościami w wierszu. Jeśli `DataRow` przekazana jako parametr jest w stanie odłączony, jest ignorowany i jest zgłaszany żaden wyjątek.  
  
 Nowy wiersz zostanie dodany na końcu tabeli danych.  
  
 Jeśli nowy wiersz narusza ograniczenie nie będą dodawane do tabeli danych.  
  
 Możesz uzyskać indeks nowego wiersza przy użyciu DataTable.Rows.Find oraz DataTable.Rows.IndexOf. Zobacz <xref:System.Data.DataRowCollection> i <xref:System.Data.DataTable.Rows%2A> Aby uzyskać więcej informacji.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/5cb86d48-a987-4af4-80e0-8cc2c8373d62">Manipulowanie danymi w elemencie DataTable (ADO.NET)</related>
      </Docs>
    </Member>
    <Member MemberName="Initialized">
      <MemberSignature Language="C#" Value="public event EventHandler Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.Initialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Initialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ Initialized;" />
      <MemberSignature Language="F#" Value="member this.Initialized : EventHandler " Usage="member this.Initialized : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po <see cref="T:System.Data.DataTable" /> został zainicjowany.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji, zobacz <xref:System.Data.DataTable.IsInitialized%2A>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Praca ze zdarzeniami DataTable</related>
      </Docs>
    </Member>
    <Member MemberName="IsInitialized">
      <MemberSignature Language="C#" Value="public bool IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.IsInitialized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInitialized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitialized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInitialized : bool" Usage="System.Data.DataTable.IsInitialized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Data.DataTable" /> został zainicjowany.</summary>
        <value>
          <see langword="true" /> Aby wskazać składnik ma ukończyła inicjowanie; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwraca stan <xref:System.Data.DataTable> podczas jego jest budowany, na przykład przez program Visual Studio. <xref:System.Data.DataTable.BeginInit%2A> Metody ustawia ją na `false` i <xref:System.Data.DataTable.EndInit%2A> metody ustawia ją na `true`.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Praca ze zdarzeniami DataTable</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wypełnia <see cref="T:System.Data.DataTable" /> wartościami ze źródła danych za pomocą podane <see cref="T:System.Data.IDataReader" />. Jeśli <see langword="DataTable" /> już zawiera wiersze, przychodzących danych ze źródła danych jest scalany z istniejących wierszy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Load` Metoda może być używana w kilku typowych scenariuszy, wszystkie wyśrodkowany wokół pobierania danych z określonego źródła danych i dodanie go do bieżącego kontenera danych (w tym przypadku `DataTable`). Scenariusze te opisują użycie standardowego `DataTable`opisujące jego aktualizacji i scalenia zachowanie.  
  
 A `DataTable` synchronizuje lub aktualizacji z pojedynczego podstawowego źródła danych. `DataTable` Śledzi zmiany, dzięki czemu synchronizacji z podstawowego źródła danych. Ponadto `DataTable` może akceptować dane przyrostowe z co najmniej jedno źródło danych pomocniczych. `DataTable` Nie jest odpowiedzialny za śledzenie zmian w celu umożliwienia synchronizacji z pomocnicze źródło danych.  
  
 Biorąc pod uwagę te dwa źródła danych hipotetyczny, użytkownik prawdopodobnie Wymagaj jednej z następujących problemów:  
  
-   Inicjowanie `DataTable` z podstawowego źródła danych. W tym scenariuszu użytkownik chce, aby zainicjować pustą `DataTable` wartościami z podstawowego źródła danych. Później użytkownik zamierza propagujące zmiany do podstawowego źródła danych.  
  
-   Zachowaj zmiany i przeprowadź ponowną synchronizację z podstawowego źródła danych. W tym scenariuszu użytkownik chce wykonać `DataTable` wypełnione w poprzednim scenariuszu i wykonywać synchronizację przyrostową z podstawowego źródła danych, zmiany dokonane w zachowaniu `DataTable`.  
  
-   Dane przyrostowe źródła danych ze źródeł danych pomocniczych. W tym scenariuszu użytkownik chce scalenie zmian z co najmniej jedno źródło danych pomocniczych i przenosić je ponownie do podstawowego źródła danych.  
  
 `Load` Metody sprawia, że wszystkie te scenariusze są możliwe. Wszystkie oprócz jednego z przeciążeń dla tej metody można określić parametr opcji obciążenia, wskazując jak wiersze już <xref:System.Data.DataTable> łączenie wierszy ładowany. (Przeciążenie, które nie pozwalają na określenie zachowania używa domyślnej opcji obciążenia). W poniższej tabeli opisano opcje ładowania trzy, dostarczone przez <xref:System.Data.LoadOption> wyliczenia. W każdym przypadku opis wskazuje zachowanie, gdy klucz podstawowy wiersza w danych przychodzących jest zgodna z klucza podstawowego istniejącego wiersza.  
  
|Opcja ładowanie|Opis|  
|-----------------|-----------------|  
|`PreserveChanges` (ustawienie domyślne)|Aktualizuje oryginalną wersję wiersz o wartości przychodzących wiersza.|  
|`OverwriteChanges`|Bieżąca i oryginalna wersja wiersz zostaje zaktualizowana o wartości przychodzących wiersza.|  
|`Upsert`|Bieżąca wersja wiersz zostaje zaktualizowana o wartości przychodzących wiersza.|  
  
 Ogólnie rzecz biorąc `PreserveChanges` i `OverwriteChanges` opcje są przeznaczone dla scenariuszy, w którym użytkownik musi zsynchronizować `DataSet` i jego zmian za pomocą podstawowego źródła danych. `Upsert` Opcja ułatwia agregację zmian z co najmniej jedno źródło danych pomocniczych.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano kilka zagadnień związanych z wywołaniem <xref:System.Data.DataTable.Load%2A> metody. Po pierwsze, przykład koncentruje się na problemy ze schematem, w tym wnioskowanie schematu z załadowanych <xref:System.Data.IDataReader>, a następnie Obsługa niezgodne schematów i schematów, dla których brakuje lub dodatkowych kolumn. Przykład następnie koncentruje się na problemy z danych, w tym obsługa różne opcje ładowania.  
  
> [!NOTE]
>  W tym przykładzie pokazano, jak użyć jednej z przeciążone wersje `Load`. Inne przykłady, które mogą być dostępne znajduje się w tematach poszczególnych przeciążeń.  
  
 [!code-csharp[DataWorks DataTableLoad#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableLoad/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableLoad#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableLoad/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Data.DataSet.Load" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Data.IDataReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Data.IDataReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Load(System.Data.IDataReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Load (reader As IDataReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Data::IDataReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.Load : System.Data.IDataReader -&gt; unit" Usage="dataTable.Load reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Data.IDataReader" /> Zapewniający zestaw wyników.</param>
        <summary>Wypełnia <see cref="T:System.Data.DataTable" /> wartościami ze źródła danych za pomocą podane <see cref="T:System.Data.IDataReader" />. Jeśli <see cref="T:System.Data.DataTable" /> już zawiera wiersze, przychodzących danych ze źródła danych jest scalany z istniejących wierszy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.Load%2A> Metoda zużywa pierwszego zestawu wyników z załadowanych <xref:System.Data.IDataReader>i po pomyślnym zakończeniu Ustawia położenie czytelnika następny zestaw wyników, jeśli wszystkie. Podczas konwertowania danych `Load` metoda wykorzystuje te same reguły konwersji jako <xref:System.Data.Common.DbDataAdapter.Fill%2A?displayProperty=nameWithType> metody.  
  
 <xref:System.Data.DataTable.Load%2A> Metody należy wziąć pod uwagę trzy określone problemy podczas ładowania danych z <xref:System.Data.IDataReader> wystąpienie: operacje schematu, dane i zdarzenia. Podczas pracy ze schematem, <xref:System.Data.DataTable.Load%2A> metody, które mogą wystąpić warunki zgodnie z opisem w poniższej tabeli. Operacje schematu miejsce dla wszystkich zestawów importowanych wynik, nawet tych, które zawierają żadnych danych.  
  
|Warunek|Zachowanie|  
|---------------|--------------|  
|<xref:System.Data.DataTable> Ma bez schematu.|<xref:System.Data.DataTable.Load%2A> Metoda wnioskuje schemat na podstawie wyniku z zaimportowanych <xref:System.Data.IDataReader>.|  
|<xref:System.Data.DataTable> Ma schematu, ale nie jest zgodny ze schematem załadowane.|<xref:System.Data.DataTable.Load%2A> Metoda zgłasza wyjątek odpowiadający danego błędu, który występuje podczas próby załadowania danych do schematu niezgodne.|  
|Schematy są zgodne, ale schemat zestawu załadować wynik zawiera kolumny, które nie istnieją w <xref:System.Data.DataTable>.|<xref:System.Data.DataTable.Load%2A> Metoda dodaje dodatkowe kolumny `DataTable`w schemacie. Metoda zgłasza wyjątek, jeśli odpowiadający kolumn w <xref:System.Data.DataTable> i zestawu wyników załadować nie są zgodne wartości. Metoda również pobiera informacje o ograniczeniach z zestawu wyników dla wszystkich dodanych kolumn. Z wyjątkiem w przypadku ograniczenia Primary Key, informacje te ograniczenia są używane tylko wtedy, gdy bieżący <xref:System.Data.DataTable> nie zawiera żadnych kolumn na początku operacji ładowania.|  
|Schematy są zgodne, ale schemat zestawu załadować wynik zawiera mniejszą liczbę kolumn niż `DataTable`.|Jeśli brakuje kolumna zawiera wartości domyślnej lub typ danych w kolumnie jest wartość null, <xref:System.Data.DataTable.Load%2A> metoda umożliwia wierszy, które mają zostać dodane, zastępując domyślne lub `null` wartość brakującej kolumnie. Jeśli ma wartości domyślnej lub `null` mogą być używane, a następnie `Load` metoda zgłasza wyjątek. Jeśli podano żadnej wartości domyślnej określonych, `Load` metoda używa `null` wartość jako wartość dorozumianych domyślne.|  
  
 Zanim będzie można uznać zachowanie `Load` metoda pod względem operacje na danych, należy wziąć pod uwagę, każdy wiersz w ramach <xref:System.Data.DataTable> obsługuje bieżąca wartość i oryginalnej wartości dla każdej kolumny. Te wartości mogą być równoważna lub może być inny, jeśli dane w wiersz został zmieniony od czasu wypełnianie `DataTable`.  Aby uzyskać więcej informacji, zobacz [stany wiersza i wersje wiersza](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md).  
  
 Ta wersja `Load` metoda próbuje zachować bieżące wartości w każdym wierszu, pozostawiając bez zmian do oryginalnej wartości. (Jeśli chcesz bardziej precyzyjną kontrolę nad zachowaniem przychodzących danych, zobacz <xref:System.Data.DataTable.Load%2A?displayProperty=nameWithType>.) Jeśli istniejący wiersz i wiersz zawiera odpowiednie wartości klucza podstawowego, wiersz zostanie przetworzona przy użyciu jego wartości stanu bieżącego wiersza, w przeciwnym razie jest ona traktowana jako nowy wiersz.  
  
 Pod względem operacje zdarzeń <xref:System.Data.DataTable.RowChanging> wystąpi zdarzenie przed zmianą każdy wiersz i <xref:System.Data.DataTable.RowChanged> wystąpi zdarzenie po zmianie każdego wiersza. W każdym przypadku <xref:System.Data.DataRowChangeEventArgs.Action%2A> właściwość <xref:System.Data.DataRowChangeEventArgs> wystąpienia przekazane do narzędzia obsługi zdarzeń zawiera informacje o określonej akcji, skojarzone ze zdarzeniem. Ta wartość akcji zależy od stanu wiersza przed wykonaniem operacji obciążenia. W każdym przypadku zarówno zdarzenia występują, a akcja jest taka sama dla każdego. Akcję można stosować do bieżącej lub oryginalnej wersji każdego wiersza i / lub, w zależności od stanu bieżącego wiersza.  
  
 W poniższej tabeli przedstawiono zachowania dla `Load` metody. Wiersz końcowy (etykietą "(Brak)") opisano działanie dla przychodzących wierszy, które nie są zgodne z dowolnego istniejącego wiersza. Każda komórka w tej tabeli opisano bieżąca i oryginalna wartość dla pola w wierszu, a wraz z <xref:System.Data.DataRowState> wartości po `Load` metoda została zakończona. W tym przypadku metoda nie pozwala wskazać opcja obciążenia i stosuje domyślną, `PreserveChanges`.  
  
|Istniejące właściwością DataRowState|Wartości po `Load` metody i zdarzenia działania|  
|---------------------------|--------------------------------------------------|  
|Dodano|Bieżące = \<istniejących ><br /><br /> Oryginalny = \<przychodzących ><br /><br /> Stan = \<zmodyfikowane ><br /><br /> RowAction = ChangeOriginal|  
|Zmodyfikowano|Bieżące = \<istniejących ><br /><br /> Oryginalny = \<przychodzących ><br /><br /> Stan = \<zmodyfikowane ><br /><br /> RowAction = ChangeOriginal|  
|Usunięte|Bieżące = \<niedostępne ><br /><br /> Oryginalny = \<przychodzących ><br /><br /> Stan = \<usunięty ><br /><br /> RowAction = ChangeOriginal|  
|bez zmian|Bieżące = \<przychodzących ><br /><br /> Oryginalny = \<przychodzących ><br /><br /> Stan = \<bez zmian ><br /><br /> RowAction = ChangeCurrentAndOriginal|  
|(Brak)|Bieżące = \<przychodzących ><br /><br /> Oryginalny = \<przychodzących ><br /><br /> Stan = \<bez zmian ><br /><br /> RowAction = ChangeCurrentAndOriginal|  
  
 Wartości w <xref:System.Data.DataColumn> może być ograniczona przez użycie właściwości takich jak <xref:System.Data.DataColumn.ReadOnly%2A> i <xref:System.Data.DataColumn.AutoIncrement%2A>. `Load` Obsługiwała takich kolumn w taki sposób, który jest zgodny z zachowaniem definiowanych przez właściwości kolumny. Jedynym ograniczeniem odczytu na <xref:System.Data.DataColumn> ma zastosowanie tylko w przypadku zmiany pojawiające się w pamięci. `Load` Metody powoduje zastąpienie wartości kolumn jako tylko do odczytu, jeśli to konieczne.  
  
 Aby określić, która wersja klucz podstawowy do użycia dla porównania bieżącego wiersza z wierszem przychodzące, `Load` metoda używa oryginalnej wersji wartość klucza podstawowego w wierszu, jeśli taki istnieje. W przeciwnym razie `Load` metoda używa bieżącej wersji klucz podstawowy.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano kilka zagadnień związanych z wywołaniem <xref:System.Data.DataTable.Load%2A> metody. Po pierwsze, przykład koncentruje się na problemy ze schematem, w tym wnioskowanie schematu z załadowanych <xref:System.Data.IDataReader>, a następnie Obsługa niezgodne schematów i schematów, dla których brakuje lub dodatkowych kolumn. Przykład następnie wywołuje `Load` metody, wyświetla dane, przed i po operacji ładowania.  
  
 [!code-csharp[DataWorks DataTableLoad.IDataReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableLoad.IDataReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableLoad.IDataReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableLoad.IDataReader/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Praca ze zdarzeniami DataTable</related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Data::IDataReader ^ reader, System::Data::LoadOption loadOption);" />
      <MemberSignature Language="F#" Value="member this.Load : System.Data.IDataReader * System.Data.LoadOption -&gt; unit" Usage="dataTable.Load (reader, loadOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Data.IDataReader" /> Zawierający jeden lub więcej zestawów wyników.</param>
        <param name="loadOption">Wartość z zakresu od <see cref="T:System.Data.LoadOption" /> wyliczenia, która wskazuje, jak już wiersze <see cref="T:System.Data.DataTable" /> są łączone z przychodzącego wierszy, które współużytkują ten sam klucz podstawowy.</param>
        <summary>Wypełnia <see cref="T:System.Data.DataTable" /> wartościami ze źródła danych za pomocą podane <see cref="T:System.Data.IDataReader" />. Jeśli <see langword="DataTable" /> już zawiera wiersze, przychodzących danych ze źródła danych jest scalany z istniejących wierszy, zgodnie z wartością <paramref name="loadOption" /> parametru.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Load` Metoda zużywa pierwszego zestawu wyników z załadowanych <xref:System.Data.IDataReader>i po pomyślnym zakończeniu Ustawia położenie czytelnika następny zestaw wyników, jeśli wszystkie. Podczas konwertowania danych `Load` metoda wykorzystuje te same reguły konwersji jako <xref:System.Data.Common.DbDataAdapter.Fill%2A> metody.  
  
 `Load` Metody należy wziąć pod uwagę trzy określone problemy podczas ładowania danych z <xref:System.Data.IDataReader> wystąpienie: operacje schematu, dane i zdarzenia. Podczas pracy ze schematem, `Load` metody, które mogą wystąpić warunki zgodnie z opisem w poniższej tabeli. Operacje schematu miejsce dla wszystkich zestawów importowanych wynik, nawet tych, które zawierają żadnych danych.  
  
|Warunek|Zachowanie|  
|---------------|--------------|  
|<xref:System.Data.DataTable> Ma bez schematu.|`Load` Metoda wnioskuje schemat na podstawie wyniku z zaimportowanych <xref:System.Data.IDataReader>.|  
|<xref:System.Data.DataTable> Ma schematu, ale nie jest zgodny ze schematem załadowane.|`Load` Metoda zgłasza wyjątek odpowiadający danego błędu, który występuje podczas próby załadowania danych do schematu niezgodne.|  
|Schematy są zgodne, ale schemat zestawu załadować wynik zawiera kolumny, które nie istnieją w `DataTable`.|`Load` Metoda dodaje dodatkowe kolumny `DataTable`w schemacie. Metoda zgłasza wyjątek, jeśli odpowiadający kolumn w <xref:System.Data.DataTable> i zestawu wyników załadować nie są zgodne wartości. Metoda również pobiera informacje o ograniczeniach z zestawu wyników dla wszystkich dodanych kolumn. Z wyjątkiem w przypadku ograniczenia Primary Key, informacje te ograniczenia są używane tylko wtedy, gdy bieżący <xref:System.Data.DataTable> nie zawiera żadnych kolumn na początku operacji ładowania.|  
|Schematy są zgodne, ale schemat zestawu załadować wynik zawiera mniejszą liczbę kolumn niż `DataTable`.|Jeśli brakuje kolumna zawiera wartości domyślnej lub typ danych w kolumnie jest wartość null, `Load` metoda umożliwia wierszy, które mają zostać dodane, zastępując wartość domyślna lub wartość null dla brakującej kolumnie. Jeśli nie wartość domyślna lub wartość null, może być używany, a następnie `Load` metoda zgłasza wyjątek. Jeśli podano żadnej wartości domyślnej określonych, `Load` metoda używa wartości null jako wartość dorozumianych domyślne.|  
  
 Zanim będzie można uznać zachowanie `Load` metoda pod względem operacje na danych, należy wziąć pod uwagę, każdy wiersz w ramach <xref:System.Data.DataTable> obsługuje bieżąca wartość i oryginalnej wartości dla każdej kolumny. Te wartości mogą być równoważna lub może być inny, jeśli dane w wiersz został zmieniony od czasu wypełnianie `DataTable`. Zobacz [stany wiersza i wersje wiersza](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md) Aby uzyskać więcej informacji.  
  
 W tym wywołaniu metody, określony <xref:System.Data.LoadOption> parametr ma wpływ przetwarzania przychodzących danych. Jak metoda obciążenia powinna obsługiwać ładowania wierszy, które mają taki sam klucz podstawowy, jak istniejące wiersze Należy go modyfikować wartości bieżących i oryginalnych wartości? Te problemy i uzyskać więcej informacji, są kontrolowane przez `loadOption` parametru.  
  
 Jeśli istniejący wiersz i wiersz zawiera odpowiednie wartości klucza podstawowego, wiersz zostanie przetworzona przy użyciu jego wartości stanu bieżącego wiersza, w przeciwnym razie jest ona traktowana jako nowy wiersz.  
  
 Pod względem operacje zdarzeń <xref:System.Data.DataTable.RowChanging> wystąpi zdarzenie przed zmianą każdy wiersz i <xref:System.Data.DataTable.RowChanged> wystąpi zdarzenie po zmianie każdego wiersza. W każdym przypadku <xref:System.Data.DataRowChangeEventArgs.Action%2A> właściwość <xref:System.Data.DataRowChangeEventArgs> wystąpienia przekazane do narzędzia obsługi zdarzeń zawiera informacje o określonej akcji, skojarzone ze zdarzeniem. Wartość ta akcja różni się w zależności od stanu wiersza przed wykonaniem operacji obciążenia. W każdym przypadku zarówno zdarzenia występują, a akcja jest taka sama dla każdego. Akcję można stosować do bieżącej lub oryginalnej wersji każdego wiersza i / lub, w zależności od stanu bieżącego wiersza.  
  
 W poniższej tabeli przedstawiono zachowania dla metody obciążenia po wywołaniu, z których każdy `LoadOption` wartości, a także pokazuje, jak wartości wchodzić w interakcje ze stanem wiersza dla wiersza, trwa ładowanie. Wiersz końcowy (etykietą "(Brak)") opisano działanie dla przychodzących wierszy, które nie są zgodne z dowolnego istniejącego wiersza. Każda komórka w tej tabeli opisano bieżąca i oryginalna wartość dla pola w wierszu, a wraz z <xref:System.Data.DataRowState> wartości po `Load` metoda została zakończona.  
  
|Istniejące właściwością DataRowState|UPSERT|OverwriteChanges|PreserveChanges (zachowanie domyślne)|  
|---------------------------|------------|----------------------|------------------------------------------|  
|Dodano|Bieżące = \<przychodzących ><br /><br /> Oryginalny = -\<niedostępne ><br /><br /> Stan = \<dodano ><br /><br /> RowAction = zmiany|Bieżące = \<przychodzących ><br /><br /> Oryginalny = \<przychodzących ><br /><br /> Stan = \<bez zmian ><br /><br /> RowAction = ChangeCurrentAndOriginal|Bieżące = \<istniejących ><br /><br /> Oryginalny = \<przychodzących ><br /><br /> Stan = \<zmodyfikowane ><br /><br /> RowAction = ChangeOriginal|  
|Zmodyfikowano|Bieżące = \<przychodzących ><br /><br /> Oryginalny = \<istniejących ><br /><br /> Stan = \<zmodyfikowane ><br /><br /> RowAction = zmiany|Bieżące = \<przychodzących ><br /><br /> Oryginalny = \<przychodzących ><br /><br /> Stan = \<bez zmian ><br /><br /> RowAction = ChangeCurrentAndOriginal|Bieżące = \<istniejących ><br /><br /> Oryginalny = \<przychodzących ><br /><br /> Stan = \<zmodyfikowane ><br /><br /> RowAction = ChangeOriginal|  
ersję usuniętą|(Ładowanie nie nie wpływają na usunięte wiersze)<br /><br /> Bieżące =---<br /><br /> Oryginalny = \<istniejących ><br /><br /> Stan = \<usunięty ><br /><br /> (Nowy wiersz został dodany o następującej charakterystyce)<br /><br /> Bieżące = \<przychodzących ><br /><br /> Oryginalny = \<niedostępne ><br /><br /> Stan = \<dodano ><br /><br /> RowAction = Dodaj|Cofanie usunięcia i<br /><br /> Bieżące = \<przychodzących ><br /><br /> Oryginalny = \<przychodzących ><br /><br /> Stan = \<bez zmian ><br /><br /> RowAction = ChangeCurrentAndOriginal|Bieżące = \<niedostępne ><br /><br /> Oryginalny = \<przychodzących ><br /><br /> Stan = \<usunięty ><br /><br /> RowAction = ChangeOriginal|  
|bez zmian|Bieżące = \<przychodzących ><br /><br /> Oryginalny = \<istniejących ><br /><br /> Jeśli nowa wartość jest taka sama jak istniejąca wartość<br /><br /> Stan = \<bez zmian ><br /><br /> RowAction = Nothing<br /><br /> else<br /><br /> Stan = \<zmodyfikowane ><br /><br /> RowAction = zmiany|Bieżące = \<przychodzących ><br /><br /> Oryginalny = \<przychodzących ><br /><br /> Stan = \<bez zmian ><br /><br /> RowAction = ChangeCurrentAndOriginal|Bieżące = \<przychodzących ><br /><br /> Oryginalny = \<przychodzących ><br /><br /> Stan = \<bez zmian ><br /><br /> RowAction = ChangeCurrentAndOriginal|  
Nie istnieje)|Bieżące = \<przychodzących ><br /><br /> Oryginalny = \<niedostępne ><br /><br /> Stan = \<dodano ><br /><br /> RowAction = Dodaj|Bieżące = \<przychodzących ><br /><br /> Oryginalny = \<przychodzących ><br /><br /> Stan = \<bez zmian ><br /><br /> RowAction = ChangeCurrentAndOriginal|Bieżące = \<przychodzących ><br /><br /> Oryginalny = \<przychodzących ><br /><br /> Stan = \<bez zmian ><br /><br /> RowAction = ChangeCurrentAndOriginal|  
  
 Wartości w <xref:System.Data.DataColumn> może być ograniczona przez użycie właściwości takich jak <xref:System.Data.DataColumn.ReadOnly%2A> i <xref:System.Data.DataColumn.AutoIncrement%2A>. `Load` Obsługiwała takich kolumn w taki sposób, który jest zgodny z zachowaniem definiowanych przez właściwości kolumny. Jedynym ograniczeniem odczytu na <xref:System.Data.DataColumn> ma zastosowanie tylko w przypadku zmiany pojawiające się w pamięci. `Load` Metody powoduje zastąpienie wartości kolumn jako tylko do odczytu, jeśli to konieczne.  
  
 Jeśli określisz OverwriteChanges lub PreserveChanges opcji podczas wywoływania `Load` metody, a następnie zakładając wykonano, że dane przychodzące pochodzi z `DataTable`firmy podstawowego źródła danych i tabeli DataTable śledzi zmiany i możesz propagować zmiany z powrotem do źródła danych. Jeśli zostanie wybrana opcja Upsert, zakłada się, pochodzą dane z jednego źródła danych dodatkowych, takich jak dane przez składnik warstwy środkowej, może być zmieniony przez użytkownika. W tym przypadku założeniem jest, celem jest z co najmniej jedno źródło danych w celu agregowania danych `DataTable`i może być propagowanie danych do podstawowego źródła danych. <xref:System.Data.LoadOption> Parametr jest używany do określania określoną wersję wiersza, który ma być używany dla porównania klucza podstawowego. Poniższa tabela zawiera szczegółowe informacje.  
  
|Opcja ładowanie|Wersji elementu DataRow używana na potrzeby porównania klucza podstawowego|  
|-----------------|-----------------------------------------------------|  
|`OverwriteChanges`|Oryginalna wersja, jeśli istnieje, w przeciwnym razie bieżąca wersja|  
|`PreserveChanges`|Oryginalna wersja, jeśli istnieje, w przeciwnym razie bieżąca wersja|  
|`Upsert`|Bieżąca wersja, jeśli istnieje, w przeciwnym razie oryginalnej wersji|  
  
   
  
## Examples  
 W poniższym przykładzie pokazano kilka zagadnień związanych z wywołaniem <xref:System.Data.DataTable.Load%2A> metody. Po pierwsze, przykład koncentruje się na problemy ze schematem, w tym wnioskowanie schematu z załadowanych <xref:System.Data.IDataReader>, a następnie Obsługa niezgodne schematów i schematów, dla których brakuje lub dodatkowych kolumn. Przykład następnie koncentruje się na problemy z danych, w tym obsługa różne opcje ładowania.  
  
 [!code-csharp[DataWorks DataTableLoad.LoadOption#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableLoad.LoadOption/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableLoad.LoadOption#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableLoad.LoadOption/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Praca ze zdarzeniami DataTable</related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public virtual void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption, System.Data.FillErrorEventHandler errorHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption, class System.Data.FillErrorEventHandler errorHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Load(System::Data::IDataReader ^ reader, System::Data::LoadOption loadOption, System::Data::FillErrorEventHandler ^ errorHandler);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Data.IDataReader * System.Data.LoadOption * System.Data.FillErrorEventHandler -&gt; unit&#xA;override this.Load : System.Data.IDataReader * System.Data.LoadOption * System.Data.FillErrorEventHandler -&gt; unit" Usage="dataTable.Load (reader, loadOption, errorHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
        <Parameter Name="errorHandler" Type="System.Data.FillErrorEventHandler" />
      </Parameters>
      <Docs>
        <param name="reader">A <see cref="T:System.Data.IDataReader" /> zapewniający zestaw wyników.</param>
        <param name="loadOption">Wartość z zakresu od <see cref="T:System.Data.LoadOption" /> wyliczenia, która wskazuje, jak już wiersze <see cref="T:System.Data.DataTable" /> są łączone z przychodzącego wierszy, które współużytkują ten sam klucz podstawowy.</param>
        <param name="errorHandler">A <see cref="T:System.Data.FillErrorEventHandler" /> pełnomocnika do wywołania po wystąpieniu błędu podczas ładowania danych.</param>
        <summary>Wypełnia <see cref="T:System.Data.DataTable" /> wartościami ze źródła danych za pomocą podane <see cref="T:System.Data.IDataReader" /> używanie delegata obsługi błędów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Load` Metoda zużywa pierwszego zestawu wyników z załadowanych <xref:System.Data.IDataReader>i po pomyślnym zakończeniu Ustawia położenie czytelnika następny zestaw wyników, jeśli wszystkie. Podczas konwertowania danych `Load` metoda wykorzystuje te same reguły konwersji jako <xref:System.Data.Common.DbDataAdapter.Fill%2A?displayProperty=nameWithType> metody.  
  
 `Load` Metody należy wziąć pod uwagę trzy określone problemy podczas ładowania danych z <xref:System.Data.IDataReader> wystąpienie: operacje schematu, dane i zdarzenia. Podczas pracy ze schematem, `Load` metody, które mogą wystąpić warunki zgodnie z opisem w poniższej tabeli. Operacje schematu miejsce dla wszystkich zestawów importowanych wynik, nawet tych, które zawierają żadnych danych.  
  
|Warunek|Zachowanie|  
|---------------|--------------|  
|<xref:System.Data.DataTable> Ma bez schematu.|`Load` Metoda wnioskuje schemat na podstawie wyniku z zaimportowanych <xref:System.Data.IDataReader>.|  
|<xref:System.Data.DataTable> Ma schematu, ale nie jest zgodny ze schematem załadowane.|`Load` Metoda zgłasza wyjątek odpowiadający danego błędu, który występuje podczas próby załadowania danych do schematu niezgodne.|  
|Schematy są zgodne, ale schemat zestawu załadować wynik zawiera kolumny, które nie istnieją w `DataTable`.|`Load` Metoda dodaje dodatkowe kolumny do `DataTable`w schemacie. Metoda zgłasza wyjątek, jeśli odpowiadający kolumn w <xref:System.Data.DataTable> i zestawu wyników załadować nie są zgodne wartości. Metoda również pobiera informacje o ograniczeniach z zestawu wyników dla wszystkich dodanych kolumn. Z wyjątkiem w przypadku ograniczenia Primary Key, informacje te ograniczenia są używane tylko wtedy, gdy bieżący <xref:System.Data.DataTable> nie zawiera żadnych kolumn na początku operacji ładowania.|  
|Schematy są zgodne, ale schemat zestawu załadować wynik zawiera mniejszą liczbę kolumn niż `DataTable`.|Jeśli brakuje kolumna zawiera wartości domyślnej lub typ danych w kolumnie jest wartość null, `Load` metoda umożliwia wierszy, które mają zostać dodane, zastępując wartość domyślna lub wartość null dla brakującej kolumnie. Jeśli nie wartość domyślna lub wartość null, może być używany, a następnie `Load` metoda zgłasza wyjątek. Jeśli podano żadnej wartości domyślnej określonych, `Load` metoda używa wartości null jako wartość dorozumianych domyślne.|  
  
 Zanim będzie można uznać zachowanie `Load` metoda pod względem operacje na danych, należy wziąć pod uwagę, każdy wiersz w ramach <xref:System.Data.DataTable> obsługuje bieżąca wartość i oryginalnej wartości dla każdej kolumny. Te wartości mogą być równoważna lub może być inny, jeśli dane w wiersz został zmieniony od czasu wypełnianie `DataTable`. Zobacz [stany wiersza i wersje wiersza](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md) Aby uzyskać więcej informacji.  
  
 W tym wywołaniu metody, określony <xref:System.Data.LoadOption> parametr ma wpływ przetwarzania przychodzących danych. Jak metoda obciążenia powinna obsługiwać ładowania wierszy, które mają taki sam klucz podstawowy, jak istniejące wiersze Należy go modyfikować wartości bieżących i oryginalnych wartości? Te problemy i uzyskać więcej informacji, są kontrolowane przez `loadOption` parametru.  
  
 Jeśli istniejący wiersz i wiersz zawiera odpowiednie wartości klucza podstawowego, wiersz zostanie przetworzona przy użyciu jego wartości stanu bieżącego wiersza, w przeciwnym razie jest ona traktowana jako nowy wiersz.  
  
 Pod względem operacje zdarzeń <xref:System.Data.DataTable.RowChanging> wystąpi zdarzenie przed zmianą każdy wiersz i <xref:System.Data.DataTable.RowChanged> wystąpi zdarzenie po zmianie każdego wiersza. W każdym przypadku <xref:System.Data.DataRowChangeEventArgs.Action%2A> właściwość <xref:System.Data.DataRowChangeEventArgs> wystąpienia przekazane do narzędzia obsługi zdarzeń zawiera informacje o określonej akcji, skojarzone ze zdarzeniem. Wartość ta akcja różni się w zależności od stanu wiersza przed wykonaniem operacji obciążenia. W każdym przypadku zarówno zdarzenia występują, a akcja jest taka sama dla każdego. Akcję można stosować do bieżącej lub oryginalnej wersji każdego wiersza i / lub, w zależności od stanu bieżącego wiersza.  
  
 W poniższej tabeli przedstawiono zachowania dla metody obciążenia po wywołaniu, z których każdy `LoadOption` wartości, a także pokazuje, jak wartości wchodzić w interakcje ze stanem wiersza dla wiersza, trwa ładowanie. Wiersz końcowy (etykietą "(Brak)") opisano działanie dla przychodzących wierszy, które nie są zgodne z dowolnego istniejącego wiersza. Każda komórka w tej tabeli opisano bieżąca i oryginalna wartość dla pola w wierszu, a wraz z <xref:System.Data.DataRowState> wartości po `Load` metoda została zakończona.  
  
|Istniejące właściwością DataRowState|UPSERT|OverwriteChanges|PreserveChanges (zachowanie domyślne)|  
|---------------------------|------------|----------------------|------------------------------------------|  
|Dodano|Bieżące = \<przychodzących ><br /><br /> Oryginalny = -\<niedostępne ><br /><br /> Stan = \<dodano ><br /><br /> RowAction = zmiany|Bieżące = \<przychodzących ><br /><br /> Oryginalny = \<przychodzących ><br /><br /> Stan = \<bez zmian ><br /><br /> RowAction = ChangeCurrentAndOriginal|Bieżące = \<istniejących ><br /><br /> Oryginalny = \<przychodzących ><br /><br /> Stan = \<zmodyfikowane ><br /><br /> RowAction = ChangeOriginal|  
|Zmodyfikowano|Bieżące = \<przychodzących ><br /><br /> Oryginalny = \<istniejących ><br /><br /> Stan = \<zmodyfikowane ><br /><br /> RowAction = zmiany|Bieżące = \<przychodzących ><br /><br /> Oryginalny = \<przychodzących ><br /><br /> Stan = \<bez zmian ><br /><br /> RowAction = ChangeCurrentAndOriginal|Bieżące = \<istniejących ><br /><br /> Oryginalny = \<przychodzących ><br /><br /> Stan = \<zmodyfikowane ><br /><br /> RowAction = ChangeOriginal|  
ersję usuniętą|(Ładowanie nie nie wpływają na usunięte wiersze)<br /><br /> Bieżące =---<br /><br /> Oryginalny = \<istniejących ><br /><br /> Stan = \<usunięty ><br /><br /> (Nowy wiersz został dodany o następującej charakterystyce)<br /><br /> Bieżące = \<przychodzących ><br /><br /> Oryginalny = \<niedostępne ><br /><br /> Stan = \<dodano ><br /><br /> RowAction = Dodaj|Cofanie usunięcia i<br /><br /> Bieżące = \<przychodzących ><br /><br /> Oryginalny = \<przychodzących ><br /><br /> Stan = \<bez zmian ><br /><br /> RowAction = ChangeCurrentAndOriginal|Bieżące = \<niedostępne ><br /><br /> Oryginalny = \<przychodzących ><br /><br /> Stan = \<usunięty ><br /><br /> RowAction = ChangeOriginal|  
|bez zmian|Bieżące = \<przychodzących ><br /><br /> Oryginalny = \<istniejących ><br /><br /> Jeśli nowa wartość jest taka sama jak istniejąca wartość<br /><br /> Stan = \<bez zmian ><br /><br /> RowAction = Nothing<br /><br /> else<br /><br /> Stan = \<zmodyfikowane ><br /><br /> RowAction = zmiany|Bieżące = \<przychodzących ><br /><br /> Oryginalny = \<przychodzących ><br /><br /> Stan = \<bez zmian ><br /><br /> RowAction = ChangeCurrentAndOriginal|Bieżące = \<przychodzących ><br /><br /> Oryginalny = \<przychodzących ><br /><br /> Stan = \<bez zmian ><br /><br /> RowAction = ChangeCurrentAndOriginal|  
Nie istnieje)|Bieżące = \<przychodzących ><br /><br /> Oryginalny = \<niedostępne ><br /><br /> Stan = \<dodano ><br /><br /> RowAction = Dodaj|Bieżące = \<przychodzących ><br /><br /> Oryginalny = \<przychodzących ><br /><br /> Stan = \<bez zmian ><br /><br /> RowAction = ChangeCurrentAndOriginal|Bieżące = \<przychodzących ><br /><br /> Oryginalny = \<przychodzących ><br /><br /> Stan = \<bez zmian ><br /><br /> RowAction = ChangeCurrentAndOriginal|  
  
 Wartości w <xref:System.Data.DataColumn> może być ograniczona przez użycie właściwości takich jak <xref:System.Data.DataColumn.ReadOnly%2A> i <xref:System.Data.DataColumn.AutoIncrement%2A>. `Load` Obsługiwała takich kolumn w taki sposób, który jest zgodny z zachowaniem definiowanych przez właściwości kolumny. Jedynym ograniczeniem odczytu na <xref:System.Data.DataColumn> ma zastosowanie tylko w przypadku zmiany pojawiające się w pamięci. `Load` Metody powoduje zastąpienie wartości kolumn jako tylko do odczytu, jeśli to konieczne.  
  
 Jeśli określisz OverwriteChanges lub PreserveChanges opcji podczas wywoływania `Load` metody, a następnie zakładając wykonano, że dane przychodzące pochodzi z `DataTable`firmy podstawowego źródła danych i tabeli DataTable śledzi zmiany i możesz propagować zmiany z powrotem do źródła danych. Jeśli zostanie wybrana opcja Upsert, zakłada się, pochodzą dane z jednego źródła danych dodatkowych, takich jak dane przez składnik warstwy środkowej, może być zmieniony przez użytkownika. W tym przypadku założeniem jest, celem jest z co najmniej jedno źródło danych w celu agregowania danych `DataTable`i może być propagowanie danych do podstawowego źródła danych. <xref:System.Data.LoadOption> Parametr jest używany do określania określoną wersję wiersza, który ma być używany dla porównania klucza podstawowego. Poniższa tabela zawiera szczegółowe informacje.  
  
|Opcja ładowanie|Wersji elementu DataRow używana na potrzeby porównania klucza podstawowego|  
|-----------------|-----------------------------------------------------|  
|`OverwriteChanges`|Oryginalna wersja, jeśli istnieje, w przeciwnym razie bieżąca wersja|  
|`PreserveChanges`|Oryginalna wersja, jeśli istnieje, w przeciwnym razie bieżąca wersja|  
|`Upsert`|Bieżąca wersja, jeśli istnieje, w przeciwnym razie oryginalnej wersji|  
  
 `errorHandler` Parametr <xref:System.Data.FillErrorEventHandler> delegata, która odwołuje się do procedury, która jest wywoływana, gdy wystąpi błąd podczas ładowania danych. <xref:System.Data.FillErrorEventArgs> Parametr przekazany do procedury udostępnia właściwości, które umożliwiają pobieranie informacji o błędzie, który wystąpił, bieżący wiersz danych, a <xref:System.Data.DataTable> są wypełnione. Za pomocą tego mechanizmu delegata, zamiast prostsze bloku try/catch, pozwala na ustalenie tego błędu, obsługiwać tę sytuację i kontynuować przetwarzanie, jeśli chcesz. <xref:System.Data.FillErrorEventArgs> Parametr dostarcza <xref:System.Data.FillErrorEventArgs.Continue%2A> właściwości: Ustaw tę właściwość na `true` oznacza zapewnienia obsługi błędu i kontynuować przetwarzanie. Ustaw właściwość `false` do wskazania, że chcesz zatrzymanie przetwarzania. Należy pamiętać, że ustawienie dla właściwości `false` powoduje, że kod, który wyzwolił problem, aby zgłosić wyjątek.  
  
   
  
## Examples  
 [!code-csharp[DataWorks DataTableLoad.ErrorEventHandler#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableLoad.ErrorEventHandler/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableLoad.ErrorEventHandler#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableLoad.ErrorEventHandler/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Praca ze zdarzeniami DataTable</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadDataRow">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Umożliwia znalezienie i aktualizuje konkretnego wiersza. Jeśli ma pasującego wiersza zostanie znaleziony, zostanie utworzony nowy wiersz, przy użyciu podanych wartości.</summary>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadDataRow">
      <MemberSignature Language="C#" Value="public System.Data.DataRow LoadDataRow (object[] values, bool fAcceptChanges);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow LoadDataRow(object[] values, bool fAcceptChanges) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.LoadDataRow(System.Object[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadDataRow (values As Object(), fAcceptChanges As Boolean) As DataRow" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataRow ^ LoadDataRow(cli::array &lt;System::Object ^&gt; ^ values, bool fAcceptChanges);" />
      <MemberSignature Language="F#" Value="member this.LoadDataRow : obj[] * bool -&gt; System.Data.DataRow" Usage="dataTable.LoadDataRow (values, fAcceptChanges)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Object[]" />
        <Parameter Name="fAcceptChanges" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="values">Tablica wartości użyte do utworzenia nowego wiersza.</param>
        <param name="fAcceptChanges">
          <see langword="true" /> Aby zaakceptować zmiany. w przeciwnym razie <see langword="false" />.</param>
        <summary>Umożliwia znalezienie i aktualizuje konkretnego wiersza. Jeśli ma pasującego wiersza zostanie znaleziony, zostanie utworzony nowy wiersz, przy użyciu podanych wartości.</summary>
        <returns>Nowy <see cref="T:System.Data.DataRow" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.LoadDataRow%2A> Metoda przyjmuje tablicę wartości i umożliwia znalezienie dopasowania wartości kolumn klucza podstawowego.  
  
 Jeśli kolumna ma wartość domyślną, należy przekazać wartość null w tablicy, aby ustawić wartość domyślną dla tej kolumny. Podobnie jeśli kolumna ma jego <xref:System.Data.DataColumn.AutoIncrement%2A> ustawioną na wartość true, Przekaż wartość null w tablicy, aby ustawić wartość automatycznie generowanego wiersza.  
  
 Jeśli `fAcceptChanges` parametr jest `true` lub nie jest określony, nowe dane są dodawane i następnie <xref:System.Data.DataTable.AcceptChanges%2A> jest wywoływana, aby zaakceptować wszystkie zmiany w <xref:System.Data.DataTable>; Jeśli argument jest `false`, nowo dodane wiersze są oznaczone jako wstawienia i zmiany istniejące wiersze są oznaczone jako modyfikacji.  
  
 Wyjątki może również wystąpić podczas <xref:System.Data.DataTable.ColumnChanging> lub <xref:System.Data.DataTable.RowChanging> zdarzeń. Jeśli wystąpi wyjątek, wiersz nie zostanie dodane do tabeli.  
  
 Użyj <xref:System.Data.DataTable.LoadDataRow%2A> w połączeniu z <xref:System.Data.DataTable.BeginLoadData%2A> i <xref:System.Data.DataTable.EndLoadData%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Data.DataTable.LoadDataRow%2A> metoda próbuje odnaleźć wiersza. Jeśli zostanie znaleziony żaden taki wiersz, wartości są używane do tworzenia nowego wiersza.  
  
 [!code-csharp[Classic WebData DataTable.LoadDataRow Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.LoadDataRow Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.LoadDataRow Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.LoadDataRow Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Tablica jest większa niż liczba kolumn w tabeli.</exception>
        <exception cref="T:System.InvalidCastException">Wartość nie odpowiada jego typ odpowiednich kolumn.</exception>
        <exception cref="T:System.Data.ConstraintException">Dodawanie wiersz unieważnia ograniczenie.</exception>
        <exception cref="T:System.Data.NoNullAllowedException">Podjęto próbę umieścić o wartości null w kolumnie gdzie <see cref="P:System.Data.DataColumn.AllowDBNull" /> ma wartość false.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Praca ze zdarzeniami DataTable</related>
      </Docs>
    </Member>
    <Member MemberName="LoadDataRow">
      <MemberSignature Language="C#" Value="public System.Data.DataRow LoadDataRow (object[] values, System.Data.LoadOption loadOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow LoadDataRow(object[] values, valuetype System.Data.LoadOption loadOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.LoadDataRow(System.Object[],System.Data.LoadOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataRow ^ LoadDataRow(cli::array &lt;System::Object ^&gt; ^ values, System::Data::LoadOption loadOption);" />
      <MemberSignature Language="F#" Value="member this.LoadDataRow : obj[] * System.Data.LoadOption -&gt; System.Data.DataRow" Usage="dataTable.LoadDataRow (values, loadOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Object[]" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
      </Parameters>
      <Docs>
        <param name="values">Tablica wartości użyte do utworzenia nowego wiersza.</param>
        <param name="loadOption">Używany do określenia, jak wartości tablicy są stosowane odpowiednie wartości w istniejącym wierszu.</param>
        <summary>Umożliwia znalezienie i aktualizuje konkretnego wiersza. Jeśli ma pasującego wiersza zostanie znaleziony, zostanie utworzony nowy wiersz, przy użyciu podanych wartości.</summary>
        <returns>Nowy <see cref="T:System.Data.DataRow" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.LoadDataRow%2A> Metoda przyjmuje tablicę wartości i umożliwia znalezienie dopasowania wartości kolumn klucza podstawowego.  
  
 Jeśli kolumna ma wartość domyślną, należy przekazać wartość null w tablicy, aby ustawić wartość domyślną dla tej kolumny. Podobnie jeśli kolumna ma jego <xref:System.Data.DataColumn.AutoIncrement%2A> ustawioną na wartość true, Przekaż wartość null w tablicy, aby ustawić wartość automatycznie generowanego wiersza.  
  
 Wartość `loadOption` parametr jest używany do określenia, jak wartości w tablicy są stosowane do istniejącego wiersza. Na przykład jeśli `loadOption` ustawiono `OverwriteChanges`, `Original` i `Current` wartości kolumn są zastępowane wartości w wierszu przychodzących i `RowState` właściwość jest ustawiona na `Unchanged`.  
  
 Wyjątki może również wystąpić podczas <xref:System.Data.DataTable.ColumnChanging> lub <xref:System.Data.DataTable.RowChanging> zdarzeń. Jeśli wystąpi wyjątek, wiersz nie zostanie dodane do tabeli.  
  
 Użyj <xref:System.Data.DataTable.LoadDataRow%2A> w połączeniu z <xref:System.Data.DataTable.BeginLoadData%2A> i <xref:System.Data.DataTable.EndLoadData%2A>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="Locale">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo Locale { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo Locale" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Locale" />
      <MemberSignature Language="VB.NET" Value="Public Property Locale As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ Locale { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Locale : System.Globalization.CultureInfo with get, set" Usage="System.Data.DataTable.Locale" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableLocaleDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia informacje dotyczące ustawień regionalnych używany do porównywania ciągów znaków w tabeli.</summary>
        <value>Element <see cref="T:System.Globalization.CultureInfo" /> zawierający dane dotyczące ustawień regionalnych komputera użytkownika. Wartość domyślna to <see cref="T:System.Data.DataSet" /> obiektu <see cref="T:System.Globalization.CultureInfo" /> (zwrócone przez <see cref="P:System.Data.DataSet.Locale" /> właściwość) do której <see cref="T:System.Data.DataTable" /> należy; Jeśli tabela nie należy do <see cref="T:System.Data.DataSet" />, wartością domyślną jest bieżący system <see cref="T:System.Globalization.CultureInfo" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Globalization.CultureInfo> reprezentuje preferencje oprogramowania określoną kulturę lub społeczności.  
  
 Gdy jest używana do porównywania ciągów znaków <xref:System.Globalization.CultureInfo> wpływa na porównań, sortowania i filtrowania.  
  
> [!NOTE]
>  W kolumnach, które zawierają wyrażenia <xref:System.StringComparison.InvariantCulture> jest używany. <xref:System.StringComparison.CurrentCulture> Jest ignorowana.  
  
   
  
## Examples  
 Poniższy przykład ustawia <xref:System.Globalization.CultureInfo> za pośrednictwem <xref:System.Data.DataTable.Locale%2A> i wyświetla nazwę języka ISO.  
  
 [!code-csharp[Classic WebData DataTable.Locale Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Locale Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Locale Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Locale Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Merge">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Scal określonego <see cref="T:System.Data.DataTable" /> z bieżącymi <see cref="T:System.Data.DataTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Merge` Metoda jest używana, aby scalić dwa <xref:System.Data.DataTable> obiektów, które mają w dużej mierze podobny schematów. Scalanie jest zazwyczaj używany w aplikacji klienckiej do włączenie najnowsze zmiany ze źródła danych do istniejącego <xref:System.Data.DataTable>. Dzięki temu aplikacja kliencka odświeżyć <xref:System.Data.DataTable> przy użyciu najnowszych danych ze źródła danych.  
  
 Operacja scalania bierze pod uwagę tylko oryginalnej tabeli, a tabela do scalenia. Tabele podrzędne nie dotyczy lub dołączone. Jeśli tabela zawiera tabele podrzędne, określonych w ramach relacji, można indywidualnie scalić każdej tabeli podrzędnej.  
  
   
  
## Examples  
 Następująca aplikacja konsoli demonstruje działanie `missingSchemaAction` parametru <xref:System.Data.DataTable.Merge%2A> metody. Ten przykład tworzy dwie wersje tej samej tabeli, modyfikowaniem schematu dla drugiej wersji. Następnie kod próbuje scalania w drugiej tabeli do pierwszej.  
  
> [!NOTE]
>  W tym przykładzie pokazano, jak użyć jednej z przeciążone wersje scalania. Inne przykłady, które mogą być dostępne znajduje się w tematach poszczególnych przeciążeń.  
  
 [!code-csharp[DataWorks DataTableMergeOverload#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableMergeOverload/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableMergeOverload#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableMergeOverload/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Merge(System.Data.DataTable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Merge (table As DataTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataTable ^ table);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataTable -&gt; unit" Usage="dataTable.Merge table" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
      </Parameters>
      <Docs>
        <param name="table">
          <see cref="T:System.Data.DataTable" /> Ma zostać scalona z bieżącą <see cref="T:System.Data.DataTable" />.</param>
        <summary>Scal określonego <see cref="T:System.Data.DataTable" /> z bieżącymi <see cref="T:System.Data.DataTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Merge — metoda jest używana, aby scalić dwa <xref:System.Data.DataTable> obiektów, które mają w dużej mierze podobny schematów. Scalanie jest zazwyczaj używany w aplikacji klienckiej do włączenie najnowsze zmiany ze źródła danych do istniejącego <xref:System.Data.DataTable>. Dzięki temu aplikacja kliencka odświeżyć <xref:System.Data.DataTable> przy użyciu najnowszych danych ze źródła danych.  
  
 Operacja scalania bierze pod uwagę tylko oryginalnej tabeli, a tabela do scalenia. Tabele podrzędne nie dotyczy lub dołączone. Jeśli tabela zawiera tabele podrzędne, określonych w ramach relacji, można indywidualnie scalić każdej tabeli podrzędnej.  
  
 `Merge` Metoda jest zwykle nazywany na końcu szereg procedur, które obejmują sprawdzanie poprawności zmian, uzgadnianie błędy, aktualizowanie źródła danych za pomocą zmian i na koniec odświeżanie istniejącego <xref:System.Data.DataTable>.  
  
 Podczas scalania zmian wprowadzonych do istniejących danych przed scaleniem są chronione domyślnie podczas operacji scalania. Deweloperzy można zmodyfikować tego zachowania, wywołując jedną z innych dwa przeciążenia tej metody i określając wartość false dla `preserveChanges` parametru.  
  
 W aplikacji klienckiej jest zwykle zapewnienie jednego przycisku, który użytkownik może kliknąć zbiera dane zmienione, a następnie zweryfikuje go przed wysłaniem ich do składnika warstwy środkowej. W tym scenariuszu <xref:System.Data.DataTable.GetChanges%2A> wywołaniu metody. Metoda zwraca wartość sekund <xref:System.Data.DataTable> zoptymalizowane pod kątem sprawdzania poprawności i scalania. To drugie <xref:System.Data.DataTable> obiekt zawiera tylko <xref:System.Data.DataRow> obiektów, które zostały zmienione, wynikające z podzbioru oryginalny <xref:System.Data.DataTable>. Podzbiór ten jest ogólnie mniejsze i w związku z tym wydajniej przesłany do składnika warstwy środkowej. Składnik warstwy środkowej następnie aktualizuje oryginalnego źródła danych zmian za pomocą procedur składowanych. Warstwy środkowej można wysłać kopii albo nową <xref:System.Data.DataTable> zawierającego oryginalne dane i najnowszych danych ze źródła danych (przez ponowne uruchomienie oryginalnego zapytania) lub Wyślij ponownie podzbioru ze wszystkimi zmianami, które zostały wprowadzone do niej ze źródła danych. (Na przykład, jeśli źródło danych automatycznie tworzy unikatowe wartości klucza podstawowego, te wartości mogą być propagowany z powrotem do aplikacji klienckiej.) W obu przypadkach zwrócona <xref:System.Data.DataTable> mogą być scalone oryginalny aplikacja kliencka <xref:System.Data.DataTable> z <xref:System.Data.DataTable.Merge%2A> metody.  
  
 Podczas scalania nowe źródło <xref:System.Data.DataTable> do obiektu docelowego, dowolnego źródła wierszy z <xref:System.Data.DataRowState> wartość `Unchanged`, `Modified`, lub `Deleted`, jest dopasowywany do docelowego wiersze z tej samej wartości klucza podstawowego. Wiersze ze źródła <xref:System.Data.DataRowState> wartość `Added` są dopasowywane do nowych wierszy docelowych przy użyciu tej samej wartości klucza podstawowego jako nowych wierszy źródłowych.  
  
   
  
## Examples  
 Następująca aplikacja konsoli tworzy prostą <xref:System.Data.DataTable> i dodaje dane do tabeli. Przykład tworzy następnie kopię tabeli, dodawanie wierszy do skopiowania. Na koniec przykład wywołuje <xref:System.Data.DataTable.Merge%2A> metodę, aby scalić dane w drugiej tabeli z danymi w pierwszej tabeli.  
  
 [!code-csharp[DataWorks DataTable.Merge#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.Merge/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.Merge#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.Merge/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Praca ze zdarzeniami DataTable</related>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table, bool preserveChanges);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table, bool preserveChanges) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Merge (table As DataTable, preserveChanges As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataTable ^ table, bool preserveChanges);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataTable * bool -&gt; unit" Usage="dataTable.Merge (table, preserveChanges)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="table">
          <see langword="DataTable" /> Ma zostać scalona z bieżącą <see langword="DataTable" />.</param>
        <param name="preserveChanges">
          <see langword="true" />, aby zachować zmiany w bieżącym <see langword="DataTable" />; w przeciwnym razie <see langword="false" />.</param>
        <summary>Scal określonego <see cref="T:System.Data.DataTable" /> z bieżącymi <see langword="DataTable" />, wskazującą, czy chcesz zachować zmiany w bieżącym <see langword="DataTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Merge — metoda jest używana, aby scalić dwa <xref:System.Data.DataTable> obiektów, które mają w dużej mierze podobny schematów. Scalanie jest zazwyczaj używany w aplikacji klienckiej do włączenie najnowsze zmiany ze źródła danych do istniejącego <xref:System.Data.DataTable>. Dzięki temu aplikacja kliencka odświeżyć <xref:System.Data.DataTable> przy użyciu najnowszych danych ze źródła danych.  
  
 Operacja scalania bierze pod uwagę tylko oryginalnej tabeli, a tabela do scalenia. Tabele podrzędne nie dotyczy lub dołączone. Jeśli tabela zawiera tabele podrzędne, określonych w ramach relacji, można indywidualnie scalić każdej tabeli podrzędnej.  
  
 `Merge` Metoda jest zwykle nazywany na końcu szereg procedur, które obejmują sprawdzanie poprawności zmian, uzgadnianie błędy, aktualizowanie źródła danych za pomocą zmian i na koniec odświeżanie istniejącego <xref:System.Data.DataTable>.  
  
 Podczas scalania zmian wprowadzonych do istniejących danych przed scaleniem są zachowywane podczas operacji scalania, chyba że deweloper określa wartość false dla `preserveChanges` parametru. Jeśli `preserveChanges` parametr ma wartość `true`, wartości przychodzących nie zastępuj istniejących wartości w bieżącej wersji wierszy istniejącego wiersza. Jeśli `preserveChanges` parametr ma wartość `false`, wartości przychodzących zastępuj istniejących wartości w bieżącej wersji wierszy istniejącego wiersza. Aby uzyskać więcej informacji na temat wersji wierszy, zobacz [stany wiersza i wersje wiersza](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md).  
  
 W aplikacji klienckiej jest zwykle zapewnienie jednego przycisku, który użytkownik może kliknąć zbiera dane zmienione, a następnie zweryfikuje go przed wysłaniem ich do składnika warstwy środkowej. W tym scenariuszu <xref:System.Data.DataTable.GetChanges%2A> wywołaniu metody. Metoda zwraca wartość sekund <xref:System.Data.DataTable> zoptymalizowane pod kątem sprawdzania poprawności i scalania. To drugie <xref:System.Data.DataTable> obiekt zawiera tylko <xref:System.Data.DataTable> i <xref:System.Data.DataRow> obiektów, które zostały zmienione, wynikające z podzbioru oryginalny <xref:System.Data.DataTable>. Ten podzbiór jest zwykle mniejsze, a zatem podzbiór ten jest bardziej efektywnie przekazywany z powrotem do składnika warstwy środkowej. Składnik warstwy środkowej następnie aktualizuje oryginalnego źródła danych zmian za pomocą procedur składowanych. Warstwy środkowej można wysłać kopii albo nową <xref:System.Data.DataTable> zawierającego oryginalne dane i najnowszych danych ze źródła danych (przez ponowne uruchomienie oryginalnego zapytania) lub Wyślij ponownie podzbioru ze wszystkimi zmianami, które zostały wprowadzone do niej ze źródła danych. (Na przykład, jeśli źródło danych automatycznie tworzy unikatowe wartości klucza podstawowego, te wartości mogą być propagowany z powrotem do aplikacji klienckiej.) W obu przypadkach zwrócona <xref:System.Data.DataTable> mogą być scalone oryginalny aplikacja kliencka <xref:System.Data.DataTable> z <xref:System.Data.DataTable.Merge%2A> metody.  
  
 Podczas scalania nowe źródło <xref:System.Data.DataTable> do obiektu docelowego, dowolnego źródła wierszy z <xref:System.Data.DataRowState> wartość `Unchanged`, `Modified`, lub `Deleted` są dopasowywane do docelowego wiersze z tej samej wartości klucza podstawowego. Wiersze ze źródła <xref:System.Data.DataRowState> wartość `Added` są dopasowywane do nowych wierszy docelowych przy użyciu tej samej wartości klucza podstawowego jako nowych wierszy źródłowych.  
  
   
  
## Examples  
 Tworzy następujące aplikację konsolową <xref:System.Data.DataTable> zawierająca wiersze, modyfikuje dane z tych wierszy, a próby scalać dane z innego <xref:System.Data.DataTable>. W przykładzie pokazano różne zachowania dla `preserveChanges` parametru.  
  
 [!code-csharp[DataWorks DataTable.MergePreserveChanges#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.MergePreserveChanges/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.MergePreserveChanges#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.MergePreserveChanges/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Praca ze zdarzeniami DataTable</related>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table, bool preserveChanges, System.Data.MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table, bool preserveChanges, valuetype System.Data.MissingSchemaAction missingSchemaAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataTable ^ table, bool preserveChanges, System::Data::MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="F#" Value="member this.Merge : System.Data.DataTable * bool * System.Data.MissingSchemaAction -&gt; unit" Usage="dataTable.Merge (table, preserveChanges, missingSchemaAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
        <Parameter Name="missingSchemaAction" Type="System.Data.MissingSchemaAction" />
      </Parameters>
      <Docs>
        <param name="table">
          <see cref="T:System.Data.DataTable" /> Ma zostać scalona z bieżącą <see cref="T:System.Data.DataTable" />.</param>
        <param name="preserveChanges">
          <see langword="true" />, aby zachować zmiany w bieżącym <see cref="T:System.Data.DataTable" />; w przeciwnym razie <see langword="false" />.</param>
        <param name="missingSchemaAction">Jedną z <see cref="T:System.Data.MissingSchemaAction" /> wartości.</param>
        <summary>Scal określonego <see cref="T:System.Data.DataTable" /> z bieżącymi <see langword="DataTable" />, wskazującą, czy chcesz zachować zmiany i sposób obsługi Brak schematu w bieżącym <see langword="DataTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Merge` Metoda jest używana, aby scalić dwa <xref:System.Data.DataTable> obiektów, które mają w dużej mierze podobny schematów. Scalanie jest zazwyczaj używany w aplikacji klienckiej do włączenie najnowsze zmiany ze źródła danych do istniejącego <xref:System.Data.DataTable>. Dzięki temu aplikacja kliencka odświeżyć <xref:System.Data.DataTable> przy użyciu najnowszych danych ze źródła danych.  
  
 Operacja scalania bierze pod uwagę tylko oryginalnej tabeli, a tabela do scalenia. Tabele podrzędne nie dotyczy lub dołączone. Jeśli tabela zawiera tabele podrzędne, określonych w ramach relacji, można indywidualnie scalić każdej tabeli podrzędnej.  
  
 `Merge` Metoda jest zwykle nazywany na końcu szereg procedur, które obejmują sprawdzanie poprawności zmian, uzgadnianie błędy, aktualizowanie źródła danych za pomocą zmian i na koniec odświeżanie istniejącego <xref:System.Data.DataTable>.  
  
 Podczas scalania zmian wprowadzonych do istniejących danych przed scaleniem są zachowywane podczas operacji scalania, chyba że deweloper określa wartość false dla `preserveChanges` parametru. Jeśli `preserveChanges` parametr ma wartość `true`, wartości przychodzących nie zastępuj istniejących wartości w bieżącej wersji wierszy istniejącego wiersza. Jeśli `preserveChanges` parametr ma wartość `false`, wartości przychodzących zastępuj istniejących wartości w bieżącej wersji wierszy istniejącego wiersza. Aby uzyskać więcej informacji na temat wersji wierszy, zobacz [stany wiersza i wersje wiersza](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md).  
  
 W aplikacji klienckiej jest zwykle zapewnienie jednego przycisku, który użytkownik może kliknąć zbiera dane zmienione, a następnie zweryfikuje go przed wysłaniem ich do składnika warstwy środkowej. W tym scenariuszu <xref:System.Data.DataTable.GetChanges%2A> wywołaniu metody. Metoda zwraca wartość sekund <xref:System.Data.DataTable> zoptymalizowane pod kątem sprawdzania poprawności i scalania. To drugie <xref:System.Data.DataTable> obiekt zawiera tylko <xref:System.Data.DataTable> i <xref:System.Data.DataRow> obiektów, które zostały zmienione, wynikające z podzbioru oryginalny <xref:System.Data.DataTable>. Ten podzbiór jest zwykle mniejsze, a zatem podzbiór ten jest bardziej efektywnie przekazywany z powrotem do składnika warstwy środkowej. Składnik warstwy środkowej następnie aktualizuje oryginalnego źródła danych zmian za pomocą procedur składowanych. Warstwy środkowej można wysłać kopii albo nową <xref:System.Data.DataTable> zawierającego oryginalne dane i najnowszych danych ze źródła danych (przez ponowne uruchomienie oryginalnego zapytania) lub Wyślij ponownie podzbioru ze wszystkimi zmianami, które zostały wprowadzone do niej ze źródła danych. (Na przykład, jeśli źródło danych automatycznie tworzy unikatowe wartości klucza podstawowego, te wartości mogą być propagowany z powrotem do aplikacji klienckiej.) W obu przypadkach zwrócona <xref:System.Data.DataTable> mogą być scalone oryginalny aplikacja kliencka <xref:System.Data.DataTable> z <xref:System.Data.DataTable.Merge%2A> metody.  
  
 Gdy <xref:System.Data.DataTable.Merge%2A> metoda jest wywoływana, schematy dwa <xref:System.Data.DataTable> obiekty są porównywane, ponieważ istnieje możliwość, że schematy mogły zostać zmienione. Na przykład w scenariuszu business-to-business, nowych kolumn może zostały dodane do schematu XML przez zautomatyzowany proces. Jeśli źródło <xref:System.Data.DataTable> zawiera elementy schematu (dodano <xref:System.Data.DataColumn> obiektów) Brak w elemencie docelowym, elementy schematu można dodać do obiektu docelowego, ustawiając `missingSchemaAction` argument `MissingSchemaAction.Add`. W takim przypadku scalonych <xref:System.Data.DataTable> zawiera dodano schemat i dane.  
  
 Po scaleniu schematów, dane są scalane.  
  
 Podczas scalania nowe źródło <xref:System.Data.DataTable> do obiektu docelowego, dowolnego źródła wierszy z <xref:System.Data.DataRowState> wartość `Unchanged`, `Modified`, lub `Deleted` są dopasowywane do docelowego wiersze z tej samej wartości klucza podstawowego. Wiersze ze źródła <xref:System.Data.DataRowState> wartość `Added` są dopasowywane do nowych wierszy docelowych przy użyciu tej samej wartości klucza podstawowego jako nowych wierszy źródłowych.  
  
   
  
## Examples  
 Następująca aplikacja konsoli demonstruje działanie `missingSchemaAction` parametru <xref:System.Data.DataTable.Merge%2A> metody. Ten przykład tworzy dwie wersje tej samej tabeli, modyfikowaniem schematu dla drugiej wersji. Następnie kod próbuje scalania w drugiej tabeli do pierwszej.  
  
 [!code-csharp[DataWorks DataTable.MergeMissingSchemaAction#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.MergeMissingSchemaAction/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.MergeMissingSchemaAction#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.MergeMissingSchemaAction/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Praca ze zdarzeniami DataTable</related>
      </Docs>
    </Member>
    <Member MemberName="MinimumCapacity">
      <MemberSignature Language="C#" Value="public int MinimumCapacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MinimumCapacity" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.MinimumCapacity" />
      <MemberSignature Language="VB.NET" Value="Public Property MinimumCapacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MinimumCapacity { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MinimumCapacity : int with get, set" Usage="System.Data.DataTable.MinimumCapacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DefaultValue(50)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableMinimumCapacityDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia początkowy rozmiar dla tej tabeli.</summary>
        <value>Początkowy rozmiar początkowy w wiersze tej tabeli. Wartością domyślną jest 50.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.MinimumCapacity%2A> Umożliwia systemowi Utwórz odpowiedni zestaw zasobów przed pobieranie danych. W sytuacji, gdy wydajność ma kluczowe znaczenie, ustawienie tej właściwości można zoptymalizować wydajność.  
  
   
  
## Examples  
 Poniższy przykład ustawia <xref:System.Data.DataTable.MinimumCapacity%2A> z <xref:System.Data.DataTable>.  
  
 [!code-csharp[Classic WebData DataTable.MinimumCapacity Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.MinimumCapacity Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.MinimumCapacity Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.MinimumCapacity Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public string Namespace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Namespace { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string with get, set" Usage="System.Data.DataTable.Namespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableNamespaceDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia obszar nazw dla Reprezentacja XML danych przechowywanych w <see cref="T:System.Data.DataTable" />.</summary>
        <value>Przestrzeń nazw <see cref="T:System.Data.DataTable" />.</value>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="NewRow">
      <MemberSignature Language="C#" Value="public System.Data.DataRow NewRow ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow NewRow() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.NewRow" />
      <MemberSignature Language="VB.NET" Value="Public Function NewRow () As DataRow" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataRow ^ NewRow();" />
      <MemberSignature Language="F#" Value="member this.NewRow : unit -&gt; System.Data.DataRow" Usage="dataTable.NewRow " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy nową <see cref="T:System.Data.DataRow" /> za pomocą tego samego schematu jako tabela.</summary>
        <returns>A <see cref="T:System.Data.DataRow" /> przy użyciu tego samego schematu jako <see cref="T:System.Data.DataTable" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy użyć <xref:System.Data.DataTable.NewRow%2A> metody, aby utworzyć nowy element <xref:System.Data.DataRow> obiektów przy użyciu tego samego schematu jako <xref:System.Data.DataTable>. Po utworzeniu <xref:System.Data.DataRow>, możesz dodać go do <xref:System.Data.DataRowCollection>za pośrednictwem <xref:System.Data.DataTable> obiektu <xref:System.Data.DataTable.Rows%2A> właściwości. Kiedy używasz <xref:System.Data.DataTable.NewRow%2A> do tworzenia nowych wierszy, wiersze musi zostać dodane do lub usunięte z tabeli danych, przed wywołaniem <xref:System.Data.DataTable.Clear%2A>.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Data.DataTable>, dodaje dwa <xref:System.Data.DataColumn> obiektów, które ustalić schemat tabeli, a następnie tworzy kilka nowych <xref:System.Data.DataRow> obiektów przy użyciu <xref:System.Data.DataTable.NewRow%2A> metody. Te <xref:System.Data.DataRow> obiekty zostaną następnie dodane do <xref:System.Data.DataRowCollection> przy użyciu <xref:System.Data.DataRowCollection.Add%2A> metody.  
  
 [!code-csharp[Classic WebData DataTable.NewRow Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.NewRow Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.NewRow Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.NewRow Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Praca ze zdarzeniami DataTable</related>
      </Docs>
    </Member>
    <Member MemberName="NewRowArray">
      <MemberSignature Language="C#" Value="protected internal System.Data.DataRow[] NewRowArray (int size);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance class System.Data.DataRow[] NewRowArray(int32 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.NewRowArray(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function NewRowArray (size As Integer) As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ NewRowArray(int size);" />
      <MemberSignature Language="F#" Value="member this.NewRowArray : int -&gt; System.Data.DataRow[]" Usage="dataTable.NewRowArray size" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="size">A <see cref="T:System.Int32" /> wartość, która opisuje rozmiar tablicy.</param>
        <summary>Zwraca tablicę <see cref="T:System.Data.DataRow" />.</summary>
        <returns>Nowej tablicy.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NewRowFromBuilder">
      <MemberSignature Language="C#" Value="protected virtual System.Data.DataRow NewRowFromBuilder (System.Data.DataRowBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Data.DataRow NewRowFromBuilder(class System.Data.DataRowBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.NewRowFromBuilder(System.Data.DataRowBuilder)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function NewRowFromBuilder (builder As DataRowBuilder) As DataRow" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Data::DataRow ^ NewRowFromBuilder(System::Data::DataRowBuilder ^ builder);" />
      <MemberSignature Language="F#" Value="abstract member NewRowFromBuilder : System.Data.DataRowBuilder -&gt; System.Data.DataRow&#xA;override this.NewRowFromBuilder : System.Data.DataRowBuilder -&gt; System.Data.DataRow" Usage="dataTable.NewRowFromBuilder builder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Data.DataRowBuilder" />
      </Parameters>
      <Docs>
        <param name="builder">Element <see cref="T:System.Data.DataRowBuilder" /> obiektu.</param>
        <summary>Tworzy nowy wiersz na podstawie istniejącego wiersza.</summary>
        <returns>Element <see cref="T:System.Data.DataRow" /> klasy pochodnej.</returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="OnColumnChanged">
      <MemberSignature Language="C#" Value="protected internal virtual void OnColumnChanged (System.Data.DataColumnChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnColumnChanged(class System.Data.DataColumnChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnColumnChanged(System.Data.DataColumnChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnColumnChanged (e As DataColumnChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnColumnChanged(System::Data::DataColumnChangeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnColumnChanged : System.Data.DataColumnChangeEventArgs -&gt; unit&#xA;override this.OnColumnChanged : System.Data.DataColumnChangeEventArgs -&gt; unit" Usage="dataTable.OnColumnChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataColumnChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Element <see cref="T:System.Data.DataColumnChangeEventArgs" /> zawierający dane zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.Data.DataTable.ColumnChanged" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać przegląd, zobacz [Handling and Raising Events](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Podczas zastępowania <see cref="M:System.Data.DataTable.OnColumnChanged(System.Data.DataColumnChangeEventArgs)" /> w klasie pochodnej, pamiętaj wywołać klasy bazowej <see cref="M:System.Data.DataTable.OnColumnChanged(System.Data.DataColumnChangeEventArgs)" /> metody.</para>
        </block>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Praca ze zdarzeniami DataTable</related>
      </Docs>
    </Member>
    <Member MemberName="OnColumnChanging">
      <MemberSignature Language="C#" Value="protected internal virtual void OnColumnChanging (System.Data.DataColumnChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnColumnChanging(class System.Data.DataColumnChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnColumnChanging(System.Data.DataColumnChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnColumnChanging (e As DataColumnChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnColumnChanging(System::Data::DataColumnChangeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnColumnChanging : System.Data.DataColumnChangeEventArgs -&gt; unit&#xA;override this.OnColumnChanging : System.Data.DataColumnChangeEventArgs -&gt; unit" Usage="dataTable.OnColumnChanging e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataColumnChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Element <see cref="T:System.Data.DataColumnChangeEventArgs" /> zawierający dane zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.Data.DataTable.ColumnChanging" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać przegląd, zobacz [Handling and Raising Events](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Podczas zastępowania <see cref="M:System.Data.DataTable.OnColumnChanging(System.Data.DataColumnChangeEventArgs)" /> w klasie pochodnej, pamiętaj wywołać klasy bazowej <see cref="M:System.Data.DataTable.OnColumnChanging(System.Data.DataColumnChangeEventArgs)" /> metody.</para>
        </block>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Praca ze zdarzeniami DataTable</related>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnPropertyChanging (System.ComponentModel.PropertyChangedEventArgs pcevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPropertyChanging(class System.ComponentModel.PropertyChangedEventArgs pcevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPropertyChanging (pcevent As PropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPropertyChanging(System::ComponentModel::PropertyChangedEventArgs ^ pcevent);" />
      <MemberSignature Language="F#" Value="abstract member OnPropertyChanging : System.ComponentModel.PropertyChangedEventArgs -&gt; unit&#xA;override this.OnPropertyChanging : System.ComponentModel.PropertyChangedEventArgs -&gt; unit" Usage="dataTable.OnPropertyChanging pcevent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcevent" Type="System.ComponentModel.PropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="pcevent">Element <see cref="T:System.ComponentModel.PropertyChangedEventArgs" /> zawierający dane zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać przegląd, zobacz [Handling and Raising Events](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Podczas zastępowania <see cref="M:System.Data.DataTable.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" /> w klasie pochodnej, pamiętaj wywołać klasy bazowej <see cref="M:System.Data.DataTable.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" /> metody.</para>
        </block>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Praca ze zdarzeniami DataTable</related>
      </Docs>
    </Member>
    <Member MemberName="OnRemoveColumn">
      <MemberSignature Language="C#" Value="protected virtual void OnRemoveColumn (System.Data.DataColumn column);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRemoveColumn(class System.Data.DataColumn column) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRemoveColumn(System.Data.DataColumn)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRemoveColumn (column As DataColumn)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRemoveColumn(System::Data::DataColumn ^ column);" />
      <MemberSignature Language="F#" Value="abstract member OnRemoveColumn : System.Data.DataColumn -&gt; unit&#xA;override this.OnRemoveColumn : System.Data.DataColumn -&gt; unit" Usage="dataTable.OnRemoveColumn column" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="column" Type="System.Data.DataColumn" />
      </Parameters>
      <Docs>
        <param name="column">
          <see cref="T:System.Data.DataColumn" /> Usuwany.</param>
        <summary>Powiadamia <see cref="T:System.Data.DataTable" /> , <see cref="T:System.Data.DataColumn" /> jest usuwana.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Handling and Raising Events](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Podczas zastępowania <see cref="M:System.Data.DataTable.OnRemoveColumn(System.Data.DataColumn)" /> w klasie pochodnej, pamiętaj wywołać klasy bazowej <see cref="M:System.Data.DataTable.OnRemoveColumn(System.Data.DataColumn)" /> metody.</para>
        </block>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Praca ze zdarzeniami DataTable</related>
      </Docs>
    </Member>
    <Member MemberName="OnRowChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnRowChanged (System.Data.DataRowChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowChanged(class System.Data.DataRowChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRowChanged(System.Data.DataRowChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRowChanged (e As DataRowChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRowChanged(System::Data::DataRowChangeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnRowChanged : System.Data.DataRowChangeEventArgs -&gt; unit&#xA;override this.OnRowChanged : System.Data.DataRowChangeEventArgs -&gt; unit" Usage="dataTable.OnRowChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataRowChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Element <see cref="T:System.Data.DataRowChangeEventArgs" /> zawierający dane zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.Data.DataTable.RowChanged" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać przegląd, zobacz [Handling and Raising Events](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Podczas zastępowania <see cref="M:System.Data.DataTable.OnRowChanged(System.Data.DataRowChangeEventArgs)" /> w klasie pochodnej, pamiętaj wywołać klasy bazowej <see cref="M:System.Data.DataTable.OnRowChanged(System.Data.DataRowChangeEventArgs)" /> metody.</para>
        </block>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Praca ze zdarzeniami DataTable</related>
      </Docs>
    </Member>
    <Member MemberName="OnRowChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnRowChanging (System.Data.DataRowChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowChanging(class System.Data.DataRowChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRowChanging(System.Data.DataRowChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRowChanging (e As DataRowChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRowChanging(System::Data::DataRowChangeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnRowChanging : System.Data.DataRowChangeEventArgs -&gt; unit&#xA;override this.OnRowChanging : System.Data.DataRowChangeEventArgs -&gt; unit" Usage="dataTable.OnRowChanging e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataRowChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Element <see cref="T:System.Data.DataRowChangeEventArgs" /> zawierający dane zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.Data.DataTable.RowChanging" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać przegląd, zobacz [Handling and Raising Events](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Podczas zastępowania <see cref="M:System.Data.DataTable.OnRowChanging(System.Data.DataRowChangeEventArgs)" /> w klasie pochodnej, pamiętaj wywołać klasy bazowej <see cref="M:System.Data.DataTable.OnRowChanging(System.Data.DataRowChangeEventArgs)" /> metody.</para>
        </block>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Praca ze zdarzeniami DataTable</related>
      </Docs>
    </Member>
    <Member MemberName="OnRowDeleted">
      <MemberSignature Language="C#" Value="protected virtual void OnRowDeleted (System.Data.DataRowChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowDeleted(class System.Data.DataRowChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRowDeleted(System.Data.DataRowChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRowDeleted (e As DataRowChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRowDeleted(System::Data::DataRowChangeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnRowDeleted : System.Data.DataRowChangeEventArgs -&gt; unit&#xA;override this.OnRowDeleted : System.Data.DataRowChangeEventArgs -&gt; unit" Usage="dataTable.OnRowDeleted e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataRowChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Element <see cref="T:System.Data.DataRowChangeEventArgs" /> zawierający dane zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.Data.DataTable.RowDeleted" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać przegląd, zobacz [Handling and Raising Events](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Podczas zastępowania <see cref="M:System.Data.DataTable.OnRowDeleted(System.Data.DataRowChangeEventArgs)" /> w klasie pochodnej, pamiętaj wywołać klasy bazowej <see cref="M:System.Data.DataTable.OnRowDeleted(System.Data.DataRowChangeEventArgs)" /> metody.</para>
        </block>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Praca ze zdarzeniami DataTable</related>
      </Docs>
    </Member>
    <Member MemberName="OnRowDeleting">
      <MemberSignature Language="C#" Value="protected virtual void OnRowDeleting (System.Data.DataRowChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowDeleting(class System.Data.DataRowChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRowDeleting(System.Data.DataRowChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRowDeleting (e As DataRowChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRowDeleting(System::Data::DataRowChangeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnRowDeleting : System.Data.DataRowChangeEventArgs -&gt; unit&#xA;override this.OnRowDeleting : System.Data.DataRowChangeEventArgs -&gt; unit" Usage="dataTable.OnRowDeleting e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataRowChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Element <see cref="T:System.Data.DataRowChangeEventArgs" /> zawierający dane zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.Data.DataTable.RowDeleting" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać przegląd, zobacz [Handling and Raising Events](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Podczas zastępowania <see cref="M:System.Data.DataTable.OnRowDeleting(System.Data.DataRowChangeEventArgs)" /> w klasie pochodnej, pamiętaj wywołać klasy bazowej <see cref="M:System.Data.DataTable.OnRowDeleting(System.Data.DataRowChangeEventArgs)" /> metody.</para>
        </block>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Praca ze zdarzeniami DataTable</related>
      </Docs>
    </Member>
    <Member MemberName="OnTableCleared">
      <MemberSignature Language="C#" Value="protected virtual void OnTableCleared (System.Data.DataTableClearEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTableCleared(class System.Data.DataTableClearEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnTableCleared(System.Data.DataTableClearEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTableCleared (e As DataTableClearEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTableCleared(System::Data::DataTableClearEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTableCleared : System.Data.DataTableClearEventArgs -&gt; unit&#xA;override this.OnTableCleared : System.Data.DataTableClearEventArgs -&gt; unit" Usage="dataTable.OnTableCleared e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataTableClearEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Element <see cref="T:System.Data.DataTableClearEventArgs" /> zawierający dane zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.Data.DataTable.TableCleared" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołuje <xref:System.Data.DataTable.TableCleared> zdarzenie, które jest uruchamiany natychmiast po zakończeniu wszystkie wiersze zostały pomyślnie wyczyszczone lecz przed <xref:System.Data.DataTable.Clear%2A> metoda zwraca sterowanie do obiektu wywołującego.  
  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać przegląd, zobacz [Handling and Raising Events](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Praca ze zdarzeniami DataTable</related>
      </Docs>
    </Member>
    <Member MemberName="OnTableClearing">
      <MemberSignature Language="C#" Value="protected virtual void OnTableClearing (System.Data.DataTableClearEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTableClearing(class System.Data.DataTableClearEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnTableClearing(System.Data.DataTableClearEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTableClearing (e As DataTableClearEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTableClearing(System::Data::DataTableClearEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTableClearing : System.Data.DataTableClearEventArgs -&gt; unit&#xA;override this.OnTableClearing : System.Data.DataTableClearEventArgs -&gt; unit" Usage="dataTable.OnTableClearing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataTableClearEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Element <see cref="T:System.Data.DataTableClearEventArgs" /> zawierający dane zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.Data.DataTable.TableClearing" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołuje <xref:System.Data.DataTable.TableClearing> zdarzenie, które jest wywoływane przed przetwarzania <xref:System.Data.DataTable.Clear%2A> rozpoczęciu operacji.  
  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać przegląd, zobacz [Handling and Raising Events](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Praca ze zdarzeniami DataTable</related>
      </Docs>
    </Member>
    <Member MemberName="OnTableNewRow">
      <MemberSignature Language="C#" Value="protected virtual void OnTableNewRow (System.Data.DataTableNewRowEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTableNewRow(class System.Data.DataTableNewRowEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnTableNewRow(System.Data.DataTableNewRowEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTableNewRow (e As DataTableNewRowEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTableNewRow(System::Data::DataTableNewRowEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTableNewRow : System.Data.DataTableNewRowEventArgs -&gt; unit&#xA;override this.OnTableNewRow : System.Data.DataTableNewRowEventArgs -&gt; unit" Usage="dataTable.OnTableNewRow e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataTableNewRowEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Element <see cref="T:System.Data.DataTableNewRowEventArgs" /> zawierający dane zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.Data.DataTable.TableNewRow" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołuje <xref:System.Data.DataTable.TableNewRow> zdarzenie, które uruchamia się po nową <xref:System.Data.DataRow> została utworzona przy użyciu <xref:System.Data.DataTable.NewRow%2A>.  
  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać przegląd, zobacz [Handling and Raising Events](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Praca ze zdarzeniami DataTable</related>
      </Docs>
    </Member>
    <Member MemberName="ParentRelations">
      <MemberSignature Language="C#" Value="public System.Data.DataRelationCollection ParentRelations { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataRelationCollection ParentRelations" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.ParentRelations" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ParentRelations As DataRelationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataRelationCollection ^ ParentRelations { System::Data::DataRelationCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ParentRelations : System.Data.DataRelationCollection" Usage="System.Data.DataTable.ParentRelations" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableParentRelationsDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRelationCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję relacji nadrzędny tego <see cref="T:System.Data.DataTable" />.</summary>
        <value>Element <see cref="T:System.Data.DataRelationCollection" /> zawiera relacji nadrzędny dla tabeli. Pusta kolekcja jest zwracany, jeśli nie <see cref="T:System.Data.DataRelation" /> istnieją obiekty.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Data.DataTable.ParentRelations%2A> właściwości do zwrócenia z każdym elementem nadrzędnym <xref:System.Data.DataRelation> w <xref:System.Data.DataTable>. Każda relacja jest następnie używana jako argument w <xref:System.Data.DataRow.GetParentRows%2A> metody <xref:System.Data.DataRow> aby zwracało tablicę wierszy. Wartość każdej kolumny w tym wierszu jest następnie wydrukowany.  
  
 [!code-csharp[Classic WebData DataTable.ParentRelations Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ParentRelations Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ParentRelations Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ParentRelations Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.ChildRelations" />
        <altmember cref="T:System.Data.DataRelation" />
        <altmember cref="T:System.Data.DataSet" />
        <altmember cref="P:System.Data.DataSet.Relations" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="Prefix">
      <MemberSignature Language="C#" Value="public string Prefix { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Prefix" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Prefix" />
      <MemberSignature Language="VB.NET" Value="Public Property Prefix As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Prefix { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Prefix : string with get, set" Usage="System.Data.DataTable.Prefix" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTablePrefixDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia obszar nazw dla Reprezentacja XML danych przechowywanych w <see cref="T:System.Data.DataTable" />.</summary>
        <value>Prefiks <see cref="T:System.Data.DataTable" />.</value>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="PrimaryKey">
      <MemberSignature Language="C#" Value="public System.Data.DataColumn[] PrimaryKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataColumn[] PrimaryKey" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.PrimaryKey" />
      <MemberSignature Language="VB.NET" Value="Public Property PrimaryKey As DataColumn()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Data::DataColumn ^&gt; ^ PrimaryKey { cli::array &lt;System::Data::DataColumn ^&gt; ^ get(); void set(cli::array &lt;System::Data::DataColumn ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PrimaryKey : System.Data.DataColumn[] with get, set" Usage="System.Data.DataTable.PrimaryKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.PrimaryKeyEditor, Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Data.PrimaryKeyTypeConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.PrimaryKeyEditor, Microsoft.VSDesigner, Version=7.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTablePrimaryKeyDescr")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.PrimaryKeyEditor, Microsoft.VSDesigner, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.PrimaryKeyEditor, Microsoft.VSDesigner, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.PrimaryKeyEditor, Microsoft.VSDesigner, Version=9.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.5.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataColumn[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia tablicę kolumn tej funkcji jako kluczy podstawowych w tabeli danych.</summary>
        <value>Tablica <see cref="T:System.Data.DataColumn" /> obiektów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klucz podstawowy tabeli musi być unikatowa do identyfikowania rekordu w tabeli. Użytkownik może również zawierać tabelę z kluczem podstawowym składają się z dwóch lub większej liczby kolumn. Dzieje się tak w przypadku zaznaczenia jednej kolumny nie może zawierać wystarczającą ilość unikatowe wartości. Na przykład dwóch kolumn klucza podstawowego może składać się z kolumny "FirstName" i "LastName". Ponieważ klucze podstawowe może składać się z więcej niż jedną kolumnę <xref:System.Data.DataTable.PrimaryKey%2A> właściwość składa się z tablicy <xref:System.Data.DataColumn> obiektów.  
  
   
  
## Examples  
 Pierwszy przykład przedstawia sposób zwrócenia kolumny klucza podstawowego dla <xref:System.Data.DataTable> wyświetlane w `DataGrid`. Drugi przykład pokazuje, jak ustawić kolumny klucza podstawowego dla <xref:System.Data.DataTable>.  
  
 [!code-csharp[Classic WebData DataTable.PrimaryKey Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.PrimaryKey Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.PrimaryKey Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.PrimaryKey Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.DataException">Klucz jest kluczem obcym.</exception>
        <altmember cref="T:System.Data.DataColumn" />
        <altmember cref="P:System.Data.DataTable.PrimaryKey" />
        <altmember cref="T:System.Data.DataColumnCollection" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadXml">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Odczytuje schemat XML i dane <see cref="T:System.Data.DataTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.ReadXml%2A> Metoda zapewnia sposób odczytać tylko dane lub zarówno danych i schemat w <xref:System.Data.DataTable> z dokumentu XML, natomiast <xref:System.Data.DataTable.ReadXmlSchema%2A> metoda odczytuje tylko schemat. Do odczytywania danych i schemat, użyj jednej z `ReadXML` przeciążenia, które zawierają `XmlReadMode` parametru i ustawić jej wartość na `ReadSchema`.  
  
 Należy pamiętać, że dotyczy to także <xref:System.Data.DataTable.WriteXml%2A> i <xref:System.Data.DataTable.WriteXmlSchema%2A> metod, odpowiednio. Aby zapisać dane XML, lub schemat i dane z `DataTable`, użyj `WriteXml` metody. Aby zapisać sam schemat, należy użyć `WriteXmlSchema` metody.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Zostanie zgłoszony, jeśli typ kolumny w `DataRow` trwa od zapisu lub odczytu implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> implementuje <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Data.DataSet.ReadXml" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXml(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.IO.Stream -&gt; System.Data.XmlReadMode" Usage="dataTable.ReadXml stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Obiekt, który pochodzi od klasy <see cref="T:System.IO.Stream" /></param>
        <summary>Odczytuje schemat XML i dane <see cref="T:System.Data.DataTable" /> przy użyciu określonego <see cref="T:System.IO.Stream" />.</summary>
        <returns>
          <see cref="T:System.Data.XmlReadMode" /> Używane do odczytywania danych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bieżący <xref:System.Data.DataTable> i jego elementy potomne są ładowane przy użyciu danych z podanym <xref:System.IO.Stream>. Zachowanie tej metody jest taka sama jak w przypadku <xref:System.Data.DataSet.ReadXml%2A?displayProperty=nameWithType> metody, z wyjątkiem danych oznacza w tym przypadku jest załadowany tylko dla bieżącej tabeli i jego elementy podrzędne.  
  
 <xref:System.Data.DataTable.ReadXml%2A> Metoda zapewnia sposób odczytać tylko dane lub zarówno danych i schemat w <xref:System.Data.DataTable> z dokumentu XML, natomiast <xref:System.Data.DataTable.ReadXmlSchema%2A> metoda odczytuje tylko schemat.  
  
 Należy pamiętać, że dotyczy to także <xref:System.Data.DataTable.WriteXml%2A> i <xref:System.Data.DataTable.WriteXmlSchema%2A> metod, odpowiednio. Aby zapisać dane XML, lub schemat i dane z `DataTable`, użyj `WriteXml` metody. Aby zapisać sam schemat, należy użyć `WriteXmlSchema` metody.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Zostanie zgłoszony, jeśli typ kolumny w `DataRow` trwa od zapisu lub odczytu implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> implementuje <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Jeśli określono schemat w tekście, schemat w tekście jest używany rozszerzyć istniejącą strukturę relacyjnej przed załadowaniem danych. Jeśli występują konflikty (na przykład tej samej kolumny w tej samej tabeli, które są zdefiniowane przy użyciu różnych typów danych), zgłaszany jest wyjątek.  
  
 Jeśli jest określony żaden schemat w tekście, relacyjnej struktury został rozszerzony za pomocą wnioskowania, odpowiednio do potrzeb zgodnie z strukturę dokumentu XML. Jeśli schemat nie można rozszerzyć za pośrednictwem wnioskowania, aby udostępnić wszystkie dane, zgłaszany jest wyjątek.  
  
> [!NOTE]
>  `DataSet` Nie kojarzy — element XML z odpowiadającymi mu dostawcami `DataColumn` lub `DataTable` po prawne znaków XML, takich jak ("_") będą miały zmienione znaczenie w serializacji XML. `DataSet` Tylko specjalne niedozwolone znaki XML w nazwach elementów XML i dlatego mogą korzystać tylko takie same. Gdy prawidłowe znaki w nazwie elementu XML są poprzedzone znakiem zmiany znaczenia, element jest ignorowany podczas przetwarzania.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Data.DataTable> zawierającą dwie kolumny i dziesięć wierszy. W przykładzie polecenie zapisuje <xref:System.Data.DataTable> schemat i dane do strumienia pamięci, wywołując <xref:System.Data.DataTable.WriteXml%2A> metody. W przykładzie jest tworzony drugi <xref:System.Data.DataTable> i wywołuje <xref:System.Data.DataTable.ReadXml%2A> metodę, aby wypełnić go schemat i dane.  
  
 [!code-csharp[DataWorks DataTable.ReadXml#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXml/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXml#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXml/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.TextReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.TextReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXml(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As TextReader) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::TextReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.IO.TextReader -&gt; System.Data.XmlReadMode" Usage="dataTable.ReadXml reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.IO.TextReader" /> Który będzie używany do odczytywania danych.</param>
        <summary>Odczytuje schemat XML i dane <see cref="T:System.Data.DataTable" /> przy użyciu określonego <see cref="T:System.IO.TextReader" />.</summary>
        <returns>
          <see cref="T:System.Data.XmlReadMode" /> Używane do odczytywania danych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bieżący <xref:System.Data.DataTable> i jego elementy potomne są ładowane przy użyciu danych z podanym <xref:System.IO.TextReader>. Zachowanie tej metody jest taka sama jak w przypadku <xref:System.Data.DataSet.ReadXml%2A?displayProperty=nameWithType> metody, z wyjątkiem danych oznacza w tym przypadku jest załadowany tylko dla bieżącej tabeli i jego elementy podrzędne.  
  
 <xref:System.Data.DataTable.ReadXml%2A> Metoda zapewnia sposób odczytać tylko dane lub zarówno danych i schemat w <xref:System.Data.DataTable> z dokumentu XML, natomiast <xref:System.Data.DataTable.ReadXmlSchema%2A> metoda odczytuje tylko schemat.  
  
 Należy pamiętać, że dotyczy to także <xref:System.Data.DataTable.WriteXml%2A> i <xref:System.Data.DataTable.WriteXmlSchema%2A> metod, odpowiednio. Aby zapisać dane XML, lub schemat i dane z `DataTable`, użyj `WriteXml` metody. Aby zapisać sam schemat, należy użyć `WriteXmlSchema` metody.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Zostanie zgłoszony, jeśli typ kolumny w `DataRow` trwa od zapisu lub odczytu implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> implementuje <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Jeśli określono schemat w tekście, schemat w tekście jest używany rozszerzyć istniejącą strukturę relacyjnej przed załadowaniem danych. Jeśli występują konflikty (na przykład tej samej kolumny w tej samej tabeli, które są zdefiniowane przy użyciu różnych typów danych), zgłaszany jest wyjątek.  
  
 Jeśli jest określony żaden schemat w tekście, relacyjnej struktury został rozszerzony za pomocą wnioskowania, odpowiednio do potrzeb zgodnie z strukturę dokumentu XML. Jeśli schemat nie można rozszerzyć za pośrednictwem wnioskowania, aby udostępnić wszystkie dane, zgłaszany jest wyjątek.  
  
> [!NOTE]
>  `DataSet` Nie kojarzy — element XML z odpowiadającymi mu dostawcami `DataColumn` lub `DataTable` po prawne znaków XML, takich jak ("_") będą miały zmienione znaczenie w serializacji XML. `DataSet` Tylko specjalne niedozwolone znaki XML w nazwach elementów XML i dlatego mogą korzystać tylko takie same. Gdy prawidłowe znaki w nazwie elementu XML są poprzedzone znakiem zmiany znaczenia, element jest ignorowany podczas przetwarzania.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Data.DataTable> zawierającą dwie kolumny i dziesięć wierszy. W przykładzie polecenie zapisuje <xref:System.Data.DataTable> schemat i dane do strumienia pamięci, wywołując <xref:System.Data.DataTable.WriteXml%2A> metody. W przykładzie jest tworzony drugi <xref:System.Data.DataTable> i wywołuje <xref:System.Data.DataTable.ReadXml%2A> metodę, aby wypełnić go schemat i dane.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlText#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlText/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlText#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlText/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXml(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (fileName As String) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : string -&gt; System.Data.XmlReadMode" Usage="dataTable.ReadXml fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nazwa pliku, z którego można odczytać danych.</param>
        <summary>Odczytuje schemat XML i dane <see cref="T:System.Data.DataTable" /> z określonego pliku.</summary>
        <returns>
          <see cref="T:System.Data.XmlReadMode" /> Używane do odczytywania danych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bieżący <xref:System.Data.DataTable> i jego elementy potomne są ładowane przy użyciu danych z pliku o nazwie w podanym <xref:System.String>. Zachowanie tej metody jest taka sama jak w przypadku <xref:System.Data.DataSet.ReadXml%2A?displayProperty=nameWithType> metody, z wyjątkiem danych oznacza w tym przypadku jest załadowany tylko dla bieżącej tabeli i jego elementy podrzędne.  
  
 <xref:System.Data.DataTable.ReadXml%2A> Metoda zapewnia sposób odczytać tylko dane lub zarówno danych i schemat w <xref:System.Data.DataTable> z dokumentu XML, natomiast <xref:System.Data.DataTable.ReadXmlSchema%2A> metoda odczytuje tylko schemat.  
  
 Należy pamiętać, że dotyczy to także <xref:System.Data.DataTable.WriteXml%2A> i <xref:System.Data.DataTable.WriteXmlSchema%2A> metod, odpowiednio. Aby zapisać dane XML, lub schemat i dane z `DataTable`, użyj `WriteXml` metody. Aby zapisać sam schemat, należy użyć `WriteXmlSchema` metody.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Zostanie zgłoszony, jeśli typ kolumny w `DataRow` trwa od zapisu lub odczytu implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> implementuje <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Jeśli określono schemat w tekście, schemat w tekście jest używany rozszerzyć istniejącą strukturę relacyjnej przed załadowaniem danych. Jeśli występują konflikty (na przykład tej samej kolumny w tej samej tabeli, które są zdefiniowane przy użyciu różnych typów danych), zgłaszany jest wyjątek.  
  
 Jeśli jest określony żaden schemat w tekście, relacyjnej struktury został rozszerzony za pomocą wnioskowania, odpowiednio do potrzeb zgodnie z strukturę dokumentu XML. Jeśli schemat nie można rozszerzyć za pośrednictwem wnioskowania, aby udostępnić wszystkie dane, zgłaszany jest wyjątek.  
  
> [!NOTE]
>  `DataSet` Nie kojarzy — element XML z odpowiadającymi mu dostawcami `DataColumn` lub `DataTable` po prawne znaków XML, takich jak ("_") będą miały zmienione znaczenie w serializacji XML. `DataSet` Tylko specjalne niedozwolone znaki XML w nazwach elementów XML i dlatego mogą korzystać tylko takie same. Gdy prawidłowe znaki w nazwie elementu XML są poprzedzone znakiem zmiany znaczenia, element jest ignorowany podczas przetwarzania.  
  
```csharp  
using System.Data;  
public class A {  
   static void Main(string[] args) {  
      DataTable tabl = new DataTable("mytable");  
      tabl.Columns.Add(new DataColumn("id", typeof(int)));  
      for (int i = 0; i < 10; i++) {  
         DataRow row = tabl.NewRow();  
         row["id"] = i;  
         tabl.Rows.Add(row);  
      }  
      tabl.WriteXml("f.xml", XmlWriteMode.WriteSchema);  
      DataTable newt = new DataTable();  
      newt.ReadXml("f.xml");  
   }  
}  
```  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Data.DataTable> zawierającą dwie kolumny i dziesięć wierszy. W przykładzie polecenie zapisuje <xref:System.Data.DataTable> schematu i danych na dysku. W przykładzie jest tworzony drugi <xref:System.Data.DataTable> i wywołuje <xref:System.Data.DataTable.ReadXml%2A> metodę, aby wypełnić go schemat i dane.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlString#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlString/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlString#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlString/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXml(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As XmlReader) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXml : System.Xml.XmlReader -&gt; System.Data.XmlReadMode" Usage="dataTable.ReadXml reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Xml.XmlReader" /> Który będzie używany do odczytywania danych.</param>
        <summary>Odczytuje schemat XML i dane <see cref="T:System.Data.DataTable" /> przy użyciu określonego <see cref="T:System.Xml.XmlReader" />.</summary>
        <returns>
          <see cref="T:System.Data.XmlReadMode" /> Używane do odczytywania danych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bieżący <xref:System.Data.DataTable> i jego elementy potomne są ładowane przy użyciu danych z pliku o nazwie w podanym <xref:System.Xml.XmlReader>. Zachowanie tej metody jest taka sama jak w przypadku <xref:System.Data.DataTable.ReadXml%2A> metody, z wyjątkiem danych oznacza w tym przypadku jest załadowany tylko dla bieżącej tabeli i jego elementy podrzędne.  
  
 <xref:System.Data.DataTable.ReadXml%2A> Metoda zapewnia sposób odczytać tylko dane lub zarówno danych i schemat w <xref:System.Data.DataTable> z dokumentu XML, natomiast <xref:System.Data.DataTable.ReadXmlSchema%2A> metoda odczytuje tylko schemat.  
  
 Należy pamiętać, że dotyczy to także <xref:System.Data.DataTable.WriteXml%2A> i <xref:System.Data.DataTable.WriteXmlSchema%2A> metod, odpowiednio. Aby zapisać dane XML, lub schemat i dane z `DataTable`, użyj `WriteXml` metody. Aby zapisać sam schemat, należy użyć `WriteXmlSchema` metody.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Zostanie zgłoszony, jeśli typ kolumny w `DataRow` trwa od zapisu lub odczytu implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> implementuje <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Jeśli określono schemat w tekście, schemat w tekście jest używany rozszerzyć istniejącą strukturę relacyjnej przed załadowaniem danych. Jeśli występują konflikty (na przykład tej samej kolumny w tej samej tabeli, które są zdefiniowane przy użyciu różnych typów danych), zgłaszany jest wyjątek.  
  
 Jeśli jest określony żaden schemat w tekście, relacyjnej struktury został rozszerzony za pomocą wnioskowania, odpowiednio do potrzeb zgodnie z strukturę dokumentu XML. Jeśli schemat nie można rozszerzyć za pośrednictwem wnioskowania, aby udostępnić wszystkie dane, zgłaszany jest wyjątek.  
  
> [!NOTE]
>  `DataSet` Nie kojarzy — element XML z odpowiadającymi mu dostawcami `DataColumn` lub `DataTable` po prawne znaków XML, takich jak ("_") będą miały zmienione znaczenie w serializacji XML. `DataSet` Tylko specjalne niedozwolone znaki XML w nazwach elementów XML i dlatego mogą korzystać tylko takie same. Gdy prawidłowe znaki w nazwie elementu XML są poprzedzone znakiem zmiany znaczenia, element jest ignorowany podczas przetwarzania.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Data.DataTable> zawierającą dwie kolumny i dziesięć wierszy. W przykładzie polecenie zapisuje <xref:System.Data.DataTable> schemat i dane do <xref:System.Xml.XmlReader>. W przykładzie jest tworzony drugi <xref:System.Data.DataTable> i wywołuje <xref:System.Data.DataTable.ReadXml%2A> metodę, aby wypełnić go schemat i dane z <xref:System.Xml.XmlReader> wystąpienia.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlXmlReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlXmlReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlXmlReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlXmlReader/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadXmlSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Odczytuje schemat XML do <see cref="T:System.Data.DataTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj `ReadXmlSchema` metodę, aby utworzyć schemat dla <xref:System.Data.DataTable>. Schemat zawiera definicje tabeli, relacji i ograniczenia.  
  
 Aby zapisać schemat do dokumentu XML, należy użyć <xref:System.Data.DataTable.WriteXmlSchema%2A> metody.  
  
 Schemat XML jest interpretowane zgodnie ze standardowego XSD.  
  
 `ReadXmlSchema` Zazwyczaj wywoływana jest metoda przed wywołaniem <xref:System.Data.DataTable.ReadXml%2A> metodę, która jest używany do wypełniania <xref:System.Data.DataTable>.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Data.DataSet.ReadXmlSchema" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSchema(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : System.IO.Stream -&gt; unit" Usage="dataTable.ReadXmlSchema stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Strumień używany do odczytu schematu.</param>
        <summary>Odczytuje schemat XML do <see cref="T:System.Data.DataTable" /> przy użyciu określonego strumienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Data.DataTable.ReadXmlSchema%2A> metodę, aby utworzyć schemat dla <xref:System.Data.DataTable>. Schemat zawiera definicje tabeli, relacji i ograniczenia.  
  
 Aby zapisać schemat do dokumentu XML, należy użyć <xref:System.Data.DataTable.WriteXmlSchema%2A> metody.  
  
 Schemat XML jest interpretowane zgodnie ze standardowego XSD.  
  
 Jeśli msdata:DataType i typy xs:type nie są zgodne, może spowodować uszkodzenie danych. Zostanie zgłoszony żaden wyjątek.  
  
 `ReadXmlSchema` Zazwyczaj wywoływana jest metoda przed wywołaniem <xref:System.Data.DataTable.ReadXml%2A> metodę, która jest używany do wypełniania <xref:System.Data.DataTable>.  
  
 Aby utworzyć relacji zagnieżdżonej przy użyciu schematu XML, należy użyć niejawnego elementów zagnieżdżonych. Można również skonfigurować zagnieżdżonych relacji można użyć nazw kolumn jawnego. Elementy muszą niejawnie zagnieżdżone w kolejności dla odpowiedniego DataTable do wzięcia udziału w relacji zagnieżdżonej.  
  
   
  
## Examples  
 Następująca aplikacja konsoli tworzy nową <xref:System.Data.DataTable>i zapisuje schemat dla tej tabeli do <xref:System.IO.MemoryStream>. Następnie przykład tworzy nowy <xref:System.Data.DataTable> i odczytuje jego schematu z zapisanych schematu XML.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlIOStream#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlIOStream/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlIOStream#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlIOStream/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.ReadXmlSchema(System.IO.Stream)" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.IO.TextReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.IO.TextReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSchema(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (reader As TextReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::IO::TextReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : System.IO.TextReader -&gt; unit" Usage="dataTable.ReadXmlSchema reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.IO.TextReader" /> Używane do odczytywania informacji o schemacie.</param>
        <summary>Odczytuje schemat XML do <see cref="T:System.Data.DataTable" /> przy użyciu określonego <see cref="T:System.IO.TextReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Data.DataTable.ReadXmlSchema%2A> metodę, aby utworzyć schemat dla <xref:System.Data.DataTable>. Schemat zawiera definicje tabeli, relacji i ograniczenia.  
  
 Aby zapisać schemat do dokumentu XML, należy użyć <xref:System.Data.DataTable.WriteXmlSchema%2A> metody.  
  
 Schemat XML jest interpretowane zgodnie ze standardowego XSD.  
  
 Jeśli msdata:DataType i typy xs:type nie są zgodne, może spowodować uszkodzenie danych. Zostanie zgłoszony żaden wyjątek.  
  
 `ReadXmlSchema` Zazwyczaj wywoływana jest metoda przed wywołaniem <xref:System.Data.DataTable.ReadXml%2A> metodę, która jest używany do wypełniania <xref:System.Data.DataTable>.  
  
 Aby utworzyć relacji zagnieżdżonej przy użyciu schematu XML, należy użyć niejawnego elementów zagnieżdżonych. Można także ponownie skonfigurować zagnieżdżonych relacji można użyć nazw kolumn jawnego. Elementy muszą niejawnie zagnieżdżone w kolejności dla odpowiedniego DataTable do wzięcia udziału w relacji zagnieżdżonej.  
  
   
  
## Examples  
 Następująca aplikacja konsoli tworzy nową <xref:System.Data.DataTable>i zapisuje schemat dla tej tabeli do <xref:System.IO.MemoryStream>. Następnie przykład tworzy nowy <xref:System.Data.DataTable> i odczytuje jego schematu z zapisanych schematu XML przy użyciu <xref:System.IO.StreamReader> (który dziedziczy z <xref:System.IO.TextReader>) jako źródło.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlSchema#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchema/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlSchema#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchema/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.ReadXmlSchema(System.IO.TextReader)" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSchema(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : string -&gt; unit" Usage="dataTable.ReadXmlSchema fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nazwa pliku, z którego można odczytać informacji o schemacie.</param>
        <summary>Odczytuje schemat XML do <see cref="T:System.Data.DataTable" /> z określonego pliku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Data.DataTable.ReadXmlSchema%2A> metodę, aby utworzyć schemat dla <xref:System.Data.DataTable>. Schemat zawiera definicje tabeli, relacji i ograniczenia.  
  
 Aby zapisać schemat do dokumentu XML, należy użyć <xref:System.Data.DataTable.WriteXmlSchema%2A> metody.  
  
 Schemat XML jest interpretowane zgodnie ze standardowego XSD.  
  
 Jeśli msdata:DataType i typy xs:type nie są zgodne, może spowodować uszkodzenie danych. Zostanie zgłoszony żaden wyjątek.  
  
 `ReadXmlSchema` Zazwyczaj wywoływana jest metoda przed wywołaniem <xref:System.Data.DataTable.ReadXml%2A> metodę, która jest używany do wypełniania `DataTable`.  
  
 Aby utworzyć relacji zagnieżdżonej przy użyciu schematu XML, należy użyć niejawnego elementów zagnieżdżonych. Można także ponownie skonfigurować zagnieżdżonych relacji można użyć nazw kolumn jawnego. Elementy muszą niejawnie zagnieżdżone w kolejności dla odpowiedniego DataTable do wzięcia udziału w relacji zagnieżdżonej.  
  
   
  
## Examples  
 Następująca aplikacja konsoli tworzy nową <xref:System.Data.DataTable>i zapisuje w pliku schematu dla tej tabeli. Następnie przykład tworzy nowy <xref:System.Data.DataTable> i odczytuje jego schematu z zapisanych schematu XML przy użyciu pliku jako źródło.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlSchemaString#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchemaString/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlSchemaString#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchemaString/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.ReadXmlSchema(System.String)" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSchema(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (reader As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.ReadXmlSchema : System.Xml.XmlReader -&gt; unit" Usage="dataTable.ReadXmlSchema reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Xml.XmlReader" /> Używane do odczytywania informacji o schemacie.</param>
        <summary>Odczytuje schemat XML do <see cref="T:System.Data.DataTable" /> przy użyciu określonego <see cref="T:System.Xml.XmlReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Data.DataTable.ReadXmlSchema%2A> metodę, aby utworzyć schemat dla <xref:System.Data.DataTable>. Schemat zawiera definicje tabeli, relacji i ograniczenia.  
  
 Aby zapisać schemat do dokumentu XML, należy użyć <xref:System.Data.DataTable.WriteXmlSchema%2A> metody.  
  
 Schemat XML jest interpretowane zgodnie ze standardowego XSD.  
  
 Jeśli msdata:DataType i typy xs:type nie są zgodne, może spowodować uszkodzenie danych. Zostanie zgłoszony żaden wyjątek.  
  
 `ReadXmlSchema` Zazwyczaj wywoływana jest metoda przed wywołaniem <xref:System.Data.DataTable.ReadXml%2A> metodę, która jest używany do wypełniania <xref:System.Data.DataTable>.  
  
> [!NOTE]
>  Sposób tworzenia relacji zagnieżdżonej przy użyciu schematu XML ma niejawne elementy zagnieżdżone. Ponadto można ponownie sieci przewodowych, aby użyć nazw kolumn jawne zagnieżdżonych relacji. Jest to konieczne, dla elementów być niejawnie zagnieżdżony odpowiedniego DataTable do wzięcia udziału w relacji zagnieżdżonej.  
  
   
  
## Examples  
 Następująca aplikacja konsoli tworzy nową <xref:System.Data.DataTable>i zapisuje schemat dla tej tabeli do <xref:System.IO.MemoryStream>. Następnie przykład tworzy nowy <xref:System.Data.DataTable> i odczytuje jego schematu z zapisanych schematu XML przy użyciu <xref:System.Xml.XmlTextReader> (który dziedziczy z <xref:System.Xml.XmlReader>) jako źródło.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlSchemaReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchemaReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlSchemaReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchemaReader/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSerializable">
      <MemberSignature Language="C#" Value="protected virtual void ReadXmlSerializable (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ReadXmlSerializable(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSerializable(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ReadXmlSerializable (reader As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ReadXmlSerializable(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="abstract member ReadXmlSerializable : System.Xml.XmlReader -&gt; unit&#xA;override this.ReadXmlSerializable : System.Xml.XmlReader -&gt; unit" Usage="dataTable.ReadXmlSerializable reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Element <see cref="T:System.Xml.XmlReader" /> obiektu.</param>
        <summary>Odczytuje dane ze strumienia XML.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RejectChanges">
      <MemberSignature Language="C#" Value="public void RejectChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RejectChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.RejectChanges" />
      <MemberSignature Language="VB.NET" Value="Public Sub RejectChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RejectChanges();" />
      <MemberSignature Language="F#" Value="member this.RejectChanges : unit -&gt; unit" Usage="dataTable.RejectChanges " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wycofuje wszystkie zmiany wprowadzone do tabeli, od momentu załadowania lub czas ostatniego <see cref="M:System.Data.DataTable.AcceptChanges" /> została wywołana.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Data.DataTable.RejectChanges%2A> jest wywoływana, dowolny <xref:System.Data.DataRow> obiekty, które są nadal w trybie edycji anulować ich edycji. Nowe wiersze są usuwane. Wiersze z <xref:System.Data.DataRowState> równa `Modified` lub `Deleted` zwracany z powrotem do pierwotnego stanu.  
  
   
  
## Examples  
 Poniższy przykład wykonuje kilka zmian <xref:System.Data.DataTable>, ale odrzuca zmiany przez wywołanie <xref:System.Data.DataTable.RejectChanges%2A> metody.  
  
 [!code-csharp[Classic WebData DataTable.RejectChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RejectChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RejectChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RejectChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Praca ze zdarzeniami DataTable</related>
      </Docs>
    </Member>
    <Member MemberName="RemotingFormat">
      <MemberSignature Language="C#" Value="public System.Data.SerializationFormat RemotingFormat { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.SerializationFormat RemotingFormat" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.RemotingFormat" />
      <MemberSignature Language="VB.NET" Value="Public Property RemotingFormat As SerializationFormat" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::SerializationFormat RemotingFormat { System::Data::SerializationFormat get(); void set(System::Data::SerializationFormat value); };" />
      <MemberSignature Language="F#" Value="member this.RemotingFormat : System.Data.SerializationFormat with get, set" Usage="System.Data.DataTable.RemotingFormat" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.SerializationFormat</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia format serializacji.</summary>
        <value>A <see cref="T:System.Data.SerializationFormat" /> wyliczenie opisujące albo <see langword="Binary" /> lub <see langword="Xml" /> serializacji.</value>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public virtual void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberSignature Language="F#" Value="abstract member Reset : unit -&gt; unit&#xA;override this.Reset : unit -&gt; unit" Usage="dataTable.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Resetuje <see cref="T:System.Data.DataTable" /> do stanu pierwotnego. Resetowanie spowoduje usunięcie wszystkich danych, indeksów, relacje i kolumn tabeli. Jeśli zestaw danych zawiera tabelę DataTable, tabeli nadal będzie częścią zestawu danych, po zresetowaniu tabeli.</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Praca ze zdarzeniami DataTable</related>
      </Docs>
    </Member>
    <Member MemberName="RowChanged">
      <MemberSignature Language="C#" Value="public event System.Data.DataRowChangeEventHandler RowChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataRowChangeEventHandler RowChanged" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.RowChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RowChanged As DataRowChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataRowChangeEventHandler ^ RowChanged;" />
      <MemberSignature Language="F#" Value="member this.RowChanged : System.Data.DataRowChangeEventHandler " Usage="member this.RowChanged : System.Data.DataRowChangeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableRowChangedDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRowChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po <see cref="T:System.Data.DataRow" /> zostało pomyślnie zmienione.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji, zobacz [Obsługa zdarzeń elementu DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md).  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.RowChanged Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RowChanged Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RowChanged Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RowChanged Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="RowChanging">
      <MemberSignature Language="C#" Value="public event System.Data.DataRowChangeEventHandler RowChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataRowChangeEventHandler RowChanging" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.RowChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RowChanging As DataRowChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataRowChangeEventHandler ^ RowChanging;" />
      <MemberSignature Language="F#" Value="member this.RowChanging : System.Data.DataRowChangeEventHandler " Usage="member this.RowChanging : System.Data.DataRowChangeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableRowChangingDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRowChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy <see cref="T:System.Data.DataRow" /> ulega zmianie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji, zobacz [Obsługa zdarzeń elementu DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md).  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.RowChanging Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RowChanging Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RowChanging Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RowChanging Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="RowDeleted">
      <MemberSignature Language="C#" Value="public event System.Data.DataRowChangeEventHandler RowDeleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataRowChangeEventHandler RowDeleted" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.RowDeleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RowDeleted As DataRowChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataRowChangeEventHandler ^ RowDeleted;" />
      <MemberSignature Language="F#" Value="member this.RowDeleted : System.Data.DataRowChangeEventHandler " Usage="member this.RowDeleted : System.Data.DataRowChangeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableRowDeletedDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRowChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po usunięciu wiersza w tabeli.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji, zobacz [Obsługa zdarzeń elementu DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md).  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.RowDeleted Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RowDeleted Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RowDeleted Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RowDeleted Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="RowDeleting">
      <MemberSignature Language="C#" Value="public event System.Data.DataRowChangeEventHandler RowDeleting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataRowChangeEventHandler RowDeleting" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.RowDeleting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RowDeleting As DataRowChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataRowChangeEventHandler ^ RowDeleting;" />
      <MemberSignature Language="F#" Value="member this.RowDeleting : System.Data.DataRowChangeEventHandler " Usage="member this.RowDeleting : System.Data.DataRowChangeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableRowDeletingDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRowChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, zanim wiersza w tabeli ma zostać usunięty.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji, zobacz [Obsługa zdarzeń elementu DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md).  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.RowDeleting Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RowDeleting Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RowDeleting Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RowDeleting Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="Rows">
      <MemberSignature Language="C#" Value="public System.Data.DataRowCollection Rows { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataRowCollection Rows" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Rows" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Rows As DataRowCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataRowCollection ^ Rows { System::Data::DataRowCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Rows : System.Data.DataRowCollection" Usage="System.Data.DataTable.Rows" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableRowsDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRowCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję wierszy, które należą do tej tabeli.</summary>
        <value>A <see cref="T:System.Data.DataRowCollection" /> zawierający <see cref="T:System.Data.DataRow" /> obiekty; w przeciwnym razie wartość o wartości null, jeśli nie <see cref="T:System.Data.DataRow" /> istnieją obiekty.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby utworzyć nowy <xref:System.Data.DataRow>, należy użyć <xref:System.Data.DataTable.NewRow%2A> metoda zwraca nowy obiekt. Taki obiekt jest automatycznie konfigurowany zgodnie ze schematem zdefiniowane dla <xref:System.Data.DataTable> za pośrednictwem jego Kolekcja <xref:System.Data.DataColumn> obiektów. Po utworzeniu nowego wiersza i ustawianie wartości dla każdej kolumny w tym wierszu, Dodaj wiersz, aby <xref:System.Data.DataRowCollection> przy użyciu `Add` metody.  
  
 Każdy <xref:System.Data.DataRow> w kolekcji reprezentuje wiersz danych w tabeli. Aby zatwierdzić zmiany na wartość kolumny w wierszu, należy wywołać <xref:System.Data.DataTable.AcceptChanges%2A> metody.  
  
   
  
## Examples  
 Poniżej przedstawiono dwa przykłady zwracanie i ustawiania wierszy. W pierwszym przykładzie użyto <xref:System.Data.DataTable.Rows%2A> właściwości i wartości kolumn dla każdego wiersza. W drugim przykładzie użyto <xref:System.Data.DataTable> obiektu <xref:System.Data.DataTable.NewRow%2A> metodę, aby utworzyć nową <xref:System.Data.DataRow> obiektu ze schematem <xref:System.Data.DataTable>. Po ustawieniu wartości wierszy, wiersz został dodany do <xref:System.Data.DataRowCollection> za pośrednictwem `Add` metody.  
  
 [!code-csharp[Classic WebData DataTable.Rows Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Rows Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Rows Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Rows Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataTable.AcceptChanges" />
        <altmember cref="T:System.Data.DataRow" />
        <altmember cref="T:System.Data.DataRowCollection" />
        <altmember cref="M:System.Data.DataTable.NewRow" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Select">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera tablicę elementów <see cref="T:System.Data.DataRow" /> obiektów.</summary>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] Select ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] Select() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Select" />
      <MemberSignature Language="VB.NET" Value="Public Function Select () As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ Select();" />
      <MemberSignature Language="F#" Value="member this.Select : unit -&gt; System.Data.DataRow[]" Usage="dataTable.Select " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera tablicę wszystkich <see cref="T:System.Data.DataRow" /> obiektów.</summary>
        <returns>Tablica <see cref="T:System.Data.DataRow" /> obiektów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W celu zapewnienia odpowiedniego sortowania, określ kryteria sortowania z <xref:System.Data.DataTable.Select(System.String,System.String)> lub <xref:System.Data.DataTable.Select(System.String,System.String,System.Data.DataViewRowState)>.  
  
   
  
## Examples  
 Poniższy przykład zwraca tablicę <xref:System.Data.DataRow> obiektów za pomocą <xref:System.Data.DataTable.Select%2A> metody.  
  
 [!code-csharp[Classic WebData DataTable.Select Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Select Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Select Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Select Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.CaseSensitive" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=191549">Wartości zerowe</related>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] Select (string filterExpression);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] Select(string filterExpression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Select(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Select (filterExpression As String) As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ Select(System::String ^ filterExpression);" />
      <MemberSignature Language="F#" Value="member this.Select : string -&gt; System.Data.DataRow[]" Usage="dataTable.Select filterExpression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filterExpression" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filterExpression">Kryteria służące do filtrowania wierszy. Przykłady do filtra wierszy, zobacz [DataView RowFilter składni [C#]](https://www.csharp-examples.net/dataview-rowfilter/).</param>
        <summary>Pobiera tablicę wszystkich <see cref="T:System.Data.DataRow" /> obiekty spełniające kryteria filtru.</summary>
        <returns>Tablica <see cref="T:System.Data.DataRow" /> obiektów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby utworzyć `filterExpression` argument, te same zasady, które są stosowane do użycia <xref:System.Data.DataColumn> klasy <xref:System.Data.DataColumn.Expression%2A> wartości właściwości do tworzenia filtrów.  
  
W celu zapewnienia odpowiedniego sortowania, określ kryteria sortowania z <xref:System.Data.DataTable.Select(System.String,System.String)> lub <xref:System.Data.DataTable.Select(System.String,System.String,System.Data.DataViewRowState)>.
  
 Jeśli kolumna filtru zawiera wartość null, nie będzie w wyniku.  
  
   
  
## Examples  
 W poniższym przykładzie użyto wyrażenia filtru, aby zwrócić tablicę <xref:System.Data.DataRow> obiektów.  
  
 [!code-csharp[Classic WebData DataTable.Select1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Select1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Select1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Select1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.CaseSensitive" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=191549">Wartości zerowe</related>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] Select (string filterExpression, string sort);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] Select(string filterExpression, string sort) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Select(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Select (filterExpression As String, sort As String) As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ Select(System::String ^ filterExpression, System::String ^ sort);" />
      <MemberSignature Language="F#" Value="member this.Select : string * string -&gt; System.Data.DataRow[]" Usage="dataTable.Select (filterExpression, sort)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filterExpression" Type="System.String" />
        <Parameter Name="sort" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filterExpression">Kryteria służące do filtrowania wierszy. Przykłady do filtra wierszy, zobacz [DataView RowFilter składni [C#]](https://www.csharp-examples.net/dataview-rowfilter/).</param>
        <param name="sort">Ciąg określający kierunek kolumny i sortowania.</param>
        <summary>Pobiera tablicę wszystkich <see cref="T:System.Data.DataRow" /> obiekty spełniające kryteria filtru, w kolejności sortowania określonego.</summary>
        <returns>Tablica <see cref="T:System.Data.DataRow" /> obiektów spełniających wyrażenie filtru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do formularza `filterExpression` argument, użyj tych samych reguł tworzenia <xref:System.Data.DataColumn> klasy <xref:System.Data.DataColumn.Expression%2A> wartości właściwości. `Sort` Argument używa również te same reguły tworzenia klasy <xref:System.Data.DataColumn.Expression%2A> ciągów.  
  
 Jeśli kolumna filtru zawiera wartość null, nie będzie w wyniku.  
  
   
  
## Examples  
 W poniższym przykładzie użyto wyrażenia filtru, aby zwrócić tablicę <xref:System.Data.DataRow> obiektów.  
  
 [!code-csharp[Classic WebData DataTable.Select2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Select2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Select2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Select2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.CaseSensitive" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=191549">Wartości zerowe</related>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] Select (string filterExpression, string sort, System.Data.DataViewRowState recordStates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] Select(string filterExpression, string sort, valuetype System.Data.DataViewRowState recordStates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Select(System.String,System.String,System.Data.DataViewRowState)" />
      <MemberSignature Language="VB.NET" Value="Public Function Select (filterExpression As String, sort As String, recordStates As DataViewRowState) As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ Select(System::String ^ filterExpression, System::String ^ sort, System::Data::DataViewRowState recordStates);" />
      <MemberSignature Language="F#" Value="member this.Select : string * string * System.Data.DataViewRowState -&gt; System.Data.DataRow[]" Usage="dataTable.Select (filterExpression, sort, recordStates)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filterExpression" Type="System.String" />
        <Parameter Name="sort" Type="System.String" />
        <Parameter Name="recordStates" Type="System.Data.DataViewRowState" />
      </Parameters>
      <Docs>
        <param name="filterExpression">Kryteria służące do filtrowania wierszy. Przykłady do filtra wierszy, zobacz [DataView RowFilter składni [C#]](https://www.csharp-examples.net/dataview-rowfilter/).</param>
        <param name="sort">Ciąg określający kierunek kolumny i sortowania.</param>
        <param name="recordStates">Jedną z <see cref="T:System.Data.DataViewRowState" /> wartości.</param>
        <summary>Pobiera tablicę wszystkich <see cref="T:System.Data.DataRow" /> obiektów, które są zgodne z filtrem w kolejności sortowania, które pasują do określonego stanu.</summary>
        <returns>Tablica <see cref="T:System.Data.DataRow" /> obiektów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do formularza `filterExpression` argument, użyj tych samych reguł tworzenia <xref:System.Data.DataColumn> klasy <xref:System.Data.DataColumn.Expression%2A> wartości właściwości. `Sort` Argument używa również te same reguły tworzenia klasy <xref:System.Data.DataColumn.Expression%2A> ciągów.  
  
 Jeśli kolumna filtru zawiera wartość null, nie będzie w wyniku.  
  
   
  
## Examples  
 W poniższym przykładzie użyto stan filtru wyrażeń i rejestrowanie, aby zwrócić tablicę <xref:System.Data.DataRow> obiektów.  
  
 [!code-csharp[Classic WebData DataTable.Select3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Select3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Select3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Select3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=191549">Wartości zerowe</related>
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Site" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Site : System.ComponentModel.ISite with get, set" Usage="System.Data.DataTable.Site" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.ComponentModel.ISite" /> dla <see cref="T:System.Data.DataTable" />.</summary>
        <value>
          <see cref="T:System.ComponentModel.ISite" /> Dla <see cref="T:System.Data.DataTable" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Powiązania witryny <xref:System.ComponentModel.Component> do <xref:System.ComponentModel.Container> i umożliwić komunikację między nimi, a także umożliwiają kontener, aby zarządzać jego składniki.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.ContainsListCollection">
      <MemberSignature Language="C#" Value="bool System.ComponentModel.IListSource.ContainsListCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.ComponentModel.IListSource.ContainsListCollection" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.System#ComponentModel#IListSource#ContainsListCollection" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ContainsListCollection As Boolean Implements IListSource.ContainsListCollection" />
      <MemberSignature Language="C++ CLI" Value="property bool System::ComponentModel::IListSource::ContainsListCollection { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.ComponentModel.IListSource.ContainsListCollection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="P:System.ComponentModel.IListSource.ContainsListCollection" />.</summary>
        <value>
          <see langword="true" /> Jeśli kolekcja jest kolekcją <see cref="T:System.Collections.IList" /> obiekty; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Data.DataTable> wystąpienia jest rzutowany na <xref:System.ComponentModel.IListSource> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.GetList">
      <MemberSignature Language="C#" Value="System.Collections.IList IListSource.GetList ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IList System.ComponentModel.IListSource.GetList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.System#ComponentModel#IListSource#GetList" />
      <MemberSignature Language="VB.NET" Value="Function GetList () As IList Implements IListSource.GetList" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IList ^ System.ComponentModel.IListSource.GetList() = System::ComponentModel::IListSource::GetList;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="M:System.ComponentModel.IListSource.GetList" />.</summary>
        <returns>
          <see cref="T:System.Collections.IList" /> , Może być powiązana ze źródłem danych z obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Data.DataTable> wystąpienia jest rzutowany na <xref:System.ComponentModel.IListSource> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Element <see cref="T:System.Runtime.Serialization.SerializationInfo" /> obiektu.</param>
        <param name="context">Element <see cref="T:System.Runtime.Serialization.StreamingContext" /> obiektu.</param>
        <summary>Wypełnia obiekt informacji o serializacji dane potrzebne do serializacji <see cref="T:System.Data.DataTable" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.GetSchema">
      <MemberSignature Language="C#" Value="System.Xml.Schema.XmlSchema IXmlSerializable.GetSchema ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Xml.Schema.XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#GetSchema" />
      <MemberSignature Language="VB.NET" Value="Function GetSchema () As XmlSchema Implements IXmlSerializable.GetSchema" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Xml::Schema::XmlSchema ^ System.Xml.Serialization.IXmlSerializable.GetSchema() = System::Xml::Serialization::IXmlSerializable::GetSchema;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.GetSchema</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchema</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" />.</summary>
        <returns>
          <see cref="T:System.Xml.Schema.XmlSchema" /> Opisujący reprezentację XML obiektu, który jest wytwarzany przez <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" /> metody, które są używane przez <see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" /> metody.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Data.DataSet> wystąpienia jest rzutowany na <xref:System.Xml.Serialization.IXmlSerializable> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.ReadXml">
      <MemberSignature Language="C#" Value="void IXmlSerializable.ReadXml (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Xml.Serialization.IXmlSerializable.ReadXml(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Sub ReadXml (reader As XmlReader) Implements IXmlSerializable.ReadXml" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Xml.Serialization.IXmlSerializable.ReadXml(System::Xml::XmlReader ^ reader) = System::Xml::Serialization::IXmlSerializable::ReadXml;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Element XmlReader.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Data.DataSet> wystąpienia jest rzutowany na <xref:System.Xml.Serialization.IXmlSerializable> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.WriteXml">
      <MemberSignature Language="C#" Value="void IXmlSerializable.WriteXml (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Xml.Serialization.IXmlSerializable.WriteXml(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Sub WriteXml (writer As XmlWriter) Implements IXmlSerializable.WriteXml" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Xml.Serialization.IXmlSerializable.WriteXml(System::Xml::XmlWriter ^ writer) = System::Xml::Serialization::IXmlSerializable::WriteXml;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Parametr XmlWriter.</param>
        <summary>Aby uzyskać opis tego elementu członkowskiego, zobacz <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Mogą być używane tylko wtedy, gdy <xref:System.Data.DataSet> wystąpienia jest rzutowany na <xref:System.Xml.Serialization.IXmlSerializable> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TableCleared">
      <MemberSignature Language="C#" Value="public event System.Data.DataTableClearEventHandler TableCleared;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataTableClearEventHandler TableCleared" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.TableCleared" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TableCleared As DataTableClearEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataTableClearEventHandler ^ TableCleared;" />
      <MemberSignature Language="F#" Value="member this.TableCleared : System.Data.DataTableClearEventHandler " Usage="member this.TableCleared : System.Data.DataTableClearEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableClearEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po <see cref="T:System.Data.DataTable" /> jest wyczyszczone.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.TableCleared> Zdarzenie jest wywoływane po wszystkie wiersze zostały pomyślnie wyczyszczone lecz przed <xref:System.Data.DataTable.Clear%2A> metoda zwraca sterowanie do obiektu wywołującego. <xref:System.Data.DataTable.TableCleared> Zdarzeń nie jest uruchamiany, jeśli istnieją wyjątki podczas operacji Wyczyść.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Praca ze zdarzeniami DataTable</related>
      </Docs>
    </Member>
    <Member MemberName="TableClearing">
      <MemberSignature Language="C#" Value="public event System.Data.DataTableClearEventHandler TableClearing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataTableClearEventHandler TableClearing" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.TableClearing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TableClearing As DataTableClearEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataTableClearEventHandler ^ TableClearing;" />
      <MemberSignature Language="F#" Value="member this.TableClearing : System.Data.DataTableClearEventHandler " Usage="member this.TableClearing : System.Data.DataTableClearEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableClearEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy <see cref="T:System.Data.DataTable" /> jest wyczyszczone.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.TableClearing> Zdarzenie jest wywoływane przed przetwarzania <xref:System.Data.DataTable.Clear%2A> rozpoczęciu operacji. To zdarzenie jest wywoływane zawsze, gdy <xref:System.Data.DataTable.Clear%2A> metoda jest wywoływana, nawet wtedy, gdy tabela zawiera zero wierszy.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Praca ze zdarzeniami DataTable</related>
      </Docs>
    </Member>
    <Member MemberName="TableName">
      <MemberSignature Language="C#" Value="public string TableName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TableName" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.TableName" />
      <MemberSignature Language="VB.NET" Value="Public Property TableName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TableName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TableName : string with get, set" Usage="System.Data.DataTable.TableName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2">
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.All)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Data.DataSysDescription("DataTableTableNameDescr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę <see cref="T:System.Data.DataTable" />.</summary>
        <value>Nazwa <see cref="T:System.Data.DataTable" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.TableName%2A> Służy do zwracania tę tabelę z nadrzędnej <xref:System.Data.DataSet> obiektu <xref:System.Data.DataTableCollection> (zwrócone przez <xref:System.Data.DataSet.Tables%2A> właściwości).  
  
   
  
## Examples  
 Poniższy przykład drukuje <xref:System.Data.DataTable.TableName%2A> dla każdej tabeli w zbiorze <xref:System.Data.DataTable> obiektów.  
  
 [!code-csharp[Classic WebData DataTable.TableName Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.TableName Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.TableName Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.TableName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see langword="null" /> lub pusty ciąg ("") jest przekazywana i w tej tabeli, który należy do kolekcji.</exception>
        <exception cref="T:System.Data.DuplicateNameException">Tabela należy do kolekcji, która już zawiera tabelę o takiej samej nazwie. (Porównanie jest rozróżniana wielkość liter).</exception>
        <altmember cref="T:System.Data.DataSet" />
        <altmember cref="P:System.Data.DataSet.Tables" />
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="TableNewRow">
      <MemberSignature Language="C#" Value="public event System.Data.DataTableNewRowEventHandler TableNewRow;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataTableNewRowEventHandler TableNewRow" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.TableNewRow" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TableNewRow As DataTableNewRowEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataTableNewRowEventHandler ^ TableNewRow;" />
      <MemberSignature Language="F#" Value="member this.TableNewRow : System.Data.DataTableNewRowEventHandler " Usage="member this.TableNewRow : System.Data.DataTableNewRowEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableNewRowEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy nowy <see cref="T:System.Data.DataRow" /> zostanie wstawiona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Generowane po nową <xref:System.Data.DataRow> została utworzona przy użyciu <xref:System.Data.DataTable.NewRow%2A>. To zdarzenie jest wywoływane przed wywołanej `NewRow` metoda zwraca. Nowy <xref:System.Data.DataRow> wystąpienia jest odłączona; nie został dodany do kolekcji.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
        <related type="Article" href="https://msdn.microsoft.com/library/62f404a5-13ea-4b93-a29f-55b74a16c9d3">Praca ze zdarzeniami DataTable</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="abstract member ToString : unit -&gt; string&#xA;override this.ToString : unit -&gt; string" Usage="dataTable.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera <see cref="P:System.Data.DataTable.TableName" /> i <see cref="P:System.Data.DataTable.DisplayExpression" />, jeśli istnieje jeden jako połączony ciąg.</summary>
        <returns>Ciąg składający się z <see cref="P:System.Data.DataTable.TableName" /> i <see cref="P:System.Data.DataTable.DisplayExpression" /> wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pobiera <xref:System.Data.DataTable.TableName%2A> i <xref:System.Data.DataTable.DisplayExpression%2A> dla <xref:System.Data.DataTable>.  
  
   
  
## Examples  
 Poniższy przykład zwraca <xref:System.Data.DataTable.TableName%2A> i <xref:System.Data.DataTable.DisplayExpression%2A> przy użyciu <xref:System.Data.DataTable.ToString%2A> metody.  
  
 [!code-csharp[Classic WebData DataTable.ToString Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ToString Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ToString Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ToString Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteXml">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapisuje zawartość bieżącego <see cref="T:System.Data.DataTable" /> jako XML.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> Metoda zapewnia byłby następujący zapis tylko dane lub zarówno dane i schemat z <xref:System.Data.DataTable> do dokumentu XML, natomiast <xref:System.Data.DataTable.WriteXmlSchema%2A> metoda zapisuje tylko schemat. Aby napisać, danych i schemat, użyj jednego z przeciążeń, które obejmują <xref:System.Data.XmlWriteMode> parametru i ustawić jej wartość na `WriteSchema`.  
  
 Należy pamiętać, że dotyczy to także <xref:System.Data.DataTable.ReadXml%2A> i <xref:System.Data.DataTable.ReadXmlSchema%2A> metod, odpowiednio. Do odczytywania danych XML lub schemat i dane `DataTable`, użyj `ReadXml` metody. Aby dowiedzieć się sam schemat, należy użyć `ReadXmlSchema` metody.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Zostanie zgłoszony, jeśli typ kolumny w `DataRow` trwa od zapisu lub odczytu implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> implementuje <xref:System.Xml.Serialization.IXmlSerializable>.  
  
   
  
## Examples  
 Następująca aplikacja konsoli tworzy dwa <xref:System.Data.DataTable> wystąpień, dodaje do <xref:System.Data.DataSet>, tworzy <xref:System.Data.DataRelation> odnoszących się dwie tabele, a następnie używa <xref:System.Data.DataTable.WriteXml%2A> metody do zapisania danych zawartych w tabeli nadrzędnej do <xref:System.IO.TextWriter>. W przykładzie pokazano zachowanie podczas ustawiania `writeHierarchy` parametru do każdego z jego wartości.  
  
> [!NOTE]
>  W tym przykładzie pokazano, jak użyć jednej z przeciążone wersje WriteXml. Inne przykłady, które mogą być dostępne znajduje się w tematach poszczególnych przeciążeń.  
  
 [!code-csharp[DataWorks DataTable.WriteXmlOverload#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlOverload/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXmlOverload#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlOverload/VB/source.vb#1)]  
  
 W przykładzie są wyświetlane następujące dane wyjściowe w oknie konsoli:  
  
```  
==============================  
Customer table, without hierarchy  
==============================  
<NewDataSet>  
  <xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema  
" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
    <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
      <xs:complexType>  
        <xs:choice minOccurs="0" maxOccurs="unbounded">  
          <xs:element name="Table1">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="ID" type="xs:int" />  
                <xs:element name="Name" type="xs:string" minOccurs="0" />  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
        </xs:choice>  
      </xs:complexType>  
      <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table1" />  
        <xs:field xpath="ID" />  
      </xs:unique>  
    </xs:element>  
  </xs:schema>  
  <Table1>  
    <ID>1</ID>  
    <Name>Mary</Name>  
  </Table1>  
  <Table1>  
    <ID>2</ID>  
    <Name>Andy</Name>  
  </Table1>  
  <Table1>  
    <ID>3</ID>  
    <Name>Peter</Name>  
  </Table1>  
  <Table1>  
    <ID>4</ID>  
    <Name>Russ</Name>  
  </Table1>  
</NewDataSet>  
==============================  
Customer table, with hierarchy  
==============================  
<NewDataSet>  
  <xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema  
" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
    <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
      <xs:complexType>  
        <xs:choice minOccurs="0" maxOccurs="unbounded">  
          <xs:element name="Table1">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="ID" type="xs:int" />  
                <xs:element name="Name" type="xs:string" minOccurs="0" />  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
          <xs:element name="Table2">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="OrderID" type="xs:int" />  
                <xs:element name="CustomerID" type="xs:int" minOccurs="0" />  
                <xs:element name="OrderDate" type="xs:dateTime" minOccurs="0" />  
  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
        </xs:choice>  
      </xs:complexType>  
      <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table1" />  
        <xs:field xpath="ID" />  
      </xs:unique>  
      <xs:unique name="Table2_Constraint1" msdata:ConstraintName="Constraint1" m  
sdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table2" />  
        <xs:field xpath="OrderID" />  
      </xs:unique>  
      <xs:keyref name="CustomerOrder" refer="Constraint1">  
        <xs:selector xpath=".//Table2" />  
        <xs:field xpath="CustomerID" />  
      </xs:keyref>  
    </xs:element>  
  </xs:schema>  
  <Table1>  
    <ID>1</ID>  
    <Name>Mary</Name>  
  </Table1>  
  <Table1>  
    <ID>2</ID>  
    <Name>Andy</Name>  
  </Table1>  
  <Table1>  
    <ID>3</ID>  
    <Name>Peter</Name>  
  </Table1>  
  <Table1>  
    <ID>4</ID>  
    <Name>Russ</Name>  
  </Table1>  
  <Table2>  
    <OrderID>1</OrderID>  
    <CustomerID>1</CustomerID>  
    <OrderDate>2003-12-02T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>2</OrderID>  
    <CustomerID>1</CustomerID>  
    <OrderDate>2004-01-03T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>3</OrderID>  
    <CustomerID>2</CustomerID>  
    <OrderDate>2004-11-13T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>4</OrderID>  
    <CustomerID>3</CustomerID>  
    <OrderDate>2004-05-16T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>5</OrderID>  
    <CustomerID>3</CustomerID>  
    <OrderDate>2004-05-22T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>6</OrderID>  
    <CustomerID>4</CustomerID>  
    <OrderDate>2004-06-15T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
</NewDataSet>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.Stream -&gt; unit" Usage="dataTable.WriteXml stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Strumień, do którego będą zapisywane dane.</param>
        <summary>Zapisuje zawartość bieżącego <see cref="T:System.Data.DataTable" /> jako XML przy użyciu określonego <see cref="T:System.IO.Stream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> Metoda zapewnia byłby następujący zapis tylko dane lub zarówno dane i schemat z <xref:System.Data.DataTable> do dokumentu XML, natomiast <xref:System.Data.DataTable.WriteXmlSchema%2A> metoda zapisuje tylko schemat. Do zapisania danych i schemat, użyj jednego z przeciążeń, które obejmuje <xref:System.Data.XmlWriteMode> parametru i ustawić jej wartość na `WriteSchema`.  
  
 Należy pamiętać, że dotyczy to także <xref:System.Data.DataTable.ReadXml%2A> i <xref:System.Data.DataTable.ReadXmlSchema%2A> metod, odpowiednio. Do odczytywania danych XML lub schemat i dane `DataTable`, użyj `ReadXml` metody. Aby dowiedzieć się sam schemat, należy użyć `ReadXmlSchema` metody.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Zostanie zgłoszony, jeśli typ kolumny w `DataRow` trwa od zapisu lub odczytu implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> implementuje <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.TextWriter -&gt; unit" Usage="dataTable.WriteXml writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.IO.TextWriter" /> Umożliwiającą zapis zawartości.</param>
        <summary>Zapisuje zawartość bieżącego <see cref="T:System.Data.DataTable" /> jako XML przy użyciu określonego <see cref="T:System.IO.TextWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> Metoda zapewnia byłby następujący zapis tylko dane lub zarówno dane i schemat z <xref:System.Data.DataTable> do dokumentu XML, natomiast <xref:System.Data.DataTable.WriteXmlSchema%2A> metoda zapisuje tylko schemat. Do zapisania danych i schemat, użyj jednego z przeciążeń, które obejmuje <xref:System.Data.XmlWriteMode> parametru i ustawić jej wartość na `WriteSchema`.  
  
 Należy pamiętać, że dotyczy to także <xref:System.Data.DataTable.ReadXml%2A> i <xref:System.Data.DataTable.ReadXmlSchema%2A> metod, odpowiednio. Do odczytywania danych XML lub schemat i dane `DataTable`, użyj `ReadXml` metody. Aby dowiedzieć się sam schemat, należy użyć `ReadXmlSchema` metody.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Zostanie zgłoszony, jeśli typ kolumny w `DataRow` trwa od zapisu lub odczytu implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> implementuje <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : string -&gt; unit" Usage="dataTable.WriteXml fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Plik, do którego można zapisywać dane XML.</param>
        <summary>Zapisuje zawartość bieżącego <see cref="T:System.Data.DataTable" /> jako XML przy użyciu określonego pliku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> Metoda zapewnia byłby następujący zapis tylko dane lub zarówno dane i schemat z <xref:System.Data.DataTable> do dokumentu XML, natomiast <xref:System.Data.DataTable.WriteXmlSchema%2A> metoda zapisuje tylko schemat. Do zapisania danych i schemat, użyj jednego z przeciążeń, które obejmuje <xref:System.Data.XmlWriteMode> parametru i ustawić jej wartość na `WriteSchema`.  
  
 Należy pamiętać, że dotyczy to także <xref:System.Data.DataTable.ReadXml%2A> i <xref:System.Data.DataTable.ReadXmlSchema%2A> metod, odpowiednio. Do odczytywania danych XML lub schemat i dane `DataTable`, użyj `ReadXml` metody. Aby dowiedzieć się sam schemat, należy użyć `ReadXmlSchema` metody.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Zostanie zgłoszony, jeśli typ kolumny w `DataRow` trwa od zapisu lub odczytu implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> implementuje <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.Xml.XmlWriter -&gt; unit" Usage="dataTable.WriteXml writer" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.Xml.XmlWriter" /> Umożliwiającą zapis zawartości.</param>
        <summary>Zapisuje zawartość bieżącego <see cref="T:System.Data.DataTable" /> jako XML przy użyciu określonego <see cref="T:System.Xml.XmlWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> Metoda zapewnia byłby następujący zapis tylko dane lub zarówno dane i schemat z <xref:System.Data.DataTable> do dokumentu XML, natomiast <xref:System.Data.DataTable.WriteXmlSchema%2A> metoda zapisuje tylko schemat. Aby napisać, danych i schemat, użyj jednego z przeciążeń, które obejmują <xref:System.Data.XmlWriteMode> parametru i ustawić jej wartość na `WriteSchema`.  
  
 Należy pamiętać, że dotyczy to także <xref:System.Data.DataTable.ReadXml%2A> i <xref:System.Data.DataTable.ReadXmlSchema%2A> metod, odpowiednio. Do odczytywania danych XML lub schemat i dane `DataTable`, użyj `ReadXml` metody. Aby dowiedzieć się sam schemat, należy użyć `ReadXmlSchema` metody.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Zostanie zgłoszony, jeśli typ kolumny w `DataRow` trwa od zapisu lub odczytu implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> implementuje <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.Stream * bool -&gt; unit" Usage="dataTable.WriteXml (stream, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">Strumień, do którego będą zapisywane dane.</param>
        <param name="writeHierarchy">Jeśli <see langword="true" />, zapisywanie zawartości w bieżącej tabeli i wszystkie jego elementy podrzędne. Jeśli <see langword="false" /> (wartość domyślna), zapis danych dla bieżącej tabeli.</param>
        <summary>Zapisuje zawartość bieżącego <see cref="T:System.Data.DataTable" /> jako XML przy użyciu określonego <see cref="T:System.IO.Stream" />. Aby zapisać dane w tabeli i wszystkie jego elementy podrzędne, ustaw <paramref name="writeHierarchy" /> parametr <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Data.DataTable.WriteXmlSchema%2A> metodę, aby zapisać schematu dla <xref:System.Data.DataTable> do dokumentu XML. Schemat zawiera definicje tabeli, relacji i ograniczenia.  
  
 Schemat XML są zapisywane przy użyciu standardu XSD.  
  
 Aby zapisać dane w dokumencie XML, należy użyć <xref:System.Data.DataTable.WriteXml%2A> metody.  
  
 Zwykle `WriteXml` metoda zapisuje dane tylko dla bieżącej tabeli. Można zapisać danych w bieżącej tabeli i wszystkich jego elementów podrzędnych, powiązanych tabelach, wywołaj metodę z `writeHierarchy` parametr `true`.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Zostanie zgłoszony, jeśli typ kolumny w `DataRow` trwa od zapisu lub odczytu implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> implementuje <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.Stream * System.Data.XmlWriteMode -&gt; unit" Usage="dataTable.WriteXml (stream, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="stream">Strumień, do którego będą zapisywane dane.</param>
        <param name="mode">Jedną z <see cref="T:System.Data.XmlWriteMode" /> wartości.</param>
        <summary>Zapisuje bieżące dane i opcjonalnie schemat dla <see cref="T:System.Data.DataTable" /> do określonego pliku przy użyciu określonego <see cref="T:System.Data.XmlWriteMode" />. Aby zapisać schemat, należy ustawić wartość <paramref name="mode" /> parametr <see langword="WriteSchema" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> Metoda zapewnia byłby następujący zapis tylko dane lub zarówno dane i schemat z <xref:System.Data.DataTable> do dokumentu XML, natomiast <xref:System.Data.DataTable.WriteXmlSchema%2A> metoda zapisuje tylko schemat. Do zapisania danych i schemat, użyj jednego z przeciążeń, które obejmuje <xref:System.Data.XmlWriteMode> parametru i ustawić jej wartość na `WriteSchema`.  
  
 Należy pamiętać, że dotyczy to także <xref:System.Data.DataTable.ReadXml%2A> i <xref:System.Data.DataTable.ReadXmlSchema%2A> metod, odpowiednio. Do odczytywania danych XML lub schemat i dane `DataTable`, użyj `ReadXml` metody. Aby dowiedzieć się sam schemat, należy użyć `ReadXmlSchema` metody.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Zostanie zgłoszony, jeśli typ kolumny w `DataRow` trwa od zapisu lub odczytu implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> implementuje <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.TextWriter * bool -&gt; unit" Usage="dataTable.WriteXml (writer, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.IO.TextWriter" /> Umożliwiającą zapis zawartości.</param>
        <param name="writeHierarchy">Jeśli <see langword="true" />, zapisywanie zawartości w bieżącej tabeli i wszystkie jego elementy podrzędne. Jeśli <see langword="false" /> (wartość domyślna), zapis danych dla bieżącej tabeli.</param>
        <summary>Zapisuje zawartość bieżącego <see cref="T:System.Data.DataTable" /> jako XML przy użyciu określonego <see cref="T:System.IO.TextWriter" />. Aby zapisać dane w tabeli i wszystkie jego elementy podrzędne, ustaw <paramref name="writeHierarchy" /> parametr <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> Metoda zapewnia byłby następujący zapis tylko dane lub zarówno dane i schemat z <xref:System.Data.DataTable> do dokumentu XML, natomiast <xref:System.Data.DataTable.WriteXmlSchema%2A> metoda zapisuje tylko schemat. Do zapisania danych i schemat, użyj jednego z przeciążeń, które obejmuje <xref:System.Data.XmlWriteMode> parametru i ustawić jej wartość na `WriteSchema`.  
  
 Zwykle `WriteXml` metoda zapisuje dane tylko dla bieżącej tabeli. Aby zapisać dane dla bieżącej tabeli i wszystkich jego elementów podrzędnych, powiązanych tabelach, wywołaj metodę z `writeHierarchy` parametr `true`.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Zostanie zgłoszony, jeśli typ kolumny w `DataRow` trwa od zapisu lub odczytu implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> implementuje <xref:System.Xml.Serialization.IXmlSerializable>.  
  
   
  
## Examples  
 Następująca aplikacja konsoli tworzy dwa <xref:System.Data.DataTable> wystąpień, dodaje do <xref:System.Data.DataSet>, tworzy <xref:System.Data.DataRelation> odnoszących się dwie tabele, a następnie używa <xref:System.Data.DataTable.WriteXml%2A> metody do zapisania danych zawartych w tabeli nadrzędnej do <xref:System.IO.TextWriter>. W przykładzie pokazano zachowanie podczas ustawiania `writeHierarchy` parametr `true`.  
  
 [!code-csharp[DataWorks DataTable.WriteXml#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXml/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXml#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXml/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.TextWriter * System.Data.XmlWriteMode -&gt; unit" Usage="dataTable.WriteXml (writer, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.IO.TextWriter" /> Używany do zapisywania dokumentu.</param>
        <param name="mode">Jedną z <see cref="T:System.Data.XmlWriteMode" /> wartości.</param>
        <summary>Zapisuje bieżące dane i opcjonalnie schemat dla <see cref="T:System.Data.DataTable" /> przy użyciu określonego <see cref="T:System.IO.TextWriter" /> i <see cref="T:System.Data.XmlWriteMode" />. Aby zapisać schemat, należy ustawić wartość <paramref name="mode" /> parametr <see langword="WriteSchema" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> Metoda zapewnia byłby następujący zapis tylko dane lub zarówno dane i schemat z <xref:System.Data.DataTable> do dokumentu XML, natomiast <xref:System.Data.DataTable.WriteXmlSchema%2A> metoda zapisuje tylko schemat. Do zapisania danych i schemat, użyj jednego z przeciążeń, które obejmuje <xref:System.Data.XmlWriteMode> parametru i ustawić jej wartość na `WriteSchema`.  
  
 Należy pamiętać, że dotyczy to także <xref:System.Data.DataTable.ReadXml%2A> i <xref:System.Data.DataTable.ReadXmlSchema%2A> metod, odpowiednio. Do odczytywania danych XML lub schemat i dane `DataTable`, użyj `ReadXml` metody. Aby dowiedzieć się sam schemat, należy użyć `ReadXmlSchema` metody.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Zostanie zgłoszony, jeśli typ kolumny w `DataRow` trwa od zapisu lub odczytu implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> implementuje <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : string * bool -&gt; unit" Usage="dataTable.WriteXml (fileName, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="fileName">Plik, do którego można zapisywać dane XML.</param>
        <param name="writeHierarchy">Jeśli <see langword="true" />, zapisywanie zawartości w bieżącej tabeli i wszystkie jego elementy podrzędne. Jeśli <see langword="false" /> (wartość domyślna), zapis danych dla bieżącej tabeli.</param>
        <summary>Zapisuje zawartość bieżącego <see cref="T:System.Data.DataTable" /> jako XML przy użyciu określonego pliku. Aby zapisać dane w tabeli i wszystkie jego elementy podrzędne, ustaw <paramref name="writeHierarchy" /> parametr <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> Metoda zapewnia byłby następujący zapis tylko dane lub zarówno dane i schemat z <xref:System.Data.DataTable> do dokumentu XML, natomiast <xref:System.Data.DataTable.WriteXmlSchema%2A> metoda zapisuje tylko schemat. Do zapisania danych i schemat, użyj jednego z przeciążeń, które obejmuje <xref:System.Data.XmlWriteMode> parametru i ustawić jej wartość na `WriteSchema`.  
  
 Należy pamiętać, że dotyczy to także <xref:System.Data.DataTable.ReadXml%2A> i <xref:System.Data.DataTable.ReadXmlSchema%2A> metod, odpowiednio. Do odczytywania danych XML lub schemat i dane `DataTable`, użyj `ReadXml` metody. Aby dowiedzieć się sam schemat, należy użyć `ReadXmlSchema` metody.  
  
 Zwykle `WriteXml` metoda zapisuje dane tylko dla bieżącej tabeli. Można zapisać danych w bieżącej tabeli i wszystkich jego elementów podrzędnych, powiązanych tabelach, wywołaj metodę z `writeHierarchy` parametr `true`.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Zostanie zgłoszony, jeśli typ kolumny w `DataRow` trwa od zapisu lub odczytu implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> implementuje <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : string * System.Data.XmlWriteMode -&gt; unit" Usage="dataTable.WriteXml (fileName, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="fileName">Nazwa pliku, do którego będą zapisywane dane.</param>
        <param name="mode">Jedną z <see cref="T:System.Data.XmlWriteMode" /> wartości.</param>
        <summary>Zapisuje bieżące dane i opcjonalnie schemat dla <see cref="T:System.Data.DataTable" /> przy użyciu określonego pliku i <see cref="T:System.Data.XmlWriteMode" />. Aby zapisać schemat, należy ustawić wartość <paramref name="mode" /> parametr <see langword="WriteSchema" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> Metoda zapewnia byłby następujący zapis tylko dane lub zarówno dane i schemat z <xref:System.Data.DataTable> do dokumentu XML, natomiast <xref:System.Data.DataTable.WriteXmlSchema%2A> metoda zapisuje tylko schemat. Aby napisać, danych i schemat, użyj jednego z przeciążeń, które obejmują <xref:System.Data.XmlWriteMode> parametru i ustawić jej wartość na `WriteSchema`.  
  
 Należy pamiętać, że dotyczy to także <xref:System.Data.DataTable.ReadXml%2A> i <xref:System.Data.DataTable.ReadXmlSchema%2A> metod, odpowiednio. Do odczytywania danych XML lub schemat i dane `DataTable`, użyj `ReadXml` metody. Aby dowiedzieć się sam schemat, należy użyć `ReadXmlSchema` metody.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Zostanie zgłoszony, jeśli typ kolumny w `DataRow` trwa od zapisu lub odczytu implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> implementuje <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.Xml.XmlWriter * bool -&gt; unit" Usage="dataTable.WriteXml (writer, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.Xml.XmlWriter" /> Umożliwiającą zapis zawartości.</param>
        <param name="writeHierarchy">Jeśli <see langword="true" />, zapisywanie zawartości w bieżącej tabeli i wszystkie jego elementy podrzędne. Jeśli <see langword="false" /> (wartość domyślna), zapis danych dla bieżącej tabeli.</param>
        <summary>Zapisuje zawartość bieżącego <see cref="T:System.Data.DataTable" /> jako XML przy użyciu określonego <see cref="T:System.Xml.XmlWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> Metoda zapewnia byłby następujący zapis tylko dane lub zarówno dane i schemat z <xref:System.Data.DataTable> do dokumentu XML, natomiast <xref:System.Data.DataTable.WriteXmlSchema%2A> metoda zapisuje tylko schemat. Aby napisać, danych i schemat, użyj jednego z przeciążeń, które obejmują <xref:System.Data.XmlWriteMode> parametru i ustawić jej wartość na `WriteSchema`.  
  
 Należy pamiętać, że dotyczy to także <xref:System.Data.DataTable.ReadXml%2A> i <xref:System.Data.DataTable.ReadXmlSchema%2A> metod, odpowiednio. Do odczytywania danych XML lub schemat i dane `DataTable`, użyj `ReadXml` metody. Aby dowiedzieć się sam schemat, należy użyć `ReadXmlSchema` metody.  
  
 Zwykle `WriteXml` metoda zapisuje dane tylko dla bieżącej tabeli. Aby zapisać dane dla bieżącej tabeli i jego całych tabel podrzędnych, powiązane, należy wywołać metodę z `writeHierarchy` parametr `true`.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Zostanie zgłoszony, jeśli typ kolumny w `DataRow` trwa od zapisu lub odczytu implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> implementuje <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer, System::Data::XmlWriteMode mode);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.Xml.XmlWriter * System.Data.XmlWriteMode -&gt; unit" Usage="dataTable.WriteXml (writer, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.Xml.XmlWriter" /> Używany do zapisywania dokumentu.</param>
        <param name="mode">Jedną z <see cref="T:System.Data.XmlWriteMode" /> wartości.</param>
        <summary>Zapisuje bieżące dane i opcjonalnie schemat dla <see cref="T:System.Data.DataTable" /> przy użyciu określonego <see cref="T:System.Xml.XmlWriter" /> i <see cref="T:System.Data.XmlWriteMode" />. Aby zapisać schemat, należy ustawić wartość <paramref name="mode" /> parametr <see langword="WriteSchema" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> Metoda zapewnia byłby następujący zapis tylko dane lub zarówno dane i schemat z <xref:System.Data.DataTable> do dokumentu XML, natomiast <xref:System.Data.DataTable.WriteXmlSchema%2A> metoda zapisuje tylko schemat. Aby napisać, danych i schemat, użyj jednego z przeciążeń, które obejmują <xref:System.Data.XmlWriteMode> parametru i ustawić jej wartość na `WriteSchema`.  
  
 Należy pamiętać, że dotyczy to także <xref:System.Data.DataTable.ReadXml%2A> i <xref:System.Data.DataTable.ReadXmlSchema%2A> metod, odpowiednio. Do odczytywania danych XML lub schemat i dane `DataTable`, użyj `ReadXml` metody. Aby dowiedzieć się sam schemat, należy użyć `ReadXmlSchema` metody.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Zostanie zgłoszony, jeśli typ kolumny w `DataRow` trwa od zapisu lub odczytu implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> implementuje <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream, System.Data.XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream, valuetype System.Data.XmlWriteMode mode, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream, System::Data::XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.Stream * System.Data.XmlWriteMode * bool -&gt; unit" Usage="dataTable.WriteXml (stream, mode, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">Strumień, do którego będą zapisywane dane.</param>
        <param name="mode">Jedną z <see cref="T:System.Data.XmlWriteMode" /> wartości.</param>
        <param name="writeHierarchy">Jeśli <see langword="true" />, zapisywanie zawartości w bieżącej tabeli i wszystkie jego elementy podrzędne. Jeśli <see langword="false" /> (wartość domyślna), zapis danych dla bieżącej tabeli.</param>
        <summary>Zapisuje bieżące dane i opcjonalnie schemat dla <see cref="T:System.Data.DataTable" /> do określonego pliku przy użyciu określonego <see cref="T:System.Data.XmlWriteMode" />. Aby zapisać schemat, należy ustawić wartość <paramref name="mode" /> parametr <see langword="WriteSchema" />. Aby zapisać dane w tabeli i wszystkie jego elementy podrzędne, ustaw <paramref name="writeHierarchy" /> parametr <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> Metoda zapewnia byłby następujący zapis tylko dane lub zarówno dane i schemat z `DataTable` do dokumentu XML, natomiast <xref:System.Data.DataTable.WriteXmlSchema%2A> metoda zapisuje tylko schemat. Do zapisania danych i schemat, użyj jednego z przeciążeń, które obejmuje `XmlWriteMode` parametru i ustawić jej wartość na `WriteSchema`.  
  
 Należy pamiętać, że dotyczy to także <xref:System.Data.DataTable.ReadXml%2A> i <xref:System.Data.DataTable.ReadXmlSchema%2A> metod, odpowiednio. Do odczytywania danych XML lub schemat i dane `DataTable`, użyj `ReadXml` metody. Aby dowiedzieć się sam schemat, należy użyć `ReadXmlSchema` metody.  
  
 Zwykle `WriteXml` metoda zapisuje dane tylko dla bieżącej tabeli. `WriteXml` Metoda zapewnia byłby następujący zapis tylko dane lub zarówno dane i schemat z `DataTable` do dokumentu XML, natomiast `WriteXmlSchema` metoda zapisuje tylko schemat. Do zapisania danych i schemat, użyj jednego z przeciążeń, które obejmuje `XmlWriteMode` parametru i ustawić jej wartość na `WriteSchema`.  
  
 Należy pamiętać, że dotyczy to także <xref:System.Data.DataTable.ReadXml%2A> i <xref:System.Data.DataTable.ReadXmlSchema%2A> metod, odpowiednio. Do odczytywania danych XML lub schemat i dane `DataTable`, użyj `ReadXml` metody. Aby dowiedzieć się sam schemat, należy użyć `ReadXmlSchema` metody.  
  
 Zwykle `WriteXml` metoda zapisuje dane tylko dla bieżącej tabeli. Można zapisać danych w bieżącej tabeli i wszystkich jego elementów podrzędnych, powiązanych tabelach, wywołaj metodę z `writeHierarchy` parametr `true`.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Zostanie zgłoszony, jeśli typ kolumny w `DataRow` trwa od zapisu lub odczytu implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> implementuje <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer, System.Data.XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer, valuetype System.Data.XmlWriteMode mode, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter, mode As XmlWriteMode, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer, System::Data::XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.IO.TextWriter * System.Data.XmlWriteMode * bool -&gt; unit" Usage="dataTable.WriteXml (writer, mode, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.IO.TextWriter" /> Używany do zapisywania dokumentu.</param>
        <param name="mode">Jedną z <see cref="T:System.Data.XmlWriteMode" /> wartości.</param>
        <param name="writeHierarchy">Jeśli <see langword="true" />, zapisywanie zawartości w bieżącej tabeli i wszystkie jego elementy podrzędne. Jeśli <see langword="false" /> (wartość domyślna), zapis danych dla bieżącej tabeli.</param>
        <summary>Zapisuje bieżące dane i opcjonalnie schemat dla <see cref="T:System.Data.DataTable" /> przy użyciu określonego <see cref="T:System.IO.TextWriter" /> i <see cref="T:System.Data.XmlWriteMode" />. Aby zapisać schemat, należy ustawić wartość <paramref name="mode" /> parametr <see langword="WriteSchema" />. Aby zapisać dane w tabeli i wszystkie jego elementy podrzędne, ustaw <paramref name="writeHierarchy" /> parametr <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> Metoda zapewnia byłby następujący zapis tylko dane lub zarówno dane i schemat z <xref:System.Data.DataTable> do dokumentu XML, natomiast <xref:System.Data.DataTable.WriteXmlSchema%2A> metoda zapisuje tylko schemat. Do zapisania danych i schemat, użyj jednego z przeciążeń, które obejmuje <xref:System.Data.XmlWriteMode> parametru i ustawić jej wartość na `WriteSchema`.  
  
 Należy pamiętać, że dotyczy to także <xref:System.Data.DataTable.ReadXml%2A> i <xref:System.Data.DataTable.ReadXmlSchema%2A> metod, odpowiednio. Do odczytywania danych XML lub schemat i dane `DataTable`, użyj `ReadXml` metody. Aby dowiedzieć się sam schemat, należy użyć `ReadXmlSchema` metody.  
  
 Zwykle `WriteXml` metoda zapisuje dane tylko dla bieżącej tabeli. <xref:System.Data.DataTable.WriteXml%2A> Metoda zapewnia byłby następujący zapis tylko dane lub zarówno dane i schemat z <xref:System.Data.DataTable> do dokumentu XML, natomiast <xref:System.Data.DataTable.WriteXmlSchema%2A> metoda zapisuje tylko schemat. Do zapisania danych i schemat, użyj jednego z przeciążeń, które obejmuje <xref:System.Data.XmlWriteMode> parametru i ustawić jej wartość na `WriteSchema`.  
  
 Należy pamiętać, że dotyczy to także <xref:System.Data.DataTable.ReadXml%2A> i <xref:System.Data.DataTable.ReadXmlSchema%2A> metod, odpowiednio. Do odczytywania danych XML lub schemat i dane `DataTable`, użyj `ReadXml` metody. Aby dowiedzieć się sam schemat, należy użyć `ReadXmlSchema` metody.  
  
 Zwykle `WriteXml` metoda zapisuje dane tylko dla bieżącej tabeli. Można zapisać danych w bieżącej tabeli i wszystkich jego elementów podrzędnych, powiązanych tabelach, wywołaj metodę z `writeHierarchy` parametr `true`.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Zostanie zgłoszony, jeśli typ kolumny w `DataRow` trwa od zapisu lub odczytu implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> implementuje <xref:System.Xml.Serialization.IXmlSerializable>.  
  
   
  
## Examples  
 Następująca aplikacja konsoli tworzy dwa <xref:System.Data.DataTable> wystąpień, dodaje do <xref:System.Data.DataSet>, tworzy <xref:System.Data.DataRelation> odnoszących się dwie tabele, a następnie używa <xref:System.Data.DataTable.WriteXml%2A> metody do zapisania danych zawartych w tabeli nadrzędnej do <xref:System.IO.TextWriter>. W przykładzie pokazano zachowanie podczas ustawiania `writeHierarchy` parametru do każdego z jego wartości.  
  
 [!code-csharp[DataWorks DataTable.WriteXmlIO#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlIO/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXmlIO#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlIO/VB/source.vb#1)]  
  
 W przykładzie są wyświetlane następujące dane wyjściowe w oknie konsoli:  
  
```  
==============================  
Customer table, without hierarchy  
==============================  
<NewDataSet>  
  <xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema  
" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
    <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
      <xs:complexType>  
        <xs:choice minOccurs="0" maxOccurs="unbounded">  
          <xs:element name="Table1">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="ID" type="xs:int" />  
                <xs:element name="Name" type="xs:string" minOccurs="0" />  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
        </xs:choice>  
      </xs:complexType>  
      <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table1" />  
        <xs:field xpath="ID" />  
      </xs:unique>  
    </xs:element>  
  </xs:schema>  
  <Table1>  
    <ID>1</ID>  
    <Name>Mary</Name>  
  </Table1>  
  <Table1>  
    <ID>2</ID>  
    <Name>Andy</Name>  
  </Table1>  
  <Table1>  
    <ID>3</ID>  
    <Name>Peter</Name>  
  </Table1>  
  <Table1>  
    <ID>4</ID>  
    <Name>Russ</Name>  
  </Table1>  
</NewDataSet>  
==============================  
Customer table, with hierarchy  
==============================  
<NewDataSet>  
  <xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema  
" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
    <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
      <xs:complexType>  
        <xs:choice minOccurs="0" maxOccurs="unbounded">  
          <xs:element name="Table1">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="ID" type="xs:int" />  
                <xs:element name="Name" type="xs:string" minOccurs="0" />  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
          <xs:element name="Table2">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="OrderID" type="xs:int" />  
                <xs:element name="CustomerID" type="xs:int" minOccurs="0" />  
                <xs:element name="OrderDate" type="xs:dateTime" minOccurs="0" />  
  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
        </xs:choice>  
      </xs:complexType>  
      <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table1" />  
        <xs:field xpath="ID" />  
      </xs:unique>  
      <xs:unique name="Table2_Constraint1" msdata:ConstraintName="Constraint1" m  
sdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table2" />  
        <xs:field xpath="OrderID" />  
      </xs:unique>  
      <xs:keyref name="CustomerOrder" refer="Constraint1">  
        <xs:selector xpath=".//Table2" />  
        <xs:field xpath="CustomerID" />  
      </xs:keyref>  
    </xs:element>  
  </xs:schema>  
  <Table1>  
    <ID>1</ID>  
    <Name>Mary</Name>  
  </Table1>  
  <Table1>  
    <ID>2</ID>  
    <Name>Andy</Name>  
  </Table1>  
  <Table1>  
    <ID>3</ID>  
    <Name>Peter</Name>  
  </Table1>  
  <Table1>  
    <ID>4</ID>  
    <Name>Russ</Name>  
  </Table1>  
  <Table2>  
    <OrderID>1</OrderID>  
    <CustomerID>1</CustomerID>  
    <OrderDate>2003-12-02T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>2</OrderID>  
    <CustomerID>1</CustomerID>  
    <OrderDate>2004-01-03T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>3</OrderID>  
    <CustomerID>2</CustomerID>  
    <OrderDate>2004-11-13T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>4</OrderID>  
    <CustomerID>3</CustomerID>  
    <OrderDate>2004-05-16T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>5</OrderID>  
    <CustomerID>3</CustomerID>  
    <OrderDate>2004-05-22T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>6</OrderID>  
    <CustomerID>4</CustomerID>  
    <OrderDate>2004-06-15T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
</NewDataSet>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName, System.Data.XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName, valuetype System.Data.XmlWriteMode mode, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String, mode As XmlWriteMode, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName, System::Data::XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : string * System.Data.XmlWriteMode * bool -&gt; unit" Usage="dataTable.WriteXml (fileName, mode, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="fileName">Nazwa pliku, do którego będą zapisywane dane.</param>
        <param name="mode">Jedną z <see cref="T:System.Data.XmlWriteMode" /> wartości.</param>
        <param name="writeHierarchy">Jeśli <see langword="true" />, zapisywanie zawartości w bieżącej tabeli i wszystkie jego elementy podrzędne. Jeśli <see langword="false" /> (wartość domyślna), zapis danych dla bieżącej tabeli.</param>
        <summary>Zapisuje bieżące dane i opcjonalnie schemat dla <see cref="T:System.Data.DataTable" /> przy użyciu określonego pliku i <see cref="T:System.Data.XmlWriteMode" />. Aby zapisać schemat, należy ustawić wartość <paramref name="mode" /> parametr <see langword="WriteSchema" />. Aby zapisać dane w tabeli i wszystkie jego elementy podrzędne, ustaw <paramref name="writeHierarchy" /> parametr <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> Metoda zapewnia byłby następujący zapis tylko dane lub zarówno dane i schemat z <xref:System.Data.DataTable> do dokumentu XML, natomiast <xref:System.Data.DataTable.WriteXmlSchema%2A> metoda zapisuje tylko schemat. Aby napisać, danych i schemat, użyj jednego z przeciążeń, które obejmują <xref:System.Data.XmlWriteMode> parametru i ustawić jej wartość na `WriteSchema`.  
  
 Należy pamiętać, że dotyczy to także <xref:System.Data.DataTable.ReadXml%2A> i <xref:System.Data.DataTable.ReadXmlSchema%2A> metod, odpowiednio. Do odczytywania danych XML lub schemat i dane `DataTable`, użyj `ReadXml` metody. Aby dowiedzieć się sam schemat, należy użyć `ReadXmlSchema` metody.  
  
 Zwykle `WriteXml` metoda zapisuje dane tylko dla bieżącej tabeli. Jeśli chcesz zapisać dane dla bieżącej tabeli i wszystkich schematów, <xref:System.Data.DataTable.WriteXml%2A> metoda zapewnia byłby następujący zapis tylko dane lub zarówno dane i schemat z <xref:System.Data.DataTable> do dokumentu XML, natomiast <xref:System.Data.DataTable.WriteXmlSchema%2A> metoda zapisuje tylko schemat. Aby napisać, danych i schemat, użyj jednego z przeciążeń, które obejmują <xref:System.Data.XmlWriteMode> parametru i ustawić jej wartość na `WriteSchema`.  
  
 Należy pamiętać, że dotyczy to także <xref:System.Data.DataTable.ReadXml%2A> i <xref:System.Data.DataTable.ReadXmlSchema%2A> metod, odpowiednio. Do odczytywania danych XML lub schemat i dane `DataTable`, użyj `ReadXml` metody. Aby dowiedzieć się sam schemat, należy użyć `ReadXmlSchema` metody.  
  
 Zwykle `WriteXml` metoda zapisuje dane tylko dla bieżącej tabeli. Aby zapisać dane dla bieżącej tabeli i wszystkie podrzędne, powiązanych tabelach, wywołaj metodę z `writeHierarchy` parametr `true`.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Zostanie zgłoszony, jeśli typ kolumny w `DataRow` trwa od zapisu lub odczytu implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> implementuje <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer, System.Data.XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer, valuetype System.Data.XmlWriteMode mode, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter, mode As XmlWriteMode, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer, System::Data::XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXml : System.Xml.XmlWriter * System.Data.XmlWriteMode * bool -&gt; unit" Usage="dataTable.WriteXml (writer, mode, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.Xml.XmlWriter" /> Używany do zapisywania dokumentu.</param>
        <param name="mode">Jedną z <see cref="T:System.Data.XmlWriteMode" /> wartości.</param>
        <param name="writeHierarchy">Jeśli <see langword="true" />, zapisywanie zawartości w bieżącej tabeli i wszystkie jego elementy podrzędne. Jeśli <see langword="false" /> (wartość domyślna), zapis danych dla bieżącej tabeli.</param>
        <summary>Zapisuje bieżące dane i opcjonalnie schemat dla <see cref="T:System.Data.DataTable" /> przy użyciu określonego <see cref="T:System.Xml.XmlWriter" /> i <see cref="T:System.Data.XmlWriteMode" />. Aby zapisać schemat, należy ustawić wartość <paramref name="mode" /> parametr <see langword="WriteSchema" />. Aby zapisać dane w tabeli i wszystkie jego elementy podrzędne, ustaw <paramref name="writeHierarchy" /> parametr <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> Metoda zapewnia byłby następujący zapis tylko dane lub zarówno dane i schemat z <xref:System.Data.DataTable> do dokumentu XML, natomiast <xref:System.Data.DataTable.WriteXmlSchema%2A> metoda zapisuje tylko schemat. Aby napisać, danych i schemat, użyj jednego z przeciążeń, które obejmują <xref:System.Data.XmlWriteMode> parametru i ustawić jej wartość na `WriteSchema`.  
  
 Należy pamiętać, że dotyczy to także <xref:System.Data.DataTable.ReadXml%2A> i <xref:System.Data.DataTable.ReadXmlSchema%2A> metod, odpowiednio. Do odczytywania danych XML lub schemat i dane `DataTable`, użyj `ReadXml` metody. Aby dowiedzieć się sam schemat, należy użyć `ReadXmlSchema` metody.  
  
 Zwykle `WriteXml` metoda zapisuje dane tylko dla bieżącej tabeli. Aby zapisać dane dla bieżącej tabeli i jego całych tabel podrzędnych, powiązane, należy wywołać metodę z `writeHierarchy` parametr `true`.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Zostanie zgłoszony, jeśli typ kolumny w `DataRow` trwa od zapisu lub odczytu implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> implementuje <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteXmlSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapisuje bieżący struktury danych <see cref="T:System.Data.DataTable" /> jako schematu XML.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Data.DataTable.WriteXmlSchema%2A> metodę, aby zapisać schematu dla <xref:System.Data.DataTable> do dokumentu XML. Schemat zawiera definicje tabeli, relacji i ograniczenia.  
  
 Schemat XML są zapisywane przy użyciu standardu XSD.  
  
 Aby zapisać dane w dokumencie XML, należy użyć <xref:System.Data.DataTable.WriteXml%2A> metody.  
  
   
  
## Examples  
 Następująca aplikacja konsoli tworzy dwa <xref:System.Data.DataTable> wystąpień, dodaje do <xref:System.Data.DataSet>, tworzy <xref:System.Data.DataRelation> odnoszących się dwie tabele, a następnie używa <xref:System.Data.DataTable.WriteXmlSchema%2A> metody do zapisania danych zawartych w tabeli nadrzędnej do <xref:System.IO.TextWriter>. W przykładzie pokazano zachowanie podczas ustawiania `writeHierarchy` parametru do każdego z jego wartości.  
  
> [!NOTE]
>  W tym przykładzie pokazano, jak użyć jednej z przeciążone wersje `WriteXmlSchema` inne przykłady, które mogą być dostępne, można znaleźć w tematach poszczególnych przeciążeń.  
  
 [!code-csharp[DataWorks DataTable.WriteXmlSchemaOverload#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlSchemaOverload/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXmlSchemaOverload#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlSchemaOverload/VB/source.vb#1)]  
  
 W przykładzie są wyświetlane następujące dane wyjściowe w oknie konsoli:  
  
```  
==============================  
Customer table, without hierarchy  
==============================  
<?xml version="1.0" encoding="utf-16"?>  
<xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema"  
xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Ta  
ble1">  
    <xs:complexType>  
      <xs:choice minOccurs="0" maxOccurs="unbounded">  
        <xs:element name="Table1">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="ID" type="xs:int" />  
              <xs:element name="Name" type="xs:string" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
      </xs:choice>  
    </xs:complexType>  
    <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table1" />  
      <xs:field xpath="ID" />  
    </xs:unique>  
  </xs:element>  
</xs:schema>  
==============================  
Customer table, with hierarchy  
==============================  
<?xml version="1.0" encoding="utf-16"?>  
<xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema"  
xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
    <xs:complexType>  
      <xs:choice minOccurs="0" maxOccurs="unbounded">  
        <xs:element name="Table1">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="ID" type="xs:int" />  
              <xs:element name="Name" type="xs:string" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
        <xs:element name="Table2">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="OrderID" type="xs:int" />  
              <xs:element name="CustomerID" type="xs:int" minOccurs="0" />  
              <xs:element name="OrderDate" type="xs:dateTime" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
      </xs:choice>  
    </xs:complexType>  
    <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table1" />  
      <xs:field xpath="ID" />  
    </xs:unique>  
    <xs:unique name="Table2_Constraint1" msdata:ConstraintName="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table2" />  
      <xs:field xpath="OrderID" />  
    </xs:unique>  
    <xs:keyref name="CustomerOrder" refer="Constraint1">  
      <xs:selector xpath=".//Table2" />  
      <xs:field xpath="CustomerID" />  
    </xs:keyref>  
  </xs:element>  
</xs:schema>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.Stream -&gt; unit" Usage="dataTable.WriteXmlSchema stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Strumień, do której zostanie zapisany schematu XML.</param>
        <summary>Zapisuje bieżący struktury danych <see cref="T:System.Data.DataTable" /> jako schematu XML do określonego strumienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Data.DataTable.WriteXmlSchema%2A> metodę, aby zapisać schematu dla <xref:System.Data.DataTable> do dokumentu XML. Schemat zawiera definicje tabeli, relacji i ograniczenia.  
  
 Schemat XML są zapisywane przy użyciu standardu XSD.  
  
 Aby zapisać dane w dokumencie XML, należy użyć <xref:System.Data.DataTable.WriteXml%2A> metody.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.TextWriter -&gt; unit" Usage="dataTable.WriteXmlSchema writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.IO.TextWriter" /> Za pomocą którego można zapisywać.</param>
        <summary>Zapisuje bieżący struktury danych <see cref="T:System.Data.DataTable" /> jako schematu XML przy użyciu określonego <see cref="T:System.IO.TextWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Data.DataTable.WriteXmlSchema%2A> metodę, aby zapisać schematu dla <xref:System.Data.DataTable> do dokumentu XML. Schemat zawiera definicje tabeli, relacji i ograniczenia.  
  
 Schemat XML są zapisywane przy użyciu standardu XSD.  
  
 Aby zapisać dane w dokumencie XML, należy użyć <xref:System.Data.DataTable.WriteXml%2A> metody.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : string -&gt; unit" Usage="dataTable.WriteXmlSchema fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nazwa pliku, który będzie używany.</param>
        <summary>Zapisuje bieżący struktury danych <see cref="T:System.Data.DataTable" /> jako schematu XML do określonego pliku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Data.DataTable.WriteXmlSchema%2A> metodę, aby zapisać schematu dla <xref:System.Data.DataTable> do dokumentu XML. Schemat zawiera definicje tabeli, relacji i ograniczenia.  
  
 Schemat XML są zapisywane przy użyciu standardu XSD.  
  
 Aby zapisać dane w dokumencie XML, należy użyć <xref:System.Data.DataTable.WriteXml%2A> metody.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.Xml.XmlWriter -&gt; unit" Usage="dataTable.WriteXmlSchema writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.Xml.XmlWriter" /> Do użycia.</param>
        <summary>Zapisuje bieżący struktury danych <see cref="T:System.Data.DataTable" /> jako schematu XML przy użyciu określonego <see cref="T:System.Xml.XmlWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Data.DataTable.WriteXmlSchema%2A> metodę, aby zapisać schematu dla <xref:System.Data.DataTable> do dokumentu XML. Schemat zawiera definicje tabeli, relacji i ograniczenia.  
  
 Schemat XML są zapisywane przy użyciu standardu XSD.  
  
 Aby zapisać dane w dokumencie XML, należy użyć <xref:System.Data.DataTable.WriteXml%2A> metody.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.Stream stream, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.Stream stream, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.IO.Stream,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::Stream ^ stream, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.Stream * bool -&gt; unit" Usage="dataTable.WriteXmlSchema (stream, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">Strumień, do której zostanie zapisany schematu XML.</param>
        <param name="writeHierarchy">Jeśli <see langword="true" />, zapisać schematu bieżącej tabeli i wszystkie jego elementy podrzędne. Jeśli <see langword="false" /> (wartość domyślna), zapis schematu dla bieżącej tabeli.</param>
        <summary>Zapisuje bieżący struktury danych <see cref="T:System.Data.DataTable" /> jako schematu XML do określonego strumienia. Aby zapisać schematu dla tabeli i wszystkich jego obiektów podrzędnych, ustawić <paramref name="writeHierarchy" /> parametr <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Data.DataTable.WriteXmlSchema%2A> metodę, aby zapisać schematu dla <xref:System.Data.DataTable> do dokumentu XML. Schemat zawiera definicje tabeli, relacji i ograniczenia.  
  
 Schemat XML są zapisywane przy użyciu standardu XSD.  
  
 Aby zapisać dane w dokumencie XML, należy użyć <xref:System.Data.DataTable.WriteXml%2A> metody.  
  
 Zwykle `WriteXmlSchema` metoda zapisuje schemat tylko dla bieżącej tabeli. Aby zapisać schematu dla bieżącej tabeli i jego całych tabel podrzędnych, powiązane, należy wywołać metodę z `writeHierarchy` parametr `true`.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.TextWriter writer, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.TextWriter writer, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.IO.TextWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As TextWriter, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::TextWriter ^ writer, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.IO.TextWriter * bool -&gt; unit" Usage="dataTable.WriteXmlSchema (writer, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.IO.TextWriter" /> Za pomocą którego można zapisywać.</param>
        <param name="writeHierarchy">Jeśli <see langword="true" />, zapisać schematu bieżącej tabeli i wszystkie jego elementy podrzędne. Jeśli <see langword="false" /> (wartość domyślna), zapis schematu dla bieżącej tabeli.</param>
        <summary>Zapisuje bieżący struktury danych <see cref="T:System.Data.DataTable" /> jako schematu XML przy użyciu określonego <see cref="T:System.IO.TextWriter" />. Aby zapisać schematu dla tabeli i wszystkich jego obiektów podrzędnych, ustawić <paramref name="writeHierarchy" /> parametr <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Data.DataTable.WriteXmlSchema%2A> metodę, aby zapisać schematu dla <xref:System.Data.DataTable> do dokumentu XML. Schemat zawiera definicje tabeli, relacji i ograniczenia.  
  
 Schemat XML są zapisywane przy użyciu standardu XSD.  
  
 Aby zapisać dane w dokumencie XML, należy użyć <xref:System.Data.DataTable.WriteXml%2A> metody.  
  
 Zwykle `WriteXmlSchema` metoda zapisuje schemat tylko dla bieżącej tabeli. Aby zapisać schematu dla bieżącej tabeli i jego całych tabel podrzędnych, powiązane, należy wywołać metodę z `writeHierarchy` parametr `true`.  
  
   
  
## Examples  
 Następująca aplikacja konsoli tworzy dwa <xref:System.Data.DataTable> wystąpień, dodaje do <xref:System.Data.DataSet>, tworzy <xref:System.Data.DataRelation> odnoszących się dwie tabele, a następnie używa <xref:System.Data.DataTable.WriteXmlSchema%2A> metody do zapisania danych zawartych w tabeli nadrzędnej do <xref:System.IO.TextWriter>. W przykładzie pokazano zachowanie podczas ustawiania `writeHierarchy` parametru do każdego z jego wartości.  
  
 [!code-csharp[DataWorks DataTable.WriteXmlSchema#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlSchema/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXmlSchema#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlSchema/VB/source.vb#1)]  
  
 W przykładzie są wyświetlane następujące dane wyjściowe w oknie konsoli:  
  
```  
==============================  
Customer table, without hierarchy  
==============================  
<?xml version="1.0" encoding="utf-16"?>  
<xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema"  
xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Ta  
ble1">  
    <xs:complexType>  
      <xs:choice minOccurs="0" maxOccurs="unbounded">  
        <xs:element name="Table1">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="ID" type="xs:int" />  
              <xs:element name="Name" type="xs:string" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
      </xs:choice>  
    </xs:complexType>  
    <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table1" />  
      <xs:field xpath="ID" />  
    </xs:unique>  
  </xs:element>  
</xs:schema>  
==============================  
Customer table, with hierarchy  
==============================  
<?xml version="1.0" encoding="utf-16"?>  
<xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema"  
xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
    <xs:complexType>  
      <xs:choice minOccurs="0" maxOccurs="unbounded">  
        <xs:element name="Table1">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="ID" type="xs:int" />  
              <xs:element name="Name" type="xs:string" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
        <xs:element name="Table2">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="OrderID" type="xs:int" />  
              <xs:element name="CustomerID" type="xs:int" minOccurs="0" />  
              <xs:element name="OrderDate" type="xs:dateTime" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
      </xs:choice>  
    </xs:complexType>  
    <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table1" />  
      <xs:field xpath="ID" />  
    </xs:unique>  
    <xs:unique name="Table2_Constraint1" msdata:ConstraintName="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table2" />  
      <xs:field xpath="OrderID" />  
    </xs:unique>  
    <xs:keyref name="CustomerOrder" refer="Constraint1">  
      <xs:selector xpath=".//Table2" />  
      <xs:field xpath="CustomerID" />  
    </xs:keyref>  
  </xs:element>  
</xs:schema>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (string fileName, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(string fileName, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (fileName As String, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::String ^ fileName, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : string * bool -&gt; unit" Usage="dataTable.WriteXmlSchema (fileName, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="fileName">Nazwa pliku, który będzie używany.</param>
        <param name="writeHierarchy">Jeśli <see langword="true" />, zapisać schematu bieżącej tabeli i wszystkie jego elementy podrzędne. Jeśli <see langword="false" /> (wartość domyślna), zapis schematu dla bieżącej tabeli.</param>
        <summary>Zapisuje bieżący struktury danych <see cref="T:System.Data.DataTable" /> jako schematu XML do określonego pliku. Aby zapisać schematu dla tabeli i wszystkich jego obiektów podrzędnych, ustawić <paramref name="writeHierarchy" /> parametr <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Data.DataTable.WriteXmlSchema%2A> metodę, aby zapisać schematu dla <xref:System.Data.DataTable> do dokumentu XML. Schemat zawiera definicje tabeli, relacji i ograniczenia.  
  
 Schemat XML są zapisywane przy użyciu standardu XSD.  
  
 Aby zapisać dane w dokumencie XML, należy użyć <xref:System.Data.DataTable.WriteXml%2A> metody.  
  
 Zwykle `WriteXmlSchema` metoda zapisuje schemat tylko dla bieżącej tabeli. Aby zapisać schematu dla bieżącej tabeli i jego całych tabel podrzędnych, powiązane, należy wywołać metodę z `writeHierarchy` parametr `true`.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.Xml.XmlWriter writer, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.Xml.XmlWriter writer, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.Xml.XmlWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As XmlWriter, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::Xml::XmlWriter ^ writer, bool writeHierarchy);" />
      <MemberSignature Language="F#" Value="member this.WriteXmlSchema : System.Xml.XmlWriter * bool -&gt; unit" Usage="dataTable.WriteXmlSchema (writer, writeHierarchy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.Xml.XmlWriter" /> Używany do zapisywania dokumentu.</param>
        <param name="writeHierarchy">Jeśli <see langword="true" />, zapisać schematu bieżącej tabeli i wszystkie jego elementy podrzędne. Jeśli <see langword="false" /> (wartość domyślna), zapis schematu dla bieżącej tabeli.</param>
        <summary>Zapisuje bieżący struktury danych <see cref="T:System.Data.DataTable" /> jako schematu XML przy użyciu określonego <see cref="T:System.Xml.XmlWriter" />. Aby zapisać schematu dla tabeli i wszystkich jego obiektów podrzędnych, ustawić <paramref name="writeHierarchy" /> parametr <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Data.DataTable.WriteXmlSchema%2A> metodę, aby zapisać schematu dla <xref:System.Data.DataTable> do dokumentu XML. Schemat zawiera definicje tabeli, relacji i ograniczenia.  
  
 Schemat XML są zapisywane przy użyciu standardu XSD.  
  
 Aby zapisać dane w dokumencie XML, należy użyć <xref:System.Data.DataTable.WriteXml%2A> metody.  
  
 Zwykle `WriteXmlSchema` metoda zapisuje schemat tylko dla bieżącej tabeli. Aby zapisać schematu dla bieżącej tabeli i jego całych tabel podrzędnych, powiązane, należy wywołać metodę z `writeHierarchy` parametr `true`.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/52ff0e32-3e5a-41de-9a3b-7b04ea52b83e">Tworzenie i używanie DataTables</related>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="DataTable" FullName="System.Data.DataTable">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ae2d2ca49781b6fbea2101bb4f63426c09bee1b1" />
    <Meta Name="ms.sourcegitcommit" Value="df6cf590aa3087f6c7c202712eee781c6a3c8f96" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="05/07/2018" />
    <Meta Name="ms.locfileid" Value="33685193" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class DataTable : System.ComponentModel.MarshalByValueComponent, System.ComponentModel.IListSource, System.ComponentModel.ISupportInitialize, System.ComponentModel.ISupportInitializeNotification, System.Runtime.Serialization.ISerializable, System.Xml.Serialization.IXmlSerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit DataTable extends System.ComponentModel.MarshalByValueComponent implements class System.ComponentModel.IListSource, class System.ComponentModel.ISupportInitialize, class System.ComponentModel.ISupportInitializeNotification, class System.Runtime.Serialization.ISerializable, class System.Xml.Serialization.IXmlSerializable" />
  <TypeSignature Language="DocId" Value="T:System.Data.DataTable" />
  <TypeSignature Language="VB.NET" Value="Public Class DataTable&#xA;Inherits MarshalByValueComponent&#xA;Implements IListSource, ISerializable, ISupportInitialize, ISupportInitializeNotification, IXmlSerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class DataTable : System::ComponentModel::MarshalByValueComponent, System::ComponentModel::IListSource, System::ComponentModel::ISupportInitialize, System::ComponentModel::ISupportInitializeNotification, System::Runtime::Serialization::ISerializable, System::Xml::Serialization::IXmlSerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Data.Common</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Data</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.MarshalByValueComponent</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.IListSource</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitializeNotification</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Xml.Serialization.IXmlSerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("RowChanging")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("TableName")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DesignTimeVisible(false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.DataTableEditor, Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItem(false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Xml.Serialization.XmlSchemaProvider("GetDataTableSchema")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje jedna tabela danych w pamięci.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable> Jest obiektem centralnej w bibliotece programu ADO.NET. Inne obiekty, które używają <xref:System.Data.DataTable> obejmują <xref:System.Data.DataSet> i <xref:System.Data.DataView>.  
  
 Podczas uzyskiwania dostępu do <xref:System.Data.DataTable> obiektów, należy pamiętać, że są one warunkowo z uwzględnieniem wielkości liter. Na przykład, jeśli jeden <xref:System.Data.DataTable> o nazwie "mydatatable" i drugiego o nazwie "Mydatatable", ciąg używany do wyszukania go tabel jest traktowany jako wielkość liter. Jednak jeśli istnieje "mydatatable" i "Mydatatable" nie ma, ciąg wyszukiwania jest traktowany jako bez uwzględniania wielkości liter. A <xref:System.Data.DataSet> może zawierać dwóch <xref:System.Data.DataTable> obiektów, które mają taki sam <xref:System.Data.DataTable.TableName%2A> wartość właściwości, ale o różnych <xref:System.Data.DataTable.Namespace%2A> wartości właściwości. Aby uzyskać więcej informacji na temat pracy z <xref:System.Data.DataTable> obiekty, zobacz [tworzenie DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/creating-a-datatable.md).  
  
 Jeśli tworzysz <xref:System.Data.DataTable> programowo, należy najpierw zdefiniować schematem przez dodanie <xref:System.Data.DataColumn> obiekty do <xref:System.Data.DataColumnCollection> (dostępnej za pośrednictwem <xref:System.Data.DataTable.Columns%2A> właściwości). Aby uzyskać więcej informacji o dodawaniu <xref:System.Data.DataColumn> obiekty, zobacz [Dodawanie kolumn do DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/adding-columns-to-a-datatable.md).  
  
 Aby dodać wierszy do <xref:System.Data.DataTable>, należy najpierw użyć <xref:System.Data.DataTable.NewRow%2A> metodę, aby zwrócić nowe <xref:System.Data.DataRow> obiektu. <xref:System.Data.DataTable.NewRow%2A> Metoda zwraca wiersza ze schematem <xref:System.Data.DataTable>, ponieważ jest on zdefiniowany w tabeli <xref:System.Data.DataColumnCollection>. Maksymalna liczba wierszy, które <xref:System.Data.DataTable> można magazyn jest 16,777,216. Aby uzyskać więcej informacji, zobacz [Dodawanie danych do elementu DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/adding-data-to-a-datatable.md).  
  
 <xref:System.Data.DataTable> Również zawiera kolekcję <xref:System.Data.Constraint> obiektów, które mogą służyć do zapewnienia integralności danych. Aby uzyskać więcej informacji, zobacz [ograniczenia DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/datatable-constraints.md).  
  
 Istnieje wiele <xref:System.Data.DataTable> zdarzenia, które mogą służyć do określenia, kiedy zmian w tabeli. Obejmują one <xref:System.Data.DataTable.RowChanged>, <xref:System.Data.DataTable.RowChanging>, <xref:System.Data.DataTable.RowDeleting>, i <xref:System.Data.DataTable.RowDeleted>. Aby uzyskać więcej informacji o zdarzeniach, które mogą być używane z <xref:System.Data.DataTable>, zobacz [obsługi zdarzeń DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md).  
  
 Gdy wystąpienie klasy <xref:System.Data.DataTable> jest tworzony, niektóre z odczytu/zapisu właściwości są ustawione na wartości początkowe. Aby uzyskać listę tych wartości, zobacz <xref:System.Data.DataTable.%23ctor%2A?displayProperty=nameWithType> tematu konstruktora.  
  
> [!NOTE]
>  <xref:System.Data.DataSet> i <xref:System.Data.DataTable> obiekty dziedziczyć <xref:System.ComponentModel.MarshalByValueComponent>i obsługuje <xref:System.Runtime.Serialization.ISerializable> interfejs dla niego komunikację zdalną środowiska .NET Framework. Są to jedyne obiekty ADO.NET, używanych do komunikacji zdalnej .NET Framework.  
  
   
  
## Examples  
 Poniższy przykład tworzy dwa <xref:System.Data.DataTable> obiektów i jeden <xref:System.Data.DataRelation> obiektu i dodaje nowe obiekty do <xref:System.Data.DataSet>. Tabele są następnie wyświetlane w <xref:System.Windows.Forms.DataGridView> formantu.  
  
 [!code-csharp[Classic WebData DataTable Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable Example/VB/source.vb#1)]  
  
 W tym przykładzie pokazano, jak ręcznie utworzyć DataTable z definicjami schematu:  
  
-   Tworzenie wielu DataTables i definiowanie początkowych kolumn.  
  
-   Tworzenie powiązanych tabel.  
  
-   Wstaw wartości i wyświetlania w tabelach.  
  
-   Utwórz wyrażenie kolumny i Wyświetl tabele.  
  
 C# i Visual Basic projektów z tym przykładowym kodzie można znaleźć w [przykłady kodu dewelopera](https://code.msdn.microsoft.com/How-to-create-DataTable-7abb4914).  
  
 [!code-csharp[Classic WebData DataTable Example2#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/classic webdata datatable example2/cs/source.cs#1)]
 [!code-vb[Classic WebData DataTable Example2#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/classic webdata datatable example2/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Tego typu są bezpieczne dla operacji wielowątkowych odczytu. Wszystkie operacje zapisu należy przeprowadzić synchronizację.</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Data.DataTable" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataTable ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataTable();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Data.DataTable" /> klasy bez argumentów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Konstruktor ustawia wartości początkowe dla wszystkich właściwości <xref:System.Data.DataTable> obiektu. W poniższej tabeli przedstawiono właściwości i ich wartości domyślne. Gdy wystąpienie klasy <xref:System.Data.DataTable> utworzono następujące właściwości są ustawione na wartości początkowe odczytu/zapisu.  
  
|Właściwość|Wartość domyślna|  
|--------------|-------------------|  
|**CaseSensitive**|Taki sam jak element nadrzędny <xref:System.Data.DataSet>, jeśli należy do jednego. W przeciwnym razie `false`.|  
|**DisplayExpression**|Pusty ciąg ("")|  
|**Wersja regionalna**|Taki sam jak element nadrzędny <xref:System.Data.DataSet> obiektu <xref:System.Globalization.CultureInfo> (zwrócony przez <xref:System.Data.DataSet.Locale%2A> właściwości); Jeśli nadrzędny nie istnieje, wartość domyślna to bieżący system <xref:System.Globalization.CultureInfo>.|  
|**MinimumCapacity**|50 wierszy.|  
  
 Można zmienić wartości dla żadnego z tych właściwości, za pomocą oddzielnego wywołania do właściwości.  
  
   
  
## Examples  
 Poniższy przykład tworzy nowy <xref:System.Data.DataTable> z <xref:System.Data.DataColumn> i <xref:System.Data.DataRow>i wyświetla je w <xref:System.Windows.Forms.DataGridView> formantu.  
  
 [!code-csharp[Classic WebData DataTable.DataTable Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.DataTable Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.DataTable Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.DataTable Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataTable (string tableName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string tableName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (tableName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataTable(System::String ^ tableName);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="tableName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="tableName">Nazwa umożliwiają tabeli. Jeśli <c>tableName</c> jest <see langword="null" /> lub pusty ciąg, domyślna nazwa znajduje się po dodaniu do <see cref="T:System.Data.DataTableCollection" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Data.DataTable" /> klasy o nazwie określonej tabeli.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład tworzy <xref:System.Data.DataTable> i wyświetla je w <xref:System.Windows.Forms.DataGridView> formantu.  
  
 [!code-csharp[Classic WebData DataTable.DataTable1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.DataTable1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.DataTable1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.DataTable1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DataTable (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DataTable(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Dane potrzebne do serializacji lub deserializacji obiektu.</param>
        <param name="context">Źródło i miejsce docelowe danego strumieniu serializowanym.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Data.DataTable" /> klasy z <see cref="T:System.Runtime.Serialization.SerializationInfo" /> i <see cref="T:System.Runtime.Serialization.StreamingContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta implementacja <xref:System.Data.DataTable> Konstruktor jest wymagany dla <xref:System.Runtime.Serialization.ISerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataTable (string tableName, string tableNamespace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string tableName, string tableNamespace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (tableName As String, tableNamespace As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataTable(System::String ^ tableName, System::String ^ tableNamespace);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="tableName" Type="System.String" />
        <Parameter Name="tableNamespace" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="tableName">Nazwa umożliwiają tabeli. Jeśli <c>tableName</c> jest <see langword="null" /> lub pusty ciąg, domyślna nazwa znajduje się po dodaniu do <see cref="T:System.Data.DataTableCollection" />.</param>
        <param name="tableNamespace">Obszar nazw XML reprezentację danych przechowywanych w <see langword="DataTable" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Data.DataTable" /> przy użyciu nazwy określonej tabeli i przestrzeni nazw.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AcceptChanges">
      <MemberSignature Language="C#" Value="public void AcceptChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcceptChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.AcceptChanges" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcceptChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcceptChanges();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zatwierdza wszystkie zmiany wprowadzone do tej tabeli od czasu ostatniego <see cref="M:System.Data.DataTable.AcceptChanges" /> została wywołana.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Data.DataTable.AcceptChanges%2A> po wywołaniu dowolnej <xref:System.Data.DataRow> obiektu nadal w trybie edycji kończy się pomyślnie jego edycji. <xref:System.Data.DataRowState> Zmieniają się także: wszystkie `Added` i `Modified` wierszy stają się `Unchanged`, i `Deleted` wiersze zostaną usunięte.  
  
 <xref:System.Data.DataTable.AcceptChanges%2A> Wywoływana jest metoda zazwyczaj <xref:System.Data.DataTable> po próbę aktualizacji <xref:System.Data.DataSet> przy użyciu <xref:System.Data.Common.DbDataAdapter.Update%2A?displayProperty=nameWithType> metody.  
  
   
  
## Examples  
 Poniższy przykład testy każdej tabeli błędów. Jeśli błędy tabeli można uzgodnić (przez przekazanie jej do niezdefiniowanej funkcji), <xref:System.Data.DataTable.AcceptChanges%2A> jest wywołana; w przeciwnym razie <xref:System.Data.DataTable.RejectChanges%2A> jest wywoływana.  
  
 [!code-csharp[Classic WebData DataTable.AcceptChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.AcceptChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.AcceptChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.AcceptChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public virtual void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rozpoczyna inicjowanie <see cref="T:System.Data.DataTable" /> który jest używany w formularzu lub używany przez inny składnik. Inicjowanie występuje w czasie wykonywania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Środowisku projektowania programu Visual Studio .NET używa tej metody, aby rozpocząć inicjowanie składnik, który jest używany w formularzu lub używany przez inny składnik. <xref:System.Data.DataTable.EndInit%2A> Metoda kończy się inicjowania. Przy użyciu <xref:System.Data.DataTable.BeginInit%2A> i <xref:System.Data.DataTable.EndInit%2A> metody uniemożliwia użycie przed pełnym zainicjowaniem formantu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginLoadData">
      <MemberSignature Language="C#" Value="public void BeginLoadData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginLoadData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.BeginLoadData" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginLoadData ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginLoadData();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Powoduje wyłączenie powiadomień, indeks konserwacji i ograniczeń podczas ładowania danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Data.DataTable.BeginLoadData%2A> w połączeniu z <xref:System.Data.DataTable.LoadDataRow%2A> i <xref:System.Data.DataTable.EndLoadData%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CaseSensitive">
      <MemberSignature Language="C#" Value="public bool CaseSensitive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CaseSensitive" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.CaseSensitive" />
      <MemberSignature Language="VB.NET" Value="Public Property CaseSensitive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CaseSensitive { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wskazuje, czy porównywanie ciągów wewnątrz tabeli jest rozróżniana wielkość liter.</summary>
        <value>
          <see langword="true" /> Jeśli wynikiem porównania jest rozróżniana wielkość liter; w przeciwnym razie <see langword="false" />. Domyślnym ustawieniem jest nadrzędny <see cref="T:System.Data.DataSet" /> obiektu <see cref="P:System.Data.DataSet.CaseSensitive" /> właściwości, lub <see langword="false" /> Jeśli <see cref="T:System.Data.DataTable" /> utworzono niezależnie od <see cref="T:System.Data.DataSet" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.CaseSensitive%2A> Właściwość ma wpływ na porównywanie ciągów w sortowanie, wyszukiwanie i filtrowanie.  
  
   
  
## Examples  
 Następujące przykładowe wywołania <xref:System.Data.DataTable.Select%2A> metody dwa razy na <xref:System.Data.DataTable>. Po raz pierwszy, <xref:System.Data.DataTable.CaseSensitive%2A> właściwość jest ustawiona na `false`, drugi do `true`.  
  
 [!code-csharp[Classic WebData DataTable.CaseSensitive Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.CaseSensitive Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.CaseSensitive Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.CaseSensitive Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataTable.Select" />
      </Docs>
    </Member>
    <Member MemberName="ChildRelations">
      <MemberSignature Language="C#" Value="public System.Data.DataRelationCollection ChildRelations { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataRelationCollection ChildRelations" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.ChildRelations" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ChildRelations As DataRelationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataRelationCollection ^ ChildRelations { System::Data::DataRelationCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRelationCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję relacje podrzędne dla tej <see cref="T:System.Data.DataTable" />.</summary>
        <value>A <see cref="T:System.Data.DataRelationCollection" /> zawiera relacje podrzędne dla tabeli. Zwracany jest pustą kolekcję, jeśli nie <see cref="T:System.Data.DataRelation" /> istnieją obiekty.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Data.DataRelation> definiuje relację między dwiema tabelami. Zazwyczaj dwie tabele są połączone za pośrednictwem jednego pola, który zawiera te same dane. Na przykład tabeli, która zawiera dane adresów może mieć jedno pole zawierający kody, które reprezentują krajów i regionów. Druga tabela, która zawiera dane kraj/region będzie mieć jedno pole, który zawiera kod, który identyfikuje kraj/region, a jest ten kod, który jest wstawiany do odpowiednich pól w pierwszej tabeli. A <xref:System.Data.DataRelation>, następnie zawiera co najmniej cztery elementy informacji: (1) Nazwa pierwszej tabeli, (2) z nazwą kolumny w pierwszej tabeli, (3) nazwa drugiej tabeli i (4) Nazwa kolumny w drugiej tabeli.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Data.DataTable.ChildRelations%2A> właściwości, aby powrócić do każdego elementu podrzędnego <xref:System.Data.DataRelation> w <xref:System.Data.DataTable>. Każda relacja jest następnie używany jako argument w <xref:System.Data.DataRow.GetChildRows%2A> metody <xref:System.Data.DataRow> aby zwracało tablicę wierszy. Następnie wydrukowaniu wartość każdej kolumny w wierszu.  
  
 [!code-csharp[Classic WebData DataTable.ChildRelations Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ChildRelations Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ChildRelations Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ChildRelations Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.ParentRelations" />
        <altmember cref="M:System.Data.DataRow.GetParentRows(System.String)" />
        <altmember cref="M:System.Data.DataRow.GetChildRows(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Czyści <see cref="T:System.Data.DataTable" /> wszystkie dane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zostaną usunięte wszystkie wiersze we wszystkich tabelach. Wyjątek jest generowany, jeśli tabela zawiera wszystkie relacje podrzędne wymuszone, powodujących wiersze podrzędne być oddzielony.  
  
 Jeśli <xref:System.Data.DataSet> jest powiązany z <xref:System.Xml.XmlDataDocument>, wywoływania <xref:System.Data.DataSet.Clear%2A?displayProperty=nameWithType> lub <xref:System.Data.DataTable.Clear%2A?displayProperty=nameWithType> zgłasza <xref:System.NotSupportedException>. Aby tego uniknąć, przechodzenie przez każdej tabeli, usunięcie każdego wiersza, w jednym naraz. Jeśli używasz <xref:System.Data.DataTable.NewRow%2A> Aby utworzyć nowe wiersze, wiersze muszą zostać przetworzone przed wywołaniem <xref:System.Data.DataTable.Clear%2A>.  
  
   
  
## Examples  
 Poniższy przykład czyści wszystkie dane w tabeli.  
  
 [!code-csharp[Classic WebData DataTable.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual System.Data.DataTable Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Data.DataTable Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Data::DataTable ^ Clone();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Struktura klonów <see cref="T:System.Data.DataTable" />, wraz ze wszystkimi <see cref="T:System.Data.DataTable" /> schematy i ograniczeń.</summary>
        <returns>Nowy <see cref="T:System.Data.DataTable" /> z tego samego schematu, ponieważ bieżący <see cref="T:System.Data.DataTable" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli zostały uzyskane tych klas, klonu będzie również tej samej klasy pochodnej.  
  
 Tworzy nowy klon <xref:System.Data.DataTable> z taką samą strukturę co oryginalny <xref:System.Data.DataTable>, ale nie kopiuje danych (nowego <xref:System.Data.DataTable> nie będzie zawierać `DataRows`). Aby skopiować struktury i danych do nowego <xref:System.Data.DataTable>, użyj <xref:System.Data.DataTable.Copy%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano, jak zaktualizować strukturę i ograniczenia tabeli docelowej po wykonaniu DataTable.Clone. Klasa ClonedDataTable zwróci tabeli docelowej i zawiera wszystkie zdarzenia aktualizacji. Po klonowania zmiany struktury tabeli źródłowej nie zostaną odzwierciedlone w tabeli docelowej. W szczególności zostanie w tym przykładzie:  
  
-   Zaktualizuj zmiany kolumny w tabeli źródłowej.  
  
-   Zaktualizuj zmiany UniqueConstraint w tabeli źródłowej.  
  
-   Zaktualizuj zmiany ForeignKeyConstraint w tabeli źródłowej.  
  
 C# i Visual Basic projektów z tym przykładowym kodzie można znaleźć w [przykłady kodu dewelopera](https://code.msdn.microsoft.com/site/search?f%5B0%5D.Type=SearchText&f%5B0%5D.Value=How%20to%20automically%20update%20the%20structure%20of%20a%20cloned%20DataTable).  
  
```csharp  
using System;  
using System.Linq;  
using System.Data;  
using System.ComponentModel;  
  
class Program {  
   static void Main(string[] args) {  
      DataTable courses = NewCourseDataTable();  
      Console.WriteLine("This is the source table:");  
      WriteDataTable(courses);  
  
      ClonedDataTable clonedResult = new ClonedDataTable(courses);  
      DataTable clonedCourses = clonedResult.DestinationTable;  
      Console.WriteLine("This is the destination table:");  
      WriteDataTable(clonedCourses);  
  
      // Add the events of updating column collection into the source table.  
      clonedResult.UpdateAddedColumn();  
      clonedResult.UpdateDeletedColumn();  
      // Add a DataColumn in source table.  
      DataColumn columnCreidts = new DataColumn("Credits", typeof(Int32));  
      courses.Columns.Add(columnCreidts);  
      Console.WriteLine("After add a column in source table, it's the result in the destination:");  
      WriteDataTable(clonedCourses);  
  
      // Add the event of updating UniqueConstraint into the source table.  
      clonedResult.UpdateUniqueConstraint();  
  
      // Add the unique constraint in source table.  
      UniqueConstraint uniqueConstraint = new UniqueConstraint(courses.Columns["CourseId"]);  
      courses.Constraints.Add(uniqueConstraint);  
  
      Console.WriteLine(@"If we add the unique constraint in source table and then insert the duplicate   
rows into the destination table, we will get the following error:");  
      InsertDuplicateData(clonedCourses);  
      Console.WriteLine();  
  
      // Add the event of updating ForeignKeyConstraint into the source table.  
      clonedResult.UpdateForeignKeyConstraint();  
  
      // Add the ForeignKeyConstraint into the source table.  
      DataTable deparments = NewDeparmentDataTable();  
      DataSet dataset = new DataSet();  
  
      dataset.Tables.Add(courses);  
      dataset.Tables.Add(clonedCourses);  
      dataset.Tables.Add(deparments);  
  
      ForeignKeyConstraint foreignKey = new ForeignKeyConstraint(deparments.Columns["DepartmentId"], courses.Columns["DepartmentId"]);  
      courses.Constraints.Add(foreignKey);  
  
      Console.WriteLine(@"If we add the foreign key constraint in source table and then insert a row   
without the parent  into the destination table, we will get the following error:");  
      InsertNoParentRow(clonedCourses);  
      Console.WriteLine();  
  
      Console.WriteLine("Please press any key to exit...");  
      Console.ReadKey();  
   }  
  
   static private DataTable NewCourseDataTable() {  
      DataTable newTable = new DataTable();  
  
      DataColumn[] columns ={   
                                      new DataColumn("CourseId", typeof(String)),  
                                      new DataColumn("CourseName",typeof(String)),                                        
                                      new DataColumn("DepartmentId", typeof(Int32))  
                                  };  
  
      newTable.Columns.AddRange(columns);  
  
      newTable.Rows.Add("C1045", "Calculus", 7);  
      newTable.Rows.Add("C1061", "Physics", 1);  
      newTable.Rows.Add("C2021", "Composition", 2);  
      newTable.Rows.Add("C2042", "Literature", 2);  
  
      return newTable;  
   }  
  
   static private DataTable NewDeparmentDataTable() {  
      DataTable newTable = new DataTable();  
  
      DataColumn[] columns ={   
                                      new DataColumn("DepartmentId", typeof(Int32)),  
                                      new DataColumn("Name",typeof(String)),  
                                  };  
  
      newTable.Columns.AddRange(columns);  
  
      newTable.Rows.Add(1, "Engineering");  
      newTable.Rows.Add(2, "English");  
      newTable.Rows.Add(4, "Economics");  
      newTable.Rows.Add(7, "Mathematics");  
  
      return newTable;  
   }  
  
   static private void WriteDataTable(DataTable table) {  
      if (table == null)  
         return;  
  
      foreach (DataColumn column in table.Columns) {  
         Console.Write("{0,-15}", column.ColumnName);  
      }  
      Console.WriteLine();  
  
      foreach (DataRow row in table.Rows) {  
         for (int i = 0; i < table.Columns.Count; i++)  
            Console.Write("{0,-15}", row[i].ToString());  
         Console.WriteLine();  
      }  
  
      Console.WriteLine();  
   }  
  
   static private void InsertDuplicateData(DataTable table) {  
      try {  
         table.Rows.Add("C1045", "Calculus", 7);  
         table.Rows.Add("C1045", "Calculus", 7);  
      } catch (Exception e) {  
         Console.WriteLine("\"" + e.Message + "\"");  
      }  
   }  
  
   private static void InsertNoParentRow(DataTable table) {  
      try {  
         table.Rows.Add("C1061", "Physics", 11);  
      } catch (Exception e) {  
         Console.WriteLine("\"" + e.Message + "\"");  
      }  
   }  
}  
  
public class ClonedDataTable {  
   private DataTable sourceTable;  
   private DataTable destinationTable;  
  
   public ClonedDataTable(DataTable source) {  
      sourceTable = source;  
      // set the cloned result  
      destinationTable = sourceTable.Clone();  
   }  
  
   public void UpdateAddedColumn() {  
      sourceTable.Columns.CollectionChanged += new CollectionChangeEventHandler(ColumnAdded);  
   }  
  
   public void UpdateDeletedColumn() {  
      sourceTable.Columns.CollectionChanged += new CollectionChangeEventHandler(ColumnDeleted);  
   }  
  
   public void UpdateUniqueConstraint() {  
      sourceTable.Constraints.CollectionChanged += new CollectionChangeEventHandler(UniqueConstraint_Changed);  
   }  
  
   public void UpdateForeignKeyConstraint() {  
      sourceTable.Constraints.CollectionChanged += new CollectionChangeEventHandler(ForeignKeyConstraint_Changed);  
   }  
  
   // After the source table adds a column, the method will add the same column in the destination table.  
   void ColumnAdded(object sender, System.ComponentModel.CollectionChangeEventArgs e) {  
      if (e.Action == CollectionChangeAction.Add) {  
         DataColumn column = e.Element as DataColumn;  
  
         if (column != null) {  
            DataColumn newColumn = new DataColumn(column.ColumnName, column.DataType, column.Expression, column.ColumnMapping);  
  
            if (!destinationTable.Columns.Contains(newColumn.ColumnName))  
               destinationTable.Columns.Add(newColumn);  
         }  
      }  
   }  
  
   // After the source table deletes a column, the method will delete the same column in the destination table.  
   void ColumnDeleted(object sender, CollectionChangeEventArgs e) {  
      if (e.Action == CollectionChangeAction.Remove) {  
         DataColumn column = e.Element as DataColumn;  
  
         if (column != null)  
            if (destinationTable.Columns.Contains(column.ColumnName))  
               destinationTable.Columns.Remove(column.ColumnName);  
      }  
   }  
  
   // After the source table changes the UniqueConstraint, this method changes the same UniqueConstraint in destination table.        
   void UniqueConstraint_Changed(object sender, CollectionChangeEventArgs e) {  
      UniqueConstraint constraint = e.Element as UniqueConstraint;  
  
      if (constraint == null)  
         return;  
  
      String constraintName = constraint.ConstraintName;  
  
      if (e.Action == CollectionChangeAction.Add) {  
         DataColumn[] columns = new DataColumn[constraint.Columns.Count()];  
         Boolean isPrimaryKey = constraint.IsPrimaryKey;  
  
         // Get the columns used in new constraint from the destiantion table.  
         for (Int32 i = 0; i < constraint.Columns.Count(); i++) {  
            String columnName = constraint.Columns[i].ColumnName;  
  
            if (destinationTable.Columns.Contains(columnName))  
               columns[i] = destinationTable.Columns[columnName];  
            else  
               return;  
         }  
  
         UniqueConstraint newConstraint = new UniqueConstraint(constraintName, columns, isPrimaryKey);  
  
         if (!destinationTable.Constraints.Contains(constraintName))  
            destinationTable.Constraints.Add(newConstraint);  
  
      } else if (e.Action == CollectionChangeAction.Remove)  
         if (destinationTable.Constraints.Contains(constraintName))  
            destinationTable.Constraints.Remove(constraintName);  
   }  
  
   // After the source table changes the ForeignKeyConstraint, this method changes    
   // the same ForeignKeyConstraint in the destination table.  
   void ForeignKeyConstraint_Changed(object sender, CollectionChangeEventArgs e) {  
      ForeignKeyConstraint constraint = e.Element as ForeignKeyConstraint;  
  
      if (constraint == null)  
         return;  
  
      // If the source and destination are not in the same DataSet, don't change the ForeignKeyConstraint.  
      if (sourceTable.DataSet != destinationTable.DataSet)  
         return;  
  
      String constraintName = constraint.ConstraintName;  
  
      if (e.Action == CollectionChangeAction.Add) {  
         DataColumn[] columns = new DataColumn[constraint.Columns.Count()];  
         DataColumn[] parentColumns = constraint.RelatedColumns;  
  
         // Get the columns used in new constraint from the destination table.  
         for (int i = 0; i < constraint.Columns.Count(); i++) {  
            String columnName = constraint.Columns[i].ColumnName;  
  
            if (destinationTable.Columns.Contains(columnName))  
               columns[i] = destinationTable.Columns[columnName];  
            else  
               return;  
         }  
  
         ForeignKeyConstraint newConstraint = new ForeignKeyConstraint(constraintName, parentColumns, columns);  
         newConstraint.AcceptRejectRule = constraint.AcceptRejectRule;  
         newConstraint.DeleteRule = constraint.DeleteRule;  
         newConstraint.UpdateRule = constraint.UpdateRule;  
  
         if (!destinationTable.Constraints.Contains(constraintName))  
            destinationTable.Constraints.Add(newConstraint);  
      } else if (e.Action == CollectionChangeAction.Remove)  
         if (destinationTable.Constraints.Contains(constraintName))  
            destinationTable.Constraints.Remove(constraintName);  
   }  
  
   // return the destination table.  
   public DataTable DestinationTable {  
      get { return destinationTable; }  
   }  
}  
```  
  
 W tym przykładzie pokazano, jak modyfikować danych w DataTable i zaktualizować źródła danych.  
  
 Najpierw utwórz bazę danych:  
  
```  
USE [master]  
GO  
  
CREATE DATABASE [MySchool]   
  
GO  
  
USE [MySchool]  
GO  
  
SET ANSI_NULLS ON  
GO  
SET QUOTED_IDENTIFIER ON  
GO  
CREATE TABLE [dbo].[Course]([CourseID] [nvarchar](10) NOT NULL,  
[Year] [smallint] NOT NULL,  
[Title] [nvarchar](100) NOT NULL,  
[Credits] [int] NOT NULL,  
[DepartmentID] [int] NOT NULL,  
 CONSTRAINT [PK_Course] PRIMARY KEY CLUSTERED   
(  
[CourseID] ASC,  
[Year] ASC  
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]) ON [PRIMARY]  
  
GO  
  
SET ANSI_NULLS ON  
GO  
SET QUOTED_IDENTIFIER ON  
GO  
CREATE TABLE [dbo].[Department]([DepartmentID] [int] IDENTITY(1,1) NOT NULL,  
[Name] [nvarchar](50) NOT NULL,  
[Budget] [money] NOT NULL,  
[StartDate] [datetime] NOT NULL,  
[Administrator] [int] NULL,  
 CONSTRAINT [PK_Department] PRIMARY KEY CLUSTERED   
(  
[DepartmentID] ASC  
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]) ON [PRIMARY]  
  
GO  
  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C1045', 2012, N'Calculus', 4, 7)  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C1061', 2012, N'Physics', 4, 1)  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C2021', 2012, N'Composition', 3, 2)  
INSERT [dbo].[Course] ([CourseID], [Year], [Title], [Credits], [DepartmentID]) VALUES (N'C2042', 2012, N'Literature', 4, 2)  
  
SET IDENTITY_INSERT [dbo].[Department] ON   
  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (1, N'Engineering', 350000.0000, CAST(0x0000999C00000000 AS DateTime), 2)  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (2, N'English', 120000.0000, CAST(0x0000999C00000000 AS DateTime), 6)  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (4, N'Economics', 200000.0000, CAST(0x0000999C00000000 AS DateTime), 4)  
INSERT [dbo].[Department] ([DepartmentID], [Name], [Budget], [StartDate], [Administrator]) VALUES (7, N'Mathematics', 250024.0000, CAST(0x0000999C00000000 AS DateTime), 3)  
SET IDENTITY_INSERT [dbo].[Department] OFF  
  
ALTER TABLE [dbo].[Course]  WITH CHECK ADD  CONSTRAINT [FK_Course_Department] FOREIGN KEY([DepartmentID])  
REFERENCES [dbo].[Department] ([DepartmentID])  
GO  
ALTER TABLE [dbo].[Course] CHECK CONSTRAINT [FK_Course_Department]  
GO  
```  
  
 Teraz można skompilować i uruchomić próbki. [Jak zmodyfikować danych w tabeli DataTable i zaktualizuj go do źródła danych](https://code.msdn.microsoft.com/How-to-modify-data-in-c68d35f4) projekty Visual Basic i C# tego przykładu.  
  
```csharp  
using System;  
using System.Data;  
using System.Data.SqlClient;  
  
class Program {  
   static void Main(string[] args) {  
  
   string MySchoolConnectionString = "Data Source=(local);Initial Catalog=MySchool;Integrated Security=True";  
  
      // Get Data  
      String selectString =  
       @"Select [CourseID],[Year],[Title],[Credits],[DepartmentID] From [dbo].[Course];  
               Select [DepartmentID],[Name],[Budget],[StartDate],[Administrator] From [dbo].[Department] ";  
  
      DataSet dataSet = new DataSet();  
      DataTable course = dataSet.Tables.Add("Course");  
      DataTable department = dataSet.Tables.Add("Department");  
  
      Console.WriteLine("Get data from database:");  
      GetDataTables(MySchoolConnectionString, selectString, dataSet, course, department);  
      Console.WriteLine();  
  
      // Use DataTable Edits to edit the data  
      String updateString =  
              @"Update [dbo].[Course] Set [Credits]=@Credits Where [CourseID]=@CourseID;";  
  
      course.ColumnChanged += OnColumnChanged;  
  
      // Set the Credits of first row is negative value, and set the Credits of second row is plus.  
      ChangeCredits(course, course.Rows[0], -1);  
      ChangeCredits(course, course.Rows[1], 11);  
  
      UpdateDataTables(MySchoolConnectionString, updateString, dataSet, "Course",  
          new SqlParameter("@CourseID", SqlDbType.NVarChar, 10, "CourseID"),  
          new SqlParameter("@Credits", SqlDbType.Int, 4, "Credits"));  
      Console.WriteLine("Only the Credits of second row is changed.");  
      ShowDataTable(course);  
      Console.WriteLine();  
  
      // Delete and Remove from DataTable  
      // Create the foreign key constraint, and set the DeleteRule with Cascade.  
      ForeignKeyConstraint courseDepartFK = new ForeignKeyConstraint("CourseDepartFK", department.Columns["DepartmentID"], course.Columns["DepartmentID"]);  
      courseDepartFK.DeleteRule = Rule.Cascade;  
      courseDepartFK.UpdateRule = Rule.Cascade;  
      courseDepartFK.AcceptRejectRule = AcceptRejectRule.None;  
      course.Constraints.Add(courseDepartFK);  
  
      String deleteString = @"Delete From [dbo].[Course] Where [CourseID]=@CourseID;";  
  
      department.Rows[0].Delete();  
      Console.WriteLine("If One row in Department table is deleted, the related rows in Course table will also be deleted.");  
      Console.WriteLine("Department DataTable:");  
      ShowDataTable(department);  
      Console.WriteLine();  
      Console.WriteLine("Course DataTable:");  
      ShowDataTable(course);  
      Console.WriteLine();  
      // Update the delete operation  
      DeleteDataTables(MySchoolConnectionString, deleteString, dataSet, "Course",  
          new SqlParameter("@CourseID", SqlDbType.NVarChar, 10, "CourseID"));  
      Console.WriteLine("After delete operation:");  
      Console.WriteLine("Course DataTable:");  
      ShowDataTable(course);  
      Console.WriteLine();  
  
      course.Rows.RemoveAt(0);  
      Console.WriteLine("Now we remove one row from Course:");  
      ShowDataTable(course);  
      DeleteDataTables(MySchoolConnectionString, deleteString, dataSet, "Course",  
          new SqlParameter("@CourseID", SqlDbType.NVarChar, 10, "CourseID"));  
   }  
  
   // Use SqlDataAdapter to get data.  
   private static void GetDataTables(String connectionString, String selectString,  
       DataSet dataSet, params DataTable[] tables) {  
      using (SqlDataAdapter adapter = new SqlDataAdapter()) {  
         adapter.SelectCommand = new SqlCommand(selectString);  
         adapter.SelectCommand.Connection = new SqlConnection(connectionString);  
  
         adapter.Fill(0, 0, tables);  
  
         foreach (DataTable table in dataSet.Tables) {  
            Console.WriteLine("Data in {0}:", table.TableName);  
            ShowDataTable(table);  
            Console.WriteLine();  
         }  
      }  
   }  
  
   // Use SqlDataAdapter to update the updata operation.  
   private static void UpdateDataTables(String connectionString, String updateString,  
       DataSet dataSet, String tableName, params SqlParameter[] parameters) {  
      using (SqlDataAdapter adapter = new SqlDataAdapter()) {  
         adapter.UpdateCommand = new SqlCommand(updateString);  
         adapter.UpdateCommand.Parameters.AddRange(parameters);  
         adapter.UpdateCommand.Connection = new SqlConnection(connectionString);  
  
         adapter.Update(dataSet, tableName);  
      }  
   }  
  
   // Use SqlDataAdapter to update delete operation.  
   private static void DeleteDataTables(String connectionString, String deleteString,  
       DataSet dataSet, String tableName, params SqlParameter[] parameters) {  
      using (SqlDataAdapter adapter = new SqlDataAdapter()) {  
         adapter.DeleteCommand = new SqlCommand(deleteString);  
         adapter.DeleteCommand.Parameters.AddRange(parameters);  
         adapter.DeleteCommand.Connection = new SqlConnection(connectionString);  
  
         adapter.Update(dataSet, tableName);  
      }  
   }  
  
   // Use DataTable Edits to modify the data.  
   private static void ChangeCredits(DataTable table, DataRow row, Int32 credits) {  
      row.BeginEdit();  
      Console.WriteLine("We change row {0}", table.Rows.IndexOf(row));  
      row["Credits"] = credits;  
      row.EndEdit();  
   }  
  
   // The method will be invoked when the value in DataTable is changed.  
   private static void OnColumnChanged(Object sender, DataColumnChangeEventArgs args) {  
      Int32 credits = 0;  
      // If Credits is changed and the value is negative, we'll cancel the edit.  
      if ((args.Column.ColumnName == "Credits") &&  
          (!Int32.TryParse(args.ProposedValue.ToString(), out credits) || credits < 0)) {  
         Console.WriteLine("The value of Credits is invalid. Edit canceled.");  
         args.Row.CancelEdit();  
      }  
   }  
  
   // Display the column and value of DataTable.  
   private static void ShowDataTable(DataTable table) {  
      foreach (DataColumn col in table.Columns) {  
         Console.Write("{0,-14}", col.ColumnName);  
      }  
      Console.WriteLine("{0,-14}", "RowState");  
  
      foreach (DataRow row in table.Rows) {  
         if (row.RowState == DataRowState.Deleted) {  
            foreach (DataColumn col in table.Columns) {  
               if (col.DataType.Equals(typeof(DateTime)))  
                  Console.Write("{0,-14:d}", row[col, DataRowVersion.Original]);  
               else if (col.DataType.Equals(typeof(Decimal)))  
                  Console.Write("{0,-14:C}", row[col, DataRowVersion.Original]);  
               else  
                  Console.Write("{0,-14}", row[col, DataRowVersion.Original]);  
            }  
         }  
         else {  
            foreach (DataColumn col in table.Columns) {  
               if (col.DataType.Equals(typeof(DateTime)))  
                  Console.Write("{0,-14:d}", row[col]);  
               else if (col.DataType.Equals(typeof(Decimal)))  
                  Console.Write("{0,-14:C}", row[col]);  
               else  
                  Console.Write("{0,-14}", row[col]);  
            }  
         }  
         Console.WriteLine("{0,-14}", row.RowState);  
      }  
   }  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataTable.Copy" />
      </Docs>
    </Member>
    <Member MemberName="ColumnChanged">
      <MemberSignature Language="C#" Value="public event System.Data.DataColumnChangeEventHandler ColumnChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataColumnChangeEventHandler ColumnChanged" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.ColumnChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ColumnChanged As DataColumnChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataColumnChangeEventHandler ^ ColumnChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataColumnChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po zmianie wartości dla określonego <see cref="T:System.Data.DataColumn" /> w <see cref="T:System.Data.DataRow" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji, zobacz [obsługi zdarzeń DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md).  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.ColumnChanged Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ColumnChanged Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ColumnChanged Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ColumnChanged Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Data.DataColumnChangeEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="ColumnChanging">
      <MemberSignature Language="C#" Value="public event System.Data.DataColumnChangeEventHandler ColumnChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataColumnChangeEventHandler ColumnChanging" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.ColumnChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ColumnChanging As DataColumnChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataColumnChangeEventHandler ^ ColumnChanging;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataColumnChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po zmianie wartości dla określonego <see cref="T:System.Data.DataColumn" /> w <see cref="T:System.Data.DataRow" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji, zobacz [obsługi zdarzeń DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md).  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.ColumnChanging Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ColumnChanging Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ColumnChanging Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ColumnChanging Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Columns">
      <MemberSignature Language="C#" Value="public System.Data.DataColumnCollection Columns { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataColumnCollection Columns" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Columns" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Columns As DataColumnCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataColumnCollection ^ Columns { System::Data::DataColumnCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataColumnCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję kolumn, które należą do tej tabeli.</summary>
        <value>A <see cref="T:System.Data.DataColumnCollection" /> zawierający kolekcję <see cref="T:System.Data.DataColumn" /> obiektów dla tabeli. Zwracany jest pustą kolekcję, jeśli nie <see cref="T:System.Data.DataColumn" /> istnieją obiekty.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataColumnCollection> Określa schemat tabeli przez określenie typu danych każdej kolumny.  
  
   
  
## Examples  
 Poniższy przykład drukuje każda wartość każdego wiersza w tabeli za pomocą <xref:System.Data.DataTable.Columns%2A> właściwości.  
  
 [!code-csharp[Classic WebData DataTable.Columns Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Columns Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Columns Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Columns Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Compute">
      <MemberSignature Language="C#" Value="public object Compute (string expression, string filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Compute(string expression, string filter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Compute(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Compute (expression As String, filter As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Compute(System::String ^ expression, System::String ^ filter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.String" />
        <Parameter Name="filter" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression">Wyrażenie do obliczenia.</param>
        <param name="filter">Filtr, aby ograniczyć liczbę wierszy, które oceny w wyrażeniu.</param>
        <summary>Oblicza danego wyrażenia na bieżącym wierszy, na które spełniać kryteria filtru.</summary>
        <returns>
          <see cref="T:System.Object" />, Ustaw dla wyniku obliczenia. Jeśli wyrażenie ma wartość null, wartość zwracana będzie <see cref="F:System.DBNull.Value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `expression` Parametr wymaga funkcji agregującej. Na przykład Oto wyrażenia prawnych:  
  
 `Count(Quantity)`  
  
 Ale nie jest to wyrażenie:  
  
 `Sum (Quantity * UnitPrice)`  
  
 Wykonaj operację na dwóch lub więcej kolumn, należy utworzyć <xref:System.Data.DataColumn>, ustaw jej <xref:System.Data.DataColumn.Expression%2A> odpowiedniego wyrażenia, a wyrażenie agregujące w wierszach kolumny dla właściwości. W takim przypadku podane <xref:System.Data.DataColumn> z nazwy "Suma" i <xref:System.Data.DataColumn.Expression%2A> właściwość to:  
  
 `"Quantity * UnitPrice"`  
  
 Argument wyrażenia <xref:System.Data.DataTable.Compute%2A> metoda będzie wówczas to:  
  
 `Sum(total)`  
  
 Drugi parametr `filter`, określa wiersze, które są używane w wyrażeniu. Na przykład jeśli tabela zawiera kolumnę dat o nazwie "colDate", można ograniczyć wiersze z następującym wyrażeniem:  
  
 `colDate > 1/1/99 AND colDate < 17/1/99`  
  
 W przypadku reguł dotyczących tworzenia wyrażenia w obydwu tych parametrów, zobacz <xref:System.Data.DataColumn.Expression%2A?displayProperty=nameWithType> właściwości.  
  
   
  
## Examples  
 Poniższy przykład sumuje wartości kolumny o nazwie "Suma" sprzedawców, których numer identyfikacyjny jest pięć.  
  
 [!code-csharp[Classic WebData DataTable.Compute Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Compute Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Compute Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Compute Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Constraints">
      <MemberSignature Language="C#" Value="public System.Data.ConstraintCollection Constraints { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.ConstraintCollection Constraints" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Constraints" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Constraints As ConstraintCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::ConstraintCollection ^ Constraints { System::Data::ConstraintCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.ConstraintCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję ograniczenia obsługiwanego przez tej tabeli.</summary>
        <value>A <see cref="T:System.Data.ConstraintCollection" /> zawierający kolekcję <see cref="T:System.Data.Constraint" /> obiektów dla tabeli. Zwracany jest pustą kolekcję, jeśli nie <see cref="T:System.Data.Constraint" /> istnieją obiekty.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Data.ForeignKeyConstraint> ogranicza akcję wykonaną gdy usunąć lub zaktualizować wartości w kolumnie (lub kolumny). Takie ograniczenie jest przeznaczony do użycia z kolumn klucza podstawowego. W relacji nadrzędny/podrzędny między dwiema tabelami usunięcie wartość z tabeli nadrzędnej może wpłynąć na wiersze podrzędne w jednym z następujących sposobów.  
  
-   Podrzędne, które wiersze mogą być również usuwane (Akcja kaskadowych).  
  
-   Wartości w kolumnie podrzędnej (lub kolumny) może być równa wartości null.  
  
-   Wartości domyślne można ustawić wartości w kolumnie podrzędnej (lub kolumny).  
  
-   Może zostać wygenerowany wyjątek.  
  
 A <xref:System.Data.UniqueConstraint> staje się aktywny podczas ustawiania wartości klucza podstawowego nie jest unikatowa wartość.  
  
   
  
## Examples  
 W poniższym przykładzie dodano <xref:System.Data.ForeignKeyConstraint> do kolekcji ograniczeń.  
  
 [!code-csharp[Classic WebData DataTable.Constraints Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Constraints Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Constraints Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Constraints Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public System.Data.DataTable Copy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTable Copy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Copy" />
      <MemberSignature Language="VB.NET" Value="Public Function Copy () As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTable ^ Copy();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Kopiuje strukturę i dane dla tego <see cref="T:System.Data.DataTable" />.</summary>
        <returns>Nowy <see cref="T:System.Data.DataTable" /> z taką samą strukturę (schematy tabeli i ograniczenia) oraz dane jako to <see cref="T:System.Data.DataTable" />.  
  
 Jeśli zostały uzyskane tych klas, kopia będzie również tej samej klasy pochodnej.  
  
 <see cref="M:System.Data.DataTable.Copy" /> Tworzy nowy <see cref="T:System.Data.DataTable" /> z taką samą strukturę oraz danych jak oryginał <see cref="T:System.Data.DataTable" />. Kopiowanie struktury na nowe <see cref="T:System.Data.DataTable" />, ale nie dane używane przez <see cref="M:System.Data.DataTable.Clone" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Data.DataTable.Copy%2A> metody, aby utworzyć kopię oryginału <xref:System.Data.DataTable>. Nazwa przestrzeni nazw nie są zachowywane, jeśli zostało ono odziedziczone z nadrzędnego <xref:System.Data.DataTable> lub <xref:System.Data.DataSet>.  
  
 [!code-csharp[Classic WebData DataTable.Copy Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Copy Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Copy Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Copy Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataView.ToTable" />
        <altmember cref="M:System.Data.DataTable.Clone" />
      </Docs>
    </Member>
    <Member MemberName="CreateDataReader">
      <MemberSignature Language="C#" Value="public System.Data.DataTableReader CreateDataReader ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTableReader CreateDataReader() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.CreateDataReader" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateDataReader () As DataTableReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTableReader ^ CreateDataReader();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableReader</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.Data.DataTableReader" /> odpowiadający danych w ramach tego <see cref="T:System.Data.DataTable" />.</summary>
        <returns>A <see cref="T:System.Data.DataTableReader" /> zawierających jeden zestaw wyników, odpowiadający źródło <see cref="T:System.Data.DataTable" /> wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Tworzy następującej aplikacji konsoli <xref:System.Data.DataTable> wystąpienia. Przykład następnie przekazuje wypełniony <xref:System.Data.DataTable> do procedury, która wywołuje <xref:System.Data.DataTable.CreateDataReader%2A> metodę, która iterację w wynikach zawartych w <xref:System.Data.DataTableReader>.  
  
 [!code-csharp[DataWorks DataTable.CreateDataReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.CreateDataReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.CreateDataReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.CreateDataReader/VB/source.vb#1)]  
  
 W przykładzie przedstawiono następujące wyniki w oknie konsoli:  
  
 `1 Mary`  
  
 `2 Andy`  
  
 `3 Peter`  
  
 `4 Russ`  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.CreateDataReader" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="protected virtual System.Data.DataTable CreateInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Data.DataTable CreateInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.CreateInstance" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateInstance () As DataTable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Data::DataTable ^ CreateInstance();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy nowe wystąpienie klasy <see cref="T:System.Data.DataTable" />.</summary>
        <returns>Nowe wyrażenie.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DataSet">
      <MemberSignature Language="C#" Value="public System.Data.DataSet DataSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataSet DataSet" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.DataSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DataSet As DataSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataSet ^ DataSet { System::Data::DataSet ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Data.DataSet" /> do której należy ta tabela.</summary>
        <value>
          <see cref="T:System.Data.DataSet" /> Do której należy ta tabela.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli formant jest powiązany z danymi do <xref:System.Data.DataTable>, i tabela należy do <xref:System.Data.DataSet>, aby przejść do <xref:System.Data.DataSet> za pomocą tej właściwości.  
  
   
  
## Examples  
 Poniższy przykład zwraca element nadrzędny <xref:System.Data.DataSet> danej tabeli za pomocą <xref:System.Data.DataTable.DataSet%2A> właściwości.  
  
 [!code-csharp[Classic WebData DataTable.DataSet Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.DataSet Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.DataSet Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.DataSet Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultView">
      <MemberSignature Language="C#" Value="public System.Data.DataView DefaultView { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataView DefaultView" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.DefaultView" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultView As DataView" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataView ^ DefaultView { System::Data::DataView ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataView</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera dostosowany widok tabeli, która może obejmować widok filtrowany lub pozycją kursora.</summary>
        <value>
          <see cref="T:System.Data.DataView" /> Skojarzone z <see cref="T:System.Data.DataTable" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.DefaultView%2A> Zwraca <xref:System.Data.DataView> służy do sortowania, filtrować i wyszukiwać <xref:System.Data.DataTable>.  
  
   
  
## Examples  
 W poniższym przykładzie ustawiono właściwość <xref:System.Data.DataTable> obiektu <xref:System.Data.DataView> za pośrednictwem <xref:System.Data.DataTable.DefaultView%2A> właściwości. W przykładzie przedstawiono również powiązanie <xref:System.Windows.Forms.DataGridView> formant <xref:System.Data.DataTable> o nazwie "Dostawcy", które zawiera kolumnę o nazwie "NazwaFirmy".  
  
 [!code-csharp[Classic WebData DataTable.DefaultView Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.DefaultView Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.DefaultView Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.DefaultView Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisplayExpression">
      <MemberSignature Language="C#" Value="public string DisplayExpression { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DisplayExpression" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.DisplayExpression" />
      <MemberSignature Language="VB.NET" Value="Public Property DisplayExpression As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DisplayExpression { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wyrażenie zwracające wartość używana do reprezentowania tej tabeli w interfejsie użytkownika. <see langword="DisplayExpression" /> Właściwości umożliwia wyświetlanie nazwy tej tabeli w interfejsie użytkownika.</summary>
        <value>Wyświetlany ciąg.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Data.DataColumn.Expression" />
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public virtual void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Kończy się inicjowanie <see cref="T:System.Data.DataTable" /> który jest używany w formularzu lub używany przez inny składnik. Inicjowanie występuje w czasie wykonywania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Środowisku projektowania programu Visual Studio .NET używa tej metody, aby zakończyć inicjowanie składnik, który jest używany w formularzu lub używany przez inny składnik. <xref:System.Data.DataTable.BeginInit%2A> Metoda uruchamia inicjowania. Przy użyciu <xref:System.Data.DataTable.BeginInit%2A> i <xref:System.Data.DataTable.EndInit%2A> metody uniemożliwia użycie przed pełnym zainicjowaniem formantu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndLoadData">
      <MemberSignature Language="C#" Value="public void EndLoadData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndLoadData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.EndLoadData" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndLoadData ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndLoadData();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Włącza funkcję powiadomień, indeks konserwacji i ograniczenia po załadowaniu danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Data.DataTable.EndLoadData%2A> w połączeniu z <xref:System.Data.DataTable.LoadDataRow%2A> i <xref:System.Data.DataTable.BeginLoadData%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExtendedProperties">
      <MemberSignature Language="C#" Value="public System.Data.PropertyCollection ExtendedProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.PropertyCollection ExtendedProperties" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.ExtendedProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExtendedProperties As PropertyCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::PropertyCollection ^ ExtendedProperties { System::Data::PropertyCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.PropertyCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję informacji użytkownika.</summary>
        <value>A <see cref="T:System.Data.PropertyCollection" /> zawiera niestandardowe informacje użytkownika.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Data.DataTable.ExtendedProperties%2A> Dodawanie niestandardowych informacji do <xref:System.Data.DataTable>. Dodawanie informacji o `Add` metody. Pobieranie informacji z `Item` metody.  
  
 Rozszerzone właściwości musi być typu <xref:System.String>. Właściwości, które nie są typu ciąg nie są zachowywane podczas <xref:System.Data.DataTable> jest zapisywany w formacie XML.  
  
   
  
## Examples  
 W poniższym przykładzie dodano wartość sygnatury czasowej do <xref:System.Data.DataTable> za pośrednictwem <xref:System.Data.DataTable.ExtendedProperties%2A> właściwości.  
  
 [!code-csharp[Classic WebData DataTable.ExtendedProperties Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ExtendedProperties Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ExtendedProperties Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ExtendedProperties Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="fInitInProgress">
      <MemberSignature Language="C#" Value="protected internal bool fInitInProgress;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly bool fInitInProgress" />
      <MemberSignature Language="DocId" Value="F:System.Data.DataTable.fInitInProgress" />
      <MemberSignature Language="VB.NET" Value="Protected Friend fInitInProgress As Boolean " />
      <MemberSignature Language="C++ CLI" Value="protected public: bool fInitInProgress;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Sprawdza, czy trwa inicjowanie. Inicjowanie występuje w czasie wykonywania.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChanges">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera kopię <see cref="T:System.Data.DataTable" /> zawierający wszystkie zmiany wprowadzone od czasu ostatniego załadowania lub od <see cref="M:System.Data.DataTable.AcceptChanges" /> została wywołana.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChanges">
      <MemberSignature Language="C#" Value="public System.Data.DataTable GetChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTable GetChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetChanges" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChanges () As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTable ^ GetChanges();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera kopię <see cref="T:System.Data.DataTable" /> zawierający wszystkie zmiany wprowadzone od momentu załadowania lub <see cref="M:System.Data.DataTable.AcceptChanges" /> ostatniego została wywołana.</summary>
        <returns>Zmian z tego <see cref="T:System.Data.DataTable" />, lub <see langword="null" /> Jeśli żadne zmiany nie zostaną znalezione.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tworzy nowy <xref:System.Data.DataSet> zawierający kopię wszystkich wierszy w oryginalnym <xref:System.Data.DataSet> , która ma oczekujące zmiany. Ograniczenia relacji może spowodować dodatkowe wiersze bez zmian do dodania do nowej <xref:System.Data.DataSet> Jeśli niezmienione wiersze zawierają kluczy podstawowych odpowiadający klucze obce w zmienionych wierszy. Metoda zwraca `null` (`Nothing` w języku Visual Basic), jeśli nie ma żadnych wierszy w oryginalnym <xref:System.Data.DataSet> z oczekujących zmian.  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.GetChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.GetChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.GetChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.GetChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChanges">
      <MemberSignature Language="C#" Value="public System.Data.DataTable GetChanges (System.Data.DataRowState rowStates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataTable GetChanges(valuetype System.Data.DataRowState rowStates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetChanges(System.Data.DataRowState)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChanges (rowStates As DataRowState) As DataTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataTable ^ GetChanges(System::Data::DataRowState rowStates);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rowStates" Type="System.Data.DataRowState" />
      </Parameters>
      <Docs>
        <param name="rowStates">Jeden z <see cref="T:System.Data.DataRowState" /> wartości.</param>
        <summary>Pobiera kopię <see cref="T:System.Data.DataTable" /> zawierający wszystkie zmiany wprowadzone od czasu ostatniego załadowania lub od <see cref="M:System.Data.DataTable.AcceptChanges" /> została wywołana, filtrowane według <see cref="T:System.Data.DataRowState" />.</summary>
        <returns>Filtrowane kopię <see cref="T:System.Data.DataTable" /> zawierających akcje wykonać na nim i nowszych można scalić w <see cref="T:System.Data.DataTable" /> przy użyciu <see cref="M:System.Data.DataSet.Merge(System.Data.DataSet)" />. Jeśli żadne wiersze z żądaną <see cref="T:System.Data.DataRowState" /> zostaną znalezione, metoda zwraca <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.GetChanges%2A> Metoda jest używana do utworzenia drugiej <xref:System.Data.DataTable> obiekt, który zawiera tylko zmiany wprowadzone do oryginalnej. Użyj `rowStates` argumentu, aby określić typ zmiany powinien zawierać nowy obiekt.  
  
 Ograniczenia relacji może spowodować wierszy nadrzędnych bez zmian, które zostaną uwzględnione.  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.GetChanges1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.GetChanges1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.GetChanges1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.GetChanges1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDataTableSchema">
      <MemberSignature Language="C#" Value="public static System.Xml.Schema.XmlSchemaComplexType GetDataTableSchema (System.Xml.Schema.XmlSchemaSet schemaSet);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.Schema.XmlSchemaComplexType GetDataTableSchema(class System.Xml.Schema.XmlSchemaSet schemaSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetDataTableSchema(System.Xml.Schema.XmlSchemaSet)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDataTableSchema (schemaSet As XmlSchemaSet) As XmlSchemaComplexType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::Schema::XmlSchemaComplexType ^ GetDataTableSchema(System::Xml::Schema::XmlSchemaSet ^ schemaSet);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchemaComplexType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="schemaSet" Type="System.Xml.Schema.XmlSchemaSet" />
      </Parameters>
      <Docs>
        <param name="schemaSet">
          <see cref="T:System.Xml.Schema.XmlSchemaSet" /> Wystąpienia.</param>
        <summary>Ta metoda zwraca <see cref="T:System.Xml.Schema.XmlSchemaSet" /> zawierające sieci Web Services Description Language (WSDL), który opisuje <see cref="T:System.Data.DataTable" /> dla usług sieci Web.</summary>
        <returns>
          <see cref="T:System.Xml.Schema.XmlSchemaSet" /> Wystąpienia.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetErrors">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] GetErrors ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] GetErrors() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetErrors" />
      <MemberSignature Language="VB.NET" Value="Public Function GetErrors () As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ GetErrors();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera tablicę <see cref="T:System.Data.DataRow" /> obiektów, które zawierają błędy.</summary>
        <returns>Tablica <see cref="T:System.Data.DataRow" /> obiektów, które mają błędy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwraca listę <xref:System.Data.DataRow> obiektów, które mają <xref:System.Data.DataRow.RowError%2A> ustawiony. Na przykład mogą wystąpić błędy podczas wywoływania metody <xref:System.Data.Common.DataAdapter.Update%2A> z <xref:System.Data.Common.DataAdapter.ContinueUpdateOnError%2A> ustawioną **true**. Nie wywołuj <xref:System.Data.DataTable.AcceptChanges%2A> na <xref:System.Data.DataTable> dopóki Usuń wszystkie błędy i ponownie prześlij <xref:System.Data.DataSet> aktualizacji.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Data.DataTable.GetErrors%2A> metoda zwraca tablicę <xref:System.Data.DataRow> obiektów, które mają błędy.  
  
 [!code-csharp[Classic WebData DataTable.GetErrors Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.GetErrors Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.GetErrors Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.GetErrors Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.HasErrors" />
        <altmember cref="P:System.Data.DataRow.RowError" />
        <altmember cref="M:System.Data.DataRow.SetColumnError(System.Int32,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> obiekt przechowujący dane serializowane skojarzone z <see cref="T:System.Data.DataTable" />.</param>
        <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> obiekt, który zawiera źródłowy i docelowy serializowanego strumienia skojarzonego z <see cref="T:System.Data.DataTable" />.</param>
        <summary>Wypełnia obiekt informacje serializacji dane potrzebne do serializacji <see cref="T:System.Data.DataTable" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" /> Parametr jest odwołanie o wartości null (<see langword="Nothing" /> w języku Visual Basic).</exception>
      </Docs>
    </Member>
    <Member MemberName="GetRowType">
      <MemberSignature Language="C#" Value="protected virtual Type GetRowType ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Type GetRowType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetRowType" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetRowType () As Type" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Type ^ GetRowType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera typ wiersza.</summary>
        <returns>Zwraca typ <see cref="T:System.Data.DataRow" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSchema">
      <MemberSignature Language="C#" Value="protected virtual System.Xml.Schema.XmlSchema GetSchema ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Xml.Schema.XmlSchema GetSchema() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.GetSchema" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetSchema () As XmlSchema" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Xml::Schema::XmlSchema ^ GetSchema();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.GetSchema</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchema</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" />.</summary>
        <returns>
          <see cref="T:System.Xml.Schema.XmlSchema" /> Opisujący reprezentację XML obiektu, który jest generowany przez <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" /> — metoda i używane przez <see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" /> metody.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasErrors">
      <MemberSignature Language="C#" Value="public bool HasErrors { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasErrors" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.HasErrors" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasErrors As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasErrors { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy występują błędy w każdym wierszy w tych tabelach <see cref="T:System.Data.DataSet" /> do której należy tabeli.</summary>
        <value>
          <see langword="true" /> Jeśli występują błędy; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przez użytkowników podczas pracy w zestawie danych zawartych w <xref:System.Data.DataTable>, można oznaczyć każdej zmiany z powodu błędu, jeśli zmiana powoduje, że niektóre niepowodzenia weryfikacji. Można zaznaczyć cały <xref:System.Data.DataRow> z komunikat błędu przy użyciu <xref:System.Data.DataRow.RowError%2A> właściwości. Można również ustawić błędów w każdej kolumnie wiersz mający <xref:System.Data.DataRow.SetColumnError%2A> metody.  
  
 Przed zaktualizowaniem źródła danych z <xref:System.Data.DataSet>, zaleca się, że należy najpierw wywołać <xref:System.Data.DataSet.GetChanges%2A> metody w celu <xref:System.Data.DataSet>. Metoda powoduje <xref:System.Data.DataSet> zawierający tylko zmiany wprowadzone w oryginalnej. Przed wysłaniem <xref:System.Data.DataSet> do aktualizowania źródła danych, sprawdź <xref:System.Data.DataTable.HasErrors%2A> właściwości każdej tabeli, aby zobaczyć, czy błędy zostały dołączone do wierszy lub kolumn w wierszach.  
  
 Po uzgodnieniu każdego błędu, usuń błędy występujące w <xref:System.Data.DataRow.ClearErrors%2A> metody `DataRow`.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Data.DataTable.HasErrors%2A> właściwość do sprawdzenia, czy tabela zawiera błędy.  
  
 [!code-csharp[Classic WebData DataTable.HasErrors Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.HasErrors Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.HasErrors Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.HasErrors Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataTable.GetErrors" />
      </Docs>
    </Member>
    <Member MemberName="ImportRow">
      <MemberSignature Language="C#" Value="public void ImportRow (System.Data.DataRow row);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ImportRow(class System.Data.DataRow row) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ImportRow(System.Data.DataRow)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ImportRow (row As DataRow)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ImportRow(System::Data::DataRow ^ row);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="row" Type="System.Data.DataRow" />
      </Parameters>
      <Docs>
        <param name="row">
          <see cref="T:System.Data.DataRow" /> Do zaimportowania.</param>
        <summary>Kopie <see cref="T:System.Data.DataRow" /> do <see cref="T:System.Data.DataTable" />, zachowując wszystkie ustawienia właściwości, a także oryginalny i bieżące wartości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływanie <xref:System.Data.DataTable.NewRow%2A> powoduje dodanie wiersza do tabeli przy użyciu istniejącego schematu tabeli, ale z wartościami domyślnymi dla wiersza i ustawia <xref:System.Data.DataRowState> do `Detached`. Wywoływanie <xref:System.Data.DataTable.ImportRow%2A> zachowuje istniejące <xref:System.Data.DataRowState> oraz innych wartości w wierszu. Jeśli `DataRow` przekazanego jako parametr jest w stanie odłączony, zostanie zignorowany, a nie wyjątek.  
  
 Nowy wiersz zostanie dodany na końcu tabeli danych.  
  
 Jeśli nowy wiersz narusza ograniczenie nie zostanie dodany do tabeli danych.  
  
 Możesz uzyskać indeks nowy wiersz z DataTable.Rows.Find i DataTable.Rows.IndexOf. Zobacz <xref:System.Data.DataRowCollection> i <xref:System.Data.DataTable.Rows%2A> Aby uzyskać więcej informacji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initialized">
      <MemberSignature Language="C#" Value="public event EventHandler Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.Initialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Initialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ Initialized;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po <see cref="T:System.Data.DataTable" /> został zainicjowany.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji, zobacz <xref:System.Data.DataTable.IsInitialized%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInitialized">
      <MemberSignature Language="C#" Value="public bool IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.IsInitialized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInitialized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitialized { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Data.DataTable" /> został zainicjowany.</summary>
        <value>
          <see langword="true" /> Aby wskazać składnika została ukończona inicjowania; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwraca stan <xref:System.Data.DataTable> podczas jego jest tworzona, na przykład przez program Visual Studio. <xref:System.Data.DataTable.BeginInit%2A> Metody ustawia ją na `false` i <xref:System.Data.DataTable.EndInit%2A> metody ustawia ją na `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wypełnia <see cref="T:System.Data.DataTable" /> z wartości ze źródłem danych przy użyciu dostarczonego <see cref="T:System.Data.IDataReader" />. Jeśli <see langword="DataTable" /> już zawiera wiersze, dane przychodzące od źródła danych jest scalany z istniejących wierszy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Load` Metoda może być używana w kilka typowych scenariuszy, wszystkie wyśrodkowany wokół pobieranie danych z określonego źródła danych i dodanie go do bieżącego kontenera danych (w tym przypadku `DataTable`). Te scenariusze opisano standardowego użycia dla `DataTable`, opisujący jej aktualizacji i scal zachowanie.  
  
 A `DataTable` synchronizuje lub aktualizuje z pojedynczego podstawowego źródła danych. `DataTable` Śledzi zmiany, dzięki czemu synchronizacji z podstawowego źródła danych. Ponadto `DataTable` może zaakceptować danych pierwotnych z co najmniej jedno źródło danych pomocniczych. `DataTable` Nie jest odpowiedzialny za śledzenia zmian w celu umożliwienia synchronizacji z pomocnicze źródło danych.  
  
 Podana tych dwóch źródeł danych hipotetyczny, użytkownik prawdopodobnie muszą mieć jedną z następujących problemów:  
  
-   Inicjowanie `DataTable` ze źródła danych podstawowych. W tym scenariuszu użytkownik chce zainicjować pustą `DataTable` wartościami z podstawowego źródła danych. Użytkownik zamierza później propagowanie zmian z powrotem na podstawowego źródła danych.  
  
-   Zachować zmiany, a następnie przeprowadź ponowną synchronizację z podstawowego źródła danych. W tym scenariuszu użytkownik chce przejąć `DataTable` wypełnione w poprzednim scenariuszu i wykonywać synchronizację przyrostową z podstawowego źródła danych, zachowując zmian wprowadzonych w `DataTable`.  
  
-   Źródła danych pierwotnych z pomocniczych źródeł danych. W tym scenariuszu użytkownik chce scalić zmiany z co najmniej jedno źródło danych pomocniczych i Propaguj tych zmian z powrotem na podstawowego źródła danych.  
  
 `Load` Metody umożliwia tych scenariuszy. Wszystkie, oprócz jednego z przeciążeń dla tej metody można określić parametr opcji obciążenia, wskazującą sposób wierszy znajdujących się w <xref:System.Data.DataTable> łączyć z wierszy ładowany. (Przeciążenie, które nie zezwala na określenie zachowania używa domyślną opcją obciążenia). W poniższej tabeli opisano opcje trzy obciążenia pochodzącymi <xref:System.Data.LoadOption> wyliczenia. W każdym przypadku opis wskazuje zachowanie, gdy klucz podstawowy wiersza w danych przychodzących jest zgodna z klucza podstawowego istniejącego wiersza.  
  
|Opcja obciążenia|Opis|  
|-----------------|-----------------|  
|`PreserveChanges` (ustawienie domyślne)|Aktualizuje wartości przychodzących wiersza oryginalnej wersji wiersza.|  
|`OverwriteChanges`|Aktualizuje wersje bieżących i oryginalnych wiersza wartości przychodzących wiersza.|  
|`Upsert`|Aktualizuje wartości wiersza przychodzące bieżącej wersji wiersza.|  
  
 Ogólnie rzecz biorąc `PreserveChanges` i `OverwriteChanges` opcje są przeznaczone dla scenariuszy, w których użytkownik chce synchronizować `DataSet` i jego zmiany z podstawowego źródła danych. `Upsert` Opcja umożliwia agregację zmiany z co najmniej jedno źródło danych pomocniczych.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano kilka zagadnień związanych z wywołaniem <xref:System.Data.DataTable.Load%2A> metody. Najpierw przykładzie koncentruje się na problemy schematu, łącznie z wnioskowanie schematu z załadować <xref:System.Data.IDataReader>, a następnie Obsługa niezgodne schematów i schematów, dla których brakuje lub dodatkowych kolumn. Przykład następnie koncentruje się na problemy z danych, w tym obsługi różnych opcji ładowania.  
  
> [!NOTE]
>  W tym przykładzie pokazano, jak używać jednej z zastąpionej wersji `Load`. Inne przykłady, które mogą być dostępne znajduje się w tematach poszczególnych przeciążenia.  
  
 [!code-csharp[DataWorks DataTableLoad#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableLoad/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableLoad#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableLoad/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Data.DataSet.Load" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Data.IDataReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Data.IDataReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Load(System.Data.IDataReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Load (reader As IDataReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Data::IDataReader ^ reader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Data.IDataReader" /> Udostępniająca zestaw wyników.</param>
        <summary>Wypełnia <see cref="T:System.Data.DataTable" /> z wartości ze źródłem danych przy użyciu dostarczonego <see cref="T:System.Data.IDataReader" />. Jeśli <see cref="T:System.Data.DataTable" /> już zawiera wiersze, dane przychodzące od źródła danych jest scalany z istniejących wierszy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.Load%2A> — Metoda korzysta z pierwszego zestawu wyników z załadować <xref:System.Data.IDataReader>i po pomyślnym ukończeniu ustawia czytelnika pozycji dalej zestaw wyników, jeśli istnieją. Podczas konwertowania danych, `Load` — metoda korzysta z tej samej reguły konwersji jako <xref:System.Data.Common.DbDataAdapter.Fill%2A?displayProperty=nameWithType> metody.  
  
 <xref:System.Data.DataTable.Load%2A> Metody należy wziąć pod uwagę trzy określonych problemów podczas ładowania danych z <xref:System.Data.IDataReader> wystąpienie: operacje schematu, dane i zdarzenia. Podczas pracy ze schematem, <xref:System.Data.DataTable.Load%2A> metody mogą wystąpić warunki, zgodnie z opisem w poniższej tabeli. Operacje schematu została wykonana dla wszystkich zestawów wyników importowane, nawet tych, które zawierają żadnych danych.  
  
|Warunek|Zachowanie|  
|---------------|--------------|  
|<xref:System.Data.DataTable> Ma nie schematu.|<xref:System.Data.DataTable.Load%2A> Metody wnioskuje schemat oparte na zestawu wyników z importowanego <xref:System.Data.IDataReader>.|  
|<xref:System.Data.DataTable> Ma schematu, ale nie jest zgodny ze schematem załadowany.|<xref:System.Data.DataTable.Load%2A> Metoda zgłosi wyjątek odpowiadający określonym błąd występujący podczas próby załadowania danych do schematu niezgodne.|  
|Schematy są zgodne, ale schemat zestawu załadować wynik zawiera kolumny, które nie istnieją w <xref:System.Data.DataTable>.|<xref:System.Data.DataTable.Load%2A> Metoda dodaje dodatkowe kolumny `DataTable`tego schematu. Metoda zgłasza wyjątek, jeśli odpowiadającego kolumn w <xref:System.Data.DataTable> i zestawu wyników załadować nie są zgodne wartości. Metoda pobiera również informacje o ograniczeniach z zestawu wyników dla wszystkich dodanych kolumn. Z wyjątkiem w przypadku ograniczenia Primary Key, te informacje ograniczenie jest używane tylko wtedy, gdy bieżący <xref:System.Data.DataTable> nie zawiera żadnych kolumn w chwili rozpoczęcia operacji ładowania.|  
|Schematy są zgodne, ale schemat zestawu załadować wynik zawiera mniejszą liczbę kolumn niż `DataTable`.|Jeśli brakuje kolumna ma zdefiniowanej wartości domyślnej lub wartości null, jest typ danych kolumny <xref:System.Data.DataTable.Load%2A> metoda pozwala wierszy ma zostać dodany, zastępując wartość domyślna lub `null` wartości w kolumnie brak. Jeśli ma wartości domyślnej lub `null` mogą być używane, a następnie `Load` metoda zgłasza wyjątek. Jeśli zostały podane nie wybraną wartość domyślną, `Load` używa metody `null` wartość jako wartość domyślną domyślnych.|  
  
 Przed biorąc pod uwagę zachowanie `Load` metody w odniesieniu do operacji danych uważają, że każdy wiersz w <xref:System.Data.DataTable> obsługuje zarówno bieżąca wartość i oryginalnej wartości dla każdej kolumny. Te wartości mogą być równoważna lub mogą być inne, jeśli dane w wierszu zostały zmienione od czasu wypełnianie `DataTable`.  Aby uzyskać więcej informacji, zobacz [stany wiersza i wersje wiersza](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md).  
  
 Ta wersja `Load` metoda próbuje zachować bieżące wartości w każdym wierszu, pozostawiając bez zmian oryginalnej wartości. (Aby uzyskać bardziej precyzyjną kontrolę nad zachowaniem przychodzących danych zobacz <xref:System.Data.DataTable.Load%2A?displayProperty=nameWithType>.) Jeśli istniejący wiersz i wiersz zawiera odpowiednie wartości klucza podstawowego, wiersz jest przetwarzany za pomocą jego wartość stanu bieżącego wiersza, w przeciwnym razie jest ona traktowana jako nowy wiersz.  
  
 W odniesieniu do operacji zdarzeń <xref:System.Data.DataTable.RowChanging> zdarzenie przed każdego wiersza zostanie zmieniona i <xref:System.Data.DataTable.RowChanged> zdarzenie po zmianie każdego wiersza. W każdym przypadku <xref:System.Data.DataRowChangeEventArgs.Action%2A> właściwość <xref:System.Data.DataRowChangeEventArgs> wystąpienia przekazane do programu obsługi zdarzeń zawiera informacje o określonej akcji, skojarzone ze zdarzeniem. Ta wartość akcji zależny od stanu wiersza przed operacji ładowania. W każdym przypadku wystąpienia obu zdarzeń, a akcja jest taka sama dla każdego. Akcja może być stosowany do bieżącej lub oryginalnej wersji każdego wiersza i/lub w zależności od bieżącego stanu wiersza.  
  
 W poniższej tabeli przedstawiono zachowania dla `Load` metody. Wiersza końcowego (oznaczony "(Brak)") określa zachowanie dla przychodzących wierszy, które nie odpowiadają dowolnego istniejącego wiersza. Każdej komórki w poniższej tabeli opisano bieżących i oryginalnych wartości pola w wierszu, wraz z <xref:System.Data.DataRowState> wartości po `Load` metody została ukończona. W tym przypadku metoda nie zezwala na wskazać opcja obciążenia i używa domyślnie `PreserveChanges`.  
  
|Istniejącą właściwością DataRowState.|Wartości po `Load` — metoda i zdarzenie akcji|  
|---------------------------|--------------------------------------------------|  
|Dodane|Bieżący = \<istniejących ><br /><br /> Oryginalny = \<przychodzące ><br /><br /> Stan = \<zmodyfikować ><br /><br /> RowAction = ChangeOriginal|  
|Zmodyfikowano|Bieżący = \<istniejących ><br /><br /> Oryginalny = \<przychodzące ><br /><br /> Stan = \<zmodyfikować ><br /><br /> RowAction = ChangeOriginal|  
|Usunięte|Bieżący = \<nie jest dostępny ><br /><br /> Oryginalny = \<przychodzące ><br /><br /> Stan = \<usunięty ><br /><br /> RowAction = ChangeOriginal|  
|Bez zmian|Bieżący = \<przychodzące ><br /><br /> Oryginalny = \<przychodzące ><br /><br /> Stan = \<niezmienione ><br /><br /> RowAction = ChangeCurrentAndOriginal|  
|(Brak)|Bieżący = \<przychodzące ><br /><br /> Oryginalny = \<przychodzące ><br /><br /> Stan = \<niezmienione ><br /><br /> RowAction = ChangeCurrentAndOriginal|  
  
 Wartości w <xref:System.Data.DataColumn> może być ograniczona przy użyciu właściwości takich jak <xref:System.Data.DataColumn.ReadOnly%2A> i <xref:System.Data.DataColumn.AutoIncrement%2A>. `Load` Metoda obsługuje takich kolumn w taki sposób, który jest zgodny z zachowaniem zdefiniowany za pomocą właściwości kolumny. Ograniczenie odczytu tylko <xref:System.Data.DataColumn> ma zastosowanie tylko w przypadku zmiany wprowadzone w pamięci. `Load` Metody spowoduje zastąpienie wartości kolumny tylko do odczytu, jeśli to konieczne.  
  
 Aby ustalić, która wersja klucz podstawowy dla porównanie bieżącego wiersza z wierszem przychodzące `Load` — metoda korzysta z oryginalną wersją wartość klucza podstawowego w wierszu, a jeśli istnieje. W przeciwnym razie `Load` — metoda korzysta z bieżącej wersji klucz podstawowy.  
  
   
  
## Examples  
 W poniższym przykładzie pokazano kilka zagadnień związanych z wywołaniem <xref:System.Data.DataTable.Load%2A> metody. Najpierw przykładzie koncentruje się na problemy schematu, łącznie z wnioskowanie schematu z załadować <xref:System.Data.IDataReader>, a następnie Obsługa niezgodne schematów i schematów, dla których brakuje lub dodatkowych kolumn. Przykład wywołuje `Load` metoda wyświetla dane przed i po operacji ładowania.  
  
 [!code-csharp[DataWorks DataTableLoad.IDataReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableLoad.IDataReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableLoad.IDataReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableLoad.IDataReader/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Load(System::Data::IDataReader ^ reader, System::Data::LoadOption loadOption);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Data.IDataReader" /> Zapewnia jeden lub więcej zestawów wyników.</param>
        <param name="loadOption">Wartość z zakresu od <see cref="T:System.Data.LoadOption" /> wyliczenia, która wskazuje, jak wierszy znajdujących się w <see cref="T:System.Data.DataTable" /> są łączone z przychodzącego wierszy, które mają taki sam klucz podstawowy.</param>
        <summary>Wypełnia <see cref="T:System.Data.DataTable" /> z wartości ze źródłem danych przy użyciu dostarczonego <see cref="T:System.Data.IDataReader" />. Jeśli <see langword="DataTable" /> już zawiera wiersze, dane przychodzące od źródła danych jest scalany z istniejących wierszy, zgodnie z wartością <paramref name="loadOption" /> parametru.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Load` — Metoda korzysta z pierwszego zestawu wyników z załadować <xref:System.Data.IDataReader>i po pomyślnym ukończeniu ustawia czytelnika pozycji dalej zestaw wyników, jeśli istnieją. Podczas konwertowania danych, `Load` — metoda korzysta z tej samej reguły konwersji jako <xref:System.Data.Common.DbDataAdapter.Fill%2A> metody.  
  
 `Load` Metody należy wziąć pod uwagę trzy określonych problemów podczas ładowania danych z <xref:System.Data.IDataReader> wystąpienie: operacje schematu, dane i zdarzenia. Podczas pracy ze schematem, `Load` metody mogą wystąpić warunki, zgodnie z opisem w poniższej tabeli. Operacje schematu została wykonana dla wszystkich zestawów wyników importowane, nawet tych, które zawierają żadnych danych.  
  
|Warunek|Zachowanie|  
|---------------|--------------|  
|<xref:System.Data.DataTable> Ma nie schematu.|`Load` Metody wnioskuje schemat oparte na zestawu wyników z importowanego <xref:System.Data.IDataReader>.|  
|<xref:System.Data.DataTable> Ma schematu, ale nie jest zgodny ze schematem załadowany.|`Load` Metoda zgłosi wyjątek odpowiadający określonym błąd występujący podczas próby załadowania danych do schematu niezgodne.|  
|Schematy są zgodne, ale schemat zestawu załadować wynik zawiera kolumny, które nie istnieją w `DataTable`.|`Load` Metoda dodaje dodatkowe kolumny `DataTable`tego schematu. Metoda zgłasza wyjątek, jeśli odpowiadającego kolumn w <xref:System.Data.DataTable> i zestawu wyników załadować nie są zgodne wartości. Metoda pobiera również informacje o ograniczeniach z zestawu wyników dla wszystkich dodanych kolumn. Z wyjątkiem w przypadku ograniczenia Primary Key, te informacje ograniczenie jest używane tylko wtedy, gdy bieżący <xref:System.Data.DataTable> nie zawiera żadnych kolumn w chwili rozpoczęcia operacji ładowania.|  
|Schematy są zgodne, ale schemat zestawu załadować wynik zawiera mniejszą liczbę kolumn niż `DataTable`.|Jeśli brakuje kolumna ma zdefiniowanej wartości domyślnej lub wartości null, jest typ danych kolumny `Load` metoda pozwala wierszy ma zostać dodany, zastępując wartości domyślne lub wartość null w kolumnie brak. Jeśli może być używany nie wartości domyślnej lub wartość null, a następnie `Load` metoda zgłasza wyjątek. Jeśli zostały podane nie wybraną wartość domyślną, `Load` — metoda korzysta z wartości null jako wartość domyślną domyślnych.|  
  
 Przed biorąc pod uwagę zachowanie `Load` metody w odniesieniu do operacji danych uważają, że każdy wiersz w <xref:System.Data.DataTable> obsługuje zarówno bieżąca wartość i oryginalnej wartości dla każdej kolumny. Te wartości mogą być równoważna lub mogą być inne, jeśli dane w wierszu zostały zmienione od czasu wypełnianie `DataTable`. Zobacz [stany wiersza i wersje wiersza](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md) Aby uzyskać więcej informacji.  
  
 W tym wywołania metody, określony <xref:System.Data.LoadOption> parametr ma wpływ przetwarzania przychodzących danych. Jak metoda obciążenia powinna obsługiwać ładowania wierszy, które mają taki sam klucz podstawowy, jak istniejące wiersze Należy go zmodyfikować wartości bieżących i oryginalnych wartości? Te problemy i inne, są kontrolowane przez `loadOption` parametru.  
  
 Jeśli istniejący wiersz i wiersz zawiera odpowiednie wartości klucza podstawowego, wiersz jest przetwarzany za pomocą jego wartość stanu bieżącego wiersza, w przeciwnym razie jest ona traktowana jako nowy wiersz.  
  
 W odniesieniu do operacji zdarzeń <xref:System.Data.DataTable.RowChanging> zdarzenie przed każdego wiersza zostanie zmieniona i <xref:System.Data.DataTable.RowChanged> zdarzenie po zmianie każdego wiersza. W każdym przypadku <xref:System.Data.DataRowChangeEventArgs.Action%2A> właściwość <xref:System.Data.DataRowChangeEventArgs> wystąpienia przekazane do programu obsługi zdarzeń zawiera informacje o określonej akcji, skojarzone ze zdarzeniem. Wartość tego działania różni się w zależności od stanu wiersz przed operacji ładowania. W każdym przypadku wystąpienia obu zdarzeń, a akcja jest taka sama dla każdego. Akcja może być stosowany do bieżącej lub oryginalnej wersji każdego wiersza i/lub w zależności od bieżącego stanu wiersza.  
  
 W poniższej tabeli przedstawiono zachowania dla metody Load, gdy wywoływana z każdym z `LoadOption` wartości, a także przedstawia interakcje wartości ze stanem wiersza dla wiersza ładowany. Wiersza końcowego (oznaczony "(Brak)") określa zachowanie dla przychodzących wierszy, które nie odpowiadają dowolnego istniejącego wiersza. Każdej komórki w poniższej tabeli opisano bieżących i oryginalnych wartości pola w wierszu, wraz z <xref:System.Data.DataRowState> wartości po `Load` metody została ukończona.  
  
|Istniejącą właściwością DataRowState.|UPSERT|OverwriteChanges|PreserveChanges (domyślnie)|  
|---------------------------|------------|----------------------|------------------------------------------|  
|Dodane|Bieżący = \<przychodzące ><br /><br /> Oryginalny = -\<nie jest dostępny ><br /><br /> Stan = \<dodane ><br /><br /> RowAction = zmiany|Bieżący = \<przychodzące ><br /><br /> Oryginalny = \<przychodzące ><br /><br /> Stan = \<niezmienione ><br /><br /> RowAction = ChangeCurrentAndOriginal|Bieżący = \<istniejących ><br /><br /> Oryginalny = \<przychodzące ><br /><br /> Stan = \<zmodyfikować ><br /><br /> RowAction = ChangeOriginal|  
|Zmodyfikowano|Bieżący = \<przychodzące ><br /><br /> Oryginalny = \<istniejących ><br /><br /> Stan = \<zmodyfikować ><br /><br /> RowAction = zmiany|Bieżący = \<przychodzące ><br /><br /> Oryginalny = \<przychodzące ><br /><br /> Stan = \<niezmienione ><br /><br /> RowAction = ChangeCurrentAndOriginal|Bieżący = \<istniejących ><br /><br /> Oryginalny = \<przychodzące ><br /><br /> Stan = \<zmodyfikować ><br /><br /> RowAction = ChangeOriginal|  
ersję usuniętą|(Nie wpływają na usunięte wiersze nie obciążenia)<br /><br /> Bieżący =---<br /><br /> Oryginalny = \<istniejących ><br /><br /> Stan = \<usunięty ><br /><br /> (Dodaniu nowego rzędu o następującej charakterystyce)<br /><br /> Bieżący = \<przychodzące ><br /><br /> Oryginalny = \<nie jest dostępny ><br /><br /> Stan = \<dodane ><br /><br /> RowAction = Dodaj|Cofanie usuwania i<br /><br /> Bieżący = \<przychodzące ><br /><br /> Oryginalny = \<przychodzące ><br /><br /> Stan = \<niezmienione ><br /><br /> RowAction = ChangeCurrentAndOriginal|Bieżący = \<nie jest dostępny ><br /><br /> Oryginalny = \<przychodzące ><br /><br /> Stan = \<usunięty ><br /><br /> RowAction = ChangeOriginal|  
|Bez zmian|Bieżący = \<przychodzące ><br /><br /> Oryginalny = \<istniejących ><br /><br /> Jeśli nowa wartość jest taka sama jak wartość następnie<br /><br /> Stan = \<niezmienione ><br /><br /> RowAction = nic nie<br /><br /> else<br /><br /> Stan = \<zmodyfikować ><br /><br /> RowAction = zmiany|Bieżący = \<przychodzące ><br /><br /> Oryginalny = \<przychodzące ><br /><br /> Stan = \<niezmienione ><br /><br /> RowAction = ChangeCurrentAndOriginal|Bieżący = \<przychodzące ><br /><br /> Oryginalny = \<przychodzące ><br /><br /> Stan = \<niezmienione ><br /><br /> RowAction = ChangeCurrentAndOriginal|  
Nie istnieje)|Bieżący = \<przychodzące ><br /><br /> Oryginalny = \<nie jest dostępny ><br /><br /> Stan = \<dodane ><br /><br /> RowAction = Dodaj|Bieżący = \<przychodzące ><br /><br /> Oryginalny = \<przychodzące ><br /><br /> Stan = \<niezmienione ><br /><br /> RowAction = ChangeCurrentAndOriginal|Bieżący = \<przychodzące ><br /><br /> Oryginalny = \<przychodzące ><br /><br /> Stan = \<niezmienione ><br /><br /> RowAction = ChangeCurrentAndOriginal|  
  
 Wartości w <xref:System.Data.DataColumn> może być ograniczona przy użyciu właściwości takich jak <xref:System.Data.DataColumn.ReadOnly%2A> i <xref:System.Data.DataColumn.AutoIncrement%2A>. `Load` Metoda obsługuje takich kolumn w taki sposób, który jest zgodny z zachowaniem zdefiniowany za pomocą właściwości kolumny. Ograniczenie odczytu tylko <xref:System.Data.DataColumn> ma zastosowanie tylko w przypadku zmiany wprowadzone w pamięci. `Load` Metody spowoduje zastąpienie wartości kolumny tylko do odczytu, jeśli to konieczne.  
  
 Jeśli można określić opcji OverwriteChanges lub PreserveChanges podczas wywoływania metody `Load` metody, a następnie zakładając staje się czy danych przychodzących jest pochodzi z `DataTable`przez podstawowe źródło danych i DataTable śledzi zmiany i można propagować zmian z powrotem do źródła danych. Jeśli wybrano opcję Upsert zakłada się, że pochodzą dane z jednego z pomocnicze źródło danych, takich jak dane dostarczone przez składnik warstwy środkowej, być może zostały zmienione przez użytkownika. W takim przypadku założenie jest celem do agregowania danych z jednego lub więcej źródeł danych w `DataTable`i być może propagować danych do podstawowego źródła danych. <xref:System.Data.LoadOption> Parametr jest używany do określania wersji wiersza, który ma być używana do porównania klucza podstawowego. Poniższa tabela zawiera szczegółowe informacje.  
  
|Opcja obciążenia|Wersja DataRow używana na potrzeby porównania klucza podstawowego|  
|-----------------|-----------------------------------------------------|  
|`OverwriteChanges`|Oryginalnej wersji, jeśli istnieje, w przeciwnym razie bieżącej wersji|  
|`PreserveChanges`|Oryginalnej wersji, jeśli istnieje, w przeciwnym razie bieżącej wersji|  
|`Upsert`|Bieżąca wersja, jeśli istnieje, w przeciwnym razie oryginalnej wersji|  
  
   
  
## Examples  
 W poniższym przykładzie pokazano kilka zagadnień związanych z wywołaniem <xref:System.Data.DataTable.Load%2A> metody. Najpierw przykładzie koncentruje się na problemy schematu, łącznie z wnioskowanie schematu z załadować <xref:System.Data.IDataReader>, a następnie Obsługa niezgodne schematów i schematów, dla których brakuje lub dodatkowych kolumn. Przykład następnie koncentruje się na problemy z danych, w tym obsługi różnych opcji ładowania.  
  
 [!code-csharp[DataWorks DataTableLoad.LoadOption#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableLoad.LoadOption/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableLoad.LoadOption#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableLoad.LoadOption/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public virtual void Load (System.Data.IDataReader reader, System.Data.LoadOption loadOption, System.Data.FillErrorEventHandler errorHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Load(class System.Data.IDataReader reader, valuetype System.Data.LoadOption loadOption, class System.Data.FillErrorEventHandler errorHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Load(System.Data.IDataReader,System.Data.LoadOption,System.Data.FillErrorEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Load(System::Data::IDataReader ^ reader, System::Data::LoadOption loadOption, System::Data::FillErrorEventHandler ^ errorHandler);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Data.IDataReader" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
        <Parameter Name="errorHandler" Type="System.Data.FillErrorEventHandler" />
      </Parameters>
      <Docs>
        <param name="reader">A <see cref="T:System.Data.IDataReader" /> udostępniająca zestaw wyników.</param>
        <param name="loadOption">Wartość z zakresu od <see cref="T:System.Data.LoadOption" /> wyliczenia, która wskazuje, jak wierszy znajdujących się w <see cref="T:System.Data.DataTable" /> są łączone z przychodzącego wierszy, które mają taki sam klucz podstawowy.</param>
        <param name="errorHandler">A <see cref="T:System.Data.FillErrorEventHandler" /> delegata do wywołania, gdy wystąpi błąd podczas ładowania danych.</param>
        <summary>Wypełnia <see cref="T:System.Data.DataTable" /> z wartości ze źródłem danych przy użyciu dostarczonego <see cref="T:System.Data.IDataReader" /> za pomocą obiektu delegowanego obsługi błędów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Load` — Metoda korzysta z pierwszego zestawu wyników z załadować <xref:System.Data.IDataReader>i po pomyślnym ukończeniu ustawia czytelnika pozycji dalej zestaw wyników, jeśli istnieją. Podczas konwertowania danych, `Load` — metoda korzysta z tej samej reguły konwersji jako <xref:System.Data.Common.DbDataAdapter.Fill%2A?displayProperty=nameWithType> metody.  
  
 `Load` Metody należy wziąć pod uwagę trzy określonych problemów podczas ładowania danych z <xref:System.Data.IDataReader> wystąpienie: operacje schematu, dane i zdarzenia. Podczas pracy ze schematem, `Load` metody mogą wystąpić warunki, zgodnie z opisem w poniższej tabeli. Operacje schematu została wykonana dla wszystkich zestawów wyników importowane, nawet tych, które zawierają żadnych danych.  
  
|Warunek|Zachowanie|  
|---------------|--------------|  
|<xref:System.Data.DataTable> Ma nie schematu.|`Load` Metody wnioskuje schemat oparte na zestawu wyników z importowanego <xref:System.Data.IDataReader>.|  
|<xref:System.Data.DataTable> Ma schematu, ale nie jest zgodny ze schematem załadowany.|`Load` Metoda zgłosi wyjątek odpowiadający określonym błąd występujący podczas próby załadowania danych do schematu niezgodne.|  
|Schematy są zgodne, ale schemat zestawu załadować wynik zawiera kolumny, które nie istnieją w `DataTable`.|`Load` Metoda dodaje dodatkowe kolumny do `DataTable`tego schematu. Metoda zgłasza wyjątek, jeśli odpowiadającego kolumn w <xref:System.Data.DataTable> i zestawu wyników załadować nie są zgodne wartości. Metoda pobiera również informacje o ograniczeniach z zestawu wyników dla wszystkich dodanych kolumn. Z wyjątkiem w przypadku ograniczenia Primary Key, te informacje ograniczenie jest używane tylko wtedy, gdy bieżący <xref:System.Data.DataTable> nie zawiera żadnych kolumn w chwili rozpoczęcia operacji ładowania.|  
|Schematy są zgodne, ale schemat zestawu załadować wynik zawiera mniejszą liczbę kolumn niż `DataTable`.|Jeśli brakuje kolumna ma zdefiniowanej wartości domyślnej lub wartości null, jest typ danych kolumny `Load` metoda pozwala wierszy ma zostać dodany, zastępując wartości domyślne lub wartość null w kolumnie brak. Jeśli może być używany nie wartości domyślnej lub wartość null, a następnie `Load` metoda zgłasza wyjątek. Jeśli zostały podane nie wybraną wartość domyślną, `Load` — metoda korzysta z wartości null jako wartość domyślną domyślnych.|  
  
 Przed biorąc pod uwagę zachowanie `Load` metody w odniesieniu do operacji danych uważają, że każdy wiersz w <xref:System.Data.DataTable> obsługuje zarówno bieżąca wartość i oryginalnej wartości dla każdej kolumny. Te wartości mogą być równoważna lub mogą być inne, jeśli dane w wierszu zostały zmienione od czasu wypełnianie `DataTable`. Zobacz [stany wiersza i wersje wiersza](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md) Aby uzyskać więcej informacji.  
  
 W tym wywołania metody, określony <xref:System.Data.LoadOption> parametr ma wpływ przetwarzania przychodzących danych. Jak metoda obciążenia powinna obsługiwać ładowania wierszy, które mają taki sam klucz podstawowy, jak istniejące wiersze Należy go zmodyfikować wartości bieżących i oryginalnych wartości? Te problemy i inne, są kontrolowane przez `loadOption` parametru.  
  
 Jeśli istniejący wiersz i wiersz zawiera odpowiednie wartości klucza podstawowego, wiersz jest przetwarzany za pomocą jego wartość stanu bieżącego wiersza, w przeciwnym razie jest ona traktowana jako nowy wiersz.  
  
 W odniesieniu do operacji zdarzeń <xref:System.Data.DataTable.RowChanging> zdarzenie przed każdego wiersza zostanie zmieniona i <xref:System.Data.DataTable.RowChanged> zdarzenie po zmianie każdego wiersza. W każdym przypadku <xref:System.Data.DataRowChangeEventArgs.Action%2A> właściwość <xref:System.Data.DataRowChangeEventArgs> wystąpienia przekazane do programu obsługi zdarzeń zawiera informacje o określonej akcji, skojarzone ze zdarzeniem. Wartość tego działania różni się w zależności od stanu wiersz przed operacji ładowania. W każdym przypadku wystąpienia obu zdarzeń, a akcja jest taka sama dla każdego. Akcja może być stosowany do bieżącej lub oryginalnej wersji każdego wiersza i/lub w zależności od bieżącego stanu wiersza.  
  
 W poniższej tabeli przedstawiono zachowania dla metody Load, gdy wywoływana z każdym z `LoadOption` wartości, a także przedstawia interakcje wartości ze stanem wiersza dla wiersza ładowany. Wiersza końcowego (oznaczony "(Brak)") określa zachowanie dla przychodzących wierszy, które nie odpowiadają dowolnego istniejącego wiersza. Każdej komórki w poniższej tabeli opisano bieżących i oryginalnych wartości pola w wierszu, wraz z <xref:System.Data.DataRowState> wartości po `Load` metody została ukończona.  
  
|Istniejącą właściwością DataRowState.|UPSERT|OverwriteChanges|PreserveChanges (domyślnie)|  
|---------------------------|------------|----------------------|------------------------------------------|  
|Dodane|Bieżący = \<przychodzące ><br /><br /> Oryginalny = -\<nie jest dostępny ><br /><br /> Stan = \<dodane ><br /><br /> RowAction = zmiany|Bieżący = \<przychodzące ><br /><br /> Oryginalny = \<przychodzące ><br /><br /> Stan = \<niezmienione ><br /><br /> RowAction = ChangeCurrentAndOriginal|Bieżący = \<istniejących ><br /><br /> Oryginalny = \<przychodzące ><br /><br /> Stan = \<zmodyfikować ><br /><br /> RowAction = ChangeOriginal|  
|Zmodyfikowano|Bieżący = \<przychodzące ><br /><br /> Oryginalny = \<istniejących ><br /><br /> Stan = \<zmodyfikować ><br /><br /> RowAction = zmiany|Bieżący = \<przychodzące ><br /><br /> Oryginalny = \<przychodzące ><br /><br /> Stan = \<niezmienione ><br /><br /> RowAction = ChangeCurrentAndOriginal|Bieżący = \<istniejących ><br /><br /> Oryginalny = \<przychodzące ><br /><br /> Stan = \<zmodyfikować ><br /><br /> RowAction = ChangeOriginal|  
ersję usuniętą|(Nie wpływają na usunięte wiersze nie obciążenia)<br /><br /> Bieżący =---<br /><br /> Oryginalny = \<istniejących ><br /><br /> Stan = \<usunięty ><br /><br /> (Dodaniu nowego rzędu o następującej charakterystyce)<br /><br /> Bieżący = \<przychodzące ><br /><br /> Oryginalny = \<nie jest dostępny ><br /><br /> Stan = \<dodane ><br /><br /> RowAction = Dodaj|Cofanie usuwania i<br /><br /> Bieżący = \<przychodzące ><br /><br /> Oryginalny = \<przychodzące ><br /><br /> Stan = \<niezmienione ><br /><br /> RowAction = ChangeCurrentAndOriginal|Bieżący = \<nie jest dostępny ><br /><br /> Oryginalny = \<przychodzące ><br /><br /> Stan = \<usunięty ><br /><br /> RowAction = ChangeOriginal|  
|Bez zmian|Bieżący = \<przychodzące ><br /><br /> Oryginalny = \<istniejących ><br /><br /> Jeśli nowa wartość jest taka sama jak wartość następnie<br /><br /> Stan = \<niezmienione ><br /><br /> RowAction = nic nie<br /><br /> else<br /><br /> Stan = \<zmodyfikować ><br /><br /> RowAction = zmiany|Bieżący = \<przychodzące ><br /><br /> Oryginalny = \<przychodzące ><br /><br /> Stan = \<niezmienione ><br /><br /> RowAction = ChangeCurrentAndOriginal|Bieżący = \<przychodzące ><br /><br /> Oryginalny = \<przychodzące ><br /><br /> Stan = \<niezmienione ><br /><br /> RowAction = ChangeCurrentAndOriginal|  
Nie istnieje)|Bieżący = \<przychodzące ><br /><br /> Oryginalny = \<nie jest dostępny ><br /><br /> Stan = \<dodane ><br /><br /> RowAction = Dodaj|Bieżący = \<przychodzące ><br /><br /> Oryginalny = \<przychodzące ><br /><br /> Stan = \<niezmienione ><br /><br /> RowAction = ChangeCurrentAndOriginal|Bieżący = \<przychodzące ><br /><br /> Oryginalny = \<przychodzące ><br /><br /> Stan = \<niezmienione ><br /><br /> RowAction = ChangeCurrentAndOriginal|  
  
 Wartości w <xref:System.Data.DataColumn> może być ograniczona przy użyciu właściwości takich jak <xref:System.Data.DataColumn.ReadOnly%2A> i <xref:System.Data.DataColumn.AutoIncrement%2A>. `Load` Metoda obsługuje takich kolumn w taki sposób, który jest zgodny z zachowaniem zdefiniowany za pomocą właściwości kolumny. Ograniczenie odczytu tylko <xref:System.Data.DataColumn> ma zastosowanie tylko w przypadku zmiany wprowadzone w pamięci. `Load` Metody spowoduje zastąpienie wartości kolumny tylko do odczytu, jeśli to konieczne.  
  
 Jeśli można określić opcji OverwriteChanges lub PreserveChanges podczas wywoływania metody `Load` metody, a następnie zakładając staje się czy danych przychodzących jest pochodzi z `DataTable`przez podstawowe źródło danych i DataTable śledzi zmiany i można propagować zmian z powrotem do źródła danych. Jeśli wybrano opcję Upsert zakłada się, że pochodzą dane z jednego z pomocnicze źródło danych, takich jak dane dostarczone przez składnik warstwy środkowej, być może zostały zmienione przez użytkownika. W takim przypadku założenie jest celem do agregowania danych z jednego lub więcej źródeł danych w `DataTable`i być może propagować danych do podstawowego źródła danych. <xref:System.Data.LoadOption> Parametr jest używany do określania wersji wiersza, który ma być używana do porównania klucza podstawowego. Poniższa tabela zawiera szczegółowe informacje.  
  
|Opcja obciążenia|Wersja DataRow używana na potrzeby porównania klucza podstawowego|  
|-----------------|-----------------------------------------------------|  
|`OverwriteChanges`|Oryginalnej wersji, jeśli istnieje, w przeciwnym razie bieżącej wersji|  
|`PreserveChanges`|Oryginalnej wersji, jeśli istnieje, w przeciwnym razie bieżącej wersji|  
|`Upsert`|Bieżąca wersja, jeśli istnieje, w przeciwnym razie oryginalnej wersji|  
  
 `errorHandler` Parametr jest <xref:System.Data.FillErrorEventHandler> delegata, który odwołuje się do procedury, która jest wywoływana, gdy wystąpi błąd podczas ładowania danych. <xref:System.Data.FillErrorEventArgs> Parametr przekazany do procedury dostarcza właściwości, które umożliwiają pobieranie informacji o błędzie, który wystąpił, bieżący wiersz danych, i <xref:System.Data.DataTable> są wypełnione. Za pomocą mechanizm ten delegat, zamiast prostsze bloku try/catch, służy do określania błędu, obsłużyć sytuację i kontynuować przetwarzanie, jeśli chcesz. <xref:System.Data.FillErrorEventArgs> Parametr dostarcza <xref:System.Data.FillErrorEventArgs.Continue%2A> właściwość: wartość tej właściwości `true` oznacza zapewnienia obsługi błędu i kontynuować przetwarzania. Ustaw dla właściwości `false` wskazująca, czy chcesz zatrzymać przetwarzanie. Należy pamiętać, że ustawienie właściwości `false` powoduje, że kod, która wyzwoliła problem do zgłoszenia wyjątku.  
  
   
  
## Examples  
 [!code-csharp[DataWorks DataTableLoad.ErrorEventHandler#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableLoad.ErrorEventHandler/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableLoad.ErrorEventHandler#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableLoad.ErrorEventHandler/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadDataRow">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wyszukuje i aktualizuje określonego wiersza. Jeśli zostanie znaleziony ma pasującego wiersza, nowy wiersz jest tworzony przy użyciu podanej wartości.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadDataRow">
      <MemberSignature Language="C#" Value="public System.Data.DataRow LoadDataRow (object[] values, bool fAcceptChanges);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow LoadDataRow(object[] values, bool fAcceptChanges) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.LoadDataRow(System.Object[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadDataRow (values As Object(), fAcceptChanges As Boolean) As DataRow" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataRow ^ LoadDataRow(cli::array &lt;System::Object ^&gt; ^ values, bool fAcceptChanges);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Object[]" />
        <Parameter Name="fAcceptChanges" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="values">Tablica wartości użyte do utworzenia nowego wiersza.</param>
        <param name="fAcceptChanges">
          <see langword="true" /> Aby zaakceptować zmiany. w przeciwnym razie <see langword="false" />.</param>
        <summary>Wyszukuje i aktualizuje określonego wiersza. Jeśli zostanie znaleziony ma pasującego wiersza, nowy wiersz jest tworzony przy użyciu podanej wartości.</summary>
        <returns>Nowe <see cref="T:System.Data.DataRow" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.LoadDataRow%2A> Metoda pobiera tablicę wartości i znajduje dopasowywania wartości z kolumn klucza podstawowego.  
  
 Jeśli kolumna ma wartość domyślną, należy przekazać wartość null w tablicy, tak aby ustawiać domyślną wartość dla tej kolumny. Podobnie jeśli kolumna zawiera jego <xref:System.Data.DataColumn.AutoIncrement%2A> właściwości ustawiono wartość true, należy przekazać wartość null w tablicy można ustawić wartości automatycznie generowanego wiersza.  
  
 Jeśli `fAcceptChanges` parametr jest `true` lub nie jest określony, dodaje nowe dane, a następnie <xref:System.Data.DataTable.AcceptChanges%2A> jest wywoływana, aby zaakceptować wszystkie zmiany w <xref:System.Data.DataTable>; Jeśli wartością argumentu jest `false`, nowo dodanych wierszy są oznaczone jako wstawienia i zmiany istniejące wiersze zostały oznaczone jako modyfikacje.  
  
 Wyjątki może również wystąpić podczas albo <xref:System.Data.DataTable.ColumnChanging> lub <xref:System.Data.DataTable.RowChanging> zdarzeń. Jeśli wystąpi wyjątek, wiersz nie został dodany do tabeli.  
  
 Użyj <xref:System.Data.DataTable.LoadDataRow%2A> w połączeniu z <xref:System.Data.DataTable.BeginLoadData%2A> i <xref:System.Data.DataTable.EndLoadData%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Data.DataTable.LoadDataRow%2A> metoda próbuje odnaleźć wiersza. Przypadku nieznalezienia ma takie wiersza, wartości są używane do tworzenia nowego wiersza.  
  
 [!code-csharp[Classic WebData DataTable.LoadDataRow Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.LoadDataRow Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.LoadDataRow Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.LoadDataRow Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Tablica jest większa niż liczba kolumn w tabeli.</exception>
        <exception cref="T:System.InvalidCastException">Wartość nie pasuje do typu jego odpowiednich kolumn.</exception>
        <exception cref="T:System.Data.ConstraintException">Dodawanie wiersza unieważnia ograniczenia.</exception>
        <exception cref="T:System.Data.NoNullAllowedException">Próba umieścić wartość null w kolumnie gdzie <see cref="P:System.Data.DataColumn.AllowDBNull" /> ma wartość false.</exception>
      </Docs>
    </Member>
    <Member MemberName="LoadDataRow">
      <MemberSignature Language="C#" Value="public System.Data.DataRow LoadDataRow (object[] values, System.Data.LoadOption loadOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow LoadDataRow(object[] values, valuetype System.Data.LoadOption loadOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.LoadDataRow(System.Object[],System.Data.LoadOption)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataRow ^ LoadDataRow(cli::array &lt;System::Object ^&gt; ^ values, System::Data::LoadOption loadOption);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Object[]" />
        <Parameter Name="loadOption" Type="System.Data.LoadOption" />
      </Parameters>
      <Docs>
        <param name="values">Tablica wartości użyte do utworzenia nowego wiersza.</param>
        <param name="loadOption">Używany do określania, jak wartości są stosowane do odpowiedniej wartości w istniejącym wierszu.</param>
        <summary>Wyszukuje i aktualizuje określonego wiersza. Jeśli zostanie znaleziony ma pasującego wiersza, nowy wiersz jest tworzony przy użyciu podanej wartości.</summary>
        <returns>Nowe <see cref="T:System.Data.DataRow" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.LoadDataRow%2A> Metoda pobiera tablicę wartości i znajduje dopasowywania wartości z kolumn klucza podstawowego.  
  
 Jeśli kolumna ma wartość domyślną, należy przekazać wartość null w tablicy, tak aby ustawiać domyślną wartość dla tej kolumny. Podobnie jeśli kolumna zawiera jego <xref:System.Data.DataColumn.AutoIncrement%2A> właściwości ustawiono wartość true, należy przekazać wartość null w tablicy można ustawić wartości automatycznie generowanego wiersza.  
  
 Wartość `loadOption` parametr jest używany do określenia sposobu wartości w tablicy są stosowane do istniejącego wiersza. Na przykład jeśli `loadOption` ustawiono `OverwriteChanges`, `Original` i `Current` wartości kolumn są zamieniane na wartości w wierszu przychodzące i `RowState` właściwość jest ustawiona na `Unchanged`.  
  
 Wyjątki może również wystąpić podczas albo <xref:System.Data.DataTable.ColumnChanging> lub <xref:System.Data.DataTable.RowChanging> zdarzeń. Jeśli wystąpi wyjątek, wiersz nie został dodany do tabeli.  
  
 Użyj <xref:System.Data.DataTable.LoadDataRow%2A> w połączeniu z <xref:System.Data.DataTable.BeginLoadData%2A> i <xref:System.Data.DataTable.EndLoadData%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Locale">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo Locale { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo Locale" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Locale" />
      <MemberSignature Language="VB.NET" Value="Public Property Locale As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ Locale { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia informacje dotyczące ustawień regionalnych używanych do porównania ciągów wewnątrz tabeli.</summary>
        <value>A <see cref="T:System.Globalization.CultureInfo" /> zawierający dane dotyczące ustawień regionalnych komputera użytkownika. Wartość domyślna to <see cref="T:System.Data.DataSet" /> obiektu <see cref="T:System.Globalization.CultureInfo" /> (zwrócony przez <see cref="P:System.Data.DataSet.Locale" /> właściwości) do której <see cref="T:System.Data.DataTable" /> należy; Jeśli tabeli nie należy do <see cref="T:System.Data.DataSet" />, wartość domyślna to bieżący system <see cref="T:System.Globalization.CultureInfo" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Globalization.CultureInfo> reprezentuje preferencje oprogramowania określonej kultury lub społeczności.  
  
 Gdy jest używany do porównywnania ciągów <xref:System.Globalization.CultureInfo> wpływa na filtrowanie i sortowanie porównania.  
  
> [!NOTE]
>  W kolumnach, które zawierają wyrażenia <xref:System.StringComparison.InvariantCulture> jest używany. <xref:System.StringComparison.CurrentCulture> Jest ignorowana.  
  
   
  
## Examples  
 W poniższym przykładzie <xref:System.Globalization.CultureInfo> za pośrednictwem <xref:System.Data.DataTable.Locale%2A> i wyświetla nazwę języka ISO.  
  
 [!code-csharp[Classic WebData DataTable.Locale Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Locale Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Locale Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Locale Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Merge">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Scal określonego <see cref="T:System.Data.DataTable" /> z bieżącym <see cref="T:System.Data.DataTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Merge` Metoda jest używana do scalenia dwa <xref:System.Data.DataTable> obiektów, które mają schematów w znacznym stopniu podobne. Scalanie jest zwykle używana w aplikacji klienta do zastosować ostatnie zmiany ze źródła danych w istniejącej <xref:System.Data.DataTable>. Umożliwia to aplikacji klienta odświeżyć <xref:System.Data.DataTable> przy użyciu najnowszych danych ze źródła danych.  
  
 Operacja scalania uwzględnia oryginalnej tabeli, a tabela, która ma być scalone. Nie dotyczy lub częścią tabele podrzędne. Jeśli tabela ma co najmniej jednej tabeli podrzędnej definiowane jako część relacji każdej tabeli podrzędnej muszą zostać połączone pojedynczo.  
  
   
  
## Examples  
 Następującej aplikacji konsoli Pokazuje zachowanie `missingSchemaAction` parametr <xref:System.Data.DataTable.Merge%2A> metody. W tym przykładzie tworzy dwie wersje tej samej tabeli modyfikowania schematu dla drugiego wersji. Kod podejmuje próbę scalenia drugiej tabeli pierwszy.  
  
> [!NOTE]
>  Ten przykład przedstawia sposób użycia jednej z wersji przeciążone scalania. Inne przykłady, które mogą być dostępne znajduje się w tematach poszczególnych przeciążenia.  
  
 [!code-csharp[DataWorks DataTableMergeOverload#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTableMergeOverload/CS/source.cs#1)]
 [!code-vb[DataWorks DataTableMergeOverload#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTableMergeOverload/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Merge(System.Data.DataTable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Merge (table As DataTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataTable ^ table);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
      </Parameters>
      <Docs>
        <param name="table">
          <see cref="T:System.Data.DataTable" /> Do scalenia z bieżącym <see cref="T:System.Data.DataTable" />.</param>
        <summary>Scal określonego <see cref="T:System.Data.DataTable" /> z bieżącym <see cref="T:System.Data.DataTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Merge — metoda jest używana do scalenia dwa <xref:System.Data.DataTable> obiektów, które mają schematów w znacznym stopniu podobne. Scalanie jest zwykle używana w aplikacji klienta do zastosować ostatnie zmiany ze źródła danych w istniejącej <xref:System.Data.DataTable>. Umożliwia to aplikacji klienta odświeżyć <xref:System.Data.DataTable> przy użyciu najnowszych danych ze źródła danych.  
  
 Operacja scalania uwzględnia oryginalnej tabeli, a tabela, która ma być scalone. Nie dotyczy lub częścią tabele podrzędne. Jeśli tabela ma co najmniej jednej tabeli podrzędnej definiowane jako część relacji każdej tabeli podrzędnej muszą zostać połączone pojedynczo.  
  
 `Merge` Zazwyczaj wywoływana jest metoda na końcu szereg procedur obejmujących sprawdzanie poprawności zmiany, uzgadnianie błędy aktualizacji źródła danych ze zmianami i na koniec odświeżanie istniejącego <xref:System.Data.DataTable>.  
  
 Podczas przeprowadzania scalania, zmiany wprowadzone w istniejących danych przed scaleniem są zachowywane domyślnie podczas operacji scalania. Deweloperzy można modyfikować tego zachowania wywołaniem inne przeciążenia tej metody, a następnie określając wartość false dla `preserveChanges` parametru.  
  
 W aplikacji klienckiej jest zwykle ma jednego przycisku, który użytkownik może kliknąć zbiera dane zmienione, a następnie zweryfikuje go przed wysłaniem go z powrotem do składników warstwy środkowej. W tym scenariuszu <xref:System.Data.DataTable.GetChanges%2A> wywołaniu metody. Metoda zwraca wartość drugiej <xref:System.Data.DataTable> zoptymalizowane pod kątem sprawdzania poprawności i scalania. Drugą <xref:System.Data.DataTable> obiekt zawiera tylko <xref:System.Data.DataRow> obiektów, które zostały zmienione, wynikające z podzbioru oryginalnej <xref:System.Data.DataTable>. Ten podzestaw jest zwykle mniejsze i w związku z tym wydajniej przekazywane z powrotem do składników warstwy środkowej. Składnik warstwy środkowej następnie aktualizuje oryginalne źródło danych zmiany za pomocą procedur składowanych. Warstwy środkowej może wysyłać kopii albo nowy <xref:System.Data.DataTable> zawierającą oryginalnych danych oraz najnowsze dane ze źródła danych (przez ponowne uruchomienie oryginalnego zapytania) lub Wyślij ponownie podzbiór o zmianach, które zostały wprowadzone do niej ze źródła danych. (Na przykład, jeśli źródło danych automatycznie tworzy unikatowe wartości kluczy podstawowych, te wartości można propagowane do aplikacji klienckiej.) W obu przypadkach zwróconego <xref:System.Data.DataTable> mogą być scalone aplikacji klienckiej, oryginalne <xref:System.Data.DataTable> z <xref:System.Data.DataTable.Merge%2A> metody.  
  
 Podczas scalania nowe źródło <xref:System.Data.DataTable> do obiektu docelowego, każde źródło wiersze z <xref:System.Data.DataRowState> wartość `Unchanged`, `Modified`, lub `Deleted`, jest dopasowywany do docelowego wierszy z tej samej wartości klucza podstawowego. Źródło wiersze z <xref:System.Data.DataRowState> wartość `Added` są dopasowywane do nowych wierszy docelowych z tej samej wartości klucza podstawowego jako nowe wiersze źródła.  
  
   
  
## Examples  
 Następującej aplikacji konsoli tworzy prosty <xref:System.Data.DataTable> i dodaje dane do tabeli. Przykład następnie tworzy kopię tabeli Dodawanie wierszy do kopiowania. Na koniec przykład wywołuje <xref:System.Data.DataTable.Merge%2A> sposób scalania danych w drugiej tabeli z danymi w pierwszej tabeli.  
  
 [!code-csharp[DataWorks DataTable.Merge#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.Merge/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.Merge#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.Merge/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table, bool preserveChanges);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table, bool preserveChanges) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Merge (table As DataTable, preserveChanges As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataTable ^ table, bool preserveChanges);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="table">
          <see langword="DataTable" /> Do scalenia z bieżącym <see langword="DataTable" />.</param>
        <param name="preserveChanges">
          <see langword="true" />, aby zachować zmiany w bieżącym <see langword="DataTable" />; w przeciwnym razie <see langword="false" />.<see langword="" /></param>
        <summary>Scal określonego <see cref="T:System.Data.DataTable" /> z bieżącym <see langword="DataTable" />, wskazującą, czy chcesz zachować zmiany w bieżącym <see langword="DataTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Merge — metoda jest używana do scalenia dwa <xref:System.Data.DataTable> obiektów, które mają schematów w znacznym stopniu podobne. Scalanie jest zwykle używana w aplikacji klienta do zastosować ostatnie zmiany ze źródła danych w istniejącej <xref:System.Data.DataTable>. Umożliwia to aplikacji klienta odświeżyć <xref:System.Data.DataTable> przy użyciu najnowszych danych ze źródła danych.  
  
 Operacja scalania uwzględnia oryginalnej tabeli, a tabela, która ma być scalone. Nie dotyczy lub częścią tabele podrzędne. Jeśli tabela ma co najmniej jednej tabeli podrzędnej definiowane jako część relacji każdej tabeli podrzędnej muszą zostać połączone pojedynczo.  
  
 `Merge` Zazwyczaj wywoływana jest metoda na końcu szereg procedur obejmujących sprawdzanie poprawności zmiany, uzgadnianie błędy aktualizacji źródła danych ze zmianami i na koniec odświeżanie istniejącego <xref:System.Data.DataTable>.  
  
 Podczas scalania, zmiany wprowadzone w istniejących danych przed scaleniem są zachowywane podczas operacji scalania, chyba że deweloper określa wartość false dla `preserveChanges` parametru. Jeśli `preserveChanges` ustawiono parametr `true`, wartości przychodzących nie zastępują istniejące wartości w bieżącej wersji wierszy istniejącego wiersza. Jeśli `preserveChanges` ustawiono parametr `false`, wartości przychodzących zastąpić istniejące wartości w bieżącej wersji wierszy istniejącego wiersza. Aby uzyskać więcej informacji dotyczących wersji wierszy, zobacz [stany wiersza i wersje wiersza](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md).  
  
 W aplikacji klienckiej jest zwykle ma jednego przycisku, który użytkownik może kliknąć zbiera dane zmienione, a następnie zweryfikuje go przed wysłaniem go z powrotem do składników warstwy środkowej. W tym scenariuszu <xref:System.Data.DataTable.GetChanges%2A> wywołaniu metody. Metoda zwraca wartość drugiej <xref:System.Data.DataTable> zoptymalizowane pod kątem sprawdzania poprawności i scalania. Drugą <xref:System.Data.DataTable> obiekt zawiera tylko <xref:System.Data.DataTable> i <xref:System.Data.DataRow> obiektów, które zostały zmienione, wynikające z podzbioru oryginalnej <xref:System.Data.DataTable>. Ten podzestaw jest zwykle mniejsze, a zatem ten podzestaw wydajniej jest przekazywane z powrotem do składników warstwy środkowej. Składnik warstwy środkowej następnie aktualizuje oryginalne źródło danych zmiany za pomocą procedur składowanych. Warstwy środkowej może wysyłać kopii albo nowy <xref:System.Data.DataTable> zawierającą oryginalnych danych oraz najnowsze dane ze źródła danych (przez ponowne uruchomienie oryginalnego zapytania) lub Wyślij ponownie podzbiór o zmianach, które zostały wprowadzone do niej ze źródła danych. (Na przykład, jeśli źródło danych automatycznie tworzy unikatowe wartości kluczy podstawowych, te wartości można propagowane do aplikacji klienckiej.) W obu przypadkach zwróconego <xref:System.Data.DataTable> mogą być scalone aplikacji klienckiej, oryginalne <xref:System.Data.DataTable> z <xref:System.Data.DataTable.Merge%2A> metody.  
  
 Podczas scalania nowe źródło <xref:System.Data.DataTable> do obiektu docelowego, każde źródło wiersze z <xref:System.Data.DataRowState> wartość `Unchanged`, `Modified`, lub `Deleted` są dopasowywane do docelowego wierszy z tej samej wartości klucza podstawowego. Źródło wiersze z <xref:System.Data.DataRowState> wartość `Added` są dopasowywane do nowych wierszy docelowych z tej samej wartości klucza podstawowego jako nowe wiersze źródła.  
  
   
  
## Examples  
 Tworzy następującej aplikacji konsoli <xref:System.Data.DataTable> zawierająca wiersze, modyfikuje niektóre dane w tych wierszach i próbuje przeprowadzić scalać dane z innego <xref:System.Data.DataTable>. W przykładzie pokazano różne zachowania dla `preserveChanges` parametru.  
  
 [!code-csharp[DataWorks DataTable.MergePreserveChanges#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.MergePreserveChanges/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.MergePreserveChanges#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.MergePreserveChanges/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="public void Merge (System.Data.DataTable table, bool preserveChanges, System.Data.MissingSchemaAction missingSchemaAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Merge(class System.Data.DataTable table, bool preserveChanges, valuetype System.Data.MissingSchemaAction missingSchemaAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Merge(System.Data.DataTable,System.Boolean,System.Data.MissingSchemaAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Merge(System::Data::DataTable ^ table, bool preserveChanges, System::Data::MissingSchemaAction missingSchemaAction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Data.DataTable" />
        <Parameter Name="preserveChanges" Type="System.Boolean" />
        <Parameter Name="missingSchemaAction" Type="System.Data.MissingSchemaAction" />
      </Parameters>
      <Docs>
        <param name="table">
          <see cref="T:System.Data.DataTable" /> Do scalenia z bieżącym <see cref="T:System.Data.DataTable" />.</param>
        <param name="preserveChanges">
          <see langword="true" />, aby zachować zmiany w bieżącym <see cref="T:System.Data.DataTable" />; w przeciwnym razie <see langword="false" />.</param>
        <param name="missingSchemaAction">Jeden z <see cref="T:System.Data.MissingSchemaAction" /> wartości.</param>
        <summary>Scal określonego <see cref="T:System.Data.DataTable" /> z bieżącym <see langword="DataTable" />, wskazującą, czy chcesz zachować zmiany i sposób obsługi Brak schematu w bieżącym <see langword="DataTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Merge` Metoda jest używana do scalenia dwa <xref:System.Data.DataTable> obiektów, które mają schematów w znacznym stopniu podobne. Scalanie jest zwykle używana w aplikacji klienta do zastosować ostatnie zmiany ze źródła danych w istniejącej <xref:System.Data.DataTable>. Umożliwia to aplikacji klienta odświeżyć <xref:System.Data.DataTable> przy użyciu najnowszych danych ze źródła danych.  
  
 Operacja scalania uwzględnia oryginalnej tabeli, a tabela, która ma być scalone. Nie dotyczy lub częścią tabele podrzędne. Jeśli tabela ma co najmniej jednej tabeli podrzędnej definiowane jako część relacji każdej tabeli podrzędnej muszą zostać połączone pojedynczo.  
  
 `Merge` Zazwyczaj wywoływana jest metoda na końcu szereg procedur obejmujących sprawdzanie poprawności zmiany, uzgadnianie błędy aktualizacji źródła danych ze zmianami i na koniec odświeżanie istniejącego <xref:System.Data.DataTable>.  
  
 Podczas scalania, zmiany wprowadzone w istniejących danych przed scaleniem są zachowywane podczas operacji scalania, chyba że deweloper określa wartość false dla `preserveChanges` parametru. Jeśli `preserveChanges` ustawiono parametr `true`, wartości przychodzących nie zastępują istniejące wartości w bieżącej wersji wierszy istniejącego wiersza. Jeśli `preserveChanges` ustawiono parametr `false`, wartości przychodzących zastąpić istniejące wartości w bieżącej wersji wierszy istniejącego wiersza. Aby uzyskać więcej informacji dotyczących wersji wierszy, zobacz [stany wiersza i wersje wiersza](~/docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md).  
  
 W aplikacji klienckiej jest zwykle ma jednego przycisku, który użytkownik może kliknąć zbiera dane zmienione, a następnie zweryfikuje go przed wysłaniem go z powrotem do składników warstwy środkowej. W tym scenariuszu <xref:System.Data.DataTable.GetChanges%2A> wywołaniu metody. Metoda zwraca wartość drugiej <xref:System.Data.DataTable> zoptymalizowane pod kątem sprawdzania poprawności i scalania. Drugą <xref:System.Data.DataTable> obiekt zawiera tylko <xref:System.Data.DataTable> i <xref:System.Data.DataRow> obiektów, które zostały zmienione, wynikające z podzbioru oryginalnej <xref:System.Data.DataTable>. Ten podzestaw jest zwykle mniejsze, a zatem ten podzestaw wydajniej jest przekazywane z powrotem do składników warstwy środkowej. Składnik warstwy środkowej następnie aktualizuje oryginalne źródło danych zmiany za pomocą procedur składowanych. Warstwy środkowej może wysyłać kopii albo nowy <xref:System.Data.DataTable> zawierającą oryginalnych danych oraz najnowsze dane ze źródła danych (przez ponowne uruchomienie oryginalnego zapytania) lub Wyślij ponownie podzbiór o zmianach, które zostały wprowadzone do niej ze źródła danych. (Na przykład, jeśli źródło danych automatycznie tworzy unikatowe wartości kluczy podstawowych, te wartości można propagowane do aplikacji klienckiej.) W obu przypadkach zwróconego <xref:System.Data.DataTable> mogą być scalone aplikacji klienckiej, oryginalne <xref:System.Data.DataTable> z <xref:System.Data.DataTable.Merge%2A> metody.  
  
 Gdy <xref:System.Data.DataTable.Merge%2A> metoda jest wywoływana, schematów dwa <xref:System.Data.DataTable> obiekty są porównywane, ponieważ jest to możliwe, że schematy mogły zostać zmienione. Na przykład w przypadku business-to-business, nowe kolumny może zostały dodane do schematu XML przez zautomatyzowany proces. Jeśli źródło <xref:System.Data.DataTable> zawiera elementy schematu (dodany <xref:System.Data.DataColumn> obiektów) brakuje w miejscu docelowym, elementy schematu mogą zostać dodane do obiektu docelowego, ustawiając `missingSchemaAction` argument `MissingSchemaAction.Add`. W takim przypadku scalonych <xref:System.Data.DataTable> zawiera dodany schemat i dane.  
  
 Po scaleniu schematów, scalania danych.  
  
 Podczas scalania nowe źródło <xref:System.Data.DataTable> do obiektu docelowego, każde źródło wiersze z <xref:System.Data.DataRowState> wartość `Unchanged`, `Modified`, lub `Deleted` są dopasowywane do docelowego wierszy z tej samej wartości klucza podstawowego. Źródło wiersze z <xref:System.Data.DataRowState> wartość `Added` są dopasowywane do nowych wierszy docelowych z tej samej wartości klucza podstawowego jako nowe wiersze źródła.  
  
   
  
## Examples  
 Następującej aplikacji konsoli Pokazuje zachowanie `missingSchemaAction` parametr <xref:System.Data.DataTable.Merge%2A> metody. W tym przykładzie tworzy dwie wersje tej samej tabeli modyfikowania schematu dla drugiego wersji. Kod podejmuje próbę scalenia drugiej tabeli pierwszy.  
  
 [!code-csharp[DataWorks DataTable.MergeMissingSchemaAction#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.MergeMissingSchemaAction/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.MergeMissingSchemaAction#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.MergeMissingSchemaAction/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinimumCapacity">
      <MemberSignature Language="C#" Value="public int MinimumCapacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MinimumCapacity" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.MinimumCapacity" />
      <MemberSignature Language="VB.NET" Value="Public Property MinimumCapacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MinimumCapacity { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(50)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia początkowy rozmiar tej tabeli.</summary>
        <value>Początkowy rozmiar początkowy w wiersze tej tabeli. Wartością domyślną jest 50.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.MinimumCapacity%2A> Umożliwi systemowi Utwórz odpowiedni zestaw zasobów przed pobieranie danych. W sytuacji, gdy ma kluczowe znaczenie, ustawienie dla tej właściwości można zoptymalizować wydajność.  
  
   
  
## Examples  
 W poniższym przykładzie <xref:System.Data.DataTable.MinimumCapacity%2A> z <xref:System.Data.DataTable>.  
  
 [!code-csharp[Classic WebData DataTable.MinimumCapacity Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.MinimumCapacity Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.MinimumCapacity Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.MinimumCapacity Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public string Namespace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Namespace { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia obszar nazw XML reprezentację danych przechowywanych w <see cref="T:System.Data.DataTable" />.</summary>
        <value>Przestrzeń nazw <see cref="T:System.Data.DataTable" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NewRow">
      <MemberSignature Language="C#" Value="public System.Data.DataRow NewRow ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow NewRow() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.NewRow" />
      <MemberSignature Language="VB.NET" Value="Public Function NewRow () As DataRow" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::DataRow ^ NewRow();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy nową <see cref="T:System.Data.DataRow" /> ze schematem tej samej tabeli.</summary>
        <returns>A <see cref="T:System.Data.DataRow" /> z tym samym schematem co <see cref="T:System.Data.DataTable" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy użyć <xref:System.Data.DataTable.NewRow%2A> metody, aby utworzyć nowy <xref:System.Data.DataRow> obiekty z tym samym schematem co <xref:System.Data.DataTable>. Po utworzeniu <xref:System.Data.DataRow>, można dodać go do <xref:System.Data.DataRowCollection>, za pomocą <xref:System.Data.DataTable> obiektu <xref:System.Data.DataTable.Rows%2A> właściwości. Jeśli używasz <xref:System.Data.DataTable.NewRow%2A> Aby utworzyć nowe wiersze, należy dodać do lub usunięte z tabeli danych przed wywołaniem wiersze <xref:System.Data.DataTable.Clear%2A>.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Data.DataTable>, dodaje dwa <xref:System.Data.DataColumn> obiekty, które ustalić schemat tabeli i tworzy kilka nowych <xref:System.Data.DataRow> obiektów przy użyciu <xref:System.Data.DataTable.NewRow%2A> metody. Te <xref:System.Data.DataRow> obiekty zostaną następnie dodane do <xref:System.Data.DataRowCollection> przy użyciu <xref:System.Data.DataRowCollection.Add%2A> metody.  
  
 [!code-csharp[Classic WebData DataTable.NewRow Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.NewRow Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.NewRow Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.NewRow Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NewRowArray">
      <MemberSignature Language="C#" Value="protected internal System.Data.DataRow[] NewRowArray (int size);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance class System.Data.DataRow[] NewRowArray(int32 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.NewRowArray(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function NewRowArray (size As Integer) As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ NewRowArray(int size);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="size" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="size">A <see cref="T:System.Int32" /> wartość, która opisuje rozmiar tablicy.</param>
        <summary>Zwraca tablicę <see cref="T:System.Data.DataRow" />.</summary>
        <returns>Nowej tablicy.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NewRowFromBuilder">
      <MemberSignature Language="C#" Value="protected virtual System.Data.DataRow NewRowFromBuilder (System.Data.DataRowBuilder builder);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Data.DataRow NewRowFromBuilder(class System.Data.DataRowBuilder builder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.NewRowFromBuilder(System.Data.DataRowBuilder)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function NewRowFromBuilder (builder As DataRowBuilder) As DataRow" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Data::DataRow ^ NewRowFromBuilder(System::Data::DataRowBuilder ^ builder);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="builder" Type="System.Data.DataRowBuilder" />
      </Parameters>
      <Docs>
        <param name="builder">A <see cref="T:System.Data.DataRowBuilder" /> obiektu.</param>
        <summary>Tworzy nowy wiersz na podstawie istniejącego wiersza.</summary>
        <returns>A <see cref="T:System.Data.DataRow" /> klasy.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnColumnChanged">
      <MemberSignature Language="C#" Value="protected internal virtual void OnColumnChanged (System.Data.DataColumnChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnColumnChanged(class System.Data.DataColumnChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnColumnChanged(System.Data.DataColumnChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnColumnChanged (e As DataColumnChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnColumnChanged(System::Data::DataColumnChangeEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataColumnChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Data.DataColumnChangeEventArgs" /> zawierający dane zdarzenia.</param>
        <summary>Zgłasza <see cref="E:System.Data.DataTable.ColumnChanged" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać ogólne informacje, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>W przypadku przesłaniania <see cref="M:System.Data.DataTable.OnColumnChanged(System.Data.DataColumnChangeEventArgs)" /> w klasie pochodnej, należy wywołać klasy podstawowej <see cref="M:System.Data.DataTable.OnColumnChanged(System.Data.DataColumnChangeEventArgs)" /> metody.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnColumnChanging">
      <MemberSignature Language="C#" Value="protected internal virtual void OnColumnChanging (System.Data.DataColumnChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnColumnChanging(class System.Data.DataColumnChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnColumnChanging(System.Data.DataColumnChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnColumnChanging (e As DataColumnChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnColumnChanging(System::Data::DataColumnChangeEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataColumnChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Data.DataColumnChangeEventArgs" /> zawierający dane zdarzenia.</param>
        <summary>Zgłasza <see cref="E:System.Data.DataTable.ColumnChanging" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać ogólne informacje, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>W przypadku przesłaniania <see cref="M:System.Data.DataTable.OnColumnChanging(System.Data.DataColumnChangeEventArgs)" /> w klasie pochodnej, należy wywołać klasy podstawowej <see cref="M:System.Data.DataTable.OnColumnChanging(System.Data.DataColumnChangeEventArgs)" /> metody.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnPropertyChanging (System.ComponentModel.PropertyChangedEventArgs pcevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPropertyChanging(class System.ComponentModel.PropertyChangedEventArgs pcevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPropertyChanging (pcevent As PropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPropertyChanging(System::ComponentModel::PropertyChangedEventArgs ^ pcevent);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcevent" Type="System.ComponentModel.PropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="pcevent">A <see cref="T:System.ComponentModel.PropertyChangedEventArgs" /> zawierający dane zdarzenia.</param>
        <summary>Zgłasza <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać ogólne informacje, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>W przypadku przesłaniania <see cref="M:System.Data.DataTable.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" /> w klasie pochodnej, należy wywołać klasy podstawowej <see cref="M:System.Data.DataTable.OnPropertyChanging(System.ComponentModel.PropertyChangedEventArgs)" /> metody.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRemoveColumn">
      <MemberSignature Language="C#" Value="protected virtual void OnRemoveColumn (System.Data.DataColumn column);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRemoveColumn(class System.Data.DataColumn column) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRemoveColumn(System.Data.DataColumn)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRemoveColumn (column As DataColumn)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRemoveColumn(System::Data::DataColumn ^ column);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="column" Type="System.Data.DataColumn" />
      </Parameters>
      <Docs>
        <param name="column">
          <see cref="T:System.Data.DataColumn" /> Usuwana.</param>
        <summary>Powiadamia <see cref="T:System.Data.DataTable" /> który <see cref="T:System.Data.DataColumn" /> jest usuwana.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>W przypadku przesłaniania <see cref="M:System.Data.DataTable.OnRemoveColumn(System.Data.DataColumn)" /> w klasie pochodnej, należy wywołać klasy podstawowej <see cref="M:System.Data.DataTable.OnRemoveColumn(System.Data.DataColumn)" /> metody.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRowChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnRowChanged (System.Data.DataRowChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowChanged(class System.Data.DataRowChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRowChanged(System.Data.DataRowChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRowChanged (e As DataRowChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRowChanged(System::Data::DataRowChangeEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataRowChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Data.DataRowChangeEventArgs" /> zawierający dane zdarzenia.</param>
        <summary>Zgłasza <see cref="E:System.Data.DataTable.RowChanged" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać ogólne informacje, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>W przypadku przesłaniania <see cref="M:System.Data.DataTable.OnRowChanged(System.Data.DataRowChangeEventArgs)" /> w klasie pochodnej, należy wywołać klasy podstawowej <see cref="M:System.Data.DataTable.OnRowChanged(System.Data.DataRowChangeEventArgs)" /> metody.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRowChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnRowChanging (System.Data.DataRowChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowChanging(class System.Data.DataRowChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRowChanging(System.Data.DataRowChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRowChanging (e As DataRowChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRowChanging(System::Data::DataRowChangeEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataRowChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Data.DataRowChangeEventArgs" /> zawierający dane zdarzenia.</param>
        <summary>Zgłasza <see cref="E:System.Data.DataTable.RowChanging" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać ogólne informacje, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>W przypadku przesłaniania <see cref="M:System.Data.DataTable.OnRowChanging(System.Data.DataRowChangeEventArgs)" /> w klasie pochodnej, należy wywołać klasy podstawowej <see cref="M:System.Data.DataTable.OnRowChanging(System.Data.DataRowChangeEventArgs)" /> metody.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRowDeleted">
      <MemberSignature Language="C#" Value="protected virtual void OnRowDeleted (System.Data.DataRowChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowDeleted(class System.Data.DataRowChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRowDeleted(System.Data.DataRowChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRowDeleted (e As DataRowChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRowDeleted(System::Data::DataRowChangeEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataRowChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Data.DataRowChangeEventArgs" /> zawierający dane zdarzenia.</param>
        <summary>Zgłasza <see cref="E:System.Data.DataTable.RowDeleted" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać ogólne informacje, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>W przypadku przesłaniania <see cref="M:System.Data.DataTable.OnRowDeleted(System.Data.DataRowChangeEventArgs)" /> w klasie pochodnej, należy wywołać klasy podstawowej <see cref="M:System.Data.DataTable.OnRowDeleted(System.Data.DataRowChangeEventArgs)" /> metody.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRowDeleting">
      <MemberSignature Language="C#" Value="protected virtual void OnRowDeleting (System.Data.DataRowChangeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRowDeleting(class System.Data.DataRowChangeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnRowDeleting(System.Data.DataRowChangeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRowDeleting (e As DataRowChangeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRowDeleting(System::Data::DataRowChangeEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataRowChangeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Data.DataRowChangeEventArgs" /> zawierający dane zdarzenia.</param>
        <summary>Zgłasza <see cref="E:System.Data.DataTable.RowDeleting" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać ogólne informacje, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>W przypadku przesłaniania <see cref="M:System.Data.DataTable.OnRowDeleting(System.Data.DataRowChangeEventArgs)" /> w klasie pochodnej, należy wywołać klasy podstawowej <see cref="M:System.Data.DataTable.OnRowDeleting(System.Data.DataRowChangeEventArgs)" /> metody.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnTableCleared">
      <MemberSignature Language="C#" Value="protected virtual void OnTableCleared (System.Data.DataTableClearEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTableCleared(class System.Data.DataTableClearEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnTableCleared(System.Data.DataTableClearEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTableCleared (e As DataTableClearEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTableCleared(System::Data::DataTableClearEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataTableClearEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Data.DataTableClearEventArgs" /> zawierający dane zdarzenia.</param>
        <summary>Zgłasza <see cref="E:System.Data.DataTable.TableCleared" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zgłasza <xref:System.Data.DataTable.TableCleared> zdarzeń, który jest uruchamiany natychmiast po wszystkie wiersze zostały pomyślnie wyczyszczone ale przed wysłaniem <xref:System.Data.DataTable.Clear%2A> metoda zwraca sterowanie do obiektu wywołującego.  
  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać ogólne informacje, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTableClearing">
      <MemberSignature Language="C#" Value="protected virtual void OnTableClearing (System.Data.DataTableClearEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTableClearing(class System.Data.DataTableClearEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnTableClearing(System.Data.DataTableClearEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTableClearing (e As DataTableClearEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTableClearing(System::Data::DataTableClearEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataTableClearEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Data.DataTableClearEventArgs" /> zawierający dane zdarzenia.</param>
        <summary>Zgłasza <see cref="E:System.Data.DataTable.TableClearing" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zgłasza <xref:System.Data.DataTable.TableClearing> zdarzenie, które jest wywoływane przed przetwarzania <xref:System.Data.DataTable.Clear%2A> rozpocznie się wykonywanie operacji.  
  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać ogólne informacje, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTableNewRow">
      <MemberSignature Language="C#" Value="protected virtual void OnTableNewRow (System.Data.DataTableNewRowEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTableNewRow(class System.Data.DataTableNewRowEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.OnTableNewRow(System.Data.DataTableNewRowEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTableNewRow (e As DataTableNewRowEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTableNewRow(System::Data::DataTableNewRowEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Data.DataTableNewRowEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Data.DataTableNewRowEventArgs" /> zawierający dane zdarzenia.</param>
        <summary>Zgłasza <see cref="E:System.Data.DataTable.TableNewRow" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zgłasza <xref:System.Data.DataTable.TableNewRow> zdarzenie, które są generowane po nowy <xref:System.Data.DataRow> został utworzony przy użyciu <xref:System.Data.DataTable.NewRow%2A>.  
  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać ogólne informacje, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ParentRelations">
      <MemberSignature Language="C#" Value="public System.Data.DataRelationCollection ParentRelations { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataRelationCollection ParentRelations" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.ParentRelations" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ParentRelations As DataRelationCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataRelationCollection ^ ParentRelations { System::Data::DataRelationCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRelationCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję relacji nadrzędny tego <see cref="T:System.Data.DataTable" />.</summary>
        <value>A <see cref="T:System.Data.DataRelationCollection" /> zawiera relacje nadrzędne dla tabeli. Zwracany jest pustą kolekcję, jeśli nie <see cref="T:System.Data.DataRelation" /> istnieją obiekty.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie użyto <xref:System.Data.DataTable.ParentRelations%2A> właściwości, aby powrócić do każdego elementu nadrzędnego <xref:System.Data.DataRelation> w <xref:System.Data.DataTable>. Każda relacja jest następnie używany jako argument w <xref:System.Data.DataRow.GetParentRows%2A> metody <xref:System.Data.DataRow> aby zwracało tablicę wierszy. Następnie wydrukowaniu wartość każdej kolumny w wierszu.  
  
 [!code-csharp[Classic WebData DataTable.ParentRelations Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ParentRelations Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ParentRelations Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ParentRelations Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.ChildRelations" />
        <altmember cref="T:System.Data.DataRelation" />
        <altmember cref="T:System.Data.DataSet" />
        <altmember cref="P:System.Data.DataSet.Relations" />
      </Docs>
    </Member>
    <Member MemberName="Prefix">
      <MemberSignature Language="C#" Value="public string Prefix { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Prefix" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Prefix" />
      <MemberSignature Language="VB.NET" Value="Public Property Prefix As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Prefix { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia obszar nazw XML reprezentację danych przechowywanych w <see cref="T:System.Data.DataTable" />.</summary>
        <value>Prefiks <see cref="T:System.Data.DataTable" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PrimaryKey">
      <MemberSignature Language="C#" Value="public System.Data.DataColumn[] PrimaryKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataColumn[] PrimaryKey" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.PrimaryKey" />
      <MemberSignature Language="VB.NET" Value="Public Property PrimaryKey As DataColumn()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Data::DataColumn ^&gt; ^ PrimaryKey { cli::array &lt;System::Data::DataColumn ^&gt; ^ get(); void set(cli::array &lt;System::Data::DataColumn ^&gt; ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor("Microsoft.VSDesigner.Data.Design.PrimaryKeyEditor, Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Data.PrimaryKeyTypeConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataColumn[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia tablicę kolumn tej funkcji jako kluczy podstawowych w tabeli danych.</summary>
        <value>Tablica <see cref="T:System.Data.DataColumn" /> obiektów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klucz podstawowy tabeli muszą być unikatowe do identyfikowania rekordu w tabeli. Jest również możliwe z składają się z dwóch lub więcej kolumn klucza podstawowego tabeli. Dzieje się tak, gdy pojedyncza kolumna nie zawiera wystarczającej liczby unikatowych wartości. Na przykład dwie kolumny klucza podstawowego może obejmować kolumny "Imię" i "Nazwisko". Ponieważ kluczy podstawowych może składać się z więcej niż jednej kolumny <xref:System.Data.DataTable.PrimaryKey%2A> właściwości składa się z tablicą <xref:System.Data.DataColumn> obiektów.  
  
   
  
## Examples  
 Pierwszym przykładzie przedstawiono sposób zwracania kolumn klucza podstawowego dla <xref:System.Data.DataTable> wyświetlane w `DataGrid`. Drugim przykładzie pokazano, jak ustawić kolumn klucza podstawowego dla <xref:System.Data.DataTable>.  
  
 [!code-csharp[Classic WebData DataTable.PrimaryKey Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.PrimaryKey Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.PrimaryKey Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.PrimaryKey Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Data.DataException">Klucz jest kluczem obcym.</exception>
        <altmember cref="T:System.Data.DataColumn" />
        <altmember cref="P:System.Data.DataTable.PrimaryKey" />
        <altmember cref="T:System.Data.DataColumnCollection" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadXml">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Odczytuje XML: schemat i dane do <see cref="T:System.Data.DataTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.ReadXml%2A> Metoda zapewnia sposób odczytać tylko dane lub zarówno danych i schematu do <xref:System.Data.DataTable> z dokumentu XML, podczas gdy <xref:System.Data.DataTable.ReadXmlSchema%2A> metoda odczytuje tylko schemat. Aby odczytać zarówno danych, jak i schematu, użyj jednej z `ReadXML` przeciążenia, które obejmują `XmlReadMode` parametru i ustaw jej wartość `ReadSchema`.  
  
 Należy pamiętać, że to samo dotyczy dla <xref:System.Data.DataTable.WriteXml%2A> i <xref:System.Data.DataTable.WriteXmlSchema%2A> metod, odpowiednio. Można zapisać danych XML lub schemat i dane z `DataTable`, użyj `WriteXml` metody. Aby zapisać tylko schemat, należy użyć `WriteXmlSchema` metody.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Zostanie wygenerowany, jeśli typ kolumny w `DataRow` trwa od zapisu lub odczytu implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> i nie implementuje <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Data.DataSet.ReadXml" />
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXml(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::Stream ^ stream);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Obiekt, który jest pochodną <see cref="T:System.IO.Stream" /></param>
        <summary>Odczytuje XML: schemat i dane do <see cref="T:System.Data.DataTable" /> przy użyciu określonego <see cref="T:System.IO.Stream" />.</summary>
        <returns>
          <see cref="T:System.Data.XmlReadMode" /> Używany do odczytu danych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bieżący <xref:System.Data.DataTable> i jego elementów podrzędnych są ładowane przy użyciu danych z podane <xref:System.IO.Stream>. Zachowanie tej metody jest identyczna ze <xref:System.Data.DataSet.ReadXml%2A?displayProperty=nameWithType> metody, z wyjątkiem danych to w tym przypadku jest załadowany tylko dla bieżącej tabeli i jego obiektów podrzędnych.  
  
 <xref:System.Data.DataTable.ReadXml%2A> Metoda zapewnia sposób odczytać tylko dane lub zarówno danych i schematu do <xref:System.Data.DataTable> z dokumentu XML, podczas gdy <xref:System.Data.DataTable.ReadXmlSchema%2A> metoda odczytuje tylko schemat.  
  
 Należy pamiętać, że to samo dotyczy dla <xref:System.Data.DataTable.WriteXml%2A> i <xref:System.Data.DataTable.WriteXmlSchema%2A> metod, odpowiednio. Można zapisać danych XML lub schemat i dane z `DataTable`, użyj `WriteXml` metody. Aby zapisać tylko schemat, należy użyć `WriteXmlSchema` metody.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Zostanie wygenerowany, jeśli typ kolumny w `DataRow` trwa od zapisu lub odczytu implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> i nie implementuje <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Jeśli określono schemat w tekście, schematu w wierszu służy do rozszerzania istniejącej struktury relacyjne przed załadowaniem danych. Jeśli występują konflikty (na przykład tej samej kolumny w tej samej tabeli zdefiniowane przy użyciu różnych typów danych) jest wyjątek.  
  
 Jeśli schemat nie-line jest określony, struktura relacyjnej został rozszerzony za pośrednictwem wnioskowania odpowiednio do potrzeb zgodnie ze struktury dokumentu XML. Jeśli schemat nie może zostać rozszerzony za pomocą wnioskowania, aby udostępnić wszystkie dane, jest wyjątek.  
  
> [!NOTE]
>  `DataSet` Nie wiąże — element XML z odpowiadającymi mu dostawcami `DataColumn` lub `DataTable` po prawidłowe znaki XML, takich jak ("_") są anulowane w serializacji XML. `DataSet` Się tylko specjalne niedozwolone znaki XML w nazwach elementów XML i dlatego tylko zajmowane są takie same. Gdy będą miały zmienione znaczenie prawidłowe znaki w nazwie elementu XML, element jest ignorowany podczas przetwarzania.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Data.DataTable> zawierających dwie kolumny i dziesięć wierszy. W przykładzie polecenie zapisuje <xref:System.Data.DataTable> schemat i dane do strumienia pamięci, wywołując <xref:System.Data.DataTable.WriteXml%2A> metody. W przykładzie jest tworzony drugiej <xref:System.Data.DataTable> i wywołuje <xref:System.Data.DataTable.ReadXml%2A> metodę, aby wypełnić go schemat i dane.  
  
 [!code-csharp[DataWorks DataTable.ReadXml#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXml/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXml#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXml/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.IO.TextReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.IO.TextReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXml(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As TextReader) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::IO::TextReader ^ reader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.IO.TextReader" /> Które będą używane do odczytywania danych.</param>
        <summary>Odczytuje XML: schemat i dane do <see cref="T:System.Data.DataTable" /> przy użyciu określonego <see cref="T:System.IO.TextReader" />.</summary>
        <returns>
          <see cref="T:System.Data.XmlReadMode" /> Używany do odczytu danych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bieżący <xref:System.Data.DataTable> i jego elementów podrzędnych są ładowane przy użyciu danych z podane <xref:System.IO.TextReader>. Zachowanie tej metody jest identyczna ze <xref:System.Data.DataSet.ReadXml%2A?displayProperty=nameWithType> metody, z wyjątkiem danych to w tym przypadku jest załadowany tylko dla bieżącej tabeli i jego obiektów podrzędnych.  
  
 <xref:System.Data.DataTable.ReadXml%2A> Metoda zapewnia sposób odczytać tylko dane lub zarówno danych i schematu do <xref:System.Data.DataTable> z dokumentu XML, podczas gdy <xref:System.Data.DataTable.ReadXmlSchema%2A> metoda odczytuje tylko schemat.  
  
 Należy pamiętać, że to samo dotyczy dla <xref:System.Data.DataTable.WriteXml%2A> i <xref:System.Data.DataTable.WriteXmlSchema%2A> metod, odpowiednio. Można zapisać danych XML lub schemat i dane z `DataTable`, użyj `WriteXml` metody. Aby zapisać tylko schemat, należy użyć `WriteXmlSchema` metody.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Zostanie wygenerowany, jeśli typ kolumny w `DataRow` trwa od zapisu lub odczytu implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> i nie implementuje <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Jeśli określono schemat w tekście, schematu w wierszu służy do rozszerzania istniejącej struktury relacyjne przed załadowaniem danych. Jeśli występują konflikty (na przykład tej samej kolumny w tej samej tabeli zdefiniowane przy użyciu różnych typów danych) jest wyjątek.  
  
 Jeśli schemat nie-line jest określony, struktura relacyjnej został rozszerzony za pośrednictwem wnioskowania odpowiednio do potrzeb zgodnie ze struktury dokumentu XML. Jeśli schemat nie może zostać rozszerzony za pomocą wnioskowania, aby udostępnić wszystkie dane, jest wyjątek.  
  
> [!NOTE]
>  `DataSet` Nie wiąże — element XML z odpowiadającymi mu dostawcami `DataColumn` lub `DataTable` po prawidłowe znaki XML, takich jak ("_") są anulowane w serializacji XML. `DataSet` Się tylko specjalne niedozwolone znaki XML w nazwach elementów XML i dlatego tylko zajmowane są takie same. Gdy będą miały zmienione znaczenie prawidłowe znaki w nazwie elementu XML, element jest ignorowany podczas przetwarzania.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Data.DataTable> zawierających dwie kolumny i dziesięć wierszy. W przykładzie polecenie zapisuje <xref:System.Data.DataTable> schemat i dane do strumienia pamięci, wywołując <xref:System.Data.DataTable.WriteXml%2A> metody. W przykładzie jest tworzony drugiej <xref:System.Data.DataTable> i wywołuje <xref:System.Data.DataTable.ReadXml%2A> metodę, aby wypełnić go schemat i dane.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlText#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlText/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlText#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlText/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXml(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (fileName As String) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::String ^ fileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nazwa pliku, z której mają być odczytywane dane.</param>
        <summary>Odczytuje XML: schemat i dane do <see cref="T:System.Data.DataTable" /> z określonego pliku.</summary>
        <returns>
          <see cref="T:System.Data.XmlReadMode" /> Używany do odczytu danych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bieżący <xref:System.Data.DataTable> i jego elementów podrzędnych są ładowane przy użyciu danych z pliku o nazwie w podane <xref:System.String>. Zachowanie tej metody jest identyczna ze <xref:System.Data.DataSet.ReadXml%2A?displayProperty=nameWithType> metody, z wyjątkiem danych to w tym przypadku jest załadowany tylko dla bieżącej tabeli i jego obiektów podrzędnych.  
  
 <xref:System.Data.DataTable.ReadXml%2A> Metoda zapewnia sposób odczytać tylko dane lub zarówno danych i schematu do <xref:System.Data.DataTable> z dokumentu XML, podczas gdy <xref:System.Data.DataTable.ReadXmlSchema%2A> metoda odczytuje tylko schemat.  
  
 Należy pamiętać, że to samo dotyczy dla <xref:System.Data.DataTable.WriteXml%2A> i <xref:System.Data.DataTable.WriteXmlSchema%2A> metod, odpowiednio. Można zapisać danych XML lub schemat i dane z `DataTable`, użyj `WriteXml` metody. Aby zapisać tylko schemat, należy użyć `WriteXmlSchema` metody.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Zostanie wygenerowany, jeśli typ kolumny w `DataRow` trwa od zapisu lub odczytu implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> i nie implementuje <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Jeśli określono schemat w tekście, schematu w wierszu służy do rozszerzania istniejącej struktury relacyjne przed załadowaniem danych. Jeśli występują konflikty (na przykład tej samej kolumny w tej samej tabeli zdefiniowane przy użyciu różnych typów danych) jest wyjątek.  
  
 Jeśli schemat nie-line jest określony, struktura relacyjnej został rozszerzony za pośrednictwem wnioskowania odpowiednio do potrzeb zgodnie ze struktury dokumentu XML. Jeśli schemat nie może zostać rozszerzony za pomocą wnioskowania, aby udostępnić wszystkie dane, jest wyjątek.  
  
> [!NOTE]
>  `DataSet` Nie wiąże — element XML z odpowiadającymi mu dostawcami `DataColumn` lub `DataTable` po prawidłowe znaki XML, takich jak ("_") są anulowane w serializacji XML. `DataSet` Się tylko specjalne niedozwolone znaki XML w nazwach elementów XML i dlatego tylko zajmowane są takie same. Gdy będą miały zmienione znaczenie prawidłowe znaki w nazwie elementu XML, element jest ignorowany podczas przetwarzania.  
  
```csharp  
using System.Data;  
public class A {  
   static void Main(string[] args) {  
      DataTable tabl = new DataTable("mytable");  
      tabl.Columns.Add(new DataColumn("id", typeof(int)));  
      for (int i = 0; i < 10; i++) {  
         DataRow row = tabl.NewRow();  
         row["id"] = i;  
         tabl.Rows.Add(row);  
      }  
      tabl.WriteXml("f.xml", XmlWriteMode.WriteSchema);  
      DataTable newt = new DataTable();  
      newt.ReadXml("f.xml");  
   }  
}  
```  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Data.DataTable> zawierających dwie kolumny i dziesięć wierszy. W przykładzie polecenie zapisuje <xref:System.Data.DataTable> schematu i danych na dysku. W przykładzie jest tworzony drugiej <xref:System.Data.DataTable> i wywołuje <xref:System.Data.DataTable.ReadXml%2A> metodę, aby wypełnić go schemat i dane.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlString#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlString/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlString#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlString/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadXml">
      <MemberSignature Language="C#" Value="public System.Data.XmlReadMode ReadXml (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Data.XmlReadMode ReadXml(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXml(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadXml (reader As XmlReader) As XmlReadMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::XmlReadMode ReadXml(System::Xml::XmlReader ^ reader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.XmlReadMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Xml.XmlReader" /> Które będą używane do odczytywania danych.</param>
        <summary>Odczytuje XML: schemat i dane do <see cref="T:System.Data.DataTable" /> przy użyciu określonego <see cref="T:System.Xml.XmlReader" />.</summary>
        <returns>
          <see cref="T:System.Data.XmlReadMode" /> Używany do odczytu danych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bieżący <xref:System.Data.DataTable> i jego elementów podrzędnych są ładowane przy użyciu danych z pliku o nazwie w podane <xref:System.Xml.XmlReader>. Zachowanie tej metody jest identyczna ze <xref:System.Data.DataTable.ReadXml%2A> metody, z wyjątkiem danych to w tym przypadku jest załadowany tylko dla bieżącej tabeli i jego obiektów podrzędnych.  
  
 <xref:System.Data.DataTable.ReadXml%2A> Metoda zapewnia sposób odczytać tylko dane lub zarówno danych i schematu do <xref:System.Data.DataTable> z dokumentu XML, podczas gdy <xref:System.Data.DataTable.ReadXmlSchema%2A> metoda odczytuje tylko schemat.  
  
 Należy pamiętać, że to samo dotyczy dla <xref:System.Data.DataTable.WriteXml%2A> i <xref:System.Data.DataTable.WriteXmlSchema%2A> metod, odpowiednio. Można zapisać danych XML lub schemat i dane z `DataTable`, użyj `WriteXml` metody. Aby zapisać tylko schemat, należy użyć `WriteXmlSchema` metody.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Zostanie wygenerowany, jeśli typ kolumny w `DataRow` trwa od zapisu lub odczytu implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> i nie implementuje <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 Jeśli określono schemat w tekście, schematu w wierszu służy do rozszerzania istniejącej struktury relacyjne przed załadowaniem danych. Jeśli występują konflikty (na przykład tej samej kolumny w tej samej tabeli zdefiniowane przy użyciu różnych typów danych) jest wyjątek.  
  
 Jeśli schemat nie-line jest określony, struktura relacyjnej został rozszerzony za pośrednictwem wnioskowania odpowiednio do potrzeb zgodnie ze struktury dokumentu XML. Jeśli schemat nie może zostać rozszerzony za pomocą wnioskowania, aby udostępnić wszystkie dane, jest wyjątek.  
  
> [!NOTE]
>  `DataSet` Nie wiąże — element XML z odpowiadającymi mu dostawcami `DataColumn` lub `DataTable` po prawidłowe znaki XML, takich jak ("_") są anulowane w serializacji XML. `DataSet` Się tylko specjalne niedozwolone znaki XML w nazwach elementów XML i dlatego tylko zajmowane są takie same. Gdy będą miały zmienione znaczenie prawidłowe znaki w nazwie elementu XML, element jest ignorowany podczas przetwarzania.  
  
   
  
## Examples  
 Poniższy przykład tworzy <xref:System.Data.DataTable> zawierających dwie kolumny i dziesięć wierszy. W przykładzie polecenie zapisuje <xref:System.Data.DataTable> schemat i dane do <xref:System.Xml.XmlReader>. W przykładzie jest tworzony drugiej <xref:System.Data.DataTable> i wywołuje <xref:System.Data.DataTable.ReadXml%2A> metodę, aby wypełnić go schemat i dane z <xref:System.Xml.XmlReader> wystąpienia.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlXmlReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlXmlReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlXmlReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlXmlReader/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadXmlSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Odczytuje schematu XML w <see cref="T:System.Data.DataTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj `ReadXmlSchema` metodę w celu utworzenia schematu <xref:System.Data.DataTable>. Schemat zawiera definicji tabeli, relacji i ograniczenia.  
  
 Aby zapisać schemat dokumentu XML, użyj <xref:System.Data.DataTable.WriteXmlSchema%2A> metody.  
  
 Schemat XML jest interpretowany zgodnie ze standardowych XSD.  
  
 `ReadXmlSchema` Zazwyczaj wywoływana jest metoda przed wywołaniem <xref:System.Data.DataTable.ReadXml%2A> metodę, która jest używany do wypełniania <xref:System.Data.DataTable>.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Data.DataSet.ReadXmlSchema" />
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSchema(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::IO::Stream ^ stream);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Strumień używany do odczytu schematu.</param>
        <summary>Odczytuje schematu XML w <see cref="T:System.Data.DataTable" /> przy użyciu określonego strumienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Data.DataTable.ReadXmlSchema%2A> metodę w celu utworzenia schematu <xref:System.Data.DataTable>. Schemat zawiera definicji tabeli, relacji i ograniczenia.  
  
 Aby zapisać schemat dokumentu XML, użyj <xref:System.Data.DataTable.WriteXmlSchema%2A> metody.  
  
 Schemat XML jest interpretowany zgodnie ze standardowych XSD.  
  
 Jeśli msdata:DataType i typy xs:type nie są zgodne, może spowodować uszkodzenie danych. Nie zostanie wygenerowany wyjątek.  
  
 `ReadXmlSchema` Zazwyczaj wywoływana jest metoda przed wywołaniem <xref:System.Data.DataTable.ReadXml%2A> metodę, która jest używany do wypełniania <xref:System.Data.DataTable>.  
  
 Aby utworzyć relacji zagnieżdżonej przy użyciu schematu XML, użyj niejawne elementów zagnieżdżonych. Można również skonfigurować relacji zagnieżdżonej można używać nazw kolumn jawnego. Elementy musi być niejawnie zagnieżdżone, aby odpowiednie DataTables brać udziału w relacji zagnieżdżonej.  
  
   
  
## Examples  
 Tworzy nową klasę następującej aplikacji konsoli <xref:System.Data.DataTable>i zapisuje schematu dla tej tabeli do <xref:System.IO.MemoryStream>. Następnie, w przykładzie jest tworzony nowy <xref:System.Data.DataTable> i odczytuje schematem z zapisanym schematu XML.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlIOStream#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlIOStream/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlIOStream#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlIOStream/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.ReadXmlSchema(System.IO.Stream)" />
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.IO.TextReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.IO.TextReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSchema(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (reader As TextReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::IO::TextReader ^ reader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.IO.TextReader" /> Używany do odczytu informacji o schemacie.</param>
        <summary>Odczytuje schematu XML w <see cref="T:System.Data.DataTable" /> przy użyciu określonego <see cref="T:System.IO.TextReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Data.DataTable.ReadXmlSchema%2A> metodę w celu utworzenia schematu <xref:System.Data.DataTable>. Schemat zawiera definicji tabeli, relacji i ograniczenia.  
  
 Aby zapisać schemat dokumentu XML, użyj <xref:System.Data.DataTable.WriteXmlSchema%2A> metody.  
  
 Schemat XML jest interpretowany zgodnie ze standardowych XSD.  
  
 Jeśli msdata:DataType i typy xs:type nie są zgodne, może spowodować uszkodzenie danych. Nie zostanie wygenerowany wyjątek.  
  
 `ReadXmlSchema` Zazwyczaj wywoływana jest metoda przed wywołaniem <xref:System.Data.DataTable.ReadXml%2A> metodę, która jest używany do wypełniania <xref:System.Data.DataTable>.  
  
 Aby utworzyć relacji zagnieżdżonej przy użyciu schematu XML, użyj niejawne elementów zagnieżdżonych. Można także ponownie skonfigurować relacji zagnieżdżonej można używać nazw kolumn jawnego. Elementy musi być niejawnie zagnieżdżone, aby odpowiednie DataTables brać udziału w relacji zagnieżdżonej.  
  
   
  
## Examples  
 Tworzy nową klasę następującej aplikacji konsoli <xref:System.Data.DataTable>i zapisuje schematu dla tej tabeli do <xref:System.IO.MemoryStream>. Następnie, w przykładzie jest tworzony nowy <xref:System.Data.DataTable> i odczytuje schematem z zapisanym schematu XML, za pomocą <xref:System.IO.StreamReader> (który dziedziczy z <xref:System.IO.TextReader>) jako źródło.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlSchema#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchema/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlSchema#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchema/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.ReadXmlSchema(System.IO.TextReader)" />
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSchema(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::String ^ fileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nazwa pliku, z którego można odczytać informacji o schemacie.</param>
        <summary>Odczytuje schematu XML w <see cref="T:System.Data.DataTable" /> z określonego pliku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Data.DataTable.ReadXmlSchema%2A> metodę w celu utworzenia schematu <xref:System.Data.DataTable>. Schemat zawiera definicji tabeli, relacji i ograniczenia.  
  
 Aby zapisać schemat dokumentu XML, użyj <xref:System.Data.DataTable.WriteXmlSchema%2A> metody.  
  
 Schemat XML jest interpretowany zgodnie ze standardowych XSD.  
  
 Jeśli msdata:DataType i typy xs:type nie są zgodne, może spowodować uszkodzenie danych. Nie zostanie wygenerowany wyjątek.  
  
 `ReadXmlSchema` Zazwyczaj wywoływana jest metoda przed wywołaniem <xref:System.Data.DataTable.ReadXml%2A> metodę, która jest używany do wypełniania `DataTable`.  
  
 Aby utworzyć relacji zagnieżdżonej przy użyciu schematu XML, użyj niejawne elementów zagnieżdżonych. Można także ponownie skonfigurować relacji zagnieżdżonej można używać nazw kolumn jawnego. Elementy musi być niejawnie zagnieżdżone, aby odpowiednie DataTables brać udziału w relacji zagnieżdżonej.  
  
   
  
## Examples  
 Tworzy nową klasę następującej aplikacji konsoli <xref:System.Data.DataTable>i zapisuje w pliku schematu dla tej tabeli. Następnie, w przykładzie jest tworzony nowy <xref:System.Data.DataTable> i odczytuje schematem z zapisanym schematu XML, korzystając z pliku jako źródła.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlSchemaString#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchemaString/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlSchemaString#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchemaString/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.ReadXmlSchema(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSchema">
      <MemberSignature Language="C#" Value="public void ReadXmlSchema (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReadXmlSchema(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSchema(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReadXmlSchema (reader As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReadXmlSchema(System::Xml::XmlReader ^ reader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Xml.XmlReader" /> Używany do odczytu informacji o schemacie.</param>
        <summary>Odczytuje schematu XML w <see cref="T:System.Data.DataTable" /> przy użyciu określonego <see cref="T:System.Xml.XmlReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Data.DataTable.ReadXmlSchema%2A> metodę w celu utworzenia schematu <xref:System.Data.DataTable>. Schemat zawiera definicji tabeli, relacji i ograniczenia.  
  
 Aby zapisać schemat dokumentu XML, użyj <xref:System.Data.DataTable.WriteXmlSchema%2A> metody.  
  
 Schemat XML jest interpretowany zgodnie ze standardowych XSD.  
  
 Jeśli msdata:DataType i typy xs:type nie są zgodne, może spowodować uszkodzenie danych. Nie zostanie wygenerowany wyjątek.  
  
 `ReadXmlSchema` Zazwyczaj wywoływana jest metoda przed wywołaniem <xref:System.Data.DataTable.ReadXml%2A> metodę, która jest używany do wypełniania <xref:System.Data.DataTable>.  
  
> [!NOTE]
>  Sposób tworzenia relacji zagnieżdżonej przy użyciu schematu XML ma niejawne elementów zagnieżdżonych. Ponadto można ponownie przewodowej, aby używać nazw kolumn jawne relacji zagnieżdżonej. Jest to konieczne dla elementów być niejawnie zagnieżdżony odpowiedniego DataTables brać udziału w relacji zagnieżdżonej.  
  
   
  
## Examples  
 Tworzy nową klasę następującej aplikacji konsoli <xref:System.Data.DataTable>i zapisuje schematu dla tej tabeli do <xref:System.IO.MemoryStream>. Następnie, w przykładzie jest tworzony nowy <xref:System.Data.DataTable> i odczytuje schematem z zapisanym schematu XML, za pomocą <xref:System.Xml.XmlTextReader> (który dziedziczy z <xref:System.Xml.XmlReader>) jako źródło.  
  
 [!code-csharp[DataWorks DataTable.ReadXmlSchemaReader#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchemaReader/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.ReadXmlSchemaReader#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.ReadXmlSchemaReader/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataSet.ReadXmlSchema(System.Xml.XmlReader)" />
      </Docs>
    </Member>
    <Member MemberName="ReadXmlSerializable">
      <MemberSignature Language="C#" Value="protected virtual void ReadXmlSerializable (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ReadXmlSerializable(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ReadXmlSerializable(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ReadXmlSerializable (reader As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ReadXmlSerializable(System::Xml::XmlReader ^ reader);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">A <see cref="T:System.Xml.XmlReader" /> obiektu.</param>
        <summary>Odczytuje dane ze strumienia XML.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RejectChanges">
      <MemberSignature Language="C#" Value="public void RejectChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RejectChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.RejectChanges" />
      <MemberSignature Language="VB.NET" Value="Public Sub RejectChanges ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RejectChanges();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wycofuje wszystkie zmiany wprowadzone do tabeli, ponieważ została załadowana lub czas ostatniego <see cref="M:System.Data.DataTable.AcceptChanges" /> została wywołana.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Data.DataTable.RejectChanges%2A> po wywołaniu dowolnej <xref:System.Data.DataRow> obiektów, które są nadal w trybie edycji Anuluj ich edycji. Nowe wiersze zostaną usunięte. Wiersze z <xref:System.Data.DataRowState> ustawioną `Modified` lub `Deleted` zwrotu z powrotem do pierwotnego stanu.  
  
   
  
## Examples  
 Poniższy przykład powoduje, że wiele zmian do <xref:System.Data.DataTable>, ale odrzuca zmiany wywołując <xref:System.Data.DataTable.RejectChanges%2A> metody.  
  
 [!code-csharp[Classic WebData DataTable.RejectChanges Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RejectChanges Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RejectChanges Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RejectChanges Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemotingFormat">
      <MemberSignature Language="C#" Value="public System.Data.SerializationFormat RemotingFormat { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.SerializationFormat RemotingFormat" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.RemotingFormat" />
      <MemberSignature Language="VB.NET" Value="Public Property RemotingFormat As SerializationFormat" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::SerializationFormat RemotingFormat { System::Data::SerializationFormat get(); void set(System::Data::SerializationFormat value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.SerializationFormat</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia format serializacji.</summary>
        <value>A <see cref="T:System.Data.SerializationFormat" /> wyliczenie opisujące albo <see langword="Binary" /> lub <see langword="Xml" /> szeregowanie.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public virtual void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Resetuje <see cref="T:System.Data.DataTable" /> do stanu pierwotnego. Resetowanie usuwa wszystkie dane, indeksy relacje i kolumn tabeli. Jeśli zestaw danych zawiera element DataTable, tabeli nadal będzie częścią elementu DataSet po zresetowaniu tabeli.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RowChanged">
      <MemberSignature Language="C#" Value="public event System.Data.DataRowChangeEventHandler RowChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataRowChangeEventHandler RowChanged" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.RowChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RowChanged As DataRowChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataRowChangeEventHandler ^ RowChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRowChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po <see cref="T:System.Data.DataRow" /> został pomyślnie zmieniony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji, zobacz [obsługi zdarzeń DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md).  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.RowChanged Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RowChanged Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RowChanged Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RowChanged Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RowChanging">
      <MemberSignature Language="C#" Value="public event System.Data.DataRowChangeEventHandler RowChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataRowChangeEventHandler RowChanging" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.RowChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RowChanging As DataRowChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataRowChangeEventHandler ^ RowChanging;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRowChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy <see cref="T:System.Data.DataRow" /> jest zmieniany.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji, zobacz [obsługi zdarzeń DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md).  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.RowChanging Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RowChanging Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RowChanging Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RowChanging Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RowDeleted">
      <MemberSignature Language="C#" Value="public event System.Data.DataRowChangeEventHandler RowDeleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataRowChangeEventHandler RowDeleted" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.RowDeleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RowDeleted As DataRowChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataRowChangeEventHandler ^ RowDeleted;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRowChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po usunięciu wiersza w tabeli.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji, zobacz [obsługi zdarzeń DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md).  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.RowDeleted Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RowDeleted Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RowDeleted Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RowDeleted Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RowDeleting">
      <MemberSignature Language="C#" Value="public event System.Data.DataRowChangeEventHandler RowDeleting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataRowChangeEventHandler RowDeleting" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.RowDeleting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RowDeleting As DataRowChangeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataRowChangeEventHandler ^ RowDeleting;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRowChangeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje przed wiersza w tabeli ma zostać usunięty.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji, zobacz [obsługi zdarzeń DataTable](~/docs/framework/data/adonet/dataset-datatable-dataview/handling-datatable-events.md).  
  
   
  
## Examples  
 [!code-csharp[Classic WebData DataTable.RowDeleting Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.RowDeleting Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.RowDeleting Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.RowDeleting Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rows">
      <MemberSignature Language="C#" Value="public System.Data.DataRowCollection Rows { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.DataRowCollection Rows" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Rows" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Rows As DataRowCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::DataRowCollection ^ Rows { System::Data::DataRowCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.DataRowCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję wierszy, które należą do tej tabeli.</summary>
        <value>A <see cref="T:System.Data.DataRowCollection" /> zawierający <see cref="T:System.Data.DataRow" /> obiekty; w przeciwnym razie wartość null, jeśli nie <see cref="T:System.Data.DataRow" /> istnieją obiekty.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby utworzyć nową <xref:System.Data.DataRow>, należy użyć <xref:System.Data.DataTable.NewRow%2A> metoda zwraca nowy obiekt. Taki obiekt jest automatycznie konfigurowany schemat zdefiniowane dla <xref:System.Data.DataTable> za pośrednictwem jego Kolekcja <xref:System.Data.DataColumn> obiektów. Po utworzeniu nowego wiersza i ustawianie wartości dla każdej kolumny w wierszu, Dodaj wiersz, aby <xref:System.Data.DataRowCollection> przy użyciu `Add` metody.  
  
 Każdy <xref:System.Data.DataRow> w kolekcji reprezentuje wiersz danych w tabeli. Aby zatwierdzić zmiany w wartości kolumny w wierszu, należy wywołać <xref:System.Data.DataTable.AcceptChanges%2A> metody.  
  
   
  
## Examples  
 Poniżej przedstawiono dwa przykłady zwracanie i ustawiania wierszy. W pierwszym przykładzie użyto <xref:System.Data.DataTable.Rows%2A> właściwości i wartość każdej kolumny dla każdego wiersza. W drugim przykładzie użyto <xref:System.Data.DataTable> obiektu <xref:System.Data.DataTable.NewRow%2A> metody, aby utworzyć nową <xref:System.Data.DataRow> obiektu ze schematem <xref:System.Data.DataTable>. Po ustawieniu wartości wierszy, wiersz został dodany do <xref:System.Data.DataRowCollection> za pośrednictwem `Add` metody.  
  
 [!code-csharp[Classic WebData DataTable.Rows Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Rows Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Rows Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Rows Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Data.DataTable.AcceptChanges" />
        <altmember cref="T:System.Data.DataRow" />
        <altmember cref="T:System.Data.DataRowCollection" />
        <altmember cref="M:System.Data.DataTable.NewRow" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Select">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera tablicę <see cref="T:System.Data.DataRow" /> obiektów.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] Select ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] Select() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Select" />
      <MemberSignature Language="VB.NET" Value="Public Function Select () As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ Select();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera tablicę wszystkich <see cref="T:System.Data.DataRow" /> obiektów.</summary>
        <returns>Tablica <see cref="T:System.Data.DataRow" /> obiektów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W celu zapewnienia prawidłowego sortowania, określ kryteria sortowania z <xref:System.Data.DataTable.Select%2A> lub <xref:System.Data.DataTable.Select%2A>.  
  
   
  
## Examples  
 Poniższy przykład zwraca tablicę <xref:System.Data.DataRow> obiektów za pomocą <xref:System.Data.DataTable.Select%2A> metody.  
  
 [!code-csharp[Classic WebData DataTable.Select Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Select Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Select Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Select Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.CaseSensitive" />
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] Select (string filterExpression);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] Select(string filterExpression) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Select(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Select (filterExpression As String) As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ Select(System::String ^ filterExpression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filterExpression" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filterExpression">Kryteria służące do filtrowania wierszy. Przykłady dotyczące do filtru wierszy, zobacz [DataView RowFilter składni C#](http://www.csharp-examples.net/dataview-rowfilter/).</param>
        <summary>Pobiera tablicę wszystkich <see cref="T:System.Data.DataRow" /> obiektów spełniających kryteria filtrowania.</summary>
        <returns>Tablica <see cref="T:System.Data.DataRow" /> obiektów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby utworzyć `filterExpression` argumentu, użyj tego samego reguły, które są stosowane do <xref:System.Data.DataColumn> klasy <xref:System.Data.DataColumn.Expression%2A> wartości właściwości dla tworzenia filtrów.  
  
 W celu zapewnienia prawidłowego sortowania, określ kryteria sortowania z <xref:System.Data.DataTable.Select%2A> lub <xref:System.Data.DataTable.Select%2A>.  
  
 Jeśli kolumna w filtrze zawiera wartość null, nie będzie częścią wyniku.  
  
   
  
## Examples  
 W poniższym przykładzie użyto wyrażenia filtru, aby powrócić na tablicę <xref:System.Data.DataRow> obiektów.  
  
 [!code-csharp[Classic WebData DataTable.Select1 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Select1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Select1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Select1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.CaseSensitive" />
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] Select (string filterExpression, string sort);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] Select(string filterExpression, string sort) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Select(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Select (filterExpression As String, sort As String) As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ Select(System::String ^ filterExpression, System::String ^ sort);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filterExpression" Type="System.String" />
        <Parameter Name="sort" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filterExpression">Kryteria służące do filtrowania wierszy. Przykłady dotyczące do filtru wierszy, zobacz [DataView RowFilter składni C#](http://www.csharp-examples.net/dataview-rowfilter/).</param>
        <param name="sort">Ciąg określający kierunku kolumny i sortowania.</param>
        <summary>Pobiera tablicę wszystkich <see cref="T:System.Data.DataRow" /> obiektów spełniających kryteria filtru w określonej kolejności.</summary>
        <returns>Tablica <see cref="T:System.Data.DataRow" /> obiektów spełniających wyrażenia filtru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do formularza `filterExpression` argumentu, użyj tego samego reguł do tworzenia <xref:System.Data.DataColumn> klasy <xref:System.Data.DataColumn.Expression%2A> wartości właściwości. `Sort` Argument również używa tego samego reguł do tworzenia klasy <xref:System.Data.DataColumn.Expression%2A> ciągów.  
  
 Jeśli kolumna w filtrze zawiera wartość null, nie będzie częścią wyniku.  
  
   
  
## Examples  
 W poniższym przykładzie użyto wyrażenia filtru, aby powrócić na tablicę <xref:System.Data.DataRow> obiektów.  
  
 [!code-csharp[Classic WebData DataTable.Select2 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Select2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Select2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Select2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataTable.CaseSensitive" />
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public System.Data.DataRow[] Select (string filterExpression, string sort, System.Data.DataViewRowState recordStates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.DataRow[] Select(string filterExpression, string sort, valuetype System.Data.DataViewRowState recordStates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.Select(System.String,System.String,System.Data.DataViewRowState)" />
      <MemberSignature Language="VB.NET" Value="Public Function Select (filterExpression As String, sort As String, recordStates As DataViewRowState) As DataRow()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Data::DataRow ^&gt; ^ Select(System::String ^ filterExpression, System::String ^ sort, System::Data::DataViewRowState recordStates);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataRow[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filterExpression" Type="System.String" />
        <Parameter Name="sort" Type="System.String" />
        <Parameter Name="recordStates" Type="System.Data.DataViewRowState" />
      </Parameters>
      <Docs>
        <param name="filterExpression">Kryteria służące do filtrowania wierszy. Przykłady dotyczące do filtru wierszy, zobacz [DataView RowFilter składni C#](http://www.csharp-examples.net/dataview-rowfilter/).</param>
        <param name="sort">Ciąg określający kierunku kolumny i sortowania.</param>
        <param name="recordStates">Jeden z <see cref="T:System.Data.DataViewRowState" /> wartości.</param>
        <summary>Pobiera tablicę wszystkich <see cref="T:System.Data.DataRow" /> obiekty spełniające kryteria filtru, kolejności sortowania, które odpowiadają określonego stanu.</summary>
        <returns>Tablica <see cref="T:System.Data.DataRow" /> obiektów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do formularza `filterExpression` argumentu, użyj tego samego reguł do tworzenia <xref:System.Data.DataColumn> klasy <xref:System.Data.DataColumn.Expression%2A> wartości właściwości. `Sort` Argument również używa tego samego reguł do tworzenia klasy <xref:System.Data.DataColumn.Expression%2A> ciągów.  
  
 Jeśli kolumna w filtrze zawiera wartość null, nie będzie częścią wyniku.  
  
   
  
## Examples  
 W poniższym przykładzie użyto stan filtru wyrażeń i rejestrowanie, aby zwracało tablicę z <xref:System.Data.DataRow> obiektów.  
  
 [!code-csharp[Classic WebData DataTable.Select3 Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.Select3 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.Select3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.Select3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.Site" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.ComponentModel.ISite" /> dla <see cref="T:System.Data.DataTable" />.</summary>
        <value>
          <see cref="T:System.ComponentModel.ISite" /> Dla <see cref="T:System.Data.DataTable" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Powiązania witryny <xref:System.ComponentModel.Component> do <xref:System.ComponentModel.Container> i umożliwić komunikację między nimi, a także umożliwiają kontener, aby zarządzać jego składniki.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.ContainsListCollection">
      <MemberSignature Language="C#" Value="bool System.ComponentModel.IListSource.ContainsListCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.ComponentModel.IListSource.ContainsListCollection" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.System#ComponentModel#IListSource#ContainsListCollection" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ContainsListCollection As Boolean Implements IListSource.ContainsListCollection" />
      <MemberSignature Language="C++ CLI" Value="property bool System.ComponentModel.IListSource.ContainsListCollection { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="P:System.ComponentModel.IListSource.ContainsListCollection" />.</summary>
        <value>
          <see langword="true" /> Jeśli kolekcja jest kolekcją <see cref="T:System.Collections.IList" /> obiekty; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Data.DataTable> wystąpienia jest rzutowane na <xref:System.ComponentModel.IListSource> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IListSource.GetList">
      <MemberSignature Language="C#" Value="System.Collections.IList IListSource.GetList ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IList System.ComponentModel.IListSource.GetList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.System#ComponentModel#IListSource#GetList" />
      <MemberSignature Language="VB.NET" Value="Function GetList () As IList Implements IListSource.GetList" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IList ^ System.ComponentModel.IListSource.GetList() = System::ComponentModel::IListSource::GetList;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="M:System.ComponentModel.IListSource.GetList" />.</summary>
        <returns>
          <see cref="T:System.Collections.IList" /> Który może być powiązana ze źródłem danych z obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Data.DataTable> wystąpienia jest rzutowane na <xref:System.ComponentModel.IListSource> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.GetSchema">
      <MemberSignature Language="C#" Value="System.Xml.Schema.XmlSchema IXmlSerializable.GetSchema ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Xml.Schema.XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#GetSchema" />
      <MemberSignature Language="VB.NET" Value="Function GetSchema () As XmlSchema Implements IXmlSerializable.GetSchema" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Xml::Schema::XmlSchema ^ System.Xml.Serialization.IXmlSerializable.GetSchema() = System::Xml::Serialization::IXmlSerializable::GetSchema;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.GetSchema</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchema</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="M:System.Xml.Serialization.IXmlSerializable.GetSchema" />.</summary>
        <returns>
          <see cref="T:System.Xml.Schema.XmlSchema" /> Opisujący reprezentację XML obiektu, który jest generowany przez <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" /> — metoda i używane przez <see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" /> metody.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Data.DataSet> wystąpienia jest rzutowane na <xref:System.Xml.Serialization.IXmlSerializable> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.ReadXml">
      <MemberSignature Language="C#" Value="void IXmlSerializable.ReadXml (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Xml.Serialization.IXmlSerializable.ReadXml(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Sub ReadXml (reader As XmlReader) Implements IXmlSerializable.ReadXml" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Xml.Serialization.IXmlSerializable.ReadXml(System::Xml::XmlReader ^ reader) = System::Xml::Serialization::IXmlSerializable::ReadXml;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Element XmlReader.</param>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="M:System.Xml.Serialization.IXmlSerializable.ReadXml(System.Xml.XmlReader)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Data.DataSet> wystąpienia jest rzutowane na <xref:System.Xml.Serialization.IXmlSerializable> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.Serialization.IXmlSerializable.WriteXml">
      <MemberSignature Language="C#" Value="void IXmlSerializable.WriteXml (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Xml.Serialization.IXmlSerializable.WriteXml(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Sub WriteXml (writer As XmlWriter) Implements IXmlSerializable.WriteXml" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Xml.Serialization.IXmlSerializable.WriteXml(System::Xml::XmlWriter ^ writer) = System::Xml::Serialization::IXmlSerializable::WriteXml;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Element XmlWriter.</param>
        <summary>Opis tego elementu członkowskiego, zobacz <see cref="M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Data.DataSet> wystąpienia jest rzutowane na <xref:System.Xml.Serialization.IXmlSerializable> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TableCleared">
      <MemberSignature Language="C#" Value="public event System.Data.DataTableClearEventHandler TableCleared;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataTableClearEventHandler TableCleared" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.TableCleared" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TableCleared As DataTableClearEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataTableClearEventHandler ^ TableCleared;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableClearEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po <see cref="T:System.Data.DataTable" /> jest wyczyszczone.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.TableCleared> Zdarzenie jest wywoływane bezpośrednio po wszystkie wiersze zostały pomyślnie wyczyszczone ale przed wysłaniem <xref:System.Data.DataTable.Clear%2A> metoda zwraca sterowanie do obiektu wywołującego. <xref:System.Data.DataTable.TableCleared> Zdarzeń nie jest uruchamiany, jeśli ma żadnych wyjątków podczas operacji Wyczyść.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TableClearing">
      <MemberSignature Language="C#" Value="public event System.Data.DataTableClearEventHandler TableClearing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataTableClearEventHandler TableClearing" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.TableClearing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TableClearing As DataTableClearEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataTableClearEventHandler ^ TableClearing;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableClearEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy <see cref="T:System.Data.DataTable" /> jest wyczyszczone.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.TableClearing> Zdarzenie jest wywoływane przed przetwarzania <xref:System.Data.DataTable.Clear%2A> rozpocznie się wykonywanie operacji. To zdarzenie jest wywoływane zawsze, gdy <xref:System.Data.DataTable.Clear%2A> wywoływana jest metoda, nawet jeśli tabela nie zawiera żadnych wierszy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TableName">
      <MemberSignature Language="C#" Value="public string TableName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TableName" />
      <MemberSignature Language="DocId" Value="P:System.Data.DataTable.TableName" />
      <MemberSignature Language="VB.NET" Value="Public Property TableName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TableName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę <see cref="T:System.Data.DataTable" />.</summary>
        <value>Nazwa <see cref="T:System.Data.DataTable" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.TableName%2A> Służy do zwracania tabeli z obiektu nadrzędnego <xref:System.Data.DataSet> obiektu <xref:System.Data.DataTableCollection> (zwrócony przez <xref:System.Data.DataSet.Tables%2A> właściwości).  
  
   
  
## Examples  
 W poniższym przykładzie <xref:System.Data.DataTable.TableName%2A> dla każdej tabeli w kolekcji <xref:System.Data.DataTable> obiektów.  
  
 [!code-csharp[Classic WebData DataTable.TableName Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.TableName Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.TableName Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.TableName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see langword="null" /> lub jest pustym ciągiem ("") jest przekazywany w i tej tabeli należy do kolekcji.</exception>
        <exception cref="T:System.Data.DuplicateNameException">Tabela należy do kolekcji, która już istnieje tabela o takiej samej nazwie. (Porównanie jest rozróżniana wielkość liter).</exception>
        <altmember cref="T:System.Data.DataSet" />
        <altmember cref="P:System.Data.DataSet.Tables" />
      </Docs>
    </Member>
    <Member MemberName="TableNewRow">
      <MemberSignature Language="C#" Value="public event System.Data.DataTableNewRowEventHandler TableNewRow;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Data.DataTableNewRowEventHandler TableNewRow" />
      <MemberSignature Language="DocId" Value="E:System.Data.DataTable.TableNewRow" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TableNewRow As DataTableNewRowEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Data::DataTableNewRowEventHandler ^ TableNewRow;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.DataTableNewRowEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy nowy <see cref="T:System.Data.DataRow" /> dodaje się.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uruchamiany po nowy <xref:System.Data.DataRow> został utworzony przy użyciu <xref:System.Data.DataTable.NewRow%2A>. To zdarzenie jest wywoływane przed wywołanej `NewRow` zwraca metody. Nowe <xref:System.Data.DataRow> odłączono wystąpienia; nie został dodany do kolekcji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera <see cref="P:System.Data.DataTable.TableName" /> i <see cref="P:System.Data.DataTable.DisplayExpression" />, jeśli są określone jako połączony ciąg.</summary>
        <returns>Ciąg zawierający <see cref="P:System.Data.DataTable.TableName" /> i <see cref="P:System.Data.DataTable.DisplayExpression" /> wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pobiera <xref:System.Data.DataTable.TableName%2A> i <xref:System.Data.DataTable.DisplayExpression%2A> dla <xref:System.Data.DataTable>.  
  
   
  
## Examples  
 Poniższy przykład zwraca <xref:System.Data.DataTable.TableName%2A> i <xref:System.Data.DataTable.DisplayExpression%2A> przy użyciu <xref:System.Data.DataTable.ToString%2A> metody.  
  
 [!code-csharp[Classic WebData DataTable.ToString Example#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/Classic WebData DataTable.ToString Example/CS/source.cs#1)]
 [!code-vb[Classic WebData DataTable.ToString Example#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/Classic WebData DataTable.ToString Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteXml">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapisuje bieżącą zawartość <see cref="T:System.Data.DataTable" /> jako XML.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> Metoda zapewnia sposób można zapisać tylko dane lub zarówno danych i schemat z <xref:System.Data.DataTable> do dokumentu XML, podczas gdy <xref:System.Data.DataTable.WriteXmlSchema%2A> metoda zapisuje tylko schemat. Aby napisać zarówno danych, jak i schematu, użyj jednego z przeciążeń, które obejmują <xref:System.Data.XmlWriteMode> parametru i ustaw dla niego wartość `WriteSchema`.  
  
 Należy pamiętać, że to samo dotyczy dla <xref:System.Data.DataTable.ReadXml%2A> i <xref:System.Data.DataTable.ReadXmlSchema%2A> metod, odpowiednio. Mają być odczytywane dane XML lub schemat i dane do `DataTable`, użyj `ReadXml` metody. Aby odczytać tylko schemat, należy użyć `ReadXmlSchema` metody.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Zostanie wygenerowany, jeśli typ kolumny w `DataRow` trwa od zapisu lub odczytu implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> i nie implementuje <xref:System.Xml.Serialization.IXmlSerializable>.  
  
   
  
## Examples  
 Następującej aplikacji konsoli tworzy dwa <xref:System.Data.DataTable> wystąpienia, dodaje do <xref:System.Data.DataSet>, tworzy <xref:System.Data.DataRelation> dotyczące dwóch tabel, a następnie używa <xref:System.Data.DataTable.WriteXml%2A> metody do zapisania danych zawartych w tabeli nadrzędnej w celu <xref:System.IO.TextWriter>. W przykładzie pokazano zachowanie podczas ustawiania `writeHierarchy` parametru do każdego z jego wartości.  
  
> [!NOTE]
>  W tym przykładzie pokazano, jak używać jednej z zastąpionej wersji WriteXml. Inne przykłady, które mogą być dostępne znajduje się w tematach poszczególnych przeciążenia.  
  
 [!code-csharp[DataWorks DataTable.WriteXmlOverload#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlOverload/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXmlOverload#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlOverload/VB/source.vb#1)]  
  
 W przykładzie przedstawiono następujące wyniki w oknie konsoli:  
  
```  
==============================  
Customer table, without hierarchy  
==============================  
<NewDataSet>  
  <xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema  
" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
    <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
      <xs:complexType>  
        <xs:choice minOccurs="0" maxOccurs="unbounded">  
          <xs:element name="Table1">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="ID" type="xs:int" />  
                <xs:element name="Name" type="xs:string" minOccurs="0" />  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
        </xs:choice>  
      </xs:complexType>  
      <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table1" />  
        <xs:field xpath="ID" />  
      </xs:unique>  
    </xs:element>  
  </xs:schema>  
  <Table1>  
    <ID>1</ID>  
    <Name>Mary</Name>  
  </Table1>  
  <Table1>  
    <ID>2</ID>  
    <Name>Andy</Name>  
  </Table1>  
  <Table1>  
    <ID>3</ID>  
    <Name>Peter</Name>  
  </Table1>  
  <Table1>  
    <ID>4</ID>  
    <Name>Russ</Name>  
  </Table1>  
</NewDataSet>  
==============================  
Customer table, with hierarchy  
==============================  
<NewDataSet>  
  <xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema  
" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
    <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
      <xs:complexType>  
        <xs:choice minOccurs="0" maxOccurs="unbounded">  
          <xs:element name="Table1">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="ID" type="xs:int" />  
                <xs:element name="Name" type="xs:string" minOccurs="0" />  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
          <xs:element name="Table2">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="OrderID" type="xs:int" />  
                <xs:element name="CustomerID" type="xs:int" minOccurs="0" />  
                <xs:element name="OrderDate" type="xs:dateTime" minOccurs="0" />  
  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
        </xs:choice>  
      </xs:complexType>  
      <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table1" />  
        <xs:field xpath="ID" />  
      </xs:unique>  
      <xs:unique name="Table2_Constraint1" msdata:ConstraintName="Constraint1" m  
sdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table2" />  
        <xs:field xpath="OrderID" />  
      </xs:unique>  
      <xs:keyref name="CustomerOrder" refer="Constraint1">  
        <xs:selector xpath=".//Table2" />  
        <xs:field xpath="CustomerID" />  
      </xs:keyref>  
    </xs:element>  
  </xs:schema>  
  <Table1>  
    <ID>1</ID>  
    <Name>Mary</Name>  
  </Table1>  
  <Table1>  
    <ID>2</ID>  
    <Name>Andy</Name>  
  </Table1>  
  <Table1>  
    <ID>3</ID>  
    <Name>Peter</Name>  
  </Table1>  
  <Table1>  
    <ID>4</ID>  
    <Name>Russ</Name>  
  </Table1>  
  <Table2>  
    <OrderID>1</OrderID>  
    <CustomerID>1</CustomerID>  
    <OrderDate>2003-12-02T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>2</OrderID>  
    <CustomerID>1</CustomerID>  
    <OrderDate>2004-01-03T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>3</OrderID>  
    <CustomerID>2</CustomerID>  
    <OrderDate>2004-11-13T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>4</OrderID>  
    <CustomerID>3</CustomerID>  
    <OrderDate>2004-05-16T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>5</OrderID>  
    <CustomerID>3</CustomerID>  
    <OrderDate>2004-05-22T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>6</OrderID>  
    <CustomerID>4</CustomerID>  
    <OrderDate>2004-06-15T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
</NewDataSet>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Strumień, z którym będą zapisywane dane.</param>
        <summary>Zapisuje bieżącą zawartość <see cref="T:System.Data.DataTable" /> jako XML przy użyciu określonego <see cref="T:System.IO.Stream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> Metoda zapewnia sposób można zapisać tylko dane lub zarówno danych i schemat z <xref:System.Data.DataTable> do dokumentu XML, podczas gdy <xref:System.Data.DataTable.WriteXmlSchema%2A> metoda zapisuje tylko schemat. Aby napisać zarówno danych, jak i schematu, użyj jednego z przeciążeń, które obejmuje <xref:System.Data.XmlWriteMode> parametru i ustaw dla niego wartość `WriteSchema`.  
  
 Należy pamiętać, że to samo dotyczy dla <xref:System.Data.DataTable.ReadXml%2A> i <xref:System.Data.DataTable.ReadXmlSchema%2A> metod, odpowiednio. Mają być odczytywane dane XML lub schemat i dane do `DataTable`, użyj `ReadXml` metody. Aby odczytać tylko schemat, należy użyć `ReadXmlSchema` metody.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Zostanie wygenerowany, jeśli typ kolumny w `DataRow` trwa od zapisu lub odczytu implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> i nie implementuje <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.IO.TextWriter" /> z którym można zapisać zawartości.</param>
        <summary>Zapisuje bieżącą zawartość <see cref="T:System.Data.DataTable" /> jako XML przy użyciu określonego <see cref="T:System.IO.TextWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> Metoda zapewnia sposób można zapisać tylko dane lub zarówno danych i schemat z <xref:System.Data.DataTable> do dokumentu XML, podczas gdy <xref:System.Data.DataTable.WriteXmlSchema%2A> metoda zapisuje tylko schemat. Aby napisać zarówno danych, jak i schematu, użyj jednego z przeciążeń, które obejmuje <xref:System.Data.XmlWriteMode> parametru i ustaw dla niego wartość `WriteSchema`.  
  
 Należy pamiętać, że to samo dotyczy dla <xref:System.Data.DataTable.ReadXml%2A> i <xref:System.Data.DataTable.ReadXmlSchema%2A> metod, odpowiednio. Mają być odczytywane dane XML lub schemat i dane do `DataTable`, użyj `ReadXml` metody. Aby odczytać tylko schemat, należy użyć `ReadXmlSchema` metody.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Zostanie wygenerowany, jeśli typ kolumny w `DataRow` trwa od zapisu lub odczytu implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> i nie implementuje <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Plik, do którego można zapisać danych XML.</param>
        <summary>Zapisuje bieżącą zawartość <see cref="T:System.Data.DataTable" /> jako XML przy użyciu określonego pliku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> Metoda zapewnia sposób można zapisać tylko dane lub zarówno danych i schemat z <xref:System.Data.DataTable> do dokumentu XML, podczas gdy <xref:System.Data.DataTable.WriteXmlSchema%2A> metoda zapisuje tylko schemat. Aby napisać zarówno danych, jak i schematu, użyj jednego z przeciążeń, które obejmuje <xref:System.Data.XmlWriteMode> parametru i ustaw dla niego wartość `WriteSchema`.  
  
 Należy pamiętać, że to samo dotyczy dla <xref:System.Data.DataTable.ReadXml%2A> i <xref:System.Data.DataTable.ReadXmlSchema%2A> metod, odpowiednio. Mają być odczytywane dane XML lub schemat i dane do `DataTable`, użyj `ReadXml` metody. Aby odczytać tylko schemat, należy użyć `ReadXmlSchema` metody.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Zostanie wygenerowany, jeśli typ kolumny w `DataRow` trwa od zapisu lub odczytu implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> i nie implementuje <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.Serialization.IXmlSerializable.WriteXml(System.Xml.XmlWriter)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.Xml.XmlWriter" /> Umożliwiające zapisanie zawartości.</param>
        <summary>Zapisuje bieżącą zawartość <see cref="T:System.Data.DataTable" /> jako XML przy użyciu określonego <see cref="T:System.Xml.XmlWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> Metoda zapewnia sposób można zapisać tylko dane lub zarówno danych i schemat z <xref:System.Data.DataTable> do dokumentu XML, podczas gdy <xref:System.Data.DataTable.WriteXmlSchema%2A> metoda zapisuje tylko schemat. Aby napisać zarówno danych, jak i schematu, użyj jednego z przeciążeń, które obejmują <xref:System.Data.XmlWriteMode> parametru i ustaw dla niego wartość `WriteSchema`.  
  
 Należy pamiętać, że to samo dotyczy dla <xref:System.Data.DataTable.ReadXml%2A> i <xref:System.Data.DataTable.ReadXmlSchema%2A> metod, odpowiednio. Mają być odczytywane dane XML lub schemat i dane do `DataTable`, użyj `ReadXml` metody. Aby odczytać tylko schemat, należy użyć `ReadXmlSchema` metody.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Zostanie wygenerowany, jeśli typ kolumny w `DataRow` trwa od zapisu lub odczytu implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> i nie implementuje <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream, bool writeHierarchy);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">Strumień, z którym będą zapisywane dane.</param>
        <param name="writeHierarchy">Jeśli <see langword="true" />, zapisywanie zawartości w bieżącej tabeli i wszystkich jego elementów podrzędnych. Jeśli <see langword="false" /> (wartość domyślna), zapis danych dla bieżącej tabeli.</param>
        <summary>Zapisuje bieżącą zawartość <see cref="T:System.Data.DataTable" /> jako XML przy użyciu określonego <see cref="T:System.IO.Stream" />. Aby zapisać dane dla tabeli i wszystkich jego elementów podrzędnych, ustawić <paramref name="writeHierarchy" /> parametr <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Data.DataTable.WriteXmlSchema%2A> metodę, aby zapisać schematu <xref:System.Data.DataTable> do dokumentu XML. Schemat zawiera definicji tabeli, relacji i ograniczenia.  
  
 Schemat XML jest zapisywany przy użyciu standardu XSD.  
  
 Aby zapisać dane dokumentu XML, użyj <xref:System.Data.DataTable.WriteXml%2A> metody.  
  
 Zwykle `WriteXml` metody zapisuje dane tylko dla bieżącej tabeli. Można zapisać danych w bieżącej tabeli i wszystkich jego obiektu podrzędnego powiązane tabele, wywołaj metodę z `writeHierarchy` ustawiono parametr `true`.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Zostanie wygenerowany, jeśli typ kolumny w `DataRow` trwa od zapisu lub odczytu implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> i nie implementuje <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream, System::Data::XmlWriteMode mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="stream">Strumień, z którym będą zapisywane dane.</param>
        <param name="mode">Jeden z <see cref="T:System.Data.XmlWriteMode" /> wartości.</param>
        <summary>Zapisuje bieżące dane i opcjonalnie schematu dla <see cref="T:System.Data.DataTable" /> do określonego pliku przy użyciu określonego <see cref="T:System.Data.XmlWriteMode" />. Aby napisać schemat, należy ustawić wartość <paramref name="mode" /> parametr <see langword="WriteSchema" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> Metoda zapewnia sposób można zapisać tylko dane lub zarówno danych i schemat z <xref:System.Data.DataTable> do dokumentu XML, podczas gdy <xref:System.Data.DataTable.WriteXmlSchema%2A> metoda zapisuje tylko schemat. Aby napisać zarówno danych, jak i schematu, użyj jednego z przeciążeń, które obejmuje <xref:System.Data.XmlWriteMode> parametru i ustaw dla niego wartość `WriteSchema`.  
  
 Należy pamiętać, że to samo dotyczy dla <xref:System.Data.DataTable.ReadXml%2A> i <xref:System.Data.DataTable.ReadXmlSchema%2A> metod, odpowiednio. Mają być odczytywane dane XML lub schemat i dane do `DataTable`, użyj `ReadXml` metody. Aby odczytać tylko schemat, należy użyć `ReadXmlSchema` metody.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Zostanie wygenerowany, jeśli typ kolumny w `DataRow` trwa od zapisu lub odczytu implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> i nie implementuje <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer, bool writeHierarchy);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.IO.TextWriter" /> z którym można zapisać zawartości.</param>
        <param name="writeHierarchy">Jeśli <see langword="true" />, zapisywanie zawartości w bieżącej tabeli i wszystkich jego elementów podrzędnych. Jeśli <see langword="false" /> (wartość domyślna), zapis danych dla bieżącej tabeli.</param>
        <summary>Zapisuje bieżącą zawartość <see cref="T:System.Data.DataTable" /> jako XML przy użyciu określonego <see cref="T:System.IO.TextWriter" />. Aby zapisać dane dla tabeli i wszystkich jego elementów podrzędnych, ustawić <paramref name="writeHierarchy" /> parametr <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> Metoda zapewnia sposób można zapisać tylko dane lub zarówno danych i schemat z <xref:System.Data.DataTable> do dokumentu XML, podczas gdy <xref:System.Data.DataTable.WriteXmlSchema%2A> metoda zapisuje tylko schemat. Aby napisać zarówno danych, jak i schematu, użyj jednego z przeciążeń, które obejmuje <xref:System.Data.XmlWriteMode> parametru i ustaw dla niego wartość `WriteSchema`.  
  
 Zwykle `WriteXml` metody zapisuje dane tylko dla bieżącej tabeli. Można zapisać danych do bieżącej tabeli i wszystkich jego elementów podrzędnych, powiązane tabele, wywołaj metodę z `writeHierarchy` ustawiono parametr `true`.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Zostanie wygenerowany, jeśli typ kolumny w `DataRow` trwa od zapisu lub odczytu implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> i nie implementuje <xref:System.Xml.Serialization.IXmlSerializable>.  
  
   
  
## Examples  
 Następującej aplikacji konsoli tworzy dwa <xref:System.Data.DataTable> wystąpienia, dodaje do <xref:System.Data.DataSet>, tworzy <xref:System.Data.DataRelation> dotyczące dwóch tabel, a następnie używa <xref:System.Data.DataTable.WriteXml%2A> metody do zapisania danych zawartych w tabeli nadrzędnej w celu <xref:System.IO.TextWriter>. W przykładzie pokazano zachowanie podczas ustawiania `writeHierarchy` parametr `true`.  
  
 [!code-csharp[DataWorks DataTable.WriteXml#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXml/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXml#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXml/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer, System::Data::XmlWriteMode mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.IO.TextWriter" /> Używany do zapisywania dokumentu.</param>
        <param name="mode">Jeden z <see cref="T:System.Data.XmlWriteMode" /> wartości.</param>
        <summary>Zapisuje bieżące dane i opcjonalnie schematu dla <see cref="T:System.Data.DataTable" /> przy użyciu określonego <see cref="T:System.IO.TextWriter" /> i <see cref="T:System.Data.XmlWriteMode" />. Aby napisać schemat, należy ustawić wartość <paramref name="mode" /> parametr <see langword="WriteSchema" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> Metoda zapewnia sposób można zapisać tylko dane lub zarówno danych i schemat z <xref:System.Data.DataTable> do dokumentu XML, podczas gdy <xref:System.Data.DataTable.WriteXmlSchema%2A> metoda zapisuje tylko schemat. Aby napisać zarówno danych, jak i schematu, użyj jednego z przeciążeń, które obejmuje <xref:System.Data.XmlWriteMode> parametru i ustaw dla niego wartość `WriteSchema`.  
  
 Należy pamiętać, że to samo dotyczy dla <xref:System.Data.DataTable.ReadXml%2A> i <xref:System.Data.DataTable.ReadXmlSchema%2A> metod, odpowiednio. Mają być odczytywane dane XML lub schemat i dane do `DataTable`, użyj `ReadXml` metody. Aby odczytać tylko schemat, należy użyć `ReadXmlSchema` metody.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Zostanie wygenerowany, jeśli typ kolumny w `DataRow` trwa od zapisu lub odczytu implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> i nie implementuje <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName, bool writeHierarchy);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="fileName">Plik, do którego można zapisać danych XML.</param>
        <param name="writeHierarchy">Jeśli <see langword="true" />, zapisywanie zawartości w bieżącej tabeli i wszystkich jego elementów podrzędnych. Jeśli <see langword="false" /> (wartość domyślna), zapis danych dla bieżącej tabeli.</param>
        <summary>Zapisuje bieżącą zawartość <see cref="T:System.Data.DataTable" /> jako XML przy użyciu określonego pliku. Aby zapisać dane dla tabeli i wszystkich jego elementów podrzędnych, ustawić <paramref name="writeHierarchy" /> parametr <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> Metoda zapewnia sposób można zapisać tylko dane lub zarówno danych i schemat z <xref:System.Data.DataTable> do dokumentu XML, podczas gdy <xref:System.Data.DataTable.WriteXmlSchema%2A> metoda zapisuje tylko schemat. Aby napisać zarówno danych, jak i schematu, użyj jednego z przeciążeń, które obejmuje <xref:System.Data.XmlWriteMode> parametru i ustaw dla niego wartość `WriteSchema`.  
  
 Należy pamiętać, że to samo dotyczy dla <xref:System.Data.DataTable.ReadXml%2A> i <xref:System.Data.DataTable.ReadXmlSchema%2A> metod, odpowiednio. Mają być odczytywane dane XML lub schemat i dane do `DataTable`, użyj `ReadXml` metody. Aby odczytać tylko schemat, należy użyć `ReadXmlSchema` metody.  
  
 Zwykle `WriteXml` metody zapisuje dane tylko dla bieżącej tabeli. Można zapisać danych w bieżącej tabeli i wszystkich jego obiektu podrzędnego powiązane tabele, wywołaj metodę z `writeHierarchy` ustawiono parametr `true`.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Zostanie wygenerowany, jeśli typ kolumny w `DataRow` trwa od zapisu lub odczytu implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> i nie implementuje <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName, System::Data::XmlWriteMode mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="fileName">Nazwa pliku, do którego zostaną zapisane dane.</param>
        <param name="mode">Jeden z <see cref="T:System.Data.XmlWriteMode" /> wartości.</param>
        <summary>Zapisuje bieżące dane i opcjonalnie schematu dla <see cref="T:System.Data.DataTable" /> przy użyciu określonego pliku i <see cref="T:System.Data.XmlWriteMode" />. Aby napisać schemat, należy ustawić wartość <paramref name="mode" /> parametr <see langword="WriteSchema" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> Metoda zapewnia sposób można zapisać tylko dane lub zarówno danych i schemat z <xref:System.Data.DataTable> do dokumentu XML, podczas gdy <xref:System.Data.DataTable.WriteXmlSchema%2A> metoda zapisuje tylko schemat. Aby napisać zarówno danych, jak i schematu, użyj jednego z przeciążeń, które obejmują <xref:System.Data.XmlWriteMode> parametru i ustaw dla niego wartość `WriteSchema`.  
  
 Należy pamiętać, że to samo dotyczy dla <xref:System.Data.DataTable.ReadXml%2A> i <xref:System.Data.DataTable.ReadXmlSchema%2A> metod, odpowiednio. Mają być odczytywane dane XML lub schemat i dane do `DataTable`, użyj `ReadXml` metody. Aby odczytać tylko schemat, należy użyć `ReadXmlSchema` metody.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Zostanie wygenerowany, jeśli typ kolumny w `DataRow` trwa od zapisu lub odczytu implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> i nie implementuje <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer, bool writeHierarchy);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.Xml.XmlWriter" /> Umożliwiające zapisanie zawartości.</param>
        <param name="writeHierarchy">Jeśli <see langword="true" />, zapisywanie zawartości w bieżącej tabeli i wszystkich jego elementów podrzędnych. Jeśli <see langword="false" /> (wartość domyślna), zapis danych dla bieżącej tabeli.</param>
        <summary>Zapisuje bieżącą zawartość <see cref="T:System.Data.DataTable" /> jako XML przy użyciu określonego <see cref="T:System.Xml.XmlWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> Metoda zapewnia sposób można zapisać tylko dane lub zarówno danych i schemat z <xref:System.Data.DataTable> do dokumentu XML, podczas gdy <xref:System.Data.DataTable.WriteXmlSchema%2A> metoda zapisuje tylko schemat. Aby napisać zarówno danych, jak i schematu, użyj jednego z przeciążeń, które obejmują <xref:System.Data.XmlWriteMode> parametru i ustaw dla niego wartość `WriteSchema`.  
  
 Należy pamiętać, że to samo dotyczy dla <xref:System.Data.DataTable.ReadXml%2A> i <xref:System.Data.DataTable.ReadXmlSchema%2A> metod, odpowiednio. Mają być odczytywane dane XML lub schemat i dane do `DataTable`, użyj `ReadXml` metody. Aby odczytać tylko schemat, należy użyć `ReadXmlSchema` metody.  
  
 Zwykle `WriteXml` metody zapisuje dane tylko dla bieżącej tabeli. Można zapisać danych do bieżącej tabeli i jego całą podrzędne, powiązane tabele, wywołaj metodę z `writeHierarchy` ustawiono parametr `true`.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Zostanie wygenerowany, jeśli typ kolumny w `DataRow` trwa od zapisu lub odczytu implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> i nie implementuje <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer, System.Data.XmlWriteMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer, valuetype System.Data.XmlWriteMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter, mode As XmlWriteMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer, System::Data::XmlWriteMode mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.Xml.XmlWriter" /> Używany do zapisywania dokumentu.</param>
        <param name="mode">Jeden z <see cref="T:System.Data.XmlWriteMode" /> wartości.</param>
        <summary>Zapisuje bieżące dane i opcjonalnie schematu dla <see cref="T:System.Data.DataTable" /> przy użyciu określonego <see cref="T:System.Xml.XmlWriter" /> i <see cref="T:System.Data.XmlWriteMode" />. Aby napisać schemat, należy ustawić wartość <paramref name="mode" /> parametr <see langword="WriteSchema" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> Metoda zapewnia sposób można zapisać tylko dane lub zarówno danych i schemat z <xref:System.Data.DataTable> do dokumentu XML, podczas gdy <xref:System.Data.DataTable.WriteXmlSchema%2A> metoda zapisuje tylko schemat. Aby napisać zarówno danych, jak i schematu, użyj jednego z przeciążeń, które obejmują <xref:System.Data.XmlWriteMode> parametru i ustaw dla niego wartość `WriteSchema`.  
  
 Należy pamiętać, że to samo dotyczy dla <xref:System.Data.DataTable.ReadXml%2A> i <xref:System.Data.DataTable.ReadXmlSchema%2A> metod, odpowiednio. Mają być odczytywane dane XML lub schemat i dane do `DataTable`, użyj `ReadXml` metody. Aby odczytać tylko schemat, należy użyć `ReadXmlSchema` metody.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Zostanie wygenerowany, jeśli typ kolumny w `DataRow` trwa od zapisu lub odczytu implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> i nie implementuje <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.Stream stream, System.Data.XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.Stream stream, valuetype System.Data.XmlWriteMode mode, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.Stream,System.Data.XmlWriteMode,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::Stream ^ stream, System::Data::XmlWriteMode mode, bool writeHierarchy);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">Strumień, z którym będą zapisywane dane.</param>
        <param name="mode">Jeden z <see cref="T:System.Data.XmlWriteMode" /> wartości.</param>
        <param name="writeHierarchy">Jeśli <see langword="true" />, zapisywanie zawartości w bieżącej tabeli i wszystkich jego elementów podrzędnych. Jeśli <see langword="false" /> (wartość domyślna), zapis danych dla bieżącej tabeli.</param>
        <summary>Zapisuje bieżące dane i opcjonalnie schematu dla <see cref="T:System.Data.DataTable" /> do określonego pliku przy użyciu określonego <see cref="T:System.Data.XmlWriteMode" />. Aby napisać schemat, należy ustawić wartość <paramref name="mode" /> parametr <see langword="WriteSchema" />. Aby zapisać dane dla tabeli i wszystkich jego elementów podrzędnych, ustawić <paramref name="writeHierarchy" /> parametr <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> Metoda zapewnia sposób można zapisać tylko dane lub zarówno danych i schemat z `DataTable` do dokumentu XML, podczas gdy <xref:System.Data.DataTable.WriteXmlSchema%2A> metoda zapisuje tylko schemat. Aby napisać zarówno danych, jak i schematu, użyj jednego z przeciążeń, które obejmuje `XmlWriteMode` parametru i ustaw dla niego wartość `WriteSchema`.  
  
 Należy pamiętać, że to samo dotyczy dla <xref:System.Data.DataTable.ReadXml%2A> i <xref:System.Data.DataTable.ReadXmlSchema%2A> metod, odpowiednio. Mają być odczytywane dane XML lub schemat i dane do `DataTable`, użyj `ReadXml` metody. Aby odczytać tylko schemat, należy użyć `ReadXmlSchema` metody.  
  
 Zwykle `WriteXml` metoda zapisuje dane tylko dla bieżącej tabeli. `WriteXml` Metoda zapewnia sposób można zapisać tylko dane lub zarówno danych i schemat z `DataTable` do dokumentu XML, podczas gdy `WriteXmlSchema` metoda zapisuje tylko schemat. Aby napisać zarówno danych, jak i schematu, użyj jednego z przeciążeń, które obejmuje `XmlWriteMode` parametru i ustaw dla niego wartość `WriteSchema`.  
  
 Należy pamiętać, że to samo dotyczy dla <xref:System.Data.DataTable.ReadXml%2A> i <xref:System.Data.DataTable.ReadXmlSchema%2A> metod, odpowiednio. Mają być odczytywane dane XML lub schemat i dane do `DataTable`, użyj `ReadXml` metody. Aby odczytać tylko schemat, należy użyć `ReadXmlSchema` metody.  
  
 Zwykle `WriteXml` metody zapisuje dane tylko dla bieżącej tabeli. Można zapisać danych w bieżącej tabeli i wszystkich jego obiektu podrzędnego powiązane tabele, wywołaj metodę z `writeHierarchy` ustawiono parametr `true`.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Zostanie wygenerowany, jeśli typ kolumny w `DataRow` trwa od zapisu lub odczytu implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> i nie implementuje <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.IO.TextWriter writer, System.Data.XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.IO.TextWriter writer, valuetype System.Data.XmlWriteMode mode, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.IO.TextWriter,System.Data.XmlWriteMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As TextWriter, mode As XmlWriteMode, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::IO::TextWriter ^ writer, System::Data::XmlWriteMode mode, bool writeHierarchy);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.IO.TextWriter" /> Używany do zapisywania dokumentu.</param>
        <param name="mode">Jeden z <see cref="T:System.Data.XmlWriteMode" /> wartości.</param>
        <param name="writeHierarchy">Jeśli <see langword="true" />, zapisywanie zawartości w bieżącej tabeli i wszystkich jego elementów podrzędnych. Jeśli <see langword="false" /> (wartość domyślna), zapis danych dla bieżącej tabeli.</param>
        <summary>Zapisuje bieżące dane i opcjonalnie schematu dla <see cref="T:System.Data.DataTable" /> przy użyciu określonego <see cref="T:System.IO.TextWriter" /> i <see cref="T:System.Data.XmlWriteMode" />. Aby napisać schemat, należy ustawić wartość <paramref name="mode" /> parametr <see langword="WriteSchema" />. Aby zapisać dane dla tabeli i wszystkich jego elementów podrzędnych, ustawić <paramref name="writeHierarchy" /> parametr <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> Metoda zapewnia sposób można zapisać tylko dane lub zarówno danych i schemat z <xref:System.Data.DataTable> do dokumentu XML, podczas gdy <xref:System.Data.DataTable.WriteXmlSchema%2A> metoda zapisuje tylko schemat. Aby napisać zarówno danych, jak i schematu, użyj jednego z przeciążeń, które obejmuje <xref:System.Data.XmlWriteMode> parametru i ustaw dla niego wartość `WriteSchema`.  
  
 Należy pamiętać, że to samo dotyczy dla <xref:System.Data.DataTable.ReadXml%2A> i <xref:System.Data.DataTable.ReadXmlSchema%2A> metod, odpowiednio. Mają być odczytywane dane XML lub schemat i dane do `DataTable`, użyj `ReadXml` metody. Aby odczytać tylko schemat, należy użyć `ReadXmlSchema` metody.  
  
 Zwykle `WriteXml` metoda zapisuje dane tylko dla bieżącej tabeli. <xref:System.Data.DataTable.WriteXml%2A> Metoda zapewnia sposób można zapisać tylko dane lub zarówno danych i schemat z <xref:System.Data.DataTable> do dokumentu XML, podczas gdy <xref:System.Data.DataTable.WriteXmlSchema%2A> metoda zapisuje tylko schemat. Aby napisać zarówno danych, jak i schematu, użyj jednego z przeciążeń, które obejmuje <xref:System.Data.XmlWriteMode> parametru i ustaw dla niego wartość `WriteSchema`.  
  
 Należy pamiętać, że to samo dotyczy dla <xref:System.Data.DataTable.ReadXml%2A> i <xref:System.Data.DataTable.ReadXmlSchema%2A> metod, odpowiednio. Mają być odczytywane dane XML lub schemat i dane do `DataTable`, użyj `ReadXml` metody. Aby odczytać tylko schemat, należy użyć `ReadXmlSchema` metody.  
  
 Zwykle `WriteXml` metody zapisuje dane tylko dla bieżącej tabeli. Można zapisać danych w bieżącej tabeli i wszystkich jego obiektu podrzędnego powiązane tabele, wywołaj metodę z `writeHierarchy` ustawiono parametr `true`.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Zostanie wygenerowany, jeśli typ kolumny w `DataRow` trwa od zapisu lub odczytu implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> i nie implementuje <xref:System.Xml.Serialization.IXmlSerializable>.  
  
   
  
## Examples  
 Następującej aplikacji konsoli tworzy dwa <xref:System.Data.DataTable> wystąpienia, dodaje do <xref:System.Data.DataSet>, tworzy <xref:System.Data.DataRelation> dotyczące dwóch tabel, a następnie używa <xref:System.Data.DataTable.WriteXml%2A> metody do zapisania danych zawartych w tabeli nadrzędnej w celu <xref:System.IO.TextWriter>. W przykładzie pokazano zachowanie podczas ustawiania `writeHierarchy` parametru do każdego z jego wartości.  
  
 [!code-csharp[DataWorks DataTable.WriteXmlIO#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlIO/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXmlIO#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlIO/VB/source.vb#1)]  
  
 W przykładzie przedstawiono następujące wyniki w oknie konsoli:  
  
```  
==============================  
Customer table, without hierarchy  
==============================  
<NewDataSet>  
  <xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema  
" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
    <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
      <xs:complexType>  
        <xs:choice minOccurs="0" maxOccurs="unbounded">  
          <xs:element name="Table1">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="ID" type="xs:int" />  
                <xs:element name="Name" type="xs:string" minOccurs="0" />  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
        </xs:choice>  
      </xs:complexType>  
      <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table1" />  
        <xs:field xpath="ID" />  
      </xs:unique>  
    </xs:element>  
  </xs:schema>  
  <Table1>  
    <ID>1</ID>  
    <Name>Mary</Name>  
  </Table1>  
  <Table1>  
    <ID>2</ID>  
    <Name>Andy</Name>  
  </Table1>  
  <Table1>  
    <ID>3</ID>  
    <Name>Peter</Name>  
  </Table1>  
  <Table1>  
    <ID>4</ID>  
    <Name>Russ</Name>  
  </Table1>  
</NewDataSet>  
==============================  
Customer table, with hierarchy  
==============================  
<NewDataSet>  
  <xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema  
" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
    <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
      <xs:complexType>  
        <xs:choice minOccurs="0" maxOccurs="unbounded">  
          <xs:element name="Table1">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="ID" type="xs:int" />  
                <xs:element name="Name" type="xs:string" minOccurs="0" />  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
          <xs:element name="Table2">  
            <xs:complexType>  
              <xs:sequence>  
                <xs:element name="OrderID" type="xs:int" />  
                <xs:element name="CustomerID" type="xs:int" minOccurs="0" />  
                <xs:element name="OrderDate" type="xs:dateTime" minOccurs="0" />  
  
              </xs:sequence>  
            </xs:complexType>  
          </xs:element>  
        </xs:choice>  
      </xs:complexType>  
      <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table1" />  
        <xs:field xpath="ID" />  
      </xs:unique>  
      <xs:unique name="Table2_Constraint1" msdata:ConstraintName="Constraint1" m  
sdata:PrimaryKey="true">  
        <xs:selector xpath=".//Table2" />  
        <xs:field xpath="OrderID" />  
      </xs:unique>  
      <xs:keyref name="CustomerOrder" refer="Constraint1">  
        <xs:selector xpath=".//Table2" />  
        <xs:field xpath="CustomerID" />  
      </xs:keyref>  
    </xs:element>  
  </xs:schema>  
  <Table1>  
    <ID>1</ID>  
    <Name>Mary</Name>  
  </Table1>  
  <Table1>  
    <ID>2</ID>  
    <Name>Andy</Name>  
  </Table1>  
  <Table1>  
    <ID>3</ID>  
    <Name>Peter</Name>  
  </Table1>  
  <Table1>  
    <ID>4</ID>  
    <Name>Russ</Name>  
  </Table1>  
  <Table2>  
    <OrderID>1</OrderID>  
    <CustomerID>1</CustomerID>  
    <OrderDate>2003-12-02T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>2</OrderID>  
    <CustomerID>1</CustomerID>  
    <OrderDate>2004-01-03T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>3</OrderID>  
    <CustomerID>2</CustomerID>  
    <OrderDate>2004-11-13T00:00:00.0000000-08:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>4</OrderID>  
    <CustomerID>3</CustomerID>  
    <OrderDate>2004-05-16T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>5</OrderID>  
    <CustomerID>3</CustomerID>  
    <OrderDate>2004-05-22T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
  <Table2>  
    <OrderID>6</OrderID>  
    <CustomerID>4</CustomerID>  
    <OrderDate>2004-06-15T00:00:00.0000000-07:00</OrderDate>  
  </Table2>  
</NewDataSet>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (string fileName, System.Data.XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(string fileName, valuetype System.Data.XmlWriteMode mode, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.String,System.Data.XmlWriteMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (fileName As String, mode As XmlWriteMode, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::String ^ fileName, System::Data::XmlWriteMode mode, bool writeHierarchy);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="fileName">Nazwa pliku, do którego zostaną zapisane dane.</param>
        <param name="mode">Jeden z <see cref="T:System.Data.XmlWriteMode" /> wartości.</param>
        <param name="writeHierarchy">Jeśli <see langword="true" />, zapisywanie zawartości w bieżącej tabeli i wszystkich jego elementów podrzędnych. Jeśli <see langword="false" /> (wartość domyślna), zapis danych dla bieżącej tabeli.</param>
        <summary>Zapisuje bieżące dane i opcjonalnie schematu dla <see cref="T:System.Data.DataTable" /> przy użyciu określonego pliku i <see cref="T:System.Data.XmlWriteMode" />. Aby napisać schemat, należy ustawić wartość <paramref name="mode" /> parametr <see langword="WriteSchema" />. Aby zapisać dane dla tabeli i wszystkich jego elementów podrzędnych, ustawić <paramref name="writeHierarchy" /> parametr <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> Metoda zapewnia sposób można zapisać tylko dane lub zarówno danych i schemat z <xref:System.Data.DataTable> do dokumentu XML, podczas gdy <xref:System.Data.DataTable.WriteXmlSchema%2A> metoda zapisuje tylko schemat. Aby napisać zarówno danych, jak i schematu, użyj jednego z przeciążeń, które obejmują <xref:System.Data.XmlWriteMode> parametru i ustaw dla niego wartość `WriteSchema`.  
  
 Należy pamiętać, że to samo dotyczy dla <xref:System.Data.DataTable.ReadXml%2A> i <xref:System.Data.DataTable.ReadXmlSchema%2A> metod, odpowiednio. Mają być odczytywane dane XML lub schemat i dane do `DataTable`, użyj `ReadXml` metody. Aby odczytać tylko schemat, należy użyć `ReadXmlSchema` metody.  
  
 Zwykle `WriteXml` metoda zapisuje dane tylko dla bieżącej tabeli. Jeśli chcesz zapisać dane w bieżącej tabeli i wszystkich schematu, <xref:System.Data.DataTable.WriteXml%2A> metoda zapewnia sposób można zapisać tylko dane lub zarówno danych i schemat z <xref:System.Data.DataTable> w dokumencie XML natomiast <xref:System.Data.DataTable.WriteXmlSchema%2A> metoda zapisuje tylko schemat. Aby napisać zarówno danych, jak i schematu, użyj jednego z przeciążeń, które obejmują <xref:System.Data.XmlWriteMode> parametru i ustaw dla niego wartość `WriteSchema`.  
  
 Należy pamiętać, że to samo dotyczy dla <xref:System.Data.DataTable.ReadXml%2A> i <xref:System.Data.DataTable.ReadXmlSchema%2A> metod, odpowiednio. Mają być odczytywane dane XML lub schemat i dane do `DataTable`, użyj `ReadXml` metody. Aby odczytać tylko schemat, należy użyć `ReadXmlSchema` metody.  
  
 Zwykle `WriteXml` metody zapisuje dane tylko dla bieżącej tabeli. Można zapisać danych do bieżącej tabeli i wszystkie podrzędne, powiązane tabele, wywołaj metodę z `writeHierarchy` ustawiono parametr `true`.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Zostanie wygenerowany, jeśli typ kolumny w `DataRow` trwa od zapisu lub odczytu implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> i nie implementuje <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXml">
      <MemberSignature Language="C#" Value="public void WriteXml (System.Xml.XmlWriter writer, System.Data.XmlWriteMode mode, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXml(class System.Xml.XmlWriter writer, valuetype System.Data.XmlWriteMode mode, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXml(System.Xml.XmlWriter,System.Data.XmlWriteMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXml (writer As XmlWriter, mode As XmlWriteMode, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXml(System::Xml::XmlWriter ^ writer, System::Data::XmlWriteMode mode, bool writeHierarchy);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="mode" Type="System.Data.XmlWriteMode" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.Xml.XmlWriter" /> Używany do zapisywania dokumentu.</param>
        <param name="mode">Jeden z <see cref="T:System.Data.XmlWriteMode" /> wartości.</param>
        <param name="writeHierarchy">Jeśli <see langword="true" />, zapisywanie zawartości w bieżącej tabeli i wszystkich jego elementów podrzędnych. Jeśli <see langword="false" /> (wartość domyślna), zapis danych dla bieżącej tabeli.</param>
        <summary>Zapisuje bieżące dane i opcjonalnie schematu dla <see cref="T:System.Data.DataTable" /> przy użyciu określonego <see cref="T:System.Xml.XmlWriter" /> i <see cref="T:System.Data.XmlWriteMode" />. Aby napisać schemat, należy ustawić wartość <paramref name="mode" /> parametr <see langword="WriteSchema" />. Aby zapisać dane dla tabeli i wszystkich jego elementów podrzędnych, ustawić <paramref name="writeHierarchy" /> parametr <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.DataTable.WriteXml%2A> Metoda zapewnia sposób można zapisać tylko dane lub zarówno danych i schemat z <xref:System.Data.DataTable> do dokumentu XML, podczas gdy <xref:System.Data.DataTable.WriteXmlSchema%2A> metoda zapisuje tylko schemat. Aby napisać zarówno danych, jak i schematu, użyj jednego z przeciążeń, które obejmują <xref:System.Data.XmlWriteMode> parametru i ustaw dla niego wartość `WriteSchema`.  
  
 Należy pamiętać, że to samo dotyczy dla <xref:System.Data.DataTable.ReadXml%2A> i <xref:System.Data.DataTable.ReadXmlSchema%2A> metod, odpowiednio. Mają być odczytywane dane XML lub schemat i dane do `DataTable`, użyj `ReadXml` metody. Aby odczytać tylko schemat, należy użyć `ReadXmlSchema` metody.  
  
 Zwykle `WriteXml` metody zapisuje dane tylko dla bieżącej tabeli. Można zapisać danych do bieżącej tabeli i jego całą podrzędne, powiązane tabele, wywołaj metodę z `writeHierarchy` ustawiono parametr `true`.  
  
> [!NOTE]
>  <xref:System.InvalidOperationException> Zostanie wygenerowany, jeśli typ kolumny w `DataRow` trwa od zapisu lub odczytu implementuje <xref:System.Dynamic.IDynamicMetaObjectProvider> i nie implementuje <xref:System.Xml.Serialization.IXmlSerializable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteXmlSchema">
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapisuje bieżący struktury danych <see cref="T:System.Data.DataTable" /> jako schematu XML.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Data.DataTable.WriteXmlSchema%2A> metodę, aby zapisać schematu <xref:System.Data.DataTable> do dokumentu XML. Schemat zawiera definicji tabeli, relacji i ograniczenia.  
  
 Schemat XML jest zapisywany przy użyciu standardu XSD.  
  
 Aby zapisać dane dokumentu XML, użyj <xref:System.Data.DataTable.WriteXml%2A> metody.  
  
   
  
## Examples  
 Następującej aplikacji konsoli tworzy dwa <xref:System.Data.DataTable> wystąpienia, dodaje do <xref:System.Data.DataSet>, tworzy <xref:System.Data.DataRelation> dotyczące dwóch tabel, a następnie używa <xref:System.Data.DataTable.WriteXmlSchema%2A> metody do zapisania danych zawartych w tabeli nadrzędnej w celu <xref:System.IO.TextWriter>. W przykładzie pokazano zachowanie podczas ustawiania `writeHierarchy` parametru do każdego z jego wartości.  
  
> [!NOTE]
>  W tym przykładzie pokazano, jak używać jednej z zastąpionej wersji `WriteXmlSchema` dla inne przykłady, które mogą być dostępne, zobacz Tematy poszczególnych przeciążenia.  
  
 [!code-csharp[DataWorks DataTable.WriteXmlSchemaOverload#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlSchemaOverload/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXmlSchemaOverload#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlSchemaOverload/VB/source.vb#1)]  
  
 W przykładzie przedstawiono następujące wyniki w oknie konsoli:  
  
```  
==============================  
Customer table, without hierarchy  
==============================  
<?xml version="1.0" encoding="utf-16"?>  
<xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema"  
xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Ta  
ble1">  
    <xs:complexType>  
      <xs:choice minOccurs="0" maxOccurs="unbounded">  
        <xs:element name="Table1">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="ID" type="xs:int" />  
              <xs:element name="Name" type="xs:string" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
      </xs:choice>  
    </xs:complexType>  
    <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table1" />  
      <xs:field xpath="ID" />  
    </xs:unique>  
  </xs:element>  
</xs:schema>  
==============================  
Customer table, with hierarchy  
==============================  
<?xml version="1.0" encoding="utf-16"?>  
<xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema"  
xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
    <xs:complexType>  
      <xs:choice minOccurs="0" maxOccurs="unbounded">  
        <xs:element name="Table1">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="ID" type="xs:int" />  
              <xs:element name="Name" type="xs:string" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
        <xs:element name="Table2">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="OrderID" type="xs:int" />  
              <xs:element name="CustomerID" type="xs:int" minOccurs="0" />  
              <xs:element name="OrderDate" type="xs:dateTime" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
      </xs:choice>  
    </xs:complexType>  
    <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table1" />  
      <xs:field xpath="ID" />  
    </xs:unique>  
    <xs:unique name="Table2_Constraint1" msdata:ConstraintName="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table2" />  
      <xs:field xpath="OrderID" />  
    </xs:unique>  
    <xs:keyref name="CustomerOrder" refer="Constraint1">  
      <xs:selector xpath=".//Table2" />  
      <xs:field xpath="CustomerID" />  
    </xs:keyref>  
  </xs:element>  
</xs:schema>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::Stream ^ stream);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Strumień, do której zostanie zapisany schemat XML.</param>
        <summary>Zapisuje bieżący struktury danych <see cref="T:System.Data.DataTable" /> jako schematu XML do określonego strumienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Data.DataTable.WriteXmlSchema%2A> metodę, aby zapisać schematu <xref:System.Data.DataTable> do dokumentu XML. Schemat zawiera definicji tabeli, relacji i ograniczenia.  
  
 Schemat XML jest zapisywany przy użyciu standardu XSD.  
  
 Aby zapisać dane dokumentu XML, użyj <xref:System.Data.DataTable.WriteXml%2A> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::TextWriter ^ writer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.IO.TextWriter" /> z jakim zostanie zapisane.</param>
        <summary>Zapisuje bieżący struktury danych <see cref="T:System.Data.DataTable" /> jako schematu XML przy użyciu określonego <see cref="T:System.IO.TextWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Data.DataTable.WriteXmlSchema%2A> metodę, aby zapisać schematu <xref:System.Data.DataTable> do dokumentu XML. Schemat zawiera definicji tabeli, relacji i ograniczenia.  
  
 Schemat XML jest zapisywany przy użyciu standardu XSD.  
  
 Aby zapisać dane dokumentu XML, użyj <xref:System.Data.DataTable.WriteXml%2A> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::String ^ fileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Nazwa pliku do użycia.</param>
        <summary>Zapisuje bieżący struktury danych <see cref="T:System.Data.DataTable" /> jako schematu XML do określonego pliku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Data.DataTable.WriteXmlSchema%2A> metodę, aby zapisać schematu <xref:System.Data.DataTable> do dokumentu XML. Schemat zawiera definicji tabeli, relacji i ograniczenia.  
  
 Schemat XML jest zapisywany przy użyciu standardu XSD.  
  
 Aby zapisać dane dokumentu XML, użyj <xref:System.Data.DataTable.WriteXml%2A> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::Xml::XmlWriter ^ writer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.Xml.XmlWriter" /> Do użycia.</param>
        <summary>Zapisuje bieżący struktury danych <see cref="T:System.Data.DataTable" /> jako schematu XML przy użyciu określonego <see cref="T:System.Xml.XmlWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Data.DataTable.WriteXmlSchema%2A> metodę, aby zapisać schematu <xref:System.Data.DataTable> do dokumentu XML. Schemat zawiera definicji tabeli, relacji i ograniczenia.  
  
 Schemat XML jest zapisywany przy użyciu standardu XSD.  
  
 Aby zapisać dane dokumentu XML, użyj <xref:System.Data.DataTable.WriteXml%2A> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.Stream stream, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.Stream stream, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.IO.Stream,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::Stream ^ stream, bool writeHierarchy);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">Strumień, do której zostanie zapisany schemat XML.</param>
        <param name="writeHierarchy">Jeśli <see langword="true" />, zapisać schematu bieżącej tabeli i wszystkich jego elementów podrzędnych. Jeśli <see langword="false" /> (wartość domyślna), zapisać schematu dla bieżącej tabeli.</param>
        <summary>Zapisuje bieżący struktury danych <see cref="T:System.Data.DataTable" /> jako schematu XML do określonego strumienia. Aby zapisać schematu dla tabeli i wszystkich jego elementów podrzędnych, ustawić <paramref name="writeHierarchy" /> parametr <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Data.DataTable.WriteXmlSchema%2A> metodę, aby zapisać schematu <xref:System.Data.DataTable> do dokumentu XML. Schemat zawiera definicji tabeli, relacji i ograniczenia.  
  
 Schemat XML jest zapisywany przy użyciu standardu XSD.  
  
 Aby zapisać dane dokumentu XML, użyj <xref:System.Data.DataTable.WriteXml%2A> metody.  
  
 Zwykle `WriteXmlSchema` metoda zapisuje schemat tylko dla bieżącej tabeli. Aby napisać schematu dla bieżącej tabeli i jego całą tabele podrzędne, powiązane, należy wywołać metodę z `writeHierarchy` ustawiono parametr `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.IO.TextWriter writer, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.IO.TextWriter writer, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.IO.TextWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As TextWriter, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::IO::TextWriter ^ writer, bool writeHierarchy);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.IO.TextWriter" /> z jakim zostanie zapisane.</param>
        <param name="writeHierarchy">Jeśli <see langword="true" />, zapisać schematu bieżącej tabeli i wszystkich jego elementów podrzędnych. Jeśli <see langword="false" /> (wartość domyślna), zapisać schematu dla bieżącej tabeli.</param>
        <summary>Zapisuje bieżący struktury danych <see cref="T:System.Data.DataTable" /> jako schematu XML przy użyciu określonego <see cref="T:System.IO.TextWriter" />. Aby zapisać schematu dla tabeli i wszystkich jego elementów podrzędnych, ustawić <paramref name="writeHierarchy" /> parametr <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Data.DataTable.WriteXmlSchema%2A> metodę, aby zapisać schematu <xref:System.Data.DataTable> do dokumentu XML. Schemat zawiera definicji tabeli, relacji i ograniczenia.  
  
 Schemat XML jest zapisywany przy użyciu standardu XSD.  
  
 Aby zapisać dane dokumentu XML, użyj <xref:System.Data.DataTable.WriteXml%2A> metody.  
  
 Zwykle `WriteXmlSchema` metoda zapisuje schemat tylko dla bieżącej tabeli. Aby napisać schematu dla bieżącej tabeli i jego całą tabele podrzędne, powiązane, należy wywołać metodę z `writeHierarchy` ustawiono parametr `true`.  
  
   
  
## Examples  
 Następującej aplikacji konsoli tworzy dwa <xref:System.Data.DataTable> wystąpienia, dodaje do <xref:System.Data.DataSet>, tworzy <xref:System.Data.DataRelation> dotyczące dwóch tabel, a następnie używa <xref:System.Data.DataTable.WriteXmlSchema%2A> metody do zapisania danych zawartych w tabeli nadrzędnej w celu <xref:System.IO.TextWriter>. W przykładzie pokazano zachowanie podczas ustawiania `writeHierarchy` parametru do każdego z jego wartości.  
  
 [!code-csharp[DataWorks DataTable.WriteXmlSchema#1](~/samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlSchema/CS/source.cs#1)]
 [!code-vb[DataWorks DataTable.WriteXmlSchema#1](~/samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataTable.WriteXmlSchema/VB/source.vb#1)]  
  
 W przykładzie przedstawiono następujące wyniki w oknie konsoli:  
  
```  
==============================  
Customer table, without hierarchy  
==============================  
<?xml version="1.0" encoding="utf-16"?>  
<xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema"  
xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Ta  
ble1">  
    <xs:complexType>  
      <xs:choice minOccurs="0" maxOccurs="unbounded">  
        <xs:element name="Table1">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="ID" type="xs:int" />  
              <xs:element name="Name" type="xs:string" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
      </xs:choice>  
    </xs:complexType>  
    <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table1" />  
      <xs:field xpath="ID" />  
    </xs:unique>  
  </xs:element>  
</xs:schema>  
==============================  
Customer table, with hierarchy  
==============================  
<?xml version="1.0" encoding="utf-16"?>  
<xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema"  
xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">  
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Table1">  
    <xs:complexType>  
      <xs:choice minOccurs="0" maxOccurs="unbounded">  
        <xs:element name="Table1">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="ID" type="xs:int" />  
              <xs:element name="Name" type="xs:string" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
        <xs:element name="Table2">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="OrderID" type="xs:int" />  
              <xs:element name="CustomerID" type="xs:int" minOccurs="0" />  
              <xs:element name="OrderDate" type="xs:dateTime" minOccurs="0" />  
            </xs:sequence>  
          </xs:complexType>  
        </xs:element>  
      </xs:choice>  
    </xs:complexType>  
    <xs:unique name="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table1" />  
      <xs:field xpath="ID" />  
    </xs:unique>  
    <xs:unique name="Table2_Constraint1" msdata:ConstraintName="Constraint1" msdata:PrimaryKey="true">  
      <xs:selector xpath=".//Table2" />  
      <xs:field xpath="OrderID" />  
    </xs:unique>  
    <xs:keyref name="CustomerOrder" refer="Constraint1">  
      <xs:selector xpath=".//Table2" />  
      <xs:field xpath="CustomerID" />  
    </xs:keyref>  
  </xs:element>  
</xs:schema>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (string fileName, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(string fileName, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (fileName As String, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::String ^ fileName, bool writeHierarchy);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="fileName">Nazwa pliku do użycia.</param>
        <param name="writeHierarchy">Jeśli <see langword="true" />, zapisać schematu bieżącej tabeli i wszystkich jego elementów podrzędnych. Jeśli <see langword="false" /> (wartość domyślna), zapisać schematu dla bieżącej tabeli.</param>
        <summary>Zapisuje bieżący struktury danych <see cref="T:System.Data.DataTable" /> jako schematu XML do określonego pliku. Aby zapisać schematu dla tabeli i wszystkich jego elementów podrzędnych, ustawić <paramref name="writeHierarchy" /> parametr <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Data.DataTable.WriteXmlSchema%2A> metodę, aby zapisać schematu <xref:System.Data.DataTable> do dokumentu XML. Schemat zawiera definicji tabeli, relacji i ograniczenia.  
  
 Schemat XML jest zapisywany przy użyciu standardu XSD.  
  
 Aby zapisać dane dokumentu XML, użyj <xref:System.Data.DataTable.WriteXml%2A> metody.  
  
 Zwykle `WriteXmlSchema` metoda zapisuje schemat tylko dla bieżącej tabeli. Aby napisać schematu dla bieżącej tabeli i jego całą tabele podrzędne, powiązane, należy wywołać metodę z `writeHierarchy` ustawiono parametr `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteXmlSchema">
      <MemberSignature Language="C#" Value="public void WriteXmlSchema (System.Xml.XmlWriter writer, bool writeHierarchy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteXmlSchema(class System.Xml.XmlWriter writer, bool writeHierarchy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.DataTable.WriteXmlSchema(System.Xml.XmlWriter,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteXmlSchema (writer As XmlWriter, writeHierarchy As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteXmlSchema(System::Xml::XmlWriter ^ writer, bool writeHierarchy);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Data.Common</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
        <Parameter Name="writeHierarchy" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.Xml.XmlWriter" /> Używany do zapisywania dokumentu.</param>
        <param name="writeHierarchy">Jeśli <see langword="true" />, zapisać schematu bieżącej tabeli i wszystkich jego elementów podrzędnych. Jeśli <see langword="false" /> (wartość domyślna), zapisać schematu dla bieżącej tabeli.</param>
        <summary>Zapisuje bieżący struktury danych <see cref="T:System.Data.DataTable" /> jako schematu XML przy użyciu określonego <see cref="T:System.Xml.XmlWriter" />. Aby zapisać schematu dla tabeli i wszystkich jego elementów podrzędnych, ustawić <paramref name="writeHierarchy" /> parametr <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Data.DataTable.WriteXmlSchema%2A> metodę, aby zapisać schematu <xref:System.Data.DataTable> do dokumentu XML. Schemat zawiera definicji tabeli, relacji i ograniczenia.  
  
 Schemat XML jest zapisywany przy użyciu standardu XSD.  
  
 Aby zapisać dane dokumentu XML, użyj <xref:System.Data.DataTable.WriteXml%2A> metody.  
  
 Zwykle `WriteXmlSchema` metoda zapisuje schemat tylko dla bieżącej tabeli. Aby napisać schematu dla bieżącej tabeli i jego całą tabele podrzędne, powiązane, należy wywołać metodę z `writeHierarchy` ustawiono parametr `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
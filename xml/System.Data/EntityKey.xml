<Type Name="EntityKey" FullName="System.Data.EntityKey">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a6911c2007bc269d038d952c3f18397a65154c85" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30449292" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class EntityKey : IEquatable&lt;System.Data.EntityKey&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit EntityKey extends System.Object implements class System.IEquatable`1&lt;class System.Data.EntityKey&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Data.EntityKey" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class EntityKey&#xA;Implements IEquatable(Of EntityKey)" />
  <TypeSignature Language="C++ CLI" Value="public ref class EntityKey sealed : IEquatable&lt;System::Data::EntityKey ^&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Data.Entity</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Data.EntityKey&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("{ConcatKeyValue()}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.Serialization.DataContract(IsReference=true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Udostępnia trwałe odwołanie do obiektu, który jest wystąpieniem typu jednostki.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.EntityKey> Obiekty są niezmienne; oznacza to, że po one nie można ich modyfikować.  
  
 Aby uzyskać więcej informacji, zobacz [Praca z kluczy jednostek](http://msdn.microsoft.com/library/fe3f4206-d277-43a1-a72f-4e86fdf12b9f).  
  
   
  
## Examples  
 Te przykłady są oparte na [modelu sprzedaży AdventureWorks](http://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). W przykładach pokazano sposób tworzenia i używania <xref:System.Data.EntityKey>.  
  
 [!code-csharp[DP ObjectServices Concepts#EntityKeyClass_TryGetObjectByKey](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#entitykeyclass_trygetobjectbykey)]
 [!code-vb[DP ObjectServices Concepts#EntityKeyClass_TryGetObjectByKey](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#entitykeyclass_trygetobjectbykey)]  
  
 [!code-csharp[DP ObjectServices Concepts#AddObjectUsingKey](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#addobjectusingkey)]
 [!code-vb[DP ObjectServices Concepts#AddObjectUsingKey](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#addobjectusingkey)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Data.EntityKey" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EntityKey ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityKey.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EntityKey();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Data.EntityKey" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EntityKey (string qualifiedEntitySetName, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt; entityKeyValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string qualifiedEntitySetName, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt; entityKeyValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityKey.#ctor(System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Object}})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (qualifiedEntitySetName As String, entityKeyValues As IEnumerable(Of KeyValuePair(Of String, Object)))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EntityKey(System::String ^ qualifiedEntitySetName, System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt; ^ entityKeyValues);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="qualifiedEntitySetName" Type="System.String" />
        <Parameter Name="entityKeyValues" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="qualifiedEntitySetName">A <see cref="T:System.String" /> to nazwa zestawu jednostek kwalifikowana przez nazwę kontenera jednostek.</param>
        <param name="entityKeyValues">Element ogólny <see cref="T:System.Collections.Generic.KeyValuePair" /> kolekcji.  
  
 Każdej pary klucz wartość zawiera nazwę właściwości jako klucz i wartość tej właściwości, jako wartość. Powinien istnieć jedna para dla każdej właściwości, która jest częścią <see cref="T:System.Data.EntityKey" />. Kolejność pary klucz wartość nie jest ważna, ale każda właściwość klucza mają zostać uwzględnione. Nazwy właściwości to proste nazwy, które nie jest kwalifikowany za pomocą nazwy typu jednostki lub nazwy schematu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Data.EntityKey" /> z nazwy zestawu jednostek i rodzajowy <see cref="T:System.Collections.Generic.KeyValuePair" /> kolekcji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Ten przykład jest oparty na [modelu sprzedaży AdventureWorks](http://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). W przykładzie pokazano sposób tworzenia i używania <xref:System.Data.EntityKey>.  
  
 [!code-csharp[DP ObjectServices Concepts#AddObjectUsingKey](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#addobjectusingkey)]
 [!code-vb[DP ObjectServices Concepts#AddObjectUsingKey](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#addobjectusingkey)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EntityKey (string qualifiedEntitySetName, System.Collections.Generic.IEnumerable&lt;System.Data.EntityKeyMember&gt; entityKeyValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string qualifiedEntitySetName, class System.Collections.Generic.IEnumerable`1&lt;class System.Data.EntityKeyMember&gt; entityKeyValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityKey.#ctor(System.String,System.Collections.Generic.IEnumerable{System.Data.EntityKeyMember})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (qualifiedEntitySetName As String, entityKeyValues As IEnumerable(Of EntityKeyMember))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EntityKey(System::String ^ qualifiedEntitySetName, System::Collections::Generic::IEnumerable&lt;System::Data::EntityKeyMember ^&gt; ^ entityKeyValues);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="qualifiedEntitySetName" Type="System.String" />
        <Parameter Name="entityKeyValues" Type="System.Collections.Generic.IEnumerable&lt;System.Data.EntityKeyMember&gt;" />
      </Parameters>
      <Docs>
        <param name="qualifiedEntitySetName">A <see cref="T:System.String" /> to nazwa zestawu jednostek kwalifikowana przez nazwę kontenera jednostek.</param>
        <param name="entityKeyValues">
          <see cref="T:System.Collections.Generic.IEnumerable`1" /> Kolekcja <see cref="T:System.Data.EntityKeyMember" /> obiektów, z którą ma zostać zainicjować klucza.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Data.EntityKey" /> klasy o nazwie zestawu jednostek i <see cref="T:System.Collections.Generic.IEnumerable`1" /> Kolekcja <see cref="T:System.Data.EntityKeyMember" /> obiektów.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EntityKey (string qualifiedEntitySetName, string keyName, object keyValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string qualifiedEntitySetName, string keyName, object keyValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityKey.#ctor(System.String,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (qualifiedEntitySetName As String, keyName As String, keyValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EntityKey(System::String ^ qualifiedEntitySetName, System::String ^ keyName, System::Object ^ keyValue);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="qualifiedEntitySetName" Type="System.String" />
        <Parameter Name="keyName" Type="System.String" />
        <Parameter Name="keyValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="qualifiedEntitySetName">A <see cref="T:System.String" /> to nazwa zestawu jednostek kwalifikowana przez nazwę kontenera jednostek.</param>
        <param name="keyName">A <see cref="T:System.String" /> czyli nazwę klucza.</param>
        <param name="keyValue">
          <see cref="T:System.Object" /> Czyli wartość klucza.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Data.EntityKey" /> z nazwy zestawu jednostek i jednostki określone pary kluczy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Ten przykład jest oparty na [modelu sprzedaży AdventureWorks](http://msdn.microsoft.com/library/f16cd988-673f-4376-b034-129ca93c7832). W przykładzie pokazano sposób tworzenia i używania <xref:System.Data.EntityKey>.  
  
 [!code-csharp[DP ObjectServices Concepts#AddObjectUsingKey](~/samples/snippets/csharp/VS_Snippets_Data/DP ObjectServices Concepts/CS/Source.cs#addobjectusingkey)]
 [!code-vb[DP ObjectServices Concepts#AddObjectUsingKey](~/samples/snippets/visualbasic/VS_Snippets_Data/DP ObjectServices Concepts/VB/Source.vb#addobjectusingkey)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EntityContainerName">
      <MemberSignature Language="C#" Value="public string EntityContainerName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EntityContainerName" />
      <MemberSignature Language="DocId" Value="P:System.Data.EntityKey.EntityContainerName" />
      <MemberSignature Language="VB.NET" Value="Public Property EntityContainerName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ EntityContainerName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.Serialization.DataMember</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę kontenera jednostek.</summary>
        <value>A <see cref="T:System.String" /> wartość, która jest nazwa kontenera jednostek dla obiekt, do którego <see cref="T:System.Data.EntityKey" /> należy.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EntityKeyValues">
      <MemberSignature Language="C#" Value="public System.Data.EntityKeyMember[] EntityKeyValues { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.EntityKeyMember[] EntityKeyValues" />
      <MemberSignature Language="DocId" Value="P:System.Data.EntityKey.EntityKeyValues" />
      <MemberSignature Language="VB.NET" Value="Public Property EntityKeyValues As EntityKeyMember()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Data::EntityKeyMember ^&gt; ^ EntityKeyValues { cli::array &lt;System::Data::EntityKeyMember ^&gt; ^ get(); void set(cli::array &lt;System::Data::EntityKeyMember ^&gt; ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.Serialization.DataMember</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.EntityKeyMember[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartości klucza skojarzony z tym <see cref="T:System.Data.EntityKey" />.</summary>
        <value>A <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> wartości kluczy dla tego <see cref="T:System.Data.EntityKey" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.EntityKey> Klasa zawiera kopię wartości, które tworzą logicznej klucz, który został określony dla tego typu jednostki.  
  
 Elementy członkowskie <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> mieć nazwę właściwości i wartość w <xref:System.Collections.Generic.KeyValuePair%602>, gdy klucz jest nazwą właściwości i wartość jest wartością rzeczywistą tej właściwości w obiekcie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EntityNotValidKey">
      <MemberSignature Language="C#" Value="public static readonly System.Data.EntityKey EntityNotValidKey;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Data.EntityKey EntityNotValidKey" />
      <MemberSignature Language="DocId" Value="F:System.Data.EntityKey.EntityNotValidKey" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EntityNotValidKey As EntityKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Data::EntityKey ^ EntityNotValidKey;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.EntityKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Prosty <see cref="T:System.Data.EntityKey" /> identyfikowania jednostki, która jest wynikiem nieudanej [TRAKTUJ](~/docs/framework/data/adonet/ef/language-reference/treat-entity-sql.md) operacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Istnieją różne sposoby pobieranie nieprawidłowe jednostki. Najbardziej typowym scenariuszem jest, gdy [!INCLUDE[esql](~/includes/esql-md.md)] zapytanie używa [TRAKTUJ](~/docs/framework/data/adonet/ef/language-reference/treat-entity-sql.md) operatora, aby zinterpretować wystąpienia typu polimorficznych jako określonego typu i danego wystąpienia nie pasuje. ([TRAKTUJ](~/docs/framework/data/adonet/ef/language-reference/treat-entity-sql.md) jest podobny do języka C# `as` operatora). W takim przypadku zapytanie zwraca jednostki, która nie jest prawidłowy, i ma ustawioną wartość klucza jednostki wynikowy jednostki <xref:System.Data.EntityKey.EntityNotValidKey>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EntitySetName">
      <MemberSignature Language="C#" Value="public string EntitySetName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EntitySetName" />
      <MemberSignature Language="DocId" Value="P:System.Data.EntityKey.EntitySetName" />
      <MemberSignature Language="VB.NET" Value="Public Property EntitySetName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ EntitySetName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.Serialization.DataMember</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę zestawu jednostek.</summary>
        <value>A <see cref="T:System.String" /> wartość, która jest nazwą jednostki ustawioną dla jednostki którego <see cref="T:System.Data.EntityKey" /> należy.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca wartość wskazującą, czy to wystąpienie jest równe podanemu obiektowi.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Data.EntityKey other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Data.EntityKey other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityKey.Equals(System.Data.EntityKey)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As EntityKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Data::EntityKey ^ other);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Data.EntityKey" />
      </Parameters>
      <Docs>
        <param name="other">
          <see cref="T:System.Data.EntityKey" /> Obiekt do porównania z tym wystąpieniem.</param>
        <summary>Zwraca wartość wskazującą, czy to wystąpienie jest równe określonej <see cref="T:System.Data.EntityKey" />.</summary>
        <returns>
          <see langword="true" /> Jeśli to wystąpienie i <paramref name="other" /> mają takie same wartości; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klucze tymczasowe ma semantykę porównania inny niż stały klucze:  
  
-   Klucze tymczasowe używają równości odwołań. Oznacza to, że dwa odwołuje się do dokładnie takie same tymczasowego <xref:System.Data.EntityKey> wystąpienia są takie same, ale żaden inny <xref:System.Data.EntityKey> wystąpienia są takie same.  
  
-   Stałe klucze określenie na podstawie wartości zawartych w niej właściwości klucza równości i <xref:System.Data.Metadata.Edm.EntitySet>. Oznacza to, że masz dwie oddzielne <xref:System.Data.EntityKey> wystąpień, które są równe, jeśli ich zestawów jednostek są takie same i ich wartości klucza są takie same.  
  
 Ponadto klucze tymczasowe nie mają <xref:System.Data.Metadata.Edm.EntitySet> lub wartości klucza, lecz stałe kluczy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityKey.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <see cref="T:System.Object" /> Do porównania z tym wystąpieniem.</param>
        <summary>Zwraca wartość wskazującą, czy to wystąpienie jest równe podanemu obiektowi.</summary>
        <returns>
          <see langword="true" /> Jeśli to wystąpienie i <paramref name="obj" /> mają takie same wartości; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klucze tymczasowe ma semantykę porównania inny niż stały klucze:  
  
-   Klucze tymczasowe używają równości odwołań. Oznacza to, że dwa odwołuje się do dokładnie takie same tymczasowego <xref:System.Data.EntityKey> wystąpienia są takie same, ale żaden inny <xref:System.Data.EntityKey> wystąpienia są takie same.  
  
-   Stałe klucze określenie na podstawie wartości zawartych w niej właściwości klucza równości i <xref:System.Data.Metadata.Edm.EntitySet>. Oznacza to, że masz dwie oddzielne <xref:System.Data.EntityKey> wystąpień, które są równe, jeśli ich <xref:System.Data.Metadata.Edm.EntitySet> obiekty są takie same i ich wartości klucza są takie same.  
  
 Ponadto klucze tymczasowe nie mają <xref:System.Data.Metadata.Edm.EntitySet> lub wartości klucza, lecz stałe kluczy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEntitySet">
      <MemberSignature Language="C#" Value="public System.Data.Metadata.Edm.EntitySet GetEntitySet (System.Data.Metadata.Edm.MetadataWorkspace metadataWorkspace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Metadata.Edm.EntitySet GetEntitySet(class System.Data.Metadata.Edm.MetadataWorkspace metadataWorkspace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityKey.GetEntitySet(System.Data.Metadata.Edm.MetadataWorkspace)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Metadata::Edm::EntitySet ^ GetEntitySet(System::Data::Metadata::Edm::MetadataWorkspace ^ metadataWorkspace);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Metadata.Edm.EntitySet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataWorkspace" Type="System.Data.Metadata.Edm.MetadataWorkspace" />
      </Parameters>
      <Docs>
        <param name="metadataWorkspace">Obszar roboczy metadanych, który zawiera jednostki.</param>
        <summary>Pobiera zestaw jednostek dla tego klucza jednostki z obszaru roboczego metadanych.</summary>
        <returns>
          <see cref="T:System.Data.Metadata.Edm.EntitySet" /> Klucza jednostki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zestaw jednostek jest dostępny na podstawie nazwy kontenera jednostek i nazwę klucza zestawu jednostek.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Nie można zlokalizować zestawu jednostek w obszarze roboczym określonych metadanych.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityKey.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pełni rolę funkcji skrótu dla bieżącego <see cref="T:System.Data.EntityKey" /> obiektu. <see cref="M:System.Data.EntityKey.GetHashCode" /> nadaje się do tworzenia skrótów algorytmów i struktury danych, takich jak tablicy skrótów.</summary>
        <returns>Wartość skrótu dla bieżącego <see cref="T:System.Data.EntityKey" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTemporary">
      <MemberSignature Language="C#" Value="public bool IsTemporary { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTemporary" />
      <MemberSignature Language="DocId" Value="P:System.Data.EntityKey.IsTemporary" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsTemporary As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsTemporary { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Data.EntityKey" /> jest tymczasowe.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Data.EntityKey" /> tymczasowe, a w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po utworzeniu nowego obiektu [!INCLUDE[adonet_ef](~/includes/adonet-ef-md.md)] definiuje klucza tymczasowego i ustawia <xref:System.Data.EntityKey.IsTemporary%2A> właściwości `true`. Podczas wywoływania <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> metody [!INCLUDE[adonet_ef](~/includes/adonet-ef-md.md)] przypisuje stałe klucza i ustawia <xref:System.Data.EntityKey.IsTemporary%2A> właściwości `false`.  
  
> [!NOTE]
>  Klucze tymczasowe są automatycznie utworzone przez platformę; Nie można ich wykonane bezpośrednio przez użytkownika.  
  
 Klucze tymczasowe ma semantykę porównania inny niż stały klucze:  
  
-   Klucze tymczasowe używają równości odwołań. Oznacza to, że dwa odwołuje się do dokładnie takie same tymczasowego <xref:System.Data.EntityKey> wystąpienia są takie same, ale żaden inny <xref:System.Data.EntityKey> wystąpienia są takie same.  
  
-   Stałe klucze określenie na podstawie wartości zawartych w niej właściwości klucza równości i <xref:System.Data.Metadata.Edm.EntitySet>. Oznacza to, że masz dwie oddzielne <xref:System.Data.EntityKey> wystąpień, które są równe, jeśli ich zestawów jednostek są takie same i ich wartości klucza są takie same.  
  
 Ponadto klucze tymczasowe nie mają <xref:System.Data.Metadata.Edm.EntitySet> lub wartości klucza, lecz stałe kluczy.  
  
 Gdy <xref:System.Data.Objects.ObjectStateEntry.AcceptChanges%2A> metoda jest wywoływana z jednostką <xref:System.Data.Objects.ObjectStateEntry> i przejścia jednostki z <xref:System.Data.EntityState.Added> stan <xref:System.Data.EntityState.Unchanged> stanu, [!INCLUDE[adonet_ef](~/includes/adonet-ef-md.md)] automatycznie oblicza nowy klucz stałe dla jednostki i synchronizuje wszystkie tymczasowe odwołania kluczy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NoEntitySetKey">
      <MemberSignature Language="C#" Value="public static readonly System.Data.EntityKey NoEntitySetKey;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Data.EntityKey NoEntitySetKey" />
      <MemberSignature Language="DocId" Value="F:System.Data.EntityKey.NoEntitySetKey" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly NoEntitySetKey As EntityKey " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Data::EntityKey ^ NoEntitySetKey;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.EntityKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pojedyncza <see cref="T:System.Data.EntityKey" /> przez zostanie zidentyfikowana jako jednostka tylko do odczytu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jednostka tylko do odczytu identyfikuje jednostki, która jest prawidłowa w każdym sposób, z tą różnicą, że nie jest skojarzony z zestawu jednostek rzeczywistych. Taka sytuacja może wystąpić w ramach wyniku [!INCLUDE[esql](~/includes/esql-md.md)] zapytanie, które tworzy i zwraca wystąpienie jednostki określone w tekście zapytania (w przeciwieństwie do jednostki, która nie została pobrana z tabeli bazy danych). Nie może zostać utrwalona jednostki, która nie ma zestawu jednostek do bazy danych, dopóki nie jest skojarzony z niektórych zestawu jednostek. W związku z tym materializer obiektu będzie traktować tego typu jednostki tak, jakby <xref:System.Data.Objects.MergeOption.NoTracking> określono opcję scalania, niezależnie od opcji scalania rzeczywista, która została określona. Do obiektu jednostki zostanie utworzony, ale jego tożsamość nie będą rozpoznawane i go nie zostanie dodany do menedżera stanu jako część procesu materialization.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDeserialized">
      <MemberSignature Language="C#" Value="public void OnDeserialized (System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OnDeserialized(valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityKey.OnDeserialized(System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OnDeserialized (context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OnDeserialized(System::Runtime::Serialization::StreamingContext context);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Serialization.OnDeserialized</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="context">Opisuje źródłowa i docelowa danego serializowanym strumieniu i zawiera dodatkowy kontekst zdefiniowane przez obiekt wywołujący.</param>
        <summary>Metoda pomocnika, który służy do deserializacji <see cref="T:System.Data.EntityKey" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.EntityKey.OnDeserialized%2A> jest używany przez usługi obiektu podczas deserializacji <xref:System.Data.EntityKey>. Aby uzyskać więcej informacji, zobacz [serializacji obiektów](http://msdn.microsoft.com/library/06c77f9b-5b2e-4c78-b3e3-8c148ba0ea99).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDeserializing">
      <MemberSignature Language="C#" Value="public void OnDeserializing (System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OnDeserializing(valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityKey.OnDeserializing(System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OnDeserializing (context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OnDeserializing(System::Runtime::Serialization::StreamingContext context);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.Serialization.OnDeserializing</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="context">Opisuje źródłowa i docelowa danego serializowanym strumieniu i zawiera dodatkowy kontekst zdefiniowane przez obiekt wywołujący.</param>
        <summary>Metoda pomocnika, który służy do deserializacji <see cref="T:System.Data.EntityKey" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Data.EntityKey.OnDeserializing%2A> jest używany przez usługi obiektu podczas deserializacji <xref:System.Data.EntityKey>. Aby uzyskać więcej informacji, zobacz [serializacji obiektów](http://msdn.microsoft.com/library/06c77f9b-5b2e-4c78-b3e3-8c148ba0ea99).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Data.EntityKey key1, System.Data.EntityKey key2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Data.EntityKey key1, class System.Data.EntityKey key2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityKey.op_Equality(System.Data.EntityKey,System.Data.EntityKey)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (key1 As EntityKey, key2 As EntityKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Data::EntityKey ^ key1, System::Data::EntityKey ^ key2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key1" Type="System.Data.EntityKey" />
        <Parameter Name="key2" Type="System.Data.EntityKey" />
      </Parameters>
      <Docs>
        <param name="key1">A <see cref="T:System.Data.EntityKey" /> do porównania.</param>
        <param name="key2">A <see cref="T:System.Data.EntityKey" /> do porównania.</param>
        <summary>Porównuje dwa <see cref="T:System.Data.EntityKey" /> obiektów.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="key1" /> i <paramref name="key2" /> wartości są równe; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klucze tymczasowe ma semantykę porównania inny niż stały klucze:  
  
-   Klucze tymczasowe używają równości odwołań. Oznacza to, że dwa odwołuje się do dokładnie takie same tymczasowego <xref:System.Data.EntityKey> wystąpienia są takie same, ale żaden inny <xref:System.Data.EntityKey> wystąpienia są takie same.  
  
-   Stałe klucze określenie na podstawie wartości zawartych w niej właściwości klucza równości i <xref:System.Data.Metadata.Edm.EntitySet>. Oznacza to, że masz dwie oddzielne <xref:System.Data.EntityKey> wystąpień, które są równe, jeśli ich zestawów jednostek są takie same i ich wartości klucza są takie same.  
  
 Ponadto klucze tymczasowe nie mają <xref:System.Data.Metadata.Edm.EntitySet> lub wartości klucza, lecz stałe kluczy.  
  
 Metoda równoważne tego operatora jest <xref:System.Data.EntityKey.Equals%28System.Data.EntityKey%29?displayProperty=nameWithType> </format> </remarks> </Docs> 
     </Member> 
     <Member MemberName="op_Inequality"> <MemberSignature Language="C#" Value="public static bool op_Inequality (System.Data.EntityKey key1, System.Data.EntityKey key2);" /> <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Data.EntityKey key1, class System.Data.EntityKey key2) cil managed" /> <MemberSignature Language="DocId" Value="M:System.Data.EntityKey.op_Inequality(System.Data.EntityKey,System.Data.EntityKey)" /> <MemberType> Metoda</MemberType> <AssemblyInfo> <AssemblyName>System.Data.Entity</AssemblyName> <AssemblyVersion>4.0.0.0</AssemblyVersion> </AssemblyInfo> <ReturnValue> <ReturnType>System.Boolean</ReturnType> </ReturnValue> <Parameters> <Parameter Name="key1" Type="System.Data.EntityKey" /> <Parameter Name="key2" Type="System.Data.EntityKey" /> </Parameters> <Docs> <param name="key1">A <see cref="T:System.Data.EntityKey" /> do porównania.</param>
        <param name="key2">A <see cref="T:System.Data.EntityKey" /> do porównania.</param>
        <summary>Porównuje dwa <see cref="T:System.Data.EntityKey" /> obiektów.</summary>
        <returns> <see langword="true" /> Jeśli <paramref name="key1" /> i <paramref name="key2" /> wartości nie są równe; w przeciwnym razie <see langword="false" />.</returns>
        <remarks> <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klucze tymczasowe ma semantykę porównania inny niż stały klucze:  
  
-   Klucze tymczasowe używają równości odwołań. Oznacza to, że dwa odwołuje się do dokładnie takie same tymczasowego <xref:System.Data.EntityKey> wystąpienia są takie same, ale żaden inny <xref:System.Data.EntityKey> wystąpienia są takie same.  
  
-   Stałe klucze określenie na podstawie wartości zawartych w niej właściwości klucza równości i <xref:System.Data.Metadata.Edm.EntitySet>. Oznacza to, że masz dwie oddzielne <xref:System.Data.EntityKey> wystąpień, które są równe, jeśli ich zestawów jednostek są takie same i ich wartości klucza są takie same.  
  
 Ponadto klucze tymczasowe nie mają <xref:System.Data.Metadata.Edm.EntitySet> lub wartości klucza, lecz regularne kluczy.  
  
 Metoda równoważne tego operatora jest <xref:System.Data.EntityKey.Equals%28System.Data.EntityKey%29?displayProperty=nameWithType>.]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Data.EntityKey key1, System.Data.EntityKey key2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Data.EntityKey key1, class System.Data.EntityKey key2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.EntityKey.op_Inequality(System.Data.EntityKey,System.Data.EntityKey)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (key1 As EntityKey, key2 As EntityKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Data::EntityKey ^ key1, System::Data::EntityKey ^ key2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key1" Type="System.Data.EntityKey" />
        <Parameter Name="key2" Type="System.Data.EntityKey" />
      </Parameters>
      <Docs>
        <param name="key1">A <see cref="T:System.Data.EntityKey" /> do porównania.</param>
        <param name="key2">A <see cref="T:System.Data.EntityKey" /> do porównania.</param>
        <summary>Porównuje dwa <see cref="T:System.Data.EntityKey" /> obiektów.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="key1" /> i <paramref name="key2" /> wartości nie są równe; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klucze tymczasowe ma semantykę porównania inny niż stały klucze:  
  
-   Klucze tymczasowe używają równości odwołań. Oznacza to, że dwa odwołuje się do dokładnie takie same tymczasowego <xref:System.Data.EntityKey> wystąpienia są takie same, ale żaden inny <xref:System.Data.EntityKey> wystąpienia są takie same.  
  
-   Stałe klucze określenie na podstawie wartości zawartych w niej właściwości klucza równości i <xref:System.Data.Metadata.Edm.EntitySet>. Oznacza to, że masz dwie oddzielne <xref:System.Data.EntityKey> wystąpień, które są równe, jeśli ich zestawów jednostek są takie same i ich wartości klucza są takie same.  
  
 Ponadto klucze tymczasowe nie mają <xref:System.Data.Metadata.Edm.EntitySet> lub wartości klucza, lecz regularne kluczy.]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="ActivityCollection" FullName="System.Workflow.ComponentModel.ActivityCollection">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="549ca1bc23794ca2b21a61591a77f0bc70a4d5ef" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36448970" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class ActivityCollection : System.Collections.Generic.List&lt;System.Workflow.ComponentModel.Activity&gt;, System.Collections.Generic.ICollection&lt;System.Workflow.ComponentModel.Activity&gt;, System.Collections.Generic.IEnumerable&lt;System.Workflow.ComponentModel.Activity&gt;, System.Collections.Generic.IList&lt;System.Workflow.ComponentModel.Activity&gt;, System.Collections.IList" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ActivityCollection extends System.Collections.Generic.List`1&lt;class System.Workflow.ComponentModel.Activity&gt; implements class System.Collections.Generic.ICollection`1&lt;class System.Workflow.ComponentModel.Activity&gt;, class System.Collections.Generic.IEnumerable`1&lt;class System.Workflow.ComponentModel.Activity&gt;, class System.Collections.Generic.IList`1&lt;class System.Workflow.ComponentModel.Activity&gt;, class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList" />
  <TypeSignature Language="DocId" Value="T:System.Workflow.ComponentModel.ActivityCollection" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ActivityCollection&#xA;Inherits List(Of Activity)&#xA;Implements ICollection(Of Activity), IEnumerable(Of Activity), IList, IList(Of Activity)" />
  <TypeSignature Language="C++ CLI" Value="public ref class ActivityCollection sealed : System::Collections::Generic::List&lt;System::Workflow::ComponentModel::Activity ^&gt;, System::Collections::Generic::ICollection&lt;System::Workflow::ComponentModel::Activity ^&gt;, System::Collections::Generic::IEnumerable&lt;System::Workflow::ComponentModel::Activity ^&gt;, System::Collections::Generic::IList&lt;System::Workflow::ComponentModel::Activity ^&gt;, System::Collections::IList" />
  <TypeSignature Language="F#" Value="type ActivityCollection = class&#xA;    inherit List&lt;Activity&gt;&#xA;    interface IList&lt;Activity&gt;&#xA;    interface ICollection&lt;Activity&gt;&#xA;    interface seq&lt;Activity&gt;&#xA;    interface IEnumerable&#xA;    interface IList&#xA;    interface ICollection" />
  <AssemblyInfo>
    <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Collections.Generic.List&lt;System.Workflow.ComponentModel.Activity&gt;</BaseTypeName>
    <BaseTypeArguments>
      <BaseTypeArgument TypeParamName="!0">System.Workflow.ComponentModel.Activity</BaseTypeArgument>
    </BaseTypeArguments>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;System.Workflow.ComponentModel.Activity&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Workflow.ComponentModel.Activity&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IList&lt;System.Workflow.ComponentModel.Activity&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.Design.Serialization.DesignerSerializer(typeof(System.Workflow.ComponentModel.Serialization.ActivityCollectionMarkupSerializer), typeof(System.Workflow.ComponentModel.Serialization.WorkflowMarkupSerializer))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Obsolete("The System.Workflow.* types are deprecated.  Instead, please use the new types from System.Activities.*")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Modele silnie typizowaną <see cref="T:System.Collections.ICollection" /> typu <see cref="T:System.Workflow.ComponentModel.Activity" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  [!INCLUDE[DeprecatedContent](~/includes/deprecatedcontent-md.md)]  
  
 Ta klasa jest używana do reprezentowania listę działań podrzędnych dla <xref:System.Workflow.ComponentModel.CompositeActivity>.  
  
> [!NOTE]
>  Wywoływać tylko metody pochodną <xref:System.Collections.Generic.IList%601> i nie <xref:System.Collections.Generic.List%601>, takiej jak <xref:System.Workflow.ComponentModel.ActivityCollection.Add%2A> dodawać działania zamiast <xref:System.Collections.Generic.List%601.AddRange%2A>. Wywołanie metod pochodną <xref:System.Collections.Generic.List%601> będzie mieć nieoczekiwane skutki.  
  
   
  
## Examples  
 W poniższym przykładzie przedstawiono dostęp <xref:System.Workflow.ComponentModel.ActivityCollection> czyli element członkowski klasy działania złożonego zawierającego wszystkich działań podrzędnych. Ten przykładowy kod jest częścią przykład przy użyciu zestawu SDK Throw i w pliku ThrowWorkflow.cs. Aby uzyskać więcej informacji, zobacz [za pomocą działania ThrowActivity](http://msdn.microsoft.com/library/82bc0fef-d78a-4750-82b4-e4cb397a10f1).  
  
 [!code-csharp[WF_Samples#179](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets11.cs#179)]
 [!code-vb[WF_Samples#179](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets11.vb#179)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ActivityCollection (System.Workflow.ComponentModel.Activity owner);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Workflow.ComponentModel.Activity owner) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.ActivityCollection.#ctor(System.Workflow.ComponentModel.Activity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (owner As Activity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ActivityCollection(System::Workflow::ComponentModel::Activity ^ owner);" />
      <MemberSignature Language="F#" Value="new System.Workflow.ComponentModel.ActivityCollection : System.Workflow.ComponentModel.Activity -&gt; System.Workflow.ComponentModel.ActivityCollection" Usage="new System.Workflow.ComponentModel.ActivityCollection owner" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="owner" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="owner">
          <see cref="T:System.Workflow.ComponentModel.Activity" /> Wyznaczony jako będącej właścicielem tego wystąpienia.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Workflow.ComponentModel.ActivityCollection" /> klasy inicjowanie właściciela <see cref="T:System.Workflow.ComponentModel.Activity" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przykład  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="owner" /> to odwołanie o wartości null (<see langword="Nothing" /> w języku Visual Basic).</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="owner" /> nie jest elementem podrzędnym <see cref="T:System.Workflow.ComponentModel.Activity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (System.Workflow.ComponentModel.Activity item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Add(class System.Workflow.ComponentModel.Activity item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.ActivityCollection.Add(System.Workflow.ComponentModel.Activity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (item As Activity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Add(System::Workflow::ComponentModel::Activity ^ item);" />
      <MemberSignature Language="F#" Value="member this.Add : System.Workflow.ComponentModel.Activity -&gt; unit" Usage="activityCollection.Add item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="item">
          <see cref="T:System.Workflow.ComponentModel.Activity" /> Mają zostać dodane do <see cref="T:System.Collections.ICollection" />.</param>
        <summary>Dodaje <see cref="T:System.Workflow.ComponentModel.Activity" /> do <see cref="T:System.Collections.ICollection" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W poniższym przykładzie przedstawiono dostęp <xref:System.Workflow.ComponentModel.ActivityCollection> czyli element członkowski klasy działania złożonego zawierającego wszystkich działań podrzędnych. W tym przykładzie przedstawiono użycie <xref:System.Workflow.ComponentModel.ActivityCollection.Add%2A>. Ten przykładowy kod jest częścią próbki Throw zestawu SDK i w pliku ThrowWorkflow.cs. Aby uzyskać więcej informacji, zobacz [za pomocą działania ThrowActivity](http://msdn.microsoft.com/library/82bc0fef-d78a-4750-82b4-e4cb397a10f1).  
  
 [!code-csharp[WF_Samples#179](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets11.cs#179)]
 [!code-vb[WF_Samples#179](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets11.vb#179)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.ActivityCollection.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="activityCollection.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
        <InterfaceMember>M:System.Collections.IList.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa co <see cref="T:System.Workflow.ComponentModel.Activity" /> z <see cref="T:System.Collections.ICollection" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (System.Workflow.ComponentModel.Activity item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(class System.Workflow.ComponentModel.Activity item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.ActivityCollection.Contains(System.Workflow.ComponentModel.Activity)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (item As Activity) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::Workflow::ComponentModel::Activity ^ item);" />
      <MemberSignature Language="F#" Value="member this.Contains : System.Workflow.ComponentModel.Activity -&gt; bool" Usage="activityCollection.Contains item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="item">
          <see cref="T:System.Workflow.ComponentModel.Activity" /> Testowana pod kątem członkostwa.</param>
        <summary>Udostępnia testu dla członkostwa <see cref="T:System.Workflow.ComponentModel.Activity" /> w <see cref="T:System.Collections.ICollection" />.</summary>
        <returns>
          <see langword="true" /> Jeśli <see cref="T:System.Workflow.ComponentModel.Activity" /> należy <see cref="T:System.Collections.ICollection" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To <xref:System.Collections.ICollection> jest bezpieczne. Wyjątek czasu wykonywania jest uruchamiany, jeśli element nie jest typu <xref:System.Workflow.ComponentModel.Activity>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Workflow.ComponentModel.ActivityCollection.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Workflow.ComponentModel.ActivityCollection.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę elementów członkowskich <see cref="T:System.Collections.ICollection" />.</summary>
        <value>Liczba członków <see cref="T:System.Collections.ICollection" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerator&lt;System.Workflow.ComponentModel.Activity&gt; GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerator`1&lt;class System.Workflow.ComponentModel.Activity&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.ActivityCollection.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator(Of Activity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerator&lt;System::Workflow::ComponentModel::Activity ^&gt; ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;System.Workflow.ComponentModel.Activity&gt;" Usage="activityCollection.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Workflow.ComponentModel.Activity&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Implementuje interfejs wyliczenie <see cref="T:System.Collections.ICollection" />.</summary>
        <returns>Zwraca moduł wyliczający, który można wykonać iterację <see cref="T:System.Collections.ReadOnlyCollectionBase" /> wystąpienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Moduły wyliczające włączyć tylko odczytywanie danych w kolekcji. Za pomocą wyliczenia nie można zmodyfikować kolekcji źródłowej.  
  
 Aby rozpocząć, moduł wyliczający jest umieszczony przed pierwszym elementem w kolekcji. <xref:System.Collections.IEnumerator.Reset%2A> również wprowadzono moduł wyliczający wróć do tej pozycji. At to pozycja, wywoływania <xref:System.Collections.IEnumerator.Current%2A> zgłasza wyjątek. W związku z tym należy wywołać <xref:System.Collections.IEnumerator.MoveNext%2A> można poprawić modułu wyliczającego pierwszy element do kolekcji przed odczytywania wartości <xref:System.Collections.IEnumerator.Current%2A>.  
  
 <xref:System.Collections.IEnumerator.Current%2A> zwraca ten sam obiekt do momentu <xref:System.Collections.IEnumerator.MoveNext%2A> lub <xref:System.Collections.IEnumerator.Reset%2A> jest wywoływana. <xref:System.Collections.IEnumerator.MoveNext%2A> Ustawia <xref:System.Collections.IEnumerator.Current%2A> do następnego elementu.  
  
 Po zakończeniu kolekcji jest moduł wyliczający jest rozmieszczanych za ostatnim elementem w kolekcji i wywoływania <xref:System.Collections.IEnumerator.MoveNext%2A> zwraca `false`. Jeśli przez ostatnie wywołanie <xref:System.Collections.IEnumerator.MoveNext%2A> zwrócił `false`, wywoływania <xref:System.Collections.IEnumerator.Current%2A> zgłasza wyjątek.  
  
 Aby ustawić `Current` aby pierwszym elementem kolekcji ponownie, należy wywołać `Reset` następuje <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Moduł wyliczający zachowuje ważność tak długo, jak długo kolekcja pozostaje niezmieniona. Jeśli wprowadzono zmiany w kolekcji, takie jak dodawanie, modyfikowanie lub usuwanie elementów, moduł wyliczający jest nieodwracalnie nieważne, a następne wywołanie <xref:System.Collections.IEnumerator.MoveNext%2A> lub `Reset` zgłasza <xref:System.InvalidOperationException> . Jeśli kolekcja jest zmodyfikowany między <xref:System.Collections.IEnumerator.MoveNext%2A> i <xref:System.Collections.IEnumerator.Current%2A>, <xref:System.Collections.IEnumerator.Current%2A> zwróci element, który ma ustawioną, nawet wtedy, gdy moduł wyliczający jest już unieważnione.  
  
 Moduł wyliczający nie ma wyłącznego dostępu do kolekcji, w związku z tym wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość. Nawet jeśli kolekcja jest synchronizowane, inne wątki nadal można modyfikować kolekcji. Powoduje to, że moduł wyliczający zgłosić wyjątek. Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania albo rejestrować wyjątki wynikłe ze zmian wprowadzanych przez inne wątków.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (System.Workflow.ComponentModel.Activity item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(class System.Workflow.ComponentModel.Activity item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.ActivityCollection.IndexOf(System.Workflow.ComponentModel.Activity)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (item As Activity) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::Workflow::ComponentModel::Activity ^ item);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : System.Workflow.ComponentModel.Activity -&gt; int" Usage="activityCollection.IndexOf item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.IndexOf(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="item">Działanie, dla którego można uzyskać indeksu.</param>
        <summary>Pobiera indeks <see cref="T:System.Workflow.ComponentModel.Activity" /> w <see cref="T:System.Collections.ICollection" />.</summary>
        <returns>Indeks <see cref="T:System.Workflow.ComponentModel.Activity" /> w <see cref="T:System.Collections.ICollection" />. W przeciwnym razie -1 (Jeśli <see cref="T:System.Workflow.ComponentModel.Activity" /> nie znajduje się w <see cref="T:System.Collections.ICollection" />).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta kolekcja jest bezpieczne. Wyjątek czasu wykonywania zostanie wygenerowany, jeśli element nie jest typu <xref:System.Workflow.ComponentModel.Activity>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public void Insert (int index, System.Workflow.ComponentModel.Activity item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Insert(int32 index, class System.Workflow.ComponentModel.Activity item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.ActivityCollection.Insert(System.Int32,System.Workflow.ComponentModel.Activity)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Insert (index As Integer, item As Activity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Insert(int index, System::Workflow::ComponentModel::Activity ^ item);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * System.Workflow.ComponentModel.Activity -&gt; unit" Usage="activityCollection.Insert (index, item)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="index">Liczony od zera indeks kolekcji, w którym ma zostać wstawiony element.</param>
        <param name="item">
          <see cref="T:System.Workflow.ComponentModel.Activity" /> Ma zostać wstawiony do kolekcji.</param>
        <summary>Wstawia element pod indeksem <see cref="T:System.Collections.ICollection" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To <xref:System.Collections.ICollection> jest typu są bezpieczne. Wyjątek czasu wykonywania jest uruchamiany, jeśli element nie jest typu <xref:System.Workflow.ComponentModel.Activity>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Item">
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera element <see cref="T:System.Workflow.ComponentModel.Activity" /> w <see cref="T:System.Collections.ICollection" /> według nazwy lub indeksu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public System.Workflow.ComponentModel.Activity this[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Workflow.ComponentModel.Activity Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Workflow.ComponentModel.ActivityCollection.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Item(index As Integer) As Activity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Workflow::ComponentModel::Activity ^ default[int] { System::Workflow::ComponentModel::Activity ^ get(int index); void set(int index, System::Workflow::ComponentModel::Activity ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Item(int) : System.Workflow.ComponentModel.Activity with get, set" Usage="System.Workflow.ComponentModel.ActivityCollection.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IList`1.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Workflow.ComponentModel.Activity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Liczony od zera indeks w <see cref="T:System.Collections.ICollection" />.</param>
        <summary>Pobiera lub ustawia działanie w <see cref="T:System.Collections.ICollection" /> oparte na indeks.</summary>
        <value>Działania elementu członkowskiego <see cref="T:System.Collections.ICollection" />, którego indeks w <see cref="T:System.Collections.ICollection" /> została określona w wywołaniu.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> nie jest prawidłowym indeksem w <see cref="T:System.Collections.IList" />.</exception>
        <exception cref="T:System.NotSupportedException">Właściwość jest ustawiona i <see cref="T:System.Collections.IList" /> jest tylko do odczytu.</exception>
        <exception cref="T:System.Exception">Podjęto próbę ustawienia <see cref="T:System.Object" /> nie jest to <see cref="T:System.Workflow.ComponentModel.Activity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public System.Workflow.ComponentModel.Activity this[string key] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Workflow.ComponentModel.Activity Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Workflow.ComponentModel.ActivityCollection.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(key As String) As Activity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Workflow::ComponentModel::Activity ^ default[System::String ^] { System::Workflow::ComponentModel::Activity ^ get(System::String ^ key); };" />
      <MemberSignature Language="F#" Value="member this.Item(string) : System.Workflow.ComponentModel.Activity" Usage="System.Workflow.ComponentModel.ActivityCollection.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Workflow.ComponentModel.Activity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Unikatowy identyfikator dla działania w <see cref="T:System.Collections.ICollection" />.</param>
        <summary>Pobiera działania w <see cref="T:System.Collections.ICollection" /> oparte na ciąg, który jest unikatowy klucz.</summary>
        <value>Element członkowski <see cref="T:System.Workflow.ComponentModel.Activity" /> z <see cref="T:System.Collections.ICollection" />; klucz w <see cref="T:System.Collections.ICollection" /> którego została określona w wywołaniu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku nie <xref:System.Workflow.ComponentModel.Activity> w <xref:System.Collections.ICollection> z określonym kluczem, jest wyjątek.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ListChanged">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Workflow.ComponentModel.ActivityCollectionChangeEventArgs&gt; ListChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Workflow.ComponentModel.ActivityCollectionChangeEventArgs&gt; ListChanged" />
      <MemberSignature Language="DocId" Value="E:System.Workflow.ComponentModel.ActivityCollection.ListChanged" />
      <MemberSignature Language="VB.NET" Value="Public Event ListChanged As EventHandler(Of ActivityCollectionChangeEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Workflow::ComponentModel::ActivityCollectionChangeEventArgs ^&gt; ^ ListChanged;" />
      <MemberSignature Language="F#" Value="member this.ListChanged : EventHandler&lt;System.Workflow.ComponentModel.ActivityCollectionChangeEventArgs&gt; " Usage="member this.ListChanged : System.EventHandler&lt;System.Workflow.ComponentModel.ActivityCollectionChangeEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Workflow.ComponentModel.ActivityCollectionChangeEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wywoływane po każdej zmianie zawartości to <see cref="T:System.Collections.ICollection" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W tym kontekście Dodawanie lub usuwanie elementów członkowskich wywołuje zdarzenie. Modyfikowanie element członkowski nie wygenerował tego zdarzenia.  
  
 Po utworzeniu <xref:System.Workflow.ComponentModel.ActivityCollection> delegata, należy określić metodę, która obsłuży zdarzenie. Aby skojarzyć zdarzenie z obsługi zdarzenia, należy dodać wystąpienia delegata zdarzenia. Program obsługi zdarzeń jest wywoływany przy każdym wystąpieniu zdarzenia, o ile nie usunięto delegata. Aby uzyskać więcej informacji na temat delegatów obsługi zdarzeń, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (System.Workflow.ComponentModel.Activity item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Remove(class System.Workflow.ComponentModel.Activity item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.ActivityCollection.Remove(System.Workflow.ComponentModel.Activity)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (item As Activity) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Remove(System::Workflow::ComponentModel::Activity ^ item);" />
      <MemberSignature Language="F#" Value="member this.Remove : System.Workflow.ComponentModel.Activity -&gt; bool" Usage="activityCollection.Remove item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="item">Działanie, aby usunąć z <see cref="T:System.Collections.ICollection" />.</param>
        <summary>Usuwa określone w wywołaniu z działania <see cref="T:System.Collections.ICollection" />.</summary>
        <returns>
          <see langword="true" /> Jeśli operacja zakończyła się pomyślnie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To <xref:System.Collections.ICollection> jest typu są bezpieczne. Wyjątek czasu wykonywania jest uruchamiany, jeśli element nie jest typu <xref:System.Workflow.ComponentModel.Activity>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public void RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.ActivityCollection.RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAt (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveAt(int index);" />
      <MemberSignature Language="F#" Value="abstract member RemoveAt : int -&gt; unit&#xA;override this.RemoveAt : int -&gt; unit" Usage="activityCollection.RemoveAt index" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)</InterfaceMember>
        <InterfaceMember>M:System.Collections.IList.RemoveAt(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Pozycja w liczony od zera indeks, aby usunąć działania z kolekcji.</param>
        <summary>Usuwa <see cref="T:System.Workflow.ComponentModel.Activity" /> w <see cref="T:System.Collections.ICollection" /> pod określonym <paramref name="index" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyjątek czasu wykonywania występuje, gdy indeks jest nieprawidłowy (poza zakresem).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Workflow.ComponentModel.Activity&gt;.Add">
      <MemberSignature Language="C#" Value="void ICollection&lt;Activity&gt;.Add (System.Workflow.ComponentModel.Activity item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;System.Workflow.ComponentModel.Activity&gt;.Add(class System.Workflow.ComponentModel.Activity item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.ActivityCollection.System#Collections#Generic#ICollection&lt;System#Workflow#ComponentModel#Activity&gt;#Add(System.Workflow.ComponentModel.Activity)" />
      <MemberSignature Language="VB.NET" Value="Sub Add (item As Activity) Implements ICollection(Of Activity).Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.ICollection&lt;System.Workflow.ComponentModel.Activity&gt;.Add(System::Workflow::ComponentModel::Activity ^ item) = System::Collections::Generic::ICollection&lt;System::Workflow::ComponentModel::Activity ^&gt;::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="item">
          <see cref="T:System.Object" /> Do dodania do <see cref="T:System.Collections.IList" />.</param>
        <summary>Dodaje obiekt, aby <see cref="T:System.Collections.IList" /> na końcu <see cref="T:System.Collections.IList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zgłasza wyjątek z komunikatem o błędzie "Error_InvalidListItem", jeśli <xref:System.Object> nie jest typu <xref:System.Workflow.ComponentModel.Activity>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Workflow.ComponentModel.Activity&gt;.Clear">
      <MemberSignature Language="C#" Value="void ICollection&lt;Activity&gt;.Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;System.Workflow.ComponentModel.Activity&gt;.Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.ActivityCollection.System#Collections#Generic#ICollection&lt;System#Workflow#ComponentModel#Activity&gt;#Clear" />
      <MemberSignature Language="VB.NET" Value="Sub Clear () Implements ICollection(Of Activity).Clear" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.ICollection&lt;System.Workflow.ComponentModel.Activity&gt;.Clear() = System::Collections::Generic::ICollection&lt;System::Workflow::ComponentModel::Activity ^&gt;::Clear;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Czyści wszystkie działania z <see cref="T:System.Collections.IList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.CollectionBase.Count%2A> Właściwości wynosi zero, po zakończeniu tej operacji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Workflow.ComponentModel.Activity&gt;.Contains">
      <MemberSignature Language="C#" Value="bool ICollection&lt;Activity&gt;.Contains (System.Workflow.ComponentModel.Activity item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.Generic.ICollection&lt;System.Workflow.ComponentModel.Activity&gt;.Contains(class System.Workflow.ComponentModel.Activity item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.ActivityCollection.System#Collections#Generic#ICollection&lt;System#Workflow#ComponentModel#Activity&gt;#Contains(System.Workflow.ComponentModel.Activity)" />
      <MemberSignature Language="VB.NET" Value="Function Contains (item As Activity) As Boolean Implements ICollection(Of Activity).Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.Generic.ICollection&lt;System.Workflow.ComponentModel.Activity&gt;.Contains(System::Workflow::ComponentModel::Activity ^ item) = System::Collections::Generic::ICollection&lt;System::Workflow::ComponentModel::Activity ^&gt;::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="item">
          <see cref="T:System.Object" /> Do zlokalizowania w <see cref="T:System.Collections.IList" />.</param>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Object" /> jest członkiem kolekcji.</summary>
        <returns>
          <see langword="true" /> Jeśli wartość znajduje się w kolekcji; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zgłasza wyjątek z komunikatem o błędzie "Error_InvalidListItem", jeśli <xref:System.Object> nie jest typu <xref:System.Workflow.ComponentModel.Activity>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Workflow.ComponentModel.Activity&gt;.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection&lt;Activity&gt;.CopyTo (System.Workflow.ComponentModel.Activity[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;System.Workflow.ComponentModel.Activity&gt;.CopyTo(class System.Workflow.ComponentModel.Activity[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.ActivityCollection.System#Collections#Generic#ICollection&lt;System#Workflow#ComponentModel#Activity&gt;#CopyTo(System.Workflow.ComponentModel.Activity[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Sub CopyTo (array As Activity(), arrayIndex As Integer) Implements ICollection(Of Activity).CopyTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.ICollection&lt;System.Workflow.ComponentModel.Activity&gt;.CopyTo(cli::array &lt;System::Workflow::ComponentModel::Activity ^&gt; ^ array, int arrayIndex) = System::Collections::Generic::ICollection&lt;System::Workflow::ComponentModel::Activity ^&gt;::CopyTo;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Workflow.ComponentModel.Activity[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">
          <see cref="T:System.Array" /> Co jest obiekt docelowy operacji kopiowania.</param>
        <param name="arrayIndex">Liczony od zera indeks w <see cref="T:System.Collections.ICollection" /> gdzie rozpoczyna się kopiowanie.</param>
        <summary>Kopiuje elementy <see cref="T:System.Collections.ICollection" /> do <see cref="T:System.Array" />, rozpoczynając od określonego <see cref="T:System.Array" /> indeksu.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> to odwołanie o wartości null (<see langword="Nothing" /> w języku Visual Basic).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza od zera.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> jest wielowymiarowy.  
  
 <paramref name="index" /> jest równa lub większa niż długość <paramref name="array" />.  Liczba elementów w źródle <see cref="T:System.Collections.ICollection" /> jest większa niż dostępne miejsce od <paramref name="index" /> do końca tablicy docelowej.</exception>
        <exception cref="T:System.InvalidCastException">Typ <see cref="T:System.Workflow.ComponentModel.Activity" /> nie można automatycznie rzutować na typ docelowy <paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Workflow.ComponentModel.Activity&gt;.Count">
      <MemberSignature Language="C#" Value="int System.Collections.Generic.ICollection&lt;System.Workflow.ComponentModel.Activity&gt;.Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 System.Collections.Generic.ICollection&lt;System.Workflow.ComponentModel.Activity&gt;.Count" />
      <MemberSignature Language="DocId" Value="P:System.Workflow.ComponentModel.ActivityCollection.System#Collections#Generic#ICollection&lt;System#Workflow#ComponentModel#Activity&gt;#Count" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Count As Integer Implements ICollection(Of Activity).Count" />
      <MemberSignature Language="C++ CLI" Value="property int System.Collections.Generic.ICollection&lt;System.Workflow.ComponentModel.Activity&gt;.Count { int get(); };" />
      <MemberSignature Language="F#" Usage="System.Workflow.ComponentModel.ActivityCollection.System.Collections.Generic.ICollection&lt;System.Workflow.ComponentModel.Activity&gt;.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę elementów zawartych w <see cref="T:System.Collections.Generic.ICollection`1" />.</summary>
        <value>Liczba elementów zawartych w <see cref="T:System.Collections.Generic.ICollection`1" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Workflow.ComponentModel.Activity&gt;.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.Generic.ICollection&lt;System.Workflow.ComponentModel.Activity&gt;.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.Generic.ICollection&lt;System.Workflow.ComponentModel.Activity&gt;.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Workflow.ComponentModel.ActivityCollection.System#Collections#Generic#ICollection&lt;System#Workflow#ComponentModel#Activity&gt;#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements ICollection(Of Activity).IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.Generic.ICollection&lt;System.Workflow.ComponentModel.Activity&gt;.IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Workflow.ComponentModel.ActivityCollection.System.Collections.Generic.ICollection&lt;System.Workflow.ComponentModel.Activity&gt;.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Collections.IList" /> jest tylko do odczytu.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Collections.IList" /> jest tylko do odczytu; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W kolekcji tylko do odczytu po jej utworzeniu nie można dodawać, usuwać ani modyfikować elementów.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;System.Workflow.ComponentModel.Activity&gt;.Remove">
      <MemberSignature Language="C#" Value="bool ICollection&lt;Activity&gt;.Remove (System.Workflow.ComponentModel.Activity item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.Generic.ICollection&lt;System.Workflow.ComponentModel.Activity&gt;.Remove(class System.Workflow.ComponentModel.Activity item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.ActivityCollection.System#Collections#Generic#ICollection&lt;System#Workflow#ComponentModel#Activity&gt;#Remove(System.Workflow.ComponentModel.Activity)" />
      <MemberSignature Language="VB.NET" Value="Function Remove (item As Activity) As Boolean Implements ICollection(Of Activity).Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.Generic.ICollection&lt;System.Workflow.ComponentModel.Activity&gt;.Remove(System::Workflow::ComponentModel::Activity ^ item) = System::Collections::Generic::ICollection&lt;System::Workflow::ComponentModel::Activity ^&gt;::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="item">Obiekt do usunięcia z <see cref="T:System.Collections.Generic.ICollection`1" />.</param>
        <summary>Usuwa pierwsze wystąpienie określonego obiektu z <see cref="T:System.Collections.Generic.ICollection`1" />.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="item" /> został pomyślnie usunięty ze <see cref="T:System.Collections.Generic.ICollection`1" />; w przeciwnym razie <see langword="false" />. Ta metoda zwraca również wartość <see langword="false" /> Jeśli <paramref name="item" /> nie został znaleziony w oryginalnej <see cref="T:System.Collections.Generic.ICollection`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Implementacje może różnić się w sposób określają równości obiektów; na przykład <xref:System.Collections.Generic.List%601> używa <xref:System.Collections.Generic.Comparer%601.Default%2A>, podczas gdy <xref:System.Collections.Generic.Dictionary%602> umożliwia użytkownikowi określenie <xref:System.Collections.Generic.IComparer%601> wdrożenia do użycia na potrzeby porównywania kluczy.  
  
 W kolekcjach elementów sąsiadujących, takich jak listy, elementy umieszczone po usuniętym elemencie przesuwają się w górę, aby zająć zwolnione miejsce. Jeśli kolekcja jest indeksowana, indeksy przeniesionych elementów również są aktualizowane. To zachowanie nie dotyczy kolekcji, w których elementy są pod względem koncepcyjnym pogrupowane w przedziały, np. tablic skrótów.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <see langword="ICollection" /> Jest tylko do odczytu.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Workflow.ComponentModel.Activity&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;System.Workflow.ComponentModel.Activity&gt; IEnumerable&lt;Activity&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;class System.Workflow.ComponentModel.Activity&gt; System.Collections.Generic.IEnumerable&lt;System.Workflow.ComponentModel.Activity&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.ActivityCollection.System#Collections#Generic#IEnumerable&lt;System#Workflow#ComponentModel#Activity&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of Activity) Implements IEnumerable(Of Activity).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;System::Workflow::ComponentModel::Activity ^&gt; ^ System.Collections.Generic.IEnumerable&lt;System.Workflow.ComponentModel.Activity&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;System::Workflow::ComponentModel::Activity ^&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Workflow.ComponentModel.Activity&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca moduł wyliczający, który dokonuje iteracji w kolekcji.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerator`1" /> Który może służyć do iterowania po kolekcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `foreach` Instrukcji języka C# (`for each` w języku C++ `For Each` w języku Visual Basic) ukrywa złożoność wyliczenia. W związku z tym przy użyciu `foreach` jest zalecane, zamiast bezpośrednie manipulowanie modułu wyliczającego.  
  
 Moduły wyliczające mogą służyć do odczytu danych w kolekcji, ale nie można za ich pomocą modyfikować kolekcji źródłowej.  
  
 Początkowo moduł wyliczający jest umieszczony przed pierwszym elementem w kolekcji. W tym miejscu <xref:System.Collections.Generic.IEnumerator%601.Current%2A> jest niezdefiniowana. W związku z tym należy wywołać <xref:System.Collections.IEnumerator.MoveNext%2A> można poprawić modułu wyliczającego pierwszy element do kolekcji przed odczytywania wartości <xref:System.Collections.Generic.IEnumerator%601.Current%2A>.  
  
 <xref:System.Collections.Generic.IEnumerator%601.Current%2A> Zwraca tego samego obiektu, dopóki nie <xref:System.Collections.IEnumerator.MoveNext%2A> jest wywoływana. <xref:System.Collections.IEnumerator.MoveNext%2A> Ustawia <xref:System.Collections.Generic.IEnumerator%601.Current%2A> do następnego elementu.  
  
 Jeśli <xref:System.Collections.IEnumerator.MoveNext%2A> przekazuje końcem kolekcji, moduł wyliczający jest umieszczony za ostatnim elementem w kolekcji i <xref:System.Collections.IEnumerator.MoveNext%2A> zwraca wartość false. Gdy moduł wyliczający jest w tym miejscu kolejnych wywołań <xref:System.Collections.IEnumerator.MoveNext%2A> również zwróci wartość false. Jeśli przez ostatnie wywołanie <xref:System.Collections.IEnumerator.MoveNext%2A> zwrócił wartość false, <xref:System.Collections.Generic.IEnumerator%601.Current%2A> jest niezdefiniowana. Nie można ustawić <xref:System.Collections.Generic.IEnumerator%601.Current%2A> do pierwszego elementu w kolekcji; należy utworzyć nowe wystąpienie modułu wyliczającego zamiast tego.  
  
 Moduł wyliczający zachowuje ważność tak długo, jak długo kolekcja pozostaje niezmieniona. Jeśli w kolekcji zostaną wprowadzone zmiany, takie jak dodanie, zmodyfikowanie czy usunięcie elementów, moduł wyliczający jest nieodwracalnie unieważniany, a jego zachowanie staje się niezdefiniowane.  
  
 Moduł wyliczający nie ma wyłącznego dostępu do kolekcji, w związku z tym wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość. Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania. Aby zezwolić wielu wątkom na dostęp do kolekcji w celu odczytu i zapisu danych, należy zaimplementować własny mechanizm synchronizacji.  
  
 Domyślne implementacje kolekcji w <xref:System.Collections.Generic> przestrzeni nazw nie są zsynchronizowane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IList&lt;System.Workflow.ComponentModel.Activity&gt;.IndexOf">
      <MemberSignature Language="C#" Value="int IList&lt;Activity&gt;.IndexOf (System.Workflow.ComponentModel.Activity item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.Generic.IList&lt;System.Workflow.ComponentModel.Activity&gt;.IndexOf(class System.Workflow.ComponentModel.Activity item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.ActivityCollection.System#Collections#Generic#IList&lt;System#Workflow#ComponentModel#Activity&gt;#IndexOf(System.Workflow.ComponentModel.Activity)" />
      <MemberSignature Language="VB.NET" Value="Function IndexOf (item As Activity) As Integer Implements IList(Of Activity).IndexOf" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.Generic.IList&lt;System.Workflow.ComponentModel.Activity&gt;.IndexOf(System::Workflow::ComponentModel::Activity ^ item) = System::Collections::Generic::IList&lt;System::Workflow::ComponentModel::Activity ^&gt;::IndexOf;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.IndexOf(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="item">Obiekt do zlokalizowania w <see cref="T:System.Collections.IList" />.</param>
        <summary>Określa indeks konkretny element w <see cref="T:System.Collections.IList" />.</summary>
        <returns>Indeks <paramref name="item" /> jeśli je znaleziono na liście; w przeciwnym razie wartość -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli obiekt powtarza się wielokrotnie na liście `IndexOf` metoda zawsze zwraca pierwsze wystąpienie znaleziono.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IList&lt;System.Workflow.ComponentModel.Activity&gt;.Insert">
      <MemberSignature Language="C#" Value="void IList&lt;Activity&gt;.Insert (int index, System.Workflow.ComponentModel.Activity item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.IList&lt;System.Workflow.ComponentModel.Activity&gt;.Insert(int32 index, class System.Workflow.ComponentModel.Activity item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.ActivityCollection.System#Collections#Generic#IList&lt;System#Workflow#ComponentModel#Activity&gt;#Insert(System.Int32,System.Workflow.ComponentModel.Activity)" />
      <MemberSignature Language="VB.NET" Value="Sub Insert (index As Integer, item As Activity) Implements IList(Of Activity).Insert" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.IList&lt;System.Workflow.ComponentModel.Activity&gt;.Insert(int index, System::Workflow::ComponentModel::Activity ^ item) = System::Collections::Generic::IList&lt;System::Workflow::ComponentModel::Activity ^&gt;::Insert;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="index">Liczony od zera pozycja wstawiania.</param>
        <param name="item">Obiekt do wstawienia. Musi być typu <see cref="T:System.Workflow.ComponentModel.Activity" />.</param>
        <summary>Wstawia <see cref="T:System.Object" /> do <see cref="T:System.Collections.IList" /> w określonym indeksie liczony od zera.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Object> nie można rzutować na <xref:System.Workflow.ComponentModel.Activity>, niestandardowego <xref:System.Exception> jest wywoływane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IList&lt;System.Workflow.ComponentModel.Activity&gt;.Item">
      <MemberSignature Language="C#" Value="System.Workflow.ComponentModel.Activity System.Collections.Generic.IList&lt;System.Workflow.ComponentModel.Activity&gt;.Item[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Workflow.ComponentModel.Activity System.Collections.Generic.IList&lt;System.Workflow.ComponentModel.Activity&gt;.Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Workflow.ComponentModel.ActivityCollection.System#Collections#Generic#IList&lt;System#Workflow#ComponentModel#Activity&gt;#Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" Property Item(index As Integer) As Activity Implements IList(Of Activity).Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Workflow::ComponentModel::Activity ^ System.Collections.Generic.IList&lt;System.Workflow.ComponentModel.Activity&gt;.Item[int] { System::Workflow::ComponentModel::Activity ^ get(int index); void set(int index, System::Workflow::ComponentModel::Activity ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Workflow.ComponentModel.ActivityCollection.System.Collections.Generic.IList&lt;System.Workflow.ComponentModel.Activity&gt;.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.IList`1.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Workflow.ComponentModel.Activity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Liczony od zera indeks elementu, który ma zostać pobrany lub skonfigurowany.</param>
        <summary>Pobieranie lub konfigurowanie elementów pod określonym indeksem.</summary>
        <value>
          <see cref="T:System.Object" /> Pod określonym indeksem.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość umożliwia dostęp do określonego elementu w kolekcji przy użyciu następującej składni: myCollection [Indeks].  
  
 Używa języka C# `this` — słowo kluczowe, aby zdefiniować indeksatory zamiast wykonania `Item` właściwości. Implementuje Visual Basic `Item` jako domyślna właściwość, która zapewnia te same funkcje indeksowania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> nie jest prawidłowym indeksem w <see cref="T:System.Collections.IList" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <see langword="ICollection" /> Jest tylko do odczytu.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IList&lt;System.Workflow.ComponentModel.Activity&gt;.RemoveAt">
      <MemberSignature Language="C#" Value="void IList&lt;Activity&gt;.RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.IList&lt;System.Workflow.ComponentModel.Activity&gt;.RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.ActivityCollection.System#Collections#Generic#IList&lt;System#Workflow#ComponentModel#Activity&gt;#RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Sub RemoveAt (index As Integer) Implements IList(Of Activity).RemoveAt" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.IList&lt;System.Workflow.ComponentModel.Activity&gt;.RemoveAt(int index) = System::Collections::Generic::IList&lt;System::Workflow::ComponentModel::Activity ^&gt;::RemoveAt;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Liczony od zera indeks elementu, który ma zostać usunięty.</param>
        <summary>Usuwa <see cref="T:System.Collections.IList" /> element pod określonym indeksem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W kolekcjach elementów sąsiadujących, takich jak listy, elementy umieszczone po usuniętym elemencie przesuwają się w górę, aby zająć zwolnione miejsce. Jeśli kolekcja jest indeksowana, indeksy przeniesionych elementów również są aktualizowane. To zachowanie nie dotyczy kolekcji, w których elementy są pod względem koncepcyjnym pogrupowane w przedziały, np. tablic skrótów.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> nie jest prawidłowym indeksem w <see cref="T:System.Collections.IList" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <see langword="ICollection" /> Jest tylko do odczytu.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.ActivityCollection.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.ICollection.CopyTo(Array ^ array, int index) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">
          <see cref="T:System.Array" /> Co jest obiekt docelowy operacji kopiowania.</param>
        <param name="index">Liczony od zera indeks w <see cref="T:System.Collections.ICollection" /> gdzie rozpoczyna się kopiowanie.</param>
        <summary>Kopiuje elementy <see cref="T:System.Collections.ICollection" /> do <see cref="T:System.Array" />, rozpoczynając od określonego <see cref="T:System.Array" /> indeksu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Workflow.ComponentModel.ActivityCollection.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.ICollection.IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Workflow.ComponentModel.ActivityCollection.System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy dostęp do <see cref="T:System.Collections.Generic.ICollection`1" /> jest synchronizowane, czyli wątkowo.</summary>
        <value>
          <see langword="true" /> Jeśli dostęp do <see cref="T:System.Collections.Generic.ICollection`1" /> jest synchronizowane, to znaczy wątkowo; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.ICollection.SyncRoot%2A> Zwraca obiekt, który może służyć do synchronizujący dostęp do <xref:System.Collections.Generic.ICollection%601>.  
  
 Większość kolekcji klas w <xref:System.Collections?displayProperty=nameWithType> przestrzeń nazw również implementować `Synchronized` metodę, która udostępnia otokę zsynchronizowane odpowiednia kolekcja.  
  
 Wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość. Nawet gdy kolekcja jest synchronizowana, inne wątki nadal mogą ją modyfikować. Powoduje to zgłaszanie wyjątku przez moduł wyliczający. Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania albo rejestrować wyjątki wynikłe ze zmian wprowadzanych przez inne wątków.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Workflow.ComponentModel.ActivityCollection.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.ICollection.SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Workflow.ComponentModel.ActivityCollection.System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera obiekt, który może służyć do synchronizujący dostęp do <see cref="T:System.Collections.Generic.ICollection`1" />.</summary>
        <value>Obiekt, który może służyć do synchronizujący dostęp do <see cref="T:System.Collections.Generic.ICollection`1" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dla kolekcji, w których Magazyn nie jest publicznie dostępna oczekiwano implementacja jest aby powrócić do bieżącego wystąpienia. Należy pamiętać, że wskaźnik do bieżącego wystąpienia nie może być wystarczający do kolekcji, które otaczają innych kolekcji; te powinny zwrócić odpowiednia Kolekcja <xref:System.Collections.ICollection.SyncRoot%2A> właściwości.  
  
 Większość kolekcji klas w <xref:System.Collections?displayProperty=nameWithType> przestrzeń nazw również implementować `Synchronized` metodę, która udostępnia otokę zsynchronizowane odpowiednia kolekcja. Jednak klasy pochodne zapewniają własne zsynchronizowanej wersji przy użyciu kolekcji <xref:System.Workflow.ComponentModel.ActivityCollection.System%23Collections%23ICollection%23SyncRoot> właściwości. Synchronizowanie kodu musi wykonywać operacje <xref:System.Workflow.ComponentModel.ActivityCollection.System%23Collections%23ICollection%23SyncRoot> właściwości kolekcji, a nie bezpośrednio w kolekcji. Gwarantuje to prawidłowe funkcjonowanie kolekcji, które są uzyskiwane z innych obiektów. W szczególności przechowuje prawidłowego synchronizacji z innych wątków, które mogą być jednocześnie modyfikowanie wystąpienie kolekcji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.ActivityCollection.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.Collections.IEnumerator" /> który iteruje po odpowiadającego <see cref="T:System.Collections.IList" />.</summary>
        <returns>
          <see cref="T:System.Collections.IEnumerator" /> Który może służyć do iterowania po kolekcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.IEnumerator> Tylko umożliwia odczytywanie danych w kolekcji. Nie można użyć <xref:System.Collections.IEnumerator> można zmodyfikować kolekcji źródłowej.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Add">
      <MemberSignature Language="C#" Value="int IList.Add (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.Add(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.ActivityCollection.System#Collections#IList#Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Add (value As Object) As Integer Implements IList.Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.Add(System::Object ^ value) = System::Collections::IList::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Add(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">
          <see cref="T:System.Object" /> Do dodania do <see cref="T:System.Collections.IList" />.</param>
        <summary>Dodaje obiekt, aby <see cref="T:System.Collections.IList" /> na końcu <see cref="T:System.Collections.IList" />.</summary>
        <returns>Zwraca <see cref="T:System.Int32" />.  Liczony od zera indeks <see cref="T:System.Object" /> który został dodany.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Clear">
      <MemberSignature Language="C#" Value="void IList.Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.ActivityCollection.System#Collections#IList#Clear" />
      <MemberSignature Language="VB.NET" Value="Sub Clear () Implements IList.Clear" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Clear() = System::Collections::IList::Clear;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa wszystkie <see cref="T:System.Workflow.ComponentModel.Activity" /> z <see cref="T:System.Collections.ICollection" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Contains">
      <MemberSignature Language="C#" Value="bool IList.Contains (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IList.Contains(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.ActivityCollection.System#Collections#IList#Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Contains (value As Object) As Boolean Implements IList.Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IList.Contains(System::Object ^ value) = System::Collections::IList::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">
          <see cref="T:System.Object" /> Do zlokalizowania w <see cref="T:System.Collections.IList" />.</param>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Object" /> jest członkiem kolekcji.</summary>
        <returns>Zwraca <see cref="T:System.Boolean" /><see langword="true" /> Jeśli <paramref name="value" /> znajduje się w kolekcji; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IndexOf">
      <MemberSignature Language="C#" Value="int IList.IndexOf (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.IndexOf(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.ActivityCollection.System#Collections#IList#IndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function IndexOf (value As Object) As Integer Implements IList.IndexOf" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.IndexOf(System::Object ^ value) = System::Collections::IList::IndexOf;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.IndexOf(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">
          <see cref="T:System.Object" /> Do indeksowania.</param>
        <summary>Pobiera liczony od zera indeks <see cref="T:System.Object" /> w źródłowej kolekcji działań.</summary>
        <returns>Liczony od zera indeks <paramref name="value" /> w źródłowej kolekcji działania lub -1, jeśli nie można odnaleźć w kolekcji.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> Nie jest typu <see cref="T:System.Workflow.ComponentModel.Activity" /> i obiekt wyjątku zawiera komunikat o błędzie "Error_InvalidListItem".</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Insert">
      <MemberSignature Language="C#" Value="void IList.Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Insert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.ActivityCollection.System#Collections#IList#Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Insert (index As Integer, value As Object) Implements IList.Insert" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Insert(int index, System::Object ^ value) = System::Collections::IList::Insert;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Insert(System.Int32,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">Liczony od zera pozycja wstawiania.</param>
        <param name="value">Obiekt do wstawienia. Musi być typu <see cref="T:System.Workflow.ComponentModel.Activity" />.</param>
        <summary>Wstawia <see cref="T:System.Object" /> do <see cref="T:System.Collections.IList" /> w określonym indeksie liczony od zera.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Workflow.ComponentModel.ActivityCollection.System#Collections#IList#IsFixedSize" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFixedSize As Boolean Implements IList.IsFixedSize" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.IList.IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Workflow.ComponentModel.ActivityCollection.System.Collections.IList.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Collections.IList" /> ma stały rozmiar.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Collections.IList" /> ma ustalony rozmiar; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W kolekcji o stałym rozmiarze po jej utworzeniu nie można dodawać ani usuwać elementów, jednak można modyfikować istniejące elementy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Workflow.ComponentModel.ActivityCollection.System#Collections#IList#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements IList.IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.IList.IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Workflow.ComponentModel.ActivityCollection.System.Collections.IList.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Collections.Generic.ICollection`1" /> jest tylko do odczytu.</summary>
        <value>Zwraca <see cref="T:System.Boolean" /><see langword="true" /> Jeśli <see cref="T:System.Collections.Generic.ICollection`1" /> jest tylko do odczytu; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IList.Item[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IList.Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Workflow.ComponentModel.ActivityCollection.System#Collections#IList#Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" Property Item(index As Integer) As Object Implements IList.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.IList.Item[int] { System::Object ^ get(int index); void set(int index, System::Object ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Workflow.ComponentModel.ActivityCollection.System.Collections.IList.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Liczony od zera indeks w <see cref="T:System.Collections.ICollection" />.</param>
        <summary>Pobiera lub ustawia działanie w <see cref="T:System.Collections.ICollection" /> oparte na indeks.</summary>
        <value>Zwraca <see cref="T:System.Object" />, elementu członkowskiego działania <see cref="T:System.Collections.ICollection" />, którego indeks w <see cref="T:System.Collections.ICollection" /> została określona w wywołaniu.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Remove">
      <MemberSignature Language="C#" Value="void IList.Remove (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Remove(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.ComponentModel.ActivityCollection.System#Collections#IList#Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Remove (value As Object) Implements IList.Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Remove(System::Object ^ value) = System::Collections::IList::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.ComponentModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">
          <see cref="T:System.Object" /> Do usunięcia z <see cref="T:System.Collections.IList" />.</param>
        <summary>Usuwa pierwsze wystąpienie określonego obiektu z <see cref="T:System.Collections.IList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Elementy, które należy wykonać usunięty element Przenieś w górę zajmować vacated miejscu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Collections.IList" /> Jest tylko do odczytu.  
  
 <see cref="T:System.Collections.IList" /> ma stały rozmiar.</exception>
      </Docs>
    </Member>
  </Members>
</Type>